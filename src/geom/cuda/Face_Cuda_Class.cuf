! Face_Cuda_Class.f90
! 
! Copyright 2017 Joseph Schoonover <joe@fluidnumerics.consulting>, Fluid Numerics LLC
! All rights reserved.
!
! //////////////////////////////////////////////////////////////////////////////////////////////// !

MODULE Face_Cuda_Class

! src/common/
USE ModelPrecision
! src/geom
USE Face_Class

IMPLICIT NONE

   TYPE Face_Cuda
      INTEGER, DEVICE, ALLOCATABLE :: faceID(:)            ! The Face ID
      INTEGER, DEVICE, ALLOCATABLE :: boundaryID(:)        ! If the Face_Cuda is part of the mesh boundary, the Face_Cuda gets assigned a boundary Face_Cuda ID
      INTEGER, DEVICE, ALLOCATABLE :: nodeIDs(:,:)      ! Node IDs which start and terminate this Face_Cuda
      INTEGER, DEVICE, ALLOCATABLE :: elementIDs(:,:)   ! Neighboring elements IDs across the Face_Cuda
      INTEGER, DEVICE, ALLOCATABLE :: elementSides(:,:) ! Local side IDs for the neighboring elements
      INTEGER, DEVICE, ALLOCATABLE :: iMap(:,:,:)      ! Loop start and increment for the secondary element side (1st computational direction)
      INTEGER, DEVICE, ALLOCATABLE :: jMap(:,:,:)      ! Loop start and increment for the secondary element side (2nd computational direction)

      CONTAINS
      
      PROCEDURE :: Build        => Build_Face_Cuda
      PROCEDURE :: Trash        => Trash_Face_Cuda
      PROCEDURE :: UpdateDevice => UpdateDevice_Face_Cuda
      
   END TYPE Face_Cuda
   
   INTEGER, CONSTANT :: nFaces_dev

 CONTAINS
!
!
!==================================================================================================!
!------------------------------- Manual Constructors/Destructors ----------------------------------!
!==================================================================================================!
!
!
 ATTRIBUTES(Host) SUBROUTINE Build_Face_Cuda( myFace, N, nFaces )

   IMPLICIT NONE
   CLASS( Face_Cuda ), INTENT(out) :: myFace
   INTEGER, INTENT(in)             :: N, nFaces

      ALLOCATE( myFace % faceID(1:nFaces), &
                myFace % boundaryID(1:nFaces), &
                myFace % nodeIDs(1:4,1:nFaces), &
                myFace % elementIDs(1:2,1:nFaces), &
                myFace % elementSides(1:2,1:nFaces), &
                myFace % iMap(0:N,0:N,1:nFaces), &
                myFace % jMap(0:N,0:N,1:nFaces) )
                
      nFaces_dev = nFaces
      
 END SUBROUTINE Build_Face_Cuda
!
 ATTRIBUTES(Host) SUBROUTINE Trash_Face_Cuda( myFace )
 
   IMPLICIT NONE
   CLASS( Face_Cuda ), INTENT(inout) :: myFace
   
      DEALLOCATE( myFace % faceID, &
                  myFace % boundaryID, &
                  myFace % nodeIDs, &
                  myFace % elementIDs, &
                  myFace % elementSides, &
                  myFace % iMap, &
                  myFace % jMap )
   
 END SUBROUTINE Trash_Face_Cuda
!
 ATTRIBUTES(Host) SUBROUTINE UpdateDevice_Face_Cuda( myFace, cpuFaceArray, N, nFaces )
 
   IMPLICIT NONE
   CLASS( Face_Cuda ), INTENT(inout) :: myFace
   INTEGER, INTENT(in)               :: N, nFaces
   TYPE( Face ), INTENT(in)          :: cpuFaceArray(1:nFaces)
   ! Local
   INTEGER :: i, j, k, ii, jj
   INTEGER :: iMapLocal(0:N,0:N,1:nFaces), jMapLocal(0:N,0:N,1:nFaces)
   INTEGER :: faceIDs(1:nFaces), boundaryIDs(1:nFaces)
   INTEGER :: nodeIDs(1:4,1:nFaces), elementIDs(1:2,1:nFaces), elementSides(1:2,1:nFaces)
   
      DO k = 1, nFaces
      
         faceIDs(k)          = cpuFaceArray(k) % faceID
         boundaryIDs(k)      = cpuFaceArray(k) % boundaryID
         nodeIDs(1:4,k)      = cpuFaceArray(k) % nodeIDs
         elementIDs(1:2,k)   = cpuFaceArray(k) % elementIDs
         elementSides(1:2,k) = cpuFaceArray(k) % elementSides
         
         DO j = 0, N
            DO i = 0, N
               IF( i == 0 )THEN
                  IF( j == 0 )THEN
                     ii = (1-cpuFaceArray(k) % swapDimensions)*&
                          (cpuFaceArray(k) % iStart) + &
                          (cpuFaceArray(k) % swapDimensions)*&
                          (cpuFaceArray(k) % jStart)
                     jj = (1-cpuFaceArray(k) % swapDimensions)*&
                          (cpuFaceArray(k) % jStart) + &
                          (cpuFaceArray(k) % swapDimensions)*&
                          (cpuFaceArray(k) % iStart)
                  ELSE
                     ii = cpuFaceArray(k) % swapDimensions*&
                          (ii+cpuFaceArray(k) % jInc) + &
                          (1-cpuFaceArray(k) % swapDimensions)*&
                          cpuFaceArray(k) % iStart
                     jj = (1-cpuFaceArray(k) % swapDimensions)*&
                          (jj+cpuFaceArray(k) % jInc) +&
                          cpuFaceArray(k) % swapDimensions*&
                          cpuFaceArray(k) % jStart
                  ENDIF
               ELSE
                  ii = (1-cpuFaceArray(k) % swapDimensions)*&
                       (ii + cpuFaceArray(k) % iInc) +&
                       cpuFaceArray(k) % swapDimensions*ii
                  jj = cpuFaceArray(k) % swapDimensions*&
                       (jj+cpuFaceArray(k) % iInc) + &
                       (1-cpuFaceArray(k) % swapDimensions)*jj
               ENDIF
               iMapLocal(i,j,k) = ii
               jMapLocal(i,j,k) = jj
            ENDDO
         ENDDO
         
      ENDDO
      
      ! Copy over to the GPU
      myFace % faceID       = faceIDs
      myFace % boundaryID   = boundaryIDs
      myFace % nodeIDs      = nodeIDs
      myFace % elementIDs   = elementIDs
      myFace % elementSides = elementSides
      myFace % iMap         = iMapLocal
      myFace % jMap         = jMapLocal
      
 END SUBROUTINE UpdateDevice_Face_Cuda
END MODULE Face_Cuda_Class
