! QuadMesh_Cuda_Class.f90
! 
! Copyright 2015 Joseph Schoonover <schoonover.numerics@gmail.com>, The Florida State University
! Copyright 2016 Joseph Schoonover <jschoonover@lanl.gov>, Los Alamos National Laboratory
!
! The SELF and accompanying documentation were produced in part under the 
! support of Florida State University and the National Science Foundation 
! through Grant OCE-1049131 during 2015 and in part under the support of the 
! Center for Nonlinear Studies and the Department of Energy through the 
! LANL/LDRD program in 2016.
!
! QuadMesh_Cuda_Class.f90 is part of the Spectral Element Libraries in Fortran (SELF).
! 
! Licensed under the Apache License, Version 2.0 (the "License"); 
! You may obtain a copy of the License at 
!
! http://www.apache.org/licenses/LICENSE-2.0 
!
! Unless required by applicable law or agreed to in writing, software 
! distributed under the License is distributed on an "AS IS" BASIS, 
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
! See the License for the specific language governing permissions and  
! limitations under the License.
!
! //////////////////////////////////////////////////////////////////////////////////////////////// !


MODULE QuadMesh_Cuda_Class

! src/common/
USE ModelPrecision
USE ConstantsDictionary
! src/spectralops/
USE Lagrange_Class
! src/geom/
USE QuadMesh_Class
USE Curve_Class
! src/geom/cuda/
USE Element_Cuda_Class
USE Node_Cuda_Class
USE Edge_Cuda_Class
USE MappedGeometry_2D_Cuda_Class

IMPLICIT NONE

   TYPE, EXTENDS( QuadMesh ) :: QuadMesh_Cuda 
      !INTEGER                                :: nElems, nNodes, nEdges
      !TYPE( QuadElement ), ALLOCATABLE       :: elements(:)
      !TYPE( MappedGeometry_2D ), ALLOCATABLE :: geom(:)
      !TYPE( Node ), ALLOCATABLE              :: nodes(:)  
      !TYPE( Edge ), ALLOCATABLE              :: edges(:)
      !INTEGER, ALLOCATABLE                   :: nodeToElement(:,:,:) 
      !INTEGER                                :: cornerMap(1:2,1:4) 
      !INTEGER                                :: sideMap(1:4) 
      !INTEGER                                :: edgeMap(1:2,1:4) 

      TYPE( Element_Cuda )           :: elements_dev
      TYPE( Node_Cuda )              :: nodes_dev
      TYPE( Edge_Cuda )              :: edges_dev
      TYPE( MappedGeometry_2D_Cuda ) :: geom_dev
      INTEGER, DEVICE, ALLOCATABLE   :: nodeToElement_dev(:,:,:)
      INTEGER, DEVICE, ALLOCATABLE   :: nodalValence_dev(:)
      INTEGER, DEVICE, ALLOCATABLE   :: cornerMap_dev(:,:)
      INTEGER, DEVICE, ALLOCATABLE   :: sideMap_dev(:)
      INTEGER, DEVICE, ALLOCATABLE   :: edgeMap_dev(:,:)
      
      
      CONTAINS

      PROCEDURE :: Initialize => Initialize_QuadMesh_Cuda
      PROCEDURE :: Trash => Trash_QuadMesh_Cuda
       
      PROCEDURE :: UpdateDevice => UpdateDevice_QuadMesh_Cuda
      PROCEDURE :: UpdateDeviceElements => UpdateDeviceElements_QuadMesh_Cuda
      
      ! File Input (Read) Routines -- these routines add the additional "UpdateDevice" Call
      PROCEDURE :: LoadDefaultMesh   => LoadDefaultMesh_QuadMesh_Cuda
      PROCEDURE :: ReadPeaceMeshFile => ReadPeaceMeshFile_QuadMesh_Cuda
      PROCEDURE :: ReadSpecMeshFile  => ReadSpecMeshFile_QuadMesh_Cuda
   END TYPE QuadMesh_Cuda



 CONTAINS
!
!
!==================================================================================================!
!------------------------------- Manual Constructors/Destructors ----------------------------------!
!==================================================================================================!
!
!
 ATTRIBUTES(Host) SUBROUTINE Initialize_QuadMesh_Cuda( myQuadMesh, nNodes, nElems, nEdges, N )

   IMPLICIT NONE
   CLASS(QuadMesh_Cuda), INTENT(out) :: myQuadMesh
   INTEGER, INTENT(in)               :: nNodes, nElems, nEdges, N
   !LOCAL
   INTEGER :: i

      myQuadMesh % sideMap(1:4)      = (/ 0, N, N, 0 /)
      myQuadMesh % cornerMap(1, 1:4) = (/ 0, N, N, 0 /)
      myQuadMesh % cornerMap(2, 1:4) = (/ 0, 0, N, N /)
      myQuadMesh % edgeMap(1, 1:4)   = (/ 1, 2, 4, 1 /)
      myQuadMesh % edgeMap(2, 1:4)   = (/ 2, 3, 3, 4 /)

      myQuadMesh % nNodes = nNodes
      myQuadMesh % nElems = nElems
      myQuadMesh % nEdges = nEdges
      
      ALLOCATE( myQuadMesh % nodes(1:nNodes), &
                myQuadMesh % edges(1:nEdges), &
                myQuadMesh % geom(1:nElems), &
                myQuadMesh % elements(1:nElems), &
                myQuadMesh % nodeToElement(1:2,0:maxNodalValence,1:nNodes),&
                myQuadMesh % nodalValence(1:nNodes) )
                
      myQuadMesh % nodeToElement = 0
      myQuadMesh % nodalValence  = 0
      
      DO i = 1, myQuadMesh % nNodes
         CALL myQuadMesh % nodes(i) % Initialize( )
      ENDDO 
      DO i = 1, myQuadMesh % nElems
         CALL myQuadMesh % elements(i) % Initialize( )
         CALL myQuadMesh % geom(i) % Initialize( N )
      ENDDO
      DO i = 1, myQuadMesh % nEdges
         CALL myQuadMesh % edges(i) % Initialize( )
      ENDDO
      
      
      ! /// Initialize Device Variables /// !
      CALL myQuadMesh % elements_dev % Build( nElems, &
                                              elementType=Quad2D )
      CALL myQuadMesh % nodes_dev % Build( nNodes )
      CALL myQuadMesh % edges_dev % Build( N, nEdges )
      CALL myQuadMesh % geom_dev % Build( N, nElems )
      
      ALLOCATE( myQuadMesh % nodeToElement_dev(1:2,0:maxNodalValence,1:nNodes), &
                myQuadMesh % nodalValence_dev(1:nNodes), &
                myQuadMesh % cornerMap_dev(1:2,1:4), &
                myQuadMesh % sideMap_dev(1:4), &
                myQuadMesh % edgeMap_dev(1:2,1:4) )
                
      myQuadMesh % nodeToElement_dev = 0
      myQuadMesh % nodalValence_dev  = 0
      myQuadMesh % cornerMap_dev     = myQuadMesh % cornerMap
      myQuadMesh % sideMap_dev       = myQuadMesh % sideMap
      myQuadMesh % edgeMap_dev       = myQuadMesh % edgeMap
      
      

 END SUBROUTINE Initialize_QuadMesh_Cuda
!
 ATTRIBUTES(Host) SUBROUTINE Trash_QuadMesh_Cuda( myQuadMesh )

   IMPLICIT NONE
   CLASS(QuadMesh_Cuda), INTENT(inout) :: myQuadMesh
  ! LOCAL
   INTEGER :: i, nEl
      
      nEl = myQuadMesh % nElems
      DO i = 1, nEl
         CALL myQuadMesh % geom(i) % Trash( )
      ENDDO

      DEALLOCATE( myQuadMesh % nodes, &
                  myQuadMesh % edges, &
                  myQuadMesh % elements, &
                  myQuadMesh % nodeToElement, &
                  myQuadMesh % geom )
                  
     ! //// Free Device Memory //// !
      CALL myQuadMesh % elements_dev % Trash( )
      CALL myQuadMesh % nodes_dev % Trash( )
      CALL myQuadMesh % edges_dev % Trash( )
      CALL myQuadMesh % geom_dev % Trash( )
      
      DEALLOCATE( myQuadMesh % nodeToElement_dev, &
                  myQuadMesh % nodalValence_dev, &
                  myQuadMesh % cornerMap_dev, &
                  myQuadMesh % sideMap_dev, &
                  myQuadMesh % edgeMap_dev )
     
 END SUBROUTINE Trash_QuadMesh_Cuda
!
!
!==================================================================================================!
!--------------------------------- Type Specific Routines -----------------------------------------!
!==================================================================================================!
!
!
 ATTRIBUTES(Host) SUBROUTINE UpdateDevice_QuadMesh_Cuda( myQuadMesh, N )
 
   IMPLICIT NONE
   CLASS( QuadMesh_Cuda ), INTENT(inout ) :: myQuadMesh
   INTEGER, INTENT(in)                    :: N
   
      CALL myQuadMesh % UpdateDeviceElements(  )
                                                  
      CALL myQuadMesh % nodes_dev % UpdateDevice( myQuadMesh % nodes, &
                                                  myQuadMesh % nNodes )
                                               
      CALL myQuadMesh % edges_dev % UpdateDevice( myQuadMesh % edges, &
                                                  N, myQuadMesh % nEdges )
                                               
      CALL myQuadMesh % geom_dev % UpdateDevice( myQuadMesh % geom, &
                                                 myQuadMesh % nElems )
                                              
      myQuadMesh % nodeToElement_dev = myQuadMesh % nodeToElement
      myQuadMesh % nodalValence_dev  = myQuadMesh % nodalValence
 
 END SUBROUTINE UpdateDevice_QuadMesh_Cuda
!
 ATTRIBUTES(Host) SUBROUTINE UpdateDeviceElements_QuadMesh_Cuda( myQuadMesh )
 
   IMPLICIT NONE
   CLASS( QuadMesh_Cuda ), INTENT(inout) :: myQuadMesh
   ! Local
   INTEGER :: k
   
      DO k = 1, myQuadMesh % nElems
         myQuadMesh % elements_dev % elementID(k)     = myQuadMesh % elements(k) % elementID
         myQuadMesh % elements_dev % nodeIDs(1:4,k)   = myQuadMesh % elements(k) % nodeIDs(1:4)
         myQuadMesh % elements_dev % neighbors(1:4,k) = myQuadMesh % elements(k) % neighbors(1:4)        
      ENDDO

 END SUBROUTINE UpdateDeviceElements_QuadMesh_Cuda
!
!
!==================================================================================================!
!------------------- File Input and Mesh Specification Routines -----------------------------------!
!==================================================================================================!
!
!
 ATTRIBUTES(Host) SUBROUTINE LoadDefaultMesh_QuadMesh_Cuda( myQuadMesh, interp, nXelem, nYelem  )

   IMPLICIT NONE
   CLASS( QuadMesh_Cuda ), INTENT(inout)  :: myQuadMesh
   TYPE( Lagrange ), INTENT(in)           :: interp
   INTEGER, INTENT(in)                    :: nXelem, nYelem
   ! LOCAL
   TYPE( Curve ) :: elBoundCurves(1:4)

   REAL(prec) :: x, y, dxElem, dyElem
   REAL(prec) :: x1, x2, y1, y2
   REAL(prec), ALLOCATABLE :: xc(:,:), s(:)

   INTEGER :: nNodes, nElems, nEdges, gPolyDeg
   INTEGER :: nodes(1:4), nids(1:2), eID
   INTEGER :: s2, n1, n2
   INTEGER :: iEdge, iNode, iEl, iSide, iX, iY
      
      dxElem = ONE/nXElem
      dyElem = ONE/nYElem
      
      ! ** "Hard-wired" values for a structured mesh with no holes ** !
      nNodes   = (nXElem+1)*(nYElem+1)
      nElems   = (nXElem)*(nYElem)
      nEdges   = (nXElem)*(nYElem+1) + (nXElem+1)*(nYElem)
      gPolyDeg = 1
      ! ************************************************************************* !

      PRINT*, 'nNodes    : ', nNodes
      PRINT*, 'nElems    : ', nElems
      PRINT*, 'gPolyDeg  : ', gPolyDeg

      ! Generate the chebyshev points of order gPolyDeg
      ! These are the points used to define the parametric
      ! curves for the element boundaries

      ALLOCATE( s(0:gPolyDeg), xc(0:gPolyDeg,1:2) )
      CALL ChebyshevQuadrature( gPolyDeg, Gauss_Lobatto, s, xc(:,1) )! ** xc is a placeholder here only.

      ! ---- Initialize the quadrature mesh (empty) ---- !
      CALL myQuadMesh % Initialize( nNodes, nElems, nEdges, interp % N ) 
      
      ! ---- Read in the corner nodes ---- !
      DO iY = 1, nYElem+1
      
         y = dYElem*(REAL(iY-1,prec))
         DO iX = 1, nXElem+1
            
            iNode = iX + (iY-1)*(nXElem+1)
            x = dXElem*(REAL(iX-1,prec))
            myQuadMesh % nodes(iNode) % x = x
            myQuadMesh % nodes(iNode) % y = y
            
         ENDDO
      ENDDO
  
      ! Do the element information
      xc = ZERO
      ! Do the initial build for the parametric curves
      DO iSide = 1, 4
         CALL elBoundCurves(iSide) % Build( xc, s, gPolyDeg, 2 ) 
      ENDDO
     
      DO iY = 1, nYElem
         DO iX = 1, nXElem

            iEl = iX + (iY-1)*(nXElem)
            ! Calculate the global node IDs for this element.
            nodes(1) = iX + (iY-1)*(nXElem+1)    ! Southwest
            nodes(2) = iX + 1 + (iY-1)*(nXElem+1)! SouthEast
            nodes(3) = iX + 1 + (iY)*(nXElem+1)  ! NorthEast
            nodes(4) = iX + (iY)*(nXElem+1)      ! NorthWest
         
            DO iSide = 1, 4 ! Loop over the sides of the quads

               ! Initialize a straight curve for this side
               n1 = nodes( myQuadMesh % edgeMap(1,iSide) )
               n2 = nodes( myQuadMesh % edgeMap(2,iSide) )

               x1 = myQuadMesh % nodes(n1) % x
               y1 = myQuadMesh % nodes(n1) % y
               x2 = myQuadMesh % nodes(n2) % x
               y2 = myQuadMesh % nodes(n2) % y
               
               DO iNode = 0, gPolyDeg
                  xc(iNode,1) = x1 + (x2-x1)*HALF*( s(iNode) + ONE )
                  xc(iNode,2) = y1 + (y2-y1)*HALF*( s(iNode) + ONE )
               ENDDO
               elBoundCurves(iSide) % x = xc

            ENDDO
            myQuadMesh % elements(iEl) % nodeIDs(1:4) = nodes
            CALL myQuadMesh % geom(iEl) % GenerateMesh( interp, elBoundCurves )
            CALL myQuadMesh % geom(iEl) % GenerateMetrics( interp )
         ENDDO
      ENDDO ! iEl, cycle over the elements

      CALL myQuadMesh % ConstructEdges( )
      nEdges = myQuadMesh % nEdges
      PRINT*, 'nEdges    : ', nEdges
      
      ! Set the start and increment for the secondary element 
      DO iEdge = 1, nEdges
            s2 = myQuadMesh % edges(iEdge) % elementSides(2)
            IF(s2 < 0)THEN
               myQuadMesh % edges(iEdge) % start = interp % N-1
               myQuadMesh % edges(iEdge) % inc   = -1
            ELSE
               myQuadMesh % edges(iEdge) % start = 1
               myQuadMesh % edges(iEdge) % inc   = 1
            ENDIF
            eID = myQuadMesh % edges(iEdge) % elementIDs(2)
            IF( eID < 0 )THEN
               myQuadMesh % edges(iEdge) % elementIDs(2) = eID
               nids = myQuadMesh % edges(iEdge) % nodeIDs
               myQuadMesh % nodes(nids(1)) % nodeType = eID
               myQuadMesh % nodes(nids(2)) % nodeType = eID
            ENDIF
      ENDDO

      CALL myQuadMesh % GetNodeToElementConnectivity( )
      CALL myQuadMesh % ConstructElementNeighbors( )

      ! Clear up memory
      DEALLOCATE( s, xc )

      DO iSide = 1, 4
         CALL elBoundCurves(iSide) % Trash( )
      ENDDO
      
      ! Now update the device
      CALL myQuadMesh % UpdateDevice( interp % N ) 
  
 END SUBROUTINE LoadDefaultMesh_QuadMesh_Cuda
!
 ATTRIBUTES(Host) SUBROUTINE ReadPeaceMeshFile_QuadMesh_Cuda( myQuadMesh, filename )

   IMPLICIT NONE
   CLASS( QuadMesh_Cuda ), INTENT(out)  :: myQuadMesh
   CHARACTER(*), INTENT(in)             :: filename
   ! LOCAL
   INTEGER :: nNodes, nElems, nEdges, N
   INTEGER :: iEdge, iNode, iEl
   INTEGER :: fUnit, k, i, j


      !PRINT*, 'Mesh File : '//TRIM( filename )//'.pc.mesh'
      
      ! Get a new file unit
      OPEN( UNIT    = NEWUNIT(fUnit), &
            FILE    = TRIM( filename )//'.pc.mesh', &
            FORM    = 'UNFORMATTED',&
            STATUS  = 'OLD', &
            ACCESS  = 'DIRECT', &
            CONVERT = 'BIG_ENDIAN', &
            RECL    = SIZEOF(nNodes) ) ! How to do variable record length

      ! ---- Gather the number of nodes, number of elements, and number of edges ---- !
      k = 1
      READ( fUnit, rec=k )nNodes
      k = k+1
      READ( fUnit, rec=k )nElems
      k = k+1
      READ( fUnit, rec=k )nEdges
      k = k+1
      READ( fUnit, rec=k )N
      k = k+1

      PRINT*, 'nNodes    : ', nNodes
      PRINT*, 'nElems    : ', nElems
      PRINT*, 'nEdges    : ', nEdges
      PRINT*, 'N         : ', N
      ! ---- Initialize the quadrature mesh (empty) ---- !
      CALL myQuadMesh % Initialize( nNodes, nElems, nEdges, N ) 
      
      ! ---- Read in the element connectivity ---- !
      DO iEl = 1, nElems
         READ( fUnit, rec=k ) myQuadMesh % elements(iEl) % elementID 
         k = k+1
         DO i = 1, 4
            READ( fUnit, rec=k ) myQuadMesh % elements(iEl) % nodeIDs(i)
            k = k+1
         ENDDO
      ENDDO 
      
      ! ---- Read in the edge information ---- !

      DO iEdge = 1, nEdges
         READ( fUnit, rec=k ) myQuadMesh % edges(iEdge) % edgeID
         k = k+1
         READ( fUnit, rec=k ) myQuadMesh % edges(iEdge) % boundaryID
         k = k+1
         DO i = 1, 2
            READ( fUnit, rec=k ) myQuadMesh % edges(iEdge) % nodeIDs(i)
            k = k+1
            READ( fUnit, rec=k ) myQuadMesh % edges(iEdge) % elementIDs(i)
            k = k+1
            READ( fUnit, rec=k ) myQuadMesh % edges(iEdge) % elementSides(i)
            k = k+1
         ENDDO
         READ( fUnit, rec=k ) myQuadMesh % edges(iEdge) % start
         k = k+1
         READ( fUnit, rec=k ) myQuadMesh % edges(iEdge) % inc
         k = k+1
      ENDDO
      
      CLOSE( fUnit )
      ! Get a new file unit
      OPEN( UNIT    = NEWUNIT(fUnit), &
            FILE    = TRIM( filename )//'.pc.geom', &
            FORM    = 'UNFORMATTED',&
            STATUS  = 'OLD', &
            ACCESS  = 'DIRECT', &
            CONVERT = 'BIG_ENDIAN', &
            RECL    = prec ) ! How to do variable record length
      
      ! ---- Read in the corner nodes ---- !
      k = 1
      DO iNode = 1, nNodes  ! Loop over the nodes in the file
         READ( fUnit, rec=k ) myQuadMesh % nodes(iNode) % x
         k = k+1
         READ( fUnit, rec=k ) myQuadMesh % nodes(iNode) % y
         k = k+1
      ENDDO

      ! ---- Read in the element information ---- !
      DO iEl = 1, nElems
         DO j = 0, N
            DO i = 0, N
               READ( fUnit, rec=k ) myQuadMesh % geom(iEl) % x(i,j)
               k = k+1
               READ( fUnit, rec=k ) myQuadMesh % geom(iEl) % y(i,j)
               k = k+1
               READ( fUnit, rec=k ) myQuadMesh % geom(iEl) % dxds(i,j)
               k = k+1
               READ( fUnit, rec=k ) myQuadMesh % geom(iEl) % dxdp(i,j)
               k = k+1
               READ( fUnit, rec=k ) myQuadMesh % geom(iEl) % dyds(i,j)
               k = k+1
               READ( fUnit, rec=k ) myQuadMesh % geom(iEl) % dydp(i,j)
               k = k+1
               READ( fUnit, rec=k ) myQuadMesh % geom(iEl) % J(i,j)
               k = k+1
            ENDDO
         ENDDO
         DO j = 1, nQuadEdges
            DO i = 0, N
               READ( fUnit, rec=k ) myQuadMesh % geom(iEl) % xBound(i,j)
               k = k+1
               READ( fUnit, rec=k ) myQuadMesh % geom(iEl) % yBound(i,j)
               k = k+1
               READ( fUnit, rec=k ) myQuadMesh % geom(iEl) % nHat(1,i,j)
               k = k+1
               READ( fUnit, rec=k ) myQuadMesh % geom(iEl) % nHat(2,i,j)
               k = k+1
            ENDDO
         ENDDO
      ENDDO 

      CLOSE( fUnit )
     
      ! Get the node to element connectivity
      CALL myQuadMesh % GetNodeToElementConnectivity( )
      CALL myQuadMesh % ConstructElementNeighbors( )
  
      CALL myQuadMesh % UpdateDevice( N )
      
 END SUBROUTINE ReadPeaceMeshFile_QuadMesh_Cuda
!
SUBROUTINE ReadSpecMeshFile_QuadMesh_Cuda( myQuadMesh, interp, filename )

   IMPLICIT NONE
   CLASS( QuadMesh_Cuda ), INTENT(out)  :: myQuadMesh
   TYPE( Lagrange ), INTENT(in)         :: interp
   CHARACTER(*), INTENT(in)             :: filename
   ! LOCAL
   TYPE( Curve ) :: elBoundCurves(1:4)

   REAL(prec) :: x, y, z
   REAL(prec) :: x1, x2, y1, y2
   REAL(prec), ALLOCATABLE :: xc(:,:), s(:)

   INTEGER :: nNodes, nElems, nEdges, gPolyDeg
   INTEGER :: bFlags(1:4), nodes(1:4)
   INTEGER :: e1, s1, s2, n1, n2, n(1:2), e(1:2), si(1:2)
   INTEGER :: iEdge, iNode, iEl, iSide
   INTEGER :: fUnit, iC, jC
   INTEGER, ALLOCATABLE :: sideFlags(:,:)

   CHARACTER(20) :: ISMversion
   CHARACTER(100) :: edgeNames
   CHARACTER(100) :: thisEdge

      PRINT*, 'Mesh File : '//TRIM( filename )
      
      ! Get a new file unit
      OPEN( UNIT=NEWUNIT(fUnit), &
            FILE= TRIM( filename ), &
            FORM='FORMATTED',&
            STATUS='OLD' )

      
      ! ---- Read in the file version ----- !

      READ( fUnit, '(A20)' ) ISMversion

      PRINT*, 'Version   : '//TRIM( ISMversion )


      ! ---- Gather the number of nodes, number of elements, and number of edges ---- !
      
      READ( fUnit, * ) nNodes, nEdges, nElems, gPolyDeg

      PRINT*, 'nNodes    : ', nNodes
      PRINT*, 'nElems    : ', nElems
      PRINT*, 'nEdges    : ', nEdges
      PRINT*, 'gPolyDeg  : ', gPolyDeg

      ! Generate the chebyshev points of order gPolyDeg
      ! These are the points used to define the parametric
      ! curves for the element boundaries

      ALLOCATE( s(0:gPolyDeg), xc(0:gPolyDeg,1:2) )
      ALLOCATE( sideFlags(1:nElems,1:4) )
      CALL ChebyshevQuadrature( gPolyDeg, Gauss_Lobatto, s, xc(:,1) )! ** xc is a placeholder here only.

      ! ---- Initialize the quadrature mesh (empty) ---- !
  
      CALL myQuadMesh % Initialize( nNodes, nElems, nEdges, interp % N ) 
      
      ! ---- Read in the corner nodes ---- !

      DO iNode = 1, nNodes  ! Loop over the nodes in the file
         READ( fUnit, * ) x, y, z
         myQuadMesh % nodes(iNode) % x = x
         myQuadMesh % nodes(iNode) % y = y
      ENDDO


      ! ---- Read in the edge information ---- !
      DO iEdge = 1, nEdges
         READ( fUnit, * ) n, e, si 
      ENDDO
      ! ---- Read in the element information ---- !
 
      xc = ZERO
      ! Do the initial build for the parametric curves
      DO iSide = 1, 4
         CALL elBoundCurves(iSide) % Build( xc, s, gPolyDeg, 2 ) 
      ENDDO
   
      sideFlags = INTERIOR
      DO iEl = 1, nElems

         READ( fUnit, * ) nodes(1:4)
         READ( fUnit, * ) bFlags(1:4)
         
         DO iSide = 1, 4 ! Loop over the sides of the quads

            IF( bFlags(iSide) == 0 )then ! this is an interior edge

               ! Initialize a straight curve for this side
               n1 = nodes( myQuadMesh % edgeMap(1,iSide) )
               n2 = nodes( myQuadMesh % edgeMap(2,iSide) )
               
               x1 = myQuadMesh % nodes(n1) % x
               y1 = myQuadMesh % nodes(n1) % y
               x2 = myQuadMesh % nodes(n2) % x
               y2 = myQuadMesh % nodes(n2) % y
               
               DO iNode = 0, gPolyDeg

                  xc(iNode,1) = x1 + (x2-x1)*HALF*( s(iNode) + ONE )
                  xc(iNode,2) = y1 + (y2-y1)*HALF*( s(iNode) + ONE )
  
               ENDDO
               elBoundCurves(iSide) % x = xc

            ELSEIF( bFlags(iSide) == 1 )then ! this is a boundary edge

                ! Read in the parametric curve
                DO iNode = 0, gPolyDeg
                   READ( fUnit, * ) x, y, z
                   xc(iNode,1) = x
                   xc(iNode,2) = y
                ENDDO
                elBoundCurves(iSide) % x = xc

             ELSE
 
                PRINT*,' S/R ReadSpecMeshFile : Impossible element boundary flag '

             ENDIF

         ENDDO

         ! Initialize this element's geometry
         myQuadMesh % elements(iEl) % nodeIDs(1:4) = nodes
         myQuadMesh % elements(iEl) % elementID    = iEl
         CALL myQuadMesh % geom(iEl) % GenerateMesh( interp, elBoundCurves )
         CALL myQuadMesh % geom(iEl) % GenerateMetrics( interp )

         ! Read in and parse the edge names
         READ( fUnit, '(1x, A100)' )  edgeNames

         ! Parse the edge names into four edge names
         iSide = 1
         iC = 1
         jC = 1
         thisEdge = ' ' 
         DO while( iSide <= 4 )

            IF( edgeNames(iC:iC) == ' ' )then ! we have reached a blank space
     
               n1 = nodes( myQuadMesh % edgeMap(1,iSide) )
               n2 = nodes( myQuadMesh % edgeMap(2,iSide) )
               
               IF( TRIM(thisEdge) == 'DIRICHLET' )then
                  
                  sideFlags(iEl,iSide) = DIRICHLET
                  
               ELSEIF( TRIM(thisEdge) == 'DIRICHLET_INFLOW' )then
                  
                  sideFlags(iEl,iSide) = DIRICHLET_INFLOW

               ELSEIF( TRIM(thisEdge) == 'DIRICHLET_OUTFLOW' )then
                  
                  sideFlags(iEl,iSide) = DIRICHLET_OUTFLOW

               ELSEIF( TRIM(thisEdge) == 'ROBIN' )then

                  sideFlags(iEl,iSide) = ROBIN

               ELSEIF( TRIM(thisEdge) == 'ROBIN_FORCED' )then

                  sideFlags(iEl,iSide) = ROBIN_FORCED

               ELSEIF( TRIM(thisEdge) == 'HOMOGENEOUS_NEUMANN' )then

                  sideFlags(iEl,iSide) = HOMOGENEOUS_NEUMANN

               ELSEIF( TRIM(thisEdge) == 'NEUMANN_WALL' )then

                  sideFlags(iEl,iSide) = NEUMANN_WALL

               ELSEIF( TRIM(thisEdge) == 'NEUMANN' )then

                  sideFlags(iEl,iSide) = NEUMANN
 
               ELSEIF( TRIM(thisEdge) == 'NO_NORMAL_FLOW' )then
                  
                  sideFlags(iEl,iSide) = NO_NORMAL_FLOW

               ELSEIF( TRIM(thisEdge) == 'PRESCRIBED' )then
               
                  sideFlags(iEl,iSide) = PRESCRIBED

               ELSEIF( TRIM(thisEdge) == 'RADIATION' )then
                  
                  sideFlags(iEl,iSide) = RADIATION

               ENDIF

               ! Reset thisEdge
               thisEdge = ' '
               jC = 1 
               iC = iC + 1
               ! Increment the side
               iSide = iSide + 1

            ELSE
            
               
               thisEdge(jC:jC) = edgeNames(iC:iC)
               iC = iC + 1
               jC = jC + 1

            ENDIF

         ENDDO ! while (iSide <= 4 )


      ENDDO ! iEl, cycle over the elements

      CLOSE( fUnit )
      CALL myQuadMesh % ConstructEdges( )
      
      ! Set the secondary element on boundary edges to the boundary flag
      DO iEdge = 1, nEdges

         e1 = myQuadMesh % edges(iEdge) % elementIDs(1)
         s1 = myQuadMesh % edges(iEdge) % elementSides(1)
      
         IF( sideFlags(e1,s1) == DIRICHLET )then

            myQuadMesh % edges(iEdge) % elementIDs(2) = DIRICHLET
            n = myQuadMesh % edges(iEdge) % nodeIDs
            myQuadMesh % nodes( n(1) ) % nodeType = DIRICHLET
            myQuadMesh % nodes( n(2) ) % nodeType = DIRICHLET
   
         ELSEIF( sideFlags(e1,s1) == DIRICHLET_INFLOW )then

            myQuadMesh % edges(iEdge) % elementIDs(2) = DIRICHLET_INFLOW
            n = myQuadMesh % edges(iEdge) % nodeIDs
            myQuadMesh % nodes( n(1) ) % nodeType = DIRICHLET_INFLOW
            myQuadMesh % nodes( n(2) ) % nodeType = DIRICHLET_INFLOW
            
         ELSEIF( sideFlags(e1,s1) == DIRICHLET_OUTFLOW )then

            myQuadMesh % edges(iEdge) % elementIDs(2) = DIRICHLET_OUTFLOW
            n = myQuadMesh % edges(iEdge) % nodeIDs
            myQuadMesh % nodes( n(1) ) % nodeType = DIRICHLET_OUTFLOW
            myQuadMesh % nodes( n(2) ) % nodeType = DIRICHLET_OUTFLOW
            
         ELSEIF( sideFlags(e1,s1) == ROBIN )then

            myQuadMesh % edges(iEdge) % elementIDs(2) = ROBIN
            n = myQuadMesh % edges(iEdge) % nodeIDs
            myQuadMesh % nodes( n(1) ) % nodeType = ROBIN
            myQuadMesh % nodes( n(2) ) % nodeType = ROBIN

         ELSEIF( sideFlags(e1,s1) == ROBIN_FORCED )then

            myQuadMesh % edges(iEdge) % elementIDs(2) = ROBIN_FORCED
            n = myQuadMesh % edges(iEdge) % nodeIDs
            myQuadMesh % nodes( n(1) ) % nodeType = ROBIN_FORCED
            myQuadMesh % nodes( n(2) ) % nodeType = ROBIN_FORCED

         ELSEIF( sideFlags(e1,s1) == HOMOGENEOUS_NEUMANN )then

            myQuadMesh % edges(iEdge) % elementIDs(2) = HOMOGENEOUS_NEUMANN
            n = myQuadMesh % edges(iEdge) % nodeIDs
            myQuadMesh % nodes( n(1) ) % nodeType = HOMOGENEOUS_NEUMANN
            myQuadMesh % nodes( n(2) ) % nodeType = HOMOGENEOUS_NEUMANN

         ELSEIF( sideFlags(e1,s1) == NEUMANN_WALL )then

            myQuadMesh % edges(iEdge) % elementIDs(2) = NEUMANN_WALL
            n = myQuadMesh % edges(iEdge) % nodeIDs
            myQuadMesh % nodes( n(1) ) % nodeType = NEUMANN_WALL
            myQuadMesh % nodes( n(2) ) % nodeType = NEUMANN_WALL

         ELSEIF( sideFlags(e1,s1) == NEUMANN )then

            myQuadMesh % edges(iEdge) % elementIDs(2) = NEUMANN
            n = myQuadMesh % edges(iEdge) % nodeIDs
            myQuadMesh % nodes( n(1) ) % nodeType = NEUMANN
            myQuadMesh % nodes( n(2) ) % nodeType = NEUMANN

         ELSEIF( sideFlags(e1,s1) == NO_NORMAL_FLOW )then

            myQuadMesh % edges(iEdge) % elementIDs(2) = NO_NORMAL_FLOW
            n = myQuadMesh % edges(iEdge) % nodeIDs
            myQuadMesh % nodes( n(1) ) % nodeType = NO_NORMAL_FLOW
            myQuadMesh % nodes( n(2) ) % nodeType = NO_NORMAL_FLOW

         ELSEIF( sideFlags(e1,s1) == PRESCRIBED )then

            myQuadMesh % edges(iEdge) % elementIDs(2) = PRESCRIBED
            n = myQuadMesh % edges(iEdge) % nodeIDs
            myQuadMesh % nodes( n(1) ) % nodeType = PRESCRIBED
            myQuadMesh % nodes( n(2) ) % nodeType = PRESCRIBED
            
         ELSEIF( sideFlags(e1,s1) == RADIATION )then

            myQuadMesh % edges(iEdge) % elementIDs(2) = RADIATION
            n = myQuadMesh % edges(iEdge) % nodeIDs
            myQuadMesh % nodes( n(1) ) % nodeType = RADIATION
            myQuadMesh % nodes( n(2) ) % nodeType = RADIATION
         ENDIF
 
      ENDDO

      DO iEdge = 1, nEdges
            s2 = myQuadMesh % edges(iEdge) % elementSides(2)
            IF(s2 < 0)THEN
               myQuadMesh % edges(iEdge) % start = interp % N -1
               myQuadMesh % edges(iEdge) % inc   = -1
            ELSE
               myQuadMesh % edges(iEdge) % start = 1
               myQuadMesh % edges(iEdge) % inc   = 1
            ENDIF
            
      ENDDO

      ! Get the node to element connectivity
      CALL myQuadMesh % GetNodeToElementConnectivity( )
      CALL myQuadMesh % ConstructElementNeighbors( )

      ! Clear up memory
      DEALLOCATE( s, xc, sideFlags )

      DO iSide = 1, 4
         CALL elBoundCurves(iSide) % Trash( )
      ENDDO
  
      CALL myQuadMesh % UpdateDevice( interp % N ) 
      
 END SUBROUTINE ReadSpecMeshFile_QuadMesh_Cuda
 
END MODULE QuadMesh_Cuda_Class
