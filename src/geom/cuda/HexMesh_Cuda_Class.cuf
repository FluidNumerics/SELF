! HexMesh_Class.f90
! 
! Copyright 2015 Joseph Schoonover <schoonover.numerics@gmail.com>, The Florida State University
! Copyright 2016 Joseph Schoonover <jschoonover@lanl.gov>, Los Alamos National Laboratory
!
! The SELF and accompanying documentation were produced in part under the 
! support of Florida State University and the National Science Foundation 
! through Grant OCE-1049131 during 2015 and in part under the support of the 
! Center for Nonlinear Studies and the Department of Energy through the 
! LANL/LDRD program in 2016.
!
! HexMesh_Class.f90 is part of the Spectral Element Libraries in Fortran (SELF).
! 
! Licensed under the Apache License, Version 2.0 (the "License"); 
! You may obtain a copy of the License at 
!
! http://www.apache.org/licenses/LICENSE-2.0 
!
! Unless required by applicable law or agreed to in writing, software 
! distributed under the License is distributed on an "AS IS" BASIS, 
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
! See the License for the specific language governing permissions and  
! limitations under the License.
!
! //////////////////////////////////////////////////////////////////////////////////////////////// !


MODULE HexMesh_Cuda_Class

! src/common/
USE ModelPrecision
USE ConstantsDictionary
! src/interp/
USE Lagrange_Class
! src/interp/cuda/
USE Lagrange_Cuda_Class
! src/geom/
USE HexMesh_Class
USE Surface_Class
! src/geom/cuda/
USE Element_Cuda_Class
USE Node_Cuda_Class
USE Face_Cuda_Class
USE MappedGeometry_3D_Cuda_Class

IMPLICIT NONE

 
   TYPE, EXTENDS( HexMesh ) :: HexMesh_Cuda 
      !INTEGER                                 :: nElems, nNodes, nFaces
      !TYPE( HexElement ), ALLOCATABLE         :: elements(:) !
      !TYPE( MappedGeometry_3D ), ALLOCATABLE  :: geom(:)
      !TYPE( Node  ), ALLOCATABLE              :: nodes(:)  
      !TYPE( Face ), ALLOCATABLE               :: faces(:)
      !INTEGER                                 :: cornerMap(1:3,1:nHexNodes) 
      !INTEGER                                 :: sideMap(1:nHexFaces) 
      !INTEGER                                 :: faceMap(1:nQuadNodes,1:nHexFaces) 
      !INTEGER                                 :: edgeFaceMap(1:2,1:nQuadEdges)
    
      TYPE( Element_Cuda )            :: elements_dev
      TYPE( Node_Cuda )               :: nodes_dev
      TYPE( Face_Cuda )               :: faces_dev
      TYPE( MappedGeometry_3D_Cuda )  :: geom_dev
      !INTEGER, DEVICE, ALLOCATABLE   :: nodeToElement_dev(:,:,:)
      !INTEGER, DEVICE, ALLOCATABLE   :: nodalValence_dev(:)
      INTEGER, DEVICE, ALLOCATABLE    :: cornerMap_dev(:,:)
      INTEGER, DEVICE, ALLOCATABLE    :: sideMap_dev(:)
      INTEGER, DEVICE, ALLOCATABLE    :: faceMap_dev(:,:)
      INTEGER, DEVICE, ALLOCATABLE    :: edgeFaceMap_dev(:,:)
      
      CONTAINS
      
      PROCEDURE :: Initialize => Initialize_HexMesh
      PROCEDURE :: Trash      => Trash_HexMesh
       
      PROCEDURE :: UpdateDevice         => UpdateDevice_HexMesh_Cuda
      PROCEDURE :: UpdateDeviceElements => UpdateDeviceElements_HexMesh_Cuda
      
      PROCEDURE :: LoadDefaultMesh      => LoadDefaultMesh_HexMesh_Cuda
      PROCEDURE :: ReadPeaceMeshFile    => ReadPeaceMeshFile_HexMesh_Cuda
      PROCEDURE :: ReadUCDMeshFile      => ReadUCDMeshFile_HexMesh_Cuda
      
      PROCEDURE :: ScaleTheMesh => ScaleTheMesh_HexMesh_Cuda
      
    END TYPE HexMesh_Cuda


 CONTAINS
!
!
!==================================================================================================!
!------------------------------- Manual Constructors/Destructors ----------------------------------!
!==================================================================================================!
!
 SUBROUTINE Initialize_HexMesh( myHexMesh, nNodes, nElems, nFaces, N )

   IMPLICIT NONE
   CLASS( HexMesh_Cuda ), INTENT(out) :: myHexMesh
   INTEGER, INTENT(in)                :: nNodes, nElems, nFaces, N
   !LOCAL
   INTEGER :: i

      ! A hexahedron element (hex-element for short) has six faces. Each face has geometry that 
      ! requires the use of two computational coordinates. The third computational coordinate is 
      ! fixed. The sideMap gives the value of the remaining computational coordinate for each face
      ! of the hex-element.
      ! 
      ! The face ordering is  1 - South, 2 - East, 3 - North, 4 - West, 5 - Bottom, 6 - Top 
      myHexmesh % sideMap(1:nHexFaces) = (/ 0, N, N, 0, 0, N /)
      
      ! The eight corner nodes in an approximation that uses Gauss-Lobatto points, typically CG-type
      ! methods, have fixed computational coordinates. The corner node numbering  starts in the 
      ! southwest corner (in the computational grid) of the bottom face, proceeds counter clockwise
      ! around the face, and then repeats for the top face. This gives the local ID for the corner
      ! nodes as
      ! 
      ! Bottom, SouthWest = 1
      ! Bottom, SouthEast = 2
      ! Bottom, NorthEast = 3
      ! Bottom, NorthWest = 4
      ! Top, SouthWest = 5
      ! Top, SouthEast = 6
      ! Top, NorthEast = 7
      ! Top, NorthWest = 8
      !
      ! The computational coordinates for the corner nodes is given assuming a Gauss-Lobatto 
      ! computational mesh is used. Note that for a Gauss mesh, the corner nodes are not included.
      
      myHexmesh % cornerMap(1, 1:nHexNodes) = (/ 0, N, N,  0,  0, N, N,  0 /)
      myHexmesh % cornerMap(2, 1:nHexNodes) = (/ 0,  0, N, N,  0,  0, N, N /)
      myHexmesh % cornerMap(3, 1:nHexNodes) = (/ 0,  0,  0,  0, N, N, N, N /)
      
      ! Mesh construction usually begins with the specification of elements and the corner nodes, in
      ! addition to the element geometry. From the element-to-node connectivity, we need to construct
      ! the unique faces in the mesh and specify the abutting elements and their relative orientation.
      ! This procedure is aided by a "convenience array" that lists the local corner node IDs in the
      ! local counter-clockwise direction beginning in the local southwest corner of the face. When 
      ! two elements share a face, the global node IDs for each element can be found using this 
      ! convenience array (called "faceMap") and the relative orientation of the neighboring elements
      ! can be determined. The first index cycles over the nodes which make up the face in a 
      ! counterclockwise direction. The second index cycles over the faces in the element.
      
      myHexMesh % faceMap(1:nQuadNodes, south)  = (/ 1, 2, 6, 5 /)
      myHexMesh % faceMap(1:nQuadNodes, east)   = (/ 2, 3, 7, 6 /)
      myHexMesh % faceMap(1:nQuadNodes, north)  = (/ 4, 3, 7, 8 /)
      myHexMesh % faceMap(1:nQuadNodes, west)   = (/ 1, 4, 8, 5 /)
      myHexMesh % faceMap(1:nQuadNodes, bottom) = (/ 1, 2, 3, 4 /)
      myHexMesh % faceMap(1:nQuadNodes, top)    = (/ 5, 6, 7, 8 /)
      
      ! Each of the faces can be identified by their four corner nodes. The geometry of the faces
      ! is described using two computational coordinates between [-1,1]X[-1,1]. This 2-D computational
      ! grid has its own "southwest", "southeast", "northeast", and "northwest" identifications. The
      ! The corner nodes of the faces are labeled in the order mentioned in the previous sentence
      ! ( counterclockwise starting from southwest ). For quick referencing when producing tri-linear
      ! elements, a book-keeping array is useful for ensuring that we reference each edge of the 
      ! face in the order of increasing computational coordinate. This is identical to what is done
      ! in the HexMeshClass.f90 for the "edgeMap". Here, it is called the "edgeFaceMap".
      ! The first index references the starting(1) or ending(2) node. The second index references
      ! the edge of the face with the first being the southern edge and increasing the second index
      ! proceeds counter-clockwise.
      
      myHexmesh % edgeFaceMap(1, 1:nQuadEdges) = (/ 1, 2, 4, 1 /)
      myHexmesh % edgeFaceMap(2, 1:nQuadEdges) = (/ 2, 3, 3, 4 /)
      
      ! The number of nodes, the number of elements, and the number of faces are stored in this data
      ! structure for convenience. In another implementation (planned for the next version), the 
      ! number of elements, nodes, and faces is dynamic; that implementation 
      ! requires the use of dynamic storage, e.g. a linked-list like structure for elements, edges,
      ! and nodes.
      myHexMesh % nNodes = nNodes
      myHexMesh % nElems = nElems
      myHexMesh % nFaces = nFaces
      
      ALLOCATE( myHexmesh % elements(1:nElems) )
      ALLOCATE( myHexmesh % geom(1:nElems) )
      ALLOCATE( myHexmesh % nodes(1:nNodes) )
      ALLOCATE( myHexmesh % faces(1:nFaces) )
     
      DO i = 1, myHexmesh % nNodes
         CALL myHexmesh % nodes(i) % Initialize( )
      ENDDO 
      DO i = 1, myHexMesh % nElems
         CALL myHexMesh % elements(i) % Initialize( )
         CALL myHexMesh % geom(i) % Initialize( N )
      ENDDO
      DO i = 1, myHexMesh % nFaces
         CALL myHexMesh % faces(i) % Initialize( )
      ENDDO
      
      ! /// Initialize Device Variables /// !
      CALL myHexMesh % elements_dev % Build( nElems, &
                                             elementType=Hex3D )
      CALL myHexMesh % nodes_dev % Build( nNodes )
      CALL myHexMesh % faces_dev % Build( N, nFaces )
      CALL myHexMesh % geom_dev  % Build( N, nElems )
      
      ALLOCATE( myHexMesh % cornerMap_dev(1:3,1:8), &
                myHexMesh % sideMap_dev(1:6), &
                myHexMesh % faceMap_dev(1:4,1:6), &
                myHexMesh % edgeFaceMap_dev(1:2,1:4) )
                
      myHexMesh % cornerMap_dev     = myHexMesh % cornerMap
      myHexMesh % sideMap_dev       = myHexMesh % sideMap
      myHexMesh % faceMap_dev       = myHexMesh % faceMap
      myHexMesh % edgeFaceMap_dev   = myHexMesh % edgeFaceMap

 END SUBROUTINE Initialize_HexMesh
!
 SUBROUTINE Trash_HexMesh( myHexMesh )

   IMPLICIT NONE
   CLASS( HexMesh_Cuda ), INTENT(inout) :: myHexMesh
  ! LOCAL
   INTEGER :: i
      
       ! //// Free Device Memory //// !
      CALL myHexMesh % elements_dev % Trash( )
      CALL myHexMesh % nodes_dev % Trash( )
      CALL myHexMesh % faces_dev % Trash( )
      CALL myHexMesh % geom_dev % Trash( )
      
      DEALLOCATE( myHexMesh % cornerMap_dev, &
                  myHexMesh % sideMap_dev, &
                  myHexMesh % faceMap_dev, &
                  myHexMesh % edgeFaceMap_dev )
      
      DO i = 1, myHexMesh % nElems
         CALL myHexMesh % geom(i) % Trash( )
      ENDDO

      DEALLOCATE( myHexMesh % nodes, &
                  myHexMesh % faces, &
                  myHexMesh % geom, &
                  myHexMesh % elements )

 END SUBROUTINE Trash_HexMesh
!
!
!==================================================================================================!
!--------------------------------- Type Specific Routines -----------------------------------------!
!==================================================================================================!
!
!
 ATTRIBUTES(Host) SUBROUTINE UpdateDevice_HexMesh_Cuda( myHexMesh, N )
 
   IMPLICIT NONE
   CLASS( HexMesh_Cuda ), INTENT(inout) :: myHexMesh
   INTEGER, INTENT(in)                  :: N
   
      CALL myHexMesh % UpdateDeviceElements(  )
                                                  
      CALL myHexMesh % nodes_dev % UpdateDevice( myHexMesh % nodes, &
                                                  myHexMesh % nNodes )
                                               
      CALL myHexMesh % faces_dev % UpdateDevice( myHexMesh % faces, &
                                                  N, myHexMesh % nFaces )
                                               
      CALL myHexMesh % geom_dev % UpdateDevice( myHexMesh % geom, &
                                                N, myHexMesh % nElems )
                                              
 END SUBROUTINE UpdateDevice_HexMesh_Cuda
!
 ATTRIBUTES(Host) SUBROUTINE UpdateDeviceElements_HexMesh_Cuda( myHexMesh )
 
   IMPLICIT NONE
   CLASS( HexMesh_Cuda ), INTENT(inout) :: myHexMesh
   ! Local
   INTEGER :: k
   INTEGER :: eIDs(1:myHexMesh % nElems)
   INTEGER :: nodeIDs(1:8,1:myHexMesh % nElems)
   INTEGER :: neighbors(1:6,1:myHexMesh % nElems)
   
      ! Construct entire "element attribute" arrays to prepare to copy to GPU
      DO k = 1, myHexMesh % nElems
         eIDs(k)          = myHexMesh % elements(k) % elementID
         nodeIDs(1:8,k)   = myHexMesh % elements(k) % nodeIDs(1:8)
         neighbors(1:6,k) = myHexMesh % elements(k) % neighbors(1:6)        
      ENDDO

      ! Copy entire array to GPU
      myHexMesh % elements_dev % elementID = eIDs
      myHexMesh % elements_dev % nodeIDs   = nodeIDs
      myHexMesh % elements_dev % neighbors = neighbors
      
 END SUBROUTINE UpdateDeviceElements_HexMesh_Cuda
!
 SUBROUTINE LoadDefaultMesh_HexMesh_Cuda( myHexMesh, interp, nXelem, nYelem, nZelem  )

   IMPLICIT NONE
   CLASS( HexMesh_Cuda ), INTENT(inout)  :: myHexMesh
   TYPE( Lagrange_Cuda ), INTENT(in)    :: interp
   INTEGER, INTENT(in)                   :: nXelem, nYelem, nZelem
   ! LOCAL
   TYPE( Surface ) :: boundSurfs(1:nHexFaces)

   REAL(prec) :: x, y, z, dxElem, dyElem, dzElem
   REAL(prec) :: x1(1:3), x2(1:3), x3(1:3), x4(1:3)
   REAL(prec) :: c1(1:3), c2(1:3)
   REAL(prec), ALLOCATABLE :: xc(:,:,:), s(:)

   INTEGER :: nNodes, nElems, nFaces, gPolyDeg
   INTEGER :: nodes(1:nHexNodes)
   INTEGER :: n1, n2, n3, n4
   INTEGER :: iNode, iEl, iSide, iX, iY, iZ, i, j

      
      dxElem = ONE/nXElem
      dyElem = ONE/nYElem
      dzElem = ONE/nZElem
      
      ! ** "Hard-wired" values for a structured mesh with no holes ** !
      nNodes   = (nXElem+1)*(nYElem+1)*(nZElem+1)
      nElems   = (nXElem)*(nYElem)*(nZElem)
      nFaces   = (nXElem)*(nYElem)*(nZElem+1) + (nXElem)*(nZElem)*(nYElem+1) + (nYElem)*(nZElem)*(nXElem+1)
      gPolyDeg = 1
      ! ************************************************************************* !

      PRINT*, 'nNodes    : ', nNodes
      PRINT*, 'nElems    : ', nElems
      PRINT*, 'gPolyDeg  : ', gPolyDeg

      ! Generate the chebyshev points of order gPolyDeg
      ! These are the points used to define the parametric
      ! curves for the element boundaries

      ALLOCATE( s(0:gPolyDeg), xc(0:gPolyDeg,0:gPolyDeg,1:3) )
      s(0) = -ONE
      s(1) = ONE
      
      ! ---- Initialize the mesh (empty) ---- !
      CALL myHexMesh % Initialize( nNodes, nElems, nFaces, interp % N ) 
      
      
      ! ---- Read in the corner nodes ---- !
      DO iZ = 1, nZElem + 1
         z = dZElem*(REAL(iZ-1,prec))
         DO iY = 1, nYElem+1
            y = dYElem*(REAL(iY-1,prec))
            DO iX = 1, nXElem+1
               iNode = iX + (iY-1)*(nXElem+1) + (iZ-1)*(nXElem+1)*(nYElem+1)
               x = dXElem*(REAL(iX-1,prec))
               myHexMesh % nodes(iNode) % x = x
               myHexMesh % nodes(iNode) % y = y
               myHexMesh % nodes(iNode) % z = z
               myHexMesh % nodes(iNode) % nodeID = iNode
            ENDDO
         ENDDO
      ENDDO
  
      ! Do the element information
      xc = ZERO
      ! Do the initial build for the parametric surfaces
      DO iSide = 1, nHexFaces
         CALL boundSurfs(iSide) % Build( xc, s, gPolyDeg, 3 ) 
      ENDDO
   
      DO iZ = 1, nZElem
         DO iY = 1, nYElem
            DO iX = 1, nXElem

               iEl = iX + (iY-1)*(nXElem) + (iZ-1)*(nXElem)*(nYElem)
               ! Calculate the global node IDs for this element.
               nodes(1) = iX + (iY-1)*(nXElem+1) + (iZ-1)*(nXElem+1)*(nYElem+1)    ! Southwest
               nodes(2) = iX + 1 + (iY-1)*(nXElem+1) + (iZ-1)*(nXElem+1)*(nYElem+1)! SouthEast
               nodes(3) = iX + 1 + (iY)*(nXElem+1) + (iZ-1)*(nXElem+1)*(nYElem+1)  ! NorthEast
               nodes(4) = iX + (iY)*(nXElem+1) + (iZ-1)*(nXElem+1)*(nYElem+1)      ! NorthWest
               nodes(5) = iX + (iY-1)*(nXElem+1) + (iZ)*(nXElem+1)*(nYElem+1)      ! Southwest
               nodes(6) = iX + 1 + (iY-1)*(nXElem+1) + (iZ)*(nXElem+1)*(nYElem+1)  ! SouthEast
               nodes(7) = iX + 1 + (iY)*(nXElem+1) + (iZ)*(nXElem+1)*(nYElem+1)    ! NorthEast
               nodes(8) = iX + (iY)*(nXElem+1) + (iZ)*(nXElem+1)*(nYElem+1)        ! NorthWest

               myHexMesh % elements(iEl) % nodeIDs = nodes
         
               DO iSide = 1, nHexFaces ! Loop over the sides of the quads

                  ! To build the current face, we construct a plane that passes through
                  ! the four corner nodes. Here, we grab the global node ID's for the four
                  ! corner nodes.
                  n1 = nodes( myHexMesh % faceMap(1,iSide) )
                  n2 = nodes( myHexMesh % faceMap(2,iSide) )
                  n3 = nodes( myHexMesh % faceMap(3,iSide) ) 
                  n4 = nodes( myHexMesh % faceMap(4,iSide) ) 

                  x1(1) = myHexMesh % nodes(n1) % x
                  x1(2) = myHexMesh % nodes(n1) % y
                  x1(3) = myHexMesh % nodes(n1) % z
                  
                  x2(1) = myHexMesh % nodes(n2) % x
                  x2(2) = myHexMesh % nodes(n2) % y
                  x2(3) = myHexMesh % nodes(n2) % z
                  
                  x3(1) = myHexMesh % nodes(n3) % x
                  x3(2) = myHexMesh % nodes(n3) % y
                  x3(3) = myHexMesh % nodes(n3) % z
                  
                  x4(1) = myHexMesh % nodes(n4) % x
                  x4(2) = myHexMesh % nodes(n4) % y
                  x4(3) = myHexMesh % nodes(n4) % z
                    
                  DO j = 0, gPolyDeg
                     DO i = 0, gPolyDeg
                     ! Transfinite inerpolation with linear blending is used to construct the face
                        c1 = ( HALF*(x2-x1)*(ONE+s(i)) + x1 ) 
                        c2 = ( HALF*(x3-x4)*(ONE+s(i)) + x4 )
                        xc(i,j,1:3) = HALF*(c2-c1)*(ONE+s(j)) + c1
                     ENDDO
                  ENDDO
                  CALL boundSurfs(iSide) % Reset( xc ) 

               ENDDO
               CALL myHexMesh % geom(iEl) % GenerateMesh( interp, boundSurfs )
               CALL myHexMesh % geom(iEl) % GenerateMetrics( interp )

            ENDDO
         ENDDO
      ENDDO ! iEl, cycle over the elements

      CALL myHexMesh % ConstructFaces( )
      nFaces = myHexMesh % nFaces
      PRINT*, 'nFaces    : ', nFaces

      CALL myHexMesh % ConstructElementNeighbors( )
      
      ! Clear up memory
      DEALLOCATE( s, xc )

      DO iSide = 1, nHexFaces
         CALL boundSurfs(iSide) % Trash( )
      ENDDO
  
      CALL myHexMesh % UpdateDevice( interp % N )
      
 END SUBROUTINE LoadDefaultMesh_HexMesh_Cuda
!
 SUBROUTINE ScaleTheMesh_HexMesh_Cuda( myHexMesh, interp, xScale, yScale, zScale  )

   IMPLICIT NONE
   CLASS( HexMesh_Cuda ), INTENT(inout) :: myHexMesh
   TYPE( Lagrange_Cuda ), INTENT(in)    :: interp
   REAL(prec), INTENT(in)          :: xScale, yScale, zScale
   ! LOCAL
   INTEGER :: i
   TYPE( Lagrange_Cuda ) :: localInterp
   
      CALL localInterp % Build( interp % N, interp % M, interp % s, interp % so )
   
      DO i = 1, myHexMesh % nElems
         CALL myHexMesh % geom(i) % ScaleGeometry( localInterp, xScale, yScale, zScale )
      ENDDO
      
      DO i = 1, myHexMesh % nNodes
         CALL myHexMesh % nodes(i) % ScalePosition( xScale, yScale, zScale )
      ENDDO
      
      CALL localInterp % Trash( )

 END SUBROUTINE ScaleTheMesh_HexMesh_Cuda
!
!
!==================================================================================================!
!--------------------------------- Mesh File I/O Routines -----------------------------------------!
!==================================================================================================!
!
!
 SUBROUTINE ReadPeaceMeshFile_HexMesh_Cuda( myHexMesh, filename )

   IMPLICIT NONE
   CLASS( HexMesh_Cuda ), INTENT(out)   :: myHexMesh
   CHARACTER(*), INTENT(in)             :: filename
   ! LOCAL
   INTEGER :: nNodes, nElems, nFaces, N
   INTEGER :: iFace, iNode, iEl
   INTEGER :: fUnit, k, i, j, l, row, col


      PRINT*, 'Mesh File : '//TRIM( filename )//'.pc.mesh'
      
      ! Get a new file unit
      OPEN( UNIT    = NEWUNIT(fUnit), &
            FILE    = TRIM( filename )//'.pc.mesh', &
            FORM    = 'UNFORMATTED',&
            STATUS  = 'OLD', &
            ACCESS  = 'DIRECT', &
            CONVERT = 'BIG_ENDIAN', &
            RECL    = SIZEOF(nNodes) ) ! How to do variable record length

      ! ---- Gather the number of nodes, number of elements, and number of edges ---- !
      k = 1
      READ( fUnit, rec=k )nNodes
      k = k+1
      READ( fUnit, rec=k )nElems
      k = k+1
      READ( fUnit, rec=k )nFaces
      k = k+1
      READ( fUnit, rec=k )N
      k = k+1

      PRINT*, 'nNodes    : ', nNodes
      PRINT*, 'nElems    : ', nElems
      PRINT*, 'nFaces    : ', nFaces
      PRINT*, 'N         : ', N
      ! ---- Initialize the quadrature mesh (empty) ---- !
      CALL myHexMesh % Initialize( nNodes, nElems, nFaces, N ) 
      
      ! ---- Read in the element connectivity ---- !
      DO iEl = 1, nElems
         READ( fUnit, rec=k ) myHexMesh % elements(iEl) % elementID 
         k = k+1
         DO i = 1, nHexNodes
            READ( fUnit, rec=k ) myHexMesh % elements(iEl) % nodeIDs(i)
            k = k+1
         ENDDO
      ENDDO 
      
      ! ---- Read in the face information ---- !

      DO iFace = 1, nFaces
         READ( fUnit, rec=k ) myHexMesh % faces(iFace) % faceID
         k = k+1
         READ( fUnit, rec=k ) myHexMesh % faces(iFace) % boundaryID
         k = k+1
         DO i = 1, 4
            READ( fUnit, rec=k ) myHexMesh % faces(iFace) % nodeIDs(i)
            k = k+1
         ENDDO
         DO i = 1, 2
            READ( fUnit, rec=k ) myHexMesh % faces(iFace) % elementIDs(i)
            k = k+1
            READ( fUnit, rec=k ) myHexMesh % faces(iFace) % elementSides(i)
            k = k+1
         ENDDO
         READ( fUnit, rec=k ) myHexMesh % faces(iFace) % iStart
         k = k+1
         READ( fUnit, rec=k ) myHexMesh % faces(iFace) % iInc
         k = k+1
         READ( fUnit, rec=k ) myHexMesh % faces(iFace) % jStart
         k = k+1
         READ( fUnit, rec=k ) myHexMesh % faces(iFace) % jInc
         k = k+1
         READ( fUnit, rec=k ) myHexMesh % faces(iFace) % swapDimensions
         k = k+1
      ENDDO
      
      CLOSE( fUnit )
      ! Get a new file unit
      OPEN( UNIT    = NEWUNIT(fUnit), &
            FILE    = TRIM( filename )//'.pc.geom', &
            FORM    = 'UNFORMATTED',&
            STATUS  = 'OLD', &
            ACCESS  = 'DIRECT', &
            CONVERT = 'BIG_ENDIAN', &
            RECL    = prec ) ! How to do variable record length
      
      ! ---- Read in the corner nodes ---- !
      k = 1
      DO iNode = 1, nNodes  ! Loop over the nodes in the file
         READ( fUnit, rec=k ) myHexMesh % nodes(iNode) % x
         k = k+1
         READ( fUnit, rec=k ) myHexMesh % nodes(iNode) % y
         k = k+1
         READ( fUnit, rec=k ) myHexMesh % nodes(iNode) % z
         k = k+1
      ENDDO

      ! ---- Read in the element information ---- !
      DO iEl = 1, nElems
         DO l = 0, N
            DO j = 0, N
               DO i = 0, N
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % x(i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % y(i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % z(i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % dxds(i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % dxdp(i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % dxdq(i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % dyds(i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % dydp(i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % dydq(i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % dzds(i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % dzdp(i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % dzdq(i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % J(i,j,l)
                  k = k+1
                  DO col = 1, 3
                     DO row = 1, 3
                        READ( fUnit, rec=k ) myHexMesh % geom(iEl) % Ja(i,j,l,row,col)
                        k = k+1
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
         DO l = 1, nHexFaces
            DO j = 0, N
               DO i = 0, N
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % xBound(i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % yBound(i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % zBound(i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % nHat(1,i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % nHat(2,i,j,l)
                  k = k+1
                  READ( fUnit, rec=k ) myHexMesh % geom(iEl) % nHat(3,i,j,l)
                  k = k+1
               ENDDO
            ENDDO
         ENDDO
      ENDDO 

      CLOSE( fUnit )
     
      CALL myHexMesh % ConstructElementNeighbors( )
  
      CALL myHexMesh % UpdateDevice( N )
      
 END SUBROUTINE ReadPeaceMeshFile_HexMesh_Cuda
!
 SUBROUTINE ReadUCDMeshFile_HexMesh_Cuda( myHexMesh, interp, filename )

   IMPLICIT NONE
   CLASS( HexMesh_Cuda ), INTENT(out)   :: myHexMesh
   TYPE( Lagrange_Cuda ), INTENT(in)         :: interp
   CHARACTER(*), INTENT(in)             :: filename
   ! LOCAL
   CHARACTER(60) :: longDummy
   CHARACTER(3)  :: shortDummy
   INTEGER :: nNodes, nElems, nFaces
   INTEGER :: iFace, iNode, iEl, iSide
   INTEGER :: fUnit, k, i, j, l, row, col, n1, n2, n3, n4
   REAL(prec) :: xc(0:1,0:1,1:3), s(0:1)
   REAL(prec) :: x1(1:3), x2(1:3), x3(1:3), x4(1:3), c1(1:3), c2(1:3)
   TYPE( Surface ) :: boundSurfs(1:nHexFaces)


      PRINT*, 'Mesh File : '//TRIM( filename )
      
      ! Get a new file unit
      OPEN( UNIT    = NEWUNIT(fUnit), &
            FILE    = TRIM( filename ), &
            FORM    = 'FORMATTED',&
            STATUS  = 'OLD', &
            ACCESS  = 'SEQUENTIAL' ) 
 
      READ( fUnit, * ) longDummy
      WRITE( *, * ) longDummy
      
      READ( fUnit, * ) longDummy
      WRITE( *, * ) longDummy
      
      READ( fUnit, * ) longDummy
      WRITE( *, * ) longDummy
      
      READ( fUnit, * ) nNodes, nElems, i, j, l ! i,j, and l are just fillers for now.
      
      
      ! ---- Gather the number of nodes, number of elements, and number of edges ---- !
      ! Default nFaces = 1 for initial build
      nFaces = 1

      PRINT*, 'nNodes    : ', nNodes
      PRINT*, 'nElems    : ', nElems
      PRINT*, 'N         : ', interp % N
      ! ---- Initialize the quadrature mesh (empty) ---- !
      CALL myHexMesh % Initialize( nNodes, nElems, nFaces, interp % N ) 
      
      ! Read in the corner node positions
      DO iNode = 1, nNodes
         READ( fUnit, * ) myHexMesh % nodes(iNode) % nodeID, &
                          myHexMesh % nodes(iNode) % x, &
                          myHexMesh % nodes(iNode) % y, &
                          myHexMesh % nodes(iNode) % z
      ENDDO
      
      ! ---- Read in the element connectivity ---- !
      DO iEl = 1, nElems
         myHexMesh % elements(iEl) % elementID = iEl
         READ( fUnit, * ) i, j, shortDummy, &
                          myHexMesh % elements(iEl) % nodeIDs(1:8)
      ENDDO 
      CLOSE( fUnit )
      
      CALL myHexMesh % ConstructFaces( )
      CALL myHexMesh % ConstructElementNeighbors( )
      
     ! Do the element information
      s(0) = -1.0_prec
      s(1) = 1.0_prec
      xc   = 0.0_prec
      ! Do the initial build for the parametric surfaces
      DO iSide = 1, nHexFaces
         CALL boundSurfs(iSide) % Build( xc, s, 1, 3 ) 
      ENDDO
      
      
      ! For now, we assume tri-linear mappings so that the geometry can be constructed
      ! using only the corner node locations. These corner nodes will be used to generate 
      ! the bounding surfaces for each element, and transfinite interpolation with linear
      ! blending is used to construct the internal mesh geometry.
      DO iEl = 1, nElems
      
          DO iSide = 1, nHexFaces ! Loop over the sides of the quads

             ! To build the current face, we construct a plane that passes through
             ! the four corner nodes. Here, we grab the global node ID's for the four
             ! corner nodes.
             n1 = myHexMesh % elements(iEl) % nodeIDs( myHexMesh % faceMap(1,iSide) )
             n2 = myHexMesh % elements(iEl) % nodeIDs( myHexMesh % faceMap(2,iSide) )
             n3 = myHexMesh % elements(iEl) % nodeIDs( myHexMesh % faceMap(3,iSide) ) 
             n4 = myHexMesh % elements(iEl) % nodeIDs( myHexMesh % faceMap(4,iSide) ) 

             x1(1) = myHexMesh % nodes(n1) % x
             x1(2) = myHexMesh % nodes(n1) % y
             x1(3) = myHexMesh % nodes(n1) % z
               
             x2(1) = myHexMesh % nodes(n2) % x
             x2(2) = myHexMesh % nodes(n2) % y
             x2(3) = myHexMesh % nodes(n2) % z
               
             x3(1) = myHexMesh % nodes(n3) % x
             x3(2) = myHexMesh % nodes(n3) % y
             x3(3) = myHexMesh % nodes(n3) % z
               
             x4(1) = myHexMesh % nodes(n4) % x
             x4(2) = myHexMesh % nodes(n4) % y
             x4(3) = myHexMesh % nodes(n4) % z
                 
             DO j = 0, 1
                DO i = 0, 1
                   ! Transfinite inerpolation with linear blending is used to construct the face
                   c1 = ( HALF*(x2-x1)*(ONE+s(i)) + x1 ) 
                   c2 = ( HALF*(x3-x4)*(ONE+s(i)) + x4 )
                   xc(i,j,1:3) = HALF*(c2-c1)*(ONE+s(j)) + c1
                ENDDO
             ENDDO
             CALL boundSurfs(iSide) % Reset( xc ) 

          ENDDO
          CALL myHexMesh % geom(iEl) % GenerateMesh( interp, boundSurfs )
          CALL myHexMesh % geom(iEl) % GenerateMetrics( interp )
      
      ENDDO
      
      
      DO iSide = 1, nHexFaces
         CALL boundSurfs(iSide) % Trash( ) 
      ENDDO
      
      CALL myHexMesh % UpdateDevice( interp % N )
  
 END SUBROUTINE ReadUCDMeshFile_HexMesh_Cuda
!
END MODULE HexMesh_Cuda_Class
