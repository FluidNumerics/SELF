! Node_Cuda_Class.f90
! 
! Copyright 2015 Joseph Schoonover <schoonover.numerics@gmail.com>, The Florida State University
! Copyright 2016 Joseph Schoonover <jschoonover@lanl.gov>, Los Alamos National Laboratory
!
! The SELF and accompanying documentation were produced in part under the 
! support of Florida State University and the National Science Foundation 
! through Grant OCE-1049131 during 2015 and in part under the support of the 
! Center for Nonlinear Studies and the Department of Energy through the 
! LANL/LDRD program in 2016.
!
! Node_Cuda_Class.f90 is part of the Spectral Element Libraries in Fortran (SELF).
! 
! Licensed under the Apache License, Version 2.0 (the "License"); 
! You may obtain a copy of the License at 
!
! http://www.apache.org/licenses/LICENSE-2.0 
!
! Unless required by applicable law or agreed to in writing, software 
! distributed under the License is distributed on an "AS IS" BASIS, 
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
! See the License for the specific language governing permissions and  
! limitations under the License.
!
! //////////////////////////////////////////////////////////////////////////////////////////////// !

MODULE Node_Cuda_Class

! src/common/
USE ModelPrecision
! src/geom/
USE Node_Class

IMPLICIT NONE

   TYPE Node_Cuda
      
      INTEGER, DEVICE, ALLOCATABLE    :: nodeID_dev(:)
      INTEGER, DEVICE, ALLOCATABLE    :: nodeType_dev(:) ! An INTEGER flag for INTERIOR or BOUNDARY
      REAL(prec), DEVICE, ALLOCATABLE :: x_dev(:,:)

      CONTAINS

      PROCEDURE :: Build => Build_Node_Cuda
      PROCEDURE :: Trash => Trash_Node_Cuda
      
      PROCEDURE :: UpdateDevice => UpdateDevice_Node_Cuda
      
   END TYPE Node_Cuda

   INTEGER, CONSTANT :: nNodes_dev
 CONTAINS
!
!
!==================================================================================================!
!------------------------------- Manual Constructors/Destructors ----------------------------------!
!==================================================================================================!
!
!
 ATTRIBUTES(Host) SUBROUTINE Build_Node_Cuda( myNodes, nNodes )

   IMPLICIT NONE
   CLASS( Node_Cuda ), INTENT(out) :: myNodes
   INTEGER, INTENT(in)             :: nNodes

      ALLOCATE( myNodes % nodeID_dev(1:nNodes), &
                myNodes % nodeType_dev(1:nNodes), &
                myNodes % x_dev(1:3,1:nNodes) )
                
      myNodes % nodeID_dev   = 0
      myNodes % nodeType_dev = 0
      myNodes % x_dev        = 0.0_prec
      
      nNodes_dev = nNodes
     
 END SUBROUTINE Build_Node_Cuda
!
 ATTRIBUTES(Host) SUBROUTINE Trash_Node_Cuda( myNodes )
 
   IMPLICIT NONE
   CLASS( Node_Cuda ), INTENT(inout) :: myNodes
   
      DEALLOCATE( myNodes % nodeID_dev, &
                  myNodes % nodeType_dev, &
                  myNodes % x_dev )
   
 END SUBROUTINE Trash_Node_Cuda
!
!
!==================================================================================================!
!--------------------------------- Type-Specific Routines  ----------------------------------------!
!==================================================================================================!
!
!
 ATTRIBUTES(Host) SUBROUTINE UpdateDevice_Node_Cuda( myNodes, cpuNodeArray, nNodes )
 
   IMPLICIT NONE
   CLASS( Node_Cuda ), INTENT(inout) :: myNodes
   INTEGER, INTENT(in)               :: nNodes
   TYPE( Node ), INTENT(in)          :: cpuNodeArray(1:nNodes)
   !Local
   INTEGER :: i
   INTEGER :: nodeIDs(1:nNodes)
   INTEGER :: nodeTypes(1:nNodes)
   REAL(prec) :: x(1:3,1:nNodes)
   
      DO i = 1, nNodes
         nodeIDs(i)   = cpuNodeArray(i) % nodeID
         nodeTypes(i) = cpuNodeArray(i) % nodeType
         x(1:3,i)     = (/ cpuNodeArray(i) % x, &
                           cpuNodeArray(i) % y, &
                           cpuNodeArray(i) % z /)
      ENDDO

      myNodes % nodeID_dev   = nodeIDs
      myNodes % nodeType_dev = nodeTypes
      myNodes % x_dev        = x
      
 END SUBROUTINE UpdateDevice_Node_Cuda

END MODULE Node_Cuda_Class
