! Edge_Cuda_Class.f90
! 
! Copyright 2017 Joseph Schoonover <joe@fluidnumerics.consulting>, Fluid Numerics LLC
! All rights reserved.
!
! //////////////////////////////////////////////////////////////////////////////////////////////// !



MODULE Edge_Cuda_Class

! src/common/
USE ModelPrecision
! src/geom/
USE Edge_Class

IMPLICIT NONE

   TYPE Edge_Cuda

      INTEGER, DEVICE, ALLOCATABLE :: edgeID(:)            ! The Edge ID
      INTEGER, DEVICE, ALLOCATABLE :: boundaryID(:)        ! If the Edge_Cuda is part of the mesh boundary, the Edge_Cuda gets assigned a boundary Edge_Cuda ID
      INTEGER, DEVICE, ALLOCATABLE :: nodeIDs(:,:)         ! Node IDs which start and terminate this Edge_Cuda
      INTEGER, DEVICE, ALLOCATABLE :: elementIDs(:,:)      ! Neighboring elements IDs across the Edge_Cuda
      INTEGER, DEVICE, ALLOCATABLE :: elementSides(:,:)    ! Local side IDs for the neighboring elements
      INTEGER, DEVICE, ALLOCATABLE :: start(:), inc(:)     ! Loop start and increment for the secondary element side (1st computational direction)

      CONTAINS
      
      PROCEDURE :: Build => Build_Edge_Cuda
      PROCEDURE :: Trash => Trash_Edge_Cuda
      
      PROCEDURE :: UpdateDevice => UpdateDevice_Edge_Cuda
      
   END TYPE Edge_Cuda

   INTEGER, CONSTANT :: nEdges_dev


 CONTAINS
!
!
!==================================================================================================!
!------------------------------- Manual Constructors/Destructors ----------------------------------!
!==================================================================================================!
!
!
 ATTRIBUTES(Host)SUBROUTINE Build_Edge_Cuda( myEdge, N, nEdges )

   IMPLICIT NONE
   CLASS( Edge_Cuda ), INTENT(out) :: myEdge
   INTEGER, INTENT(in)             :: N, nEdges
   
      ALLOCATE( myEdge % edgeID(1:nEdges), &
                myEdge % boundaryID(1:nEdges), &
                myEdge % nodeIDs(1:2,1:nEdges), &
                myEdge % elementIDs(1:2,1:nEdges), &
                myEdge % elementSides(1:2,1:nEdges),&
                myEdge % start(1:nEdges), &
                myEdge % inc(1:nEdges) )
     
      nEdges_dev = nEdges
      
 END SUBROUTINE Build_Edge_Cuda
!
 ATTRIBUTES(Host) SUBROUTINE Trash_Edge_Cuda( myEdge )

   IMPLICIT NONE
   CLASS( Edge_Cuda ) :: myEdge

      DEALLOCATE( myEdge % edgeID, &
                  myEdge % boundaryID, &
                  myEdge % nodeIDs, &
                  myEdge % elementIDs, &
                  myEdge % elementSides,&
                  myEdge % start, &
                  myEdge % inc )
  
 END SUBROUTINE Trash_Edge_Cuda
!
 ATTRIBUTES(Host) SUBROUTINE UpdateDevice_Edge_Cuda( myEdge, cpuEdgeArray, N, nEdges )
 
   IMPLICIT NONE
   CLASS( Edge_Cuda ), INTENT(inout) :: myEdge
   INTEGER, INTENT(in)               :: N, nEdges
   TYPE( Edge ), INTENT(in)          :: cpuEdgeArray(1:nEdges)
   ! Local
   INTEGER :: k
   
      DO k = 1, nEdges
         myEdge % edgeID(k)         = cpuEdgeArray(k) % edgeID
         myEdge % boundaryID(k)     = cpuEdgeArray(k) % boundaryID
         myEdge % nodeIDs(1:2,k)    = cpuEdgeArray(k) % nodeIDs
         myEdge % elementIDs(1:2,k) = cpuEdgeArray(k) % elementIDs
         myEdge % start(k)          = cpuEdgeArray(k) % start
         myEdge % inc(k)            = cpuEdgeArray(k) % inc
      ENDDO

 END SUBROUTINE UpdateDevice_Edge_Cuda
END MODULE Edge_Cuda_Class
