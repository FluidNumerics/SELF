! NodalStorage_Cuda_Class.cuf
! 
! Copyright 2015 Joseph Schoonover <schoonover.numerics@gmail.com>, The Florida State University
! Copyright 2016 Joseph Schoonover <jschoonover@lanl.gov>, Los Alamos National Laboratory
!
! The SELF and accompanying documentation were produced in part under the 
! support of Florida State University and the National Science Foundation 
! through Grant OCE-1049131 during 2015 and in part  the support of the 
! Center for Nonlinear Studies and the Department of Energy through the 
! LANL/LDRD program in 2016.
!
! NodalStorage_Cuda_Class.cuf is part of the Spectral Element Libraries in Fortran (SELF).
! 
! Licensed under the Apache License, Version 2.0 (the "License"); 
! You may obtain a copy of the License at 
!
! http://www.apache.org/licenses/LICENSE-2.0 
!
! Unless required by applicable law or agreed to in writing, software 
! distributed under the License is distributed on an "AS IS" BASIS, 
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
! See the License for the specific language governing permissions and  
! limitations under the License.
!
! //////////////////////////////////////////////////////////////////////////////////////////////// !

MODULE NodalStorage_Cuda_Class

! src/common/
 USE ModelPrecision
 USE ConstantsDictionary
 USE CommonRoutines
! src/spectralops
 USE Quadrature
! src/spectralops/cuda/
 USE Lagrange_Cuda_Class

IMPLICIT NONE


   ! To port this data structure to the GPU with cuda, I chose not to do a type-extension
   ! because of the dependency on the "Lagrange_Cuda" data structure, which already has
   ! its data mapped to the GPU
   TYPE NodalStorage_Cuda
      INTEGER                          :: N, nPlot
      TYPE(Lagrange_Cuda)              :: interp      ! Lagrange interpolant
      REAL(prec), ALLOCATABLE          :: qWeight(:)  ! Quadrature weights for integration
      REAL(prec), ALLOCATABLE          :: dMatS(:,:)  ! Derivative matrix
      REAL(prec), ALLOCATABLE          :: dMatP(:,:)  ! Derivative matrix
      REAL(prec), ALLOCATABLE          :: bMat(:,:)   ! Matrix for interpolating functions to boundaries of 
                                             ! an element
      ! ////// Device Arrays ////// !
      REAL(prec), ALLOCATABLE, DEVICE  :: qWeight_dev(:)  ! Quadrature weights for integration
      REAL(prec), ALLOCATABLE, DEVICE  :: dMatP_dev(:,:)  ! Derivative matrix
      REAL(prec), ALLOCATABLE, DEVICE  :: bMat_dev(:,:)   ! Matrix for interpolating functions to boundaries of 
                                             ! an element
      ! /////////////////////////// !
      CONTAINS

      ! Manual Constructors/Destructors
      PROCEDURE :: Build => Build_NodalStorage_Cuda
      PROCEDURE :: Trash => Trash_NodalStorage_Cuda

      
    END TYPE NodalStorage_Cuda
    
 CONTAINS
!
!
!==================================================================================================!
!------------------------------- Manual Constructors/Destructors ----------------------------------!
!==================================================================================================!
!
!
 ATTRIBUTES(Host) SUBROUTINE Build_NodalStorage_Cuda( myNodal, N, nPlot, quadrature, approxForm  )

   IMPLICIT NONE
   CLASS(NodalStorage_Cuda), INTENT(inout) :: myNodal
   INTEGER, INTENT(in)                :: N, nPlot, quadrature, approxForm
   !LOCAL
   INTEGER                 :: i, j
   REAL(prec):: tempS(0:N), tempQ(0:N), tempUni(0:nPlot)

      myNodal % N     = N
      myNodal % nPlot = nPlot
      
      ! Allocate space
      ALLOCATE( myNodal % dMatS(0:N,0:N), &
                myNodal % dMatP(0:N,0:N), &
                myNodal % bMat(0:N,0:1), &
                myNodal % qWeight(0:N) )
                
      myNodal % dMatS   = ZERO
      myNodal % dMatP   = ZERO
      myNodal % bMat    = ZERO
      myNodal % qWeight = ZERO

      tempS   = 0.0_prec
      tempUni = 0.0_prec
      tempQ   = 0.0_prec
      ! Generate the quadrature
      CALL LegendreQuadrature( N, tempS, tempQ, quadrature )
      myNodal % qWeight = tempQ      
       
      ! Build and store the interpolant
      tempUni = UniformPoints( -ONE, ONE, nPlot )

      CALL myNodal % interp % Build( N, nPlot, tempS, tempUni )
   
      ! Calculate and store the interpolants evaluated at the endpoints
      myNodal % bMat(0:N,0) = myNodal % interp % CalculateLagrangePolynomials( -ONE )
      myNodal % bMat(0:N,1) = myNodal % interp % CalculateLagrangePolynomials( ONE )
      
      IF( approxForm == CG )then ! Continuous Galerkin, store the derivative matrices as is

         myNodal % dMatS = myNodal % interp % D
         myNodal % dMatP = myNodal % interp % DTr

      ELSEIF( approxForm == DG )then
      
         ! For Discontinuous Galerkin, the matrix is transposed and multiplied by a ratio of quadrature
         ! weights.
        DO j = 0, N ! loop over the matrix rows
            DO i = 0, N ! loop over the matrix columns

               myNodal % dMatS(i,j) = -myNodal % interp % D(j,i)*&
                                         myNodal % qWeight(j)/&
                                         myNodal % qWeight(i)

            ENDDO
         ENDDO
         
         DO j = 0, N ! loop over the matrix rows
            DO i = 0, N ! loop over the matrix columns

               ! Here, we are purposefully using the transpose of the p-derivative matrix
               ! to conform with a new version of "MappedTimeDerivative"
               myNodal % dMatP(j,i) = myNodal % dMatS(i,j)

            ENDDO
         ENDDO
        
         
      ELSE

         PRINT*,'Module NodalStorage_Cuda_Class.cuf : S/R BuildNodalStorage_Cuda : Invalid SEM form. Stopping'
         STOP

      ENDIF

      ! Allocate the device arrays
      ALLOCATE( myNodal % dMatP_dev(0:N,0:N), &
                myNodal % bMat_dev(0:N,0:1), &
                myNodal % qWeight_dev(0:N) )
                
      ! Copy from the host to the device
      myNodal % dMatP_dev   = myNodal % dMatP
      myNodal % bMat_dev    = myNodal % bMat
      myNodal % qWeight_dev = myNodal % qWeight
      
 END SUBROUTINE Build_NodalStorage_Cuda
!
!> \addtogroup NodalStorage_Cuda_Class 
!! @{ 
! ================================================================================================ !
! S/R Trash
! 
!> \fn Trash_NodalStorage_Cuda  
!! Frees memory held by the attributes of the NodalStorage_Cuda class. 
!! 
!! <H2> Usage : </H2> 
!! <B>TYPE</B>(NodalStorage_Cuda) :: this <BR>
!!         .... <BR>
!!     <B>CALL</B> this % Trash( ) <BR>
!! 
!!  <H2> Parameters : </H2>
!!  <table> 
!!   <tr> <td> in/out <th> myNodal <td> NodalStorage_Cuda <td>
!!                         On <B>input</B>, a NodalStorage_Cuda class that has previously been 
!!                         constructed. <BR>
!!                         On <B>output</B>, the memory held by the attributes of this 
!!                         data-structure have been freed.
!!                                                           
!!  </table>  
!!   
! ================================================================================================ ! 
!>@}
 ATTRIBUTES(Host) SUBROUTINE Trash_NodalStorage_Cuda( myNodal )

   IMPLICIT NONE
   CLASS(NodalStorage_Cuda), INTENT(inout) :: myNodal

   CALL myNodal % interp % Trash( )
   DEALLOCATE( myNodal % qWeight, myNodal % dMatS, myNodal % dMatP, myNodal % bMat )
   
   DEALLOCATE( myNodal % qWeight_dev, myNodal % dMatP_dev, myNodal % bMat_dev )


 END SUBROUTINE Trash_NodalStorage_Cuda
!
!
!==================================================================================================!
!--------------------------- Type Specific Routines -----------------------------------------------!
!==================================================================================================!
!
!
!
END MODULE NodalStorage_Cuda_Class
