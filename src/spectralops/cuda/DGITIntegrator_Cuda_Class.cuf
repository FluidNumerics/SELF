! DGITIntegrator_Cuda_Class.f90
! 
! Copyright 2017 Joseph Schoonover <joe@fluidnumerics.consulting>, Fluid Numerics LLC
! All rights reserved.
!
! //////////////////////////////////////////////////////////////////////////////////////////////// !

MODULE DGITIntegrator_Cuda_Class

! src/common/
 USE ModelPrecision
 USE ConstantsDictionary
 USE CommonRoutines
! src/spectralops
 USE Quadrature
 USE Lagrange_Cuda_Class

IMPLICIT NONE

   TYPE DGITIntegrator_Cuda
      INTEGER                 :: N
      REAL(prec)              :: stepSize 
      TYPE(Lagrange_Cuda)     :: interp            ! Lagrange interpolant
      REAL(prec), ALLOCATABLE :: rVector(:)        ! Weights for initial condition
      REAL(prec), ALLOCATABLE :: gMat(:,:)         ! Derivative matrix
      REAL(prec), ALLOCATABLE :: prolongMat(:)     ! Matrix for interpolating functions to the "right" side of an element 
      REAL(prec), ALLOCATABLE :: integratorMat(:,:)! Matrix for forward stepping DGIT solver
     
      ! ////// Device Arrays ////// !
      REAL(prec), ALLOCATABLE, DEVICE :: rVector_dev(:)
      REAL(prec), ALLOCATABLE, DEVICE :: gMat_dev(:,:)
      REAL(prec), ALLOCATABLE, DEVICE :: prolongMat_dev(:)
      REAL(prec), ALLOCATABLE, DEVICE :: integratorMat_dev(:,:)
      CONTAINS

      ! Manual Constructors/Destructors
      PROCEDURE :: Build => Build_DGITIntegrator_Cuda
      PROCEDURE :: Trash => Trash_DGITIntegrator_Cuda

      
    END TYPE DGITIntegrator_Cuda
    
 CONTAINS
!
!
!==================================================================================================!
!------------------------------- Manual Constructors/Destructors ----------------------------------!
!==================================================================================================!
!
!
 SUBROUTINE Build_DGITIntegrator_Cuda( myNodal, N, stepSize, quadrature  )

   IMPLICIT NONE
   CLASS(DGITIntegrator_Cuda), INTENT(out) :: myNodal
   INTEGER, INTENT(in)                :: N
   REAL(prec), INTENT(in)             :: stepSize
   INTEGER, INTENT(in)                :: quadrature
   !LOCAL
   INTEGER                 :: i, j, INFO
   REAL(prec), ALLOCATABLE :: tempS(:), tempQ(:), tempL(:), tempR(:), tempMat(:,:), WORK(:)
   INTEGER, ALLOCATABLE    :: IPIV(:)

      myNodal % N        = N
      myNodal % stepSize = stepSize
      
      ! Allocate space
      ALLOCATE( myNodal % rVector(0:N), &
                myNodal % gMat(0:N,0:N), &
                myNodal % prolongMat(0:N), &
                myNodal % integratorMat(0:N,0:N) )
                
      myNodal % rVector       = 0.0_prec
      myNodal % gMat          = 0.0_prec
      myNodal % prolongMat    = 0.0_prec
      myNodal % integratorMat = 0.0_prec

      ALLOCATE( tempS(0:N), tempQ(0:N), tempL(0:N), tempR(0:N), tempMat(0:N,0:N) )
      tempS   = 0.0_prec
      tempQ   = 0.0_prec
      tempL   = 0.0_prec
      tempR   = 0.0_prec
      tempMat = 0.0_prec

      ALLOCATE( IPIV(1:N+1), WORK(1:N+1) )
      ! Generate the quadrature
      CALL LegendreQuadrature( N, tempS, tempQ, quadrature )
       

      CALL myNodal % interp % Build( N, N, tempS, tempS )
   
      ! Calculate and store the interpolants evaluated at the endpoints
      tempR = myNodal % interp % CalculateLagrangePolynomials( 1.0_prec )
      tempL = myNodal % interp % CalculateLagrangePolynomials( -1.0_prec )
      
       ! For Discontinuous Galerkin, the matrix is transposed and multiplied by a ratio of quadrature
       ! weights.
      DO j = 0, N ! loop over the matrix rows
         DO i = 0, N ! loop over the matrix columns

            myNodal % gMat(i,j) = tempR(i)*tempR(j)/tempQ(i) - &
                                  myNodal % interp % D(j,i)*tempQ(j)/tempQ(i)
 
            tempMat(i,j) =stepsize*0.5_prec*( tempR(i)*tempR(j)/tempQ(i) - &
                                              myNodal % interp % D(j,i)*tempQ(j)/tempQ(i) )

         ENDDO
         myNodal % rVector(j)    = tempL(j)/tempQ(j)
         myNodal % prolongMat(j) = tempR(j)
         tempMat(j,j)            = tempMat(j,j) + 1.0_prec
      ENDDO
      
      

      ! Invert the integrator matrix
      CALL DGETRF( N+1, N+1, tempMat, N+1, IPIV, INFO )
      CALL DGETRI( N+1, tempMat, N+1, IPIV, WORK, N+1, INFO )

      myNodal % integratorMat = tempMat


      DEALLOCATE( tempS, tempQ, tempL, tempR, tempMat )
      ALLOCATE( IPIV(1:N+1), WORK(1:N+1) )

      myNodal % gMat_dev          = myNodal % gMat
      myNodal % rVector_dev       = myNodal % rVector
      myNodal % prolongMat_dev    = myNodal % prolongMat
      myNodal % integratorMat_dev = myNodal % integratorMat

 END SUBROUTINE Build_DGITIntegrator_Cuda
!
 SUBROUTINE Trash_DGITIntegrator_Cuda( myNodal)

   IMPLICIT NONE
   CLASS(DGITIntegrator_Cuda), INTENT(inout) :: myNodal

   CALL myNodal % interp % Trash( )
   DEALLOCATE( myNodal % rVector, myNodal % gMat, myNodal % prolongMat, myNodal % integratorMat )
   DEALLOCATE( myNodal % rVector_dev, myNodal % gMat_dev, myNodal % prolongMat_dev, myNodal % integratorMat_dev )


 END SUBROUTINE Trash_DGITIntegrator_Cuda
!
!
!==================================================================================================!
!--------------------------- Type Specific Routines -----------------------------------------------!
!==================================================================================================!
!
!
END MODULE DGITIntegrator_Cuda_Class
