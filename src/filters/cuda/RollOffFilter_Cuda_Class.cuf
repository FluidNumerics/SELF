! RollOffFilter_Cuda_Class.cuf
! 
! Copyright 2017 Joseph Schoonover <joe@fluidnumerics.consulting>, Fluid Numerics LLC
! All rights reserved.
!
! RollOffFilter_Cuda_Class.cuf is part of the Spectral Element Libraries in Fortran for Fluids (SELF-Fluids).
!
! //////////////////////////////////////////////////////////////////////////////////////////////// !


MODULE RollOffFilter_Cuda_Class

! src/common/
USE ModelPrecision
USE ConstantsDictionary
USE CommonRoutines
! src/spectralops/
USE Quadrature
! src/filters/
USE RollOffFilter_Class

IMPLICIT NONE


   TYPE, EXTENDS( RollOffFilter ) :: RollOffFilter_Cuda
      REAL(prec), DEVICE, ALLOCATABLE :: filterMat_dev(:,:)
      
      CONTAINS
  
      PROCEDURE :: Build => Build_RollOffFilter_Cuda
      PROCEDURE :: Trash => Trash_RollOffFilter_Cuda

   END TYPE RollOffFilter_Cuda

 INTEGER, CONSTANT :: nCutoff_dev

CONTAINS
!
!
!==================================================================================================!
!------------------------------- Manual Constructors/Destructors ----------------------------------!
!==================================================================================================!
!
!
 SUBROUTINE Build_RollOffFilter_Cuda( thisFilter, s, w, N, nCutoff )

   IMPLICIT NONE
   CLASS(RollOffFilter_Cuda), INTENT(inout) :: thisFilter
   INTEGER, INTENT(in)                 :: N, nCutoff
   REAL(prec), INTENT(in)              :: s(0:N)
   REAL(prec), INTENT(in)              :: w(0:N)
   ! Local
   REAL(prec)              :: Lnorm, Li, Ls, sc, alpha, r
   REAL(prec), ALLOCATABLE :: Pfilt(:,:), V(:,:), VInv(:,:)
   INTEGER                 :: row, col 
   
      thisFilter % N       = N
      thisFilter % nCutoff = nCutoff
      thisFilter % nPacked = (N+1)*(N+1)-1

      ALLOCATE( thisFilter % filterMat(0:N,0:N) )

      ALLOCATE( Pfilt(0:N,0:N), V(0:N,0:N), VInv(0:N,0:N) )

      thisFilter % filterMat = ZERO

      Pfilt = ZERO
      V     = ZERO
      VInv  = ZERO

      sc = real(nCutoff,prec)
      alpha = 1.0_prec
      DO row = 0, N 
 
         r = real(row,prec)
         Pfilt(row,row) = 0.5_prec*( 1.0_prec-tanh( (r-nCutoff)/alpha ) )
         Lnorm = ZERO

         DO col = 0, N

            CALL LegendrePolynomial( row, s(col), Li, Ls)

            Lnorm = Lnorm + Li*Li*w(col)
            V(row,col) = Li*w(col)
            ! The inverse of the modal projection matrix is easy to build since the Legendre basis
            ! is an orthogonal basis
            VInv(col,row) = Li
              
         ENDDO
            V(row,0:N) = V(row,0:N)/Lnorm
      ENDDO

      Pfilt = MATMUL( Pfilt, V )
      V = MATMUL( VInv, Pfilt )
      thisFilter % filterMat = TRANSPOSE( V )
      
      DEALLOCATE( V, Pfilt, Vinv )

      ! Device array
      ALLOCATE( thisFilter % filterMat_dev(0:N,0:N) )
      thisFilter % filterMat_dev = thisFilter % filterMat
      
 END SUBROUTINE Build_RollOffFilter_Cuda
!
 SUBROUTINE Trash_RollOffFilter_Cuda( thisFilter )

   IMPLICIT NONE
   CLASS(RollOffFilter_Cuda), INTENT(inout) :: thisFilter
   
      DEALLOCATE( thisFilter % filterMat )
      DEALLOCATE( thisFilter % filterMat_dev )

 END SUBROUTINE Trash_RollOffFilter_Cuda
!
!
!==================================================================================================!
!------------------------------------- Type Specific ----------------------------------------------!
!==================================================================================================!
!
! 
END MODULE RollOffFilter_Cuda_Class
