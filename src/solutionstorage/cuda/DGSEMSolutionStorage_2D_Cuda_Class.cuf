! DGSEMSolutionStorage_2D_Cuda_Class.cuf
! 
! Copyright 2015 Joseph Schoonover <schoonover.numerics@gmail.com>, The Florida State University
! Copyright 2016 Joseph Schoonover <jschoonover@lanl.gov>, Los Alamos National Laboratory
!
! The SELF and accompanying documentation were produced in part under the 
! support of Florida State University and the National Science Foundation 
! through Grant OCE-1049131 during 2015 and in part  the support of the 
! Center for Nonlinear Studies and the Department of Energy through the 
! LANL/LDRD program in 2016.
!
! DGSEMSolutionStorage_2D_Cuda_Class.cuf is part of the Spectral Element Libraries in Fortran (SELF).
! 
! Licensed under the Apache License, Version 2.0 (the "License"); 
! You may obtain a copy of the License at 
!
! http://www.apache.org/licenses/LICENSE-2.0 
!
! Unless required by applicable law or agreed to in writing, software 
! distributed under the License is distributed on an "AS IS" BASIS, 
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
! See the License for the specific language governing permissions and  
! limitations under the License.
!
! //////////////////////////////////////////////////////////////////////////////////////////////// !


MODULE DGSEMSolutionStorage_2D_Cuda_Class

! src/common/
USE ModelPrecision

IMPLICIT NONE



    TYPE :: DGSEMSolution_2D_Cuda
      REAL(prec), ALLOCATABLE :: solution(:,:,:,:)
      REAL(prec), ALLOCATABLE :: tendency(:,:,:,:)
      REAL(prec), ALLOCATABLE :: boundarySolution(:,:,:,:)  
      REAL(prec), ALLOCATABLE :: boundaryFlux(:,:,:,:)     
 
      
      REAL(prec), ALLOCATABLE, DEVICE :: solution_dev(:,:,:,:)
      REAL(prec), ALLOCATABLE, DEVICE :: tendency_dev(:,:,:,:)
      REAL(prec), ALLOCATABLE, DEVICE :: boundarySolution_dev(:,:,:,:)  
      REAL(prec), ALLOCATABLE, DEVICE :: boundaryFlux_dev(:,:,:,:)     

      CONTAINS

      ! CONSTRUCTORS/DESTRUCTORS
      PROCEDURE :: Build => Build_DGSEMSolution_2D_Cuda
      PROCEDURE :: Trash => Trash_DGSEMSolution_2D_Cuda
      
      PROCEDURE :: UpdateDevice => UpdateDevice_DGSEMSolutionStorage_2D
      PROCEDURE :: UpdateHost   => UpdateHost_DGSEMSolutionStorage_2D

    END TYPE DGSEMSolution_2D_Cuda
    
    
    ! Light Storage : No tendency or boundary flux
    TYPE LightDGSEMSolution_2D_Cuda
      REAL(prec), ALLOCATABLE :: solution(:,:,:,:)
      REAL(prec), ALLOCATABLE :: boundarySolution(:,:,:,:) 
      
      REAL(prec), ALLOCATABLE, DEVICE :: solution_dev(:,:,:,:)
      REAL(prec), ALLOCATABLE, DEVICE :: boundarySolution_dev(:,:,:,:) 

      CONTAINS

      ! CONSTRUCTORS/DESTRUCTORS
      PROCEDURE :: Build => Build_LightDGSEMSolution_2D_Cuda
      PROCEDURE :: Trash => Trash_LightDGSEMSolution_2D_Cuda
      
      PROCEDURE :: UpdateDevice => UpdateDevice_LightDGSEMSolutionStorage_2D
      PROCEDURE :: UpdateHost   => UpdateHost_LightDGSEMSolutionStorage_2D

    END TYPE LightDGSEMSolution_2D_Cuda

    INTEGER, CONSTANT :: nEq_dev
    
 CONTAINS
!
!
!==================================================================================================!
!------------------------------- Manual Constructors/Destructors ----------------------------------!
!==================================================================================================!
!
!

 ATTRIBUTES(Host) SUBROUTINE Build_DGSEMSolution_2D_Cuda( myDGS, N, nEq, nElems )

   IMPLICIT NONE
   CLASS(DGSEMSolution_2D_Cuda), INTENT(inout) :: myDGS
   INTEGER, INTENT(in)                         :: N, nEq, nElems
      
      ALLOCATE( myDGS % solution(0:N,0:N,1:nEq,1:nElems) )
      ALLOCATE( myDGS % tendency(0:N,0:N,1:nEq,1:nElems) )
      ALLOCATE( myDGS % boundarySolution(0:N,1:nEq,1:4,1:nElems) ) 
      ALLOCATE( myDGS % boundaryFlux(0:N,1:nEq,1:4,1:nElems) ) 
      
      myDGS % solution         = 0.0_prec
      myDGS % tendency         = 0.0_prec
      myDGS % boundarySolution = 0.0_prec
      myDGS % boundaryFlux     = 0.0_prec
      
      ALLOCATE( myDGS % solution_dev(0:N,0:N,1:nEq,1:nElems) )
      ALLOCATE( myDGS % tendency_dev(0:N,0:N,1:nEq,1:nElems) )
      ALLOCATE( myDGS % boundarySolution_dev(0:N,1:nEq,1:4,1:nElems) ) 
      ALLOCATE( myDGS % boundaryFlux_dev(0:N,1:nEq,1:4,1:nElems) ) 

      myDGS % solution_dev         = 0.0_prec
      myDGS % tendency_dev         = 0.0_prec
      myDGS % boundarySolution_dev = 0.0_prec
      myDGS % boundaryFlux_dev     = 0.0_prec
      
      nEq_dev = nEq

 END SUBROUTINE Build_DGSEMSolution_2D_Cuda
!
!> \addtogroup DGSEMSolutionStorage_2D_Cuda_Class
!! @{ 
! ================================================================================================ !
! S/R Trash
! 
!> \fn Trash_DGSEMSolution_2D_Cuda
!! Frees memory held by the attributes of the DGSEMSolution_2D_Cuda data structure.
!! 
!! <H2> Usage : </H2> 
!! <B>TYPE</B>(DGSEMSolution_2D_Cuda) :: this <BR>
!!         .... <BR>
!!     <B>CALL</B> this % Trash( ) <BR>
!! 
!!  <H2> Parameters : </H2>
!!  <table> 
!!   <tr> <td> in/out <th> myDGS <td> DGSEMSolution_2D_Cuda <td> On output, memory held by the attributes
!!                                                          of the data structure has been deallocated.
!!  </table>  
!!   
! ================================================================================================ ! 
!>@}
 ATTRIBUTES(Host) SUBROUTINE Trash_DGSEMSolution_2D_Cuda( myDGS )

   IMPLICIT NONE
   CLASS(DGSEMSolution_2D_Cuda), INTENT(inout) :: myDGS

      DEALLOCATE( myDGS % Solution )
      DEALLOCATE( myDGS % tendency )
      DEALLOCATE( myDGS % boundarySolution ) 
      DEALLOCATE( myDGS % boundaryFlux ) 
      
      DEALLOCATE( myDGS % Solution_dev )
      DEALLOCATE( myDGS % tendency_dev )
      DEALLOCATE( myDGS % boundarySolution_dev ) 
      DEALLOCATE( myDGS % boundaryFlux_dev ) 

 END SUBROUTINE Trash_DGSEMSolution_2D_Cuda
!
!
!> \addtogroup LightDGSEMSolutionStorage_2D_Cuda_Class
!! @{ 
! ================================================================================================ !
! S/R Build
! 
!> \fn Build_LightDGSEMSolution_2D_Cuda_Class  
!! Allocates space for the LightDGSEMSolution_2D_Cuda attributes and initializes arrays to zero.
!! 
!! <H2> Usage : </H2> 
!! <B>TYPE</B>(LightDGSEMSolution_2D_Cuda) :: this <BR>
!! <B>INTEGER</B>                :: N, nEq <BR>
!!         .... <BR>
!!     <B>CALL</B> this % Build( N, nEq ) <BR>
!! 
!!  <H2> Parameters : </H2>
!!  <table> 
!!   <tr> <td> out <th> myDGS <td> LightDGSEMSolution_2D_Cuda <td> On output, memory has been allocated for
!!                                                       each attribute and each array is initialized
!!                                                       with a value of zero. 
!!   <tr> <td> in <th> N <td> INTEGER <td> Polynomial degree of the DG-method you plan on using
!!   <tr> <td> in <th> nEq <td> INTEGER <td> Number of prognostic variables; number of equations for
!!                                           the system being solved
!!  </table>  
!!   
! ================================================================================================ ! 
!>@}
 ATTRIBUTES(Host) SUBROUTINE Build_LightDGSEMSolution_2D_Cuda( myDGS, N, nEq, nElems )

   IMPLICIT NONE
   CLASS(LightDGSEMSolution_2D_Cuda), INTENT(inout) :: myDGS
   INTEGER, INTENT(in)                              :: N, nEq, nElems
      
      ALLOCATE( myDGS % solution(0:N,0:N,1:nEq,1:nElems) )
      ALLOCATE( myDGS % boundarySolution(0:N,1:nEq,1:4,1:nElems) ) 
      
      myDGS % solution = 0.0_prec
      myDGS % boundarySolution = 0.0_prec
      
      ALLOCATE( myDGS % solution_dev(0:N,0:N,1:nEq,1:nElems) )
      ALLOCATE( myDGS % boundarySolution_dev(0:N,1:nEq,1:4,1:nElems) ) 
      
      myDGS % solution_dev = 0.0_prec
      myDGS % boundarySolution_dev = 0.0_prec

 END SUBROUTINE Build_LightDGSEMSolution_2D_Cuda
!
!> \addtogroup LightDGSEMSolutionStorage_2D_Cuda_Class
!! @{ 
! ================================================================================================ !
! S/R Trash
! 
!> \fn Trash_LightDGSEMSolution_2D_Cuda
!! Frees memory held by the attributes of the LightDGSEMSolution_2D_Cuda data structure.
!! 
!! <H2> Usage : </H2> 
!! <B>TYPE</B>(LightDGSEMSolution_2D_Cuda) :: this <BR>
!!         .... <BR>
!!     <B>CALL</B> this % Trash( ) <BR>
!! 
!!  <H2> Parameters : </H2>
!!  <table> 
!!   <tr> <td> in/out <th> myDGS <td> LightDGSEMSolution_2D_Cuda <td> On output, memory held by the attributes
!!                                                          of the data structure has been deallocated.
!!  </table>  
!!   
! ================================================================================================ ! 
!>@}
 ATTRIBUTES(Host) SUBROUTINE Trash_LightDGSEMSolution_2D_Cuda( myDGS )

   IMPLICIT NONE
   CLASS(LightDGSEMSolution_2D_Cuda), INTENT(inout) :: myDGS

      DEALLOCATE( myDGS % Solution )
      DEALLOCATE( myDGS % boundarySolution ) 
      
      
      DEALLOCATE( myDGS % Solution_dev )
      DEALLOCATE( myDGS % boundarySolution_dev ) 

 END SUBROUTINE Trash_LightDGSEMSolution_2D_Cuda
!
!==================================================================================================!
!--------------------------------- Type Specific Routines -----------------------------------------!
!==================================================================================================!
!
!
 ATTRIBUTES(Host) SUBROUTINE UpdateDevice_DGSEMSolutionStorage_2D( myDGS )
   IMPLICIT NONE
   CLASS( DGSEMSolution_2D_Cuda ), INTENT(inout) :: myDGS
   
      myDGS % Solution_dev         = myDGS % Solution
      myDGS % tendency_dev         = myDGS % tendency
      myDGS % boundarySolution_dev = myDGS % boundarySolution
      myDGS % boundaryFlux_dev     = myDGS % boundaryFlux
      
 END SUBROUTINE UpdateDevice_DGSEMSolutionStorage_2D
!
 ATTRIBUTES(Host) SUBROUTINE UpdateHost_DGSEMSolutionStorage_2D( myDGS )
   IMPLICIT NONE
   CLASS( DGSEMSolution_2D_Cuda ), INTENT(inout) :: myDGS
   
      myDGS % Solution         = myDGS % Solution_dev
      myDGS % tendency         = myDGS % tendency_dev
      myDGS % boundarySolution = myDGS % boundarySolution_dev
      myDGS % boundaryFlux     = myDGS % boundaryFlux_dev
      
 END SUBROUTINE UpdateHost_DGSEMSolutionStorage_2D
!
 ATTRIBUTES(Host) SUBROUTINE UpdateDevice_LightDGSEMSolutionStorage_2D( myDGS )
   IMPLICIT NONE
   CLASS( LightDGSEMSolution_2D_Cuda ), INTENT(inout) :: myDGS
   
      myDGS % Solution_dev         = myDGS % Solution
      myDGS % boundarySolution_dev = myDGS % boundarySolution
      
 END SUBROUTINE UpdateDevice_LightDGSEMSolutionStorage_2D
!
 ATTRIBUTES(Host) SUBROUTINE UpdateHost_LightDGSEMSolutionStorage_2D( myDGS )
   IMPLICIT NONE
   CLASS( LightDGSEMSolution_2D_Cuda ), INTENT(inout) :: myDGS
   
      myDGS % Solution         = myDGS % Solution_dev
      myDGS % boundarySolution = myDGS % boundarySolution_dev
      
 END SUBROUTINE UpdateHost_LightDGSEMSolutionStorage_2D
! 
END MODULE DGSEMSolutionStorage_2D_Cuda_Class
