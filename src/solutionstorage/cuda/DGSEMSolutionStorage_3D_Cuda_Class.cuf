! DGSEMSolutionStorage_3D_Cuda_Class.cuf
! 
! Copyright 2017 Joseph Schoonover <joe@fluidnumerics.consulting>, Fluid Numerics LLC
! All rights reserved.
!
! //////////////////////////////////////////////////////////////////////////////////////////////// !


MODULE DGSEMSolutionStorage_3D_Cuda_Class

! src/common/
USE ModelPrecision

IMPLICIT NONE



    TYPE :: DGSEMSolution_3D_Cuda
      REAL(prec), ALLOCATABLE :: solution(:,:,:,:,:)
      REAL(prec), ALLOCATABLE :: tendency(:,:,:,:,:)
      REAL(prec), ALLOCATABLE :: boundarySolution(:,:,:,:,:)  
      REAL(prec), ALLOCATABLE :: boundaryFlux(:,:,:,:,:)     
 
      
      REAL(prec), ALLOCATABLE, DEVICE :: solution_dev(:,:,:,:,:)
      REAL(prec), ALLOCATABLE, DEVICE :: tendency_dev(:,:,:,:,:)
      REAL(prec), ALLOCATABLE, DEVICE :: boundarySolution_dev(:,:,:,:,:)  
      REAL(prec), ALLOCATABLE, DEVICE :: boundaryFlux_dev(:,:,:,:,:)     

      CONTAINS

      ! CONSTRUCTORS/DESTRUCTORS
      PROCEDURE :: Build => Build_DGSEMSolution_3D_Cuda
      PROCEDURE :: Trash => Trash_DGSEMSolution_3D_Cuda
      
      PROCEDURE :: UpdateDevice => UpdateDevice_DGSEMSolutionStorage_3D
      PROCEDURE :: UpdateHost   => UpdateHost_DGSEMSolutionStorage_3D

    END TYPE DGSEMSolution_3D_Cuda
    
    
    ! Light Storage : No tendency or boundary flux
    TYPE LightDGSEMSolution_3D_Cuda
      REAL(prec), ALLOCATABLE :: solution(:,:,:,:,:)
      REAL(prec), ALLOCATABLE :: boundarySolution(:,:,:,:,:) 
      
      REAL(prec), ALLOCATABLE, DEVICE :: solution_dev(:,:,:,:,:)
      REAL(prec), ALLOCATABLE, DEVICE :: boundarySolution_dev(:,:,:,:,:) 

      CONTAINS

      ! CONSTRUCTORS/DESTRUCTORS
      PROCEDURE :: Build => Build_LightDGSEMSolution_3D_Cuda
      PROCEDURE :: Trash => Trash_LightDGSEMSolution_3D_Cuda
      
      PROCEDURE :: UpdateDevice => UpdateDevice_LightDGSEMSolutionStorage_3D
      PROCEDURE :: UpdateHost   => UpdateHost_LightDGSEMSolutionStorage_3D

    END TYPE LightDGSEMSolution_3D_Cuda

 CONTAINS
!
!
!==================================================================================================!
!------------------------------- Manual Constructors/Destructors ----------------------------------!
!==================================================================================================!
!
!

 ATTRIBUTES(Host) SUBROUTINE Build_DGSEMSolution_3D_Cuda( myDGS, N, nEq, nElems )

   IMPLICIT NONE
   CLASS(DGSEMSolution_3D_Cuda), INTENT(inout) :: myDGS
   INTEGER, INTENT(in)                         :: N, nEq, nElems
      
      ALLOCATE( myDGS % solution(0:N,0:N,0:N,1:nEq,1:nElems) )
      ALLOCATE( myDGS % tendency(0:N,0:N,0:N,1:nEq,1:nElems) )
      ALLOCATE( myDGS % boundarySolution(0:N,0:N,1:nEq,1:6,1:nElems) ) 
      ALLOCATE( myDGS % boundaryFlux(0:N,0:N,1:nEq,1:6,1:nElems) ) 
      
      myDGS % solution         = 0.0_prec
      myDGS % tendency         = 0.0_prec
      myDGS % boundarySolution = 0.0_prec
      myDGS % boundaryFlux     = 0.0_prec
      
      ALLOCATE( myDGS % solution_dev(0:N,0:N,0:N,1:nEq,1:nElems) )
      ALLOCATE( myDGS % tendency_dev(0:N,0:N,0:N,1:nEq,1:nElems) )
      ALLOCATE( myDGS % boundarySolution_dev(0:N,0:N,1:nEq,1:6,1:nElems) ) 
      ALLOCATE( myDGS % boundaryFlux_dev(0:N,0:N,1:nEq,1:6,1:nElems) ) 

      myDGS % solution_dev         = 0.0_prec
      myDGS % tendency_dev         = 0.0_prec
      myDGS % boundarySolution_dev = 0.0_prec
      myDGS % boundaryFlux_dev     = 0.0_prec
      
 END SUBROUTINE Build_DGSEMSolution_3D_Cuda
!
!> \addtogroup DGSEMSolutionStorage_3D_Cuda_Class
!! @{ 
! ================================================================================================ !
! S/R Trash
! 
!> \fn Trash_DGSEMSolution_3D_Cuda
!! Frees memory held by the attributes of the DGSEMSolution_3D_Cuda data structure.
!! 
!! <H2> Usage : </H2> 
!! <B>TYPE</B>(DGSEMSolution_3D_Cuda) :: this <BR>
!!         .... <BR>
!!     <B>CALL</B> this % Trash( ) <BR>
!! 
!!  <H2> Parameters : </H2>
!!  <table> 
!!   <tr> <td> in/out <th> myDGS <td> DGSEMSolution_3D_Cuda <td> On output, memory held by the attributes
!!                                                          of the data structure has been deallocated.
!!  </table>  
!!   
! ================================================================================================ ! 
!>@}
 ATTRIBUTES(Host) SUBROUTINE Trash_DGSEMSolution_3D_Cuda( myDGS )

   IMPLICIT NONE
   CLASS(DGSEMSolution_3D_Cuda), INTENT(inout) :: myDGS

      DEALLOCATE( myDGS % Solution )
      DEALLOCATE( myDGS % tendency )
      DEALLOCATE( myDGS % boundarySolution ) 
      DEALLOCATE( myDGS % boundaryFlux ) 
      
      DEALLOCATE( myDGS % Solution_dev )
      DEALLOCATE( myDGS % tendency_dev )
      DEALLOCATE( myDGS % boundarySolution_dev ) 
      DEALLOCATE( myDGS % boundaryFlux_dev ) 

 END SUBROUTINE Trash_DGSEMSolution_3D_Cuda
!
!
!> \addtogroup LightDGSEMSolutionStorage_3D_Cuda_Class
!! @{ 
! ================================================================================================ !
! S/R Build
! 
!> \fn Build_LightDGSEMSolution_3D_Cuda_Class  
!! Allocates space for the LightDGSEMSolution_3D_Cuda attributes and initializes arrays to zero.
!! 
!! <H2> Usage : </H2> 
!! <B>TYPE</B>(LightDGSEMSolution_3D_Cuda) :: this <BR>
!! <B>INTEGER</B>                :: N, nEq <BR>
!!         .... <BR>
!!     <B>CALL</B> this % Build( N, nEq ) <BR>
!! 
!!  <H2> Parameters : </H2>
!!  <table> 
!!   <tr> <td> out <th> myDGS <td> LightDGSEMSolution_3D_Cuda <td> On output, memory has been allocated for
!!                                                       each attribute and each array is initialized
!!                                                       with a value of zero. 
!!   <tr> <td> in <th> N <td> INTEGER <td> Polynomial degree of the DG-method you plan on using
!!   <tr> <td> in <th> nEq <td> INTEGER <td> Number of prognostic variables; number of equations for
!!                                           the system being solved
!!  </table>  
!!   
! ================================================================================================ ! 
!>@}
 ATTRIBUTES(Host) SUBROUTINE Build_LightDGSEMSolution_3D_Cuda( myDGS, N, nEq, nElems )

   IMPLICIT NONE
   CLASS(LightDGSEMSolution_3D_Cuda), INTENT(inout) :: myDGS
   INTEGER, INTENT(in)                              :: N, nEq, nElems
      
      ALLOCATE( myDGS % solution(0:N,0:N,0:N,1:nEq,1:nElems) )
      ALLOCATE( myDGS % boundarySolution(0:N,0:N,1:nEq,1:6,1:nElems) ) 
      
      myDGS % solution = 0.0_prec
      myDGS % boundarySolution = 0.0_prec
      
      ALLOCATE( myDGS % solution_dev(0:N,0:N,0:N,1:nEq,1:nElems) )
      ALLOCATE( myDGS % boundarySolution_dev(0:N,0:N,1:nEq,1:6,1:nElems) ) 
      
      myDGS % solution_dev = 0.0_prec
      myDGS % boundarySolution_dev = 0.0_prec

 END SUBROUTINE Build_LightDGSEMSolution_3D_Cuda
!
!> \addtogroup LightDGSEMSolutionStorage_3D_Cuda_Class
!! @{ 
! ================================================================================================ !
! S/R Trash
! 
!> \fn Trash_LightDGSEMSolution_3D_Cuda
!! Frees memory held by the attributes of the LightDGSEMSolution_3D_Cuda data structure.
!! 
!! <H2> Usage : </H2> 
!! <B>TYPE</B>(LightDGSEMSolution_3D_Cuda) :: this <BR>
!!         .... <BR>
!!     <B>CALL</B> this % Trash( ) <BR>
!! 
!!  <H2> Parameters : </H2>
!!  <table> 
!!   <tr> <td> in/out <th> myDGS <td> LightDGSEMSolution_3D_Cuda <td> On output, memory held by the attributes
!!                                                          of the data structure has been deallocated.
!!  </table>  
!!   
! ================================================================================================ ! 
!>@}
 ATTRIBUTES(Host) SUBROUTINE Trash_LightDGSEMSolution_3D_Cuda( myDGS )

   IMPLICIT NONE
   CLASS(LightDGSEMSolution_3D_Cuda), INTENT(inout) :: myDGS

      DEALLOCATE( myDGS % Solution )
      DEALLOCATE( myDGS % boundarySolution ) 
      
      
      DEALLOCATE( myDGS % Solution_dev )
      DEALLOCATE( myDGS % boundarySolution_dev ) 

 END SUBROUTINE Trash_LightDGSEMSolution_3D_Cuda
!
!==================================================================================================!
!--------------------------------- Type Specific Routines -----------------------------------------!
!==================================================================================================!
!
!
 ATTRIBUTES(Host) SUBROUTINE UpdateDevice_DGSEMSolutionStorage_3D( myDGS )
   IMPLICIT NONE
   CLASS( DGSEMSolution_3D_Cuda ), INTENT(inout) :: myDGS
   
      myDGS % Solution_dev         = myDGS % Solution
      myDGS % tendency_dev         = myDGS % tendency
      myDGS % boundarySolution_dev = myDGS % boundarySolution
      myDGS % boundaryFlux_dev     = myDGS % boundaryFlux
      
 END SUBROUTINE UpdateDevice_DGSEMSolutionStorage_3D
!
 ATTRIBUTES(Host) SUBROUTINE UpdateHost_DGSEMSolutionStorage_3D( myDGS )
   IMPLICIT NONE
   CLASS( DGSEMSolution_3D_Cuda ), INTENT(inout) :: myDGS
   
      myDGS % Solution         = myDGS % Solution_dev
      myDGS % tendency         = myDGS % tendency_dev
      myDGS % boundarySolution = myDGS % boundarySolution_dev
      myDGS % boundaryFlux     = myDGS % boundaryFlux_dev
      
 END SUBROUTINE UpdateHost_DGSEMSolutionStorage_3D
!
 ATTRIBUTES(Host) SUBROUTINE UpdateDevice_LightDGSEMSolutionStorage_3D( myDGS )
   IMPLICIT NONE
   CLASS( LightDGSEMSolution_3D_Cuda ), INTENT(inout) :: myDGS
   
      myDGS % Solution_dev         = myDGS % Solution
      myDGS % boundarySolution_dev = myDGS % boundarySolution
      
 END SUBROUTINE UpdateDevice_LightDGSEMSolutionStorage_3D
!
 ATTRIBUTES(Host) SUBROUTINE UpdateHost_LightDGSEMSolutionStorage_3D( myDGS )
   IMPLICIT NONE
   CLASS( LightDGSEMSolution_3D_Cuda ), INTENT(inout) :: myDGS
   
      myDGS % Solution         = myDGS % Solution_dev
      myDGS % boundarySolution = myDGS % boundarySolution_dev
      
 END SUBROUTINE UpdateHost_LightDGSEMSolutionStorage_3D
! 
END MODULE DGSEMSolutionStorage_3D_Cuda_Class
