var tipuesearch = {"pages":[{"title":" SELF ","text":"SELF Developer Info Joe Schoonover Committed to service for science","tags":"home","loc":"index.html"},{"title":"Model3D – SELF ","text":"type, public, extends( Model ) :: Model3D Contents Variables dSdt decomp dt entropy flux fluxDivergence geometry gpuAccel ioIterate mesh prevSol solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures AdamsBashforth2_timeIntegrator AdamsBashforth3_timeIntegrator AdamsBashforth4_timeIntegrator CalculateEntropy CalculateFluxDivergence CalculateTendency DisableGPUAccel EnableGPUAccel Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreFlux PreTendency PrintType ReadModel ReportEntropy ReprojectFlux ResizePrevSol RiemannSolver SetBoundaryCondition SetInitialConditions SetSimulationTime SetSolution SetSolutionFromChar_Model3D SetSolutionFromEqn_Model3D SetTimeIntegrator SourceMethod UpdateBoundary UpdateDevice UpdateGAB2 UpdateGAB3 UpdateGAB4 UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateHost UpdateSolution WriteModel WriteTecplot Source Code Model3D Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, POINTER :: geometry logical, public :: gpuAccel integer, public :: ioIterate = 0 type( Mesh3D ), public, POINTER :: mesh type( MappedScalar3D ), public :: prevSol type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator public subroutine AdamsBashforth2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth3_timeIntegrator public subroutine AdamsBashforth3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth4_timeIntegrator public subroutine AdamsBashforth4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: CalculateEntropy => CalculateEntropy_Model public subroutine CalculateEntropy_Model (this) Base method for calculating entropy of a model\nWhen this method is not overridden, the entropy\nis simply set to 0.0. When you develop a model\nbuilt on top of this abstract class or one of its\nchildren, it is recommended that you define a\nconvex mathematical entropy function that is used\nas a measure of the model stability. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_Model3D public subroutine CalculateFluxDivergence_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_Model3D public subroutine CalculateTendency_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this procedure, public :: DisableGPUAccel => DisableGPUAccel_Model public subroutine DisableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: EnableGPUAccel => EnableGPUAccel_Model public subroutine EnableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => Flux_Model public subroutine Flux_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: tn real(kind=prec), intent(in), optional :: dt real(kind=prec), intent(in), optional :: ioInterval procedure, public :: Free => Free_Model3D public subroutine Free_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_Model3D public subroutine Init_Model3D (this, nvar, mesh, geometry, decomp) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(out) :: this integer, intent(in) :: nvar type( Mesh3D ), intent(in), TARGET :: mesh type( SEMHex ), intent(in), TARGET :: geometry type( MPILayer ), intent(in), TARGET :: decomp procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreFlux => PreFlux_Model public subroutine PreFlux_Model (this) PreFlux is a template routine that is used to house any additional calculations\nthat you want to execute just before the calculation of flux terms.\nThis default PreFlux simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_Model3D public subroutine Read_Model3D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReprojectFlux => ReprojectFlux_Model3D public subroutine ReprojectFlux_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this procedure, public :: ResizePrevSol => ResizePrevSol_Model3D public subroutine ResizePrevSol_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: RiemannSolver => RiemannSolver_Model public subroutine RiemannSolver_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetBoundaryCondition => SetBoundaryCondition_Model public subroutine SetBoundaryCondition_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetInitialConditions => SetInitialConditions_Model public subroutine SetInitialConditions_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_Model3D , SetSolutionFromEqn_Model3D public subroutine SetSolutionFromChar_Model3D (this, eqnChar) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_Model3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) procedure, private :: SetSolutionFromChar_Model3D public subroutine SetSolutionFromChar_Model3D (this, eqnChar) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) procedure, private :: SetSolutionFromEqn_Model3D public subroutine SetSolutionFromEqn_Model3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt , SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withInt (this, integrator) Sets the time integrator method, using an integer flag Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: integrator public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => Source_Model public subroutine Source_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: UpdateBoundary => UpdateBoundary_Model public subroutine UpdateBoundary_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_Model3D public subroutine UpdateDevice_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this procedure, public :: UpdateGAB2 => UpdateGAB2_Model3D public subroutine UpdateGAB2_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGAB3 => UpdateGAB3_Model3D public subroutine UpdateGAB3_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGAB4 => UpdateGAB4_Model3D public subroutine UpdateGAB4_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK2 => UpdateGRK2_Model3D public subroutine UpdateGRK2_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_Model3D public subroutine UpdateGRK3_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_Model3D public subroutine UpdateGRK4_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateHost => UpdateHost_Model3D public subroutine UpdateHost_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this procedure, public :: UpdateSolution => UpdateSolution_Model3D public subroutine UpdateSolution_Model3D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_Model3D public subroutine Write_Model3D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_Model3D public subroutine WriteTecplot_Model3D (this, filename) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in), optional :: filename Source Code TYPE , EXTENDS ( Model ) :: Model3D TYPE ( MappedScalar3D ) :: solution TYPE ( MappedVector3D ) :: solutionGradient TYPE ( MappedVector3D ) :: flux TYPE ( MappedScalar3D ) :: source TYPE ( MappedScalar3D ) :: fluxDivergence TYPE ( MappedScalar3D ) :: dSdt TYPE ( MappedScalar3D ) :: workSol TYPE ( MappedScalar3D ) :: prevSol TYPE ( Mesh3D ), POINTER :: mesh TYPE ( SEMHex ), POINTER :: geometry CONTAINS PROCEDURE :: Init => Init_Model3D PROCEDURE :: Free => Free_Model3D PROCEDURE :: UpdateHost => UpdateHost_Model3D PROCEDURE :: UpdateDevice => UpdateDevice_Model3D PROCEDURE :: UpdateSolution => UpdateSolution_Model3D PROCEDURE :: ResizePrevSol => ResizePrevSol_Model3D PROCEDURE :: UpdateGAB2 => UpdateGAB2_Model3D PROCEDURE :: UpdateGAB3 => UpdateGAB3_Model3D PROCEDURE :: UpdateGAB4 => UpdateGAB4_Model3D PROCEDURE :: UpdateGRK2 => UpdateGRK2_Model3D PROCEDURE :: UpdateGRK3 => UpdateGRK3_Model3D PROCEDURE :: UpdateGRK4 => UpdateGRK4_Model3D PROCEDURE :: CalculateTendency => CalculateTendency_Model3D PROCEDURE :: CalculateFluxDivergence => CalculateFluxDivergence_Model3D GENERIC :: SetSolution => SetSolutionFromChar_Model3D , & SetSolutionFromEqn_Model3D PROCEDURE , PRIVATE :: SetSolutionFromChar_Model3D PROCEDURE , PRIVATE :: SetSolutionFromEqn_Model3D PROCEDURE :: ReprojectFlux => ReprojectFlux_Model3D PROCEDURE :: ReadModel => Read_Model3D PROCEDURE :: WriteModel => Write_Model3D PROCEDURE :: WriteTecplot => WriteTecplot_Model3D END TYPE Model3D","tags":"","loc":"type/model3d.html"},{"title":"Lagrange – SELF ","text":"type, public :: Lagrange A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions.\nThe Lagrange data-structure stores the information necessary to interpolate between two\nsets of grid-points and to estimate the derivative of data at native grid points. Routines for\nmultidimensional interpolation are based on the tensor product of 1-D interpolants. It is\nassumed that the polynomial degree (and the interpolation nodes) are the same in each direction.\nThis assumption permits the storage of only one array of interpolation nodes and barycentric\nweights and is what allows this data structure to be flexible. Contents Variables M N bMatrix bWeights controlNodeType controlPoints dMatrix dgMatrix iMatrix qWeights targetNodeType targetPoints Type-Bound Procedures CalculateBarycentricWeights CalculateDerivativeMatrix CalculateInterpolationMatrix CalculateLagrangePolynomials DGDerivative_1D DGDerivative_1D_cpu DGDerivative_1D_gpu Derivative_1D Derivative_1D_cpu Derivative_1D_gpu Free Init ScalarBoundaryInterp_1D ScalarBoundaryInterp_1D_cpu ScalarBoundaryInterp_1D_gpu ScalarBoundaryInterp_2D ScalarBoundaryInterp_2D_cpu ScalarBoundaryInterp_2D_gpu ScalarBoundaryInterp_3D ScalarBoundaryInterp_3D_cpu ScalarBoundaryInterp_3D_gpu ScalarGradient_2D ScalarGradient_2D_cpu ScalarGradient_2D_gpu ScalarGradient_3D ScalarGradient_3D_cpu ScalarGradient_3D_gpu ScalarGridInterp_1D ScalarGridInterp_1D_cpu ScalarGridInterp_1D_gpu ScalarGridInterp_2D ScalarGridInterp_2D_cpu ScalarGridInterp_2D_gpu ScalarGridInterp_3D ScalarGridInterp_3D_cpu ScalarGridInterp_3D_gpu TensorBoundaryInterp_2D TensorBoundaryInterp_2D_cpu TensorBoundaryInterp_2D_gpu TensorBoundaryInterp_3D TensorBoundaryInterp_3D_cpu TensorBoundaryInterp_3D_gpu UpdateDevice UpdateHost VectorBoundaryInterp_2D VectorBoundaryInterp_2D_cpu VectorBoundaryInterp_2D_gpu VectorBoundaryInterp_3D VectorBoundaryInterp_3D_cpu VectorBoundaryInterp_3D_gpu VectorDGDivergence_2D VectorDGDivergence_2D_cpu VectorDGDivergence_2D_gpu VectorDGDivergence_3D VectorDGDivergence_3D_cpu VectorDGDivergence_3D_gpu VectorDivergence_2D VectorDivergence_2D_cpu VectorDivergence_2D_gpu VectorDivergence_3D VectorDivergence_3D_cpu VectorDivergence_3D_gpu VectorGradient_2D VectorGradient_2D_cpu VectorGradient_2D_gpu VectorGradient_3D VectorGradient_3D_cpu VectorGradient_3D_gpu VectorGridInterp_2D VectorGridInterp_2D_cpu VectorGridInterp_2D_gpu VectorGridInterp_3D VectorGridInterp_3D_cpu VectorGridInterp_3D_gpu WriteHDF5 Source Code Lagrange Components Type Visibility Attributes Name Initial integer, public :: M The number of target points. integer, public :: N The number of control points. type( hfReal_r2 ), public :: bMatrix The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. type( hfReal_r1 ), public :: bWeights The barycentric weights that are calculated from the controlPoints and used for interpolation. integer, public :: controlNodeType type( hfReal_r1 ), public :: controlPoints The set of nodes in one dimension where data is known.\nTo create higher dimension interpolation and differentiation operators, structured grids in two and three\ndimensions are created by tensor products of the controlPoints. This design decision implies that all\nspectral element methods supported by the Lagrange class have the same polynomial degree in each\ncomputational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto,\nLegendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over\nthe domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of\nthese quadrature types or uniform points on [-1,1]. type( hfReal_r2 ), public :: dMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The\ndMatrix is based on a strong form of the derivative. type( hfReal_r2 ), public :: dgMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based\non a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. type( hfReal_r2 ), public :: iMatrix The interpolation matrix (transpose) for mapping data from the control grid to the target grid. type( hfReal_r1 ), public :: qWeights The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints\nprovided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss,\nChebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant . integer, public :: targetNodeType type( hfReal_r1 ), public :: targetPoints The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation\nand differentiation operators, structured grids in two and three dimensions are created by tensor products of\nthe targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1]\n(computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. Type-Bound Procedures procedure, private :: CalculateBarycentricWeights public subroutine CalculateBarycentricWeights (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly procedure, private :: CalculateDerivativeMatrix public subroutine CalculateDerivativeMatrix (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly procedure, private :: CalculateInterpolationMatrix public subroutine CalculateInterpolationMatrix (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly procedure, private :: CalculateLagrangePolynomials public function CalculateLagrangePolynomials (myPoly, sE) result(lAtS) Arguments Type Intent Optional Attributes Name class( Lagrange ) :: myPoly real(kind=prec) :: sE Return Value real(kind=prec)(0:myPoly%N) generic, public :: DGDerivative_1D => DGDerivative_1D_cpu , DGDerivative_1D_gpu public subroutine DGDerivative_1D_cpu (myPoly, f, bf, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:nVariables,1:2,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine DGDerivative_1D_gpu (myPoly, f_dev, bf_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: DGDerivative_1D_cpu public subroutine DGDerivative_1D_cpu (myPoly, f, bf, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:nVariables,1:2,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: DGDerivative_1D_gpu public subroutine DGDerivative_1D_gpu (myPoly, f_dev, bf_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: Derivative_1D => Derivative_1D_cpu , Derivative_1D_gpu public subroutine Derivative_1D_cpu (myPoly, f, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine Derivative_1D_gpu (myPoly, f_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: Derivative_1D_cpu public subroutine Derivative_1D_cpu (myPoly, f, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: Derivative_1D_gpu public subroutine Derivative_1D_gpu (myPoly, f_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, public :: Free => Free_Lagrange public subroutine Free_Lagrange (myPoly) Frees all memory (host and device) associated with an instance of the Lagrange class Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance procedure, public :: Init => Init_Lagrange public subroutine Init_Lagrange (myPoly, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange class\nOn output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(out) :: myPoly Lagrange class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) generic, public :: ScalarBoundaryInterp_1D => ScalarBoundaryInterp_1D_cpu , ScalarBoundaryInterp_1D_gpu public subroutine ScalarBoundaryInterp_1D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:nVariables,1:2,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_1D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_1D_cpu public subroutine ScalarBoundaryInterp_1D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:nVariables,1:2,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_1D_gpu public subroutine ScalarBoundaryInterp_1D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarBoundaryInterp_2D => ScalarBoundaryInterp_2D_cpu , ScalarBoundaryInterp_2D_gpu public subroutine ScalarBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_2D_cpu public subroutine ScalarBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_2D_gpu public subroutine ScalarBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarBoundaryInterp_3D => ScalarBoundaryInterp_3D_cpu , ScalarBoundaryInterp_3D_gpu public subroutine ScalarBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_3D_cpu public subroutine ScalarBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_3D_gpu public subroutine ScalarBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarGradient_2D => ScalarGradient_2D_cpu , ScalarGradient_2D_gpu public subroutine ScalarGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGradient_2D_cpu public subroutine ScalarGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGradient_2D_gpu public subroutine ScalarGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarGradient_3D => ScalarGradient_3D_cpu , ScalarGradient_3D_gpu public subroutine ScalarGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGradient_3D_cpu public subroutine ScalarGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGradient_3D_gpu public subroutine ScalarGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarGridInterp_1D => ScalarGridInterp_1D_cpu , ScalarGridInterp_1D_gpu public subroutine ScalarGridInterp_1D_cpu (myPoly, f, fInterp, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fInterp (0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine ScalarGridInterp_1D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_1D_gpu_wrapper\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid procedure, private :: ScalarGridInterp_1D_cpu public subroutine ScalarGridInterp_1D_cpu (myPoly, f, fInterp, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fInterp (0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid procedure, private :: ScalarGridInterp_1D_gpu public subroutine ScalarGridInterp_1D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_1D_gpu_wrapper\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid generic, public :: ScalarGridInterp_2D => ScalarGridInterp_2D_cpu , ScalarGridInterp_2D_gpu public subroutine ScalarGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine ScalarGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_2D_gpu_wrapper\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid procedure, private :: ScalarGridInterp_2D_cpu public subroutine ScalarGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid procedure, private :: ScalarGridInterp_2D_gpu public subroutine ScalarGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_2D_gpu_wrapper\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid generic, public :: ScalarGridInterp_3D => ScalarGridInterp_3D_cpu , ScalarGridInterp_3D_gpu public subroutine ScalarGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGridInterp_3D_cpu public subroutine ScalarGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGridInterp_3D_gpu public subroutine ScalarGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorBoundaryInterp_2D => TensorBoundaryInterp_2D_cpu , TensorBoundaryInterp_2D_gpu public subroutine TensorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorBoundaryInterp_2D_cpu public subroutine TensorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorBoundaryInterp_2D_gpu public subroutine TensorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorBoundaryInterp_3D => TensorBoundaryInterp_3D_cpu , TensorBoundaryInterp_3D_gpu public subroutine TensorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorBoundaryInterp_3D_cpu public subroutine TensorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorBoundaryInterp_3D_gpu public subroutine TensorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, public :: UpdateDevice => UpdateDevice_Lagrange public subroutine UpdateDevice_Lagrange (myPoly) Copy the Lagrange attributes from the host (CPU) to the device (GPU) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance procedure, public :: UpdateHost => UpdateHost_Lagrange public subroutine UpdateHost_Lagrange (myPoly) Copy the Lagrange attributes from the device (GPU) to the host (CPU) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance generic, public :: VectorBoundaryInterp_2D => VectorBoundaryInterp_2D_cpu , VectorBoundaryInterp_2D_gpu public subroutine VectorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorBoundaryInterp_2D_cpu public subroutine VectorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorBoundaryInterp_2D_gpu public subroutine VectorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorBoundaryInterp_3D => VectorBoundaryInterp_3D_cpu , VectorBoundaryInterp_3D_gpu public subroutine VectorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorBoundaryInterp_3D_cpu public subroutine VectorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorBoundaryInterp_3D_gpu public subroutine VectorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorDGDivergence_2D => VectorDGDivergence_2D_cpu , VectorDGDivergence_2D_gpu public subroutine VectorDGDivergence_2D_cpu (myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_2D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGDivergence_2D_cpu public subroutine VectorDGDivergence_2D_cpu (myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGDivergence_2D_gpu public subroutine VectorDGDivergence_2D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorDGDivergence_3D => VectorDGDivergence_3D_cpu , VectorDGDivergence_3D_gpu public subroutine VectorDGDivergence_3D_cpu (myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_3D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGDivergence_3D_cpu public subroutine VectorDGDivergence_3D_cpu (myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGDivergence_3D_gpu public subroutine VectorDGDivergence_3D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorDivergence_2D => VectorDivergence_2D_cpu , VectorDivergence_2D_gpu public subroutine VectorDivergence_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDivergence_2D_cpu public subroutine VectorDivergence_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDivergence_2D_gpu public subroutine VectorDivergence_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorDivergence_3D => VectorDivergence_3D_cpu , VectorDivergence_3D_gpu public subroutine VectorDivergence_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDivergence_3D_cpu public subroutine VectorDivergence_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDivergence_3D_gpu public subroutine VectorDivergence_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorGradient_2D => VectorGradient_2D_cpu , VectorGradient_2D_gpu public subroutine VectorGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGradient_2D_cpu public subroutine VectorGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGradient_2D_gpu public subroutine VectorGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorGradient_3D => VectorGradient_3D_cpu , VectorGradient_3D_gpu public subroutine VectorGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGradient_3D_cpu public subroutine VectorGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGradient_3D_gpu public subroutine VectorGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorGridInterp_2D => VectorGridInterp_2D_cpu , VectorGridInterp_2D_gpu public subroutine VectorGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine VectorGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:VectorGridInterp_2D_gpu_wrapper\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid procedure, private :: VectorGridInterp_2D_cpu public subroutine VectorGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid procedure, private :: VectorGridInterp_2D_gpu public subroutine VectorGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:VectorGridInterp_2D_gpu_wrapper\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid generic, public :: VectorGridInterp_3D => VectorGridInterp_3D_cpu , VectorGridInterp_3D_gpu public subroutine VectorGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGridInterp_3D_cpu public subroutine VectorGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGridInterp_3D_gpu public subroutine VectorGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, public :: WriteHDF5 => WriteHDF5_Lagrange public subroutine WriteHDF5_Lagrange (this, fileId) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId Source Code TYPE , PUBLIC :: Lagrange !! A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions. !! The Lagrange data-structure stores the information necessary to interpolate between two !! sets of grid-points and to estimate the derivative of data at native grid points. Routines for !! multidimensional interpolation are based on the tensor product of 1-D interpolants. It is !! assumed that the polynomial degree (and the interpolation nodes) are the same in each direction. !! This assumption permits the storage of only one array of interpolation nodes and barycentric !! weights and is what allows this data structure to be flexible. INTEGER :: N !! The number of control points. INTEGER :: controlNodeType INTEGER :: M !! The number of target points. INTEGER :: targetNodeType TYPE ( hfReal_r1 ) :: controlPoints !! The set of nodes in one dimension where data is known. !! To create higher dimension interpolation and differentiation operators, structured grids in two and three !! dimensions are created by tensor products of the controlPoints. This design decision implies that all !! spectral element methods supported by the Lagrange class have the same polynomial degree in each !! computational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto, !! Legendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over !! the domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of !! these quadrature types or uniform points on [-1,1]. TYPE ( hfReal_r1 ) :: targetPoints !! The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation !! and differentiation operators, structured grids in two and three dimensions are created by tensor products of !! the targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1] !! (computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. TYPE ( hfReal_r1 ) :: bWeights !! The barycentric weights that are calculated from the controlPoints and used for interpolation. TYPE ( hfReal_r1 ) :: qWeights !! The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints !! provided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss, !! Chebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant !! dx = \\frac{2.0}{N+1}. TYPE ( hfReal_r2 ) :: iMatrix !! The interpolation matrix (transpose) for mapping data from the control grid to the target grid. TYPE ( hfReal_r2 ) :: dMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The !! dMatrix is based on a strong form of the derivative. TYPE ( hfReal_r2 ) :: dgMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based !! on a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. TYPE ( hfReal_r2 ) :: bMatrix !! The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. CONTAINS PROCEDURE , PUBLIC :: Init => Init_Lagrange PROCEDURE , PUBLIC :: Free => Free_Lagrange PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Lagrange PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Lagrange GENERIC , PUBLIC :: ScalarGridInterp_1D => ScalarGridInterp_1D_cpu , ScalarGridInterp_1D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_1D_cpu , ScalarGridInterp_1D_gpu GENERIC , PUBLIC :: ScalarGridInterp_2D => ScalarGridInterp_2D_cpu , ScalarGridInterp_2D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_2D_cpu , ScalarGridInterp_2D_gpu GENERIC , PUBLIC :: VectorGridInterp_2D => VectorGridInterp_2D_cpu , VectorGridInterp_2D_gpu PROCEDURE , PRIVATE :: VectorGridInterp_2D_cpu , VectorGridInterp_2D_gpu ! GENERIC,PUBLIC :: TensorGridInterp_2D => TensorGridInterp_2D_cpu,TensorGridInterp_2D_gpu ! PROCEDURE,PRIVATE :: TensorGridInterp_2D_cpu,TensorGridInterp_2D_gpu GENERIC , PUBLIC :: ScalarGridInterp_3D => ScalarGridInterp_3D_cpu , ScalarGridInterp_3D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_3D_cpu , ScalarGridInterp_3D_gpu GENERIC , PUBLIC :: VectorGridInterp_3D => VectorGridInterp_3D_cpu , VectorGridInterp_3D_gpu PROCEDURE , PRIVATE :: VectorGridInterp_3D_cpu , VectorGridInterp_3D_gpu ! GENERIC,PUBLIC :: TensorGridInterp_3D => TensorGridInterp_3D_cpu,TensorGridInterp_3D_gpu ! PROCEDURE,PRIVATE :: TensorGridInterp_3D_cpu,TensorGridInterp_3D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_1D => ScalarBoundaryInterp_1D_cpu , ScalarBoundaryInterp_1D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_1D_cpu , ScalarBoundaryInterp_1D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_2D => ScalarBoundaryInterp_2D_cpu , ScalarBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_2D_cpu , ScalarBoundaryInterp_2D_gpu GENERIC , PUBLIC :: VectorBoundaryInterp_2D => VectorBoundaryInterp_2D_cpu , VectorBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: VectorBoundaryInterp_2D_cpu , VectorBoundaryInterp_2D_gpu GENERIC , PUBLIC :: TensorBoundaryInterp_2D => TensorBoundaryInterp_2D_cpu , TensorBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: TensorBoundaryInterp_2D_cpu , TensorBoundaryInterp_2D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_3D => ScalarBoundaryInterp_3D_cpu , ScalarBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_3D_cpu , ScalarBoundaryInterp_3D_gpu GENERIC , PUBLIC :: VectorBoundaryInterp_3D => VectorBoundaryInterp_3D_cpu , VectorBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: VectorBoundaryInterp_3D_cpu , VectorBoundaryInterp_3D_gpu GENERIC , PUBLIC :: TensorBoundaryInterp_3D => TensorBoundaryInterp_3D_cpu , TensorBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: TensorBoundaryInterp_3D_cpu , TensorBoundaryInterp_3D_gpu GENERIC , PUBLIC :: Derivative_1D => Derivative_1D_cpu , Derivative_1D_gpu PROCEDURE , PRIVATE :: Derivative_1D_cpu , Derivative_1D_gpu GENERIC , PUBLIC :: DGDerivative_1D => DGDerivative_1D_cpu , DGDerivative_1D_gpu PROCEDURE , PRIVATE :: DGDerivative_1D_cpu , DGDerivative_1D_gpu GENERIC , PUBLIC :: ScalarGradient_2D => ScalarGradient_2D_cpu , ScalarGradient_2D_gpu PROCEDURE , PRIVATE :: ScalarGradient_2D_cpu , ScalarGradient_2D_gpu ! GENERIC,PUBLIC :: ScalarDGGradient_2D => ScalarDGGradient_2D_cpu,ScalarDGGradient_2D_gpu ! PROCEDURE,PRIVATE :: ScalarDGGradient_2D_cpu,ScalarDGGradient_2D_gpu GENERIC , PUBLIC :: VectorGradient_2D => VectorGradient_2D_cpu , VectorGradient_2D_gpu PROCEDURE , PRIVATE :: VectorGradient_2D_cpu , VectorGradient_2D_gpu ! GENERIC,PUBLIC :: VectorDGGradient_2D => VectorDGGradient_2D_cpu,VectorDGGradient_2D_gpu ! PROCEDURE,PRIVATE :: VectorDGGradient_2D_cpu,VectorDGGradient_2D_gpu GENERIC , PUBLIC :: VectorDivergence_2D => VectorDivergence_2D_cpu , VectorDivergence_2D_gpu PROCEDURE , PRIVATE :: VectorDivergence_2D_cpu , VectorDivergence_2D_gpu GENERIC , PUBLIC :: VectorDGDivergence_2D => VectorDGDivergence_2D_cpu , VectorDGDivergence_2D_gpu PROCEDURE , PRIVATE :: VectorDGDivergence_2D_cpu , VectorDGDivergence_2D_gpu ! GENERIC,PUBLIC :: P2VectorDivergence_2D => P2VectorDivergence_2D_cpu,P2VectorDivergence_2D_gpu ! PROCEDURE,PRIVATE :: P2VectorDivergence_2D_cpu,P2VectorDivergence_2D_gpu ! GENERIC,PUBLIC :: P2VectorDGDivergence_2D => P2VectorDGDivergence_2D_cpu,P2VectorDGDivergence_2D_gpu ! PROCEDURE,PRIVATE :: P2VectorDGDivergence_2D_cpu,P2VectorDGDivergence_2D_gpu ! GENERIC,PUBLIC :: VectorCurl_2D => VectorCurl_2D_cpu,VectorCurl_2D_gpu ! PROCEDURE,PRIVATE :: VectorCurl_2D_cpu,VectorCurl_2D_gpu ! GENERIC,PUBLIC :: TensorDivergence_2D => TensorDivergence_2D_cpu,TensorDivergence_2D_gpu ! PROCEDURE,PRIVATE :: TensorDivergence_2D_cpu,TensorDivergence_2D_gpu ! GENERIC,PUBLIC :: TensorDGDivergence_2D => TensorDGDivergence_2D_cpu,TensorDGDivergence_2D_gpu ! PROCEDURE,PRIVATE :: TensorDGDivergence_2D_cpu,TensorDGDivergence_2D_gpu GENERIC , PUBLIC :: ScalarGradient_3D => ScalarGradient_3D_cpu , ScalarGradient_3D_gpu PROCEDURE , PRIVATE :: ScalarGradient_3D_cpu , ScalarGradient_3D_gpu GENERIC , PUBLIC :: VectorGradient_3D => VectorGradient_3D_cpu , VectorGradient_3D_gpu PROCEDURE , PRIVATE :: VectorGradient_3D_cpu , VectorGradient_3D_gpu GENERIC , PUBLIC :: VectorDivergence_3D => VectorDivergence_3D_cpu , VectorDivergence_3D_gpu PROCEDURE , PRIVATE :: VectorDivergence_3D_cpu , VectorDivergence_3D_gpu GENERIC , PUBLIC :: VectorDGDivergence_3D => VectorDGDivergence_3D_cpu , VectorDGDivergence_3D_gpu PROCEDURE , PRIVATE :: VectorDGDivergence_3D_cpu , VectorDGDivergence_3D_gpu ! GENERIC,PUBLIC :: VectorCurl_3D => VectorCurl_3D_cpu,VectorCurl_3D_gpu ! PROCEDURE,PRIVATE :: VectorCurl_3D_cpu,VectorCurl_3D_gpu ! GENERIC,PUBLIC :: TensorDivergence_3D => TensorDivergence_3D_cpu,TensorDivergence_3D_gpu ! PROCEDURE,PRIVATE :: TensorDivergence_3D_cpu,TensorDivergence_3D_gpu ! GENERIC,PUBLIC :: TensorDGDivergence_3D => TensorDGDivergence_3D_cpu,TensorDGDivergence_3D_gpu ! PROCEDURE,PRIVATE :: TensorDGDivergence_3D_cpu,TensorDGDivergence_3D_gpu PROCEDURE , PUBLIC :: WriteHDF5 => WriteHDF5_Lagrange PROCEDURE , PRIVATE :: CalculateBarycentricWeights PROCEDURE , PRIVATE :: CalculateInterpolationMatrix PROCEDURE , PRIVATE :: CalculateDerivativeMatrix PROCEDURE , PRIVATE :: CalculateLagrangePolynomials END TYPE Lagrange","tags":"","loc":"type/lagrange.html"},{"title":"Model – SELF ","text":"type, public, ABSTRACT :: Model Contents Variables decomp dt entropy gpuAccel ioIterate t timeIntegrator Type-Bound Procedures AdamsBashforth2_timeIntegrator AdamsBashforth3_timeIntegrator AdamsBashforth4_timeIntegrator CalculateEntropy CalculateTendency DisableGPUAccel EnableGPUAccel Euler_timeIntegrator FluxMethod ForwardStep GetSimulationTime IncrementIOCounter LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreFlux PreTendency PrintType ReadModel ReportEntropy ResizePrevSol RiemannSolver SetBoundaryCondition SetInitialConditions SetSimulationTime SetTimeIntegrator SetTimeIntegrator_withChar SetTimeIntegrator_withInt SourceMethod UpdateBoundary UpdateGAB2 UpdateGAB3 UpdateGAB4 UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot Source Code Model Components Type Visibility Attributes Name Initial type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy logical, public :: gpuAccel integer, public :: ioIterate = 0 real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator public subroutine AdamsBashforth2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth3_timeIntegrator public subroutine AdamsBashforth3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth4_timeIntegrator public subroutine AdamsBashforth4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: CalculateEntropy => CalculateEntropy_Model public subroutine CalculateEntropy_Model (this) Base method for calculating entropy of a model\nWhen this method is not overridden, the entropy\nis simply set to 0.0. When you develop a model\nbuilt on top of this abstract class or one of its\nchildren, it is recommended that you define a\nconvex mathematical entropy function that is used\nas a measure of the model stability. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure( CalculateTendency ), public, deferred :: CalculateTendency subroutine CalculateTendency(this) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: DisableGPUAccel => DisableGPUAccel_Model public subroutine DisableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: EnableGPUAccel => EnableGPUAccel_Model public subroutine EnableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => Flux_Model public subroutine Flux_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: tn real(kind=prec), intent(in), optional :: dt real(kind=prec), intent(in), optional :: ioInterval procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreFlux => PreFlux_Model public subroutine PreFlux_Model (this) PreFlux is a template routine that is used to house any additional calculations\nthat you want to execute just before the calculation of flux terms.\nThis default PreFlux simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure( ReadModel ), public, deferred :: ReadModel subroutine ReadModel(this, filename) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: filename procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure( ResizePrevSol ), public, deferred :: ResizePrevSol subroutine ResizePrevSol(this, m) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m procedure, public :: RiemannSolver => RiemannSolver_Model public subroutine RiemannSolver_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetBoundaryCondition => SetBoundaryCondition_Model public subroutine SetBoundaryCondition_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetInitialConditions => SetInitialConditions_Model public subroutine SetInitialConditions_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt , SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withInt (this, integrator) Sets the time integrator method, using an integer flag Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: integrator public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, private :: SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, private :: SetTimeIntegrator_withInt public subroutine SetTimeIntegrator_withInt (this, integrator) Sets the time integrator method, using an integer flag Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: integrator procedure, public :: SourceMethod => Source_Model public subroutine Source_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: UpdateBoundary => UpdateBoundary_Model public subroutine UpdateBoundary_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure( UpdateGAB ), public, deferred :: UpdateGAB2 subroutine UpdateGAB(this, m) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m procedure( UpdateGAB ), public, deferred :: UpdateGAB3 subroutine UpdateGAB(this, m) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m procedure( UpdateGAB ), public, deferred :: UpdateGAB4 subroutine UpdateGAB(this, m) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m procedure( UpdateGRK ), public, deferred :: UpdateGRK2 subroutine UpdateGRK(this, m) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m procedure( UpdateGRK ), public, deferred :: UpdateGRK3 subroutine UpdateGRK(this, m) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m procedure( UpdateGRK ), public, deferred :: UpdateGRK4 subroutine UpdateGRK(this, m) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m procedure( UpdateSolution ), public, deferred :: UpdateSolution subroutine UpdateSolution(this, dt) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure( WriteModel ), public, deferred :: WriteModel subroutine WriteModel(this, filename) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in), optional :: filename procedure( WriteTecplot ), public, deferred :: WriteTecplot subroutine WriteTecplot(this, filename) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in), optional :: filename Source Code TYPE , ABSTRACT :: Model LOGICAL :: gpuAccel ! Time integration attributes PROCEDURE ( SELF_timeIntegrator ), POINTER :: timeIntegrator => Euler_timeIntegrator REAL ( prec ) :: dt REAL ( prec ) :: t INTEGER :: ioIterate = 0 ! Standard Diagnostics REAL ( prec ) :: entropy ! Mathematical entropy function for the model ! Domain Decomposition TYPE ( MPILayer ), POINTER :: decomp CONTAINS PROCEDURE :: IncrementIOCounter PROCEDURE :: PrintType => PrintType_Model PROCEDURE :: SetInitialConditions => SetInitialConditions_Model PROCEDURE :: ForwardStep => ForwardStep_Model PROCEDURE :: Euler_timeIntegrator ! Adams-Bashforth Methods PROCEDURE ( ResizePrevSol ), DEFERRED :: ResizePrevSol PROCEDURE :: AdamsBashforth2_timeIntegrator PROCEDURE ( UpdateGAB ), DEFERRED :: UpdateGAB2 PROCEDURE :: AdamsBashforth3_timeIntegrator PROCEDURE ( UpdateGAB ), DEFERRED :: UpdateGAB3 PROCEDURE :: AdamsBashforth4_timeIntegrator PROCEDURE ( UpdateGAB ), DEFERRED :: UpdateGAB4 ! Runge-Kutta methods PROCEDURE :: LowStorageRK2_timeIntegrator PROCEDURE ( UpdateGRK ), DEFERRED :: UpdateGRK2 PROCEDURE :: LowStorageRK3_timeIntegrator PROCEDURE ( UpdateGRK ), DEFERRED :: UpdateGRK3 PROCEDURE :: LowStorageRK4_timeIntegrator PROCEDURE ( UpdateGRK ), DEFERRED :: UpdateGRK4 !    PROCEDURE :: CrankNicholson_timeIntegrator PROCEDURE :: PreTendency => PreTendency_Model PROCEDURE :: PreFlux => PreFlux_Model PROCEDURE :: SourceMethod => Source_Model PROCEDURE :: FluxMethod => Flux_Model PROCEDURE :: RiemannSolver => RiemannSolver_Model PROCEDURE :: UpdateBoundary => UpdateBoundary_Model PROCEDURE :: SetBoundaryCondition => SetBoundaryCondition_Model PROCEDURE :: ReportEntropy => ReportEntropy_Model PROCEDURE :: CalculateEntropy => CalculateEntropy_Model PROCEDURE ( UpdateSolution ), DEFERRED :: UpdateSolution PROCEDURE ( CalculateTendency ), DEFERRED :: CalculateTendency PROCEDURE ( ReadModel ), DEFERRED :: ReadModel PROCEDURE ( WriteModel ), DEFERRED :: WriteModel PROCEDURE ( WriteTecplot ), DEFERRED :: WriteTecplot GENERIC :: SetTimeIntegrator => SetTimeIntegrator_withInt , & SetTimeIntegrator_withChar PROCEDURE , PRIVATE :: SetTimeIntegrator_withInt PROCEDURE , PRIVATE :: SetTimeIntegrator_withChar PROCEDURE :: SetSimulationTime PROCEDURE :: GetSimulationTime PROCEDURE :: EnableGPUAccel => EnableGPUAccel_Model PROCEDURE :: DisableGPUAccel => DisableGPUAccel_Model END TYPE Model","tags":"","loc":"type/model.html"},{"title":"hfInt32_r1 – SELF ","text":"type, public :: hfInt32_r1 Data type for storing one-dimensional int32 arrays on the host and the device Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r1 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r1 public subroutine Alloc_hfInt32_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound procedure, public :: Free => Free_hfInt32_r1 public subroutine Free_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r1 public subroutine UpdateDevice_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r1 public subroutine UpdateHost_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this Source Code TYPE hfInt32_r1 !! Data type for storing one-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r1 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r1 END TYPE hfInt32_r1","tags":"","loc":"type/hfint32_r1.html"},{"title":"hfInt32_r2 – SELF ","text":"type, public :: hfInt32_r2 Data type for storing two-dimensional int32 arrays on the host and the device Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r2 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r2 public subroutine Alloc_hfInt32_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) procedure, public :: Free => Free_hfInt32_r2 public subroutine Free_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r2 public subroutine UpdateDevice_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r2 public subroutine UpdateHost_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this Source Code TYPE hfInt32_r2 !! Data type for storing two-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r2 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r2 END TYPE hfInt32_r2","tags":"","loc":"type/hfint32_r2.html"},{"title":"hfInt32_r3 – SELF ","text":"type, public :: hfInt32_r3 Data type for storing three-dimensional int32 arrays on the host and the device Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r3 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r3 public subroutine Alloc_hfInt32_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) procedure, public :: Free => Free_hfInt32_r3 public subroutine Free_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r3 public subroutine UpdateDevice_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r3 public subroutine UpdateHost_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this Source Code TYPE hfInt32_r3 !! Data type for storing three-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r3 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r3 END TYPE hfInt32_r3","tags":"","loc":"type/hfint32_r3.html"},{"title":"hfInt32_r4 – SELF ","text":"type, public :: hfInt32_r4 Data type for storing four-dimensional int32 arrays on the host and the device Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r4 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r4 public subroutine Alloc_hfInt32_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) procedure, public :: Free => Free_hfInt32_r4 public subroutine Free_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r4 public subroutine UpdateDevice_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r4 public subroutine UpdateHost_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this Source Code TYPE hfInt32_r4 !! Data type for storing four-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r4 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r4 END TYPE hfInt32_r4","tags":"","loc":"type/hfint32_r4.html"},{"title":"hfReal_r1 – SELF ","text":"type, public :: hfReal_r1 Data type for storing one-dimensional real arrays on the host and the device Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r1 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r1 public subroutine Alloc_hfReal_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound procedure, public :: Free => Free_hfReal_r1 public subroutine Free_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r1 public subroutine UpdateDevice_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r1 public subroutine UpdateHost_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this Source Code TYPE hfReal_r1 !! Data type for storing one-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r1 PROCEDURE , PUBLIC :: Free => Free_hfReal_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r1 END TYPE hfReal_r1","tags":"","loc":"type/hfreal_r1.html"},{"title":"hfReal_r2 – SELF ","text":"type, public :: hfReal_r2 Data type for storing two-dimensional real arrays on the host and the device Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r2 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r2 public subroutine Alloc_hfReal_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) procedure, public :: Free => Free_hfReal_r2 public subroutine Free_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r2 public subroutine UpdateDevice_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r2 public subroutine UpdateHost_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this Source Code TYPE hfReal_r2 !! Data type for storing two-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r2 PROCEDURE , PUBLIC :: Free => Free_hfReal_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r2 END TYPE hfReal_r2","tags":"","loc":"type/hfreal_r2.html"},{"title":"hfReal_r3 – SELF ","text":"type, public :: hfReal_r3 Data type for storing three-dimensional real arrays on the host and the device Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r3 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r3 public subroutine Alloc_hfReal_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) procedure, public :: Free => Free_hfReal_r3 public subroutine Free_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r3 public subroutine UpdateDevice_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r3 public subroutine UpdateHost_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this Source Code TYPE hfReal_r3 !! Data type for storing three-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r3 PROCEDURE , PUBLIC :: Free => Free_hfReal_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r3 END TYPE hfReal_r3","tags":"","loc":"type/hfreal_r3.html"},{"title":"hfReal_r4 – SELF ","text":"type, public :: hfReal_r4 Data type for storing four-dimensional real arrays on the host and the device Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r4 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r4 public subroutine Alloc_hfReal_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) procedure, public :: Free => Free_hfReal_r4 public subroutine Free_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r4 public subroutine UpdateDevice_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r4 public subroutine UpdateHost_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this Source Code TYPE hfReal_r4 !! Data type for storing four-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r4 PROCEDURE , PUBLIC :: Free => Free_hfReal_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r4 END TYPE hfReal_r4","tags":"","loc":"type/hfreal_r4.html"},{"title":"hfReal_r5 – SELF ","text":"type, public :: hfReal_r5 Data type for storing five-dimensional real arrays on the host and the device Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r5 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r5 public subroutine Alloc_hfReal_r5 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) procedure, public :: Free => Free_hfReal_r5 public subroutine Free_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r5 public subroutine UpdateDevice_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r5 public subroutine UpdateHost_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this Source Code TYPE hfReal_r5 !! Data type for storing five-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r5 PROCEDURE , PUBLIC :: Free => Free_hfReal_r5 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r5 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r5 END TYPE hfReal_r5","tags":"","loc":"type/hfreal_r5.html"},{"title":"hfReal_r6 – SELF ","text":"type, public :: hfReal_r6 Data type for storing one-dimensional real arrays on the host and the device Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r6 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r6 public subroutine Alloc_hfReal_r6 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) procedure, public :: Free => Free_hfReal_r6 public subroutine Free_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r6 public subroutine UpdateDevice_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r6 public subroutine UpdateHost_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this Source Code TYPE hfReal_r6 !! Data type for storing one-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r6 PROCEDURE , PUBLIC :: Free => Free_hfReal_r6 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r6 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r6 END TYPE hfReal_r6","tags":"","loc":"type/hfreal_r6.html"},{"title":"hfReal_r7 – SELF ","text":"type, public :: hfReal_r7 Data type for storing seven-dimensional real arrays on the host and the device Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r7 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r7 public subroutine Alloc_hfReal_r7 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) procedure, public :: Free => Free_hfReal_r7 public subroutine Free_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r7 public subroutine UpdateDevice_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r7 public subroutine UpdateHost_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this Source Code TYPE hfReal_r7 !! Data type for storing seven-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r7 PROCEDURE , PUBLIC :: Free => Free_hfReal_r7 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r7 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r7 END TYPE hfReal_r7","tags":"","loc":"type/hfreal_r7.html"},{"title":"Geometry1D – SELF ","text":"type, public, extends( SEMGeometry ) :: Geometry1D Contents Variables dxds nElem x Type-Bound Procedures CalculateMetricTerms Free GenerateFromMesh Init UpdateDevice UpdateHost Write Source Code Geometry1D Components Type Visibility Attributes Name Initial type( Scalar1D ), public :: dxds integer, public :: nElem type( Scalar1D ), public :: x Type-Bound Procedures procedure, public :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D public subroutine CalculateMetricTerms_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom procedure, public :: Free => Free_Geometry1D public subroutine Free_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom procedure, public :: GenerateFromMesh => GenerateFromMesh_Geometry1D public subroutine GenerateFromMesh_Geometry1D (myGeom, mesh) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom type( Mesh1D ), intent(in) :: mesh procedure, public :: Init => Init_Geometry1D public subroutine Init_Geometry1D (myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom type( Lagrange ), intent(in), POINTER :: interp integer, intent(in) :: nElem procedure, public :: UpdateDevice => UpdateDevice_Geometry1D public subroutine UpdateDevice_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom procedure, public :: UpdateHost => UpdateHost_Geometry1D public subroutine UpdateHost_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom procedure, public :: Write => Write_Geometry1D public subroutine Write_Geometry1D (myGeom, fileName) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(in) :: myGeom character, intent(in), optional :: fileName Source Code TYPE , EXTENDS ( SEMGeometry ), PUBLIC :: Geometry1D TYPE ( Scalar1D ) :: x ! Physical Positions TYPE ( Scalar1D ) :: dxds ! Conversion from computational to physical space CONTAINS PROCEDURE , PUBLIC :: Init => Init_Geometry1D PROCEDURE , PUBLIC :: Free => Free_Geometry1D PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_Geometry1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Geometry1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Geometry1D PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D PROCEDURE :: Write => Write_Geometry1D END TYPE Geometry1D","tags":"","loc":"type/geometry1d.html"},{"title":"SEMGeometry – SELF ","text":"type, public :: SEMGeometry Contents Variables nElem Source Code SEMGeometry Components Type Visibility Attributes Name Initial integer, public :: nElem Source Code TYPE , PUBLIC :: SEMGeometry INTEGER :: nElem END TYPE SEMGeometry","tags":"","loc":"type/semgeometry.html"},{"title":"SEMHex – SELF ","text":"type, public, extends( SEMGeometry ) :: SEMHex Contents Variables J dsdx dxds nElem nHat nScale x Type-Bound Procedures CalculateContravariantBasis CalculateMetricTerms CheckSides Free GenerateFromMesh Init UpdateDevice UpdateHost Source Code SEMHex Components Type Visibility Attributes Name Initial type( Scalar3D ), public :: J type( Tensor3D ), public :: dsdx type( Tensor3D ), public :: dxds integer, public :: nElem type( Vector3D ), public :: nHat type( Scalar3D ), public :: nScale type( Vector3D ), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex public subroutine CalculateContravariantBasis_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMHex public subroutine CalculateMetricTerms_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom procedure, private :: CheckSides => CheckSides_SEMHex public subroutine CheckSides_SEMHex (myGeom, mesh) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(in) :: myGeom type( Mesh3D ), intent(in) :: mesh procedure, public :: Free => Free_SEMHex public subroutine Free_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMHex public subroutine GenerateFromMesh_SEMHex (myGeom, mesh) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom type( Mesh3D ), intent(in) :: mesh procedure, public :: Init => Init_SEMHex public subroutine Init_SEMHex (myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom type( Lagrange ), intent(in), POINTER :: interp integer, intent(in) :: nElem procedure, public :: UpdateDevice => UpdateDevice_SEMHex public subroutine UpdateDevice_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom procedure, public :: UpdateHost => UpdateHost_SEMHex public subroutine UpdateHost_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Source Code TYPE , EXTENDS ( SEMGeometry ), PUBLIC :: SEMHex TYPE ( Vector3D ) :: x ! Physical positions TYPE ( Tensor3D ) :: dxds ! Covariant basis vectors TYPE ( Tensor3D ) :: dsdx ! Contavariant basis vectors TYPE ( Vector3D ) :: nHat ! Normal Vectors pointing across coordinate lines TYPE ( Scalar3D ) :: nScale ! Boundary scale TYPE ( Scalar3D ) :: J ! Jacobian of the transformation CONTAINS PROCEDURE , PUBLIC :: Init => Init_SEMHex PROCEDURE , PUBLIC :: Free => Free_SEMHex PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_SEMHex PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_SEMHex PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_SEMHex PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_SEMHex PROCEDURE , PRIVATE :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex PROCEDURE , PRIVATE :: CheckSides => CheckSides_SEMHex !PROCEDURE :: Write => Write_SEMHex END TYPE SEMHex","tags":"","loc":"type/semhex.html"},{"title":"SEMQuad – SELF ","text":"type, public, extends( SEMGeometry ) :: SEMQuad Contents Variables J dsdx dxds nElem nHat nScale x Type-Bound Procedures CalculateContravariantBasis CalculateMetricTerms CovariantArcMin Free GenerateFromMesh Init UpdateDevice UpdateHost Source Code SEMQuad Components Type Visibility Attributes Name Initial type( Scalar2D ), public :: J type( Tensor2D ), public :: dsdx type( Tensor2D ), public :: dxds integer, public :: nElem type( Vector2D ), public :: nHat type( Scalar2D ), public :: nScale type( Vector2D ), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad public subroutine CalculateContravariantBasis_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad public subroutine CalculateMetricTerms_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom procedure, public :: CovariantArcMin => CovariantArcMin_SEMQuad public function CovariantArcMin_SEMQuad (myGeom) result(dxMin) Arguments Type Intent Optional Attributes Name class( SEMQuad ) :: myGeom Return Value real(kind=prec) procedure, public :: Free => Free_SEMQuad public subroutine Free_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMQuad public subroutine GenerateFromMesh_SEMQuad (myGeom, mesh) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom type( Mesh2D ), intent(in) :: mesh procedure, public :: Init => Init_SEMQuad public subroutine Init_SEMQuad (myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom type( Lagrange ), intent(in), POINTER :: interp integer, intent(in) :: nElem procedure, public :: UpdateDevice => UpdateDevice_SEMQuad public subroutine UpdateDevice_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom procedure, public :: UpdateHost => UpdateHost_SEMQuad public subroutine UpdateHost_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Source Code TYPE , EXTENDS ( SEMGeometry ), PUBLIC :: SEMQuad TYPE ( Vector2D ) :: x ! Physical positions TYPE ( Tensor2D ) :: dxds ! Covariant basis vectors TYPE ( Tensor2D ) :: dsdx ! Contavariant basis vectors TYPE ( Vector2D ) :: nHat ! Normal Vectors pointing across coordinate lines TYPE ( Scalar2D ) :: nScale ! Boundary scale TYPE ( Scalar2D ) :: J ! Jacobian of the transformation CONTAINS PROCEDURE , PUBLIC :: Init => Init_SEMQuad PROCEDURE , PUBLIC :: Free => Free_SEMQuad PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_SEMQuad PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_SEMQuad PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_SEMQuad PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad PROCEDURE , PRIVATE :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad PROCEDURE , PUBLIC :: CovariantArcMin => CovariantArcMin_SEMQuad !PROCEDURE :: Write => Write_SEMQuad END TYPE SEMQuad","tags":"","loc":"type/semquad.html"},{"title":"MappedScalar1D – SELF ","text":"type, public, extends( Scalar1D ) :: MappedScalar1D Contents Variables avgBoundary boundary eqn extBoundary interior interp jumpBoundary meta nElem nVar Type-Bound Procedures BassiRebaySides BoundaryInterp Derivative Derivative_MappedScalar1D Free GridInterp Init JacobianWeight SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedScalar1D Components Type Visibility Attributes Name Initial type( hfReal_r3 ), public :: avgBoundary type( hfReal_r3 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r3 ), public :: extBoundary type( hfReal_r3 ), public :: interior type( Lagrange ), public, POINTER :: interp type( hfReal_r3 ), public :: jumpBoundary type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BassiRebaySides => BassiRebaySides_MappedScalar1D public subroutine BassiRebaySides_MappedScalar1D (scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D public subroutine BoundaryInterp_Scalar1D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel generic, public :: Derivative => Derivative_Scalar1D , Derivative_MappedScalar1D public subroutine Derivative_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Derivative_MappedScalar1D (scalar, geometry, dF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: scalar type( Geometry1D ), intent(in) :: geometry type( MappedScalar1D ), intent(inout) :: dF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Derivative_MappedScalar1D public subroutine Derivative_MappedScalar1D (scalar, geometry, dF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: scalar type( Geometry1D ), intent(in) :: geometry type( MappedScalar1D ), intent(inout) :: dF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, public :: Free => Free_Scalar1D public subroutine Free_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage procedure, public :: GridInterp => GridInterp_Scalar1D public subroutine GridInterp_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Scalar1D public subroutine Init_Scalar1D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: JacobianWeight => JacobianWeight_MappedScalar1D public subroutine JacobianWeight_MappedScalar1D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar type( Geometry1D ), intent(in) :: geometry logical, intent(in) :: gpuAccel procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (SELFStorage, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar1D public subroutine SetInteriorFromEquation_MappedScalar1D (scalar, geometry, time) Sets the scalar % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar type( Geometry1D ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (SELFStorage, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (SELFStorage, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedScalar1D public subroutine SideExchange_MappedScalar1D (scalar, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar type( Mesh1D ), intent(in) :: mesh type( MPILayer ), intent(inout) :: decomp logical, intent(in) :: gpuAccel procedure, public :: UpdateDevice => UpdateDevice_Scalar1D public subroutine UpdateDevice_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Scalar1D public subroutine UpdateHost_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage generic, public :: WriteHDF5 => WriteHDF5_Scalar1D , WriteHDF5_MPI_Scalar1D public subroutine WriteHDF5_Scalar1D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group public subroutine WriteHDF5_MPI_Scalar1D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem Source Code TYPE , EXTENDS ( Scalar1D ), PUBLIC :: MappedScalar1D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedScalar1D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedScalar1D GENERIC , PUBLIC :: Derivative => Derivative_MappedScalar1D PROCEDURE , PRIVATE :: Derivative_MappedScalar1D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedScalar1D PROCEDURE , PUBLIC :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar1D END TYPE MappedScalar1D","tags":"","loc":"type/mappedscalar1d.html"},{"title":"MappedScalar2D – SELF ","text":"type, public, extends( Scalar2D ) :: MappedScalar2D Contents Variables avgBoundary boundary eqn extBoundary interior interp jumpBoundary meta nElem nVar Type-Bound Procedures ApplyFlip BassiRebaySides BoundaryInterp Free Gradient GradientBR_MappedScalar2D GradientSF_MappedScalar2D Gradient_MappedScalar2D GridInterp Init Integral JacobianWeight MPIExchangeAsync SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedScalar2D Components Type Visibility Attributes Name Initial type( hfReal_r4 ), public :: avgBoundary type( hfReal_r4 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r4 ), public :: extBoundary type( hfReal_r4 ), public :: interior type( Lagrange ), public, POINTER :: interp type( hfReal_r4 ), public :: jumpBoundary type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedScalar2D public subroutine ApplyFlip_MappedScalar2D (scalar, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( MPILayer ), intent(inout) :: mpiHandler type( Mesh2D ), intent(in) :: mesh logical, intent(in) :: gpuAccel procedure, public :: BassiRebaySides => BassiRebaySides_MappedScalar2D public subroutine BassiRebaySides_MappedScalar2D (scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D public subroutine BoundaryInterp_Scalar2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, public :: Free => Free_Scalar2D public subroutine Free_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Scalar2D , Gradient_MappedScalar2D public subroutine Gradient_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Gradient_MappedScalar2D (scalar, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( SEMQuad ), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: GradientBR_MappedScalar2D public subroutine GradientBR_MappedScalar2D (scalar, geometry, gradF, gpuAccel) Calculates the gradient of a scalar 2D function using a bassi-rebay method Read more… Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( SEMQuad ), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF logical, intent(in) :: gpuAccel procedure, private :: GradientSF_MappedScalar2D public subroutine GradientSF_MappedScalar2D (scalar, geometry, gradF, gpuAccel) Calculates the gradient of a scalar 2D function using the conservative form of the\nmapped gradient operator Read more… Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type( SEMQuad ), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF logical, intent(in) :: gpuAccel procedure, private :: Gradient_MappedScalar2D public subroutine Gradient_MappedScalar2D (scalar, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( SEMQuad ), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Scalar2D public subroutine GridInterp_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Scalar2D public subroutine Init_Scalar2D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: Integral => Integral_MappedScalar2D public function Integral_MappedScalar2D (this, geometry, decomp, gpuAccel) result(fRes) Calculates the area integral the scalar over all of the geometry.\nGlobal reduction is done across all MPI ranks when the domain\ndecomposition indicates MPI is enabled. Arguments Type Intent Optional Attributes Name class( MappedScalar2D ) :: this type( SEMQuad ) :: geometry type( MPILayer ) :: decomp logical :: gpuAccel Return Value real(kind=prec) procedure, public :: JacobianWeight => JacobianWeight_MappedScalar2D public subroutine JacobianWeight_MappedScalar2D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( SEMQuad ), intent(in) :: geometry logical, intent(in) :: gpuAccel procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D public subroutine MPIExchangeAsync_MappedScalar2D (scalar, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( MPILayer ), intent(inout) :: mpiHandler type( Mesh2D ), intent(in) :: mesh logical, intent(in) :: resetCount procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (SELFStorage, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar2D public subroutine SetInteriorFromEquation_MappedScalar2D (scalar, geometry, time) Sets the scalar % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (SELFStorage, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (SELFStorage, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedScalar2D public subroutine SideExchange_MappedScalar2D (scalar, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( Mesh2D ), intent(in) :: mesh type( MPILayer ), intent(inout) :: decomp logical, intent(in) :: gpuAccel procedure, public :: UpdateDevice => UpdateDevice_Scalar2D public subroutine UpdateDevice_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Scalar2D public subroutine UpdateHost_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D , WriteHDF5_Scalar2D public subroutine WriteHDF5_MPI_Scalar2D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar2D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code TYPE , EXTENDS ( Scalar2D ), PUBLIC :: MappedScalar2D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedScalar2D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedScalar2D GENERIC , PUBLIC :: Gradient => Gradient_MappedScalar2D PROCEDURE , PRIVATE :: Gradient_MappedScalar2D PROCEDURE , PRIVATE :: GradientSF_MappedScalar2D ! Strong-Form Gradient PROCEDURE , PRIVATE :: GradientBR_MappedScalar2D ! Bassi-Rebay Gradient PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedScalar2D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedScalar2D PROCEDURE , PUBLIC :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar2D PROCEDURE , PUBLIC :: Integral => Integral_MappedScalar2D END TYPE MappedScalar2D","tags":"","loc":"type/mappedscalar2d.html"},{"title":"MappedScalar3D – SELF ","text":"type, public, extends( Scalar3D ) :: MappedScalar3D Contents Variables avgBoundary boundary eqn extBoundary interior interp jumpBoundary meta nElem nVar Type-Bound Procedures ApplyFlip BassiRebaySides BoundaryInterp Free Gradient GradientBR_MappedScalar3D GradientSF_MappedScalar3D Gradient_MappedScalar3D GridInterp Init JacobianWeight MPIExchangeAsync SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedScalar3D Components Type Visibility Attributes Name Initial type( hfReal_r5 ), public :: avgBoundary type( hfReal_r5 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r5 ), public :: extBoundary type( hfReal_r5 ), public :: interior type( Lagrange ), public, POINTER :: interp type( hfReal_r5 ), public :: jumpBoundary type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedScalar3D public subroutine ApplyFlip_MappedScalar3D (scalar, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( MPILayer ), intent(inout) :: mpiHandler type( Mesh3D ), intent(in) :: mesh logical, intent(in) :: gpuAccel procedure, public :: BassiRebaySides => BassiRebaySides_MappedScalar3D public subroutine BassiRebaySides_MappedScalar3D (scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D public subroutine BoundaryInterp_Scalar3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, public :: Free => Free_Scalar3D public subroutine Free_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Scalar3D , Gradient_MappedScalar3D public subroutine Gradient_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Gradient_MappedScalar3D (scalar, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( SEMHex ), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: GradientBR_MappedScalar3D public subroutine GradientBR_MappedScalar3D (scalar, geometry, gradF, gpuAccel) Calculates the gradient of a scalar 3D function using a bassi-rebay method Read more… Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( SEMHex ), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF logical, intent(in) :: gpuAccel procedure, private :: GradientSF_MappedScalar3D public subroutine GradientSF_MappedScalar3D (scalar, geometry, gradF, gpuAccel) Calculates the gradient of a scalar 3D function using the conservative form of the\nmapped gradient operator Read more… Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type( SEMHex ), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF logical, intent(in) :: gpuAccel procedure, private :: Gradient_MappedScalar3D public subroutine Gradient_MappedScalar3D (scalar, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( SEMHex ), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Scalar3D public subroutine GridInterp_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Scalar3D public subroutine Init_Scalar3D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: JacobianWeight => JacobianWeight_MappedScalar3D public subroutine JacobianWeight_MappedScalar3D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( SEMHex ), intent(in) :: geometry logical, intent(in) :: gpuAccel procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D public subroutine MPIExchangeAsync_MappedScalar3D (scalar, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( MPILayer ), intent(inout) :: mpiHandler type( Mesh3D ), intent(in) :: mesh logical, intent(in) :: resetCount procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (SELFStorage, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar3D public subroutine SetInteriorFromEquation_MappedScalar3D (scalar, geometry, time) Sets the scalar % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (SELFStorage, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (SELFStorage, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedScalar3D public subroutine SideExchange_MappedScalar3D (scalar, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( Mesh3D ), intent(in) :: mesh type( MPILayer ), intent(inout) :: decomp logical, intent(in) :: gpuAccel procedure, public :: UpdateDevice => UpdateDevice_Scalar3D public subroutine UpdateDevice_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Scalar3D public subroutine UpdateHost_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D , WriteHDF5_Scalar3D public subroutine WriteHDF5_MPI_Scalar3D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar3D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code TYPE , EXTENDS ( Scalar3D ), PUBLIC :: MappedScalar3D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedScalar3D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedScalar3D GENERIC , PUBLIC :: Gradient => Gradient_MappedScalar3D PROCEDURE , PRIVATE :: Gradient_MappedScalar3D PROCEDURE , PRIVATE :: GradientSF_MappedScalar3D ! Strong-Form Gradient PROCEDURE , PRIVATE :: GradientBR_MappedScalar3D ! Bassi-Rebay Gradient PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedScalar3D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedScalar3D PROCEDURE , PUBLIC :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar3D END TYPE MappedScalar3D","tags":"","loc":"type/mappedscalar3d.html"},{"title":"MappedVector2D – SELF ","text":"type, public, extends( Vector2D ) :: MappedVector2D Contents Variables boundary boundaryNormal eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures ApplyFlip BassiRebaySides BoundaryInterp ContravariantProjection Divergence Divergence_MappedVector2D Free Gradient GridInterp Init JacobianWeight MPIExchangeAsync SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedVector2D Components Type Visibility Attributes Name Initial type( hfReal_r5 ), public :: boundary type( hfReal_r4 ), public :: boundaryNormal type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r5 ), public :: extBoundary type( hfReal_r5 ), public :: interior type( Lagrange ), public, POINTER :: interp type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedVector2D public subroutine ApplyFlip_MappedVector2D (vector, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( MPILayer ), intent(inout) :: mpiHandler type( Mesh2D ), intent(in) :: mesh logical, intent(in) :: gpuAccel procedure, public :: BassiRebaySides => BassiRebaySides_MappedVector2D public subroutine BassiRebaySides_MappedVector2D (vector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector logical, intent(in) :: gpuAccel procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D public subroutine BoundaryInterp_Vector2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, public :: ContravariantProjection => ContravariantProjection_MappedVector2D public subroutine ContravariantProjection_MappedVector2D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( SEMQuad ), intent(in) :: geometry logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_Vector2D , Divergence_MappedVector2D public subroutine Divergence_Vector2D (SELFStorage, SELFOut, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Divergence_MappedVector2D (compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: compVector type( SEMQuad ), intent(in) :: geometry type( MappedScalar2D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Divergence_MappedVector2D public subroutine Divergence_MappedVector2D (compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: compVector type( SEMQuad ), intent(in) :: geometry type( MappedScalar2D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, public :: Free => Free_Vector2D public subroutine Free_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Vector2D public subroutine Gradient_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Vector2D public subroutine GridInterp_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Vector2D public subroutine Init_Vector2D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: JacobianWeight => JacobianWeight_MappedVector2D public subroutine JacobianWeight_MappedVector2D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( SEMQuad ), intent(in) :: geometry logical, intent(in) :: gpuAccel procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D public subroutine MPIExchangeAsync_MappedVector2D (vector, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( MPILayer ), intent(inout) :: mpiHandler type( Mesh2D ), intent(in) :: mesh logical, intent(in) :: resetCount procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (SELFStorage, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector2D public subroutine SetEquation_DataObj (SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector2D (SELFStorage, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector2D public subroutine SetInteriorFromEquation_MappedVector2D (vector, geometry, time) Sets the scalar % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (SELFStorage, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (SELFStorage, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedVector2D public subroutine SideExchange_MappedVector2D (vector, mesh, decomp, gpuAccel) SideExchange_MappedVectorvector2D is used to populate vector % extBoundary\nby finding neighboring elements that share a side and copying the neighboring\nelements solution % boundary data. Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( Mesh2D ), intent(in) :: mesh type( MPILayer ), intent(inout) :: decomp logical, intent(in) :: gpuAccel procedure, public :: UpdateDevice => UpdateDevice_Vector2D public subroutine UpdateDevice_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Vector2D public subroutine UpdateHost_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D , WriteHDF5_Vector2D public subroutine WriteHDF5_MPI_Vector2D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector2D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code TYPE , EXTENDS ( Vector2D ), PUBLIC :: MappedVector2D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedVector2D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedVector2D GENERIC , PUBLIC :: Divergence => Divergence_MappedVector2D PROCEDURE , PRIVATE :: Divergence_MappedVector2D PROCEDURE , PUBLIC :: ContravariantProjection => ContravariantProjection_MappedVector2D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedVector2D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedVector2D PROCEDURE , PUBLIC :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector2D END TYPE MappedVector2D","tags":"","loc":"type/mappedvector2d.html"},{"title":"MappedVector3D – SELF ","text":"type, public, extends( Vector3D ) :: MappedVector3D Contents Variables boundary boundaryNormal eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures ApplyFlip BassiRebaySides BoundaryInterp ContravariantProjection Divergence Divergence_MappedVector3D Free Gradient GridInterp Init JacobianWeight MPIExchangeAsync SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedVector3D Components Type Visibility Attributes Name Initial type( hfReal_r6 ), public :: boundary type( hfReal_r5 ), public :: boundaryNormal type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r6 ), public :: extBoundary type( hfReal_r6 ), public :: interior type( Lagrange ), public, POINTER :: interp type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedVector3D public subroutine ApplyFlip_MappedVector3D (vector, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( MPILayer ), intent(inout) :: mpiHandler type( Mesh3D ), intent(in) :: mesh logical, intent(in) :: gpuAccel procedure, public :: BassiRebaySides => BassiRebaySides_MappedVector3D public subroutine BassiRebaySides_MappedVector3D (vector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector logical, intent(in) :: gpuAccel procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D public subroutine BoundaryInterp_Vector3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, public :: ContravariantProjection => ContravariantProjection_MappedVector3D public subroutine ContravariantProjection_MappedVector3D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( SEMHex ), intent(in) :: geometry logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_Vector3D , Divergence_MappedVector3D public subroutine Divergence_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Divergence_MappedVector3D (compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: compVector type( SEMHex ), intent(in) :: geometry type( MappedScalar3D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Divergence_MappedVector3D public subroutine Divergence_MappedVector3D (compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: compVector type( SEMHex ), intent(in) :: geometry type( MappedScalar3D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, public :: Free => Free_Vector3D public subroutine Free_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Vector3D public subroutine Gradient_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Vector3D public subroutine GridInterp_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Vector3D public subroutine Init_Vector3D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: JacobianWeight => JacobianWeight_MappedVector3D public subroutine JacobianWeight_MappedVector3D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( SEMHex ), intent(in) :: geometry logical, intent(in) :: gpuAccel procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D public subroutine MPIExchangeAsync_MappedVector3D (vector, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( MPILayer ), intent(inout) :: mpiHandler type( Mesh3D ), intent(in) :: mesh logical, intent(in) :: resetCount procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (SELFStorage, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector3D public subroutine SetEquation_DataObj (SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector3D (SELFStorage, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector3D public subroutine SetInteriorFromEquation_MappedVector3D (vector, geometry, time) Sets the scalar % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (SELFStorage, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (SELFStorage, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedVector3D public subroutine SideExchange_MappedVector3D (vector, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( Mesh3D ), intent(in) :: mesh type( MPILayer ), intent(inout) :: decomp logical, intent(in) :: gpuAccel procedure, public :: UpdateDevice => UpdateDevice_Vector3D public subroutine UpdateDevice_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Vector3D public subroutine UpdateHost_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D , WriteHDF5_Vector3D public subroutine WriteHDF5_MPI_Vector3D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector3D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code TYPE , EXTENDS ( Vector3D ), PUBLIC :: MappedVector3D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedVector3D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedVector3D GENERIC , PUBLIC :: Divergence => Divergence_MappedVector3D PROCEDURE , PRIVATE :: Divergence_MappedVector3D PROCEDURE , PUBLIC :: ContravariantProjection => ContravariantProjection_MappedVector3D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedVector3D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedVector3D PROCEDURE , PUBLIC :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector3D END TYPE MappedVector3D","tags":"","loc":"type/mappedvector3d.html"},{"title":"Metadata – SELF ","text":"type, public :: Metadata Contents Variables description name units Type-Bound Procedures SetDescription SetName SetUnits WriteHDF5 Source Code Metadata Components Type Visibility Attributes Name Initial character, public :: description character, public :: name character, public :: units Type-Bound Procedures procedure, public :: SetDescription => SetDescription_Metadata public subroutine SetDescription_Metadata (mtd, description) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: description procedure, public :: SetName => SetName_Metadata public subroutine SetName_Metadata (mtd, name) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: name procedure, public :: SetUnits => SetUnits_Metadata public subroutine SetUnits_Metadata (mtd, units) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: units procedure, public :: WriteHDF5 => WriteHDF5_Metadata public subroutine WriteHDF5_Metadata (mtd, group, varid, fileId) Writes the metadata to a HDF5 file using the \nfields :\n * /metadata/{group}/name/{varid} * /metadata/{group}/description/{varid} * /metadata/{group}/units/{varid} Read more… Arguments Type Intent Optional Attributes Name class( Metadata ), intent(in) :: mtd character, intent(in) :: group integer, intent(in) :: varid integer(kind=HID_T), intent(in) :: fileId Source Code TYPE Metadata CHARACTER ( SELF_MTD_NameLength ) :: name CHARACTER ( SELF_MTD_DescriptionLength ) :: description CHARACTER ( SELF_MTD_UnitsLength ) :: units CONTAINS PROCEDURE , PUBLIC :: SetName => SetName_Metadata PROCEDURE , PUBLIC :: SetDescription => SetDescription_Metadata PROCEDURE , PUBLIC :: SetUnits => SetUnits_Metadata PROCEDURE , PUBLIC :: WriteHDF5 => WriteHDF5_Metadata END TYPE Metadata","tags":"","loc":"type/metadata.html"},{"title":"Model1D – SELF ","text":"type, public, extends( Model ) :: Model1D Contents Variables dSdt decomp dt entropy flux fluxDivergence geometry gpuAccel ioIterate mesh prevSol solution solutionGradient source t timeIntegrator velocity workSol Type-Bound Procedures AdamsBashforth2_timeIntegrator AdamsBashforth3_timeIntegrator AdamsBashforth4_timeIntegrator CalculateEntropy CalculateFluxDivergence CalculateTendency DisableGPUAccel EnableGPUAccel Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreFlux PreTendency PrintType ReadModel ReportEntropy ResizePrevSol RiemannSolver SetBoundaryCondition SetInitialConditions SetSimulationTime SetSolution SetSolutionFromChar_Model1D SetSolutionFromEqn_Model1D SetTimeIntegrator SourceMethod UpdateBoundary UpdateDevice UpdateGAB2 UpdateGAB3 UpdateGAB4 UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateHost UpdateSolution WriteModel WriteTecplot Source Code Model1D Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, POINTER :: geometry logical, public :: gpuAccel integer, public :: ioIterate = 0 type( Mesh1D ), public, POINTER :: mesh type( MappedScalar1D ), public :: prevSol type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: velocity type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator public subroutine AdamsBashforth2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth3_timeIntegrator public subroutine AdamsBashforth3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth4_timeIntegrator public subroutine AdamsBashforth4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: CalculateEntropy => CalculateEntropy_Model public subroutine CalculateEntropy_Model (this) Base method for calculating entropy of a model\nWhen this method is not overridden, the entropy\nis simply set to 0.0. When you develop a model\nbuilt on top of this abstract class or one of its\nchildren, it is recommended that you define a\nconvex mathematical entropy function that is used\nas a measure of the model stability. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_Model1D public subroutine CalculateFluxDivergence_Model1D (this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_Model1D public subroutine CalculateTendency_Model1D (this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this procedure, public :: DisableGPUAccel => DisableGPUAccel_Model public subroutine DisableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: EnableGPUAccel => EnableGPUAccel_Model public subroutine EnableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => Flux_Model public subroutine Flux_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: tn real(kind=prec), intent(in), optional :: dt real(kind=prec), intent(in), optional :: ioInterval procedure, public :: Free => Free_Model1D public subroutine Free_Model1D (this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_Model1D public subroutine Init_Model1D (this, nvar, mesh, geometry, decomp) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), TARGET :: mesh type( Geometry1D ), intent(in), TARGET :: geometry type( MPILayer ), intent(in), TARGET :: decomp procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreFlux => PreFlux_Model public subroutine PreFlux_Model (this) PreFlux is a template routine that is used to house any additional calculations\nthat you want to execute just before the calculation of flux terms.\nThis default PreFlux simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_Model1D public subroutine Read_Model1D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ResizePrevSol => ResizePrevSol_Model1D public subroutine ResizePrevSol_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: RiemannSolver => RiemannSolver_Model public subroutine RiemannSolver_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetBoundaryCondition => SetBoundaryCondition_Model public subroutine SetBoundaryCondition_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetInitialConditions => SetInitialConditions_Model public subroutine SetInitialConditions_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_Model1D , SetSolutionFromEqn_Model1D public subroutine SetSolutionFromChar_Model1D (this, eqnChar) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_Model1D (this, eqn) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) procedure, private :: SetSolutionFromChar_Model1D public subroutine SetSolutionFromChar_Model1D (this, eqnChar) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) procedure, private :: SetSolutionFromEqn_Model1D public subroutine SetSolutionFromEqn_Model1D (this, eqn) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt , SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withInt (this, integrator) Sets the time integrator method, using an integer flag Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: integrator public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => Source_Model public subroutine Source_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: UpdateBoundary => UpdateBoundary_Model public subroutine UpdateBoundary_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_Model1D public subroutine UpdateDevice_Model1D (this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this procedure, public :: UpdateGAB2 => UpdateGAB2_Model1D public subroutine UpdateGAB2_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGAB3 => UpdateGAB3_Model1D public subroutine UpdateGAB3_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGAB4 => UpdateGAB4_Model1D public subroutine UpdateGAB4_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK2 => UpdateGRK2_Model1D public subroutine UpdateGRK2_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_Model1D public subroutine UpdateGRK3_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_Model1D public subroutine UpdateGRK4_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateHost => UpdateHost_Model1D public subroutine UpdateHost_Model1D (this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this procedure, public :: UpdateSolution => UpdateSolution_Model1D public subroutine UpdateSolution_Model1D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_Model1D public subroutine Write_Model1D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_Model1D public subroutine WriteTecplot_Model1D (this, filename) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character, intent(in), optional :: filename Source Code TYPE , EXTENDS ( Model ) :: Model1D TYPE ( MappedScalar1D ) :: solution TYPE ( MappedScalar1D ) :: solutionGradient TYPE ( MappedScalar1D ) :: velocity TYPE ( MappedScalar1D ) :: flux TYPE ( MappedScalar1D ) :: source TYPE ( MappedScalar1D ) :: fluxDivergence TYPE ( MappedScalar1D ) :: dSdt TYPE ( MappedScalar1D ) :: workSol TYPE ( MappedScalar1D ) :: prevSol TYPE ( Mesh1D ), POINTER :: mesh TYPE ( Geometry1D ), POINTER :: geometry CONTAINS PROCEDURE :: Init => Init_Model1D PROCEDURE :: Free => Free_Model1D PROCEDURE :: UpdateHost => UpdateHost_Model1D PROCEDURE :: UpdateDevice => UpdateDevice_Model1D PROCEDURE :: UpdateSolution => UpdateSolution_Model1D PROCEDURE :: ResizePrevSol => ResizePrevSol_Model1D PROCEDURE :: UpdateGAB2 => UpdateGAB2_Model1D PROCEDURE :: UpdateGAB3 => UpdateGAB3_Model1D PROCEDURE :: UpdateGAB4 => UpdateGAB4_Model1D PROCEDURE :: UpdateGRK2 => UpdateGRK2_Model1D PROCEDURE :: UpdateGRK3 => UpdateGRK3_Model1D PROCEDURE :: UpdateGRK4 => UpdateGRK4_Model1D PROCEDURE :: CalculateTendency => CalculateTendency_Model1D PROCEDURE :: CalculateFluxDivergence => CalculateFluxDivergence_Model1D GENERIC :: SetSolution => SetSolutionFromChar_Model1D , & SetSolutionFromEqn_Model1D PROCEDURE , PRIVATE :: SetSolutionFromChar_Model1D PROCEDURE , PRIVATE :: SetSolutionFromEqn_Model1D PROCEDURE :: ReadModel => Read_Model1D PROCEDURE :: WriteModel => Write_Model1D PROCEDURE :: WriteTecplot => WriteTecplot_Model1D END TYPE Model1D","tags":"","loc":"type/model1d.html"},{"title":"advection_diffusion_2d – SELF ","text":"type, public, extends( Model2D ) :: advection_diffusion_2d Contents Variables dSdt decomp dt entropy flux fluxDivergence geometry gpuAccel ioIterate mesh nu prevSol solution solutionGradient source t timeIntegrator u v workSol Type-Bound Procedures AdamsBashforth2_timeIntegrator AdamsBashforth3_timeIntegrator AdamsBashforth4_timeIntegrator CalculateEntropy CalculateFluxDivergence CalculateTendency DisableGPUAccel EnableGPUAccel Euler_timeIntegrator ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreFlux PrintType ReadModel ReportEntropy ReprojectFlux ResizePrevSol SetInitialConditions SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateBoundary UpdateDevice UpdateGAB2 UpdateGAB3 UpdateGAB4 UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateHost UpdateSolution WriteModel WriteTecplot fluxmethod pretendency riemannsolver setboundarycondition Source Code advection_diffusion_2d Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, POINTER :: geometry logical, public :: gpuAccel integer, public :: ioIterate = 0 type( Mesh2D ), public, POINTER :: mesh real(kind=prec), public :: nu type( MappedScalar2D ), public :: prevSol type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator public subroutine AdamsBashforth2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth3_timeIntegrator public subroutine AdamsBashforth3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth4_timeIntegrator public subroutine AdamsBashforth4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: CalculateEntropy => CalculateEntropy_Model public subroutine CalculateEntropy_Model (this) Base method for calculating entropy of a model\nWhen this method is not overridden, the entropy\nis simply set to 0.0. When you develop a model\nbuilt on top of this abstract class or one of its\nchildren, it is recommended that you define a\nconvex mathematical entropy function that is used\nas a measure of the model stability. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_Model2D public subroutine CalculateFluxDivergence_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_Model2D public subroutine CalculateTendency_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this procedure, public :: DisableGPUAccel => DisableGPUAccel_Model public subroutine DisableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: EnableGPUAccel => EnableGPUAccel_Model public subroutine EnableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: tn real(kind=prec), intent(in), optional :: dt real(kind=prec), intent(in), optional :: ioInterval procedure, public :: Free => Free_Model2D public subroutine Free_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_Model2D public subroutine Init_Model2D (this, nvar, mesh, geometry, decomp) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), TARGET :: mesh type( SEMQuad ), intent(in), TARGET :: geometry type( MPILayer ), intent(in), TARGET :: decomp procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreFlux => PreFlux_Model public subroutine PreFlux_Model (this) PreFlux is a template routine that is used to house any additional calculations\nthat you want to execute just before the calculation of flux terms.\nThis default PreFlux simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_Model2D public subroutine Read_Model2D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReprojectFlux => ReprojectFlux_Model2D public subroutine ReprojectFlux_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this procedure, public :: ResizePrevSol => ResizePrevSol_Model2D public subroutine ResizePrevSol_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: SetInitialConditions => SetInitialConditions_Model public subroutine SetInitialConditions_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_Model2D , SetSolutionFromEqn_Model2D public subroutine SetSolutionFromChar_Model2D (this, eqnChar) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_Model2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt , SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withInt (this, integrator) Sets the time integrator method, using an integer flag Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: integrator public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => Source_Model public subroutine Source_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: UpdateBoundary => UpdateBoundary_Model public subroutine UpdateBoundary_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_Model2D public subroutine UpdateDevice_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this procedure, public :: UpdateGAB2 => UpdateGAB2_Model2D public subroutine UpdateGAB2_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGAB3 => UpdateGAB3_Model2D public subroutine UpdateGAB3_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGAB4 => UpdateGAB4_Model2D public subroutine UpdateGAB4_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK2 => UpdateGRK2_Model2D public subroutine UpdateGRK2_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_Model2D public subroutine UpdateGRK3_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_Model2D public subroutine UpdateGRK4_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateHost => UpdateHost_Model2D public subroutine UpdateHost_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this procedure, public :: UpdateSolution => UpdateSolution_Model2D public subroutine UpdateSolution_Model2D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_Model2D public subroutine Write_Model2D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_Model2D public subroutine WriteTecplot_Model2D (this, filename) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: fluxmethod => fluxmethod_advection_diffusion_2d public subroutine fluxmethod_advection_diffusion_2d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this procedure, public :: pretendency => pretendency_advection_diffusion_2d public subroutine pretendency_advection_diffusion_2d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this procedure, public :: riemannsolver => riemannsolver_advection_diffusion_2d public subroutine riemannsolver_advection_diffusion_2d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this procedure, public :: setboundarycondition => setboundarycondition_advection_diffusion_2d public subroutine setboundarycondition_advection_diffusion_2d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this Source Code type , extends ( model2d ) :: advection_diffusion_2d real ( prec ) :: nu ! diffusion coefficient real ( prec ) :: u ! constant x-component of velocity real ( prec ) :: v ! constant y-component of velocity contains procedure :: pretendency => pretendency_advection_diffusion_2d procedure :: setboundarycondition => setboundarycondition_advection_diffusion_2d procedure :: riemannsolver => riemannsolver_advection_diffusion_2d procedure :: fluxmethod => fluxmethod_advection_diffusion_2d end type advection_diffusion_2d","tags":"","loc":"type/advection_diffusion_2d.html"},{"title":"advection_diffusion_1d – SELF ","text":"type, public, extends( Model1D ) :: advection_diffusion_1d Contents Variables dSdt decomp dt entropy flux fluxDivergence geometry gpuAccel ioIterate mesh nu prevSol solution solutionGradient source t timeIntegrator u velocity workSol Type-Bound Procedures AdamsBashforth2_timeIntegrator AdamsBashforth3_timeIntegrator AdamsBashforth4_timeIntegrator CalculateEntropy CalculateFluxDivergence CalculateTendency DisableGPUAccel EnableGPUAccel Euler_timeIntegrator ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreFlux PrintType ReadModel ReportEntropy ResizePrevSol SetInitialConditions SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateBoundary UpdateDevice UpdateGAB2 UpdateGAB3 UpdateGAB4 UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateHost UpdateSolution WriteModel WriteTecplot fluxmethod pretendency riemannsolver setboundarycondition Source Code advection_diffusion_1d Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, POINTER :: geometry logical, public :: gpuAccel integer, public :: ioIterate = 0 type( Mesh1D ), public, POINTER :: mesh real(kind=prec), public :: nu type( MappedScalar1D ), public :: prevSol type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u type( MappedScalar1D ), public :: velocity type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator public subroutine AdamsBashforth2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth3_timeIntegrator public subroutine AdamsBashforth3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth4_timeIntegrator public subroutine AdamsBashforth4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: CalculateEntropy => CalculateEntropy_Model public subroutine CalculateEntropy_Model (this) Base method for calculating entropy of a model\nWhen this method is not overridden, the entropy\nis simply set to 0.0. When you develop a model\nbuilt on top of this abstract class or one of its\nchildren, it is recommended that you define a\nconvex mathematical entropy function that is used\nas a measure of the model stability. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_Model1D public subroutine CalculateFluxDivergence_Model1D (this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_Model1D public subroutine CalculateTendency_Model1D (this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this procedure, public :: DisableGPUAccel => DisableGPUAccel_Model public subroutine DisableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: EnableGPUAccel => EnableGPUAccel_Model public subroutine EnableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: tn real(kind=prec), intent(in), optional :: dt real(kind=prec), intent(in), optional :: ioInterval procedure, public :: Free => Free_Model1D public subroutine Free_Model1D (this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_Model1D public subroutine Init_Model1D (this, nvar, mesh, geometry, decomp) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), TARGET :: mesh type( Geometry1D ), intent(in), TARGET :: geometry type( MPILayer ), intent(in), TARGET :: decomp procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreFlux => PreFlux_Model public subroutine PreFlux_Model (this) PreFlux is a template routine that is used to house any additional calculations\nthat you want to execute just before the calculation of flux terms.\nThis default PreFlux simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_Model1D public subroutine Read_Model1D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ResizePrevSol => ResizePrevSol_Model1D public subroutine ResizePrevSol_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: SetInitialConditions => SetInitialConditions_Model public subroutine SetInitialConditions_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_Model1D , SetSolutionFromEqn_Model1D public subroutine SetSolutionFromChar_Model1D (this, eqnChar) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_Model1D (this, eqn) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt , SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withInt (this, integrator) Sets the time integrator method, using an integer flag Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: integrator public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => Source_Model public subroutine Source_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: UpdateBoundary => UpdateBoundary_Model public subroutine UpdateBoundary_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_Model1D public subroutine UpdateDevice_Model1D (this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this procedure, public :: UpdateGAB2 => UpdateGAB2_Model1D public subroutine UpdateGAB2_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGAB3 => UpdateGAB3_Model1D public subroutine UpdateGAB3_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGAB4 => UpdateGAB4_Model1D public subroutine UpdateGAB4_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK2 => UpdateGRK2_Model1D public subroutine UpdateGRK2_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_Model1D public subroutine UpdateGRK3_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_Model1D public subroutine UpdateGRK4_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateHost => UpdateHost_Model1D public subroutine UpdateHost_Model1D (this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this procedure, public :: UpdateSolution => UpdateSolution_Model1D public subroutine UpdateSolution_Model1D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_Model1D public subroutine Write_Model1D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_Model1D public subroutine WriteTecplot_Model1D (this, filename) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: fluxmethod => fluxmethod_advection_diffusion_1d public subroutine fluxmethod_advection_diffusion_1d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this procedure, public :: pretendency => pretendency_advection_diffusion_1d public subroutine pretendency_advection_diffusion_1d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this procedure, public :: riemannsolver => riemannsolver_advection_diffusion_1d public subroutine riemannsolver_advection_diffusion_1d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this procedure, public :: setboundarycondition => setboundarycondition_advection_diffusion_1d public subroutine setboundarycondition_advection_diffusion_1d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this Source Code type , extends ( model1d ) :: advection_diffusion_1d real ( prec ) :: nu ! diffusion coefficient real ( prec ) :: u ! constant velocity contains procedure :: pretendency => pretendency_advection_diffusion_1d procedure :: setboundarycondition => setboundarycondition_advection_diffusion_1d procedure :: riemannsolver => riemannsolver_advection_diffusion_1d procedure :: fluxmethod => fluxmethod_advection_diffusion_1d end type advection_diffusion_1d","tags":"","loc":"type/advection_diffusion_1d.html"},{"title":"advection_diffusion_3d – SELF ","text":"type, public, extends( Model3D ) :: advection_diffusion_3d Contents Variables dSdt decomp dt entropy flux fluxDivergence geometry gpuAccel ioIterate mesh nu prevSol solution solutionGradient source t timeIntegrator u v w workSol Type-Bound Procedures AdamsBashforth2_timeIntegrator AdamsBashforth3_timeIntegrator AdamsBashforth4_timeIntegrator CalculateEntropy CalculateFluxDivergence CalculateTendency DisableGPUAccel EnableGPUAccel Euler_timeIntegrator ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreFlux PrintType ReadModel ReportEntropy ReprojectFlux ResizePrevSol SetInitialConditions SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateBoundary UpdateDevice UpdateGAB2 UpdateGAB3 UpdateGAB4 UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateHost UpdateSolution WriteModel WriteTecplot fluxmethod pretendency riemannsolver setboundarycondition Source Code advection_diffusion_3d Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, POINTER :: geometry logical, public :: gpuAccel integer, public :: ioIterate = 0 type( Mesh3D ), public, POINTER :: mesh real(kind=prec), public :: nu type( MappedScalar3D ), public :: prevSol type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v real(kind=prec), public :: w type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator public subroutine AdamsBashforth2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth3_timeIntegrator public subroutine AdamsBashforth3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth4_timeIntegrator public subroutine AdamsBashforth4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: CalculateEntropy => CalculateEntropy_Model public subroutine CalculateEntropy_Model (this) Base method for calculating entropy of a model\nWhen this method is not overridden, the entropy\nis simply set to 0.0. When you develop a model\nbuilt on top of this abstract class or one of its\nchildren, it is recommended that you define a\nconvex mathematical entropy function that is used\nas a measure of the model stability. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_Model3D public subroutine CalculateFluxDivergence_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_Model3D public subroutine CalculateTendency_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this procedure, public :: DisableGPUAccel => DisableGPUAccel_Model public subroutine DisableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: EnableGPUAccel => EnableGPUAccel_Model public subroutine EnableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: tn real(kind=prec), intent(in), optional :: dt real(kind=prec), intent(in), optional :: ioInterval procedure, public :: Free => Free_Model3D public subroutine Free_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_Model3D public subroutine Init_Model3D (this, nvar, mesh, geometry, decomp) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(out) :: this integer, intent(in) :: nvar type( Mesh3D ), intent(in), TARGET :: mesh type( SEMHex ), intent(in), TARGET :: geometry type( MPILayer ), intent(in), TARGET :: decomp procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreFlux => PreFlux_Model public subroutine PreFlux_Model (this) PreFlux is a template routine that is used to house any additional calculations\nthat you want to execute just before the calculation of flux terms.\nThis default PreFlux simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_Model3D public subroutine Read_Model3D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReprojectFlux => ReprojectFlux_Model3D public subroutine ReprojectFlux_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this procedure, public :: ResizePrevSol => ResizePrevSol_Model3D public subroutine ResizePrevSol_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: SetInitialConditions => SetInitialConditions_Model public subroutine SetInitialConditions_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_Model3D , SetSolutionFromEqn_Model3D public subroutine SetSolutionFromChar_Model3D (this, eqnChar) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_Model3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt , SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withInt (this, integrator) Sets the time integrator method, using an integer flag Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: integrator public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => Source_Model public subroutine Source_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: UpdateBoundary => UpdateBoundary_Model public subroutine UpdateBoundary_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_Model3D public subroutine UpdateDevice_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this procedure, public :: UpdateGAB2 => UpdateGAB2_Model3D public subroutine UpdateGAB2_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGAB3 => UpdateGAB3_Model3D public subroutine UpdateGAB3_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGAB4 => UpdateGAB4_Model3D public subroutine UpdateGAB4_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK2 => UpdateGRK2_Model3D public subroutine UpdateGRK2_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_Model3D public subroutine UpdateGRK3_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_Model3D public subroutine UpdateGRK4_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateHost => UpdateHost_Model3D public subroutine UpdateHost_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this procedure, public :: UpdateSolution => UpdateSolution_Model3D public subroutine UpdateSolution_Model3D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_Model3D public subroutine Write_Model3D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_Model3D public subroutine WriteTecplot_Model3D (this, filename) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: fluxmethod => fluxmethod_advection_diffusion_3d public subroutine fluxmethod_advection_diffusion_3d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this procedure, public :: pretendency => pretendency_advection_diffusion_3d public subroutine pretendency_advection_diffusion_3d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this procedure, public :: riemannsolver => riemannsolver_advection_diffusion_3d public subroutine riemannsolver_advection_diffusion_3d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this procedure, public :: setboundarycondition => setboundarycondition_advection_diffusion_3d public subroutine setboundarycondition_advection_diffusion_3d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this Source Code type , extends ( model3d ) :: advection_diffusion_3d real ( prec ) :: nu ! diffusion coefficient real ( prec ) :: u ! constant x-component of velocity real ( prec ) :: v ! constant y-component of velocity real ( prec ) :: w ! constant z-component of velocity contains procedure :: pretendency => pretendency_advection_diffusion_3d procedure :: setboundarycondition => setboundarycondition_advection_diffusion_3d procedure :: riemannsolver => riemannsolver_advection_diffusion_3d procedure :: fluxmethod => fluxmethod_advection_diffusion_3d end type advection_diffusion_3d","tags":"","loc":"type/advection_diffusion_3d.html"},{"title":"Model2D – SELF ","text":"type, public, extends( Model ) :: Model2D Contents Variables dSdt decomp dt entropy flux fluxDivergence geometry gpuAccel ioIterate mesh prevSol solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures AdamsBashforth2_timeIntegrator AdamsBashforth3_timeIntegrator AdamsBashforth4_timeIntegrator CalculateEntropy CalculateFluxDivergence CalculateTendency DisableGPUAccel EnableGPUAccel Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreFlux PreTendency PrintType ReadModel ReportEntropy ReprojectFlux ResizePrevSol RiemannSolver SetBoundaryCondition SetInitialConditions SetSimulationTime SetSolution SetSolutionFromChar_Model2D SetSolutionFromEqn_Model2D SetTimeIntegrator SourceMethod UpdateBoundary UpdateDevice UpdateGAB2 UpdateGAB3 UpdateGAB4 UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateHost UpdateSolution WriteModel WriteTecplot Source Code Model2D Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, POINTER :: geometry logical, public :: gpuAccel integer, public :: ioIterate = 0 type( Mesh2D ), public, POINTER :: mesh type( MappedScalar2D ), public :: prevSol type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator public subroutine AdamsBashforth2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth3_timeIntegrator public subroutine AdamsBashforth3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth4_timeIntegrator public subroutine AdamsBashforth4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: CalculateEntropy => CalculateEntropy_Model public subroutine CalculateEntropy_Model (this) Base method for calculating entropy of a model\nWhen this method is not overridden, the entropy\nis simply set to 0.0. When you develop a model\nbuilt on top of this abstract class or one of its\nchildren, it is recommended that you define a\nconvex mathematical entropy function that is used\nas a measure of the model stability. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_Model2D public subroutine CalculateFluxDivergence_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_Model2D public subroutine CalculateTendency_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this procedure, public :: DisableGPUAccel => DisableGPUAccel_Model public subroutine DisableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: EnableGPUAccel => EnableGPUAccel_Model public subroutine EnableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => Flux_Model public subroutine Flux_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: tn real(kind=prec), intent(in), optional :: dt real(kind=prec), intent(in), optional :: ioInterval procedure, public :: Free => Free_Model2D public subroutine Free_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_Model2D public subroutine Init_Model2D (this, nvar, mesh, geometry, decomp) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), TARGET :: mesh type( SEMQuad ), intent(in), TARGET :: geometry type( MPILayer ), intent(in), TARGET :: decomp procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreFlux => PreFlux_Model public subroutine PreFlux_Model (this) PreFlux is a template routine that is used to house any additional calculations\nthat you want to execute just before the calculation of flux terms.\nThis default PreFlux simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_Model2D public subroutine Read_Model2D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReprojectFlux => ReprojectFlux_Model2D public subroutine ReprojectFlux_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this procedure, public :: ResizePrevSol => ResizePrevSol_Model2D public subroutine ResizePrevSol_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: RiemannSolver => RiemannSolver_Model public subroutine RiemannSolver_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetBoundaryCondition => SetBoundaryCondition_Model public subroutine SetBoundaryCondition_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetInitialConditions => SetInitialConditions_Model public subroutine SetInitialConditions_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_Model2D , SetSolutionFromEqn_Model2D public subroutine SetSolutionFromChar_Model2D (this, eqnChar) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_Model2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) procedure, private :: SetSolutionFromChar_Model2D public subroutine SetSolutionFromChar_Model2D (this, eqnChar) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) procedure, private :: SetSolutionFromEqn_Model2D public subroutine SetSolutionFromEqn_Model2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt , SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withInt (this, integrator) Sets the time integrator method, using an integer flag Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: integrator public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => Source_Model public subroutine Source_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: UpdateBoundary => UpdateBoundary_Model public subroutine UpdateBoundary_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_Model2D public subroutine UpdateDevice_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this procedure, public :: UpdateGAB2 => UpdateGAB2_Model2D public subroutine UpdateGAB2_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGAB3 => UpdateGAB3_Model2D public subroutine UpdateGAB3_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGAB4 => UpdateGAB4_Model2D public subroutine UpdateGAB4_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK2 => UpdateGRK2_Model2D public subroutine UpdateGRK2_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_Model2D public subroutine UpdateGRK3_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_Model2D public subroutine UpdateGRK4_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateHost => UpdateHost_Model2D public subroutine UpdateHost_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this procedure, public :: UpdateSolution => UpdateSolution_Model2D public subroutine UpdateSolution_Model2D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_Model2D public subroutine Write_Model2D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_Model2D public subroutine WriteTecplot_Model2D (this, filename) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in), optional :: filename Source Code TYPE , EXTENDS ( Model ) :: Model2D TYPE ( MappedScalar2D ) :: solution TYPE ( MappedVector2D ) :: solutionGradient TYPE ( MappedVector2D ) :: flux TYPE ( MappedScalar2D ) :: source TYPE ( MappedScalar2D ) :: fluxDivergence TYPE ( MappedScalar2D ) :: dSdt TYPE ( MappedScalar2D ) :: workSol TYPE ( MappedScalar2D ) :: prevSol TYPE ( Mesh2D ), POINTER :: mesh TYPE ( SEMQuad ), POINTER :: geometry CONTAINS PROCEDURE :: Init => Init_Model2D PROCEDURE :: Free => Free_Model2D PROCEDURE :: UpdateHost => UpdateHost_Model2D PROCEDURE :: UpdateDevice => UpdateDevice_Model2D PROCEDURE :: UpdateSolution => UpdateSolution_Model2D PROCEDURE :: ResizePrevSol => ResizePrevSol_Model2D PROCEDURE :: UpdateGAB2 => UpdateGAB2_Model2D PROCEDURE :: UpdateGAB3 => UpdateGAB3_Model2D PROCEDURE :: UpdateGAB4 => UpdateGAB4_Model2D PROCEDURE :: UpdateGRK2 => UpdateGRK2_Model2D PROCEDURE :: UpdateGRK3 => UpdateGRK3_Model2D PROCEDURE :: UpdateGRK4 => UpdateGRK4_Model2D PROCEDURE :: CalculateTendency => CalculateTendency_Model2D PROCEDURE :: CalculateFluxDivergence => CalculateFluxDivergence_Model2D GENERIC :: SetSolution => SetSolutionFromChar_Model2D , & SetSolutionFromEqn_Model2D PROCEDURE , PRIVATE :: SetSolutionFromChar_Model2D PROCEDURE , PRIVATE :: SetSolutionFromEqn_Model2D PROCEDURE :: ReprojectFlux => ReprojectFlux_Model2D PROCEDURE :: ReadModel => Read_Model2D PROCEDURE :: WriteModel => Write_Model2D PROCEDURE :: WriteTecplot => WriteTecplot_Model2D END TYPE Model2D","tags":"","loc":"type/model2d.html"},{"title":"MPILayer – SELF ","text":"type, public :: MPILayer Contents Variables elemToRank maxMsg mpiComm mpiEnabled mpiPrec msgCount nElem nRanks offSetElem rankId requests stats Type-Bound Procedures Finalize FinalizeMPIExchangeAsync Free GenerateDecomposition GlobalReduce GlobalReduce_RealScalar Init SetElemToRank SetMaxMsg Source Code MPILayer Components Type Visibility Attributes Name Initial type( hfInt32_r1 ), public :: elemToRank integer, public :: maxMsg integer, public :: mpiComm logical, public :: mpiEnabled integer, public :: mpiPrec integer, public :: msgCount integer, public :: nElem integer, public :: nRanks type( hfInt32_r1 ), public :: offSetElem integer, public :: rankId integer, public, ALLOCATABLE :: requests (:) integer, public, ALLOCATABLE :: stats (:,:) Type-Bound Procedures procedure, public :: Finalize => Finalize_MPILayer public subroutine Finalize_MPILayer (this) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this procedure, public :: FinalizeMPIExchangeAsync public subroutine FinalizeMPIExchangeAsync (mpiHandler) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: mpiHandler procedure, public :: Free => Free_MPILayer public subroutine Free_MPILayer (this) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this procedure, public :: GenerateDecomposition => GenerateDecomposition_MPILayer public subroutine GenerateDecomposition_MPILayer (this, nGlobalElem, maxMsg) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this integer, intent(in) :: nGlobalElem integer, intent(in) :: maxMsg generic, public :: GlobalReduce => GlobalReduce_RealScalar public subroutine GlobalReduce_RealScalar (mpiHandler, sendBuf, recvBuf) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(in) :: mpiHandler real(kind=prec), intent(in) :: sendBuf real(kind=prec), intent(out) :: recvBuf procedure, private :: GlobalReduce_RealScalar public subroutine GlobalReduce_RealScalar (mpiHandler, sendBuf, recvBuf) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(in) :: mpiHandler real(kind=prec), intent(in) :: sendBuf real(kind=prec), intent(out) :: recvBuf procedure, public :: Init => Init_MPILayer public subroutine Init_MPILayer (this, enableMPI) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(out) :: this logical, intent(in) :: enableMPI procedure, public :: SetElemToRank public subroutine SetElemToRank (this, nElem) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this integer, intent(in) :: nElem procedure, public :: SetMaxMsg public subroutine SetMaxMsg (this, maxMsg) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this integer, intent(in) :: maxMsg Source Code TYPE MPILayer LOGICAL :: mpiEnabled INTEGER :: mpiComm INTEGER :: mpiPrec INTEGER :: rankId INTEGER :: nRanks INTEGER :: nElem INTEGER :: maxMsg INTEGER :: msgCount TYPE ( hfInt32_r1 ) :: elemToRank TYPE ( hfInt32_r1 ) :: offSetElem INTEGER , ALLOCATABLE :: requests (:) INTEGER , ALLOCATABLE :: stats (:,:) CONTAINS PROCEDURE :: Init => Init_MPILayer PROCEDURE :: Free => Free_MPILayer PROCEDURE :: Finalize => Finalize_MPILayer PROCEDURE :: GenerateDecomposition => GenerateDecomposition_MPILayer PROCEDURE :: SetElemToRank PROCEDURE :: SetMaxMsg PROCEDURE , PUBLIC :: FinalizeMPIExchangeAsync GENERIC , PUBLIC :: GlobalReduce => GlobalReduce_RealScalar PROCEDURE , PRIVATE :: GlobalReduce_RealScalar END TYPE MPILayer","tags":"","loc":"type/mpilayer.html"},{"title":"Mesh1D – SELF ","text":"type, public, extends( SEMMesh ) :: Mesh1D Contents Variables BCNames BCType elemInfo globalNodeIDs nBCs nCornerNodes nElem nGeo nGlobalElem nNodes nSides nUniqueNodes nUniqueSides nodeCoords quadrature Type-Bound Procedures Free Init UniformBlockMesh UpdateDevice UpdateHost Write_Mesh Source Code Mesh1D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type( hfInt32_r2 ), public :: BCType type( hfInt32_r2 ), public :: elemInfo type( hfInt32_r1 ), public :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides type( hfReal_r1 ), public :: nodeCoords integer, public :: quadrature Type-Bound Procedures procedure, public :: Free => Free_Mesh1D public subroutine Free_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh procedure, public :: Init => Init_Mesh1D public subroutine Init_Mesh1D (myMesh, nGeo, nElem, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nNodes integer, intent(in) :: nBCs procedure, public :: UniformBlockMesh => UniformBlockMesh_Mesh1D public subroutine UniformBlockMesh_Mesh1D (myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem real(kind=prec), intent(in) :: x (1:2) procedure, public :: UpdateDevice => UpdateDevice_Mesh1D public subroutine UpdateDevice_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh procedure, public :: UpdateHost => UpdateHost_Mesh1D public subroutine UpdateHost_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh procedure, public :: Write_Mesh => Write_Mesh1D public subroutine Write_Mesh1D (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh character, intent(in) :: meshFile Source Code TYPE , EXTENDS ( SEMMesh ) :: Mesh1D TYPE ( hfInt32_r2 ) :: elemInfo TYPE ( hfReal_r1 ) :: nodeCoords TYPE ( hfInt32_r1 ) :: globalNodeIDs TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh1D PROCEDURE , PUBLIC :: Free => Free_Mesh1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh1D PROCEDURE , PUBLIC :: UniformBlockMesh => UniformBlockMesh_Mesh1D PROCEDURE , PUBLIC :: Write_Mesh => Write_Mesh1D END TYPE Mesh1D","tags":"","loc":"type/mesh1d.html"},{"title":"Mesh2D – SELF ","text":"type, public, extends( SEMMesh ) :: Mesh2D Contents Variables BCNames BCType CGNSCornerMap CGNSSideMap elemInfo globalNodeIDs nBCs nCornerNodes nElem nGeo nGlobalElem nNodes nSides nUniqueNodes nUniqueSides nodeCoords quadrature sideInfo Type-Bound Procedures Free Init Read_HOPr RecalculateFlip ResetBoundaryConditionType UpdateDevice UpdateHost Write_Mesh Source Code Mesh2D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type( hfInt32_r2 ), public :: BCType type( hfInt32_r2 ), public :: CGNSCornerMap type( hfInt32_r2 ), public :: CGNSSideMap type( hfInt32_r2 ), public :: elemInfo type( hfInt32_r3 ), public :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides type( hfReal_r4 ), public :: nodeCoords integer, public :: quadrature type( hfInt32_r3 ), public :: sideInfo Type-Bound Procedures procedure, public :: Free => Free_Mesh2D public subroutine Free_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh procedure, public :: Init => Init_Mesh2D public subroutine Init_Mesh2D (myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs procedure, public :: Read_HOPr => Read_HOPr_Mesh2D public subroutine Read_HOPr_Mesh2D (myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh character, intent(in) :: meshFile type( MPILayer ), intent(inout) :: decomp procedure, private :: RecalculateFlip => RecalculateFlip_Mesh2D public subroutine RecalculateFlip_Mesh2D (myMesh, decomp) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh type( MPILayer ), intent(inout), optional :: decomp procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh2D public subroutine ResetBoundaryConditionType_Mesh2D (myMesh, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Read more… Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh integer, intent(in) :: bcid procedure, public :: UpdateDevice => UpdateDevice_Mesh2D public subroutine UpdateDevice_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh procedure, public :: UpdateHost => UpdateHost_Mesh2D public subroutine UpdateHost_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh procedure, public :: Write_Mesh => Write_Mesh2D public subroutine Write_Mesh2D (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh character, intent(in) :: meshFile Source Code TYPE , EXTENDS ( SEMMesh ) :: Mesh2D TYPE ( hfInt32_r3 ) :: sideInfo TYPE ( hfReal_r4 ) :: nodeCoords TYPE ( hfInt32_r2 ) :: elemInfo TYPE ( hfInt32_r3 ) :: globalNodeIDs TYPE ( hfInt32_r2 ) :: CGNSCornerMap TYPE ( hfInt32_r2 ) :: CGNSSideMap TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh2D PROCEDURE , PUBLIC :: Free => Free_Mesh2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh2D PROCEDURE , PUBLIC :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh2D PROCEDURE , PUBLIC :: Read_HOPr => Read_HOPr_Mesh2D PROCEDURE , PUBLIC :: Write_Mesh => Write_Mesh2D PROCEDURE , PRIVATE :: RecalculateFlip => RecalculateFlip_Mesh2D END TYPE Mesh2D","tags":"","loc":"type/mesh2d.html"},{"title":"Mesh3D – SELF ","text":"type, public, extends( SEMMesh ) :: Mesh3D Contents Variables BCNames BCType CGNSCornerMap CGNSSideMap elemInfo globalNodeIDs nBCs nCornerNodes nElem nGeo nGlobalElem nNodes nSides nUniqueNodes nUniqueSides nodeCoords quadrature sideInfo sideMap Type-Bound Procedures Free Init Read_HOPr RecalculateFlip ResetBoundaryConditionType UpdateDevice UpdateHost Write_Mesh Source Code Mesh3D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type( hfInt32_r2 ), public :: BCType type( hfInt32_r2 ), public :: CGNSCornerMap type( hfInt32_r2 ), public :: CGNSSideMap type( hfInt32_r2 ), public :: elemInfo type( hfInt32_r4 ), public :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides type( hfReal_r5 ), public :: nodeCoords integer, public :: quadrature type( hfInt32_r3 ), public :: sideInfo type( hfInt32_r2 ), public :: sideMap Type-Bound Procedures procedure, public :: Free => Free_Mesh3D public subroutine Free_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh procedure, public :: Init => Init_Mesh3D public subroutine Init_Mesh3D (myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs procedure, public :: Read_HOPr => Read_HOPr_Mesh3D public subroutine Read_HOPr_Mesh3D (myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh character, intent(in) :: meshFile type( MPILayer ), intent(inout) :: decomp procedure, private :: RecalculateFlip => RecalculateFlip_Mesh3D public subroutine RecalculateFlip_Mesh3D (myMesh, decomp) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh type( MPILayer ), intent(inout), optional :: decomp procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh3D public subroutine ResetBoundaryConditionType_Mesh3D (myMesh, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Read more… Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh integer, intent(in) :: bcid procedure, public :: UpdateDevice => UpdateDevice_Mesh3D public subroutine UpdateDevice_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh procedure, public :: UpdateHost => UpdateHost_Mesh3D public subroutine UpdateHost_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh procedure, public :: Write_Mesh => Write_Mesh3D public subroutine Write_Mesh3D (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh character, intent(in) :: meshFile Source Code TYPE , EXTENDS ( SEMMesh ) :: Mesh3D TYPE ( hfInt32_r3 ) :: sideInfo TYPE ( hfReal_r5 ) :: nodeCoords TYPE ( hfInt32_r2 ) :: elemInfo TYPE ( hfInt32_r4 ) :: globalNodeIDs TYPE ( hfInt32_r2 ) :: CGNSCornerMap TYPE ( hfInt32_r2 ) :: CGNSSideMap TYPE ( hfInt32_r2 ) :: sideMap TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh3D PROCEDURE , PUBLIC :: Free => Free_Mesh3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh3D PROCEDURE , PUBLIC :: Read_HOPr => Read_HOPr_Mesh3D PROCEDURE , PUBLIC :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh3D PROCEDURE , PUBLIC :: Write_Mesh => Write_Mesh3D PROCEDURE , PRIVATE :: RecalculateFlip => RecalculateFlip_Mesh3D END TYPE Mesh3D","tags":"","loc":"type/mesh3d.html"},{"title":"MeshSpec – SELF ","text":"type, public :: MeshSpec Contents Variables blockMesh blockMesh_nElemX blockMesh_nElemY blockMesh_nElemZ blockMesh_nGeo blockMesh_x0 blockMesh_x1 blockMesh_y0 blockMesh_y1 blockMesh_z0 blockMesh_z1 fileType filename Source Code MeshSpec Components Type Visibility Attributes Name Initial logical, public :: blockMesh integer, public :: blockMesh_nElemX integer, public :: blockMesh_nElemY integer, public :: blockMesh_nElemZ integer, public :: blockMesh_nGeo real(kind=prec), public :: blockMesh_x0 real(kind=prec), public :: blockMesh_x1 real(kind=prec), public :: blockMesh_y0 real(kind=prec), public :: blockMesh_y1 real(kind=prec), public :: blockMesh_z0 real(kind=prec), public :: blockMesh_z1 integer, public :: fileType character, public :: filename Source Code TYPE MeshSpec CHARACTER ( self_FileNameLength ) :: filename INTEGER :: fileType LOGICAL :: blockMesh INTEGER :: blockMesh_nGeo INTEGER :: blockMesh_nElemX INTEGER :: blockMesh_nElemY INTEGER :: blockMesh_nElemZ REAL ( prec ) :: blockMesh_x0 , blockMesh_x1 REAL ( prec ) :: blockMesh_y0 , blockMesh_y1 REAL ( prec ) :: blockMesh_z0 , blockMesh_z1 END TYPE MeshSpec","tags":"","loc":"type/meshspec.html"},{"title":"SEMMesh – SELF ","text":"type, public :: SEMMesh Contents Variables nBCs nCornerNodes nElem nGeo nGlobalElem nNodes nSides nUniqueNodes nUniqueSides quadrature Source Code SEMMesh Components Type Visibility Attributes Name Initial integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides integer, public :: quadrature Source Code TYPE :: SEMMesh INTEGER :: nGeo INTEGER :: nElem INTEGER :: nGlobalElem INTEGER :: nNodes INTEGER :: nSides INTEGER :: nCornerNodes INTEGER :: nUniqueNodes INTEGER :: nUniqueSides INTEGER :: nBCs INTEGER :: quadrature END TYPE SEMMesh","tags":"","loc":"type/semmesh.html"},{"title":"SELF_DataObj – SELF ","text":"type, public :: SELF_DataObj The SELF_DataObj class is a base class for all data objects in SELF.\nA data object in SELF is a multidimensional array of data, represented\non both host and device, that is associated with an interpolant, metadata,\nand (optionally) an equation string.\nType extensions of the SELF_DataObj include scalars, vectors, and tensors\nin 1-D, 2-D, and 3-D using the storage patterns that are expected for\nderivative and interpolation operations defined in SELF_Lagrange.f90\nAdditionally, each extended type has the necessary attributes to store\ninformation on element interiors and element boundaries, both of which\nare commonly used for spectral element solvers. Contents Variables eqn interp meta nElem nVar Type-Bound Procedures SetDescription SetEquation SetEquation_DataObj SetName SetUnits Source Code SELF_DataObj Components Type Visibility Attributes Name Initial type(EquationParser), public, ALLOCATABLE :: eqn (:) type( Lagrange ), public, POINTER :: interp type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (SELFStorage, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, private :: SetEquation_DataObj public subroutine SetEquation_DataObj (SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (SELFStorage, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (SELFStorage, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: units Source Code TYPE , PUBLIC :: SELF_DataObj !! The SELF_DataObj class is a base class for all data objects in SELF. !! A data object in SELF is a multidimensional array of data, represented !! on both host and device, that is associated with an interpolant, metadata, !! and (optionally) an equation string. !! Type extensions of the SELF_DataObj include scalars, vectors, and tensors !! in 1-D, 2-D, and 3-D using the storage patterns that are expected for !! derivative and interpolation operations defined in SELF_Lagrange.f90 !! Additionally, each extended type has the necessary attributes to store !! information on element interiors and element boundaries, both of which !! are commonly used for spectral element solvers. INTEGER :: nVar INTEGER :: nElem TYPE ( Lagrange ), POINTER :: interp TYPE ( Metadata ), ALLOCATABLE :: meta (:) TYPE ( EquationParser ), ALLOCATABLE :: eqn (:) CONTAINS ! PROCEDURE,PUBLIC :: Init => Init_DataObj ! PROCEDURE,PUBLIC :: Free => Free_DataObj ! Procedures for setting metadata for PROCEDURE , PUBLIC :: SetName => SetName_DataObj PROCEDURE , PUBLIC :: SetDescription => SetDescription_DataObj PROCEDURE , PUBLIC :: SetUnits => SetUnits_DataObj GENERIC , PUBLIC :: SetEquation => SetEquation_DataObj PROCEDURE , PRIVATE :: SetEquation_DataObj END TYPE SELF_DataObj","tags":"","loc":"type/self_dataobj.html"},{"title":"Scalar1D – SELF ","text":"type, public, extends( SELF_DataObj ) :: Scalar1D Contents Variables avgBoundary boundary eqn extBoundary interior interp jumpBoundary meta nElem nVar Type-Bound Procedures BoundaryInterp Derivative Derivative_Scalar1D Free GridInterp Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 WriteHDF5_MPI_Scalar1D WriteHDF5_Scalar1D Source Code Scalar1D Components Type Visibility Attributes Name Initial type( hfReal_r3 ), public :: avgBoundary type( hfReal_r3 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r3 ), public :: extBoundary type( hfReal_r3 ), public :: interior type( Lagrange ), public, POINTER :: interp type( hfReal_r3 ), public :: jumpBoundary type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D public subroutine BoundaryInterp_Scalar1D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel generic, public :: Derivative => Derivative_Scalar1D public subroutine Derivative_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Derivative_Scalar1D public subroutine Derivative_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Free => Free_Scalar1D public subroutine Free_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage procedure, public :: GridInterp => GridInterp_Scalar1D public subroutine GridInterp_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Scalar1D public subroutine Init_Scalar1D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (SELFStorage, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (SELFStorage, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (SELFStorage, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Scalar1D public subroutine UpdateDevice_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Scalar1D public subroutine UpdateHost_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage generic, public :: WriteHDF5 => WriteHDF5_Scalar1D , WriteHDF5_MPI_Scalar1D public subroutine WriteHDF5_Scalar1D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group public subroutine WriteHDF5_MPI_Scalar1D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem procedure, private :: WriteHDF5_MPI_Scalar1D public subroutine WriteHDF5_MPI_Scalar1D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem procedure, private :: WriteHDF5_Scalar1D public subroutine WriteHDF5_Scalar1D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code TYPE , EXTENDS ( SELF_DataObj ), PUBLIC :: Scalar1D TYPE ( hfReal_r3 ) :: interior TYPE ( hfReal_r3 ) :: boundary TYPE ( hfReal_r3 ) :: extBoundary TYPE ( hfReal_r3 ) :: avgBoundary TYPE ( hfReal_r3 ) :: jumpBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar1D PROCEDURE , PUBLIC :: Free => Free_Scalar1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar1D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar1D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar1D GENERIC , PUBLIC :: Derivative => Derivative_Scalar1D PROCEDURE , PRIVATE :: Derivative_Scalar1D ! PROCEDURE,PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar1D ! PROCEDURE,PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar1D ! GENERIC,PUBLIC :: ASSIGNMENT(=) => Equals_Scalar1D ! PROCEDURE,PRIVATE,PASS(SELFOut) :: Equals_Scalar1D GENERIC , PUBLIC :: WriteHDF5 => WriteHDF5_Scalar1D , WriteHDF5_MPI_Scalar1D PROCEDURE , PRIVATE :: WriteHDF5_Scalar1D PROCEDURE , PRIVATE :: WriteHDF5_MPI_Scalar1D END TYPE Scalar1D","tags":"","loc":"type/scalar1d.html"},{"title":"Scalar2D – SELF ","text":"type, public, extends( SELF_DataObj ) :: Scalar2D Contents Variables avgBoundary boundary eqn extBoundary interior interp jumpBoundary meta nElem nVar Type-Bound Procedures BoundaryInterp Free Gradient Gradient_Scalar2D GridInterp Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 WriteHDF5_MPI_Scalar2D WriteHDF5_Scalar2D Source Code Scalar2D Components Type Visibility Attributes Name Initial type( hfReal_r4 ), public :: avgBoundary type( hfReal_r4 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r4 ), public :: extBoundary type( hfReal_r4 ), public :: interior type( Lagrange ), public, POINTER :: interp type( hfReal_r4 ), public :: jumpBoundary type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D public subroutine BoundaryInterp_Scalar2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, public :: Free => Free_Scalar2D public subroutine Free_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Scalar2D public subroutine Gradient_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Gradient_Scalar2D public subroutine Gradient_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Scalar2D public subroutine GridInterp_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Scalar2D public subroutine Init_Scalar2D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (SELFStorage, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (SELFStorage, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (SELFStorage, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Scalar2D public subroutine UpdateDevice_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Scalar2D public subroutine UpdateHost_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D , WriteHDF5_Scalar2D public subroutine WriteHDF5_MPI_Scalar2D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar2D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group procedure, private :: WriteHDF5_MPI_Scalar2D public subroutine WriteHDF5_MPI_Scalar2D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem procedure, private :: WriteHDF5_Scalar2D public subroutine WriteHDF5_Scalar2D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code TYPE , EXTENDS ( SELF_DataObj ), PUBLIC :: Scalar2D TYPE ( hfReal_r4 ) :: interior TYPE ( hfReal_r4 ) :: boundary TYPE ( hfReal_r4 ) :: extBoundary TYPE ( hfReal_r4 ) :: avgBoundary TYPE ( hfReal_r4 ) :: jumpBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar2D PROCEDURE , PUBLIC :: Free => Free_Scalar2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar2D GENERIC , PUBLIC :: Gradient => Gradient_Scalar2D PROCEDURE , PRIVATE :: Gradient_Scalar2D ! PROCEDURE,PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar2D ! PROCEDURE,PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar2D ! GENERIC,PUBLIC :: ASSIGNMENT(=) => Equals_Scalar2D ! PROCEDURE,PRIVATE,PASS(SELFOut) :: Equals_Scalar2D GENERIC , PUBLIC :: WriteHDF5 => WriteHDF5_MPI_Scalar2D , WriteHDF5_Scalar2D PROCEDURE , PRIVATE :: WriteHDF5_MPI_Scalar2D PROCEDURE , PRIVATE :: WriteHDF5_Scalar2D END TYPE Scalar2D","tags":"","loc":"type/scalar2d.html"},{"title":"Scalar3D – SELF ","text":"type, public, extends( SELF_DataObj ) :: Scalar3D Contents Variables avgBoundary boundary eqn extBoundary interior interp jumpBoundary meta nElem nVar Type-Bound Procedures BoundaryInterp Free Gradient Gradient_Scalar3D GridInterp Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 WriteHDF5_MPI_Scalar3D WriteHDF5_Scalar3D Source Code Scalar3D Components Type Visibility Attributes Name Initial type( hfReal_r5 ), public :: avgBoundary type( hfReal_r5 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r5 ), public :: extBoundary type( hfReal_r5 ), public :: interior type( Lagrange ), public, POINTER :: interp type( hfReal_r5 ), public :: jumpBoundary type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D public subroutine BoundaryInterp_Scalar3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, public :: Free => Free_Scalar3D public subroutine Free_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Scalar3D public subroutine Gradient_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Gradient_Scalar3D public subroutine Gradient_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Scalar3D public subroutine GridInterp_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Scalar3D public subroutine Init_Scalar3D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (SELFStorage, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (SELFStorage, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (SELFStorage, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Scalar3D public subroutine UpdateDevice_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Scalar3D public subroutine UpdateHost_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D , WriteHDF5_Scalar3D public subroutine WriteHDF5_MPI_Scalar3D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar3D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group procedure, private :: WriteHDF5_MPI_Scalar3D public subroutine WriteHDF5_MPI_Scalar3D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem procedure, private :: WriteHDF5_Scalar3D public subroutine WriteHDF5_Scalar3D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code TYPE , EXTENDS ( SELF_DataObj ), PUBLIC :: Scalar3D TYPE ( hfReal_r5 ) :: interior TYPE ( hfReal_r5 ) :: boundary TYPE ( hfReal_r5 ) :: extBoundary TYPE ( hfReal_r5 ) :: avgBoundary TYPE ( hfReal_r5 ) :: jumpBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar3D PROCEDURE , PUBLIC :: Free => Free_Scalar3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar3D GENERIC , PUBLIC :: Gradient => Gradient_Scalar3D PROCEDURE , PRIVATE :: Gradient_Scalar3D ! PROCEDURE,PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar3D ! PROCEDURE,PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar3D ! GENERIC,PUBLIC :: ASSIGNMENT(=) => Equals_Scalar3D ! PROCEDURE,PRIVATE,PASS(SELFOut) :: Equals_Scalar3D GENERIC , PUBLIC :: WriteHDF5 => WriteHDF5_MPI_Scalar3D , WriteHDF5_Scalar3D PROCEDURE , PRIVATE :: WriteHDF5_MPI_Scalar3D PROCEDURE , PRIVATE :: WriteHDF5_Scalar3D END TYPE Scalar3D","tags":"","loc":"type/scalar3d.html"},{"title":"Tensor2D – SELF ","text":"type, public, extends( SELF_DataObj ) :: Tensor2D Contents Variables boundary eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures BoundaryInterp Determinant Free Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost Source Code Tensor2D Components Type Visibility Attributes Name Initial type( hfReal_r6 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r6 ), public :: extBoundary type( hfReal_r6 ), public :: interior type( Lagrange ), public, POINTER :: interp type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor2D public subroutine BoundaryInterp_Tensor2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, public :: Determinant => Determinant_Tensor2D public subroutine Determinant_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Free => Free_Tensor2D public subroutine Free_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage procedure, public :: Init => Init_Tensor2D public subroutine Init_Tensor2D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (SELFStorage, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (SELFStorage, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (SELFStorage, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Tensor2D public subroutine UpdateDevice_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Tensor2D public subroutine UpdateHost_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage Source Code TYPE , EXTENDS ( SELF_DataObj ), PUBLIC :: Tensor2D TYPE ( hfReal_r6 ) :: interior TYPE ( hfReal_r6 ) :: boundary TYPE ( hfReal_r6 ) :: extBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Tensor2D PROCEDURE , PUBLIC :: Free => Free_Tensor2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Tensor2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Tensor2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Tensor2D !PROCEDURE,PUBLIC :: GridInterp => GridInterp_Tensor2D PROCEDURE , PUBLIC :: Determinant => Determinant_Tensor2D !GENERIC,PUBLIC :: Divergence => Divergence_Tensor2D !PROCEDURE,PRIVATE :: Divergence_Tensor2D ! PROCEDURE,PUBLIC :: AbsMaxInterior => AbsMaxInterior_Tensor2D ! PROCEDURE,PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Tensor2D ! GENERIC,PUBLIC :: ASSIGNMENT(=) => Equals_Tensor2D ! PROCEDURE,PRIVATE,PASS(SELFOut) :: Equals_Tensor2D !GENERIC,PUBLIC :: SetEquation => SetEquation_Tensor2D !PROCEDURE,PRIVATE :: SetEquation_Tensor2D END TYPE Tensor2D","tags":"","loc":"type/tensor2d.html"},{"title":"Tensor3D – SELF ","text":"type, public, extends( SELF_DataObj ) :: Tensor3D Contents Variables boundary eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures BoundaryInterp Determinant Free Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost Source Code Tensor3D Components Type Visibility Attributes Name Initial type( hfReal_r7 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r7 ), public :: extBoundary type( hfReal_r7 ), public :: interior type( Lagrange ), public, POINTER :: interp type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor3D public subroutine BoundaryInterp_Tensor3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, public :: Determinant => Determinant_Tensor3D public subroutine Determinant_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Free => Free_Tensor3D public subroutine Free_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage procedure, public :: Init => Init_Tensor3D public subroutine Init_Tensor3D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (SELFStorage, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (SELFStorage, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (SELFStorage, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Tensor3D public subroutine UpdateDevice_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Tensor3D public subroutine UpdateHost_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage Source Code TYPE , EXTENDS ( SELF_DataObj ), PUBLIC :: Tensor3D TYPE ( hfReal_r7 ) :: interior TYPE ( hfReal_r7 ) :: boundary TYPE ( hfReal_r7 ) :: extBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Tensor3D PROCEDURE , PUBLIC :: Free => Free_Tensor3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Tensor3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Tensor3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Tensor3D ! PROCEDURE,PUBLIC :: GridInterp => GridInterp_Tensor3D PROCEDURE , PUBLIC :: Determinant => Determinant_Tensor3D !GENERIC,PUBLIC :: Divergence => Divergence_Tensor3D !PROCEDURE,PRIVATE :: Divergence_Tensor3D ! PROCEDURE,PUBLIC :: AbsMaxInterior => AbsMaxInterior_Tensor3D ! PROCEDURE,PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Tensor3D ! GENERIC,PUBLIC :: ASSIGNMENT(=) => Equals_Tensor3D ! PROCEDURE,PRIVATE,PASS(SELFOut) :: Equals_Tensor3D !GENERIC,PUBLIC :: SetEquation => SetEquation_Tensor3D !PROCEDURE,PRIVATE :: SetEquation_Tensor3D END TYPE Tensor3D","tags":"","loc":"type/tensor3d.html"},{"title":"Vector2D – SELF ","text":"type, public, extends( SELF_DataObj ) :: Vector2D Contents Variables boundary boundaryNormal eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures BoundaryInterp Divergence Divergence_Vector2D Free Gradient Gradient_Vector2D GridInterp Init SetDescription SetEquation SetEquation_Vector2D SetName SetUnits UpdateDevice UpdateHost WriteHDF5 WriteHDF5_MPI_Vector2D WriteHDF5_Vector2D Source Code Vector2D Components Type Visibility Attributes Name Initial type( hfReal_r5 ), public :: boundary type( hfReal_r4 ), public :: boundaryNormal type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r5 ), public :: extBoundary type( hfReal_r5 ), public :: interior type( Lagrange ), public, POINTER :: interp type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D public subroutine BoundaryInterp_Vector2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_Vector2D public subroutine Divergence_Vector2D (SELFStorage, SELFOut, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Divergence_Vector2D public subroutine Divergence_Vector2D (SELFStorage, SELFOut, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, public :: Free => Free_Vector2D public subroutine Free_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Vector2D public subroutine Gradient_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Gradient_Vector2D public subroutine Gradient_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Vector2D public subroutine GridInterp_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Vector2D public subroutine Init_Vector2D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (SELFStorage, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector2D public subroutine SetEquation_DataObj (SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector2D (SELFStorage, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, private :: SetEquation_Vector2D public subroutine SetEquation_Vector2D (SELFStorage, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (SELFStorage, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (SELFStorage, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Vector2D public subroutine UpdateDevice_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Vector2D public subroutine UpdateHost_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D , WriteHDF5_Vector2D public subroutine WriteHDF5_MPI_Vector2D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector2D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group procedure, private :: WriteHDF5_MPI_Vector2D public subroutine WriteHDF5_MPI_Vector2D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem procedure, private :: WriteHDF5_Vector2D public subroutine WriteHDF5_Vector2D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code TYPE , EXTENDS ( SELF_DataObj ), PUBLIC :: Vector2D TYPE ( hfReal_r5 ) :: interior TYPE ( hfReal_r5 ) :: boundary TYPE ( hfReal_r5 ) :: extBoundary TYPE ( hfReal_r4 ) :: boundaryNormal CONTAINS PROCEDURE , PUBLIC :: Init => Init_Vector2D PROCEDURE , PUBLIC :: Free => Free_Vector2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Vector2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Vector2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Vector2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Vector2D GENERIC , PUBLIC :: Gradient => Gradient_Vector2D PROCEDURE , PRIVATE :: Gradient_Vector2D GENERIC , PUBLIC :: Divergence => Divergence_Vector2D PROCEDURE , PRIVATE :: Divergence_Vector2D ! GENERIC,PUBLIC :: Curl => Curl_Vector2D ! PROCEDURE,PRIVATE :: Curl_Vector2D ! PROCEDURE,PUBLIC :: AbsMaxInterior => AbsMaxInterior_Vector2D ! PROCEDURE,PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Vector2D ! GENERIC,PUBLIC :: ASSIGNMENT(=) => Equals_Vector2D ! PROCEDURE,PRIVATE,PASS(SELFOut) :: Equals_Vector2D GENERIC , PUBLIC :: SetEquation => SetEquation_Vector2D PROCEDURE , PRIVATE :: SetEquation_Vector2D GENERIC , PUBLIC :: WriteHDF5 => WriteHDF5_MPI_Vector2D , WriteHDF5_Vector2D PROCEDURE , PRIVATE :: WriteHDF5_MPI_Vector2D PROCEDURE , PRIVATE :: WriteHDF5_Vector2D END TYPE Vector2D","tags":"","loc":"type/vector2d.html"},{"title":"Vector3D – SELF ","text":"type, public, extends( SELF_DataObj ) :: Vector3D Contents Variables boundary boundaryNormal eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures BoundaryInterp Divergence Divergence_Vector3D Free Gradient Gradient_Vector3D GridInterp Init SetDescription SetEquation SetEquation_Vector3D SetName SetUnits UpdateDevice UpdateHost WriteHDF5 WriteHDF5_MPI_Vector3D WriteHDF5_Vector3D Source Code Vector3D Components Type Visibility Attributes Name Initial type( hfReal_r6 ), public :: boundary type( hfReal_r5 ), public :: boundaryNormal type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r6 ), public :: extBoundary type( hfReal_r6 ), public :: interior type( Lagrange ), public, POINTER :: interp type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D public subroutine BoundaryInterp_Vector3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_Vector3D public subroutine Divergence_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Divergence_Vector3D public subroutine Divergence_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Free => Free_Vector3D public subroutine Free_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Vector3D public subroutine Gradient_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Gradient_Vector3D public subroutine Gradient_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Vector3D public subroutine GridInterp_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Vector3D public subroutine Init_Vector3D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (SELFStorage, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector3D public subroutine SetEquation_DataObj (SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector3D (SELFStorage, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, private :: SetEquation_Vector3D public subroutine SetEquation_Vector3D (SELFStorage, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (SELFStorage, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (SELFStorage, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Vector3D public subroutine UpdateDevice_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Vector3D public subroutine UpdateHost_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D , WriteHDF5_Vector3D public subroutine WriteHDF5_MPI_Vector3D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector3D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group procedure, private :: WriteHDF5_MPI_Vector3D public subroutine WriteHDF5_MPI_Vector3D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem procedure, private :: WriteHDF5_Vector3D public subroutine WriteHDF5_Vector3D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code TYPE , EXTENDS ( SELF_DataObj ), PUBLIC :: Vector3D TYPE ( hfReal_r6 ) :: interior TYPE ( hfReal_r6 ) :: boundary TYPE ( hfReal_r6 ) :: extBoundary TYPE ( hfReal_r5 ) :: boundaryNormal CONTAINS PROCEDURE , PUBLIC :: Init => Init_Vector3D PROCEDURE , PUBLIC :: Free => Free_Vector3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Vector3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Vector3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Vector3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Vector3D GENERIC , PUBLIC :: Gradient => Gradient_Vector3D PROCEDURE , PRIVATE :: Gradient_Vector3D GENERIC , PUBLIC :: Divergence => Divergence_Vector3D PROCEDURE , PRIVATE :: Divergence_Vector3D ! GENERIC,PUBLIC :: Curl => Curl_Vector3D ! PROCEDURE,PRIVATE :: Curl_Vector3D ! PROCEDURE,PUBLIC :: AbsMaxInterior => AbsMaxInterior_Vector3D ! PROCEDURE,PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Vector3D ! GENERIC,PUBLIC :: ASSIGNMENT(=) => Equals_Vector3D ! PROCEDURE,PRIVATE,PASS(SELFOut) :: Equals_Vector3D GENERIC , PUBLIC :: SetEquation => SetEquation_Vector3D PROCEDURE , PRIVATE :: SetEquation_Vector3D GENERIC , PUBLIC :: WriteHDF5 => WriteHDF5_MPI_Vector3D , WriteHDF5_Vector3D PROCEDURE , PRIVATE :: WriteHDF5_MPI_Vector3D PROCEDURE , PRIVATE :: WriteHDF5_Vector3D END TYPE Vector3D","tags":"","loc":"type/vector3d.html"},{"title":"ECModel2D – SELF ","text":"type, public, extends( Model ) :: ECModel2D Contents Variables dSdt decomp dt entropy flux fluxDivergence geometry gpuAccel ioIterate mesh prevSol solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures AdamsBashforth2_timeIntegrator AdamsBashforth3_timeIntegrator AdamsBashforth4_timeIntegrator CalculateEntropy CalculateFluxDivergence CalculateTendency DisableGPUAccel EnableGPUAccel Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreFlux PreTendency PrintType ReadModel ReportEntropy ReprojectFlux ResizePrevSol RiemannSolver SetBoundaryCondition SetInitialConditions SetSimulationTime SetSolution SetSolutionFromChar_ECModel2D SetSolutionFromEqn_ECModel2D SetTimeIntegrator SourceMethod UpdateBoundary UpdateDevice UpdateGAB2 UpdateGAB3 UpdateGAB4 UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateHost UpdateSolution WriteModel WriteTecplot Source Code ECModel2D Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy type(MappedP2Vector2D), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, POINTER :: geometry logical, public :: gpuAccel integer, public :: ioIterate = 0 type( Mesh2D ), public, POINTER :: mesh type( MappedScalar2D ), public :: prevSol type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator public subroutine AdamsBashforth2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth3_timeIntegrator public subroutine AdamsBashforth3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: AdamsBashforth4_timeIntegrator public subroutine AdamsBashforth4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: CalculateEntropy => CalculateEntropy_Model public subroutine CalculateEntropy_Model (this) Base method for calculating entropy of a model\nWhen this method is not overridden, the entropy\nis simply set to 0.0. When you develop a model\nbuilt on top of this abstract class or one of its\nchildren, it is recommended that you define a\nconvex mathematical entropy function that is used\nas a measure of the model stability. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_ECModel2D public subroutine CalculateFluxDivergence_ECModel2D (this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_ECModel2D public subroutine CalculateTendency_ECModel2D (this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this procedure, public :: DisableGPUAccel => DisableGPUAccel_Model public subroutine DisableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: EnableGPUAccel => EnableGPUAccel_Model public subroutine EnableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => Flux_Model public subroutine Flux_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: tn real(kind=prec), intent(in), optional :: dt real(kind=prec), intent(in), optional :: ioInterval procedure, public :: Free => Free_ECModel2D public subroutine Free_ECModel2D (this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_ECModel2D public subroutine Init_ECModel2D (this, nvar, mesh, geometry, decomp) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), TARGET :: mesh type( SEMQuad ), intent(in), TARGET :: geometry type( MPILayer ), intent(in), TARGET :: decomp procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreFlux => PreFlux_Model public subroutine PreFlux_Model (this) PreFlux is a template routine that is used to house any additional calculations\nthat you want to execute just before the calculation of flux terms.\nThis default PreFlux simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_ECModel2D public subroutine Read_ECModel2D (this, fileName) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReprojectFlux => ReprojectFlux_ECModel2D public subroutine ReprojectFlux_ECModel2D (this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this procedure, public :: ResizePrevSol => ResizePrevSol_ECModel2D public subroutine ResizePrevSol_ECModel2D (this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: RiemannSolver => RiemannSolver_Model public subroutine RiemannSolver_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetBoundaryCondition => SetBoundaryCondition_Model public subroutine SetBoundaryCondition_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetInitialConditions => SetInitialConditions_Model public subroutine SetInitialConditions_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_ECModel2D , SetSolutionFromEqn_ECModel2D public subroutine SetSolutionFromChar_ECModel2D (this, eqnChar) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_ECModel2D (this, eqn) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) procedure, private :: SetSolutionFromChar_ECModel2D public subroutine SetSolutionFromChar_ECModel2D (this, eqnChar) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) procedure, private :: SetSolutionFromEqn_ECModel2D public subroutine SetSolutionFromEqn_ECModel2D (this, eqn) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt , SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withInt (this, integrator) Sets the time integrator method, using an integer flag Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: integrator public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => Source_Model public subroutine Source_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: UpdateBoundary => UpdateBoundary_ECModel2D public subroutine UpdateBoundary_ECModel2D (this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_ECModel2D public subroutine UpdateDevice_ECModel2D (this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this procedure, public :: UpdateGAB2 => UpdateGAB2_ECModel2D public subroutine UpdateGAB2_ECModel2D (this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGAB3 => UpdateGAB3_ECModel2D public subroutine UpdateGAB3_ECModel2D (this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGAB4 => UpdateGAB4_ECModel2D public subroutine UpdateGAB4_ECModel2D (this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK2 => UpdateGRK2_ECModel2D public subroutine UpdateGRK2_ECModel2D (this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_ECModel2D public subroutine UpdateGRK3_ECModel2D (this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_ECModel2D public subroutine UpdateGRK4_ECModel2D (this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateHost => UpdateHost_ECModel2D public subroutine UpdateHost_ECModel2D (this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this procedure, public :: UpdateSolution => UpdateSolution_ECModel2D public subroutine UpdateSolution_ECModel2D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the ECModel's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_ECModel2D public subroutine Write_ECModel2D (this, fileName) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_ECModel2D public subroutine WriteTecplot_ECModel2D (this, filename) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this character, intent(in), optional :: filename Source Code TYPE , EXTENDS ( Model ) :: ECModel2D TYPE ( MappedScalar2D ) :: solution TYPE ( MappedVector2D ) :: solutionGradient TYPE ( MappedP2Vector2D ) :: flux TYPE ( MappedScalar2D ) :: source TYPE ( MappedScalar2D ) :: fluxDivergence TYPE ( MappedScalar2D ) :: dSdt TYPE ( MappedScalar2D ) :: workSol TYPE ( MappedScalar2D ) :: prevSol TYPE ( Mesh2D ), POINTER :: mesh TYPE ( SEMQuad ), POINTER :: geometry CONTAINS PROCEDURE :: Init => Init_ECModel2D PROCEDURE :: Free => Free_ECModel2D PROCEDURE :: UpdateHost => UpdateHost_ECModel2D PROCEDURE :: UpdateDevice => UpdateDevice_ECModel2D PROCEDURE :: UpdateSolution => UpdateSolution_ECModel2D PROCEDURE :: ResizePrevSol => ResizePrevSol_ECModel2D PROCEDURE :: UpdateGAB2 => UpdateGAB2_ECModel2D PROCEDURE :: UpdateGAB3 => UpdateGAB3_ECModel2D PROCEDURE :: UpdateGAB4 => UpdateGAB4_ECModel2D PROCEDURE :: UpdateGRK2 => UpdateGRK2_ECModel2D PROCEDURE :: UpdateGRK3 => UpdateGRK3_ECModel2D PROCEDURE :: UpdateGRK4 => UpdateGRK4_ECModel2D PROCEDURE :: CalculateTendency => CalculateTendency_ECModel2D PROCEDURE :: CalculateFluxDivergence => CalculateFluxDivergence_ECModel2D GENERIC :: SetSolution => SetSolutionFromChar_ECModel2D , & SetSolutionFromEqn_ECModel2D PROCEDURE , PRIVATE :: SetSolutionFromChar_ECModel2D PROCEDURE , PRIVATE :: SetSolutionFromEqn_ECModel2D PROCEDURE :: UpdateBoundary => UpdateBoundary_ECModel2D PROCEDURE :: ReprojectFlux => ReprojectFlux_ECModel2D PROCEDURE :: ReadModel => Read_ECModel2D PROCEDURE :: WriteModel => Write_ECModel2D PROCEDURE :: WriteTecplot => WriteTecplot_ECModel2D END TYPE ECModel2D","tags":"","loc":"type/ecmodel2d.html"},{"title":"AlmostEqual_r64 – SELF","text":"public function AlmostEqual_r64(a, b) result(AisB) \\addtogroup SELF_SupportRoutines\n @{\n \\fn AlmostEqual\n Compares two floating point numbers and determines if they are equal (to machine precision). This function is from Alg. 139 on pg. 359 of D.A. Kopriva, 2009, \"Implementing Spectral Element\n    Methods for Scientists and Engineers\" Usage : Logical :: AisB REAL (prec) :: a, b .... AisB = AlmostEqual( a, b ) Parameters : in a REAL(prec) scalar in b REAL(prec) scalar in AisB Logical .TRUE. IF a=b to machine precision .FALSE. otherwise @} Arguments Type Intent Optional Attributes Name real(kind=real64) :: a real(kind=real64) :: b Return Value logical Contents Source Code AlmostEqual_r64 Source Code FUNCTION AlmostEqual_r64 ( a , b ) RESULT ( AisB ) IMPLICIT NONE REAL ( real64 ) :: a , b LOGICAL :: AisB IF ( a == 0.0_real64 . OR . b == 0.0_real64 ) THEN IF ( ABS ( a - b ) <= EPSILON ( 1.0_real64 )) THEN AisB = . TRUE . ELSE AisB = . FALSE . END IF ELSE IF (( abs ( a - b ) <= EPSILON ( 1.0_real64 ) * abs ( a )) . OR . ( abs ( a - b ) <= EPSILON ( 1.0_real64 ) * abs ( b ))) THEN AisB = . TRUE . ELSE AisB = . FALSE . END IF END IF END FUNCTION AlmostEqual_r64","tags":"","loc":"proc/almostequal_r64.html"},{"title":"CompareArray – SELF","text":"public function CompareArray(arrayOne, arrayTwo, N) result(arraysMatch) \\addtogroup SELF_SupportRoutines\n @{\n \\fn CompareArray\n Compares to INTEGER arrays and determines if they are identical. A logical is returned that specifies whether or not two arrays are identical. To determine\n if the two arrays are identical, the sum of the difference between each element in the input\n array is calculated. If the arrays are identical, each contribution to the sum is zero and hence\n the sum is zero. If the sum is non-zero, the arrays are distinct. This routine is used in the \\ref HexMeshClass module. A face of an element in an unstructured\n mesh is identified by its four corner nodes. When identifying unique faces in an unstructured\n mesh, we need to determine if two elements share a face. This can be accomplished by comparing\n the four corner nodes (from each element) that define each face. Usage : INTEGER :: N INTEGER :: arrayOne(1:N) INTEGER :: arrayTwo(1:N) LOGICAL :: arraysMatch .... arraysMatch = CompareArray( arrayOne, arrayTwo, N ) Parameters : in arrayOne(1:N) INTEGER in arrayTwo(1:N) INTEGER in N INTEGER out arraysMatch INTEGER @} Arguments Type Intent Optional Attributes Name integer :: arrayOne (1:N) integer :: arrayTwo (1:N) integer :: N Return Value logical Contents Source Code CompareArray Source Code FUNCTION CompareArray ( arrayOne , arrayTwo , N ) RESULT ( arraysMatch ) IMPLICIT NONE INTEGER :: N INTEGER :: arrayOne ( 1 : N ), arrayTwo ( 1 : N ) LOGICAL :: arraysMatch ! LOCAL INTEGER :: i , theSumOfDiffs theSumOfDiffs = 0 DO i = 1 , N theSumOfDiffs = theSumOfDiffs + ABS ( arrayOne ( i ) - arrayTwo ( i )) END DO IF ( theSumOfDiffs == 0 ) THEN arraysMatch = . TRUE . ELSE arraysMatch = . FALSE . END IF END FUNCTION CompareArray","tags":"","loc":"proc/comparearray.html"},{"title":"UniformPoints – SELF","text":"public function UniformPoints(a, b, firstInd, lastInd) result(xU) \\addtogroup SELF_SupportRoutines\n @{\n \\fn UniformPoints\n Generates a REAL(prec) array of N points evenly spaced between two points. Usage : REAL (prec) :: a REAL (prec) :: b REAL (prec) :: xU(0:N) INTEGER :: N .... xU = UniformPoints( a, b, N ) Parameters : in a REAL(prec) Starting point of the interval in b REAL(prec) Ending point of the interval in N INTEGER The number of points in the interval \\f$[a,b]\\f$ in xU(0:N) REAL(prec) Array of evenly spaced points in the interval \\f$[a,b]\\f$ @} Arguments Type Intent Optional Attributes Name real(kind=prec) :: a real(kind=prec) :: b integer :: firstInd integer :: lastInd Return Value real(kind=prec)(firstInd:lastInd) Contents Source Code UniformPoints Source Code FUNCTION UniformPoints ( a , b , firstInd , lastInd ) RESULT ( xU ) IMPLICIT NONE REAL ( prec ) :: a , b INTEGER :: firstInd , lastInd REAL ( prec ) :: xU ( firstInd : lastInd ) ! LOCAL REAL ( prec ) :: dx INTEGER :: i dx = ( b - a ) / REAL (( lastInd - firstInd ), prec ) DO i = firstInd , lastInd xU ( i ) = a + dx * REAL ( i - firstInd , prec ) END DO END FUNCTION UniformPoints","tags":"","loc":"proc/uniformpoints.html"},{"title":"UpperCase – SELF","text":"public function UpperCase(str) result(Upper) Arguments Type Intent Optional Attributes Name character, intent(in) :: str Return Value character Contents Source Code UpperCase Source Code FUNCTION UpperCase ( str ) RESULT ( upper ) Implicit None CHARACTER ( * ), INTENT ( In ) :: str CHARACTER ( LEN ( str )) :: Upper INTEGER :: ic , i CHARACTER ( 27 ), PARAMETER :: cap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ ' CHARACTER ( 27 ), PARAMETER :: low = 'abcdefghijklmnopqrstuvwxyz ' DO i = 1 , LEN ( str ) ic = INDEX ( low , str ( i : i )) IF ( ic > 0 ) THEN Upper ( i : i ) = cap ( ic : ic ) ELSE Upper ( i : i ) = str ( i : i ) END IF END DO END FUNCTION UpperCase","tags":"","loc":"proc/uppercase.html"},{"title":"newunit – SELF","text":"public function newunit(unit) Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: unit Return Value integer Contents Source Code newunit Source Code integer function newunit ( unit ) !  https://fortranwiki.org/fortran/show/newunit integer , intent ( out ), optional :: unit ! local integer , parameter :: LUN_MIN = 10 , LUN_MAX = 1000 logical :: opened integer :: lun ! begin newunit =- 1 do lun = LUN_MIN , LUN_MAX inquire ( unit = lun , opened = opened ) if (. not . opened ) then newunit = lun exit end if end do if ( present ( unit )) unit = newunit end function newunit","tags":"","loc":"proc/newunit.html"},{"title":"ForwardShift – SELF","text":"public subroutine ForwardShift(myArray, N) \\addtogroup SELF_SupportRoutines\n @{\n \\fn ForwardShift\n Shift an array integers by one index forward, moving the last index to the first. Shifts the array entries as follows : myArray(1) <-- myArray(N) myArray(2) <-- myArray(1) myArray(3) <-- myArray(2) Usage : INTEGER :: N INTEGER :: myArray(1:N) .... CALL ForwardShift( myArray, N ) Parameters : in/out myArray(1:N) INTEGER On output , the input array with elements shifted forward by\n                         one index. in N INTEGER The number of elements in the array @} Arguments Type Intent Optional Attributes Name integer, intent(inout) :: myArray (1:N) integer, intent(in) :: N Contents Source Code ForwardShift Source Code SUBROUTINE ForwardShift ( myArray , N ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( inout ) :: myArray ( 1 : N ) ! LOCAL INTEGER :: temp ( 1 : N ) temp = myArray myArray ( 1 ) = temp ( N ) myArray ( 2 : N ) = temp ( 1 : N - 1 ) END SUBROUTINE ForwardShift","tags":"","loc":"proc/forwardshift.html"},{"title":"AlmostEqual – SELF","text":"public interface AlmostEqual Contents Module Procedures AlmostEqual_r64 Module Procedures public function AlmostEqual_r64 (a, b) result(AisB) \\addtogroup SELF_SupportRoutines\n @{\n \\fn AlmostEqual\n Compares two floating point numbers and determines if they are equal (to machine precision). Read more… Arguments Type Intent Optional Attributes Name real(kind=real64) :: a real(kind=real64) :: b Return Value logical","tags":"","loc":"interface/almostequal.html"},{"title":"CalculateFluxDivergence_Model3D – SELF","text":"public subroutine CalculateFluxDivergence_Model3D(this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this Contents Source Code CalculateFluxDivergence_Model3D Source Code SUBROUTINE CalculateFluxDivergence_Model3D ( this ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CALL this % flux % Divergence ( this % geometry , & this % fluxDivergence , & selfWeakDGForm , & this % gpuAccel ) END SUBROUTINE CalculateFluxDivergence_Model3D","tags":"","loc":"proc/calculatefluxdivergence_model3d.html"},{"title":"CalculateTendency_Model3D – SELF","text":"public subroutine CalculateTendency_Model3D(this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this Contents Source Code CalculateTendency_Model3D Source Code SUBROUTINE CalculateTendency_Model3D ( this ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this ! Local INTEGER :: i , j , k , iVar , iEl CALL this % PreTendency () CALL this % solution % BoundaryInterp ( this % gpuAccel ) CALL this % solution % SideExchange ( this % mesh , this % decomp , this % gpuAccel ) CALL this % SetBoundaryCondition () CALL this % SourceMethod () CALL this % RiemannSolver () CALL this % FluxMethod () CALL this % ReprojectFlux () CALL this % CalculateFluxDivergence () IF ( this % gpuAccel ) THEN CALL CalculateDSDt_Model3D_gpu_wrapper ( this % fluxDivergence % interior % deviceData , & this % source % interior % deviceData , & this % dSdt % interior % deviceData , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % dSdt % interior % hostData ( i , j , k , iVar , iEl ) = & this % source % interior % hostData ( i , j , k , iVar , iEl ) - & this % fluxDivergence % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO END IF END SUBROUTINE CalculateTendency_Model3D","tags":"","loc":"proc/calculatetendency_model3d.html"},{"title":"Free_Model3D – SELF","text":"public subroutine Free_Model3D(this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this Contents Source Code Free_Model3D Source Code SUBROUTINE Free_Model3D ( this ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CALL this % solution % Free () CALL this % workSol % Free () CALL this % prevSol % Free () CALL this % dSdt % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () END SUBROUTINE Free_Model3D","tags":"","loc":"proc/free_model3d.html"},{"title":"Init_Model3D – SELF","text":"public subroutine Init_Model3D(this, nvar, mesh, geometry, decomp) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(out) :: this integer, intent(in) :: nvar type( Mesh3D ), intent(in), TARGET :: mesh type( SEMHex ), intent(in), TARGET :: geometry type( MPILayer ), intent(in), TARGET :: decomp Contents Source Code Init_Model3D Source Code SUBROUTINE Init_Model3D ( this , nvar , mesh , geometry , decomp ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: nvar TYPE ( Mesh3D ), INTENT ( in ), TARGET :: mesh TYPE ( SEMHex ), INTENT ( in ), TARGET :: geometry TYPE ( MPILayer ), INTENT ( in ), TARGET :: decomp ! Local INTEGER :: ivar CHARACTER ( LEN = 3 ) :: ivarChar CHARACTER ( LEN = 25 ) :: varname this % decomp => decomp this % mesh => mesh this % geometry => geometry this % gpuAccel = . FALSE . CALL this % solution % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % workSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % prevSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % dSdt % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % solutionGradient % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % flux % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % source % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % fluxDivergence % Init ( geometry % x % interp , nVar , this % mesh % nElem ) ! set default metadata DO ivar = 1 , nvar WRITE ( ivarChar , '(I3.3)' ) ivar varname = \"solution\" // TRIM ( ivarChar ) CALL this % solution % SetName ( ivar , varname ) CALL this % solution % SetUnits ( ivar , \"[null]\" ) END DO END SUBROUTINE Init_Model3D","tags":"","loc":"proc/init_model3d.html"},{"title":"Read_Model3D – SELF","text":"public subroutine Read_Model3D(this, fileName) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in) :: fileName Contents Source Code Read_Model3D Source Code SUBROUTINE Read_Model3D ( this , fileName ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 5 ) INTEGER :: firstElem INTEGER :: N IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % decomp % mpiComm ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) END IF ! CALL ReadAttribute_HDF5(fileId,'N',N) ! IF (this % solution % interp % N /= N) THEN !   STOP 'Error : Solution polynomial degree does not match input file' ! END IF IF ( this % decomp % mpiEnabled ) THEN firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 5 ) = ( / 0 , 0 , 0 , 1 , firstElem / ) CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , & this % solution % interior , solOffset ) ELSE CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , this % solution % interior ) END IF CALL Close_HDF5 ( fileId ) IF ( this % gpuAccel ) THEN CALL this % solution % interior % UpdateDevice () END IF END SUBROUTINE Read_Model3D","tags":"","loc":"proc/read_model3d.html"},{"title":"ReprojectFlux_Model3D – SELF","text":"public subroutine ReprojectFlux_Model3D(this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this Contents Source Code ReprojectFlux_Model3D Source Code SUBROUTINE ReprojectFlux_Model3D ( this ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CALL this % flux % ContravariantProjection ( this % geometry , this % gpuAccel ) END SUBROUTINE ReprojectFlux_Model3D","tags":"","loc":"proc/reprojectflux_model3d.html"},{"title":"ResizePrevSol_Model3D – SELF","text":"public subroutine ResizePrevSol_Model3D(this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code ResizePrevSol_Model3D Source Code SUBROUTINE ResizePrevSol_Model3D ( this , m ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: nVar ! Free space, if necessary CALL this % prevSol % Free () ! Reallocate with increased variable dimension for ! storing \"m\" copies of solution data nVar = this % solution % nVar CALL this % prevSol % Init ( this % geometry % x % interp , m * nVar , this % mesh % nElem ) END SUBROUTINE ResizePrevSol_Model3D","tags":"","loc":"proc/resizeprevsol_model3d.html"},{"title":"SetSolutionFromChar_Model3D – SELF","text":"public subroutine SetSolutionFromChar_Model3D(this, eqnChar) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) Contents Source Code SetSolutionFromChar_Model3D Source Code SUBROUTINE SetSolutionFromChar_Model3D ( this , eqnChar ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: eqnChar ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar DO iVar = 1 , this % solution % nVar CALL this % solution % SetEquation ( ivar , TRIM ( eqnChar ( iVar ))) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromChar_Model3D","tags":"","loc":"proc/setsolutionfromchar_model3d.html"},{"title":"SetSolutionFromEqn_Model3D – SELF","text":"public subroutine SetSolutionFromEqn_Model3D(this, eqn) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) Contents Source Code SetSolutionFromEqn_Model3D Source Code SUBROUTINE SetSolutionFromEqn_Model3D ( this , eqn ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar ! Copy the equation parser DO iVar = 1 , this % solution % nVar CALL this % solution % SetEquation ( ivar , eqn ( iVar ) % equation ) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromEqn_Model3D","tags":"","loc":"proc/setsolutionfromeqn_model3d.html"},{"title":"UpdateDevice_Model3D – SELF","text":"public subroutine UpdateDevice_Model3D(this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this Contents Source Code UpdateDevice_Model3D Source Code SUBROUTINE UpdateDevice_Model3D ( this ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CALL this % mesh % UpdateDevice () CALL this % geometry % UpdateDevice () CALL this % dSdt % UpdateDevice () CALL this % solution % UpdateDevice () CALL this % solutionGradient % UpdateDevice () CALL this % flux % UpdateDevice () CALL this % source % UpdateDevice () CALL this % fluxDivergence % UpdateDevice () END SUBROUTINE UpdateDevice_Model3D","tags":"","loc":"proc/updatedevice_model3d.html"},{"title":"UpdateGAB2_Model3D – SELF","text":"public subroutine UpdateGAB2_Model3D(this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGAB2_Model3D Source Code SUBROUTINE UpdateGAB2_Model3D ( this , m ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , k , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB2_Model3D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE ! ab2_weight IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSEIF ( m == 1 ) THEN ! Reset solution DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , k , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last solution this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & 1.5_PREC * this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) - & 0.5_PREC * this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) END DO END DO ENDDO END DO END DO END IF END IF END SUBROUTINE UpdateGAB2_Model3D","tags":"","loc":"proc/updategab2_model3d.html"},{"title":"UpdateGAB3_Model3D – SELF","text":"public subroutine UpdateGAB3_Model3D(this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGAB3_Model3D Source Code SUBROUTINE UpdateGAB3_Model3D ( this , m ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , k , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB3_Model3D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSEIF ( m == 2 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , k , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions this % prevSol % interior % hostData ( i , j , k , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & ( 2 3.0_PREC * this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) - & 1 6.0_PREC * this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) + & 5.0_PREC * this % prevSol % interior % hostData ( i , j , k , 2 * nVar + iVar , iEl )) / 1 2.0_PREC END DO END DO ENDDO END DO END DO END IF END IF END SUBROUTINE UpdateGAB3_Model3D","tags":"","loc":"proc/updategab3_model3d.html"},{"title":"UpdateGAB4_Model3D – SELF","text":"public subroutine UpdateGAB4_Model3D(this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGAB4_Model3D Source Code SUBROUTINE UpdateGAB4_Model3D ( this , m ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , k , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB4_Model3D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , k , 2 * nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSEIF ( m == 2 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSEIF ( m == 3 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , k , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) END DO ENDDO END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions this % prevSol % interior % hostData ( i , j , k , 3 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , 2 * nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , k , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & ( 5 5.0_PREC * this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) - & 5 9.0_PREC * this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) + & 3 7.0_PREC * this % prevSol % interior % hostData ( i , j , k , 2 * nVar + iVar , iEl ) - & 9.0_PREC * this % prevSol % interior % hostData ( i , j , k , 3 * nVar + iVar , iEl )) / 2 4.0_PREC END DO END DO ENDDO END DO END DO END IF END IF END SUBROUTINE UpdateGAB4_Model3D","tags":"","loc":"proc/updategab4_model3d.html"},{"title":"UpdateGRK2_Model3D – SELF","text":"public subroutine UpdateGRK2_Model3D(this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK2_Model3D Source Code SUBROUTINE UpdateGRK2_Model3D ( this , m ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , k , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model3D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk2_a ( m ), rk2_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , k , iVar , iEl ) = rk2_a ( m ) * & this % workSol % interior % hostData ( i , j , k , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , k , iVar , iEl ) this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & this % solution % interior % hostData ( i , j , k , iVar , iEl ) + & rk2_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , k , iVar , iEl ) END DO ENDDO END DO END DO END DO END IF END SUBROUTINE UpdateGRK2_Model3D","tags":"","loc":"proc/updategrk2_model3d.html"},{"title":"UpdateGRK3_Model3D – SELF","text":"public subroutine UpdateGRK3_Model3D(this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK3_Model3D Source Code SUBROUTINE UpdateGRK3_Model3D ( this , m ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , k , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model3D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk3_a ( m ), rk3_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , k , iVar , iEl ) = rk3_a ( m ) * & this % workSol % interior % hostData ( i , j , k , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , k , iVar , iEl ) this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & this % solution % interior % hostData ( i , j , k , iVar , iEl ) + & rk3_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO END IF END SUBROUTINE UpdateGRK3_Model3D","tags":"","loc":"proc/updategrk3_model3d.html"},{"title":"UpdateGRK4_Model3D – SELF","text":"public subroutine UpdateGRK4_Model3D(this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK4_Model3D Source Code SUBROUTINE UpdateGRK4_Model3D ( this , m ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , k , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model3D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk4_a ( m ), rk4_g ( m ), this % dt , & this % workSol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , k , iVar , iEl ) = rk4_a ( m ) * & this % workSol % interior % hostData ( i , j , k , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , k , iVar , iEl ) this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & this % solution % interior % hostData ( i , j , k , iVar , iEl ) + & rk4_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO END IF END SUBROUTINE UpdateGRK4_Model3D","tags":"","loc":"proc/updategrk4_model3d.html"},{"title":"UpdateHost_Model3D – SELF","text":"public subroutine UpdateHost_Model3D(this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this Contents Source Code UpdateHost_Model3D Source Code SUBROUTINE UpdateHost_Model3D ( this ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CALL this % mesh % UpdateHost () CALL this % geometry % UpdateHost () CALL this % solution % UpdateHost () CALL this % dSdt % UpdateHost () CALL this % solution % UpdateHost () CALL this % solutionGradient % UpdateHost () CALL this % flux % UpdateHost () CALL this % source % UpdateHost () CALL this % fluxDivergence % UpdateHost () END SUBROUTINE UpdateHost_Model3D","tags":"","loc":"proc/updatehost_model3d.html"},{"title":"UpdateSolution_Model3D – SELF","text":"public subroutine UpdateSolution_Model3D(this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt Contents Source Code UpdateSolution_Model3D Source Code SUBROUTINE UpdateSolution_Model3D ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this REAL ( prec ), OPTIONAL , INTENT ( in ) :: dt ! Local REAL ( prec ) :: dtLoc INTEGER :: i , j , k , iVar , iEl IF ( PRESENT ( dt )) THEN dtLoc = dt ELSE dtLoc = this % dt END IF IF ( this % gpuAccel ) THEN CALL UpdateSolution_Model3D_gpu_wrapper ( this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & dtLoc , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & this % solution % interior % hostData ( i , j , k , iVar , iEl ) + & dtLoc * this % dSdt % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO END IF END SUBROUTINE UpdateSolution_Model3D","tags":"","loc":"proc/updatesolution_model3d.html"},{"title":"WriteTecplot_Model3D – SELF","text":"public subroutine WriteTecplot_Model3D(this, filename) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in), optional :: filename Contents Source Code WriteTecplot_Model3D Source Code SUBROUTINE WriteTecplot_Model3D ( this , filename ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ), OPTIONAL :: filename ! Local CHARACTER ( 8 ) :: zoneID INTEGER :: fUnit INTEGER :: iEl , i , j , k , iVar CHARACTER ( LEN = self_FileNameLength ) :: tecFile CHARACTER ( LEN = self_TecplotHeaderLength ) :: tecHeader CHARACTER ( LEN = self_FormatLength ) :: fmat CHARACTER ( 13 ) :: timeStampString CHARACTER ( 5 ) :: rankString TYPE ( Scalar3D ) :: solution TYPE ( Vector3D ) :: solutionGradient TYPE ( Vector3D ) :: x TYPE ( Lagrange ), TARGET :: interp IF ( PRESENT ( filename )) THEN tecFile = filename ELSE WRITE ( timeStampString , '(I13.13)' ) this % ioIterate IF ( this % decomp % mpiEnabled ) THEN WRITE ( rankString , '(I5.5)' ) this % decomp % rankId tecFile = 'solution.' // rankString // '.' // timeStampString // '.tec' ELSE tecFile = 'solution.' // timeStampString // '.tec' END IF END IF ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL solutionGradient % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solutionGradient % GridInterp ( solutionGradient , gpuAccel = . FALSE .) OPEN ( UNIT = NEWUNIT ( fUnit ), & FILE = TRIM ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) tecHeader = 'VARIABLES = \"X\", \"Y\", \"Z\"' DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"' // TRIM ( this % solution % meta ( iVar ) % name ) // '\"' END DO DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"d/dx(' // TRIM ( this % solution % meta ( iVar ) % name ) // ')\"' END DO DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"d/dy(' // TRIM ( this % solution % meta ( iVar ) % name ) // ')\"' END DO WRITE ( fUnit , * ) TRIM ( tecHeader ) ! Create format statement WRITE ( fmat , * ) 3 * this % solution % nvar + 3 fmat = '(' // TRIM ( fmat ) // '(ES16.7E3,1x))' DO iEl = 1 , this % solution % nElem ! TO DO :: Get the global element ID WRITE ( zoneID , '(I8.8)' ) iEl WRITE ( fUnit , * ) 'ZONE T=\"el' // TRIM ( zoneID ) // '\", I=' , this % solution % interp % M + 1 , & ', J=' , this % solution % interp % M + 1 DO k = 0 , this % solution % interp % M DO j = 0 , this % solution % interp % M DO i = 0 , this % solution % interp % M WRITE ( fUnit , fmat ) x % interior % hostData ( 1 , i , j , k , 1 , iEl ), & x % interior % hostData ( 2 , i , j , k , 1 , iEl ), & x % interior % hostData ( 3 , i , j , k , 1 , iEl ), & solution % interior % hostData ( i , j , k , 1 : this % solution % nvar , iEl ), & solutionGradient % interior % hostData ( 1 , i , j , k , 1 : this % solution % nvar , iEl ), & solutionGradient % interior % hostData ( 2 , i , j , k , 1 : this % solution % nvar , iEl ), & solutionGradient % interior % hostData ( 3 , i , j , k , 1 : this % solution % nvar , iEl ) END DO END DO ENDDO END DO CLOSE ( UNIT = fUnit ) CALL x % Free () CALL solution % Free () CALL interp % Free () END SUBROUTINE WriteTecplot_Model3D","tags":"","loc":"proc/writetecplot_model3d.html"},{"title":"Write_Model3D – SELF","text":"public subroutine Write_Model3D(this, fileName) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in), optional :: fileName Contents Source Code Write_Model3D Source Code SUBROUTINE Write_Model3D ( this , fileName ) #undef __FUNC__ #define __FUNC__ \"Write_Model3D\" IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CHARACTER ( * ), OPTIONAL , INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId TYPE ( Scalar3D ) :: solution TYPE ( Vector3D ) :: x TYPE ( Lagrange ), TARGET :: interp CHARACTER ( LEN = self_FileNameLength ) :: pickupFile CHARACTER ( 13 ) :: timeStampString IF ( PRESENT ( filename )) THEN pickupFile = filename ELSE WRITE ( timeStampString , '(I13.13)' ) this % ioIterate pickupFile = 'solution.' // timeStampString // '.h5' END IF IF ( this % gpuAccel ) THEN CALL this % solution % UpdateHost () CALL this % solutionGradient % UpdateHost () END IF INFO ( \"Writing pickup file : \" // TRIM ( pickupFile )) IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId , this % decomp % mpiComm ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file INFO ( \"Writing control grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid/mesh' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/mesh/coords' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) CALL Close_HDF5 ( fileId ) ELSE CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' ) ! Write the geometry to file INFO ( \"Writing control grid  geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file INFO ( \"Writing target grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' ) ! Write the geometry to file INFO ( \"Writing target grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid/geometry' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/geometry/x' ) CALL Close_HDF5 ( fileId ) END IF CALL x % Free () CALL solution % Free () CALL interp % Free () END SUBROUTINE Write_Model3D","tags":"","loc":"proc/write_model3d.html"},{"title":"CalculateDSDt_Model3D_gpu_wrapper – SELF","text":"interface public subroutine CalculateDSDt_Model3D_gpu_wrapper(fluxDivergence, source, dSdt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: fluxDivergence type(C_PTR) :: source type(C_PTR) :: dSdt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/calculatedsdt_model3d_gpu_wrapper.html"},{"title":"UpdateGAB2_Model3D_gpu_wrapper – SELF","text":"interface public subroutine UpdateGAB2_Model3D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updategab2_model3d_gpu_wrapper.html"},{"title":"UpdateGAB3_Model3D_gpu_wrapper – SELF","text":"interface public subroutine UpdateGAB3_Model3D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updategab3_model3d_gpu_wrapper.html"},{"title":"UpdateGAB4_Model3D_gpu_wrapper – SELF","text":"interface public subroutine UpdateGAB4_Model3D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updategab4_model3d_gpu_wrapper.html"},{"title":"UpdateGRK_Model3D_gpu_wrapper – SELF","text":"interface public subroutine UpdateGRK_Model3D_gpu_wrapper(grk, solution, dSdt, rk_a, rk_g, dt, nWork, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: grk type(C_PTR) :: solution type(C_PTR) :: dSdt real(kind=c_prec), VALUE :: rk_a real(kind=c_prec), VALUE :: rk_g real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: nWork integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updategrk_model3d_gpu_wrapper.html"},{"title":"UpdateSolution_Model3D_gpu_wrapper – SELF","text":"interface public subroutine UpdateSolution_Model3D_gpu_wrapper(solution, dSdt, dt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: solution type(C_PTR) :: dSdt real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updatesolution_model3d_gpu_wrapper.html"},{"title":"CalculateLagrangePolynomials – SELF","text":"public function CalculateLagrangePolynomials(myPoly, sE) result(lAtS) Arguments Type Intent Optional Attributes Name class( Lagrange ) :: myPoly real(kind=prec) :: sE Return Value real(kind=prec)(0:myPoly%N) Contents Source Code CalculateLagrangePolynomials Source Code FUNCTION CalculateLagrangePolynomials ( myPoly , sE ) RESULT ( lAtS ) IMPLICIT NONE CLASS ( Lagrange ) :: myPoly REAL ( prec ) :: sE REAL ( prec ) :: lAtS ( 0 : myPoly % N ) ! Local INTEGER :: j LOGICAL :: xMatchesNode REAL ( real64 ) :: temp1 , temp2 REAL ( real64 ) :: sELocal REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: lS ( 0 : myPoly % N ) sELocal = REAL ( sE , real64 ) DO j = 0 , myPoly % N controlPoints ( j ) = REAL ( myPoly % controlPoints % hostData ( j ), real64 ) bWeights ( j ) = REAL ( myPoly % bWeights % hostData ( j ), real64 ) END DO xMatchesNode = . FALSE . DO j = 0 , myPoly % N lS ( j ) = 0.0_real64 IF ( AlmostEqual ( sELocal , controlPoints ( j ))) THEN lS ( j ) = 1.0_real64 xMatchesNode = . TRUE . END IF END DO IF ( xMatchesNode ) THEN DO j = 0 , myPoly % N lAtS ( j ) = REAL ( lS ( j ), prec ) END DO RETURN END IF temp1 = 0.0_real64 DO j = 0 , myPoly % N temp2 = bWeights ( j ) / ( sE - controlPoints ( j )) lS ( j ) = temp2 temp1 = temp1 + temp2 END DO lS = lS / temp1 DO j = 0 , myPoly % N lAtS ( j ) = REAL ( lS ( j ), prec ) END DO END FUNCTION CalculateLagrangePolynomials","tags":"","loc":"proc/calculatelagrangepolynomials.html"},{"title":"CalculateBarycentricWeights – SELF","text":"public subroutine CalculateBarycentricWeights(myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Contents Source Code CalculateBarycentricWeights Source Code SUBROUTINE CalculateBarycentricWeights ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: i , j REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) DO i = 0 , myPoly % N bWeights ( i ) = 1.0_real64 controlPoints ( i ) = REAL ( myPoly % controlPoints % hostData ( i ), real64 ) END DO ! Computes the product w_k = w_k*(s_k - s_j), k /= j DO j = 1 , myPoly % N DO i = 0 , j - 1 bWeights ( i ) = bWeights ( i ) * ( controlPoints ( i ) - controlPoints ( j )) bWeights ( j ) = bWeights ( j ) * ( controlPoints ( j ) - controlPoints ( i )) END DO END DO DO j = 0 , myPoly % N bWeights ( j ) = 1.0_prec / bWeights ( j ) myPoly % bWeights % hostData ( j ) = REAL ( bWeights ( j ), prec ) END DO END SUBROUTINE CalculateBarycentricWeights","tags":"","loc":"proc/calculatebarycentricweights.html"},{"title":"CalculateDerivativeMatrix – SELF","text":"public subroutine CalculateDerivativeMatrix(myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Contents Source Code CalculateDerivativeMatrix Source Code SUBROUTINE CalculateDerivativeMatrix ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: row , col REAL ( real64 ) :: dmat ( 0 : myPoly % N , 0 : myPoly % N ) REAL ( real64 ) :: dgmat ( 0 : myPoly % N , 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: qWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) DO row = 0 , myPoly % N bWeights ( row ) = REAL ( myPoly % bWeights % hostData ( row ), real64 ) qWeights ( row ) = REAL ( myPoly % qWeights % hostData ( row ), real64 ) controlPoints ( row ) = REAL ( myPoly % controlPoints % hostData ( row ), real64 ) END DO DO row = 0 , myPoly % N dmat ( row , row ) = 0.0_prec DO col = 0 , myPoly % N IF (. NOT . ( col == row )) THEN dmat ( row , col ) = bWeights ( col ) / & ( bWeights ( row ) * & ( controlPoints ( row ) - & controlPoints ( col ))) dmat ( row , row ) = dmat ( row , row ) - dmat ( row , col ) END IF END DO END DO DO row = 0 , myPoly % N DO col = 0 , myPoly % N dgmat ( row , col ) = - dmat ( col , row ) * & qWeights ( col ) / & qWeights ( row ) END DO END DO DO row = 0 , myPoly % N DO col = 0 , myPoly % N myPoly % dMatrix % hostData ( row , col ) = REAL ( dmat ( col , row ), prec ) myPoly % dgMatrix % hostData ( row , col ) = REAL ( dgmat ( col , row ), prec ) END DO END DO END SUBROUTINE CalculateDerivativeMatrix","tags":"","loc":"proc/calculatederivativematrix.html"},{"title":"CalculateInterpolationMatrix – SELF","text":"public subroutine CalculateInterpolationMatrix(myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Contents Source Code CalculateInterpolationMatrix Source Code SUBROUTINE CalculateInterpolationMatrix ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: row , col LOGICAL :: rowHasMatch REAL ( real64 ) :: temp1 , temp2 REAL ( real64 ) :: iMatrix ( 0 : myPoly % M , 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) REAL ( real64 ) :: targetPoints ( 0 : myPoly % M ) DO col = 0 , myPoly % N controlPoints ( col ) = REAL ( myPoly % controlPoints % hostData ( col ), real64 ) bWeights ( col ) = REAL ( myPoly % bWeights % hostData ( col ), real64 ) END DO DO row = 0 , myPoly % M targetPoints ( row ) = REAL ( myPoly % targetPoints % hostData ( row ), real64 ) END DO DO row = 0 , myPoly % M rowHasMatch = . FALSE . DO col = 0 , myPoly % N iMatrix ( row , col ) = 0.0_real64 IF ( AlmostEqual ( targetPoints ( row ), controlPoints ( col ))) THEN rowHasMatch = . TRUE . iMatrix ( row , col ) = 1.0_real64 END IF END DO IF (. NOT . ( rowHasMatch )) THEN temp1 = 0.0_real64 DO col = 0 , myPoly % N temp2 = bWeights ( col ) / & ( targetPoints ( row ) - & controlPoints ( col )) iMatrix ( row , col ) = temp2 temp1 = temp1 + temp2 END DO DO col = 0 , myPoly % N iMatrix ( row , col ) = iMatrix ( row , col ) / temp1 END DO END IF END DO DO row = 0 , myPoly % M DO col = 0 , myPoly % N myPoly % iMatrix % hostData ( col , row ) = REAL ( iMatrix ( row , col ), prec ) END DO END DO END SUBROUTINE CalculateInterpolationMatrix","tags":"","loc":"proc/calculateinterpolationmatrix.html"},{"title":"DGDerivative_1D_cpu – SELF","text":"public subroutine DGDerivative_1D_cpu(myPoly, f, bf, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:nVariables,1:2,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code DGDerivative_1D_cpu Source Code SUBROUTINE DGDerivative_1D_cpu ( myPoly , f , bf , df , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : nVariables , 1 : 2 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: df ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N ! Interior Derivative Matrix Application df ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO ! Boundary Contribution df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + ( bf ( iVar , 2 , iEl ) * myPoly % bMatrix % hostData ( i , 1 ) + & bf ( iVar , 1 , iEl ) * myPoly % bMatrix % hostData ( i , 0 )) / & myPoly % qWeights % hostData ( i ) END DO END DO END DO END SUBROUTINE DGDerivative_1D_cpu","tags":"","loc":"proc/dgderivative_1d_cpu.html"},{"title":"DGDerivative_1D_gpu – SELF","text":"public subroutine DGDerivative_1D_gpu(myPoly, f_dev, bf_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code DGDerivative_1D_gpu Source Code SUBROUTINE DGDerivative_1D_gpu ( myPoly , f_dev , bf_dev , df_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: df_dev CALL DGDerivative_1D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bf_dev , df_dev , & myPoly % N , & nVariables , nElements ) END SUBROUTINE DGDerivative_1D_gpu","tags":"","loc":"proc/dgderivative_1d_gpu.html"},{"title":"Derivative_1D_cpu – SELF","text":"public subroutine Derivative_1D_cpu(myPoly, f, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code Derivative_1D_cpu Source Code SUBROUTINE Derivative_1D_cpu ( myPoly , f , df , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: df ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N df ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO END DO END DO END DO END SUBROUTINE Derivative_1D_cpu","tags":"","loc":"proc/derivative_1d_cpu.html"},{"title":"Derivative_1D_gpu – SELF","text":"public subroutine Derivative_1D_gpu(myPoly, f_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code Derivative_1D_gpu Source Code SUBROUTINE Derivative_1D_gpu ( myPoly , f_dev , df_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: df_dev CALL Derivative_1D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , df_dev , & myPoly % N , & nVariables , nElements ) END SUBROUTINE Derivative_1D_gpu","tags":"","loc":"proc/derivative_1d_gpu.html"},{"title":"Free_Lagrange – SELF","text":"public subroutine Free_Lagrange(myPoly) Frees all memory (host and device) associated with an instance of the Lagrange class Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance Contents Source Code Free_Lagrange Source Code SUBROUTINE Free_Lagrange ( myPoly ) !! Frees all memory (host and device) associated with an instance of the Lagrange class IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly !! Lagrange class instance CALL myPoly % controlPoints % Free () CALL myPoly % targetPoints % Free () CALL myPoly % bWeights % Free () CALL myPoly % qWeights % Free () CALL myPoly % iMatrix % Free () CALL myPoly % dMatrix % Free () CALL myPoly % dgMatrix % Free () CALL myPoly % bMatrix % Free () END SUBROUTINE Free_Lagrange","tags":"","loc":"proc/free_lagrange.html"},{"title":"Init_Lagrange – SELF","text":"public subroutine Init_Lagrange(myPoly, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange class\nOn output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(out) :: myPoly Lagrange class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) Contents Source Code Init_Lagrange Source Code SUBROUTINE Init_Lagrange ( myPoly , N , controlNodeType , M , targetNodeType ) !! Initialize an instance of the Lagrange class !! On output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of !! control points, number of target points, and the types for the control and target nodes. !! If a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. IMPLICIT NONE CLASS ( Lagrange ), INTENT ( out ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: N !! The number of control points for interpolant INTEGER , INTENT ( in ) :: M !! The number of target points for the interpolant INTEGER , INTENT ( in ) :: controlNodeType !! The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) INTEGER , INTENT ( in ) :: targetNodeType !! The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) ! -------! ! Local REAL ( prec ) :: q ( 0 : M ) myPoly % N = N myPoly % M = M myPoly % controlNodeType = controlNodeType myPoly % targetNodeType = targetNodeType CALL myPoly % controlPoints % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % targetPoints % Alloc ( loBound = 0 , & upBound = M ) CALL myPoly % bWeights % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % qWeights % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % iMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , M / )) CALL myPoly % dMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , N / )) CALL myPoly % dgMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , N / )) CALL myPoly % bMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , 1 / )) IF ( controlNodeType == GAUSS . OR . controlNodeType == GAUSS_LOBATTO ) THEN CALL LegendreQuadrature ( N , & myPoly % controlPoints % hostData , & myPoly % qWeights % hostData , & controlNodeType ) ELSEIF ( controlNodeType == CHEBYSHEV_GAUSS . OR . controlNodeType == CHEBYSHEV_GAUSS_LOBATTO ) THEN CALL ChebyshevQuadrature ( N , & myPoly % controlPoints % hostData , & myPoly % qWeights % hostData , & controlNodeType ) ELSEIF ( controlNodeType == UNIFORM ) THEN myPoly % controlPoints % hostData = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , N ) myPoly % qWeights % hostData = 2.0_prec / REAL ( N , prec ) END IF ! Target Points IF ( targetNodeType == GAUSS . OR . targetNodeType == GAUSS_LOBATTO ) THEN CALL LegendreQuadrature ( M , & myPoly % targetPoints % hostData , & q , & targetNodeType ) ELSEIF ( targetNodeType == UNIFORM ) THEN myPoly % targetPoints % hostData = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , M ) END IF CALL myPoly % CalculateBarycentricWeights () CALL myPoly % CalculateInterpolationMatrix () CALL myPoly % CalculateDerivativeMatrix () myPoly % bMatrix % hostData ( 0 : N , 0 ) = myPoly % CalculateLagrangePolynomials ( - 1.0_prec ) myPoly % bMatrix % hostData ( 0 : N , 1 ) = myPoly % CalculateLagrangePolynomials ( 1.0_prec ) CALL myPoly % UpdateDevice () END SUBROUTINE Init_Lagrange","tags":"","loc":"proc/init_lagrange.html"},{"title":"ScalarBoundaryInterp_1D_cpu – SELF","text":"public subroutine ScalarBoundaryInterp_1D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:nVariables,1:2,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarBoundaryInterp_1D_cpu Source Code SUBROUTINE ScalarBoundaryInterp_1D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : nVariables , 1 : 2 , 1 : nElements ) ! Local INTEGER :: ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables fb ( 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , iVar , iEl ) ! West fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , iVar , iEl ) ! East END DO fBound ( iVar , 1 : 2 , iEl ) = fb ( 1 : 2 ) END DO END DO END SUBROUTINE ScalarBoundaryInterp_1D_cpu","tags":"","loc":"proc/scalarboundaryinterp_1d_cpu.html"},{"title":"ScalarBoundaryInterp_1D_gpu – SELF","text":"public subroutine ScalarBoundaryInterp_1D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarBoundaryInterp_1D_gpu Source Code SUBROUTINE ScalarBoundaryInterp_1D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL ScalarBoundaryInterp_1D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE ScalarBoundaryInterp_1D_gpu","tags":"","loc":"proc/scalarboundaryinterp_1d_gpu.html"},{"title":"ScalarBoundaryInterp_2D_cpu – SELF","text":"public subroutine ScalarBoundaryInterp_2D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarBoundaryInterp_2D_cpu Source Code SUBROUTINE ScalarBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , ii , iVar , iEl ) ! South fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , i , iVar , iEl ) ! East fb ( 3 ) = fb ( 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , ii , iVar , iEl ) ! North fb ( 4 ) = fb ( 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , i , iVar , iEl ) ! West END DO fBound ( i , iVar , 1 : 4 , iEl ) = fb ( 1 : 4 ) END DO END DO END DO END SUBROUTINE ScalarBoundaryInterp_2D_cpu","tags":"","loc":"proc/scalarboundaryinterp_2d_cpu.html"},{"title":"ScalarBoundaryInterp_2D_gpu – SELF","text":"public subroutine ScalarBoundaryInterp_2D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarBoundaryInterp_2D_gpu Source Code SUBROUTINE ScalarBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL ScalarBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE ScalarBoundaryInterp_2D_gpu","tags":"","loc":"proc/scalarboundaryinterp_2d_gpu.html"},{"title":"ScalarBoundaryInterp_3D_cpu – SELF","text":"public subroutine ScalarBoundaryInterp_3D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarBoundaryInterp_3D_cpu Source Code SUBROUTINE ScalarBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , j , ii , iVar , iEl ) ! Bottom fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , ii , j , iVar , iEl ) ! South fb ( 3 ) = fb ( 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , i , j , iVar , iEl ) ! East fb ( 4 ) = fb ( 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , ii , j , iVar , iEl ) ! North fb ( 5 ) = fb ( 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , i , j , iVar , iEl ) ! West fb ( 6 ) = fb ( 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , j , ii , iVar , iEl ) ! Top END DO fBound ( i , j , iVar , 1 : 6 , iEl ) = fb ( 1 : 6 ) END DO END DO END DO END DO END SUBROUTINE ScalarBoundaryInterp_3D_cpu","tags":"","loc":"proc/scalarboundaryinterp_3d_cpu.html"},{"title":"ScalarBoundaryInterp_3D_gpu – SELF","text":"public subroutine ScalarBoundaryInterp_3D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarBoundaryInterp_3D_gpu Source Code SUBROUTINE ScalarBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL ScalarBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE ScalarBoundaryInterp_3D_gpu","tags":"","loc":"proc/scalarboundaryinterp_3d_gpu.html"},{"title":"ScalarGradient_2D_cpu – SELF","text":"public subroutine ScalarGradient_2D_cpu(myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarGradient_2D_cpu Source Code SUBROUTINE ScalarGradient_2D_cpu ( myPoly , f , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = gradF ( 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , j , iVar , iEl ) gradF ( 2 , i , j , iVar , iEl ) = gradF ( 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE ScalarGradient_2D_cpu","tags":"","loc":"proc/scalargradient_2d_cpu.html"},{"title":"ScalarGradient_2D_gpu – SELF","text":"public subroutine ScalarGradient_2D_gpu(myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarGradient_2D_gpu Source Code SUBROUTINE ScalarGradient_2D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL ScalarGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE ScalarGradient_2D_gpu","tags":"","loc":"proc/scalargradient_2d_gpu.html"},{"title":"ScalarGradient_3D_cpu – SELF","text":"public subroutine ScalarGradient_3D_cpu(myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarGradient_3D_cpu Source Code SUBROUTINE ScalarGradient_3D_cpu ( myPoly , f , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl REAL ( prec ) :: gf ( 1 : 3 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N gF ( 1 ) = 0.0_prec gF ( 2 ) = 0.0_prec gF ( 3 ) = 0.0_prec DO ii = 0 , myPoly % N gF ( 1 ) = gF ( 1 ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , j , k , iVar , iEl ) gF ( 2 ) = gF ( 2 ) + myPoly % dMatrix % hostData ( ii , j ) * f ( i , ii , k , iVar , iEl ) gF ( 3 ) = gF ( 3 ) + myPoly % dMatrix % hostData ( ii , k ) * f ( i , j , ii , iVar , iEl ) END DO gradF ( 1 , i , j , k , iVar , iEl ) = gF ( 1 ) gradF ( 2 , i , j , k , iVar , iEl ) = gF ( 2 ) gradF ( 3 , i , j , k , iVar , iEl ) = gF ( 3 ) END DO END DO END DO END DO END DO END SUBROUTINE ScalarGradient_3D_cpu","tags":"","loc":"proc/scalargradient_3d_cpu.html"},{"title":"ScalarGradient_3D_gpu – SELF","text":"public subroutine ScalarGradient_3D_gpu(myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarGradient_3D_gpu Source Code SUBROUTINE ScalarGradient_3D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL ScalarGradient_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE ScalarGradient_3D_gpu","tags":"","loc":"proc/scalargradient_3d_gpu.html"},{"title":"ScalarGridInterp_1D_cpu – SELF","text":"public subroutine ScalarGridInterp_1D_cpu(myPoly, f, fInterp, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Interpolation is applied using a series of matrix-vector multiplications, using\nthe Lagrange class's interpolation matrix Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fInterp (0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid Contents Source Code ScalarGridInterp_1D_cpu Source Code SUBROUTINE ScalarGridInterp_1D_cpu ( myPoly , f , fInterp , nVariables , nElements ) !! Host (CPU) implementation of the ScalarGridInterp_1D interface. !! In most cases, you should use the `ScalarGridInterp_1D` generic interface, !! rather than calling this routine directly. !! Interpolate a scalar-1D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,ivar,iel} = \\sum_{i=0}&#94;N f_{i,ivar,iel} I_{i,m}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) !! (Input) Array of function values, defined on the control grid REAL ( prec ), INTENT ( out ) :: fInterp ( 0 : myPoly % M , 1 : nVariables , 1 : nElements ) !! (Output) Array of function values, defined on the target grid ! Local INTEGER :: iVar , iEl , i , ii DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % M fInterp ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N fInterp ( i , iVar , iEl ) = fInterp ( i , iVar , iEl ) + myPoly % iMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_1D_cpu","tags":"","loc":"proc/scalargridinterp_1d_cpu.html"},{"title":"ScalarGridInterp_1D_gpu – SELF","text":"public subroutine ScalarGridInterp_1D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_1D_gpu_wrapper\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Interpolation is applied using a series of matrix-vector multiplications, using\nthe Lagrange class's interpolation matrix Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid Contents Source Code ScalarGridInterp_1D_gpu Source Code SUBROUTINE ScalarGridInterp_1D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) !! Device (GPU) implementation of the ScalarGridInterp_1D interface. !! In most cases, you should use the `ScalarGridInterp_1D` generic interface, !! rather than calling this routine directly. !! This routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_1D_gpu_wrapper !! Interpolate a scalar-1D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,ivar,iel} = \\sum_{i=0}&#94;N f_{i,ivar,iel} I_{i,m}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid TYPE ( c_ptr ), INTENT ( in ) :: f_dev !! (Input) Array of function values, defined on the control grid TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev !! (Output) Array of function values, defined on the target grid CALL ScalarGridInterp_1D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE ScalarGridInterp_1D_gpu","tags":"","loc":"proc/scalargridinterp_1d_gpu.html"},{"title":"ScalarGridInterp_2D_cpu – SELF","text":"public subroutine ScalarGridInterp_2D_cpu(myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Interpolation is applied using a series of matrix-vector multiplications, using\nthe Lagrange class's interpolation matrix Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid Contents Source Code ScalarGridInterp_2D_cpu Source Code SUBROUTINE ScalarGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) !! Host (CPU) implementation of the ScalarGridInterp_2D interface. !! In most cases, you should use the `ScalarGridInterp_2D` generic interface, !! rather than calling this routine directly. !! Interpolate a scalar-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) !! (Input) Array of function values, defined on the control grid REAL ( prec ), INTENT ( out ) :: fNew ( 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) !! (Output) Array of function values, defined on the target grid ! Local INTEGER :: i , j , ii , jj , iEl , iVar REAL ( prec ) :: fi , fij DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fij = 0.0_prec DO jj = 0 , myPoly % N fi = 0.0_prec DO ii = 0 , myPoly % N fi = fi + f ( ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij = fij + fi * myPoly % iMatrix % hostData ( jj , j ) END DO fNew ( i , j , iVar , iEl ) = fij END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_2D_cpu","tags":"","loc":"proc/scalargridinterp_2d_cpu.html"},{"title":"ScalarGridInterp_2D_gpu – SELF","text":"public subroutine ScalarGridInterp_2D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_2D_gpu_wrapper\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Interpolation is applied using a series of matrix-vector multiplications, using\nthe Lagrange class's interpolation matrix Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid Contents Source Code ScalarGridInterp_2D_gpu Source Code SUBROUTINE ScalarGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) !! Device (GPU) implementation of the ScalarGridInterp_2D interface. !! In most cases, you should use the `ScalarGridInterp_2D` generic interface, !! rather than calling this routine directly. !! This routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_2D_gpu_wrapper !! Interpolate a scalar-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid TYPE ( c_ptr ), INTENT ( in ) :: f_dev !! (Input) Array of function values, defined on the control grid TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev !! (Output) Array of function values, defined on the target grid CALL ScalarGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE ScalarGridInterp_2D_gpu","tags":"","loc":"proc/scalargridinterp_2d_gpu.html"},{"title":"ScalarGridInterp_3D_cpu – SELF","text":"public subroutine ScalarGridInterp_3D_cpu(myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarGridInterp_3D_cpu Source Code SUBROUTINE ScalarGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi , fij , fijk DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fijk = 0.0_prec DO kk = 0 , myPoly % N fij = 0.0_prec DO jj = 0 , myPoly % N fi = 0.0_prec DO ii = 0 , myPoly % N fi = fi + f ( ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij = fij + fi * myPoly % iMatrix % hostData ( jj , j ) END DO fijk = fijk + fij * myPoly % iMatrix % hostData ( kk , k ) END DO fInterp ( i , j , k , iVar , iEl ) = fijk END DO END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_3D_cpu","tags":"","loc":"proc/scalargridinterp_3d_cpu.html"},{"title":"ScalarGridInterp_3D_gpu – SELF","text":"public subroutine ScalarGridInterp_3D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarGridInterp_3D_gpu Source Code SUBROUTINE ScalarGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev CALL ScalarGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE ScalarGridInterp_3D_gpu","tags":"","loc":"proc/scalargridinterp_3d_gpu.html"},{"title":"TensorBoundaryInterp_2D_cpu – SELF","text":"public subroutine TensorBoundaryInterp_2D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorBoundaryInterp_2D_cpu Source Code SUBROUTINE TensorBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , ii , idir , jdir , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 , 1 : 2 , 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 2 , 1 : 2 , 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N DO jdir = 1 , 2 DO idir = 1 , 2 fb ( idir , jdir , 1 ) = fb ( idir , jdir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , ii , iVar , iEl ) ! South fb ( idir , jdir , 2 ) = fb ( idir , jdir , 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , ii , i , iVar , iEl ) ! East fb ( idir , jdir , 3 ) = fb ( idir , jdir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , ii , iVar , iEl ) ! North fb ( idir , jdir , 4 ) = fb ( idir , jdir , 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , ii , i , iVar , iEl ) ! West END DO END DO END DO DO jdir = 1 , 2 DO idir = 1 , 2 fBound ( idir , jdir , i , iVar , 1 : 4 , iEl ) = fb ( idir , jdir , 1 : 4 ) END DO END DO END DO END DO END DO END SUBROUTINE TensorBoundaryInterp_2D_cpu","tags":"","loc":"proc/tensorboundaryinterp_2d_cpu.html"},{"title":"TensorBoundaryInterp_2D_gpu – SELF","text":"public subroutine TensorBoundaryInterp_2D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorBoundaryInterp_2D_gpu Source Code SUBROUTINE TensorBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL TensorBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE TensorBoundaryInterp_2D_gpu","tags":"","loc":"proc/tensorboundaryinterp_2d_gpu.html"},{"title":"TensorBoundaryInterp_3D_cpu – SELF","text":"public subroutine TensorBoundaryInterp_3D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorBoundaryInterp_3D_cpu Source Code SUBROUTINE TensorBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , jdir , iVar , iEl REAL ( prec ) :: fb ( 1 : 3 , 1 : 3 , 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 3 , 1 : 3 , 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N DO jdir = 1 , 3 DO idir = 1 , 3 fb ( idir , jdir , 1 ) = fb ( idir , jdir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , j , ii , iVar , iEl ) ! Bottom fb ( idir , jdir , 2 ) = fb ( idir , jdir , 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , ii , j , iVar , iEl ) ! South fb ( idir , jdir , 3 ) = fb ( idir , jdir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , ii , i , j , iVar , iEl ) ! East fb ( idir , jdir , 4 ) = fb ( idir , jdir , 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , ii , j , iVar , iEl ) ! North fb ( idir , jdir , 5 ) = fb ( idir , jdir , 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , ii , i , j , iVar , iEl ) ! West fb ( idir , jdir , 6 ) = fb ( idir , jdir , 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , j , ii , iVar , iEl ) ! Top END DO END DO END DO DO jdir = 1 , 3 DO idir = 1 , 3 fBound ( idir , jdir , i , j , iVar , 1 : 6 , iEl ) = fb ( idir , jdir , 1 : 6 ) END DO END DO END DO END DO END DO END DO END SUBROUTINE TensorBoundaryInterp_3D_cpu","tags":"","loc":"proc/tensorboundaryinterp_3d_cpu.html"},{"title":"TensorBoundaryInterp_3D_gpu – SELF","text":"public subroutine TensorBoundaryInterp_3D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorBoundaryInterp_3D_gpu Source Code SUBROUTINE TensorBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL TensorBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE TensorBoundaryInterp_3D_gpu","tags":"","loc":"proc/tensorboundaryinterp_3d_gpu.html"},{"title":"UpdateDevice_Lagrange – SELF","text":"public subroutine UpdateDevice_Lagrange(myPoly) Copy the Lagrange attributes from the host (CPU) to the device (GPU) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance Contents Source Code UpdateDevice_Lagrange Source Code SUBROUTINE UpdateDevice_Lagrange ( myPoly ) !! Copy the Lagrange attributes from the host (CPU) to the device (GPU) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly !! Lagrange class instance CALL myPoly % controlPoints % UpdateDevice () CALL myPoly % targetPoints % UpdateDevice () CALL myPoly % bWeights % UpdateDevice () CALL myPoly % qWeights % UpdateDevice () CALL myPoly % iMatrix % UpdateDevice () CALL myPoly % dMatrix % UpdateDevice () CALL myPoly % dgMatrix % UpdateDevice () CALL myPoly % bMatrix % UpdateDevice () END SUBROUTINE UpdateDevice_Lagrange","tags":"","loc":"proc/updatedevice_lagrange.html"},{"title":"UpdateHost_Lagrange – SELF","text":"public subroutine UpdateHost_Lagrange(myPoly) Copy the Lagrange attributes from the device (GPU) to the host (CPU) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance Contents Source Code UpdateHost_Lagrange Source Code SUBROUTINE UpdateHost_Lagrange ( myPoly ) !! Copy the Lagrange attributes from the device (GPU) to the host (CPU) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly !! Lagrange class instance CALL myPoly % controlPoints % UpdateHost () CALL myPoly % targetPoints % UpdateHost () CALL myPoly % bWeights % UpdateHost () CALL myPoly % qWeights % UpdateHost () CALL myPoly % iMatrix % UpdateHost () CALL myPoly % dMatrix % UpdateHost () CALL myPoly % dgMatrix % UpdateHost () CALL myPoly % bMatrix % UpdateHost () END SUBROUTINE UpdateHost_Lagrange","tags":"","loc":"proc/updatehost_lagrange.html"},{"title":"VectorBoundaryInterp_2D_cpu – SELF","text":"public subroutine VectorBoundaryInterp_2D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorBoundaryInterp_2D_cpu Source Code SUBROUTINE VectorBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , ii , idir , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 , 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 2 , 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N DO idir = 1 , 2 fb ( idir , 1 ) = fb ( idir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , ii , iVar , iEl ) ! South fb ( idir , 2 ) = fb ( idir , 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , ii , i , iVar , iEl ) ! East fb ( idir , 3 ) = fb ( idir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , ii , iVar , iEl ) ! North fb ( idir , 4 ) = fb ( idir , 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , ii , i , iVar , iEl ) ! West END DO END DO DO idir = 1 , 2 fBound ( idir , i , iVar , 1 : 4 , iEl ) = fb ( idir , 1 : 4 ) END DO END DO END DO END DO END SUBROUTINE VectorBoundaryInterp_2D_cpu","tags":"","loc":"proc/vectorboundaryinterp_2d_cpu.html"},{"title":"VectorBoundaryInterp_2D_gpu – SELF","text":"public subroutine VectorBoundaryInterp_2D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorBoundaryInterp_2D_gpu Source Code SUBROUTINE VectorBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL VectorBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE VectorBoundaryInterp_2D_gpu","tags":"","loc":"proc/vectorboundaryinterp_2d_gpu.html"},{"title":"VectorBoundaryInterp_3D_cpu – SELF","text":"public subroutine VectorBoundaryInterp_3D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorBoundaryInterp_3D_cpu Source Code SUBROUTINE VectorBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , iVar , iEl REAL ( prec ) :: fb ( 1 : 3 , 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 3 , 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N DO idir = 1 , 3 fb ( idir , 1 ) = fb ( idir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , j , ii , iVar , iEl ) ! Bottom fb ( idir , 2 ) = fb ( idir , 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , ii , j , iVar , iEl ) ! South fb ( idir , 3 ) = fb ( idir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , ii , i , j , iVar , iEl ) ! East fb ( idir , 4 ) = fb ( idir , 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , ii , j , iVar , iEl ) ! North fb ( idir , 5 ) = fb ( idir , 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , ii , i , j , iVar , iEl ) ! West fb ( idir , 6 ) = fb ( idir , 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , j , ii , iVar , iEl ) ! Top END DO END DO DO idir = 1 , 3 fBound ( idir , i , j , iVar , 1 : 6 , iEl ) = fb ( idir , 1 : 6 ) END DO END DO END DO END DO END DO END SUBROUTINE VectorBoundaryInterp_3D_cpu","tags":"","loc":"proc/vectorboundaryinterp_3d_cpu.html"},{"title":"VectorBoundaryInterp_3D_gpu – SELF","text":"public subroutine VectorBoundaryInterp_3D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorBoundaryInterp_3D_gpu Source Code SUBROUTINE VectorBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL VectorBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE VectorBoundaryInterp_3D_gpu","tags":"","loc":"proc/vectorboundaryinterp_3d_gpu.html"},{"title":"VectorDGDivergence_2D_cpu – SELF","text":"public subroutine VectorDGDivergence_2D_cpu(myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDGDivergence_2D_cpu Source Code SUBROUTINE VectorDGDivergence_2D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Assumes bF is the vector component in the direction normal to the boundary IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bF ( 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local REAL ( prec ) :: dfLoc INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dfLoc = 0.0_prec DO ii = 0 , myPoly % N dfLoc = dfLoc + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO dfLoc = dfLoc + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bF ( j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bF ( i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) dF ( i , j , iVar , iEl ) = dFLoc END DO END DO END DO END DO END SUBROUTINE VectorDGDivergence_2D_cpu","tags":"","loc":"proc/vectordgdivergence_2d_cpu.html"},{"title":"VectorDGDivergence_2D_gpu – SELF","text":"public subroutine VectorDGDivergence_2D_gpu(myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDGDivergence_2D_gpu Source Code SUBROUTINE VectorDGDivergence_2D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDGDivergence_2D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDGDivergence_2D_gpu","tags":"","loc":"proc/vectordgdivergence_2d_gpu.html"},{"title":"VectorDGDivergence_3D_cpu – SELF","text":"public subroutine VectorDGDivergence_3D_cpu(myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDGDivergence_3D_cpu Source Code SUBROUTINE VectorDGDivergence_3D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Assumes bF is the vector component in the direction normal to the element boundaries IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) END DO END DO END DO END DO END DO END SUBROUTINE VectorDGDivergence_3D_cpu","tags":"","loc":"proc/vectordgdivergence_3d_cpu.html"},{"title":"VectorDGDivergence_3D_gpu – SELF","text":"public subroutine VectorDGDivergence_3D_gpu(myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDGDivergence_3D_gpu Source Code SUBROUTINE VectorDGDivergence_3D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDGDivergence_3D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDGDivergence_3D_gpu","tags":"","loc":"proc/vectordgdivergence_3d_gpu.html"},{"title":"VectorDivergence_2D_cpu – SELF","text":"public subroutine VectorDivergence_2D_cpu(myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDivergence_2D_cpu Source Code SUBROUTINE VectorDivergence_2D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE VectorDivergence_2D_cpu","tags":"","loc":"proc/vectordivergence_2d_cpu.html"},{"title":"VectorDivergence_2D_gpu – SELF","text":"public subroutine VectorDivergence_2D_gpu(myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDivergence_2D_gpu Source Code SUBROUTINE VectorDivergence_2D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDivergence_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDivergence_2D_gpu","tags":"","loc":"proc/vectordivergence_2d_gpu.html"},{"title":"VectorDivergence_3D_cpu – SELF","text":"public subroutine VectorDivergence_3D_cpu(myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDivergence_3D_cpu Source Code SUBROUTINE VectorDivergence_3D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorDivergence_3D_cpu","tags":"","loc":"proc/vectordivergence_3d_cpu.html"},{"title":"VectorDivergence_3D_gpu – SELF","text":"public subroutine VectorDivergence_3D_gpu(myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDivergence_3D_gpu Source Code SUBROUTINE VectorDivergence_3D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDivergence_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDivergence_3D_gpu","tags":"","loc":"proc/vectordivergence_3d_gpu.html"},{"title":"VectorGradient_2D_cpu – SELF","text":"public subroutine VectorGradient_2D_cpu(myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorGradient_2D_cpu Source Code SUBROUTINE VectorGradient_2D_cpu ( myPoly , f , gradF , nVariables , nElements ) ! ! Input : Vector(1:2,...) ! Output : Tensor(1:2,1:2,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: gf ( 1 : 2 , 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gf ( 1 , 1 ) = 0.0_prec gf ( 2 , 1 ) = 0.0_prec gf ( 1 , 2 ) = 0.0_prec gf ( 2 , 2 ) = 0.0_prec DO ii = 0 , myPoly % N gf ( 1 , 1 ) = gf ( 1 , 1 ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) gf ( 2 , 1 ) = gf ( 2 , 1 ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , iVar , iEl ) gf ( 1 , 2 ) = gf ( 1 , 2 ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , iVar , iEl ) gf ( 2 , 2 ) = gf ( 2 , 2 ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO gradF ( 1 : 2 , 1 : 2 , i , j , iVar , iEl ) = gf ( 1 : 2 , 1 : 2 ) END DO END DO END DO END DO END SUBROUTINE VectorGradient_2D_cpu","tags":"","loc":"proc/vectorgradient_2d_cpu.html"},{"title":"VectorGradient_2D_gpu – SELF","text":"public subroutine VectorGradient_2D_gpu(myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorGradient_2D_gpu Source Code SUBROUTINE VectorGradient_2D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL VectorGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorGradient_2D_gpu","tags":"","loc":"proc/vectorgradient_2d_gpu.html"},{"title":"VectorGradient_3D_cpu – SELF","text":"public subroutine VectorGradient_3D_cpu(myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorGradient_3D_cpu Source Code SUBROUTINE VectorGradient_3D_cpu ( myPoly , f , gradF , nVariables , nElements ) ! ! Input : Vector(1:3,...) ! Output : Tensor(1:3,1:3,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(3,1) = d/ds1( Vector(3,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) !          > Tensor(3,2) = d/ds2( Vector(3,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl REAL ( prec ) :: gF ( 1 : 3 , 1 : 3 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N gF = 0.0_prec DO ii = 0 , myPoly % N gF ( 1 , 1 ) = gF ( 1 , 1 ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) gF ( 2 , 1 ) = gF ( 2 , 1 ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , k , iVar , iEl ) gF ( 3 , 1 ) = gF ( 3 , 1 ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 3 , ii , j , k , iVar , iEl ) gF ( 1 , 2 ) = gF ( 1 , 2 ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , k , iVar , iEl ) gF ( 2 , 2 ) = gF ( 2 , 2 ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) gF ( 3 , 2 ) = gF ( 3 , 2 ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 3 , i , ii , k , iVar , iEl ) gF ( 1 , 3 ) = gF ( 1 , 3 ) + myPoly % dMatrix % hostData ( ii , k ) * f ( 1 , i , j , ii , iVar , iEl ) gF ( 2 , 3 ) = gF ( 2 , 3 ) + myPoly % dMatrix % hostData ( ii , k ) * f ( 2 , i , j , ii , iVar , iEl ) gF ( 3 , 3 ) = gF ( 3 , 3 ) + myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO gradF ( 1 , 1 , i , j , k , iVar , iEl ) = gF ( 1 , 1 ) gradF ( 2 , 1 , i , j , k , iVar , iEl ) = gF ( 2 , 1 ) gradF ( 3 , 1 , i , j , k , iVar , iEl ) = gF ( 3 , 1 ) gradF ( 1 , 2 , i , j , k , iVar , iEl ) = gF ( 1 , 2 ) gradF ( 2 , 2 , i , j , k , iVar , iEl ) = gF ( 2 , 2 ) gradF ( 3 , 2 , i , j , k , iVar , iEl ) = gF ( 3 , 2 ) gradF ( 1 , 3 , i , j , k , iVar , iEl ) = gF ( 1 , 3 ) gradF ( 2 , 3 , i , j , k , iVar , iEl ) = gF ( 2 , 3 ) gradF ( 3 , 3 , i , j , k , iVar , iEl ) = gF ( 3 , 3 ) END DO END DO END DO END DO END DO END SUBROUTINE VectorGradient_3D_cpu","tags":"","loc":"proc/vectorgradient_3d_cpu.html"},{"title":"VectorGradient_3D_gpu – SELF","text":"public subroutine VectorGradient_3D_gpu(myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorGradient_3D_gpu Source Code SUBROUTINE VectorGradient_3D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL VectorGradient_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorGradient_3D_gpu","tags":"","loc":"proc/vectorgradient_3d_gpu.html"},{"title":"VectorGridInterp_2D_cpu – SELF","text":"public subroutine VectorGridInterp_2D_cpu(myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Interpolation is applied using a series of matrix-vector multiplications, using\nthe Lagrange class's interpolation matrix Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid Contents Source Code VectorGridInterp_2D_cpu Source Code SUBROUTINE VectorGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) !! Host (CPU) implementation of the VectorGridInterp_2D interface. !! In most cases, you should use the `VectorGridInterp_2D` generic interface, !! rather than calling this routine directly. !! Interpolate a vector-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{dir,m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{dir,i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) !! (Input) Array of function values, defined on the control grid REAL ( prec ), INTENT ( out ) :: fNew ( 1 : 2 , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) !! (Output) Array of function values, defined on the target grid ! Local INTEGER :: i , j , ii , jj , iEl , iVar REAL ( prec ) :: fi ( 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fNew ( 1 , i , j , iVar , iEl ) = 0.0_prec fNew ( 2 , i , j , iVar , iEl ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 2 ) = fi ( 1 : 2 ) + f ( 1 : 2 , ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fNew ( 1 : 2 , i , j , iVar , iEl ) = fNew ( 1 : 2 , i , j , iVar , iEl ) + fi ( 1 : 2 ) * myPoly % iMatrix % hostData ( jj , j ) END DO END DO END DO END DO END DO END SUBROUTINE VectorGridInterp_2D_cpu","tags":"","loc":"proc/vectorgridinterp_2d_cpu.html"},{"title":"VectorGridInterp_2D_gpu – SELF","text":"public subroutine VectorGridInterp_2D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:VectorGridInterp_2D_gpu_wrapper\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Interpolation is applied using a series of matrix-vector multiplications, using\nthe Lagrange class's interpolation matrix Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid Contents Source Code VectorGridInterp_2D_gpu Source Code SUBROUTINE VectorGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) !! Device (GPU) implementation of the VectorGridInterp_2D interface. !! In most cases, you should use the `VectorGridInterp_2D` generic interface, !! rather than calling this routine directly. !! This routine calls hip/SELF_Lagrange.cpp:VectorGridInterp_2D_gpu_wrapper !! Interpolate a vector-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{dir,m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{dir,i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid TYPE ( c_ptr ), INTENT ( in ) :: f_dev !! (Input) Array of function values, defined on the control grid TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev !! (Output) Array of function values, defined on the target grid CALL VectorGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE VectorGridInterp_2D_gpu","tags":"","loc":"proc/vectorgridinterp_2d_gpu.html"},{"title":"VectorGridInterp_3D_cpu – SELF","text":"public subroutine VectorGridInterp_3D_cpu(myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorGridInterp_3D_cpu Source Code SUBROUTINE VectorGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 1 : 3 , 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi ( 1 : 3 ), fij ( 1 : 3 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fInterp ( 1 : 3 , i , j , k , iVar , iEl ) = 0.0_prec DO kk = 0 , myPoly % N fij ( 1 : 3 ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 3 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 3 ) = fi ( 1 : 3 ) + f ( 1 : 3 , ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij ( 1 : 3 ) = fij ( 1 : 3 ) + fi ( 1 : 3 ) * myPoly % iMatrix % hostData ( jj , j ) END DO fInterp ( 1 : 3 , i , j , k , iVar , iEl ) = fInterp ( 1 : 3 , i , j , k , iVar , iEl ) + fij ( 1 : 3 ) * myPoly % iMatrix % hostData ( kk , k ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorGridInterp_3D_cpu","tags":"","loc":"proc/vectorgridinterp_3d_cpu.html"},{"title":"VectorGridInterp_3D_gpu – SELF","text":"public subroutine VectorGridInterp_3D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorGridInterp_3D_gpu Source Code SUBROUTINE VectorGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev CALL VectorGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE VectorGridInterp_3D_gpu","tags":"","loc":"proc/vectorgridinterp_3d_gpu.html"},{"title":"WriteHDF5_Lagrange – SELF","text":"public subroutine WriteHDF5_Lagrange(this, fileId) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId Contents Source Code WriteHDF5_Lagrange Source Code SUBROUTINE WriteHDF5_Lagrange ( this , fileId ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: this INTEGER ( HID_T ), INTENT ( in ) :: fileId CALL CreateGroup_HDF5 ( fileId , '/interp' ) CALL WriteArray_HDF5 ( fileId , '/interp/controlpoints' , & this % controlPoints ) CALL WriteArray_HDF5 ( fileId , '/interp/qweights' , & this % qWeights ) CALL WriteArray_HDF5 ( fileId , '/interp/dgmatrix' , & this % dgMatrix ) CALL WriteArray_HDF5 ( fileId , '/interp/dmatrix' , & this % dMatrix ) CALL WriteArray_HDF5 ( fileId , '/interp/bmatrix' , & this % bMatrix ) CALL WriteArray_HDF5 ( fileId , '/interp/imatrix' , & this % iMatrix ) END SUBROUTINE WriteHDF5_Lagrange","tags":"","loc":"proc/writehdf5_lagrange.html"},{"title":"DGDerivative_1D_gpu_wrapper – SELF","text":"interface public subroutine DGDerivative_1D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/dgderivative_1d_gpu_wrapper.html"},{"title":"Derivative_1D_gpu_wrapper – SELF","text":"interface public subroutine Derivative_1D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/derivative_1d_gpu_wrapper.html"},{"title":"ScalarBoundaryInterp_1D_gpu_wrapper – SELF","text":"interface public subroutine ScalarBoundaryInterp_1D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalarboundaryinterp_1d_gpu_wrapper.html"},{"title":"ScalarBoundaryInterp_2D_gpu_wrapper – SELF","text":"interface public subroutine ScalarBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalarboundaryinterp_2d_gpu_wrapper.html"},{"title":"ScalarBoundaryInterp_3D_gpu_wrapper – SELF","text":"interface public subroutine ScalarBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalarboundaryinterp_3d_gpu_wrapper.html"},{"title":"ScalarGradient_2D_gpu_wrapper – SELF","text":"interface public subroutine ScalarGradient_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalargradient_2d_gpu_wrapper.html"},{"title":"ScalarGradient_3D_gpu_wrapper – SELF","text":"interface public subroutine ScalarGradient_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalargradient_3d_gpu_wrapper.html"},{"title":"ScalarGridInterp_1D_gpu_wrapper – SELF","text":"interface public subroutine ScalarGridInterp_1D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalargridinterp_1d_gpu_wrapper.html"},{"title":"ScalarGridInterp_2D_gpu_wrapper – SELF","text":"interface public subroutine ScalarGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalargridinterp_2d_gpu_wrapper.html"},{"title":"ScalarGridInterp_3D_gpu_wrapper – SELF","text":"interface public subroutine ScalarGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalargridinterp_3d_gpu_wrapper.html"},{"title":"TensorBoundaryInterp_2D_gpu_wrapper – SELF","text":"interface public subroutine TensorBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/tensorboundaryinterp_2d_gpu_wrapper.html"},{"title":"TensorBoundaryInterp_3D_gpu_wrapper – SELF","text":"interface public subroutine TensorBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/tensorboundaryinterp_3d_gpu_wrapper.html"},{"title":"VectorBoundaryInterp_2D_gpu_wrapper – SELF","text":"interface public subroutine VectorBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectorboundaryinterp_2d_gpu_wrapper.html"},{"title":"VectorBoundaryInterp_3D_gpu_wrapper – SELF","text":"interface public subroutine VectorBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectorboundaryinterp_3d_gpu_wrapper.html"},{"title":"VectorDGDivergence_2D_gpu_wrapper – SELF","text":"interface public subroutine VectorDGDivergence_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectordgdivergence_2d_gpu_wrapper.html"},{"title":"VectorDGDivergence_3D_gpu_wrapper – SELF","text":"interface public subroutine VectorDGDivergence_3D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectordgdivergence_3d_gpu_wrapper.html"},{"title":"VectorDGGradient_2D_gpu_wrapper – SELF","text":"interface public subroutine VectorDGGradient_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectordggradient_2d_gpu_wrapper.html"},{"title":"VectorDivergence_2D_gpu_wrapper – SELF","text":"interface public subroutine VectorDivergence_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectordivergence_2d_gpu_wrapper.html"},{"title":"VectorDivergence_3D_gpu_wrapper – SELF","text":"interface public subroutine VectorDivergence_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectordivergence_3d_gpu_wrapper.html"},{"title":"VectorGradient_2D_gpu_wrapper – SELF","text":"interface public subroutine VectorGradient_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectorgradient_2d_gpu_wrapper.html"},{"title":"VectorGradient_3D_gpu_wrapper – SELF","text":"interface public subroutine VectorGradient_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectorgradient_3d_gpu_wrapper.html"},{"title":"VectorGridInterp_2D_gpu_wrapper – SELF","text":"interface public subroutine VectorGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectorgridinterp_2d_gpu_wrapper.html"},{"title":"VectorGridInterp_3D_gpu_wrapper – SELF","text":"interface public subroutine VectorGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectorgridinterp_3d_gpu_wrapper.html"},{"title":"GetBCFlagForChar – SELF","text":"public function GetBCFlagForChar(charFlag) result(intFlag) This method is used to return the integer flag from a char for boundary conditions Arguments Type Intent Optional Attributes Name character, intent(in) :: charFlag Return Value integer Contents Source Code GetBCFlagForChar Source Code FUNCTION GetBCFlagForChar ( charFlag ) RESULT ( intFlag ) !! This method is used to return the integer flag from a char for boundary conditions !! IMPLICIT NONE CHARACTER ( * ), INTENT ( in ) :: charFlag INTEGER :: intFlag SELECT CASE ( UpperCase ( TRIM ( charFlag )) ) CASE ( \"PRESCRIBED\" ) intFlag = SELF_BC_PRESCRIBED CASE ( \"RADIATION\" ) intFlag = SELF_BC_RADIATION CASE ( \"NO_NORMAL_FLOW\" ) intFlag = SELF_BC_NONORMALFLOW CASE ( \"PRESCRIBED_STRESS\" ) intFlag = SELF_BC_PRESCRIBED_STRESS CASE ( \"NO_STRESS\" ) intFlag = SELF_BC_NOSTRESS CASE DEFAULT intFlag = 0 END SELECT END FUNCTION GetBCFlagForChar","tags":"","loc":"proc/getbcflagforchar.html"},{"title":"AdamsBashforth2_timeIntegrator – SELF","text":"public subroutine AdamsBashforth2_timeIntegrator(this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn Contents Source Code AdamsBashforth2_timeIntegrator Source Code SUBROUTINE AdamsBashforth2_timeIntegrator ( this , tn ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: tn ! Local INTEGER :: m REAL ( prec ) :: tRemain REAL ( prec ) :: dtLim REAL ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute t0 = this % t ! Do a single step with RK2 ! Initialize the PrevSol attribute CALL this % UpdateGAB2 ( 0 ) CALL this % LowStorageRK2_timeIntegrator ( t0 + this % dt ) DO WHILE ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = MIN ( dtLim , tRemain ) CALL this % UpdateGAB2 ( 2 ) ! Store the solution in PrevSol and store the interpolated ! solution in the solution attribute for tendency calculation CALL this % CalculateTendency () CALL this % UpdateGAB2 ( 1 ) ! Reset the solution from the PrevSol CALL this % UpdateSolution () this % t = t0 + this % dt END DO this % dt = dtLim END SUBROUTINE AdamsBashforth2_timeIntegrator","tags":"","loc":"proc/adamsbashforth2_timeintegrator.html"},{"title":"AdamsBashforth3_timeIntegrator – SELF","text":"public subroutine AdamsBashforth3_timeIntegrator(this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn Contents Source Code AdamsBashforth3_timeIntegrator Source Code SUBROUTINE AdamsBashforth3_timeIntegrator ( this , tn ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: tn ! Local INTEGER :: m REAL ( prec ) :: tRemain REAL ( prec ) :: dtLim REAL ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute ! Do two time steps with RK3 ! Initialize the PrevSol attribute t0 = this % t CALL this % UpdateGAB3 ( 0 ) CALL this % LowStorageRK3_timeIntegrator ( t0 + this % dt ) t0 = this % t CALL this % UpdateGAB3 ( 1 ) CALL this % LowStorageRK3_timeIntegrator ( t0 + this % dt ) DO WHILE ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = MIN ( dtLim , tRemain ) CALL this % UpdateGAB3 ( 3 ) ! Store the solution in PrevSol and store the interpolated ! solution in the solution attribute for tendency calculation CALL this % CalculateTendency () CALL this % UpdateGAB3 ( 2 ) ! Reset the solution from the PrevSol CALL this % UpdateSolution () this % t = t0 + this % dt END DO this % dt = dtLim END SUBROUTINE AdamsBashforth3_timeIntegrator","tags":"","loc":"proc/adamsbashforth3_timeintegrator.html"},{"title":"AdamsBashforth4_timeIntegrator – SELF","text":"public subroutine AdamsBashforth4_timeIntegrator(this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn Contents Source Code AdamsBashforth4_timeIntegrator Source Code SUBROUTINE AdamsBashforth4_timeIntegrator ( this , tn ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: tn ! Local INTEGER :: m REAL ( prec ) :: tRemain REAL ( prec ) :: dtLim REAL ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute ! Do three time steps with RK4 ! Initialize the PrevSol attribute t0 = this % t CALL this % UpdateGAB4 ( 0 ) CALL this % LowStorageRK4_timeIntegrator ( t0 + this % dt ) t0 = this % t CALL this % UpdateGAB4 ( 1 ) CALL this % LowStorageRK4_timeIntegrator ( t0 + this % dt ) t0 = this % t CALL this % UpdateGAB4 ( 2 ) CALL this % LowStorageRK4_timeIntegrator ( t0 + this % dt ) DO WHILE ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = MIN ( dtLim , tRemain ) CALL this % UpdateGAB4 ( 4 ) ! Store the solution in PrevSol and store the interpolated ! solution in the solution attribute for tendency calculation CALL this % CalculateTendency () CALL this % UpdateGAB4 ( 3 ) ! Reset the solution from the PrevSol CALL this % UpdateSolution () this % t = t0 + this % dt END DO this % dt = dtLim END SUBROUTINE AdamsBashforth4_timeIntegrator","tags":"","loc":"proc/adamsbashforth4_timeintegrator.html"},{"title":"CalculateEntropy_Model – SELF","text":"public subroutine CalculateEntropy_Model(this) Base method for calculating entropy of a model\nWhen this method is not overridden, the entropy\nis simply set to 0.0. When you develop a model\nbuilt on top of this abstract class or one of its\nchildren, it is recommended that you define a\nconvex mathematical entropy function that is used\nas a measure of the model stability. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this Contents Source Code CalculateEntropy_Model Source Code SUBROUTINE CalculateEntropy_Model ( this ) !! Base method for calculating entropy of a model !! When this method is not overridden, the entropy !! is simply set to 0.0. When you develop a model !! built on top of this abstract class or one of its !! children, it is recommended that you define a !! convex mathematical entropy function that is used !! as a measure of the model stability. IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this this % entropy = 0.0_PREC END SUBROUTINE CalculateEntropy_Model","tags":"","loc":"proc/calculateentropy_model.html"},{"title":"DisableGPUAccel_Model – SELF","text":"public subroutine DisableGPUAccel_Model(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this Contents Source Code DisableGPUAccel_Model Source Code SUBROUTINE DisableGPUAccel_Model ( this ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this this % gpuAccel = . FALSE . END SUBROUTINE DisableGPUAccel_Model","tags":"","loc":"proc/disablegpuaccel_model.html"},{"title":"EnableGPUAccel_Model – SELF","text":"public subroutine EnableGPUAccel_Model(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this Contents Source Code EnableGPUAccel_Model Source Code SUBROUTINE EnableGPUAccel_Model ( this ) #undef __FUNC__ #define __FUNC__ \"EnableGPUAccel\" IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN this % gpuAccel = . TRUE . ELSE this % gpuAccel = . FALSE . WARNING ( \"GPU acceleration requested, but no GPU is available\" ) END IF END SUBROUTINE EnableGPUAccel_Model","tags":"","loc":"proc/enablegpuaccel_model.html"},{"title":"Euler_timeIntegrator – SELF","text":"public subroutine Euler_timeIntegrator(this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn Contents Source Code Euler_timeIntegrator Source Code SUBROUTINE Euler_timeIntegrator ( this , tn ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: tn ! Local REAL ( prec ) :: tRemain REAL ( prec ) :: dtLim dtLim = this % dt ! Get the max time step size from the dt attribute DO WHILE ( this % t < tn ) tRemain = tn - this % t this % dt = MIN ( dtLim , tRemain ) CALL this % CalculateTendency () CALL this % UpdateSolution () this % t = this % t + this % dt END DO this % dt = dtLim END SUBROUTINE Euler_timeIntegrator","tags":"","loc":"proc/euler_timeintegrator.html"},{"title":"Flux_Model – SELF","text":"public subroutine Flux_Model(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this Contents Source Code Flux_Model Source Code SUBROUTINE Flux_Model ( this ) !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this RETURN END SUBROUTINE Flux_Model","tags":"","loc":"proc/flux_model.html"},{"title":"ForwardStep_Model – SELF","text":"public subroutine ForwardStep_Model(this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator If the final time  is provided, the model is forward stepped to that final time,\n otherwise, the model is forward stepped only a single time step If a time step is provided through the interface, the model time step size is updated\n and that time step is used to update the model If ioInterval is provided, file IO will be conducted every ioInterval seconds until tn\nis reached Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: tn real(kind=prec), intent(in), optional :: dt real(kind=prec), intent(in), optional :: ioInterval Contents Source Code ForwardStep_Model Source Code SUBROUTINE ForwardStep_Model ( this , tn , dt , ioInterval ) !!  Forward steps the model using the associated tendency procedure and time integrator !! !!  If the final time  is provided, the model is forward stepped to that final time, !!  otherwise, the model is forward stepped only a single time step !! !!  If a time step is provided through the interface, the model time step size is updated !!  and that time step is used to update the model !! !! If ioInterval is provided, file IO will be conducted every ioInterval seconds until tn !! is reached IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), OPTIONAL , INTENT ( in ) :: tn REAL ( prec ), OPTIONAL , INTENT ( in ) :: dt REAL ( prec ), OPTIONAL , INTENT ( in ) :: ioInterval ! Local REAL ( prec ) :: targetTime , tNext INTEGER :: i , nIO IF ( PRESENT ( dt )) THEN this % dt = dt END IF IF ( PRESENT ( tn )) THEN targetTime = tn ELSE targetTime = this % t + this % dt END IF IF ( PRESENT ( ioInterval )) THEN nIO = INT (( targetTime - this % t ) / ioInterval ) DO i = 1 , nIO tNext = this % t + ioInterval CALL this % timeIntegrator ( tNext ) this % t = tNext CALL this % WriteModel () CALL this % IncrementIOCounter () CALL this % CalculateEntropy () CALL this % ReportEntropy () END DO ELSE CALL this % timeIntegrator ( targetTime ) this % t = targetTime CALL this % CalculateEntropy () CALL this % ReportEntropy () END IF END SUBROUTINE ForwardStep_Model","tags":"","loc":"proc/forwardstep_model.html"},{"title":"GetSimulationTime – SELF","text":"public subroutine GetSimulationTime(this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t Contents Source Code GetSimulationTime Source Code SUBROUTINE GetSimulationTime ( this , t ) !! Returns the current simulation time stored in the model % t attribute IMPLICIT NONE CLASS ( Model ), INTENT ( in ) :: this REAL ( prec ), INTENT ( out ) :: t t = this % t END SUBROUTINE GetSimulationTime","tags":"","loc":"proc/getsimulationtime.html"},{"title":"IncrementIOCounter – SELF","text":"public subroutine IncrementIOCounter(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this Contents Source Code IncrementIOCounter Source Code SUBROUTINE IncrementIOCounter ( this ) IMPLICIT NONE CLASS ( Model ), intent ( inout ) :: this ! Increment the ioIterate this % ioIterate = this % ioIterate + 1 END SUBROUTINE IncrementIOCounter","tags":"","loc":"proc/incrementiocounter.html"},{"title":"LowStorageRK2_timeIntegrator – SELF","text":"public subroutine LowStorageRK2_timeIntegrator(this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn Contents Source Code LowStorageRK2_timeIntegrator Source Code SUBROUTINE LowStorageRK2_timeIntegrator ( this , tn ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: tn ! Local INTEGER :: m REAL ( prec ) :: tRemain REAL ( prec ) :: dtLim REAL ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute DO WHILE ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = MIN ( dtLim , tRemain ) DO m = 1 , 2 CALL this % CalculateTendency () CALL this % UpdateGRK2 ( m ) this % t = t0 + rk2_b ( m ) * this % dt END DO this % t = t0 + this % dt END DO this % dt = dtLim END SUBROUTINE LowStorageRK2_timeIntegrator","tags":"","loc":"proc/lowstoragerk2_timeintegrator.html"},{"title":"LowStorageRK3_timeIntegrator – SELF","text":"public subroutine LowStorageRK3_timeIntegrator(this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn Contents Source Code LowStorageRK3_timeIntegrator Source Code SUBROUTINE LowStorageRK3_timeIntegrator ( this , tn ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: tn ! Local INTEGER :: m REAL ( prec ) :: tRemain REAL ( prec ) :: dtLim REAL ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute DO WHILE ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = MIN ( dtLim , tRemain ) DO m = 1 , 3 CALL this % CalculateTendency () CALL this % UpdateGRK3 ( m ) this % t = t0 + rk3_b ( m ) * this % dt END DO this % t = t0 + this % dt END DO this % dt = dtLim END SUBROUTINE LowStorageRK3_timeIntegrator","tags":"","loc":"proc/lowstoragerk3_timeintegrator.html"},{"title":"LowStorageRK4_timeIntegrator – SELF","text":"public subroutine LowStorageRK4_timeIntegrator(this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn Contents Source Code LowStorageRK4_timeIntegrator Source Code SUBROUTINE LowStorageRK4_timeIntegrator ( this , tn ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: tn ! Local INTEGER :: m REAL ( prec ) :: tRemain REAL ( prec ) :: dtLim REAL ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute DO WHILE ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = MIN ( dtLim , tRemain ) DO m = 1 , 5 CALL this % CalculateTendency () CALL this % UpdateGRK4 ( m ) this % t = t0 + rk4_b ( m ) * this % dt END DO this % t = t0 + this % dt END DO this % dt = dtLim END SUBROUTINE LowStorageRK4_timeIntegrator","tags":"","loc":"proc/lowstoragerk4_timeintegrator.html"},{"title":"PreFlux_Model – SELF","text":"public subroutine PreFlux_Model(this) PreFlux is a template routine that is used to house any additional calculations\nthat you want to execute just before the calculation of flux terms.\nThis default PreFlux simply returns back to the caller without executing any instructions The intention is to provide a method that can be overridden through type-extension, to handle\nany steps that need to be executed before proceeding with the usual tendency calculation methods. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this Contents Source Code PreFlux_Model Source Code SUBROUTINE PreFlux_Model ( this ) !! PreFlux is a template routine that is used to house any additional calculations !! that you want to execute just before the calculation of flux terms. !! This default PreFlux simply returns back to the caller without executing any instructions !! !! The intention is to provide a method that can be overridden through type-extension, to handle !! any steps that need to be executed before proceeding with the usual tendency calculation methods. !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this RETURN END SUBROUTINE PreFlux_Model","tags":"","loc":"proc/preflux_model.html"},{"title":"PreTendency_Model – SELF","text":"public subroutine PreTendency_Model(this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions The intention is to provide a method that can be overridden through type-extension, to handle\nany steps that need to be executed before proceeding with the usual tendency calculation methods. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this Contents Source Code PreTendency_Model Source Code SUBROUTINE PreTendency_Model ( this ) !! PreTendency is a template routine that is used to house any additional calculations !! that you want to execute at the beginning of the tendency calculation routine. !! This default PreTendency simply returns back to the caller without executing any instructions !! !! The intention is to provide a method that can be overridden through type-extension, to handle !! any steps that need to be executed before proceeding with the usual tendency calculation methods. !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this RETURN END SUBROUTINE PreTendency_Model","tags":"","loc":"proc/pretendency_model.html"},{"title":"PrintType_Model – SELF","text":"public subroutine PrintType_Model(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this Contents Source Code PrintType_Model Source Code SUBROUTINE PrintType_Model ( this ) #undef __FUNC__ #define __FUNC__ \"PrintType\" IMPLICIT NONE CLASS ( Model ), INTENT ( in ) :: this INFO ( \"None\" ) END SUBROUTINE PrintType_Model","tags":"","loc":"proc/printtype_model.html"},{"title":"ReportEntropy_Model – SELF","text":"public subroutine ReportEntropy_Model(this) Uses iso_fortran_env Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this Contents Source Code ReportEntropy_Model Source Code SUBROUTINE ReportEntropy_Model ( this ) #undef __FUNC__ #define __FUNC__ \"ReportEntropy\" !! Base method for reporting the entropy of a model !! to stdout. Only override this procedure if additional !! reporting is needed. Alternatively, if you think !! additional reporting would be valuable for all models, !! open a pull request with modifications to this base !! method. USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE CLASS ( Model ), INTENT ( in ) :: this ! Local INTEGER , PARAMETER :: ucs2 = SELECTED_CHAR_KIND ( 'ISO_10646' ) CHARACTER ( KIND = ucs2 , len = 20 ) :: modelTime CHARACTER ( KIND = ucs2 , len = 20 ) :: entropy CHARACTER ( KIND = ucs2 , len = :), ALLOCATABLE :: str IF ( this % decomp % rankId == 0 ) THEN ! Copy the time and entropy to a string WRITE ( modelTime , \"(ES16.7E3)\" ) this % t WRITE ( entropy , \"(ES16.7E3)\" ) this % entropy ! Write the output to STDOUT OPEN ( OUTPUT_UNIT , ENCODING = 'utf-8' ) WRITE ( OUTPUT_UNIT , '(\"INFO : [\",A,\"] : \")' , ADVANCE = 'no' ) __ FUNC__ str = ucs2_ 't\\u1D62 =' // TRIM ( modelTime ) WRITE ( OUTPUT_UNIT , '(A)' , ADVANCE = 'no' ) str str = ucs2_ '  |  e\\u1D62 =' // TRIM ( entropy ) WRITE ( OUTPUT_UNIT , '(A)' , ADVANCE = 'yes' ) str END IF END SUBROUTINE ReportEntropy_Model","tags":"","loc":"proc/reportentropy_model.html"},{"title":"RiemannSolver_Model – SELF","text":"public subroutine RiemannSolver_Model(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this Contents Source Code RiemannSolver_Model Source Code SUBROUTINE RiemannSolver_Model ( this ) !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this RETURN END SUBROUTINE RiemannSolver_Model","tags":"","loc":"proc/riemannsolver_model.html"},{"title":"SetBoundaryCondition_Model – SELF","text":"public subroutine SetBoundaryCondition_Model(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this Contents Source Code SetBoundaryCondition_Model Source Code SUBROUTINE SetBoundaryCondition_Model ( this ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this RETURN END SUBROUTINE SetBoundaryCondition_Model","tags":"","loc":"proc/setboundarycondition_model.html"},{"title":"SetInitialConditions_Model – SELF","text":"public subroutine SetInitialConditions_Model(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this Contents Source Code SetInitialConditions_Model Source Code SUBROUTINE SetInitialConditions_Model ( this ) #undef __FUNC__ #define __FUNC__ \"SetInitialConditions\" IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this INFO ( \"No model, so nothing to set\" ) END SUBROUTINE SetInitialConditions_Model","tags":"","loc":"proc/setinitialconditions_model.html"},{"title":"SetSimulationTime – SELF","text":"public subroutine SetSimulationTime(this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t Contents Source Code SetSimulationTime Source Code SUBROUTINE SetSimulationTime ( this , t ) !! Sets the model % t attribute with the provided simulation time IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: t this % t = t END SUBROUTINE SetSimulationTime","tags":"","loc":"proc/setsimulationtime.html"},{"title":"SetTimeIntegrator_withChar – SELF","text":"public subroutine SetTimeIntegrator_withChar(this, integrator) Sets the time integrator method, using a character input Valid options for integrator are \"euler\"\n  \"rk3\"\n  \"rk4\" Note that the character provided is not case-sensitive Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator Contents Source Code SetTimeIntegrator_withChar Source Code SUBROUTINE SetTimeIntegrator_withChar ( this , integrator ) !! Sets the time integrator method, using a character input !! !! Valid options for integrator are !! !!   \"euler\" !!   \"rk3\" !!   \"rk4\" !! !! Note that the character provided is not case-sensitive !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: integrator ! Local CHARACTER ( SELF_INTEGRATOR_LENGTH ) :: upperCaseInt upperCaseInt = UpperCase ( TRIM ( integrator )) SELECT CASE ( TRIM ( upperCaseInt )) CASE ( \"EULER\" ) this % timeIntegrator => Euler_timeIntegrator CASE ( \"AB2\" ) this % timeIntegrator => AdamsBashforth2_timeIntegrator CALL this % ResizePrevSol ( 2 ) CASE ( \"AB3\" ) this % timeIntegrator => AdamsBashforth3_timeIntegrator CALL this % ResizePrevSol ( 3 ) CASE ( \"AB4\" ) this % timeIntegrator => AdamsBashforth4_timeIntegrator CALL this % ResizePrevSol ( 4 ) CASE ( \"RK2\" ) this % timeIntegrator => LowStorageRK2_timeIntegrator CASE ( \"RK3\" ) this % timeIntegrator => LowStorageRK3_timeIntegrator CASE ( \"RK4\" ) this % timeIntegrator => LowStorageRK4_timeIntegrator CASE DEFAULT this % timeIntegrator => LowStorageRK3_timeIntegrator END SELECT END SUBROUTINE SetTimeIntegrator_withChar","tags":"","loc":"proc/settimeintegrator_withchar.html"},{"title":"SetTimeIntegrator_withInt – SELF","text":"public subroutine SetTimeIntegrator_withInt(this, integrator) Sets the time integrator method, using an integer flag Valid options for  are SELF_EULER\n   SELF_RK3\n   SELF_RK4 Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: integrator Contents Source Code SetTimeIntegrator_withInt Source Code SUBROUTINE SetTimeIntegrator_withInt ( this , integrator ) !! Sets the time integrator method, using an integer flag !! !! Valid options for  are !! !!    SELF_EULER !!    SELF_RK3 !!    SELF_RK4 !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: integrator SELECT CASE ( integrator ) CASE ( SELF_EULER ) this % timeIntegrator => Euler_timeIntegrator CASE ( SELF_AB2 ) this % timeIntegrator => AdamsBashforth2_timeIntegrator CALL this % ResizePrevSol ( 2 ) CASE ( SELF_AB3 ) this % timeIntegrator => AdamsBashforth3_timeIntegrator CALL this % ResizePrevSol ( 3 ) CASE ( SELF_AB4 ) this % timeIntegrator => AdamsBashforth4_timeIntegrator CALL this % ResizePrevSol ( 4 ) CASE ( SELF_RK2 ) this % timeIntegrator => LowStorageRK2_timeIntegrator CASE ( SELF_RK3 ) this % timeIntegrator => LowStorageRK3_timeIntegrator CASE ( SELF_RK4 ) this % timeIntegrator => LowStorageRK4_timeIntegrator CASE DEFAULT this % timeIntegrator => LowStorageRK3_timeIntegrator END SELECT END SUBROUTINE SetTimeIntegrator_withInt","tags":"","loc":"proc/settimeintegrator_withint.html"},{"title":"Source_Model – SELF","text":"public subroutine Source_Model(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this Contents Source Code Source_Model Source Code SUBROUTINE Source_Model ( this ) !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this RETURN END SUBROUTINE Source_Model","tags":"","loc":"proc/source_model.html"},{"title":"UpdateBoundary_Model – SELF","text":"public subroutine UpdateBoundary_Model(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this Contents Source Code UpdateBoundary_Model Source Code SUBROUTINE UpdateBoundary_Model ( this ) !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this RETURN END SUBROUTINE UpdateBoundary_Model","tags":"","loc":"proc/updateboundary_model.html"},{"title":"CalculateTendency – SELF","text":"interface public subroutine CalculateTendency(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this","tags":"","loc":"interface/calculatetendency.html"},{"title":"ReadModel – SELF","text":"interface public subroutine ReadModel(this, filename) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: filename","tags":"","loc":"interface/readmodel.html"},{"title":"ResizePrevSol – SELF","text":"interface public subroutine ResizePrevSol(this, m) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m","tags":"","loc":"interface/resizeprevsol.html"},{"title":"SELF_timeIntegrator – SELF","text":"interface public subroutine SELF_timeIntegrator(this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn","tags":"","loc":"interface/self_timeintegrator.html"},{"title":"UpdateGAB – SELF","text":"interface public subroutine UpdateGAB(this, m) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m","tags":"","loc":"interface/updategab.html"},{"title":"UpdateGRK – SELF","text":"interface public subroutine UpdateGRK(this, m) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m","tags":"","loc":"interface/updategrk.html"},{"title":"UpdateSolution – SELF","text":"interface public subroutine UpdateSolution(this, dt) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt","tags":"","loc":"interface/updatesolution.html"},{"title":"WriteModel – SELF","text":"interface public subroutine WriteModel(this, filename) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in), optional :: filename","tags":"","loc":"interface/writemodel.html"},{"title":"WriteTecplot – SELF","text":"interface public subroutine WriteTecplot(this, filename) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in), optional :: filename","tags":"","loc":"interface/writetecplot.html"},{"title":"GPUAvailable – SELF","text":"public function GPUAvailable() result(avail) Arguments None Return Value logical Contents Source Code GPUAvailable Source Code FUNCTION GPUAvailable () RESULT ( avail ) IMPLICIT NONE LOGICAL :: avail ! Local INTEGER ( C_INT ) :: gpuCount INTEGER ( KIND ( hipSuccess )) :: err err = hipGetDeviceCount ( gpuCount ) IF ( gpuCount > 0 . AND . err == hipSuccess ) THEN avail = . TRUE . ELSE avail = . FALSE . END IF END FUNCTION GPUAvailable","tags":"","loc":"proc/gpuavailable.html"},{"title":"Alloc_hfInt32_r1 – SELF","text":"public subroutine Alloc_hfInt32_r1(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound Contents Source Code Alloc_hfInt32_r1 Source Code SUBROUTINE Alloc_hfInt32_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) this % hostData = 0 IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r1","tags":"","loc":"proc/alloc_hfint32_r1.html"},{"title":"Alloc_hfInt32_r2 – SELF","text":"public subroutine Alloc_hfInt32_r2(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) Contents Source Code Alloc_hfInt32_r2 Source Code SUBROUTINE Alloc_hfInt32_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) this % hostData = 0 IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r2","tags":"","loc":"proc/alloc_hfint32_r2.html"},{"title":"Alloc_hfInt32_r3 – SELF","text":"public subroutine Alloc_hfInt32_r3(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) Contents Source Code Alloc_hfInt32_r3 Source Code SUBROUTINE Alloc_hfInt32_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) this % hostData = 0 IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r3","tags":"","loc":"proc/alloc_hfint32_r3.html"},{"title":"Alloc_hfInt32_r4 – SELF","text":"public subroutine Alloc_hfInt32_r4(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) Contents Source Code Alloc_hfInt32_r4 Source Code SUBROUTINE Alloc_hfInt32_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) this % hostData = 0 IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r4","tags":"","loc":"proc/alloc_hfint32_r4.html"},{"title":"Alloc_hfReal_r1 – SELF","text":"public subroutine Alloc_hfReal_r1(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound Contents Source Code Alloc_hfReal_r1 Source Code SUBROUTINE Alloc_hfReal_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) this % hostData = 0.0_prec IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r1","tags":"","loc":"proc/alloc_hfreal_r1.html"},{"title":"Alloc_hfReal_r2 – SELF","text":"public subroutine Alloc_hfReal_r2(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) Contents Source Code Alloc_hfReal_r2 Source Code SUBROUTINE Alloc_hfReal_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) this % hostData = 0.0_prec IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r2","tags":"","loc":"proc/alloc_hfreal_r2.html"},{"title":"Alloc_hfReal_r3 – SELF","text":"public subroutine Alloc_hfReal_r3(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) Contents Source Code Alloc_hfReal_r3 Source Code SUBROUTINE Alloc_hfReal_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) this % hostData = 0.0_prec IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r3","tags":"","loc":"proc/alloc_hfreal_r3.html"},{"title":"Alloc_hfReal_r4 – SELF","text":"public subroutine Alloc_hfReal_r4(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) Contents Source Code Alloc_hfReal_r4 Source Code SUBROUTINE Alloc_hfReal_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) this % hostData = 0.0_prec IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r4","tags":"","loc":"proc/alloc_hfreal_r4.html"},{"title":"Alloc_hfReal_r5 – SELF","text":"public subroutine Alloc_hfReal_r5(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) Contents Source Code Alloc_hfReal_r5 Source Code SUBROUTINE Alloc_hfReal_r5 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 5 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 5 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ))) this % hostData = 0.0_prec IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r5","tags":"","loc":"proc/alloc_hfreal_r5.html"},{"title":"Alloc_hfReal_r6 – SELF","text":"public subroutine Alloc_hfReal_r6(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) Contents Source Code Alloc_hfReal_r6 Source Code SUBROUTINE Alloc_hfReal_r6 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 6 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 6 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ))) this % hostData = 0.0_prec IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r6","tags":"","loc":"proc/alloc_hfreal_r6.html"},{"title":"Alloc_hfReal_r7 – SELF","text":"public subroutine Alloc_hfReal_r7(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) Contents Source Code Alloc_hfReal_r7 Source Code SUBROUTINE Alloc_hfReal_r7 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 7 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 7 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ), & loBound ( 7 ): upBound ( 7 ))) this % hostData = 0.0_prec IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r7","tags":"","loc":"proc/alloc_hfreal_r7.html"},{"title":"Free_hfInt32_r1 – SELF","text":"public subroutine Free_hfInt32_r1(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this Contents Source Code Free_hfInt32_r1 Source Code SUBROUTINE Free_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r1","tags":"","loc":"proc/free_hfint32_r1.html"},{"title":"Free_hfInt32_r2 – SELF","text":"public subroutine Free_hfInt32_r2(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this Contents Source Code Free_hfInt32_r2 Source Code SUBROUTINE Free_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r2","tags":"","loc":"proc/free_hfint32_r2.html"},{"title":"Free_hfInt32_r3 – SELF","text":"public subroutine Free_hfInt32_r3(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this Contents Source Code Free_hfInt32_r3 Source Code SUBROUTINE Free_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r3","tags":"","loc":"proc/free_hfint32_r3.html"},{"title":"Free_hfInt32_r4 – SELF","text":"public subroutine Free_hfInt32_r4(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this Contents Source Code Free_hfInt32_r4 Source Code SUBROUTINE Free_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r4","tags":"","loc":"proc/free_hfint32_r4.html"},{"title":"Free_hfReal_r1 – SELF","text":"public subroutine Free_hfReal_r1(this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this Contents Source Code Free_hfReal_r1 Source Code SUBROUTINE Free_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r1","tags":"","loc":"proc/free_hfreal_r1.html"},{"title":"Free_hfReal_r2 – SELF","text":"public subroutine Free_hfReal_r2(this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this Contents Source Code Free_hfReal_r2 Source Code SUBROUTINE Free_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r2","tags":"","loc":"proc/free_hfreal_r2.html"},{"title":"Free_hfReal_r3 – SELF","text":"public subroutine Free_hfReal_r3(this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this Contents Source Code Free_hfReal_r3 Source Code SUBROUTINE Free_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r3","tags":"","loc":"proc/free_hfreal_r3.html"},{"title":"Free_hfReal_r4 – SELF","text":"public subroutine Free_hfReal_r4(this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this Contents Source Code Free_hfReal_r4 Source Code SUBROUTINE Free_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r4","tags":"","loc":"proc/free_hfreal_r4.html"},{"title":"Free_hfReal_r5 – SELF","text":"public subroutine Free_hfReal_r5(this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this Contents Source Code Free_hfReal_r5 Source Code SUBROUTINE Free_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r5","tags":"","loc":"proc/free_hfreal_r5.html"},{"title":"Free_hfReal_r6 – SELF","text":"public subroutine Free_hfReal_r6(this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this Contents Source Code Free_hfReal_r6 Source Code SUBROUTINE Free_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r6","tags":"","loc":"proc/free_hfreal_r6.html"},{"title":"Free_hfReal_r7 – SELF","text":"public subroutine Free_hfReal_r7(this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this Contents Source Code Free_hfReal_r7 Source Code SUBROUTINE Free_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r7","tags":"","loc":"proc/free_hfreal_r7.html"},{"title":"UpdateDevice_hfInt32_r1 – SELF","text":"public subroutine UpdateDevice_hfInt32_r1(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this Contents Source Code UpdateDevice_hfInt32_r1 Source Code SUBROUTINE UpdateDevice_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r1","tags":"","loc":"proc/updatedevice_hfint32_r1.html"},{"title":"UpdateDevice_hfInt32_r2 – SELF","text":"public subroutine UpdateDevice_hfInt32_r2(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this Contents Source Code UpdateDevice_hfInt32_r2 Source Code SUBROUTINE UpdateDevice_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r2","tags":"","loc":"proc/updatedevice_hfint32_r2.html"},{"title":"UpdateDevice_hfInt32_r3 – SELF","text":"public subroutine UpdateDevice_hfInt32_r3(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this Contents Source Code UpdateDevice_hfInt32_r3 Source Code SUBROUTINE UpdateDevice_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r3","tags":"","loc":"proc/updatedevice_hfint32_r3.html"},{"title":"UpdateDevice_hfInt32_r4 – SELF","text":"public subroutine UpdateDevice_hfInt32_r4(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this Contents Source Code UpdateDevice_hfInt32_r4 Source Code SUBROUTINE UpdateDevice_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r4","tags":"","loc":"proc/updatedevice_hfint32_r4.html"},{"title":"UpdateDevice_hfReal_r1 – SELF","text":"public subroutine UpdateDevice_hfReal_r1(this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this Contents Source Code UpdateDevice_hfReal_r1 Source Code SUBROUTINE UpdateDevice_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r1","tags":"","loc":"proc/updatedevice_hfreal_r1.html"},{"title":"UpdateDevice_hfReal_r2 – SELF","text":"public subroutine UpdateDevice_hfReal_r2(this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this Contents Source Code UpdateDevice_hfReal_r2 Source Code SUBROUTINE UpdateDevice_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r2","tags":"","loc":"proc/updatedevice_hfreal_r2.html"},{"title":"UpdateDevice_hfReal_r3 – SELF","text":"public subroutine UpdateDevice_hfReal_r3(this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this Contents Source Code UpdateDevice_hfReal_r3 Source Code SUBROUTINE UpdateDevice_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r3","tags":"","loc":"proc/updatedevice_hfreal_r3.html"},{"title":"UpdateDevice_hfReal_r4 – SELF","text":"public subroutine UpdateDevice_hfReal_r4(this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this Contents Source Code UpdateDevice_hfReal_r4 Source Code SUBROUTINE UpdateDevice_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r4","tags":"","loc":"proc/updatedevice_hfreal_r4.html"},{"title":"UpdateDevice_hfReal_r5 – SELF","text":"public subroutine UpdateDevice_hfReal_r5(this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this Contents Source Code UpdateDevice_hfReal_r5 Source Code SUBROUTINE UpdateDevice_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r5","tags":"","loc":"proc/updatedevice_hfreal_r5.html"},{"title":"UpdateDevice_hfReal_r6 – SELF","text":"public subroutine UpdateDevice_hfReal_r6(this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this Contents Source Code UpdateDevice_hfReal_r6 Source Code SUBROUTINE UpdateDevice_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r6","tags":"","loc":"proc/updatedevice_hfreal_r6.html"},{"title":"UpdateDevice_hfReal_r7 – SELF","text":"public subroutine UpdateDevice_hfReal_r7(this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this Contents Source Code UpdateDevice_hfReal_r7 Source Code SUBROUTINE UpdateDevice_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r7","tags":"","loc":"proc/updatedevice_hfreal_r7.html"},{"title":"UpdateHost_hfInt32_r1 – SELF","text":"public subroutine UpdateHost_hfInt32_r1(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this Contents Source Code UpdateHost_hfInt32_r1 Source Code SUBROUTINE UpdateHost_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r1","tags":"","loc":"proc/updatehost_hfint32_r1.html"},{"title":"UpdateHost_hfInt32_r2 – SELF","text":"public subroutine UpdateHost_hfInt32_r2(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this Contents Source Code UpdateHost_hfInt32_r2 Source Code SUBROUTINE UpdateHost_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r2","tags":"","loc":"proc/updatehost_hfint32_r2.html"},{"title":"UpdateHost_hfInt32_r3 – SELF","text":"public subroutine UpdateHost_hfInt32_r3(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this Contents Source Code UpdateHost_hfInt32_r3 Source Code SUBROUTINE UpdateHost_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r3","tags":"","loc":"proc/updatehost_hfint32_r3.html"},{"title":"UpdateHost_hfInt32_r4 – SELF","text":"public subroutine UpdateHost_hfInt32_r4(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this Contents Source Code UpdateHost_hfInt32_r4 Source Code SUBROUTINE UpdateHost_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r4","tags":"","loc":"proc/updatehost_hfint32_r4.html"},{"title":"UpdateHost_hfReal_r1 – SELF","text":"public subroutine UpdateHost_hfReal_r1(this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this Contents Source Code UpdateHost_hfReal_r1 Source Code SUBROUTINE UpdateHost_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r1","tags":"","loc":"proc/updatehost_hfreal_r1.html"},{"title":"UpdateHost_hfReal_r2 – SELF","text":"public subroutine UpdateHost_hfReal_r2(this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this Contents Source Code UpdateHost_hfReal_r2 Source Code SUBROUTINE UpdateHost_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r2","tags":"","loc":"proc/updatehost_hfreal_r2.html"},{"title":"UpdateHost_hfReal_r3 – SELF","text":"public subroutine UpdateHost_hfReal_r3(this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this Contents Source Code UpdateHost_hfReal_r3 Source Code SUBROUTINE UpdateHost_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r3","tags":"","loc":"proc/updatehost_hfreal_r3.html"},{"title":"UpdateHost_hfReal_r4 – SELF","text":"public subroutine UpdateHost_hfReal_r4(this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this Contents Source Code UpdateHost_hfReal_r4 Source Code SUBROUTINE UpdateHost_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r4","tags":"","loc":"proc/updatehost_hfreal_r4.html"},{"title":"UpdateHost_hfReal_r5 – SELF","text":"public subroutine UpdateHost_hfReal_r5(this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this Contents Source Code UpdateHost_hfReal_r5 Source Code SUBROUTINE UpdateHost_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r5","tags":"","loc":"proc/updatehost_hfreal_r5.html"},{"title":"UpdateHost_hfReal_r6 – SELF","text":"public subroutine UpdateHost_hfReal_r6(this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this Contents Source Code UpdateHost_hfReal_r6 Source Code SUBROUTINE UpdateHost_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r6","tags":"","loc":"proc/updatehost_hfreal_r6.html"},{"title":"UpdateHost_hfReal_r7 – SELF","text":"public subroutine UpdateHost_hfReal_r7(this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this Contents Source Code UpdateHost_hfReal_r7 Source Code SUBROUTINE UpdateHost_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r7","tags":"","loc":"proc/updatehost_hfreal_r7.html"},{"title":"CovariantArcMin_SEMQuad – SELF","text":"public function CovariantArcMin_SEMQuad(myGeom) result(dxMin) Arguments Type Intent Optional Attributes Name class( SEMQuad ) :: myGeom Return Value real(kind=prec) Contents Source Code CovariantArcMin_SEMQuad Source Code FUNCTION CovariantArcMin_SEMQuad ( myGeom ) RESULT ( dxMin ) IMPLICIT NONE CLASS ( SEMQuad ) :: myGeom REAL ( prec ) :: dxMin ! Local INTEGER :: i , j , iEl , N REAL ( prec ) :: dx , dy REAL ( prec ) :: dxds ( 1 : 2 , 1 : 2 ) REAL ( prec ) :: ds ( 0 : myGeom % dxds % interp % N ,& 0 : myGeom % dxds % interp % N ,& 1 : myGeom % nElem ) N = myGeom % dxds % interp % N DO iEl = 1 , myGeom % nElem DO j = 0 , N DO i = 0 , N dxds = myGeom % dxds % interior % hostData ( 1 : 2 , 1 : 2 , i , j , 1 , iEl ) dx = SQRT ( dxds ( 1 , 1 ) ** 2 + dxds ( 1 , 2 ) ** 2 ) dy = SQRT ( dxds ( 2 , 1 ) ** 2 + dxds ( 2 , 2 ) ** 2 ) ds ( i , j , iEl ) = 2.0_prec * MIN ( dx , dy ) / ( REAL ( N , prec ) ** 2 ) ENDDO ENDDO ENDDO dxMin = MINVAL ( ds ) END FUNCTION CovariantArcMin_SEMQuad","tags":"","loc":"proc/covariantarcmin_semquad.html"},{"title":"CalculateContravariantBasis_SEMHex – SELF","text":"public subroutine CalculateContravariantBasis_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code CalculateContravariantBasis_SEMHex Source Code SUBROUTINE CalculateContravariantBasis_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom ! Local INTEGER :: iEl , i , j , k REAL ( prec ) :: fac REAL ( prec ) :: mag ! Now calculate the contravariant basis vectors ! In this convention, dsdx(j,i) is contravariant vector i, component j ! To project onto contravariant vector i, dot vector along the first dimension ! TO DO : Curl Invariant Form DO iEl = 1 , myGeom % nElem DO k = 0 , myGeom % dxds % interp % N DO j = 0 , myGeom % dxds % interp % N DO i = 0 , myGeom % dxds % interp % N ! Ja1 myGeom % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) ! Ja2 myGeom % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) ! Ja3 myGeom % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) END DO END DO END DO END DO ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . FALSE .) ! Now, calculate nHat (outward pointing normal) DO iEl = 1 , myGeom % nElem DO k = 1 , 6 DO j = 0 , myGeom % J % interp % N DO i = 0 , myGeom % J % interp % N IF ( k == selfSide3D_Top . OR . k == selfSide3D_East . OR . k == selfSide3D_North ) THEN fac = SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , j , 1 , k , iEl )) ELSE fac = - SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , j , 1 , k , iEl )) END IF IF ( k == 1 ) THEN ! Bottom mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 3 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 3 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 2 ) THEN ! South mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 2 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 2 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 3 ) THEN ! East mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 1 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 4 ) THEN ! North mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 2 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 2 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 5 ) THEN ! West mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 1 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 6 ) THEN ! Top mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 3 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 3 , i , j , 1 , k , iEl ) / mag ENDIF ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , 1 , k , iEl ) = & myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , 1 , k , iEl ) * fac END DO END DO END DO END DO END SUBROUTINE CalculateContravariantBasis_SEMHex","tags":"","loc":"proc/calculatecontravariantbasis_semhex.html"},{"title":"CalculateContravariantBasis_SEMQuad – SELF","text":"public subroutine CalculateContravariantBasis_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code CalculateContravariantBasis_SEMQuad Source Code SUBROUTINE CalculateContravariantBasis_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom ! Local INTEGER :: iEl , i , j , k REAL ( prec ) :: fac REAL ( prec ) :: mag ! Now calculate the contravariant basis vectors ! In this convention, dsdx(j,i) is contravariant vector i, component j ! To project onto contravariant vector i, dot vector along the first dimension DO iEl = 1 , myGeom % nElem DO j = 0 , myGeom % dxds % interp % N DO i = 0 , myGeom % dxds % interp % N myGeom % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iEl ) = myGeom % dxds % interior % hostData ( 2 , 2 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iEl ) = - myGeom % dxds % interior % hostData ( 1 , 2 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iEl ) = - myGeom % dxds % interior % hostData ( 2 , 1 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iEl ) = myGeom % dxds % interior % hostData ( 1 , 1 , i , j , 1 , iEl ) END DO END DO END DO ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . FALSE .) ! Now, modify the sign of dsdx so that ! myGeom % dsdx % boundary is equal to the outward pointing normal vector DO iEl = 1 , myGeom % nElem DO k = 1 , 4 DO i = 0 , myGeom % J % interp % N IF ( k == selfSide2D_East . OR . k == selfSide2D_North ) THEN fac = SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , 1 , k , iEl )) ELSE fac = - SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , 1 , k , iEl )) END IF IF ( k == 1 ) THEN ! South mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 2 , i , 1 , k , iEl ) / mag ELSEIF ( k == 2 ) THEN ! East mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 , i , 1 , k , iEl ) / mag ELSEIF ( k == 3 ) THEN ! North mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 2 , i , 1 , k , iEl ) / mag ELSEIF ( k == 4 ) THEN ! West mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 , i , 1 , k , iEl ) / mag ENDIF ! Set the directionality for dsdx on the boundaries myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 : 2 , i , 1 , k , iEl ) = & myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 : 2 , i , 1 , k , iEl ) * fac END DO END DO END DO END SUBROUTINE CalculateContravariantBasis_SEMQuad","tags":"","loc":"proc/calculatecontravariantbasis_semquad.html"},{"title":"CalculateMetricTerms_Geometry1D – SELF","text":"public subroutine CalculateMetricTerms_Geometry1D(myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Contents Source Code CalculateMetricTerms_Geometry1D Source Code SUBROUTINE CalculateMetricTerms_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % Derivative ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % UpdateDevice () END SUBROUTINE CalculateMetricTerms_Geometry1D","tags":"","loc":"proc/calculatemetricterms_geometry1d.html"},{"title":"CalculateMetricTerms_SEMHex – SELF","text":"public subroutine CalculateMetricTerms_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code CalculateMetricTerms_SEMHex Source Code SUBROUTINE CalculateMetricTerms_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom !IF (GPUAvailable()) THEN !  CALL myGeom % x % Gradient(myGeom % dxds,gpuAccel=.TRUE.) !  CALL myGeom % dxds % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % dxds % Determinant(myGeom % J,gpuAccel=.TRUE.) !  CALL myGeom % J % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % UpdateHost() !ELSE CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . FALSE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . FALSE .) !END IF CALL myGeom % CalculateContravariantBasis () IF ( GPUAvailable ()) THEN CALL myGeom % UpdateDevice () ENDIF END SUBROUTINE CalculateMetricTerms_SEMHex","tags":"","loc":"proc/calculatemetricterms_semhex.html"},{"title":"CalculateMetricTerms_SEMQuad – SELF","text":"public subroutine CalculateMetricTerms_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code CalculateMetricTerms_SEMQuad Source Code SUBROUTINE CalculateMetricTerms_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom !    IF (GPUAvailable()) THEN !      CALL myGeom % x % Gradient(myGeom % dxds,gpuAccel=.TRUE.) !      CALL myGeom % dxds % BoundaryInterp(gpuAccel=.TRUE.) !      CALL myGeom % dxds % Determinant(myGeom % J,gpuAccel=.TRUE.) !      CALL myGeom % J % BoundaryInterp(gpuAccel=.TRUE.) !      CALL myGeom % UpdateHost() !    ELSE CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . FALSE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . FALSE .) !    END IF CALL myGeom % CalculateContravariantBasis () IF ( GPUAvailable ()) THEN CALL myGeom % dsdx % UpdateDevice () CALL myGeom % nHat % UpdateDevice () CALL myGeom % nScale % UpdateDevice () ENDIF END SUBROUTINE CalculateMetricTerms_SEMQuad","tags":"","loc":"proc/calculatemetricterms_semquad.html"},{"title":"CheckSides_SEMHex – SELF","text":"public subroutine CheckSides_SEMHex(myGeom, mesh) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(in) :: myGeom type( Mesh3D ), intent(in) :: mesh Contents Source Code CheckSides_SEMHex Source Code SUBROUTINE CheckSides_SEMHex ( myGeom , mesh ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( in ) :: myGeom TYPE ( Mesh3D ), INTENT ( in ) :: mesh ! INTEGER :: e1 , s1 INTEGER :: e2 , s2 INTEGER :: i1 , j1 INTEGER :: i2 , j2 INTEGER :: flip , bcid REAL ( prec ) :: rms DO e1 = 1 , mesh % nElem DO s1 = 1 , 6 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN ! Interior rms = 0.0_prec IF ( flip == 0 ) THEN DO j1 = 0 , myGeom % x % interp % N DO i1 = 0 , myGeom % x % interp % N rms = rms + & sqrt ( ( myGeom % x % boundary % hostdata ( 1 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 1 , i1 , j1 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 2 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 2 , i1 , j1 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 3 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 3 , i1 , j1 , 1 , s2 , e2 )) ** 2 ) END DO END DO ELSEIF ( flip == 1 ) THEN DO j1 = 0 , myGeom % x % interp % N DO i1 = 0 , myGeom % x % interp % N i2 = j1 j2 = myGeom % x % interp % N - i1 rms = rms + & sqrt ( ( myGeom % x % boundary % hostdata ( 1 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 1 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 2 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 2 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 3 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 3 , i2 , j2 , 1 , s2 , e2 )) ** 2 ) END DO END DO ELSEIF ( flip == 2 ) THEN DO j1 = 0 , myGeom % x % interp % N DO i1 = 0 , myGeom % x % interp % N i2 = myGeom % x % interp % N - i1 j2 = myGeom % x % interp % N - j1 rms = rms + & sqrt ( ( myGeom % x % boundary % hostdata ( 1 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 1 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 2 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 2 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 3 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 3 , i2 , j2 , 1 , s2 , e2 )) ** 2 ) END DO END DO ELSEIF ( flip == 3 ) THEN DO j1 = 0 , myGeom % x % interp % N DO i1 = 0 , myGeom % x % interp % N i2 = myGeom % x % interp % N - j1 j2 = i1 rms = rms + & sqrt ( ( myGeom % x % boundary % hostdata ( 1 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 1 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 2 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 2 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 3 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 3 , i2 , j2 , 1 , s2 , e2 )) ** 2 ) END DO END DO ELSEIF ( flip == 4 ) THEN DO j1 = 0 , myGeom % x % interp % N DO i1 = 0 , myGeom % x % interp % N i2 = j1 j2 = i1 rms = rms + & sqrt ( ( myGeom % x % boundary % hostdata ( 1 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 1 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 2 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 2 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 3 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 3 , i2 , j2 , 1 , s2 , e2 )) ** 2 ) END DO END DO END IF END IF END DO END DO END SUBROUTINE CheckSides_SEMHex","tags":"","loc":"proc/checksides_semhex.html"},{"title":"Free_Geometry1D – SELF","text":"public subroutine Free_Geometry1D(myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Contents Source Code Free_Geometry1D Source Code SUBROUTINE Free_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () END SUBROUTINE Free_Geometry1D","tags":"","loc":"proc/free_geometry1d.html"},{"title":"Free_SEMHex – SELF","text":"public subroutine Free_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code Free_SEMHex Source Code SUBROUTINE Free_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () CALL myGeom % dsdx % Free () CALL myGeom % nHat % Free () CALL myGeom % nScale % Free () CALL myGeom % J % Free () END SUBROUTINE Free_SEMHex","tags":"","loc":"proc/free_semhex.html"},{"title":"Free_SEMQuad – SELF","text":"public subroutine Free_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code Free_SEMQuad Source Code SUBROUTINE Free_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () CALL myGeom % dsdx % Free () CALL myGeom % nHat % Free () CALL myGeom % nScale % Free () CALL myGeom % J % Free () END SUBROUTINE Free_SEMQuad","tags":"","loc":"proc/free_semquad.html"},{"title":"GenerateFromMesh_Geometry1D – SELF","text":"public subroutine GenerateFromMesh_Geometry1D(myGeom, mesh) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom type( Mesh1D ), intent(in) :: mesh Contents Source Code GenerateFromMesh_Geometry1D Source Code SUBROUTINE GenerateFromMesh_Geometry1D ( myGeom , mesh ) ! Generates the geometry for a 1-D mesh ( set of line segments ) ! Assumes that mesh is using Gauss-Lobatto quadrature and the degree is given by mesh % nGeo IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom TYPE ( Mesh1D ), INTENT ( in ) :: mesh ! Local INTEGER :: iel , i , nid TYPE ( Lagrange ), TARGET :: meshToModel TYPE ( Scalar1D ) :: xMesh CALL meshToModel % Init ( mesh % nGeo , mesh % quadrature ,& myGeom % x % interp % N , & myGeom % x % interp % controlNodeType ) CALL xMesh % Init ( meshToModel ,& 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 DO iel = 1 , mesh % nElem DO i = 0 , mesh % nGeo xMesh % interior % hostData ( i , 1 , iel ) = mesh % nodeCoords % hostData ( nid ) nid = nid + 1 END DO END DO ! Interpolate from the mesh hopr_nodeCoords to the geometry (Possibly not gauss_lobatto quadrature) CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () CALL myGeom % UpdateDevice () CALL xMesh % Free () CALL meshToModel % Free () END SUBROUTINE GenerateFromMesh_Geometry1D","tags":"","loc":"proc/generatefrommesh_geometry1d.html"},{"title":"GenerateFromMesh_SEMHex – SELF","text":"public subroutine GenerateFromMesh_SEMHex(myGeom, mesh) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom type( Mesh3D ), intent(in) :: mesh Contents Source Code GenerateFromMesh_SEMHex Source Code SUBROUTINE GenerateFromMesh_SEMHex ( myGeom , mesh ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom TYPE ( Mesh3D ), INTENT ( in ) :: mesh ! Local INTEGER :: iel INTEGER :: i , j , k , nid TYPE ( Lagrange ), TARGET :: meshToModel TYPE ( Vector3D ) :: xMesh CALL meshToModel % Init ( mesh % nGeo , mesh % quadrature ,& myGeom % x % interp % N , & myGeom % x % interp % controlNodeType ) CALL xMesh % Init ( meshToModel ,& 1 , mesh % nElem ) ! Set the element internal mesh locations DO iel = 1 , mesh % nElem DO k = 0 , mesh % nGeo DO j = 0 , mesh % nGeo DO i = 0 , mesh % nGeo xMesh % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) = mesh % nodeCoords % hostData ( 1 : 3 , i , j , k , iel ) END DO END DO END DO END DO ! Interpolate from the mesh hopr_nodeCoords to the geometry (Possibly not gauss_lobatto quadrature) !IF (GPUAvailable()) THEN !  CALL xMesh % UpdateDevice() !  CALL xMesh % GridInterp(myGeom % x,.TRUE.) !  CALL myGeom % x % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % CalculateMetricTerms() !  CALL myGeom % UpdateHost() !ELSE CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () !END IF !    CALL myGeom % CheckSides(mesh) CALL myGeom % UpdateDevice () CALL xMesh % Free () CALL meshToModel % Free () END SUBROUTINE GenerateFromMesh_SEMHex","tags":"","loc":"proc/generatefrommesh_semhex.html"},{"title":"GenerateFromMesh_SEMQuad – SELF","text":"public subroutine GenerateFromMesh_SEMQuad(myGeom, mesh) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom type( Mesh2D ), intent(in) :: mesh Contents Source Code GenerateFromMesh_SEMQuad Source Code SUBROUTINE GenerateFromMesh_SEMQuad ( myGeom , mesh ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom TYPE ( Mesh2D ), INTENT ( in ) :: mesh ! Local INTEGER :: iel INTEGER :: i , j , nid TYPE ( Lagrange ), TARGET :: meshToModel TYPE ( Vector2D ) :: xMesh CALL meshToModel % Init ( mesh % nGeo , & mesh % quadrature , & myGeom % x % interp % N , & myGeom % x % interp % controlNodeType ) CALL xMesh % Init ( meshToModel , 1 , mesh % nElem ) ! Set the element internal mesh locations DO iel = 1 , mesh % nElem DO j = 0 , mesh % nGeo DO i = 0 , mesh % nGeo xMesh % interior % hostData ( 1 : 2 , i , j , 1 , iel ) = mesh % nodeCoords % hostData ( 1 : 2 , i , j , iel ) END DO END DO END DO !IF (GPUAvailable()) THEN !  CALL xMesh % UpdateDevice() !  CALL xMesh % GridInterp(myGeom % x,.TRUE.) !  CALL myGeom % x % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % CalculateMetricTerms() !  CALL myGeom % UpdateHost() !ELSE CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () !END IF CALL myGeom % UpdateDevice () CALL xMesh % Free () CALL meshToModel % Free () END SUBROUTINE GenerateFromMesh_SEMQuad","tags":"","loc":"proc/generatefrommesh_semquad.html"},{"title":"Init_Geometry1D – SELF","text":"public subroutine Init_Geometry1D(myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom type( Lagrange ), intent(in), POINTER :: interp integer, intent(in) :: nElem Contents Source Code Init_Geometry1D Source Code SUBROUTINE Init_Geometry1D ( myGeom , interp , nElem ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( out ) :: myGeom TYPE ( Lagrange ), POINTER , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nElem myGeom % nElem = nElem CALL myGeom % x % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_Geometry1D","tags":"","loc":"proc/init_geometry1d.html"},{"title":"Init_SEMHex – SELF","text":"public subroutine Init_SEMHex(myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom type( Lagrange ), intent(in), POINTER :: interp integer, intent(in) :: nElem Contents Source Code Init_SEMHex Source Code SUBROUTINE Init_SEMHex ( myGeom , interp , nElem ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( out ) :: myGeom TYPE ( Lagrange ), POINTER , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nElem myGeom % nElem = nElem CALL myGeom % x % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % dsdx % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % nHat % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % nScale % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % J % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_SEMHex","tags":"","loc":"proc/init_semhex.html"},{"title":"Init_SEMQuad – SELF","text":"public subroutine Init_SEMQuad(myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom type( Lagrange ), intent(in), POINTER :: interp integer, intent(in) :: nElem Contents Source Code Init_SEMQuad Source Code SUBROUTINE Init_SEMQuad ( myGeom , interp , nElem ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( out ) :: myGeom TYPE ( Lagrange ), POINTER , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nElem myGeom % nElem = nElem CALL myGeom % x % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % dsdx % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % nHat % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % nScale % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % J % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_SEMQuad","tags":"","loc":"proc/init_semquad.html"},{"title":"UpdateDevice_Geometry1D – SELF","text":"public subroutine UpdateDevice_Geometry1D(myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Contents Source Code UpdateDevice_Geometry1D Source Code SUBROUTINE UpdateDevice_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () END SUBROUTINE UpdateDevice_Geometry1D","tags":"","loc":"proc/updatedevice_geometry1d.html"},{"title":"UpdateDevice_SEMHex – SELF","text":"public subroutine UpdateDevice_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code UpdateDevice_SEMHex Source Code SUBROUTINE UpdateDevice_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () CALL myGeom % dsdx % UpdateDevice () CALL myGeom % nHat % UpdateDevice () CALL myGeom % nScale % UpdateDevice () CALL myGeom % J % UpdateDevice () END SUBROUTINE UpdateDevice_SEMHex","tags":"","loc":"proc/updatedevice_semhex.html"},{"title":"UpdateDevice_SEMQuad – SELF","text":"public subroutine UpdateDevice_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code UpdateDevice_SEMQuad Source Code SUBROUTINE UpdateDevice_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () CALL myGeom % dsdx % UpdateDevice () CALL myGeom % nHat % UpdateDevice () CALL myGeom % nScale % UpdateDevice () CALL myGeom % J % UpdateDevice () END SUBROUTINE UpdateDevice_SEMQuad","tags":"","loc":"proc/updatedevice_semquad.html"},{"title":"UpdateHost_Geometry1D – SELF","text":"public subroutine UpdateHost_Geometry1D(myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Contents Source Code UpdateHost_Geometry1D Source Code SUBROUTINE UpdateHost_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () END SUBROUTINE UpdateHost_Geometry1D","tags":"","loc":"proc/updatehost_geometry1d.html"},{"title":"UpdateHost_SEMHex – SELF","text":"public subroutine UpdateHost_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code UpdateHost_SEMHex Source Code SUBROUTINE UpdateHost_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () CALL myGeom % dsdx % UpdateHost () CALL myGeom % nHat % UpdateHost () CALL myGeom % nScale % UpdateHost () CALL myGeom % J % UpdateHost () END SUBROUTINE UpdateHost_SEMHex","tags":"","loc":"proc/updatehost_semhex.html"},{"title":"UpdateHost_SEMQuad – SELF","text":"public subroutine UpdateHost_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code UpdateHost_SEMQuad Source Code SUBROUTINE UpdateHost_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () CALL myGeom % dsdx % UpdateHost () CALL myGeom % nHat % UpdateHost () CALL myGeom % nScale % UpdateHost () CALL myGeom % J % UpdateHost () END SUBROUTINE UpdateHost_SEMQuad","tags":"","loc":"proc/updatehost_semquad.html"},{"title":"Write_Geometry1D – SELF","text":"public subroutine Write_Geometry1D(myGeom, fileName) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(in) :: myGeom character, intent(in), optional :: fileName Contents Source Code Write_Geometry1D Source Code SUBROUTINE Write_Geometry1D ( myGeom , fileName ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( in ) :: myGeom CHARACTER ( * ), OPTIONAL , INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId ! Local CHARACTER ( LEN = self_FileNameLength ) :: pickupFile IF ( PRESENT ( filename ) ) THEN pickupFile = filename ELSE pickupFile = 'mesh.h5' ENDIF CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) CALL CreateGroup_HDF5 ( fileId , '/quadrature' ) CALL WriteArray_HDF5 ( fileId , '/quadrature/xi' , & myGeom % x % interp % controlPoints ) CALL WriteArray_HDF5 ( fileId , '/quadrature/weights' , & myGeom % x % interp % qWeights ) CALL WriteArray_HDF5 ( fileId , '/quadrature/dgmatrix' , & myGeom % x % interp % dgMatrix ) CALL WriteArray_HDF5 ( fileId , '/quadrature/dmatrix' , & myGeom % x % interp % dMatrix ) CALL CreateGroup_HDF5 ( fileId , '/mesh' ) CALL CreateGroup_HDF5 ( fileId , '/mesh/interior' ) CALL CreateGroup_HDF5 ( fileId , '/mesh/boundary' ) CALL WriteArray_HDF5 ( fileId , '/mesh/interior/x' , myGeom % x % interior ) CALL WriteArray_HDF5 ( fileId , '/mesh/interior/dxds' , myGeom % dxds % interior ) CALL WriteArray_HDF5 ( fileId , '/mesh/boundary/x' , myGeom % x % boundary ) CALL WriteArray_HDF5 ( fileId , '/mesh/boundary/dxds' , myGeom % dxds % boundary ) CALL Close_HDF5 ( fileId ) END SUBROUTINE Write_Geometry1D","tags":"","loc":"proc/write_geometry1d.html"},{"title":"AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper – SELF","text":"interface public subroutine AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper(dsdx, J, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dsdx type(c_ptr) :: J integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/adjustboundarycontravariantbasis_semhex_gpu_wrapper.html"},{"title":"AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper – SELF","text":"interface public subroutine AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper(dsdx, J, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dsdx type(c_ptr) :: J integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/adjustboundarycontravariantbasis_semquad_gpu_wrapper.html"},{"title":"CalculateContravariantBasis_SEMHex_gpu_wrapper – SELF","text":"interface public subroutine CalculateContravariantBasis_SEMHex_gpu_wrapper(dxds, dsdx, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dxds type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/calculatecontravariantbasis_semhex_gpu_wrapper.html"},{"title":"CalculateContravariantBasis_SEMQuad_gpu_wrapper – SELF","text":"interface public subroutine CalculateContravariantBasis_SEMQuad_gpu_wrapper(dxds, dsdx, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dxds type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/calculatecontravariantbasis_semquad_gpu_wrapper.html"},{"title":"Integral_MappedScalar2D – SELF","text":"public function Integral_MappedScalar2D(this, geometry, decomp, gpuAccel) result(fRes) Calculates the area integral the scalar over all of the geometry.\nGlobal reduction is done across all MPI ranks when the domain\ndecomposition indicates MPI is enabled. Arguments Type Intent Optional Attributes Name class( MappedScalar2D ) :: this type( SEMQuad ) :: geometry type( MPILayer ) :: decomp logical :: gpuAccel Return Value real(kind=prec) Contents Source Code Integral_MappedScalar2D Source Code FUNCTION Integral_MappedScalar2D ( this , geometry , decomp , gpuAccel ) RESULT ( fRes ) !! Calculates the area integral the scalar over all of the geometry. !! Global reduction is done across all MPI ranks when the domain !! decomposition indicates MPI is enabled. IMPLICIT NONE CLASS ( MappedScalar2D ) :: this TYPE ( SEMQuad ) :: geometry TYPE ( MPILayer ) :: decomp LOGICAL :: gpuAccel REAL ( prec ) :: fRes ! Local INTEGER :: i , j , iEl REAL ( prec ) :: wi , wj , fint , Jacobian , f IF ( gpuAccel ) THEN CALL this % interior % UpdateHost () ENDIF fint = 0.0_prec DO iEl = 1 , geometry % x % nElem DO j = 0 , geometry % x % interp % N DO i = 0 , geometry % x % interp % N ! Coordinate mapping Jacobian Jacobian = geometry % J % interior % hostData ( i , j , 1 , iEl ) ! Quadrature weights wi = geometry % x % interp % qWeights % hostData ( i ) wj = geometry % x % interp % qWeights % hostData ( j ) f = this % interior % hostData ( i , j , 4 , iEl ) fint = fint + f * wi * wj * Jacobian ENDDO ENDDO ENDDO CALL decomp % GlobalReduce ( fint , fRes ) END FUNCTION Integral_MappedScalar2D","tags":"","loc":"proc/integral_mappedscalar2d.html"},{"title":"ApplyFlip_MappedScalar2D – SELF","text":"public subroutine ApplyFlip_MappedScalar2D(scalar, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( MPILayer ), intent(inout) :: mpiHandler type( Mesh2D ), intent(in) :: mesh logical, intent(in) :: gpuAccel Contents Source Code ApplyFlip_MappedScalar2D Source Code SUBROUTINE ApplyFlip_MappedScalar2D ( scalar , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId INTEGER :: bcid REAL ( prec ) :: extBuff ( 0 : scalar % interp % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedScalar2D_gpu_wrapper ( scalar % extBoundary % deviceData , & mesh % sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO e1 = 1 , scalar % nElem DO s1 = 1 , 4 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN ! Interior Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % sideInfo % hostdata ( 2 , s1 , e1 ) ! Need to update extBoundary with flip applied IF ( flip == 1 ) THEN DO ivar = 1 , scalar % nvar DO i = 0 , scalar % interp % N i2 = scalar % interp % N - i extBuff ( i ) = scalar % extBoundary % hostData ( i2 , ivar , s1 , e1 ) END DO DO i = 0 , scalar % interp % N scalar % extBoundary % hostData ( i , ivar , s1 , e1 ) = extBuff ( i ) END DO END DO END IF END IF ENDIF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedScalar2D","tags":"","loc":"proc/applyflip_mappedscalar2d.html"},{"title":"ApplyFlip_MappedScalar3D – SELF","text":"public subroutine ApplyFlip_MappedScalar3D(scalar, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( MPILayer ), intent(inout) :: mpiHandler type( Mesh3D ), intent(in) :: mesh logical, intent(in) :: gpuAccel Contents Source Code ApplyFlip_MappedScalar3D Source Code SUBROUTINE ApplyFlip_MappedScalar3D ( scalar , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 , j , j2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId INTEGER :: bcid REAL ( prec ) :: extBuff ( 0 : scalar % interp % N , 0 : scalar % interp % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedScalar3D_gpu_wrapper ( scalar % extBoundary % deviceData , & mesh % sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO e1 = 1 , scalar % nElem DO s1 = 1 , 6 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN ! Interior Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % sideInfo % hostdata ( 2 , s1 , e1 ) ! Need to update extBoundary with flip applied IF ( flip == 1 ) THEN DO ivar = 1 , scalar % nvar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N i2 = j j2 = scalar % interp % N - i extBuff ( i , j ) = scalar % extBoundary % hostData ( i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N scalar % extBoundary % hostData ( i , j , ivar , s1 , e1 ) = extBuff ( i , j ) END DO END DO END DO ELSEIF ( flip == 2 ) THEN DO ivar = 1 , scalar % nvar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N i2 = scalar % interp % N - i j2 = scalar % interp % N - j extBuff ( i , j ) = scalar % extBoundary % hostData ( i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N scalar % extBoundary % hostData ( i , j , ivar , s1 , e1 ) = extBuff ( i , j ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , scalar % nvar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N i2 = scalar % interp % N - j j2 = i extBuff ( i , j ) = scalar % extBoundary % hostData ( i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N scalar % extBoundary % hostData ( i , j , ivar , s1 , e1 ) = extBuff ( i , j ) END DO END DO END DO ELSEIF ( flip == 4 ) THEN DO ivar = 1 , scalar % nvar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N i2 = j j2 = i extBuff ( i , j ) = scalar % extBoundary % hostData ( i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N scalar % extBoundary % hostData ( i , j , ivar , s1 , e1 ) = extBuff ( i , j ) END DO END DO END DO END IF END IF ENDIF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedScalar3D","tags":"","loc":"proc/applyflip_mappedscalar3d.html"},{"title":"ApplyFlip_MappedVector2D – SELF","text":"public subroutine ApplyFlip_MappedVector2D(vector, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( MPILayer ), intent(inout) :: mpiHandler type( Mesh2D ), intent(in) :: mesh logical, intent(in) :: gpuAccel Contents Source Code ApplyFlip_MappedVector2D Source Code SUBROUTINE ApplyFlip_MappedVector2D ( vector , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId INTEGER :: bcid REAL ( prec ) :: extBuff ( 1 : 2 , 0 : vector % interp % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedVector2D_gpu_wrapper ( vector % extBoundary % deviceData , & mesh % sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & vector % interp % N , & vector % nVar , & vector % nElem ) ELSE DO e1 = 1 , vector % nElem DO s1 = 1 , 4 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN ! Interior Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % sideInfo % hostdata ( 2 , s1 , e1 ) ! Need to update extBoundary with flip applied IF ( flip == 1 ) THEN DO ivar = 1 , vector % nvar DO i = 0 , vector % interp % N i2 = vector % interp % N - i extBuff ( 1 : 2 , i ) = vector % extBoundary % hostData ( 1 : 2 , i2 , ivar , s1 , e1 ) END DO DO i = 0 , vector % interp % N vector % extBoundary % hostData ( 1 : 2 , i , ivar , s1 , e1 ) = extBuff ( 1 : 2 , i ) END DO END DO END IF END IF ENDIF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedVector2D","tags":"","loc":"proc/applyflip_mappedvector2d.html"},{"title":"ApplyFlip_MappedVector3D – SELF","text":"public subroutine ApplyFlip_MappedVector3D(vector, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( MPILayer ), intent(inout) :: mpiHandler type( Mesh3D ), intent(in) :: mesh logical, intent(in) :: gpuAccel Contents Source Code ApplyFlip_MappedVector3D Source Code SUBROUTINE ApplyFlip_MappedVector3D ( vector , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 , j , j2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId INTEGER :: bcid REAL ( prec ) :: extBuff ( 1 : 3 , 0 : vector % interp % N , 0 : vector % interp % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedVector3D_gpu_wrapper ( vector % extBoundary % deviceData , & mesh % sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & vector % interp % N , & vector % nVar , & vector % nElem ) ELSE DO e1 = 1 , vector % nElem DO s1 = 1 , 6 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN ! Interior Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % sideInfo % hostdata ( 2 , s1 , e1 ) IF ( flip == 1 ) THEN DO ivar = 1 , vector % nvar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N i2 = j j2 = vector % interp % N - i extBuff ( 1 : 3 , i , j ) = vector % extBoundary % hostData ( 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , i , j ) END DO END DO END DO ELSEIF ( flip == 2 ) THEN DO ivar = 1 , vector % nvar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N i2 = vector % interp % N - i j2 = vector % interp % N - j extBuff ( 1 : 3 , i , j ) = vector % extBoundary % hostData ( 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , i , j ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , vector % nvar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N i2 = vector % interp % N - j j2 = i extBuff ( 1 : 3 , i , j ) = vector % extBoundary % hostData ( 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , i , j ) END DO END DO END DO ELSEIF ( flip == 4 ) THEN DO ivar = 1 , vector % nvar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N i2 = j j2 = i extBuff ( 1 : 3 , i , j ) = vector % extBoundary % hostData ( 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , i , j ) END DO END DO END DO END IF END IF ENDIF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedVector3D","tags":"","loc":"proc/applyflip_mappedvector3d.html"},{"title":"BassiRebaySides_MappedScalar1D – SELF","text":"public subroutine BassiRebaySides_MappedScalar1D(scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel Contents Source Code BassiRebaySides_MappedScalar1D Source Code SUBROUTINE BassiRebaySides_MappedScalar1D ( scalar , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i if ( gpuAccel ) then call scalar % boundary % updatehost () call scalar % extBoundary % updatehost () endif DO iel = 1 , scalar % nElem DO ivar = 1 , scalar % nVar ! Left side - we account for the -\\hat{x} normal scalar % avgBoundary % hostData ( ivar , 1 , iel ) = - 0.5_prec * ( & scalar % boundary % hostData ( ivar , 1 , iel ) + & scalar % extBoundary % hostData ( ivar , 1 , iel )) ! Right side - we account for the +\\hat{x} normal scalar % avgBoundary % hostData ( ivar , 2 , iel ) = 0.5_prec * ( & scalar % boundary % hostData ( ivar , 2 , iel ) + & scalar % extBoundary % hostData ( ivar , 2 , iel )) END DO END DO if ( gpuAccel ) then call scalar % avgBoundary % updateDevice () endif END SUBROUTINE BassiRebaySides_MappedScalar1D","tags":"","loc":"proc/bassirebaysides_mappedscalar1d.html"},{"title":"BassiRebaySides_MappedScalar2D – SELF","text":"public subroutine BassiRebaySides_MappedScalar2D(scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel Contents Source Code BassiRebaySides_MappedScalar2D Source Code SUBROUTINE BassiRebaySides_MappedScalar2D ( scalar , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedScalar2D_gpu_wrapper ( scalar % avgBoundary % deviceData , & scalar % boundary % deviceData , & scalar % extBoundary % deviceData , & scalar % interp % N , & scalar % nvar , & scalar % nElem ) ELSE DO iel = 1 , scalar % nElem DO iside = 1 , 4 DO ivar = 1 , scalar % nVar DO i = 0 , scalar % interp % N scalar % avgBoundary % hostData ( i , ivar , iside , iel ) = 0.5_prec * ( & scalar % boundary % hostData ( i , ivar , iside , iel ) + & scalar % extBoundary % hostData ( i , ivar , iside , iel )) END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedScalar2D","tags":"","loc":"proc/bassirebaysides_mappedscalar2d.html"},{"title":"BassiRebaySides_MappedScalar3D – SELF","text":"public subroutine BassiRebaySides_MappedScalar3D(scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel Contents Source Code BassiRebaySides_MappedScalar3D Source Code SUBROUTINE BassiRebaySides_MappedScalar3D ( scalar , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i , j IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedScalar3D_gpu_wrapper ( scalar % avgBoundary % deviceData , & scalar % boundary % deviceData , & scalar % extBoundary % deviceData , & scalar % interp % N , & scalar % nvar , & scalar % nElem ) ELSE DO iel = 1 , scalar % nElem DO iside = 1 , 6 DO ivar = 1 , scalar % nVar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N scalar % avgBoundary % hostData ( i , j , ivar , iside , iel ) = 0.5_prec * ( & scalar % boundary % hostData ( i , j , ivar , iside , iel ) + & scalar % extBoundary % hostData ( i , j , ivar , iside , iel )) END DO END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedScalar3D","tags":"","loc":"proc/bassirebaysides_mappedscalar3d.html"},{"title":"BassiRebaySides_MappedVector2D – SELF","text":"public subroutine BassiRebaySides_MappedVector2D(vector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector logical, intent(in) :: gpuAccel Contents Source Code BassiRebaySides_MappedVector2D Source Code SUBROUTINE BassiRebaySides_MappedVector2D ( vector , gpuAccel ) IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedVector2D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & vector % interp % N , & vector % nvar , & vector % nElem ) ELSE DO iel = 1 , vector % nElem DO iside = 1 , 4 DO ivar = 1 , vector % nVar DO i = 0 , vector % interp % N vector % boundary % hostData ( 1 : 2 , i , ivar , iside , iel ) = 0.5_prec * ( & vector % boundary % hostData ( 1 : 2 , i , ivar , iside , iel ) + & vector % extBoundary % hostData ( 1 : 2 , i , ivar , iside , iel )) END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedVector2D","tags":"","loc":"proc/bassirebaysides_mappedvector2d.html"},{"title":"BassiRebaySides_MappedVector3D – SELF","text":"public subroutine BassiRebaySides_MappedVector3D(vector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector logical, intent(in) :: gpuAccel Contents Source Code BassiRebaySides_MappedVector3D Source Code SUBROUTINE BassiRebaySides_MappedVector3D ( vector , gpuAccel ) IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i , j IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedVector3D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & vector % interp % N , & vector % nvar , & vector % nElem ) ELSE DO iel = 1 , vector % nElem DO iside = 1 , 6 DO ivar = 1 , vector % nVar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N vector % boundary % hostData ( 1 : 3 , i , j , ivar , iside , iel ) = 0.5_prec * ( & vector % boundary % hostData ( 1 : 3 , i , j , ivar , iside , iel ) + & vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , iside , iel )) END DO END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedVector3D","tags":"","loc":"proc/bassirebaysides_mappedvector3d.html"},{"title":"ContravariantProjection_MappedVector2D – SELF","text":"public subroutine ContravariantProjection_MappedVector2D(vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( SEMQuad ), intent(in) :: geometry logical, intent(in) :: gpuAccel Contents Source Code ContravariantProjection_MappedVector2D Source Code SUBROUTINE ContravariantProjection_MappedVector2D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantProjection_MappedVector2D\" ! Takes a vector that has physical space coordinate directions (x,y,z) and projects the vector ! into the the contravariant basis vector directions. Keep in mind that the contravariant basis ! vectors are really the Jacobian weighted contravariant basis vectors IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , ivar , iel REAL ( prec ) :: Fx , Fy IF ( gpuAccel ) THEN CALL ContravariantProjection_MappedVector2D_gpu_wrapper ( vector % interior % deviceData , & geometry % dsdx % interior % deviceData , & vector % interp % N , & vector % nVar , & vector % nElem ) ELSE ! Assume that tensor(j,i) is vector i, component j ! => dot product is done along first dimension ! to project onto computational space DO iel = 1 , vector % nElem DO ivar = 1 , vector % nVar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N Fx = vector % interior % hostData ( 1 , i , j , ivar , iel ) Fy = vector % interior % hostData ( 2 , i , j , ivar , iel ) vector % interior % hostData ( 1 , i , j , ivar , iel ) = & geometry % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iel ) * Fx + & geometry % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iel ) * Fy vector % interior % hostData ( 2 , i , j , ivar , iel ) = & geometry % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iel ) * Fx + & geometry % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iel ) * Fy END DO END DO END DO END DO END IF END SUBROUTINE ContravariantProjection_MappedVector2D","tags":"","loc":"proc/contravariantprojection_mappedvector2d.html"},{"title":"ContravariantProjection_MappedVector3D – SELF","text":"public subroutine ContravariantProjection_MappedVector3D(vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( SEMHex ), intent(in) :: geometry logical, intent(in) :: gpuAccel Contents Source Code ContravariantProjection_MappedVector3D Source Code SUBROUTINE ContravariantProjection_MappedVector3D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantProjection_MappedVector3D\" ! Takes a vector that has physical space coordinate directions (x,y,z) and projects the vector ! into the the contravariant basis vector directions. Keep in mind that the contravariant basis ! vectors are really the Jacobian weighted contravariant basis vectors IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , k , iVar , iEl REAL ( prec ) :: Fx , Fy , Fz IF ( gpuAccel ) THEN CALL ContravariantProjection_MappedVector3D_gpu_wrapper ( vector % interior % deviceData , & geometry % dsdx % interior % deviceData , & vector % interp % N , & vector % nVar , & vector % nElem ) ELSE ! Assume that tensor(j,i) is vector i, component j ! => dot product is done along first dimension to ! project onto computational space DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO k = 0 , vector % interp % N DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N Fx = vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) Fy = vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) Fz = vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * Fx + & geometry % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * Fy + & geometry % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * Fz vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * Fx + & geometry % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * Fy + & geometry % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * Fz vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * Fx + & geometry % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * Fy + & geometry % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * Fz END DO END DO END DO END DO END DO END IF END SUBROUTINE ContravariantProjection_MappedVector3D","tags":"","loc":"proc/contravariantprojection_mappedvector3d.html"},{"title":"Derivative_MappedScalar1D – SELF","text":"public subroutine Derivative_MappedScalar1D(scalar, geometry, dF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: scalar type( Geometry1D ), intent(in) :: geometry type( MappedScalar1D ), intent(inout) :: dF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Derivative_MappedScalar1D Source Code SUBROUTINE Derivative_MappedScalar1D ( scalar , geometry , dF , dForm , gpuAccel ) ! Strong Form Operator ! ! Calculates the gradient of a scalar 1D function using the conservative form of the ! mapped gradient operator ! ! df/dx =  d\\xi/dx( df/d\\xi ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( in ) :: scalar TYPE ( Geometry1D ), INTENT ( in ) :: geometry TYPE ( MappedScalar1D ), INTENT ( inout ) :: dF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL scalar % interp % DGDerivative_1D ( scalar % interior % deviceData , & scalar % boundary % deviceData , & df % interior % deviceData , & scalar % nVar , & scalar % nElem ) ELSE CALL scalar % interp % DGDerivative_1D ( scalar % interior % hostData , & scalar % boundary % hostData , & df % interior % hostData , & scalar % nVar , & scalar % nElem ) END IF ELSEIF ( dForm == selfWeakBRForm ) THEN IF ( gpuAccel ) THEN CALL scalar % interp % DGDerivative_1D ( scalar % interior % deviceData , & scalar % avgBoundary % deviceData , & df % interior % deviceData , & scalar % nVar , & scalar % nElem ) ELSE CALL scalar % interp % DGDerivative_1D ( scalar % interior % hostData , & scalar % avgBoundary % hostData , & df % interior % hostData , & scalar % nVar , & scalar % nElem ) END IF ELSEIF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL scalar % interp % Derivative_1D ( scalar % interior % deviceData , & df % interior % deviceData , & scalar % nVar , & scalar % nElem ) ELSE CALL scalar % interp % Derivative_1D ( scalar % interior % hostData , & df % interior % hostData , & scalar % nVar , & scalar % nElem ) END IF END IF CALL df % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Derivative_MappedScalar1D","tags":"","loc":"proc/derivative_mappedscalar1d.html"},{"title":"Divergence_MappedVector2D – SELF","text":"public subroutine Divergence_MappedVector2D(compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: compVector type( SEMQuad ), intent(in) :: geometry type( MappedScalar2D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Divergence_MappedVector2D Source Code SUBROUTINE Divergence_MappedVector2D ( compVector , geometry , divVector , dForm , gpuAccel ) ! Strong Form Operator ! ! DG Weak Form Operator ! ! Assumes vector has been projected to computational coordinates ! IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: compVector TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedScalar2D ), INTENT ( inout ) :: divVector INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDGDivergence_2D ( compVector % interior % deviceData , & compVector % boundaryNormal % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDGDivergence_2D ( compVector % interior % hostData , & compVector % boundaryNormal % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDivergence_2D ( compVector % interior % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDivergence_2D ( compVector % interior % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF END IF CALL divVector % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Divergence_MappedVector2D","tags":"","loc":"proc/divergence_mappedvector2d.html"},{"title":"Divergence_MappedVector3D – SELF","text":"public subroutine Divergence_MappedVector3D(compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: compVector type( SEMHex ), intent(in) :: geometry type( MappedScalar3D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Divergence_MappedVector3D Source Code SUBROUTINE Divergence_MappedVector3D ( compVector , geometry , divVector , dForm , gpuAccel ) ! IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: compVector TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedScalar3D ), INTENT ( inout ) :: divVector INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDGDivergence_3D ( compVector % interior % deviceData , & compVector % boundaryNormal % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDGDivergence_3D ( compVector % interior % hostData , & compVector % boundaryNormal % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDivergence_3D ( compVector % interior % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDivergence_3D ( compVector % interior % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF END IF CALL divVector % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Divergence_MappedVector3D","tags":"","loc":"proc/divergence_mappedvector3d.html"},{"title":"GradientBR_MappedScalar2D – SELF","text":"public subroutine GradientBR_MappedScalar2D(scalar, geometry, gradF, gpuAccel) Calculates the gradient of a scalar 2D function using a bassi-rebay method This method will call the BassiRebaySides method, which assumes the SideExchange\nhas already been completed, to update the avgBoundary attribute. Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( SEMQuad ), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF logical, intent(in) :: gpuAccel Contents Source Code GradientBR_MappedScalar2D Source Code SUBROUTINE GradientBR_MappedScalar2D ( scalar , geometry , gradF , gpuAccel ) !! Calculates the gradient of a scalar 2D function using a bassi-rebay method !! !! This method will call the BassiRebaySides method, which assumes the SideExchange !! has already been completed, to update the avgBoundary attribute. !! IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedVector2D ), INTENT ( inout ) :: gradF LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: gFx , gFy REAL ( prec ) :: f1 , f2 CALL scalar % BassiRebaySides ( gpuAccel ) IF ( gpuAccel ) THEN CALL GradientBR_MappedScalar2D_gpu_wrapper ( scalar % interior % deviceData , & scalar % avgBoundary % deviceData , & geometry % dsdx % interior % deviceData , & geometry % J % interior % deviceData , & geometry % nHat % boundary % deviceData , & geometry % nScale % boundary % deviceData , & gradF % interior % deviceData , & scalar % interp % dgMatrix % deviceData , & scalar % interp % bMatrix % deviceData , & scalar % interp % qWeights % deviceData , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N gFx = 0.0_prec gFy = 0.0_prec DO ii = 0 , scalar % interp % N f1 = scalar % interior % hostData ( ii , j , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 1 , ii , j , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 2 , i , ii , 1 , iEl ) gFx = gFx + scalar % interp % dgMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dgMatrix % hostData ( ii , j ) * f2 f1 = scalar % interior % hostData ( ii , j , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 1 , ii , j , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 2 , i , ii , 1 , iEl ) gFy = gFy + scalar % interp % dgMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dgMatrix % hostData ( ii , j ) * f2 END DO ! Boundary Contribution f1 = scalar % avgBoundary % hostData ( j , iVar , 2 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , j , 1 , 2 , iEl ) * & geometry % nScale % boundary % hostData ( j , 1 , 2 , iEl ) ! East f2 = scalar % avgBoundary % hostData ( j , iVar , 4 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , j , 1 , 4 , iEl ) * & geometry % nScale % boundary % hostData ( j , 1 , 4 , iEl ) ! West gFx = gFx + ( f1 * scalar % interp % bMatrix % hostData ( i , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( i , 0 )) / & scalar % interp % qWeights % hostData ( i ) f1 = scalar % avgBoundary % hostData ( i , iVar , 3 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , i , 1 , 3 , iEl ) * & geometry % nScale % boundary % hostData ( i , 1 , 3 , iEl ) ! North f2 = scalar % avgBoundary % hostData ( i , iVar , 1 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , i , 1 , 1 , iEl ) * & geometry % nScale % boundary % hostData ( i , 1 , 1 , iEl ) ! South gFx = gFx + ( f1 * scalar % interp % bMatrix % hostData ( j , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( j , 0 )) / & scalar % interp % qWeights % hostData ( j ) f1 = scalar % avgBoundary % hostData ( j , iVar , 2 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , j , 1 , 2 , iEl ) * & geometry % nScale % boundary % hostData ( j , 1 , 2 , iEl ) ! East f2 = scalar % avgBoundary % hostData ( j , iVar , 4 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , j , 1 , 4 , iEl ) * & geometry % nScale % boundary % hostData ( j , 1 , 4 , iEl ) ! West gFy = gFy + ( f1 * scalar % interp % bMatrix % hostData ( i , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( i , 0 )) / & scalar % interp % qWeights % hostData ( i ) f1 = scalar % avgBoundary % hostData ( i , iVar , 3 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , i , 1 , 3 , iEl ) * & geometry % nScale % boundary % hostData ( i , 1 , 3 , iEl ) ! North f2 = scalar % avgBoundary % hostData ( i , iVar , 1 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , i , 1 , 1 , iEl ) * & geometry % nScale % boundary % hostData ( i , 1 , 1 , iEl ) ! South gFy = gFy + ( f1 * scalar % interp % bMatrix % hostData ( j , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( j , 0 )) / & scalar % interp % qWeights % hostData ( j ) gradF % interior % hostData ( 1 , i , j , iVar , iEl ) = gFx / geometry % J % interior % hostData ( i , j , 1 , iEl ) gradF % interior % hostData ( 2 , i , j , iVar , iEl ) = gFy / geometry % J % interior % hostData ( i , j , 1 , iEl ) END DO END DO END DO END DO ENDIF END SUBROUTINE GradientBR_MappedScalar2D","tags":"","loc":"proc/gradientbr_mappedscalar2d.html"},{"title":"GradientBR_MappedScalar3D – SELF","text":"public subroutine GradientBR_MappedScalar3D(scalar, geometry, gradF, gpuAccel) Calculates the gradient of a scalar 3D function using a bassi-rebay method This method will call the BassiRebaySides method, which assumes the SideExchange\nhas already been completed, to update the avgBoundary attribute. Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( SEMHex ), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF logical, intent(in) :: gpuAccel Contents Source Code GradientBR_MappedScalar3D Source Code SUBROUTINE GradientBR_MappedScalar3D ( scalar , geometry , gradF , gpuAccel ) !! Calculates the gradient of a scalar 3D function using a bassi-rebay method !! !! This method will call the BassiRebaySides method, which assumes the SideExchange !! has already been completed, to update the avgBoundary attribute. !! IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedVector3D ), INTENT ( inout ) :: gradF LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , k , ii , iVar , iEl REAL ( prec ) :: gFx , gFy , gFz REAL ( prec ) :: f1 , f2 , f3 CALL scalar % BassiRebaySides ( gpuAccel ) IF ( gpuAccel ) THEN CALL GradientBR_MappedScalar3D_gpu_wrapper ( scalar % interior % deviceData , & scalar % avgBoundary % deviceData , & geometry % dsdx % interior % deviceData , & geometry % J % interior % deviceData , & geometry % nHat % boundary % deviceData , & geometry % nScale % boundary % deviceData , & gradF % interior % deviceData , & scalar % interp % dgMatrix % deviceData , & scalar % interp % bMatrix % deviceData , & scalar % interp % qWeights % deviceData , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % interp % N DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N gFx = 0.0_prec gFy = 0.0_prec gFz = 0.0_prec DO ii = 0 , scalar % interp % N f1 = scalar % interior % hostData ( ii , j , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 1 , ii , j , k , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 2 , i , ii , k , 1 , iEl ) f3 = scalar % interior % hostData ( i , j , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 3 , i , j , ii , 1 , iEl ) gFx = gFx + scalar % interp % dgMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dgMatrix % hostData ( ii , j ) * f2 + & scalar % interp % dgMatrix % hostData ( ii , k ) * f3 f1 = scalar % interior % hostData ( ii , j , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 1 , ii , j , k , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 2 , i , ii , k , 1 , iEl ) f3 = scalar % interior % hostData ( i , j , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 3 , i , j , ii , 1 , iEl ) gFy = gFy + scalar % interp % dgMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dgMatrix % hostData ( ii , j ) * f2 + & scalar % interp % dgMatrix % hostData ( ii , k ) * f3 f1 = scalar % interior % hostData ( ii , j , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 3 , 1 , ii , j , k , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 3 , 2 , i , ii , k , 1 , iEl ) f3 = scalar % interior % hostData ( i , j , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 3 , 3 , i , j , ii , 1 , iEl ) gFz = gFz + scalar % interp % dgMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dgMatrix % hostData ( ii , j ) * f2 + & scalar % interp % dgMatrix % hostData ( ii , k ) * f3 END DO ! Boundary Contribution f1 = scalar % avgBoundary % hostData ( j , k , iVar , 2 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , j , k , 1 , 2 , iEl ) * & geometry % nScale % boundary % hostData ( j , k , 1 , 2 , iEl ) ! East f2 = scalar % avgBoundary % hostData ( j , k , iVar , 4 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , j , k , 1 , 4 , iEl ) * & geometry % nScale % boundary % hostData ( j , k , 1 , 4 , iEl ) ! West gFx = gFx + ( f1 * scalar % interp % bMatrix % hostData ( i , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( i , 0 )) / & scalar % interp % qWeights % hostData ( i ) f1 = scalar % avgBoundary % hostData ( i , k , iVar , 3 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , i , k , 1 , 3 , iEl ) * & geometry % nScale % boundary % hostData ( i , k , 1 , 3 , iEl ) ! North f2 = scalar % avgBoundary % hostData ( i , k , iVar , 1 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , i , k , 1 , 1 , iEl ) * & geometry % nScale % boundary % hostData ( i , k , 1 , 1 , iEl ) ! South gFx = gFx + ( f1 * scalar % interp % bMatrix % hostData ( j , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( j , 0 )) / & scalar % interp % qWeights % hostData ( j ) f1 = scalar % avgBoundary % hostData ( i , j , iVar , 6 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , i , j , 1 , 6 , iEl ) * & geometry % nScale % boundary % hostData ( i , j , 1 , 6 , iEl ) ! Top f2 = scalar % avgBoundary % hostData ( i , j , iVar , 5 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , i , j , 1 , 5 , iEl ) * & geometry % nScale % boundary % hostData ( i , j , 1 , 5 , iEl ) ! Bottom gFx = gFx + ( f1 * scalar % interp % bMatrix % hostData ( k , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( k , 0 )) / & scalar % interp % qWeights % hostData ( k ) f1 = scalar % avgBoundary % hostData ( j , k , iVar , 2 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , j , k , 1 , 2 , iEl ) * & geometry % nScale % boundary % hostData ( j , k , 1 , 2 , iEl ) ! East f2 = scalar % avgBoundary % hostData ( j , k , iVar , 4 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , j , k , 1 , 4 , iEl ) * & geometry % nScale % boundary % hostData ( j , k , 1 , 4 , iEl ) ! West gFy = gFy + ( f1 * scalar % interp % bMatrix % hostData ( i , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( i , 0 )) / & scalar % interp % qWeights % hostData ( i ) f1 = scalar % avgBoundary % hostData ( i , k , iVar , 3 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , i , k , 1 , 3 , iEl ) * & geometry % nScale % boundary % hostData ( i , k , 1 , 3 , iEl ) ! North f2 = scalar % avgBoundary % hostData ( i , k , iVar , 1 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , i , k , 1 , 1 , iEl ) * & geometry % nScale % boundary % hostData ( i , k , 1 , 1 , iEl ) ! South gFy = gFy + ( f1 * scalar % interp % bMatrix % hostData ( j , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( j , 0 )) / & scalar % interp % qWeights % hostData ( j ) f1 = scalar % avgBoundary % hostData ( i , j , iVar , 6 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , i , j , 1 , 6 , iEl ) * & geometry % nScale % boundary % hostData ( i , j , 1 , 6 , iEl ) ! Top f2 = scalar % avgBoundary % hostData ( i , j , iVar , 5 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , i , j , 1 , 5 , iEl ) * & geometry % nScale % boundary % hostData ( i , j , 1 , 5 , iEl ) ! Bottom gFy = gFy + ( f1 * scalar % interp % bMatrix % hostData ( k , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( k , 0 )) / & scalar % interp % qWeights % hostData ( k ) f1 = scalar % avgBoundary % hostData ( j , k , iVar , 2 , iEl ) * & geometry % nHat % boundary % hostData ( 3 , j , k , 1 , 2 , iEl ) * & geometry % nScale % boundary % hostData ( j , k , 1 , 2 , iEl ) ! East f2 = scalar % avgBoundary % hostData ( j , k , iVar , 4 , iEl ) * & geometry % nHat % boundary % hostData ( 3 , j , k , 1 , 4 , iEl ) * & geometry % nScale % boundary % hostData ( j , k , 1 , 4 , iEl ) ! West gFz = gFz + ( f1 * scalar % interp % bMatrix % hostData ( i , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( i , 0 )) / & scalar % interp % qWeights % hostData ( i ) f1 = scalar % avgBoundary % hostData ( i , k , iVar , 3 , iEl ) * & geometry % nHat % boundary % hostData ( 3 , i , k , 1 , 3 , iEl ) * & geometry % nScale % boundary % hostData ( i , k , 1 , 3 , iEl ) ! North f2 = scalar % avgBoundary % hostData ( i , k , iVar , 1 , iEl ) * & geometry % nHat % boundary % hostData ( 3 , i , k , 1 , 1 , iEl ) * & geometry % nScale % boundary % hostData ( i , k , 1 , 1 , iEl ) ! South gFz = gFz + ( f1 * scalar % interp % bMatrix % hostData ( j , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( j , 0 )) / & scalar % interp % qWeights % hostData ( j ) f1 = scalar % avgBoundary % hostData ( i , j , iVar , 6 , iEl ) * & geometry % nHat % boundary % hostData ( 3 , i , j , 1 , 6 , iEl ) * & geometry % nScale % boundary % hostData ( i , j , 1 , 6 , iEl ) ! Top f2 = scalar % avgBoundary % hostData ( i , j , iVar , 5 , iEl ) * & geometry % nHat % boundary % hostData ( 3 , i , j , 1 , 5 , iEl ) * & geometry % nScale % boundary % hostData ( i , j , 1 , 5 , iEl ) ! Bottom gFz = gFz + ( f1 * scalar % interp % bMatrix % hostData ( k , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( k , 0 )) / & scalar % interp % qWeights % hostData ( k ) gradF % interior % hostData ( 1 , i , j , k , iVar , iEl ) = gFx / geometry % J % interior % hostData ( i , j , k , 1 , iEl ) gradF % interior % hostData ( 2 , i , j , k , iVar , iEl ) = gFy / geometry % J % interior % hostData ( i , j , k , 1 , iEl ) gradF % interior % hostData ( 3 , i , j , k , iVar , iEl ) = gFz / geometry % J % interior % hostData ( i , j , k , 1 , iEl ) END DO END DO END DO END DO END DO ENDIF END SUBROUTINE GradientBR_MappedScalar3D","tags":"","loc":"proc/gradientbr_mappedscalar3d.html"},{"title":"GradientSF_MappedScalar2D – SELF","text":"public subroutine GradientSF_MappedScalar2D(scalar, geometry, gradF, gpuAccel) Calculates the gradient of a scalar 2D function using the conservative form of the\nmapped gradient operator \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) where the sum over i is implied. Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type( SEMQuad ), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF logical, intent(in) :: gpuAccel Contents Source Code GradientSF_MappedScalar2D Source Code SUBROUTINE GradientSF_MappedScalar2D ( scalar , geometry , gradF , gpuAccel ) !! Calculates the gradient of a scalar 2D function using the conservative form of the !! mapped gradient operator !! !! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) !! !! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( in ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedVector2D ), INTENT ( inout ) :: gradF LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: gFx , gFy REAL ( prec ) :: f1 , f2 IF ( gpuAccel ) THEN CALL GradientSF_MappedScalar2D_gpu_wrapper ( scalar % interior % deviceData , & geometry % dsdx % interior % deviceData , & geometry % J % interior % deviceData , & gradF % interior % deviceData , & scalar % interp % dMatrix % deviceData , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N gFx = 0.0_prec gFy = 0.0_prec DO ii = 0 , scalar % interp % N f1 = scalar % interior % hostData ( ii , j , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 1 , ii , j , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 2 , i , ii , 1 , iEl ) gFx = gFx + scalar % interp % dMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dMatrix % hostData ( ii , j ) * f2 f1 = scalar % interior % hostData ( ii , j , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 1 , ii , j , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 2 , i , ii , 1 , iEl ) gFy = gFy + scalar % interp % dMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dMatrix % hostData ( ii , j ) * f2 END DO gradF % interior % hostData ( 1 , i , j , iVar , iEl ) = gFx / geometry % J % interior % hostData ( i , j , 1 , iEl ) gradF % interior % hostData ( 2 , i , j , iVar , iEl ) = gFy / geometry % J % interior % hostData ( i , j , 1 , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE GradientSF_MappedScalar2D","tags":"","loc":"proc/gradientsf_mappedscalar2d.html"},{"title":"GradientSF_MappedScalar3D – SELF","text":"public subroutine GradientSF_MappedScalar3D(scalar, geometry, gradF, gpuAccel) Calculates the gradient of a scalar 3D function using the conservative form of the\nmapped gradient operator \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) where the sum over i is implied. Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type( SEMHex ), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF logical, intent(in) :: gpuAccel Contents Source Code GradientSF_MappedScalar3D Source Code SUBROUTINE GradientSF_MappedScalar3D ( scalar , geometry , gradF , gpuAccel ) !! Calculates the gradient of a scalar 3D function using the conservative form of the !! mapped gradient operator !! !! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) !! !! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( in ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedVector3D ), INTENT ( inout ) :: gradF LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , k , ii , iVar , iEl REAL ( prec ) :: gFx , gFy , gFz REAL ( prec ) :: f1 , f2 , f3 IF ( gpuAccel ) THEN CALL GradientSF_MappedScalar3D_gpu_wrapper ( scalar % interior % deviceData , & geometry % dsdx % interior % deviceData , & geometry % J % interior % deviceData , & gradF % interior % deviceData , & scalar % interp % dMatrix % deviceData , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % interp % N DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N gFx = 0.0_prec gFy = 0.0_prec gFz = 0.0_prec DO ii = 0 , scalar % interp % N f1 = scalar % interior % hostData ( ii , j , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 1 , ii , j , k , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 2 , i , ii , k , 1 , iEl ) f3 = scalar % interior % hostData ( i , j , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 3 , i , j , ii , 1 , iEl ) gFx = gFx + scalar % interp % dMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dMatrix % hostData ( ii , j ) * f2 + & scalar % interp % dMatrix % hostData ( ii , k ) * f3 f1 = scalar % interior % hostData ( ii , j , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 1 , ii , j , k , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 2 , i , ii , k , 1 , iEl ) f3 = scalar % interior % hostData ( i , j , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 2 , i , j , ii , 1 , iEl ) gFy = gFy + scalar % interp % dMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dMatrix % hostData ( ii , j ) * f2 + & scalar % interp % dMatrix % hostData ( ii , k ) * f3 f1 = scalar % interior % hostData ( ii , j , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 3 , 1 , ii , j , k , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 3 , 2 , i , ii , k , 1 , iEl ) f3 = scalar % interior % hostData ( i , j , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 3 , 2 , i , j , ii , 1 , iEl ) gFz = gFz + scalar % interp % dMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dMatrix % hostData ( ii , j ) * f2 + & scalar % interp % dMatrix % hostData ( ii , k ) * f3 END DO gradF % interior % hostData ( 1 , i , j , k , iVar , iEl ) = gFx / geometry % J % interior % hostData ( i , j , k , 1 , iEl ) gradF % interior % hostData ( 2 , i , j , k , iVar , iEl ) = gFy / geometry % J % interior % hostData ( i , j , k , 1 , iEl ) gradF % interior % hostData ( 3 , i , j , k , iVar , iEl ) = gFz / geometry % J % interior % hostData ( i , j , k , 1 , iEl ) END DO END DO ENDDO END DO END DO END IF END SUBROUTINE GradientSF_MappedScalar3D","tags":"","loc":"proc/gradientsf_mappedscalar3d.html"},{"title":"Gradient_MappedScalar2D – SELF","text":"public subroutine Gradient_MappedScalar2D(scalar, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( SEMQuad ), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Gradient_MappedScalar2D Source Code SUBROUTINE Gradient_MappedScalar2D ( scalar , geometry , gradF , dForm , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedVector2D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel if ( dForm == selfStrongForm ) then call scalar % GradientSF_MappedScalar2D ( geometry , gradF , gpuAccel ) elseif ( dForm == selfWeakBRForm ) then call scalar % GradientBR_MappedScalar2D ( geometry , gradF , gpuAccel ) endif END SUBROUTINE Gradient_MappedScalar2D","tags":"","loc":"proc/gradient_mappedscalar2d.html"},{"title":"Gradient_MappedScalar3D – SELF","text":"public subroutine Gradient_MappedScalar3D(scalar, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( SEMHex ), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Gradient_MappedScalar3D Source Code SUBROUTINE Gradient_MappedScalar3D ( scalar , geometry , gradF , dForm , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedVector3D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel if ( dForm == selfStrongForm ) then call scalar % GradientSF_MappedScalar3D ( geometry , gradF , gpuAccel ) elseif ( dForm == selfWeakBRForm ) then call scalar % GradientBR_MappedScalar3D ( geometry , gradF , gpuAccel ) endif END SUBROUTINE Gradient_MappedScalar3D","tags":"","loc":"proc/gradient_mappedscalar3d.html"},{"title":"JacobianWeight_MappedScalar1D – SELF","text":"public subroutine JacobianWeight_MappedScalar1D(scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar type( Geometry1D ), intent(in) :: geometry logical, intent(in) :: gpuAccel Contents Source Code JacobianWeight_MappedScalar1D Source Code SUBROUTINE JacobianWeight_MappedScalar1D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar1D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( inout ) :: scalar TYPE ( Geometry1D ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i IF ( gpuAccel ) THEN CALL JacobianWeight_MappedScalar1D_gpu_wrapper ( scalar % interior % deviceData , & geometry % dxds % interior % deviceData , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO i = 0 , scalar % interp % N scalar % interior % hostData ( i , iVar , iEl ) = scalar % interior % hostData ( i , iVar , iEl ) / & geometry % dxds % interior % hostData ( i , 1 , iEl ) END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedScalar1D","tags":"","loc":"proc/jacobianweight_mappedscalar1d.html"},{"title":"JacobianWeight_MappedScalar2D – SELF","text":"public subroutine JacobianWeight_MappedScalar2D(scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( SEMQuad ), intent(in) :: geometry logical, intent(in) :: gpuAccel Contents Source Code JacobianWeight_MappedScalar2D Source Code SUBROUTINE JacobianWeight_MappedScalar2D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j IF ( gpuAccel ) THEN CALL JacobianWeight_MappedScalar2D_gpu_wrapper ( scalar % interior % deviceData , & geometry % J % interior % deviceData , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N scalar % interior % hostData ( i , j , iVar , iEl ) = scalar % interior % hostData ( i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedScalar2D","tags":"","loc":"proc/jacobianweight_mappedscalar2d.html"},{"title":"JacobianWeight_MappedScalar3D – SELF","text":"public subroutine JacobianWeight_MappedScalar3D(scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( SEMHex ), intent(in) :: geometry logical, intent(in) :: gpuAccel Contents Source Code JacobianWeight_MappedScalar3D Source Code SUBROUTINE JacobianWeight_MappedScalar3D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k IF ( gpuAccel ) THEN CALL JacobianWeight_MappedScalar3D_gpu_wrapper ( scalar % interior % deviceData , & geometry % J % interior % deviceData , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % interp % N DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N scalar % interior % hostData ( i , j , k , iVar , iEl ) = scalar % interior % hostData ( i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) END DO END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedScalar3D","tags":"","loc":"proc/jacobianweight_mappedscalar3d.html"},{"title":"JacobianWeight_MappedVector2D – SELF","text":"public subroutine JacobianWeight_MappedVector2D(vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( SEMQuad ), intent(in) :: geometry logical, intent(in) :: gpuAccel Contents Source Code JacobianWeight_MappedVector2D Source Code SUBROUTINE JacobianWeight_MappedVector2D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedVector2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j IF ( gpuAccel ) THEN CALL JacobianWeight_MappedVector2D_gpu_wrapper ( vector % interior % deviceData , & geometry % J % interior % deviceData , & vector % interp % N , & vector % nVar , & vector % nElem ) ELSE DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N vector % interior % hostData ( 1 , i , j , iVar , iEl ) = vector % interior % hostData ( 1 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) vector % interior % hostData ( 2 , i , j , iVar , iEl ) = vector % interior % hostData ( 2 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedVector2D","tags":"","loc":"proc/jacobianweight_mappedvector2d.html"},{"title":"JacobianWeight_MappedVector3D – SELF","text":"public subroutine JacobianWeight_MappedVector3D(vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( SEMHex ), intent(in) :: geometry logical, intent(in) :: gpuAccel Contents Source Code JacobianWeight_MappedVector3D Source Code SUBROUTINE JacobianWeight_MappedVector3D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedVector3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k IF ( gpuAccel ) THEN CALL JacobianWeight_MappedVector3D_gpu_wrapper ( vector % interior % deviceData , & geometry % J % interior % deviceData , & vector % interp % N , & vector % nVar , & vector % nElem ) ELSE DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO k = 0 , vector % interp % N DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) END DO END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedVector3D","tags":"","loc":"proc/jacobianweight_mappedvector3d.html"},{"title":"MPIExchangeAsync_MappedScalar2D – SELF","text":"public subroutine MPIExchangeAsync_MappedScalar2D(scalar, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( MPILayer ), intent(inout) :: mpiHandler type( Mesh2D ), intent(in) :: mesh logical, intent(in) :: resetCount Contents Source Code MPIExchangeAsync_MappedScalar2D Source Code SUBROUTINE MPIExchangeAsync_MappedScalar2D ( scalar , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , scalar % nElem DO s1 = 1 , 4 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element IF ( e2 > 0 ) THEN r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = ABS ( mesh % sideInfo % hostdata ( 2 , s1 , e1 )) msgCount = msgCount + 1 CALL MPI_IRECV ( scalar % extBoundary % hostData (:,:, s1 , e1 ), & ( scalar % interp % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( scalar % boundary % hostData (:,:, s1 , e1 ), & ( scalar % interp % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) END IF END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedScalar2D","tags":"","loc":"proc/mpiexchangeasync_mappedscalar2d.html"},{"title":"MPIExchangeAsync_MappedScalar3D – SELF","text":"public subroutine MPIExchangeAsync_MappedScalar3D(scalar, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( MPILayer ), intent(inout) :: mpiHandler type( Mesh3D ), intent(in) :: mesh logical, intent(in) :: resetCount Contents Source Code MPIExchangeAsync_MappedScalar3D Source Code SUBROUTINE MPIExchangeAsync_MappedScalar3D ( scalar , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , scalar % nElem DO s1 = 1 , 6 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element IF ( e2 > 0 ) THEN r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = ABS ( mesh % sideInfo % hostdata ( 2 , s1 , e1 )) msgCount = msgCount + 1 CALL MPI_IRECV ( scalar % extBoundary % hostData (:,:,:, s1 , e1 ), & ( scalar % interp % N + 1 ) * ( scalar % interp % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( scalar % boundary % hostData (:,:,:, s1 , e1 ), & ( scalar % interp % N + 1 ) * ( scalar % interp % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) END IF ENDIF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedScalar3D","tags":"","loc":"proc/mpiexchangeasync_mappedscalar3d.html"},{"title":"MPIExchangeAsync_MappedVector2D – SELF","text":"public subroutine MPIExchangeAsync_MappedVector2D(vector, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( MPILayer ), intent(inout) :: mpiHandler type( Mesh2D ), intent(in) :: mesh logical, intent(in) :: resetCount Contents Source Code MPIExchangeAsync_MappedVector2D Source Code SUBROUTINE MPIExchangeAsync_MappedVector2D ( vector , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , vector % nElem DO s1 = 1 , 4 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element IF ( e2 > 0 ) THEN r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = ABS ( mesh % sideInfo % hostdata ( 2 , s1 , e1 )) msgCount = msgCount + 1 CALL MPI_IRECV ( vector % extBoundary % hostData (:,:,:, s1 , e1 ), & 2 * ( vector % interp % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( vector % boundary % hostData (:,:,:, s1 , e1 ), & 2 * ( vector % interp % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) END IF ENDIF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedVector2D","tags":"","loc":"proc/mpiexchangeasync_mappedvector2d.html"},{"title":"MPIExchangeAsync_MappedVector3D – SELF","text":"public subroutine MPIExchangeAsync_MappedVector3D(vector, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( MPILayer ), intent(inout) :: mpiHandler type( Mesh3D ), intent(in) :: mesh logical, intent(in) :: resetCount Contents Source Code MPIExchangeAsync_MappedVector3D Source Code SUBROUTINE MPIExchangeAsync_MappedVector3D ( vector , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , vector % nElem DO s1 = 1 , 6 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = ABS ( mesh % sideInfo % hostdata ( 2 , s1 , e1 )) msgCount = msgCount + 1 CALL MPI_IRECV ( vector % extBoundary % hostData (:,:,:,:, s1 , e1 ), & 3 * ( vector % interp % N + 1 ) * ( vector % interp % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( vector % boundary % hostData (:,:,:,:, s1 , e1 ), & 3 * ( vector % interp % N + 1 ) * ( vector % interp % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedVector3D","tags":"","loc":"proc/mpiexchangeasync_mappedvector3d.html"},{"title":"SetInteriorFromEquation_MappedScalar1D – SELF","text":"public subroutine SetInteriorFromEquation_MappedScalar1D(scalar, geometry, time) Sets the scalar % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar type( Geometry1D ), intent(in) :: geometry real(kind=prec), intent(in) :: time Contents Source Code SetInteriorFromEquation_MappedScalar1D Source Code SUBROUTINE SetInteriorFromEquation_MappedScalar1D ( scalar , geometry , time ) !!  Sets the scalar % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( inout ) :: scalar TYPE ( Geometry1D ), INTENT ( in ) :: geometry REAL ( prec ), INTENT ( in ) :: time ! Local INTEGER :: i , iEl , iVar REAL ( prec ) :: x ! TO DO : Check if scalar % eqn is set before proceeding DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO i = 0 , scalar % interp % N ! Get the mesh positions x = geometry % x % interior % hostData ( i , 1 , iEl ) scalar % interior % hostData ( i , iVar , iEl ) = & scalar % eqn ( iVar ) % Evaluate (( / x , 0.0_prec , 0.0_prec , time / )) ENDDO ENDDO ENDDO END SUBROUTINE SetInteriorFromEquation_MappedScalar1D","tags":"","loc":"proc/setinteriorfromequation_mappedscalar1d.html"},{"title":"SetInteriorFromEquation_MappedScalar2D – SELF","text":"public subroutine SetInteriorFromEquation_MappedScalar2D(scalar, geometry, time) Sets the scalar % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time Contents Source Code SetInteriorFromEquation_MappedScalar2D Source Code SUBROUTINE SetInteriorFromEquation_MappedScalar2D ( scalar , geometry , time ) !!  Sets the scalar % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry REAL ( prec ), INTENT ( in ) :: time ! Local INTEGER :: i , j , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N ! Get the mesh positions x = geometry % x % interior % hostData ( 1 , i , j , 1 , iEl ) y = geometry % x % interior % hostData ( 2 , i , j , 1 , iEl ) scalar % interior % hostData ( i , j , iVar , iEl ) = & scalar % eqn ( iVar ) % Evaluate (( / x , y , 0.0_prec , time / )) ENDDO ENDDO ENDDO ENDDO END SUBROUTINE SetInteriorFromEquation_MappedScalar2D","tags":"","loc":"proc/setinteriorfromequation_mappedscalar2d.html"},{"title":"SetInteriorFromEquation_MappedScalar3D – SELF","text":"public subroutine SetInteriorFromEquation_MappedScalar3D(scalar, geometry, time) Sets the scalar % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time Contents Source Code SetInteriorFromEquation_MappedScalar3D Source Code SUBROUTINE SetInteriorFromEquation_MappedScalar3D ( scalar , geometry , time ) !!  Sets the scalar % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry REAL ( prec ), INTENT ( in ) :: time ! Local INTEGER :: i , j , k , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: z DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % interp % N DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N ! Get the mesh positions x = geometry % x % interior % hostData ( 1 , i , j , k , 1 , iEl ) y = geometry % x % interior % hostData ( 2 , i , j , k , 1 , iEl ) z = geometry % x % interior % hostData ( 3 , i , j , k , 1 , iEl ) scalar % interior % hostData ( i , j , k , iVar , iEl ) = & scalar % eqn ( iVar ) % Evaluate (( / x , y , z , time / )) ENDDO ENDDO ENDDO ENDDO ENDDO END SUBROUTINE SetInteriorFromEquation_MappedScalar3D","tags":"","loc":"proc/setinteriorfromequation_mappedscalar3d.html"},{"title":"SetInteriorFromEquation_MappedVector2D – SELF","text":"public subroutine SetInteriorFromEquation_MappedVector2D(vector, geometry, time) Sets the scalar % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time Contents Source Code SetInteriorFromEquation_MappedVector2D Source Code SUBROUTINE SetInteriorFromEquation_MappedVector2D ( vector , geometry , time ) !!  Sets the scalar % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( SEMQuad ), INTENT ( in ) :: geometry REAL ( prec ), INTENT ( in ) :: time ! Local INTEGER :: i , j , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N ! Get the mesh positions x = geometry % x % interior % hostData ( 1 , i , j , 1 , iEl ) y = geometry % x % interior % hostData ( 2 , i , j , 1 , iEl ) vector % interior % hostData ( 1 , i , j , iVar , iEl ) = & vector % eqn ( 1 + 2 * ( iVar - 1 )) % Evaluate (( / x , y , 0.0_prec , time / )) vector % interior % hostData ( 2 , i , j , iVar , iEl ) = & vector % eqn ( 2 + 2 * ( iVar - 1 )) % Evaluate (( / x , y , 0.0_prec , time / )) ENDDO ENDDO ENDDO ENDDO END SUBROUTINE SetInteriorFromEquation_MappedVector2D","tags":"","loc":"proc/setinteriorfromequation_mappedvector2d.html"},{"title":"SetInteriorFromEquation_MappedVector3D – SELF","text":"public subroutine SetInteriorFromEquation_MappedVector3D(vector, geometry, time) Sets the scalar % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time Contents Source Code SetInteriorFromEquation_MappedVector3D Source Code SUBROUTINE SetInteriorFromEquation_MappedVector3D ( vector , geometry , time ) !!  Sets the scalar % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( SEMHex ), INTENT ( in ) :: geometry REAL ( prec ), INTENT ( in ) :: time ! Local INTEGER :: i , j , k , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: z DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO k = 0 , vector % interp % N DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N ! Get the mesh positions x = geometry % x % interior % hostData ( 1 , i , j , k , 1 , iEl ) y = geometry % x % interior % hostData ( 2 , i , j , k , 1 , iEl ) z = geometry % x % interior % hostData ( 3 , i , j , k , 1 , iEl ) vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) = & vector % eqn ( 1 + 3 * ( iVar - 1 )) % Evaluate (( / x , y , z , time / )) vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) = & vector % eqn ( 2 + 3 * ( iVar - 1 )) % Evaluate (( / x , y , z , time / )) vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) = & vector % eqn ( 3 + 3 * ( iVar - 1 )) % Evaluate (( / x , y , z , time / )) ENDDO ENDDO ENDDO ENDDO ENDDO END SUBROUTINE SetInteriorFromEquation_MappedVector3D","tags":"","loc":"proc/setinteriorfromequation_mappedvector3d.html"},{"title":"SideExchange_MappedScalar1D – SELF","text":"public subroutine SideExchange_MappedScalar1D(scalar, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar type( Mesh1D ), intent(in) :: mesh type( MPILayer ), intent(inout) :: decomp logical, intent(in) :: gpuAccel Contents Source Code SideExchange_MappedScalar1D Source Code SUBROUTINE SideExchange_MappedScalar1D ( scalar , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( inout ) :: scalar TYPE ( Mesh1D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 , e2Global INTEGER :: flip , bcid INTEGER :: i1 , i2 , ivar INTEGER :: neighborRank INTEGER :: rankId , offset rankId = decomp % rankId offset = decomp % offsetElem % hostData ( rankId ) if ( gpuAccel ) then call scalar % boundary % updatehost () endif DO e1 = 1 , mesh % nElem IF ( e1 == 1 ) THEN s1 = 2 e2 = e1 + 1 s2 = 1 !neighborRank = decomp % elemToRank % hostData(e2Global) DO ivar = 1 , scalar % nvar scalar % extBoundary % hostData ( ivar , s1 , e1 ) = scalar % boundary % hostData ( ivar , s2 , e2 ) ENDDO ELSEIF ( e1 == mesh % nElem ) THEN s1 = 1 e2 = e1 - 1 s2 = 2 !neighborRank = decomp % elemToRank % hostData(e2Global) DO ivar = 1 , scalar % nvar scalar % extBoundary % hostData ( ivar , s1 , e1 ) = scalar % boundary % hostData ( ivar , s2 , e2 ) ENDDO ELSE s1 = 1 e2 = e1 - 1 s2 = 2 !neighborRank = decomp % elemToRank % hostData(e2Global) DO ivar = 1 , scalar % nvar scalar % extBoundary % hostData ( ivar , s1 , e1 ) = scalar % boundary % hostData ( ivar , s2 , e2 ) ENDDO s1 = 2 e2 = e1 + 1 s2 = 1 !neighborRank = decomp % elemToRank % hostData(e2Global) DO ivar = 1 , scalar % nvar scalar % extBoundary % hostData ( ivar , s1 , e1 ) = scalar % boundary % hostData ( ivar , s2 , e2 ) ENDDO ENDIF ENDDO if ( gpuAccel ) then call scalar % extBoundary % updatedevice () endif END SUBROUTINE SideExchange_MappedScalar1D","tags":"","loc":"proc/sideexchange_mappedscalar1d.html"},{"title":"SideExchange_MappedScalar2D – SELF","text":"public subroutine SideExchange_MappedScalar2D(scalar, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( Mesh2D ), intent(in) :: mesh type( MPILayer ), intent(inout) :: decomp logical, intent(in) :: gpuAccel Contents Source Code SideExchange_MappedScalar2D Source Code SUBROUTINE SideExchange_MappedScalar2D ( scalar , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( Mesh2D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 , e2Global INTEGER :: flip , bcid INTEGER :: i1 , i2 , ivar INTEGER :: neighborRank INTEGER :: rankId , offset rankId = decomp % rankId offset = decomp % offsetElem % hostData ( rankId ) IF ( gpuAccel ) THEN CALL scalar % boundary % UpdateHost () CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL decomp % FinalizeMPIExchangeAsync () CALL scalar % extBoundary % UpdateDevice () CALL SideExchange_MappedScalar2D_gpu_wrapper ( scalar % extBoundary % deviceData , & scalar % boundary % deviceData , & mesh % sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & offset , & scalar % interp % N , & scalar % nvar , & scalar % nElem ) ELSE CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 4 e2Global = mesh % sideInfo % hostData ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2Global ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , scalar % nvar DO i1 = 0 , scalar % interp % N scalar % extBoundary % hostData ( i1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i1 , ivar , s2 , e2 ) END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , scalar % nvar DO i1 = 0 , scalar % interp % N i2 = scalar % interp % N - i1 scalar % extBoundary % hostData ( i1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , ivar , s2 , e2 ) END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL scalar % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedScalar2D","tags":"","loc":"proc/sideexchange_mappedscalar2d.html"},{"title":"SideExchange_MappedScalar3D – SELF","text":"public subroutine SideExchange_MappedScalar3D(scalar, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( Mesh3D ), intent(in) :: mesh type( MPILayer ), intent(inout) :: decomp logical, intent(in) :: gpuAccel Contents Source Code SideExchange_MappedScalar3D Source Code SUBROUTINE SideExchange_MappedScalar3D ( scalar , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( Mesh3D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 , e2Global INTEGER :: flip , bcid INTEGER :: neighborRank INTEGER :: i1 , i2 , j1 , j2 , ivar INTEGER :: rankId , offset rankId = decomp % rankId offset = decomp % offsetElem % hostData ( rankId ) IF ( gpuAccel ) THEN CALL scalar % boundary % UpdateHost () CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL decomp % FinalizeMPIExchangeAsync () CALL scalar % extBoundary % UpdateDevice () CALL SideExchange_MappedScalar3D_gpu_wrapper ( scalar % extBoundary % deviceData , & scalar % boundary % deviceData , & mesh % sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & offset , & scalar % interp % N , & scalar % nvar , & scalar % nElem ) ELSE CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 6 e2Global = mesh % sideInfo % hostData ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2Global ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN ! Orientation matches on both sides of the face DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % interp % N DO i1 = 0 , scalar % interp % N scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i1 , j1 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % interp % N DO i1 = 0 , scalar % interp % N i2 = j1 j2 = scalar % interp % N - i1 scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 2 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % interp % N DO i1 = 0 , scalar % interp % N i2 = scalar % interp % N - i1 j2 = scalar % interp % N - j1 scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % interp % N DO i1 = 0 , scalar % interp % N i2 = scalar % interp % N - j1 j2 = i1 scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 4 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % interp % N DO i1 = 0 , scalar % interp % N i2 = j1 j2 = i1 scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL scalar % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedScalar3D","tags":"","loc":"proc/sideexchange_mappedscalar3d.html"},{"title":"SideExchange_MappedVector2D – SELF","text":"public subroutine SideExchange_MappedVector2D(vector, mesh, decomp, gpuAccel) SideExchange_MappedVectorvector2D is used to populate vector % extBoundary\nby finding neighboring elements that share a side and copying the neighboring\nelements solution % boundary data. Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( Mesh2D ), intent(in) :: mesh type( MPILayer ), intent(inout) :: decomp logical, intent(in) :: gpuAccel Contents Source Code SideExchange_MappedVector2D Source Code SUBROUTINE SideExchange_MappedVector2D ( vector , mesh , decomp , gpuAccel ) !! SideExchange_MappedVectorvector2D is used to populate vector % extBoundary !! by finding neighboring elements that share a side and copying the neighboring !! elements solution % boundary data. IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( Mesh2D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 , e2Global INTEGER :: flip , bcid INTEGER :: neighborRank INTEGER :: i1 , i2 , ivar INTEGER :: rankId , offset rankId = decomp % rankId offset = decomp % offsetElem % hostData ( rankId ) IF ( gpuAccel ) THEN CALL vector % boundary % UpdateHost () CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL decomp % FinalizeMPIExchangeAsync () CALL vector % extBoundary % UpdateDevice () CALL SideExchange_MappedVector2D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & mesh % sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & offset , & vector % interp % N , & vector % nvar , & vector % nElem ) ELSE CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 4 e2Global = mesh % sideInfo % hostData ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2Global ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , vector % nvar DO i1 = 0 , vector % interp % N vector % extBoundary % hostData ( 1 : 2 , i1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 2 , i1 , ivar , s2 , e2 ) END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , vector % nvar DO i1 = 0 , vector % interp % N i2 = vector % interp % N - i1 vector % extBoundary % hostData ( 1 : 2 , i1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 2 , i2 , ivar , s2 , e2 ) END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL vector % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedVector2D","tags":"","loc":"proc/sideexchange_mappedvector2d.html"},{"title":"SideExchange_MappedVector3D – SELF","text":"public subroutine SideExchange_MappedVector3D(vector, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( Mesh3D ), intent(in) :: mesh type( MPILayer ), intent(inout) :: decomp logical, intent(in) :: gpuAccel Contents Source Code SideExchange_MappedVector3D Source Code SUBROUTINE SideExchange_MappedVector3D ( vector , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( Mesh3D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 , e2Global INTEGER :: flip , bcid INTEGER :: neighborRank INTEGER :: i1 , i2 , j1 , j2 , ivar INTEGER :: rankId , offset rankId = decomp % rankId offset = decomp % offsetElem % hostData ( rankId ) IF ( gpuAccel ) THEN CALL vector % boundary % UpdateHost () CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL decomp % FinalizeMPIExchangeAsync () CALL vector % extBoundary % UpdateDevice () CALL SideExchange_MappedVector3D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & mesh % sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & offset , & vector % interp % N , & vector % nvar , & vector % nElem ) ELSE CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 6 e2Global = mesh % sideInfo % hostData ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN ! Interior neighborRank = decomp % elemToRank % hostData ( e2Global ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % interp % N DO i1 = 0 , vector % interp % N vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i1 , j1 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % interp % N DO i1 = 0 , vector % interp % N i2 = j1 j2 = vector % interp % N - i1 vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 2 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % interp % N DO i1 = 0 , vector % interp % N i2 = vector % interp % N - i1 j2 = vector % interp % N - j1 vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % interp % N DO i1 = 0 , vector % interp % N i2 = vector % interp % N - j1 j2 = i1 vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 4 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % interp % N DO i1 = 0 , vector % interp % N i2 = j1 j2 = i1 vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL vector % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedVector3D","tags":"","loc":"proc/sideexchange_mappedvector3d.html"},{"title":"ApplyFlip_MappedScalar2D_gpu_wrapper – SELF","text":"interface public subroutine ApplyFlip_MappedScalar2D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/applyflip_mappedscalar2d_gpu_wrapper.html"},{"title":"ApplyFlip_MappedScalar3D_gpu_wrapper – SELF","text":"interface public subroutine ApplyFlip_MappedScalar3D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/applyflip_mappedscalar3d_gpu_wrapper.html"},{"title":"ApplyFlip_MappedVector2D_gpu_wrapper – SELF","text":"interface public subroutine ApplyFlip_MappedVector2D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/applyflip_mappedvector2d_gpu_wrapper.html"},{"title":"ApplyFlip_MappedVector3D_gpu_wrapper – SELF","text":"interface public subroutine ApplyFlip_MappedVector3D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/applyflip_mappedvector3d_gpu_wrapper.html"},{"title":"BassiRebaySides_MappedScalar2D_gpu_wrapper – SELF","text":"interface public subroutine BassiRebaySides_MappedScalar2D_gpu_wrapper(avgBoundary, boundary, extBoundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: avgBoundary type(c_ptr) :: boundary type(c_ptr) :: extBoundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/bassirebaysides_mappedscalar2d_gpu_wrapper.html"},{"title":"BassiRebaySides_MappedScalar3D_gpu_wrapper – SELF","text":"interface public subroutine BassiRebaySides_MappedScalar3D_gpu_wrapper(avgBoundary, boundary, extBoundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: avgBoundary type(c_ptr) :: boundary type(c_ptr) :: extBoundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/bassirebaysides_mappedscalar3d_gpu_wrapper.html"},{"title":"BassiRebaySides_MappedVector2D_gpu_wrapper – SELF","text":"interface public subroutine BassiRebaySides_MappedVector2D_gpu_wrapper(extBoundary, boundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/bassirebaysides_mappedvector2d_gpu_wrapper.html"},{"title":"BassiRebaySides_MappedVector3D_gpu_wrapper – SELF","text":"interface public subroutine BassiRebaySides_MappedVector3D_gpu_wrapper(extBoundary, boundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/bassirebaysides_mappedvector3d_gpu_wrapper.html"},{"title":"ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper – SELF","text":"interface public subroutine ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/contravariantprojectionboundary_mappedvector2d_gpu_wrapper.html"},{"title":"ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper – SELF","text":"interface public subroutine ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/contravariantprojectionboundary_mappedvector3d_gpu_wrapper.html"},{"title":"ContravariantProjection_MappedVector2D_gpu_wrapper – SELF","text":"interface public subroutine ContravariantProjection_MappedVector2D_gpu_wrapper(vector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/contravariantprojection_mappedvector2d_gpu_wrapper.html"},{"title":"ContravariantProjection_MappedVector3D_gpu_wrapper – SELF","text":"interface public subroutine ContravariantProjection_MappedVector3D_gpu_wrapper(vector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/contravariantprojection_mappedvector3d_gpu_wrapper.html"},{"title":"GradientBR_MappedScalar2D_gpu_wrapper – SELF","text":"interface public subroutine GradientBR_MappedScalar2D_gpu_wrapper(scalar, avgBoundary, dsdx, jacobian, nHat, nScale, gradF, dgMatrix, bMatrix, qWeights, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: avgBoundary type(c_ptr) :: dsdx type(c_ptr) :: jacobian type(c_ptr) :: nHat type(c_ptr) :: nScale type(c_ptr) :: gradF type(c_ptr) :: dgMatrix type(c_ptr) :: bMatrix type(c_ptr) :: qWeights integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/gradientbr_mappedscalar2d_gpu_wrapper.html"},{"title":"GradientBR_MappedScalar3D_gpu_wrapper – SELF","text":"interface public subroutine GradientBR_MappedScalar3D_gpu_wrapper(scalar, avgBoundary, dsdx, jacobian, nHat, nScale, gradF, dgMatrix, bMatrix, qWeights, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: avgBoundary type(c_ptr) :: dsdx type(c_ptr) :: jacobian type(c_ptr) :: nHat type(c_ptr) :: nScale type(c_ptr) :: gradF type(c_ptr) :: dgMatrix type(c_ptr) :: bMatrix type(c_ptr) :: qWeights integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/gradientbr_mappedscalar3d_gpu_wrapper.html"},{"title":"GradientSF_MappedScalar2D_gpu_wrapper – SELF","text":"interface public subroutine GradientSF_MappedScalar2D_gpu_wrapper(scalar, dsdx, jacobian, gradF, dMatrix, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: dsdx type(c_ptr) :: jacobian type(c_ptr) :: gradF type(c_ptr) :: dMatrix integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/gradientsf_mappedscalar2d_gpu_wrapper.html"},{"title":"GradientSF_MappedScalar3D_gpu_wrapper – SELF","text":"interface public subroutine GradientSF_MappedScalar3D_gpu_wrapper(scalar, dsdx, jacobian, gradF, dMatrix, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: dsdx type(c_ptr) :: jacobian type(c_ptr) :: gradF type(c_ptr) :: dMatrix integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/gradientsf_mappedscalar3d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedScalar1D_gpu_wrapper – SELF","text":"interface public subroutine JacobianWeight_MappedScalar1D_gpu_wrapper(scalar, dxds, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: dxds integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedscalar1d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedScalar2D_gpu_wrapper – SELF","text":"interface public subroutine JacobianWeight_MappedScalar2D_gpu_wrapper(scalar, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedscalar2d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedScalar3D_gpu_wrapper – SELF","text":"interface public subroutine JacobianWeight_MappedScalar3D_gpu_wrapper(scalar, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedscalar3d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedVector2D_gpu_wrapper – SELF","text":"interface public subroutine JacobianWeight_MappedVector2D_gpu_wrapper(vector, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedvector2d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedVector3D_gpu_wrapper – SELF","text":"interface public subroutine JacobianWeight_MappedVector3D_gpu_wrapper(vector, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedvector3d_gpu_wrapper.html"},{"title":"SideExchange_MappedScalar2D_gpu_wrapper – SELF","text":"interface public subroutine SideExchange_MappedScalar2D_gpu_wrapper(extBoundary, boundary, sideInfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: offset integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/sideexchange_mappedscalar2d_gpu_wrapper.html"},{"title":"SideExchange_MappedScalar3D_gpu_wrapper – SELF","text":"interface public subroutine SideExchange_MappedScalar3D_gpu_wrapper(extBoundary, boundary, sideInfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: offset integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/sideexchange_mappedscalar3d_gpu_wrapper.html"},{"title":"SideExchange_MappedVector2D_gpu_wrapper – SELF","text":"interface public subroutine SideExchange_MappedVector2D_gpu_wrapper(extBoundary, boundary, sideInfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: offset integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/sideexchange_mappedvector2d_gpu_wrapper.html"},{"title":"SideExchange_MappedVector3D_gpu_wrapper – SELF","text":"interface public subroutine SideExchange_MappedVector3D_gpu_wrapper(extBoundary, boundary, sideInfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: offset integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/sideexchange_mappedvector3d_gpu_wrapper.html"},{"title":"SetDescription_Metadata – SELF","text":"public subroutine SetDescription_Metadata(mtd, description) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: description Contents Source Code SetDescription_Metadata Source Code SUBROUTINE SetDescription_Metadata ( mtd , description ) IMPLICIT NONE CLASS ( Metadata ), INTENT ( inout ) :: mtd CHARACTER ( * ), INTENT ( in ) :: description mtd % description = description END SUBROUTINE SetDescription_Metadata","tags":"","loc":"proc/setdescription_metadata.html"},{"title":"SetName_Metadata – SELF","text":"public subroutine SetName_Metadata(mtd, name) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: name Contents Source Code SetName_Metadata Source Code SUBROUTINE SetName_Metadata ( mtd , name ) IMPLICIT NONE CLASS ( Metadata ), INTENT ( inout ) :: mtd CHARACTER ( * ), INTENT ( in ) :: name mtd % name = name END SUBROUTINE SetName_Metadata","tags":"","loc":"proc/setname_metadata.html"},{"title":"SetUnits_Metadata – SELF","text":"public subroutine SetUnits_Metadata(mtd, units) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: units Contents Source Code SetUnits_Metadata Source Code SUBROUTINE SetUnits_Metadata ( mtd , units ) IMPLICIT NONE CLASS ( Metadata ), INTENT ( inout ) :: mtd CHARACTER ( * ), INTENT ( in ) :: units mtd % units = units END SUBROUTINE SetUnits_Metadata","tags":"","loc":"proc/setunits_metadata.html"},{"title":"WriteHDF5_Metadata – SELF","text":"public subroutine WriteHDF5_Metadata(mtd, group, varid, fileId) Writes the metadata to a HDF5 file using the \nfields :\n * /metadata/{group}/name/{varid} * /metadata/{group}/description/{varid} * /metadata/{group}/units/{varid} This method assumes that an HDF5 file is already\nopen for writing and is associated with the fileId input. Arguments Type Intent Optional Attributes Name class( Metadata ), intent(in) :: mtd character, intent(in) :: group integer, intent(in) :: varid integer(kind=HID_T), intent(in) :: fileId Contents Source Code WriteHDF5_Metadata Source Code SUBROUTINE WriteHDF5_Metadata ( mtd , group , varid , fileId ) !! Writes the metadata to a HDF5 file using the !! fields : !!  * `/metadata/{group}/name/{varid}` !!  * `/metadata/{group}/description/{varid}` !!  * `/metadata/{group}/units/{varid}` !! !! This method assumes that an HDF5 file is already !! open for writing and is associated with the `fileId` !! input. CLASS ( Metadata ), INTENT ( in ) :: mtd CHARACTER ( * ), INTENT ( in ) :: group INTEGER , INTENT ( in ) :: varid INTEGER ( HID_T ), INTENT ( in ) :: fileId ! Local CHARACTER ( 4 ) :: varNumber ! Add variable names to the file CALL CreateGroup_HDF5 ( fileId , TRIM ( group ) // \"/metadata\" ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group ) // \"/metadata/name\" ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group ) // \"/metadata/description\" ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group ) // \"/metadata/units\" ) WRITE ( varNumber , \"(I0)\" ) varid CALL WriteCharacter_HDF5 ( fileId , TRIM ( group ) // \"/metadata/name/\" // TRIM ( varnumber ), & TRIM ( mtd % name )) CALL WriteCharacter_HDF5 ( fileId , TRIM ( group ) // \"/metadata/description/\" // TRIM ( varnumber ), & TRIM ( mtd % description )) CALL WriteCharacter_HDF5 ( fileId , TRIM ( group ) // \"/metadata/units/\" // TRIM ( varnumber ), & TRIM ( mtd % units )) END SUBROUTINE WriteHDF5_Metadata","tags":"","loc":"proc/writehdf5_metadata.html"},{"title":"CalculateFluxDivergence_Model1D – SELF","text":"public subroutine CalculateFluxDivergence_Model1D(this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this Contents Source Code CalculateFluxDivergence_Model1D Source Code SUBROUTINE CalculateFluxDivergence_Model1D ( this ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CALL this % flux % Derivative ( this % geometry , & this % fluxDivergence , & selfWeakDGForm , & this % gpuAccel ) END SUBROUTINE CalculateFluxDivergence_Model1D","tags":"","loc":"proc/calculatefluxdivergence_model1d.html"},{"title":"CalculateTendency_Model1D – SELF","text":"public subroutine CalculateTendency_Model1D(this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this Contents Source Code CalculateTendency_Model1D Source Code SUBROUTINE CalculateTendency_Model1D ( this ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this ! Local INTEGER :: i , iVar , iEl CALL this % solution % BoundaryInterp ( this % gpuAccel ) CALL this % solution % SideExchange ( this % mesh , this % decomp , this % gpuAccel ) CALL this % PreTendency () CALL this % SetBoundaryCondition () CALL this % SourceMethod () CALL this % RiemannSolver () CALL this % FluxMethod () CALL this % CalculateFluxDivergence () IF ( this % gpuAccel ) THEN CALL CalculateDSDt_Model1D_gpu_wrapper ( this % fluxDivergence % interior % deviceData , & this % source % interior % deviceData , & this % dSdt % interior % deviceData , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % dSdt % interior % hostData ( i , iVar , iEl ) = & this % source % interior % hostData ( i , iVar , iEl ) - & this % fluxDivergence % interior % hostData ( i , iVar , iEl ) END DO END DO END DO END IF END SUBROUTINE CalculateTendency_Model1D","tags":"","loc":"proc/calculatetendency_model1d.html"},{"title":"Free_Model1D – SELF","text":"public subroutine Free_Model1D(this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this Contents Source Code Free_Model1D Source Code SUBROUTINE Free_Model1D ( this ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CALL this % solution % Free () CALL this % workSol % Free () CALL this % prevSol % Free () CALL this % velocity % Free () CALL this % dSdt % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () END SUBROUTINE Free_Model1D","tags":"","loc":"proc/free_model1d.html"},{"title":"Init_Model1D – SELF","text":"public subroutine Init_Model1D(this, nvar, mesh, geometry, decomp) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), TARGET :: mesh type( Geometry1D ), intent(in), TARGET :: geometry type( MPILayer ), intent(in), TARGET :: decomp Contents Source Code Init_Model1D Source Code SUBROUTINE Init_Model1D ( this , nvar , mesh , geometry , decomp ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: nvar TYPE ( Mesh1D ), INTENT ( in ), TARGET :: mesh TYPE ( Geometry1D ), INTENT ( in ), TARGET :: geometry TYPE ( MPILayer ), INTENT ( in ), TARGET :: decomp this % decomp => decomp this % mesh => mesh this % geometry => geometry this % gpuAccel = . FALSE . CALL this % solution % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % workSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % prevSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % velocity % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % dSdt % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % solutionGradient % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % flux % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % source % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % fluxDivergence % Init ( geometry % x % interp , nVar , this % mesh % nElem ) END SUBROUTINE Init_Model1D","tags":"","loc":"proc/init_model1d.html"},{"title":"Read_Model1D – SELF","text":"public subroutine Read_Model1D(this, fileName) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character, intent(in) :: fileName Contents Source Code Read_Model1D Source Code SUBROUTINE Read_Model1D ( this , fileName ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 3 ) INTEGER :: firstElem INTEGER :: N IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % decomp % mpiComm ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) END IF ! CALL ReadAttribute_HDF5(fileId,'N',N) ! IF (this % solution % interp % N /= N) THEN !   STOP 'Error : Solution polynomial degree does not match input file' ! END IF IF ( this % decomp % mpiEnabled ) THEN firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 3 ) = ( / 0 , 1 , firstElem / ) CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , & this % solution % interior , solOffset ) ELSE CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , this % solution % interior ) END IF CALL Close_HDF5 ( fileId ) IF ( this % gpuAccel ) THEN CALL this % solution % interior % UpdateDevice () END IF END SUBROUTINE Read_Model1D","tags":"","loc":"proc/read_model1d.html"},{"title":"ResizePrevSol_Model1D – SELF","text":"public subroutine ResizePrevSol_Model1D(this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code ResizePrevSol_Model1D Source Code SUBROUTINE ResizePrevSol_Model1D ( this , m ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: nVar ! Free space, if necessary CALL this % prevSol % Free () ! Reallocate with increased variable dimension for ! storing \"m\" copies of solution data nVar = this % solution % nVar CALL this % prevSol % Init ( this % geometry % x % interp , m * nVar , this % mesh % nElem ) END SUBROUTINE ResizePrevSol_Model1D","tags":"","loc":"proc/resizeprevsol_model1d.html"},{"title":"SetSolutionFromChar_Model1D – SELF","text":"public subroutine SetSolutionFromChar_Model1D(this, eqnChar) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) Contents Source Code SetSolutionFromChar_Model1D Source Code SUBROUTINE SetSolutionFromChar_Model1D ( this , eqnChar ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CHARACTER ( LEN = SELF_EQUATION_LENGTH ), INTENT ( in ) :: eqnChar ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar DO iVar = 1 , this % solution % nVar PRINT * , iVar , eqnChar ( iVar ) CALL this % solution % SetEquation ( ivar , eqnChar ( iVar )) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromChar_Model1D","tags":"","loc":"proc/setsolutionfromchar_model1d.html"},{"title":"SetSolutionFromEqn_Model1D – SELF","text":"public subroutine SetSolutionFromEqn_Model1D(this, eqn) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) Contents Source Code SetSolutionFromEqn_Model1D Source Code SUBROUTINE SetSolutionFromEqn_Model1D ( this , eqn ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar ! Copy the equation parser DO iVar = 1 , this % solution % nVar CALL this % solution % SetEquation ( ivar , eqn ( iVar ) % equation ) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromEqn_Model1D","tags":"","loc":"proc/setsolutionfromeqn_model1d.html"},{"title":"UpdateDevice_Model1D – SELF","text":"public subroutine UpdateDevice_Model1D(this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this Contents Source Code UpdateDevice_Model1D Source Code SUBROUTINE UpdateDevice_Model1D ( this ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CALL this % mesh % UpdateDevice () CALL this % geometry % UpdateDevice () CALL this % dSdt % UpdateDevice () CALL this % solution % UpdateDevice () CALL this % velocity % UpdateDevice () CALL this % solutionGradient % UpdateDevice () CALL this % flux % UpdateDevice () CALL this % source % UpdateDevice () CALL this % fluxDivergence % UpdateDevice () END SUBROUTINE UpdateDevice_Model1D","tags":"","loc":"proc/updatedevice_model1d.html"},{"title":"UpdateGAB2_Model1D – SELF","text":"public subroutine UpdateGAB2_Model1D(this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGAB2_Model1D Source Code SUBROUTINE UpdateGAB2_Model1D ( this , m ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB2_Model1D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE ! ab2_weight IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Copy the solution back from prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , iVar , iEl ) = this % prevSol % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N ! Bump the last solution nVar = this % solution % nVar this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) this % solution % interior % hostData ( i , iVar , iEl ) = & 1.5_PREC * this % prevSol % interior % hostData ( i , iVar , iEl ) - & 0.5_PREC * this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB2_Model1D","tags":"","loc":"proc/updategab2_model1d.html"},{"title":"UpdateGAB3_Model1D – SELF","text":"public subroutine UpdateGAB3_Model1D(this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGAB3_Model1D Source Code SUBROUTINE UpdateGAB3_Model1D ( this , m ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB3_Model1D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSEIF ( m == 2 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , iVar , iEl ) = this % prevSol % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions nVar = this % solution % nVar this % prevSol % interior % hostData ( i , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) this % solution % interior % hostData ( i , iVar , iEl ) = & ( 2 3.0_PREC * this % prevSol % interior % hostData ( i , iVar , iEl ) - & 1 6.0_PREC * this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) + & 5.0_PREC * this % prevSol % interior % hostData ( i , 2 * nVar + iVar , iEl )) / 1 2.0_PREC END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB3_Model1D","tags":"","loc":"proc/updategab3_model1d.html"},{"title":"UpdateGAB4_Model1D – SELF","text":"public subroutine UpdateGAB4_Model1D(this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGAB4_Model1D Source Code SUBROUTINE UpdateGAB4_Model1D ( this , m ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB4_Model1D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , 2 * nVar + iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSEIF ( m == 2 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSEIF ( m == 3 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , iVar , iEl ) = this % prevSol % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions this % prevSol % interior % hostData ( i , 3 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , 2 * nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) this % solution % interior % hostData ( i , iVar , iEl ) = & ( 5 5.0_PREC * this % prevSol % interior % hostData ( i , iVar , iEl ) - & 5 9.0_PREC * this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) + & 3 7.0_PREC * this % prevSol % interior % hostData ( i , 2 * nVar + iVar , iEl ) - & 9.0_PREC * this % prevSol % interior % hostData ( i , 3 * nVar + iVar , iEl )) / 2 4.0_PREC END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB4_Model1D","tags":"","loc":"proc/updategab4_model1d.html"},{"title":"UpdateGRK2_Model1D – SELF","text":"public subroutine UpdateGRK2_Model1D(this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK2_Model1D Source Code SUBROUTINE UpdateGRK2_Model1D ( this , m ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model1D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk2_a ( m ), rk2_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , iVar , iEl ) = rk2_a ( m ) * & this % workSol % interior % hostData ( i , iVar , iEl ) + & this % dSdt % interior % hostData ( i , iVar , iEl ) this % solution % interior % hostData ( i , iVar , iEl ) = & this % solution % interior % hostData ( i , iVar , iEl ) + & rk2_g ( m ) * this % dt * this % workSol % interior % hostData ( i , iVar , iEl ) END DO END DO END DO END IF END SUBROUTINE UpdateGRK2_Model1D","tags":"","loc":"proc/updategrk2_model1d.html"},{"title":"UpdateGRK3_Model1D – SELF","text":"public subroutine UpdateGRK3_Model1D(this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK3_Model1D Source Code SUBROUTINE UpdateGRK3_Model1D ( this , m ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model1D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk3_a ( m ), rk3_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , iVar , iEl ) = rk3_a ( m ) * & this % workSol % interior % hostData ( i , iVar , iEl ) + & this % dSdt % interior % hostData ( i , iVar , iEl ) this % solution % interior % hostData ( i , iVar , iEl ) = & this % solution % interior % hostData ( i , iVar , iEl ) + & rk3_g ( m ) * this % dt * this % workSol % interior % hostData ( i , iVar , iEl ) END DO END DO END DO END IF END SUBROUTINE UpdateGRK3_Model1D","tags":"","loc":"proc/updategrk3_model1d.html"},{"title":"UpdateGRK4_Model1D – SELF","text":"public subroutine UpdateGRK4_Model1D(this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK4_Model1D Source Code SUBROUTINE UpdateGRK4_Model1D ( this , m ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model1D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk4_a ( m ), rk4_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , iVar , iEl ) = rk4_a ( m ) * & this % workSol % interior % hostData ( i , iVar , iEl ) + & this % dSdt % interior % hostData ( i , iVar , iEl ) this % solution % interior % hostData ( i , iVar , iEl ) = & this % solution % interior % hostData ( i , iVar , iEl ) + & rk4_g ( m ) * this % dt * this % workSol % interior % hostData ( i , iVar , iEl ) END DO END DO END DO END IF END SUBROUTINE UpdateGRK4_Model1D","tags":"","loc":"proc/updategrk4_model1d.html"},{"title":"UpdateHost_Model1D – SELF","text":"public subroutine UpdateHost_Model1D(this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this Contents Source Code UpdateHost_Model1D Source Code SUBROUTINE UpdateHost_Model1D ( this ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CALL this % mesh % UpdateHost () CALL this % geometry % UpdateHost () CALL this % velocity % UpdateHost () CALL this % solution % UpdateHost () CALL this % dSdt % UpdateHost () CALL this % solutionGradient % UpdateHost () CALL this % flux % UpdateHost () CALL this % source % UpdateHost () CALL this % fluxDivergence % UpdateHost () END SUBROUTINE UpdateHost_Model1D","tags":"","loc":"proc/updatehost_model1d.html"},{"title":"UpdateSolution_Model1D – SELF","text":"public subroutine UpdateSolution_Model1D(this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt Contents Source Code UpdateSolution_Model1D Source Code SUBROUTINE UpdateSolution_Model1D ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this REAL ( prec ), OPTIONAL , INTENT ( in ) :: dt ! Local REAL ( prec ) :: dtLoc INTEGER :: i , iVar , iEl IF ( PRESENT ( dt )) THEN dtLoc = dt ELSE dtLoc = this % dt END IF IF ( this % gpuAccel ) THEN CALL UpdateSolution_Model1D_gpu_wrapper ( this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & dtLoc , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , iVar , iEl ) = & this % solution % interior % hostData ( i , iVar , iEl ) + & dtLoc * this % dSdt % interior % hostData ( i , iVar , iEl ) END DO END DO END DO END IF END SUBROUTINE UpdateSolution_Model1D","tags":"","loc":"proc/updatesolution_model1d.html"},{"title":"WriteTecplot_Model1D – SELF","text":"public subroutine WriteTecplot_Model1D(this, filename) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character, intent(in), optional :: filename Contents Source Code WriteTecplot_Model1D Source Code SUBROUTINE WriteTecplot_Model1D ( this , filename ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ), OPTIONAL :: filename ! Local CHARACTER ( 8 ) :: zoneID INTEGER :: fUnit INTEGER :: iEl , i , iVar CHARACTER ( LEN = self_FileNameLength ) :: tecFile CHARACTER ( LEN = self_TecplotHeaderLength ) :: tecHeader CHARACTER ( LEN = self_FormatLength ) :: fmat CHARACTER ( 13 ) :: timeStampString CHARACTER ( 5 ) :: rankString TYPE ( Scalar1D ) :: solution TYPE ( Scalar1D ) :: x TYPE ( Lagrange ), TARGET :: interp IF ( PRESENT ( filename )) THEN tecFile = filename ELSE ! Create a 0-padded integer for the output iterate WRITE ( timeStampString , '(I13.13)' ) this % ioIterate ! Increment the ioIterate this % ioIterate = this % ioIterate + 1 tecFile = 'solution.' // timeStampString // '.curve' END IF ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) fmat = '(2(ES16.7E3,1x))' ! Let's write some tecplot!! OPEN ( UNIT = NEWUNIT ( fUnit ), & FILE = TRIM ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) DO iVar = 1 , this % solution % nVar WRITE ( tecHeader , '(E15.6)' ) this % t tecHeader = \"#TIME \" // TRIM ( tecHeader ) WRITE ( fUnit , * ) TRIM ( tecHeader ) tecHeader = \"#\" // TRIM ( this % solution % meta ( iVar ) % name ) // \" vs position\" WRITE ( fUnit , * ) TRIM ( tecHeader ) DO iEl = 1 , this % solution % nElem !WRITE (zoneID,'(I8.8)') iEl !WRITE (fUnit,*) 'ZONE T=\"el'//TRIM(zoneID)//'\", I=',this % solution % interp % M + 1 DO i = 0 , this % solution % interp % M WRITE ( fUnit , fmat ) x % interior % hostData ( i , 1 , iEl ), & solution % interior % hostData ( i , ivar , iEl ) END DO END DO END DO CLOSE ( UNIT = fUnit ) CALL x % Free () CALL solution % Free () CALL interp % Free () END SUBROUTINE WriteTecplot_Model1D","tags":"","loc":"proc/writetecplot_model1d.html"},{"title":"Write_Model1D – SELF","text":"public subroutine Write_Model1D(this, fileName) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character, intent(in), optional :: fileName Contents Source Code Write_Model1D Source Code SUBROUTINE Write_Model1D ( this , fileName ) #undef __FUNC__ #define __FUNC__ \"Write_Model1D\" IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CHARACTER ( * ), OPTIONAL , INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId TYPE ( Scalar1D ) :: solution TYPE ( Scalar1D ) :: x TYPE ( Lagrange ), TARGET :: interp CHARACTER ( LEN = self_FileNameLength ) :: pickupFile CHARACTER ( 13 ) :: timeStampString WRITE ( timeStampString , '(I13.13)' ) this % ioIterate IF ( PRESENT ( filename )) THEN pickupFile = TRIM ( filename ) // timeStampString // '.h5' ELSE pickupFile = 'solution.' // timeStampString // '.h5' END IF IF ( this % gpuAccel ) THEN CALL this % solution % UpdateHost () CALL this % solutionGradient % UpdateHost () END IF INFO ( \"Writing pickup file : \" // TRIM ( pickupFile )) IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId , this % decomp % mpiComm ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file INFO ( \"Writing control grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid/mesh' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/mesh/coords' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) CALL Close_HDF5 ( fileId ) ELSE CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' ) ! Write the geometry to file INFO ( \"Writing control grid  geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file INFO ( \"Writing target grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' ) ! Write the geometry to file INFO ( \"Writing target grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid/geometry' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/geometry/x' ) CALL Close_HDF5 ( fileId ) END IF CALL x % Free () CALL solution % Free () CALL interp % Free () END SUBROUTINE Write_Model1D","tags":"","loc":"proc/write_model1d.html"},{"title":"CalculateDSDt_Model1D_gpu_wrapper – SELF","text":"interface public subroutine CalculateDSDt_Model1D_gpu_wrapper(fluxDivergence, source, dSdt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: fluxDivergence type(C_PTR) :: source type(C_PTR) :: dSdt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/calculatedsdt_model1d_gpu_wrapper.html"},{"title":"UpdateGAB2_Model1D_gpu_wrapper – SELF","text":"interface public subroutine UpdateGAB2_Model1D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updategab2_model1d_gpu_wrapper.html"},{"title":"UpdateGAB3_Model1D_gpu_wrapper – SELF","text":"interface public subroutine UpdateGAB3_Model1D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updategab3_model1d_gpu_wrapper.html"},{"title":"UpdateGAB4_Model1D_gpu_wrapper – SELF","text":"interface public subroutine UpdateGAB4_Model1D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updategab4_model1d_gpu_wrapper.html"},{"title":"UpdateGRK_Model1D_gpu_wrapper – SELF","text":"interface public subroutine UpdateGRK_Model1D_gpu_wrapper(grk, solution, dSdt, rk_a, rk_g, dt, nWork, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: grk type(C_PTR) :: solution type(C_PTR) :: dSdt real(kind=c_prec), VALUE :: rk_a real(kind=c_prec), VALUE :: rk_g real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: nWork integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updategrk_model1d_gpu_wrapper.html"},{"title":"UpdateSolution_Model1D_gpu_wrapper – SELF","text":"interface public subroutine UpdateSolution_Model1D_gpu_wrapper(solution, dSdt, dt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: solution type(C_PTR) :: dSdt real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updatesolution_model1d_gpu_wrapper.html"},{"title":"Close_HDF5 – SELF","text":"public subroutine Close_HDF5(fileId) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId Contents Source Code Close_HDF5 Source Code SUBROUTINE Close_HDF5 ( fileId ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId ! Local INTEGER :: error CALL h5fclose_f ( fileId , error ) CALL h5close_f ( error ) END SUBROUTINE Close_HDF5","tags":"","loc":"proc/close_hdf5.html"},{"title":"CreateGroup_HDF5 – SELF","text":"public subroutine CreateGroup_HDF5(fileId, groupName) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: groupName Contents Source Code CreateGroup_HDF5 Source Code SUBROUTINE CreateGroup_HDF5 ( fileId , groupName ) #undef __FUNC__ #define __FUNC__ \"CreateGroup_HDF5\" IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: groupName ! Local INTEGER ( HID_T ) :: groupId LOGICAL :: groupExists INTEGER :: error CALL h5lexists_f ( fileId , TRIM ( groupName ), groupExists , error ) IF ( error /= 0 ) THEN ERROR ( \"Link check failure for \" // TRIM ( groupName ) ) ELSE IF ( . NOT . groupExists ) THEN INFO ( \"Creating group \" // TRIM ( groupName )) ! Create groups CALL h5gcreate_f ( fileId , TRIM ( groupName ), groupId , error ) IF ( error /= 0 ) THEN ERROR ( \"Failed to create group \" // TRIM ( groupName ) ) ENDIF CALL h5gclose_f ( groupId , error ) IF ( error /= 0 ) THEN ERROR ( \"Failed to close group \" // TRIM ( groupName ) ) ENDIF ENDIF ENDIF END SUBROUTINE CreateGroup_HDF5","tags":"","loc":"proc/creategroup_hdf5.html"},{"title":"Open_HDF5_parallel – SELF","text":"private subroutine Open_HDF5_parallel(fileName, accessFlag, fileId, mpiComm) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId integer, intent(in) :: mpiComm Contents Source Code Open_HDF5_parallel Source Code SUBROUTINE Open_HDF5_parallel ( fileName , accessFlag , fileId , mpiComm ) IMPLICIT NONE CHARACTER ( * ), INTENT ( in ) :: fileName INTEGER , INTENT ( in ) :: accessFlag INTEGER ( HID_T ), INTENT ( inout ) :: fileId INTEGER , INTENT ( in ) :: mpiComm ! Local INTEGER ( HID_T ) :: plistId INTEGER :: error CALL h5open_f ( error ) CALL h5pcreate_f ( H5P_FILE_ACCESS_F , plistId , error ) CALL h5pset_fapl_mpio_f ( plistId , mpiComm , MPI_INFO_NULL , error ) IF ( accessFlag == H5F_ACC_TRUNC_F ) THEN CALL h5fcreate_f ( TRIM ( fileName ), accessFlag , fileId , error , access_prp = plistId ) ELSE CALL h5fopen_f ( TRIM ( fileName ), accessFlag , fileId , error , access_prp = plistId ) END IF CALL h5pclose_f ( plistId , error ) IF ( error == - 1 ) THEN PRINT * , 'Failed to open ' // TRIM ( fileName ) // '.' STOP - 1 END IF END SUBROUTINE Open_HDF5_parallel","tags":"","loc":"proc/open_hdf5_parallel.html"},{"title":"Open_HDF5_serial – SELF","text":"private subroutine Open_HDF5_serial(fileName, accessFlag, fileId) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId Contents Source Code Open_HDF5_serial Source Code SUBROUTINE Open_HDF5_serial ( fileName , accessFlag , fileId ) IMPLICIT NONE CHARACTER ( * ), INTENT ( in ) :: fileName INTEGER , INTENT ( in ) :: accessFlag INTEGER ( HID_T ), INTENT ( inout ) :: fileId ! Local INTEGER :: error CALL h5open_f ( error ) IF ( accessFlag == H5F_ACC_TRUNC_F ) THEN CALL h5fcreate_f ( TRIM ( fileName ), accessFlag , fileId , error ) ELSE CALL h5fopen_f ( TRIM ( fileName ), accessFlag , fileId , error ) END IF IF ( error == - 1 ) THEN PRINT * , 'Failed to open ' // TRIM ( fileName ) // '.' STOP - 1 END IF END SUBROUTINE Open_HDF5_serial","tags":"","loc":"proc/open_hdf5_serial.html"},{"title":"ReadArray_HDF5_int32_r1_parallel – SELF","text":"private subroutine ReadArray_HDF5_int32_r1_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) Contents Source Code ReadArray_HDF5_int32_r1_parallel Source Code SUBROUTINE ReadArray_HDF5_int32_r1_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfInt32_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( 1 , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r1_parallel","tags":"","loc":"proc/readarray_hdf5_int32_r1_parallel.html"},{"title":"ReadArray_HDF5_int32_r1_serial – SELF","text":"private subroutine ReadArray_HDF5_int32_r1_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(inout) :: hfArray Contents Source Code ReadArray_HDF5_int32_r1_serial Source Code SUBROUTINE ReadArray_HDF5_int32_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( INT32 , H5_INTEGER_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r1_serial","tags":"","loc":"proc/readarray_hdf5_int32_r1_serial.html"},{"title":"ReadArray_HDF5_int32_r2_parallel – SELF","text":"private subroutine ReadArray_HDF5_int32_r2_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) Contents Source Code ReadArray_HDF5_int32_r2_parallel Source Code SUBROUTINE ReadArray_HDF5_int32_r2_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfInt32_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r2_parallel","tags":"","loc":"proc/readarray_hdf5_int32_r2_parallel.html"},{"title":"ReadArray_HDF5_int32_r2_serial – SELF","text":"private subroutine ReadArray_HDF5_int32_r2_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(inout) :: hfArray Contents Source Code ReadArray_HDF5_int32_r2_serial Source Code SUBROUTINE ReadArray_HDF5_int32_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( INT32 , H5_INTEGER_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r2_serial","tags":"","loc":"proc/readarray_hdf5_int32_r2_serial.html"},{"title":"ReadArray_HDF5_real_r1_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r1_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) Contents Source Code ReadArray_HDF5_real_r1_parallel Source Code SUBROUTINE ReadArray_HDF5_real_r1_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfReal_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r1_parallel","tags":"","loc":"proc/readarray_hdf5_real_r1_parallel.html"},{"title":"ReadArray_HDF5_real_r1_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r1_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(inout) :: hfArray Contents Source Code ReadArray_HDF5_real_r1_serial Source Code SUBROUTINE ReadArray_HDF5_real_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r1_serial","tags":"","loc":"proc/readarray_hdf5_real_r1_serial.html"},{"title":"ReadArray_HDF5_real_r2_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r2_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) Contents Source Code ReadArray_HDF5_real_r2_parallel Source Code SUBROUTINE ReadArray_HDF5_real_r2_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfReal_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r2_parallel","tags":"","loc":"proc/readarray_hdf5_real_r2_parallel.html"},{"title":"ReadArray_HDF5_real_r2_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r2_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(inout) :: hfArray Contents Source Code ReadArray_HDF5_real_r2_serial Source Code SUBROUTINE ReadArray_HDF5_real_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r2_serial","tags":"","loc":"proc/readarray_hdf5_real_r2_serial.html"},{"title":"ReadArray_HDF5_real_r3_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r3_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) Contents Source Code ReadArray_HDF5_real_r3_parallel Source Code SUBROUTINE ReadArray_HDF5_real_r3_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfReal_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r3_parallel","tags":"","loc":"proc/readarray_hdf5_real_r3_parallel.html"},{"title":"ReadArray_HDF5_real_r3_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r3_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(inout) :: hfArray Contents Source Code ReadArray_HDF5_real_r3_serial Source Code SUBROUTINE ReadArray_HDF5_real_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r3_serial","tags":"","loc":"proc/readarray_hdf5_real_r3_serial.html"},{"title":"ReadArray_HDF5_real_r4_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r4_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) Contents Source Code ReadArray_HDF5_real_r4_parallel Source Code SUBROUTINE ReadArray_HDF5_real_r4_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfReal_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r4_parallel","tags":"","loc":"proc/readarray_hdf5_real_r4_parallel.html"},{"title":"ReadArray_HDF5_real_r4_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r4_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(inout) :: hfArray Contents Source Code ReadArray_HDF5_real_r4_serial Source Code SUBROUTINE ReadArray_HDF5_real_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r4_serial","tags":"","loc":"proc/readarray_hdf5_real_r4_serial.html"},{"title":"ReadArray_HDF5_real_r5_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r5_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) Contents Source Code ReadArray_HDF5_real_r5_parallel Source Code SUBROUTINE ReadArray_HDF5_real_r5_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfReal_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r5_parallel","tags":"","loc":"proc/readarray_hdf5_real_r5_parallel.html"},{"title":"ReadArray_HDF5_real_r5_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r5_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(inout) :: hfArray Contents Source Code ReadArray_HDF5_real_r5_serial Source Code SUBROUTINE ReadArray_HDF5_real_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r5_serial","tags":"","loc":"proc/readarray_hdf5_real_r5_serial.html"},{"title":"ReadArray_HDF5_real_r6_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r6_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) Contents Source Code ReadArray_HDF5_real_r6_parallel Source Code SUBROUTINE ReadArray_HDF5_real_r6_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfReal_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r6_parallel","tags":"","loc":"proc/readarray_hdf5_real_r6_parallel.html"},{"title":"ReadArray_HDF5_real_r6_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r6_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(inout) :: hfArray Contents Source Code ReadArray_HDF5_real_r6_serial Source Code SUBROUTINE ReadArray_HDF5_real_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r6_serial","tags":"","loc":"proc/readarray_hdf5_real_r6_serial.html"},{"title":"ReadAttribute_HDF5_character – SELF","text":"private subroutine ReadAttribute_HDF5_character(fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(out) :: attribute Contents Source Code ReadAttribute_HDF5_character Source Code SUBROUTINE ReadAttribute_HDF5_character ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName CHARACTER ( * ), INTENT ( out ) :: attribute ! Local INTEGER ( HID_T ) :: attrId INTEGER ( HID_T ) :: typeId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5aopen_f ( fileId , TRIM ( attributeName ), attrId , error ) CALL h5aget_type_f ( attrId , typeId , error ) CALL h5aread_f ( attrId , typeId , attribute , dims , error ) CALL h5tclose_f ( typeId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE ReadAttribute_HDF5_character","tags":"","loc":"proc/readattribute_hdf5_character.html"},{"title":"ReadAttribute_HDF5_int32 – SELF","text":"private subroutine ReadAttribute_HDF5_int32(fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(out) :: attribute Contents Source Code ReadAttribute_HDF5_int32 Source Code SUBROUTINE ReadAttribute_HDF5_int32 ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName INTEGER , INTENT ( out ) :: attribute ! Local INTEGER ( HID_T ) :: attrId INTEGER ( HID_T ) :: typeId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5aopen_f ( fileId , TRIM ( attributeName ), attrId , error ) CALL h5aget_type_f ( attrId , typeId , error ) CALL h5aread_f ( attrId , typeId , attribute , dims , error ) CALL h5tclose_f ( typeId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE ReadAttribute_HDF5_int32","tags":"","loc":"proc/readattribute_hdf5_int32.html"},{"title":"ReadAttribute_HDF5_real – SELF","text":"private subroutine ReadAttribute_HDF5_real(fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(out) :: attribute Contents Source Code ReadAttribute_HDF5_real Source Code SUBROUTINE ReadAttribute_HDF5_real ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName REAL ( prec ), INTENT ( out ) :: attribute ! Local INTEGER ( HID_T ) :: attrId INTEGER ( HID_T ) :: typeId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5aopen_f ( fileId , TRIM ( attributeName ), attrId , error ) CALL h5aget_type_f ( attrId , typeId , error ) CALL h5aread_f ( attrId , typeId , attribute , dims , error ) CALL h5tclose_f ( typeId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE ReadAttribute_HDF5_real","tags":"","loc":"proc/readattribute_hdf5_real.html"},{"title":"WriteArray_HDF5_int32_r1_parallel – SELF","text":"private subroutine WriteArray_HDF5_int32_r1_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) Contents Source Code WriteArray_HDF5_int32_r1_parallel Source Code SUBROUTINE WriteArray_HDF5_int32_r1_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfint32_r1 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r1_parallel","tags":"","loc":"proc/writearray_hdf5_int32_r1_parallel.html"},{"title":"WriteArray_HDF5_int32_r1_serial – SELF","text":"private subroutine WriteArray_HDF5_int32_r1_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(in) :: hfArray Contents Source Code WriteArray_HDF5_int32_r1_serial Source Code SUBROUTINE WriteArray_HDF5_int32_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r1 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r1_serial","tags":"","loc":"proc/writearray_hdf5_int32_r1_serial.html"},{"title":"WriteArray_HDF5_int32_r2_parallel – SELF","text":"private subroutine WriteArray_HDF5_int32_r2_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) Contents Source Code WriteArray_HDF5_int32_r2_parallel Source Code SUBROUTINE WriteArray_HDF5_int32_r2_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfint32_r2 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 2 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r2_parallel","tags":"","loc":"proc/writearray_hdf5_int32_r2_parallel.html"},{"title":"WriteArray_HDF5_int32_r2_serial – SELF","text":"private subroutine WriteArray_HDF5_int32_r2_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(in) :: hfArray Contents Source Code WriteArray_HDF5_int32_r2_serial Source Code SUBROUTINE WriteArray_HDF5_int32_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r2 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r2_serial","tags":"","loc":"proc/writearray_hdf5_int32_r2_serial.html"},{"title":"WriteArray_HDF5_int32_r3_parallel – SELF","text":"private subroutine WriteArray_HDF5_int32_r3_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r3 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) Contents Source Code WriteArray_HDF5_int32_r3_parallel Source Code SUBROUTINE WriteArray_HDF5_int32_r3_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfint32_r3 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 3 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r3_parallel","tags":"","loc":"proc/writearray_hdf5_int32_r3_parallel.html"},{"title":"WriteArray_HDF5_int32_r3_serial – SELF","text":"private subroutine WriteArray_HDF5_int32_r3_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r3 ), intent(in) :: hfArray Contents Source Code WriteArray_HDF5_int32_r3_serial Source Code SUBROUTINE WriteArray_HDF5_int32_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r3 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r3_serial","tags":"","loc":"proc/writearray_hdf5_int32_r3_serial.html"},{"title":"WriteArray_HDF5_int32_r4_parallel – SELF","text":"private subroutine WriteArray_HDF5_int32_r4_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r4 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) Contents Source Code WriteArray_HDF5_int32_r4_parallel Source Code SUBROUTINE WriteArray_HDF5_int32_r4_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfint32_r4 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 4 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r4_parallel","tags":"","loc":"proc/writearray_hdf5_int32_r4_parallel.html"},{"title":"WriteArray_HDF5_int32_r4_serial – SELF","text":"private subroutine WriteArray_HDF5_int32_r4_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r4 ), intent(in) :: hfArray Contents Source Code WriteArray_HDF5_int32_r4_serial Source Code SUBROUTINE WriteArray_HDF5_int32_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r4 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r4_serial","tags":"","loc":"proc/writearray_hdf5_int32_r4_serial.html"},{"title":"WriteArray_HDF5_real_r1_parallel – SELF","text":"private subroutine WriteArray_HDF5_real_r1_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) Contents Source Code WriteArray_HDF5_real_r1_parallel Source Code SUBROUTINE WriteArray_HDF5_real_r1_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfReal_r1 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r1_parallel","tags":"","loc":"proc/writearray_hdf5_real_r1_parallel.html"},{"title":"WriteArray_HDF5_real_r1_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r1_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(in) :: hfArray Contents Source Code WriteArray_HDF5_real_r1_serial Source Code SUBROUTINE WriteArray_HDF5_real_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r1 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r1_serial","tags":"","loc":"proc/writearray_hdf5_real_r1_serial.html"},{"title":"WriteArray_HDF5_real_r2_parallel – SELF","text":"private subroutine WriteArray_HDF5_real_r2_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) Contents Source Code WriteArray_HDF5_real_r2_parallel Source Code SUBROUTINE WriteArray_HDF5_real_r2_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfReal_r2 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 2 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r2_parallel","tags":"","loc":"proc/writearray_hdf5_real_r2_parallel.html"},{"title":"WriteArray_HDF5_real_r2_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r2_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(in) :: hfArray Contents Source Code WriteArray_HDF5_real_r2_serial Source Code SUBROUTINE WriteArray_HDF5_real_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r2 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r2_serial","tags":"","loc":"proc/writearray_hdf5_real_r2_serial.html"},{"title":"WriteArray_HDF5_real_r3_parallel – SELF","text":"private subroutine WriteArray_HDF5_real_r3_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) Contents Source Code WriteArray_HDF5_real_r3_parallel Source Code SUBROUTINE WriteArray_HDF5_real_r3_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfReal_r3 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 3 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r3_parallel","tags":"","loc":"proc/writearray_hdf5_real_r3_parallel.html"},{"title":"WriteArray_HDF5_real_r3_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r3_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(in) :: hfArray Contents Source Code WriteArray_HDF5_real_r3_serial Source Code SUBROUTINE WriteArray_HDF5_real_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r3 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r3_serial","tags":"","loc":"proc/writearray_hdf5_real_r3_serial.html"},{"title":"WriteArray_HDF5_real_r4_parallel – SELF","text":"private subroutine WriteArray_HDF5_real_r4_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) Contents Source Code WriteArray_HDF5_real_r4_parallel Source Code SUBROUTINE WriteArray_HDF5_real_r4_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfReal_r4 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 4 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( filespace , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r4_parallel","tags":"","loc":"proc/writearray_hdf5_real_r4_parallel.html"},{"title":"WriteArray_HDF5_real_r4_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r4_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(in) :: hfArray Contents Source Code WriteArray_HDF5_real_r4_serial Source Code SUBROUTINE WriteArray_HDF5_real_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r4 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r4_serial","tags":"","loc":"proc/writearray_hdf5_real_r4_serial.html"},{"title":"WriteArray_HDF5_real_r5_parallel – SELF","text":"private subroutine WriteArray_HDF5_real_r5_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) Contents Source Code WriteArray_HDF5_real_r5_parallel Source Code SUBROUTINE WriteArray_HDF5_real_r5_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfReal_r5 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 5 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r5_parallel","tags":"","loc":"proc/writearray_hdf5_real_r5_parallel.html"},{"title":"WriteArray_HDF5_real_r5_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r5_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(in) :: hfArray Contents Source Code WriteArray_HDF5_real_r5_serial Source Code SUBROUTINE WriteArray_HDF5_real_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r5 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r5_serial","tags":"","loc":"proc/writearray_hdf5_real_r5_serial.html"},{"title":"WriteArray_HDF5_real_r6_parallel – SELF","text":"private subroutine WriteArray_HDF5_real_r6_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) Contents Source Code WriteArray_HDF5_real_r6_parallel Source Code SUBROUTINE WriteArray_HDF5_real_r6_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfReal_r6 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 6 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r6_parallel","tags":"","loc":"proc/writearray_hdf5_real_r6_parallel.html"},{"title":"WriteArray_HDF5_real_r6_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r6_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(in) :: hfArray Contents Source Code WriteArray_HDF5_real_r6_serial Source Code SUBROUTINE WriteArray_HDF5_real_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r6 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r6_serial","tags":"","loc":"proc/writearray_hdf5_real_r6_serial.html"},{"title":"WriteAttribute_HDF5_int32 – SELF","text":"private subroutine WriteAttribute_HDF5_int32(fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(in) :: attribute Contents Source Code WriteAttribute_HDF5_int32 Source Code SUBROUTINE WriteAttribute_HDF5_int32 ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName INTEGER , INTENT ( in ) :: attribute ! Local INTEGER ( HID_T ) :: aspaceId INTEGER ( HID_T ) :: attrId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5screate_f ( H5S_SCALAR_F , aspaceId , error ) CALL h5acreate_f ( fileId , TRIM ( attributeName ), H5T_STD_I32LE , & aspaceId , attrId , error ) CALL h5awrite_f ( attrId , H5T_STD_I32LE , attribute , dims , error ) CALL h5sclose_f ( aspaceId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE WriteAttribute_HDF5_int32","tags":"","loc":"proc/writeattribute_hdf5_int32.html"},{"title":"WriteCharacter_HDF5_serial – SELF","text":"private subroutine WriteCharacter_HDF5_serial(fileId, name, hfField) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character(len=*), intent(in) :: name character(len=*), intent(in) :: hfField Contents Source Code WriteCharacter_HDF5_serial Source Code subroutine WriteCharacter_HDF5_serial ( fileid , name , hfField ) ! adapted from https://forum.hdfgroup.org/t/writing-a-string-array-as-attribute-in-fortran/8503/6 IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: hfField ! Local integer ( HID_T ) :: h5_strtype , h5_dspace , h5_dset integer ( HSIZE_T ), dimension ( 2 ) :: size character ( len = len ( hfField ) + 1 ), dimension ( 1 ) :: str_data integer ( SIZE_T ), dimension ( 1 ) :: str_len INTEGER :: error ! string output requires to open a file local = non-parallel str_len ( 1 ) = len_trim ( hfField ) size ( 1 ) = str_len ( 1 ) size ( 2 ) = 1 str_data ( 1 ) = hfField // char ( 0 ) ! create data space call H5Tcopy_f ( H5T_STRING , h5_strtype , error ) call H5Tset_strpad_f ( h5_strtype , H5T_STR_NULLPAD_F , error ) call h5screate_simple_f ( 1 , size ( 2 ), h5_dspace , error ) call h5dcreate_f ( fileid , trim ( name ), h5_strtype , h5_dspace , h5_dset , error ) call h5dwrite_vl_f ( h5_dset , h5_strtype , str_data , size , str_len , error , h5_dspace ) call h5dclose_f ( h5_dset , error ) call h5sclose_f ( h5_dspace , error ) end subroutine WriteCharacter_HDF5_serial","tags":"","loc":"proc/writecharacter_hdf5_serial.html"},{"title":"Open_HDF5 – SELF","text":"public interface Open_HDF5 Contents Module Procedures Open_HDF5_serial Open_HDF5_parallel Module Procedures private subroutine Open_HDF5_serial (fileName, accessFlag, fileId) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId private subroutine Open_HDF5_parallel (fileName, accessFlag, fileId, mpiComm) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId integer, intent(in) :: mpiComm","tags":"","loc":"interface/open_hdf5.html"},{"title":"ReadArray_HDF5 – SELF","text":"public interface ReadArray_HDF5 Contents Module Procedures ReadArray_HDF5_real_r1_serial ReadArray_HDF5_real_r2_serial ReadArray_HDF5_real_r3_serial ReadArray_HDF5_real_r4_serial ReadArray_HDF5_real_r5_serial ReadArray_HDF5_real_r6_serial ReadArray_HDF5_int32_r1_serial ReadArray_HDF5_int32_r2_serial ReadArray_HDF5_real_r1_parallel ReadArray_HDF5_real_r2_parallel ReadArray_HDF5_real_r3_parallel ReadArray_HDF5_real_r4_parallel ReadArray_HDF5_real_r5_parallel ReadArray_HDF5_real_r6_parallel ReadArray_HDF5_int32_r1_parallel ReadArray_HDF5_int32_r2_parallel Module Procedures private subroutine ReadArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_real_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) private subroutine ReadArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) private subroutine ReadArray_HDF5_real_r5_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) private subroutine ReadArray_HDF5_real_r6_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) private subroutine ReadArray_HDF5_int32_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_int32_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2)","tags":"","loc":"interface/readarray_hdf5.html"},{"title":"ReadAttribute_HDF5 – SELF","text":"public interface ReadAttribute_HDF5 Contents Module Procedures ReadAttribute_HDF5_int32 ReadAttribute_HDF5_real ReadAttribute_HDF5_character Module Procedures private subroutine ReadAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(out) :: attribute private subroutine ReadAttribute_HDF5_real (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(out) :: attribute private subroutine ReadAttribute_HDF5_character (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(out) :: attribute","tags":"","loc":"interface/readattribute_hdf5.html"},{"title":"WriteArray_HDF5 – SELF","text":"public interface WriteArray_HDF5 Contents Module Procedures WriteArray_HDF5_real_r1_serial WriteArray_HDF5_real_r2_serial WriteArray_HDF5_real_r3_serial WriteArray_HDF5_real_r4_serial WriteArray_HDF5_real_r5_serial WriteArray_HDF5_real_r6_serial WriteArray_HDF5_int32_r1_serial WriteArray_HDF5_int32_r2_serial WriteArray_HDF5_int32_r3_serial WriteArray_HDF5_int32_r4_serial WriteArray_HDF5_real_r1_parallel WriteArray_HDF5_real_r2_parallel WriteArray_HDF5_real_r3_parallel WriteArray_HDF5_real_r4_parallel WriteArray_HDF5_real_r5_parallel WriteArray_HDF5_real_r6_parallel WriteArray_HDF5_int32_r1_parallel WriteArray_HDF5_int32_r2_parallel WriteArray_HDF5_int32_r3_parallel WriteArray_HDF5_int32_r4_parallel Module Procedures private subroutine WriteArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r3 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r4 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r1_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) private subroutine WriteArray_HDF5_real_r2_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) private subroutine WriteArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) private subroutine WriteArray_HDF5_real_r5_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) private subroutine WriteArray_HDF5_real_r6_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) private subroutine WriteArray_HDF5_int32_r1_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) private subroutine WriteArray_HDF5_int32_r2_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) private subroutine WriteArray_HDF5_int32_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r3 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_int32_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r4 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4)","tags":"","loc":"interface/writearray_hdf5.html"},{"title":"WriteAttribute_HDF5 – SELF","text":"public interface WriteAttribute_HDF5 Contents Module Procedures WriteAttribute_HDF5_int32 Module Procedures private subroutine WriteAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(in) :: attribute","tags":"","loc":"interface/writeattribute_hdf5.html"},{"title":"WriteCharacter_HDF5 – SELF","text":"public interface WriteCharacter_HDF5 Contents Module Procedures WriteCharacter_HDF5_serial Module Procedures private subroutine WriteCharacter_HDF5_serial (fileId, name, hfField) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character(len=*), intent(in) :: name character(len=*), intent(in) :: hfField","tags":"","loc":"interface/writecharacter_hdf5.html"},{"title":"fluxmethod_advection_diffusion_2d – SELF","text":"public subroutine fluxmethod_advection_diffusion_2d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this Contents Source Code fluxmethod_advection_diffusion_2d Source Code subroutine fluxmethod_advection_diffusion_2d ( this ) implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this ! Local integer :: iel integer :: ivar integer :: i integer :: j real ( prec ) :: u , v , nu , f , dfdx , dfdy u = this % u v = this % v nu = this % nu do iel = 1 , this % mesh % nelem do ivar = 1 , this % solution % nvar do j = 0 , this % solution % interp % N do i = 0 , this % solution % interp % N f = this % solution % interior % hostdata ( i , j , ivar , iel ) dfdx = this % solutionGradient % interior % hostdata ( 1 , i , j , ivar , iel ) dfdy = this % solutionGradient % interior % hostdata ( 2 , i , j , ivar , iel ) this % flux % interior % hostdata ( 1 , i , j , ivar , iel ) = u * f - nu * dfdx ! advective flux + diffusive flux (x-component) this % flux % interior % hostdata ( 2 , i , j , ivar , iel ) = v * f - nu * dfdy ! advective flux + diffusive flux (y-component) enddo enddo enddo enddo end subroutine fluxmethod_advection_diffusion_2d","tags":"","loc":"proc/fluxmethod_advection_diffusion_2d.html"},{"title":"pretendency_advection_diffusion_2d – SELF","text":"public subroutine pretendency_advection_diffusion_2d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this Contents Source Code pretendency_advection_diffusion_2d Source Code subroutine pretendency_advection_diffusion_2d ( this ) ! Here, we use the pre-tendency method to calculate the ! derivative of the solution using a bassi-rebay method ! We then do a boundary interpolation and side exchange ! on the gradient field implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this ! local integer :: i , ivar , iEl , iSide , e2 do iEl = 1 , this % solution % nElem ! Loop over all elements do iSide = 1 , 4 ! Loop over all sides !bcid = this % mesh % sideInfo % hostData(5,iSide,iEl) ! Boundary Condition ID e2 = this % mesh % sideInfo % hostData ( 3 , iSide , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then do ivar = 1 , this % solution % nvar do i = 0 , this % solution % interp % N ! Loop over quadrature points this % solution % extBoundary % hostData ( i , ivar , iSide , iEl ) = 0.0_prec enddo enddo end if end do end do ! calculate the averages of the solutions on the element ! boundaries and store is this % solution % avgBoundary call this % solution % BassiRebaySides ( this % gpuaccel ) ! calculate the derivative using the bassi-rebay form call this % solution % Gradient ( this % geometry , & this % solutionGradient , selfWeakBRForm , & this % gpuaccel ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp ( this % gpuaccel ) ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh , & this % decomp , this % gpuaccel ) end subroutine pretendency_advection_diffusion_2d","tags":"","loc":"proc/pretendency_advection_diffusion_2d.html"},{"title":"riemannsolver_advection_diffusion_2d – SELF","text":"public subroutine riemannsolver_advection_diffusion_2d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this Contents Source Code riemannsolver_advection_diffusion_2d Source Code subroutine riemannsolver_advection_diffusion_2d ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this ! Local integer :: iel integer :: ivar integer :: iside integer :: i real ( prec ) :: fin , fout , dfdn , un real ( prec ) :: nhat ( 1 : 2 ), nmag do iEl = 1 , this % solution % nElem do iSide = 1 , 4 do ivar = 1 , this % solution % nvar do i = 0 , this % solution % interp % N ! Get the boundary normals on cell edges from the mesh geometry nhat ( 1 : 2 ) = this % geometry % nHat % boundary % hostData ( 1 : 2 , i , 1 , iSide , iEl ) nmag = this % geometry % nScale % boundary % hostData ( i , 1 , iSide , iEl ) un = this % u * nhat ( 1 ) + this % v * nhat ( 2 ) dfdn = this % solutionGradient % boundary % hostData ( 1 , i , ivar , iSide , iEl ) * nhat ( 1 ) + & this % solutionGradient % boundary % hostData ( 2 , i , ivar , iSide , iEl ) * nhat ( 2 ) fin = this % solution % boundary % hostdata ( i , ivar , iside , iel ) ! interior solution fout = this % solution % extboundary % hostdata ( i , ivar , iside , iel ) ! exterior solution this % flux % boundaryNormal % hostData ( i , 1 , iSide , iEl ) = ( 0.5_prec * ( & un * ( fin + fout ) + abs ( un ) * ( fin - fout ) ) - & ! advective flux this % nu * dfdn ) * nmag enddo enddo enddo enddo end subroutine riemannsolver_advection_diffusion_2d","tags":"","loc":"proc/riemannsolver_advection_diffusion_2d.html"},{"title":"setboundarycondition_advection_diffusion_2d – SELF","text":"public subroutine setboundarycondition_advection_diffusion_2d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this Contents Source Code setboundarycondition_advection_diffusion_2d Source Code subroutine setboundarycondition_advection_diffusion_2d ( this ) ! Here, we set the boundary conditions for the ! solution and the solution gradient at the left ! and right most boundaries. ! ! Here, we use periodic boundary conditions implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this ! local integer :: i , ivar , iEl , iSide , e2 do iEl = 1 , this % solution % nElem ! Loop over all elements do iSide = 1 , 4 ! Loop over all sides !bcid = this % mesh % sideInfo % hostData(5,iSide,iEl) ! Boundary Condition ID e2 = this % mesh % sideInfo % hostData ( 3 , iSide , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then do ivar = 1 , this % solution % nvar do i = 0 , this % solution % interp % N ! Loop over quadrature points this % solutionGradient % extBoundary % hostData ( 1 : 2 , i , ivar , iSide , iEl ) = 0.0_prec enddo enddo end if end do end do call this % solutionGradient % BassiRebaySides ( this % gpuaccel ) end subroutine setboundarycondition_advection_diffusion_2d","tags":"","loc":"proc/setboundarycondition_advection_diffusion_2d.html"},{"title":"fluxmethod_advection_diffusion_1d – SELF","text":"public subroutine fluxmethod_advection_diffusion_1d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this Contents Source Code fluxmethod_advection_diffusion_1d Source Code subroutine fluxmethod_advection_diffusion_1d ( this ) implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this ! Local integer :: iel integer :: ivar integer :: i real ( prec ) :: u , nu , f , dfdx u = this % u nu = this % nu do iel = 1 , this % mesh % nelem do ivar = 1 , this % solution % nvar do i = 0 , this % solution % interp % N f = this % solution % interior % hostdata ( i , ivar , iel ) dfdx = this % solutionGradient % interior % hostdata ( i , ivar , iel ) this % flux % interior % hostdata ( i , ivar , iel ) = u * f - nu * dfdx ! advective flux + diffusive flux enddo enddo enddo end subroutine fluxmethod_advection_diffusion_1d","tags":"","loc":"proc/fluxmethod_advection_diffusion_1d.html"},{"title":"pretendency_advection_diffusion_1d – SELF","text":"public subroutine pretendency_advection_diffusion_1d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this Contents Source Code pretendency_advection_diffusion_1d Source Code subroutine pretendency_advection_diffusion_1d ( this ) ! Here, we use the pre-tendency method to calculate the ! derivative of the solution using a bassi-rebay method ! We then do a boundary interpolation and side exchange ! on the gradient field implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this ! local integer :: ivar integer :: N , nelem nelem = this % geometry % nelem ! number of elements in the mesh N = this % solution % interp % N ! polynomial degree do ivar = 1 , this % solution % nvar ! left-most boundary this % solution % extBoundary % hostdata ( ivar , 1 , 1 ) = & this % solution % boundary % hostdata ( ivar , 2 , nelem ) ! right-most boundary this % solution % extBoundary % hostdata ( ivar , 2 , nelem ) = & this % solution % boundary % hostdata ( ivar , 1 , 1 ) enddo ! calculate the averages of the solutions on the element ! boundaries and store is this % solution % avgBoundary call this % solution % BassiRebaySides ( this % gpuaccel ) ! calculate the derivative using the bassi-rebay form call this % solution % Derivative ( this % geometry , & this % solutionGradient , selfWeakBRForm , & this % gpuaccel ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp ( this % gpuaccel ) ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh , & this % decomp , this % gpuaccel ) call this % solutionGradient % BassiRebaySides ( this % gpuaccel ) end subroutine pretendency_advection_diffusion_1d","tags":"","loc":"proc/pretendency_advection_diffusion_1d.html"},{"title":"riemannsolver_advection_diffusion_1d – SELF","text":"public subroutine riemannsolver_advection_diffusion_1d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this Contents Source Code riemannsolver_advection_diffusion_1d Source Code subroutine riemannsolver_advection_diffusion_1d ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this ! Local integer :: iel integer :: ivar integer :: iside real ( prec ) :: fin , fout , dfavg , un call this % solutionGradient % BassiRebaySides ( this % gpuaccel ) do iel = 1 , this % mesh % nelem do iside = 1 , 2 ! set the normal velocity if ( iside == 1 ) then un = - this % u else un = this % u endif do ivar = 1 , this % solution % nvar fin = this % solution % boundary % hostdata ( ivar , iside , iel ) ! interior solution fout = this % solution % extboundary % hostdata ( ivar , iside , iel ) ! exterior solution dfavg = this % solutionGradient % avgboundary % hostdata ( ivar , iside , iel ) ! average solution gradient (with direction taken into account) this % flux % boundary % hostdata ( ivar , iside , iel ) = 0.5_prec * ( un * ( fin + fout ) + abs ( un ) * ( fin - fout ) ) - & ! advective flux this % nu * dfavg ! diffusive flux enddo enddo enddo end subroutine riemannsolver_advection_diffusion_1d","tags":"","loc":"proc/riemannsolver_advection_diffusion_1d.html"},{"title":"setboundarycondition_advection_diffusion_1d – SELF","text":"public subroutine setboundarycondition_advection_diffusion_1d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this Contents Source Code setboundarycondition_advection_diffusion_1d Source Code subroutine setboundarycondition_advection_diffusion_1d ( this ) ! Here, we set the boundary conditions for the ! solution and the solution gradient at the left ! and right most boundaries. ! ! Here, we use periodic boundary conditions implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this ! local integer :: ivar integer :: N , nelem nelem = this % geometry % nelem ! number of elements in the mesh N = this % solution % interp % N ! polynomial degree do ivar = 1 , this % solution % nvar ! left-most boundary this % solutionGradient % extBoundary % hostdata ( ivar , 1 , 1 ) = & this % solutionGradient % boundary % hostdata ( ivar , 2 , nelem ) this % solutionGradient % avgBoundary % hostdata ( ivar , 1 , 1 ) = & - 0.5_prec * ( this % solutionGradient % extBoundary % hostdata ( ivar , 1 , 1 ) + & this % solutionGradient % boundary % hostdata ( ivar , 1 , 1 )) ! right-most boundary this % solutionGradient % extBoundary % hostdata ( ivar , 2 , nelem ) = & this % solutionGradient % boundary % hostdata ( ivar , 1 , 1 ) this % solutionGradient % avgBoundary % hostdata ( ivar , 2 , nelem ) = & 0.5_prec * ( this % solutionGradient % extBoundary % hostdata ( ivar , 2 , nelem ) + & this % solutionGradient % boundary % hostdata ( ivar , 2 , nelem )) enddo end subroutine setboundarycondition_advection_diffusion_1d","tags":"","loc":"proc/setboundarycondition_advection_diffusion_1d.html"},{"title":"fluxmethod_advection_diffusion_3d – SELF","text":"public subroutine fluxmethod_advection_diffusion_3d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this Contents Source Code fluxmethod_advection_diffusion_3d Source Code subroutine fluxmethod_advection_diffusion_3d ( this ) implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this ! Local integer :: iel integer :: ivar integer :: i integer :: j integer :: k real ( prec ) :: u , v , w , nu , f , dfdx , dfdy , dfdz u = this % u v = this % v nu = this % nu do iel = 1 , this % mesh % nelem do ivar = 1 , this % solution % nvar do k = 0 , this % solution % interp % N do j = 0 , this % solution % interp % N do i = 0 , this % solution % interp % N f = this % solution % interior % hostdata ( i , j , k , ivar , iel ) dfdx = this % solutionGradient % interior % hostdata ( 1 , i , j , k , ivar , iel ) dfdy = this % solutionGradient % interior % hostdata ( 2 , i , j , k , ivar , iel ) dfdz = this % solutionGradient % interior % hostdata ( 3 , i , j , k , ivar , iel ) this % flux % interior % hostdata ( 1 , i , j , k , ivar , iel ) = u * f - nu * dfdx ! advective flux + diffusive flux (x-component) this % flux % interior % hostdata ( 2 , i , j , k , ivar , iel ) = v * f - nu * dfdy ! advective flux + diffusive flux (y-component) this % flux % interior % hostdata ( 3 , i , j , k , ivar , iel ) = w * f - nu * dfdz ! advective flux + diffusive flux (z-component) enddo enddo enddo enddo enddo end subroutine fluxmethod_advection_diffusion_3d","tags":"","loc":"proc/fluxmethod_advection_diffusion_3d.html"},{"title":"pretendency_advection_diffusion_3d – SELF","text":"public subroutine pretendency_advection_diffusion_3d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this Contents Source Code pretendency_advection_diffusion_3d Source Code subroutine pretendency_advection_diffusion_3d ( this ) ! Here, we use the pre-tendency method to calculate the ! derivative of the solution using a bassi-rebay method ! We then do a boundary interpolation and side exchange ! on the gradient field implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this ! local integer :: i , j , ivar , iEl , iSide , e2 do iEl = 1 , this % solution % nElem ! Loop over all elements do iSide = 1 , 6 ! Loop over all sides !bcid = this % mesh % sideInfo % hostData(5,iSide,iEl) ! Boundary Condition ID e2 = this % mesh % sideInfo % hostData ( 3 , iSide , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then do ivar = 1 , this % solution % nvar do j = 0 , this % solution % interp % N ! Loop over quadrature point do i = 0 , this % solution % interp % N ! Loop over quadrature points this % solution % extBoundary % hostData ( i , j , ivar , iSide , iEl ) = 0.0_prec enddo enddo enddo end if end do end do ! calculate the averages of the solutions on the element ! boundaries and store is this % solution % avgBoundary call this % solution % BassiRebaySides ( this % gpuaccel ) ! calculate the derivative using the bassi-rebay form call this % solution % Gradient ( this % geometry , & this % solutionGradient , selfWeakBRForm , & this % gpuaccel ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp ( this % gpuaccel ) ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh , & this % decomp , this % gpuaccel ) end subroutine pretendency_advection_diffusion_3d","tags":"","loc":"proc/pretendency_advection_diffusion_3d.html"},{"title":"riemannsolver_advection_diffusion_3d – SELF","text":"public subroutine riemannsolver_advection_diffusion_3d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this Contents Source Code riemannsolver_advection_diffusion_3d Source Code subroutine riemannsolver_advection_diffusion_3d ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this ! Local integer :: iel integer :: ivar integer :: iside integer :: i , j real ( prec ) :: fin , fout , dfdn , un real ( prec ) :: nhat ( 1 : 3 ), nmag do iEl = 1 , this % solution % nElem do iSide = 1 , 6 do ivar = 1 , this % solution % nvar do j = 0 , this % solution % interp % N do i = 0 , this % solution % interp % N ! Get the boundary normals on cell edges from the mesh geometry nhat ( 1 : 3 ) = this % geometry % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , iSide , iEl ) nmag = this % geometry % nScale % boundary % hostData ( i , j , 1 , iSide , iEl ) un = this % u * nhat ( 1 ) + this % v * nhat ( 2 ) + this % w * nhat ( 3 ) dfdn = this % solutionGradient % boundary % hostData ( 1 , i , j , ivar , iSide , iEl ) * nhat ( 1 ) + & this % solutionGradient % boundary % hostData ( 2 , i , j , ivar , iSide , iEl ) * nhat ( 2 ) + & this % solutionGradient % boundary % hostData ( 3 , i , j , ivar , iSide , iEl ) * nhat ( 3 ) fin = this % solution % boundary % hostdata ( i , j , ivar , iside , iel ) ! interior solution fout = this % solution % extboundary % hostdata ( i , j , ivar , iside , iel ) ! exterior solution this % flux % boundaryNormal % hostData ( i , j , 1 , iSide , iEl ) = ( 0.5_prec * ( & un * ( fin + fout ) + abs ( un ) * ( fin - fout ) ) - & ! advective flux this % nu * dfdn ) * nmag enddo enddo enddo enddo enddo end subroutine riemannsolver_advection_diffusion_3d","tags":"","loc":"proc/riemannsolver_advection_diffusion_3d.html"},{"title":"setboundarycondition_advection_diffusion_3d – SELF","text":"public subroutine setboundarycondition_advection_diffusion_3d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this Contents Source Code setboundarycondition_advection_diffusion_3d Source Code subroutine setboundarycondition_advection_diffusion_3d ( this ) ! Here, we set the boundary conditions for the ! solution and the solution gradient at the left ! and right most boundaries. ! ! Here, we use periodic boundary conditions implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this ! local integer :: i , j , ivar , iEl , iSide , e2 do iEl = 1 , this % solution % nElem ! Loop over all elements do iSide = 1 , 6 ! Loop over all sides !bcid = this % mesh % sideInfo % hostData(5,iSide,iEl) ! Boundary Condition ID e2 = this % mesh % sideInfo % hostData ( 3 , iSide , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then do ivar = 1 , this % solution % nvar do j = 0 , this % solution % interp % N ! Loop over quadrature points do i = 0 , this % solution % interp % N ! Loop over quadrature points this % solutionGradient % extBoundary % hostData ( 1 : 3 , i , j , ivar , iSide , iEl ) = 0.0_prec enddo enddo enddo end if end do end do call this % solutionGradient % BassiRebaySides ( this % gpuaccel ) end subroutine setboundarycondition_advection_diffusion_3d","tags":"","loc":"proc/setboundarycondition_advection_diffusion_3d.html"},{"title":"CalculateFluxDivergence_Model2D – SELF","text":"public subroutine CalculateFluxDivergence_Model2D(this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this Contents Source Code CalculateFluxDivergence_Model2D Source Code SUBROUTINE CalculateFluxDivergence_Model2D ( this ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CALL this % flux % Divergence ( this % geometry , & this % fluxDivergence , & selfWeakDGForm , & this % gpuAccel ) END SUBROUTINE CalculateFluxDivergence_Model2D","tags":"","loc":"proc/calculatefluxdivergence_model2d.html"},{"title":"CalculateTendency_Model2D – SELF","text":"public subroutine CalculateTendency_Model2D(this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this Contents Source Code CalculateTendency_Model2D Source Code SUBROUTINE CalculateTendency_Model2D ( this ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this ! Local INTEGER :: i , j , iVar , iEl CALL this % PreTendency () CALL this % solution % BoundaryInterp ( this % gpuAccel ) CALL this % solution % SideExchange ( this % mesh , this % decomp , this % gpuAccel ) CALL this % SetBoundaryCondition () CALL this % SourceMethod () CALL this % RiemannSolver () CALL this % FluxMethod () CALL this % ReprojectFlux () CALL this % CalculateFluxDivergence () IF ( this % gpuAccel ) THEN CALL CalculateDSDt_Model2D_gpu_wrapper ( this % fluxDivergence % interior % deviceData , & this % source % interior % deviceData , & this % dSdt % interior % deviceData , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % dSdt % interior % hostData ( i , j , iVar , iEl ) = & this % source % interior % hostData ( i , j , iVar , iEl ) - & this % fluxDivergence % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE CalculateTendency_Model2D","tags":"","loc":"proc/calculatetendency_model2d.html"},{"title":"Free_Model2D – SELF","text":"public subroutine Free_Model2D(this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this Contents Source Code Free_Model2D Source Code SUBROUTINE Free_Model2D ( this ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CALL this % solution % Free () CALL this % workSol % Free () CALL this % prevSol % Free () CALL this % dSdt % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () END SUBROUTINE Free_Model2D","tags":"","loc":"proc/free_model2d.html"},{"title":"Init_Model2D – SELF","text":"public subroutine Init_Model2D(this, nvar, mesh, geometry, decomp) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), TARGET :: mesh type( SEMQuad ), intent(in), TARGET :: geometry type( MPILayer ), intent(in), TARGET :: decomp Contents Source Code Init_Model2D Source Code SUBROUTINE Init_Model2D ( this , nvar , mesh , geometry , decomp ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: nvar TYPE ( Mesh2D ), INTENT ( in ), TARGET :: mesh TYPE ( SEMQuad ), INTENT ( in ), TARGET :: geometry TYPE ( MPILayer ), INTENT ( in ), TARGET :: decomp ! Local INTEGER :: ivar CHARACTER ( LEN = 3 ) :: ivarChar CHARACTER ( LEN = 25 ) :: varname this % decomp => decomp this % mesh => mesh this % geometry => geometry this % gpuAccel = . FALSE . CALL this % solution % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % workSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % prevSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % dSdt % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % solutionGradient % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % flux % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % source % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % fluxDivergence % Init ( geometry % x % interp , nVar , this % mesh % nElem ) ! set default metadata DO ivar = 1 , nvar WRITE ( ivarChar , '(I3.3)' ) ivar varname = \"solution\" // TRIM ( ivarChar ) CALL this % solution % SetName ( ivar , varname ) CALL this % solution % SetUnits ( ivar , \"[null]\" ) END DO END SUBROUTINE Init_Model2D","tags":"","loc":"proc/init_model2d.html"},{"title":"Read_Model2D – SELF","text":"public subroutine Read_Model2D(this, fileName) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in) :: fileName Contents Source Code Read_Model2D Source Code SUBROUTINE Read_Model2D ( this , fileName ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 4 ) INTEGER :: firstElem INTEGER :: N IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % decomp % mpiComm ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) END IF ! CALL ReadAttribute_HDF5(fileId,'N',N) ! IF (this % solution % interp % N /= N) THEN !   STOP 'Error : Solution polynomial degree does not match input file' ! END IF IF ( this % decomp % mpiEnabled ) THEN firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 4 ) = ( / 0 , 0 , 1 , firstElem / ) CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , & this % solution % interior , solOffset ) ELSE CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , this % solution % interior ) END IF CALL Close_HDF5 ( fileId ) IF ( this % gpuAccel ) THEN CALL this % solution % interior % UpdateDevice () END IF END SUBROUTINE Read_Model2D","tags":"","loc":"proc/read_model2d.html"},{"title":"ReprojectFlux_Model2D – SELF","text":"public subroutine ReprojectFlux_Model2D(this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this Contents Source Code ReprojectFlux_Model2D Source Code SUBROUTINE ReprojectFlux_Model2D ( this ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CALL this % flux % ContravariantProjection ( this % geometry , this % gpuAccel ) END SUBROUTINE ReprojectFlux_Model2D","tags":"","loc":"proc/reprojectflux_model2d.html"},{"title":"ResizePrevSol_Model2D – SELF","text":"public subroutine ResizePrevSol_Model2D(this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code ResizePrevSol_Model2D Source Code SUBROUTINE ResizePrevSol_Model2D ( this , m ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: nVar ! Free space, if necessary CALL this % prevSol % Free () ! Reallocate with increased variable dimension for ! storing \"m\" copies of solution data nVar = this % solution % nVar CALL this % prevSol % Init ( this % geometry % x % interp , m * nVar , this % mesh % nElem ) END SUBROUTINE ResizePrevSol_Model2D","tags":"","loc":"proc/resizeprevsol_model2d.html"},{"title":"SetSolutionFromChar_Model2D – SELF","text":"public subroutine SetSolutionFromChar_Model2D(this, eqnChar) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) Contents Source Code SetSolutionFromChar_Model2D Source Code SUBROUTINE SetSolutionFromChar_Model2D ( this , eqnChar ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: eqnChar ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar DO iVar = 1 , this % solution % nVar CALL this % solution % SetEquation ( ivar , TRIM ( eqnChar ( iVar ))) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromChar_Model2D","tags":"","loc":"proc/setsolutionfromchar_model2d.html"},{"title":"SetSolutionFromEqn_Model2D – SELF","text":"public subroutine SetSolutionFromEqn_Model2D(this, eqn) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) Contents Source Code SetSolutionFromEqn_Model2D Source Code SUBROUTINE SetSolutionFromEqn_Model2D ( this , eqn ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar ! Copy the equation parser DO iVar = 1 , this % solution % nVar CALL this % solution % SetEquation ( ivar , eqn ( iVar ) % equation ) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromEqn_Model2D","tags":"","loc":"proc/setsolutionfromeqn_model2d.html"},{"title":"UpdateDevice_Model2D – SELF","text":"public subroutine UpdateDevice_Model2D(this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this Contents Source Code UpdateDevice_Model2D Source Code SUBROUTINE UpdateDevice_Model2D ( this ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CALL this % mesh % UpdateDevice () CALL this % geometry % UpdateDevice () CALL this % dSdt % UpdateDevice () CALL this % solution % UpdateDevice () CALL this % solutionGradient % UpdateDevice () CALL this % flux % UpdateDevice () CALL this % source % UpdateDevice () CALL this % fluxDivergence % UpdateDevice () END SUBROUTINE UpdateDevice_Model2D","tags":"","loc":"proc/updatedevice_model2d.html"},{"title":"UpdateGAB2_Model2D – SELF","text":"public subroutine UpdateGAB2_Model2D(this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGAB2_Model2D Source Code SUBROUTINE UpdateGAB2_Model2D ( this , m ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB2_Model2D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE ! ab2_weight IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Reset solution DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last solution this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & 1.5_PREC * this % prevSol % interior % hostData ( i , j , iVar , iEl ) - & 0.5_PREC * this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) END DO END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB2_Model2D","tags":"","loc":"proc/updategab2_model2d.html"},{"title":"UpdateGAB3_Model2D – SELF","text":"public subroutine UpdateGAB3_Model2D(this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGAB3_Model2D Source Code SUBROUTINE UpdateGAB3_Model2D ( this , m ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB3_Model2D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 2 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & ( 2 3.0_PREC * this % prevSol % interior % hostData ( i , j , iVar , iEl ) - & 1 6.0_PREC * this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) + & 5.0_PREC * this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl )) / 1 2.0_PREC END DO END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB3_Model2D","tags":"","loc":"proc/updategab3_model2d.html"},{"title":"UpdateGAB4_Model2D – SELF","text":"public subroutine UpdateGAB4_Model2D(this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGAB4_Model2D Source Code SUBROUTINE UpdateGAB4_Model2D ( this , m ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB4_Model2D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 2 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 3 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions this % prevSol % interior % hostData ( i , j , 3 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & ( 5 5.0_PREC * this % prevSol % interior % hostData ( i , j , iVar , iEl ) - & 5 9.0_PREC * this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) + & 3 7.0_PREC * this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) - & 9.0_PREC * this % prevSol % interior % hostData ( i , j , 3 * nVar + iVar , iEl )) / 2 4.0_PREC END DO END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB4_Model2D","tags":"","loc":"proc/updategab4_model2d.html"},{"title":"UpdateGRK2_Model2D – SELF","text":"public subroutine UpdateGRK2_Model2D(this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK2_Model2D Source Code SUBROUTINE UpdateGRK2_Model2D ( this , m ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model2D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk2_a ( m ), rk2_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , iVar , iEl ) = rk2_a ( m ) * & this % workSol % interior % hostData ( i , j , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & rk2_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateGRK2_Model2D","tags":"","loc":"proc/updategrk2_model2d.html"},{"title":"UpdateGRK3_Model2D – SELF","text":"public subroutine UpdateGRK3_Model2D(this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK3_Model2D Source Code SUBROUTINE UpdateGRK3_Model2D ( this , m ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model2D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk3_a ( m ), rk3_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , iVar , iEl ) = rk3_a ( m ) * & this % workSol % interior % hostData ( i , j , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & rk3_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateGRK3_Model2D","tags":"","loc":"proc/updategrk3_model2d.html"},{"title":"UpdateGRK4_Model2D – SELF","text":"public subroutine UpdateGRK4_Model2D(this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK4_Model2D Source Code SUBROUTINE UpdateGRK4_Model2D ( this , m ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model2D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk4_a ( m ), rk4_g ( m ), this % dt , & this % workSol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , iVar , iEl ) = rk4_a ( m ) * & this % workSol % interior % hostData ( i , j , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & rk4_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateGRK4_Model2D","tags":"","loc":"proc/updategrk4_model2d.html"},{"title":"UpdateHost_Model2D – SELF","text":"public subroutine UpdateHost_Model2D(this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this Contents Source Code UpdateHost_Model2D Source Code SUBROUTINE UpdateHost_Model2D ( this ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CALL this % mesh % UpdateHost () CALL this % geometry % UpdateHost () CALL this % solution % UpdateHost () CALL this % dSdt % UpdateHost () CALL this % solution % UpdateHost () CALL this % solutionGradient % UpdateHost () CALL this % flux % UpdateHost () CALL this % source % UpdateHost () CALL this % fluxDivergence % UpdateHost () END SUBROUTINE UpdateHost_Model2D","tags":"","loc":"proc/updatehost_model2d.html"},{"title":"UpdateSolution_Model2D – SELF","text":"public subroutine UpdateSolution_Model2D(this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt Contents Source Code UpdateSolution_Model2D Source Code SUBROUTINE UpdateSolution_Model2D ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this REAL ( prec ), OPTIONAL , INTENT ( in ) :: dt ! Local REAL ( prec ) :: dtLoc INTEGER :: i , j , iVar , iEl IF ( PRESENT ( dt )) THEN dtLoc = dt ELSE dtLoc = this % dt END IF IF ( this % gpuAccel ) THEN CALL UpdateSolution_Model2D_gpu_wrapper ( this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & dtLoc , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & dtLoc * this % dSdt % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateSolution_Model2D","tags":"","loc":"proc/updatesolution_model2d.html"},{"title":"WriteTecplot_Model2D – SELF","text":"public subroutine WriteTecplot_Model2D(this, filename) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in), optional :: filename Contents Source Code WriteTecplot_Model2D Source Code SUBROUTINE WriteTecplot_Model2D ( this , filename ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ), OPTIONAL :: filename ! Local CHARACTER ( 8 ) :: zoneID INTEGER :: fUnit INTEGER :: iEl , i , j , iVar CHARACTER ( LEN = self_FileNameLength ) :: tecFile CHARACTER ( LEN = self_TecplotHeaderLength ) :: tecHeader CHARACTER ( LEN = self_FormatLength ) :: fmat CHARACTER ( 13 ) :: timeStampString CHARACTER ( 5 ) :: rankString TYPE ( Scalar2D ) :: solution TYPE ( Vector2D ) :: solutionGradient TYPE ( Vector2D ) :: x TYPE ( Lagrange ), TARGET :: interp IF ( PRESENT ( filename )) THEN tecFile = filename ELSE WRITE ( timeStampString , '(I13.13)' ) this % ioIterate IF ( this % decomp % mpiEnabled ) THEN WRITE ( rankString , '(I5.5)' ) this % decomp % rankId tecFile = 'solution.' // rankString // '.' // timeStampString // '.tec' ELSE tecFile = 'solution.' // timeStampString // '.tec' END IF END IF ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL solutionGradient % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solutionGradient % GridInterp ( solutionGradient , gpuAccel = . FALSE .) OPEN ( UNIT = NEWUNIT ( fUnit ), & FILE = TRIM ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) tecHeader = 'VARIABLES = \"X\", \"Y\"' DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"' // TRIM ( this % solution % meta ( iVar ) % name ) // '\"' END DO DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"d/dx(' // TRIM ( this % solution % meta ( iVar ) % name ) // ')\"' END DO DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"d/dy(' // TRIM ( this % solution % meta ( iVar ) % name ) // ')\"' END DO WRITE ( fUnit , * ) TRIM ( tecHeader ) ! Create format statement WRITE ( fmat , * ) 3 * this % solution % nvar + 2 fmat = '(' // TRIM ( fmat ) // '(ES16.7E3,1x))' DO iEl = 1 , this % solution % nElem ! TO DO :: Get the global element ID WRITE ( zoneID , '(I8.8)' ) iEl WRITE ( fUnit , * ) 'ZONE T=\"el' // TRIM ( zoneID ) // '\", I=' , this % solution % interp % M + 1 , & ', J=' , this % solution % interp % M + 1 DO j = 0 , this % solution % interp % M DO i = 0 , this % solution % interp % M WRITE ( fUnit , fmat ) x % interior % hostData ( 1 , i , j , 1 , iEl ), & x % interior % hostData ( 2 , i , j , 1 , iEl ), & solution % interior % hostData ( i , j , 1 : this % solution % nvar , iEl ), & solutionGradient % interior % hostData ( 1 , i , j , 1 : this % solution % nvar , iEl ), & solutionGradient % interior % hostData ( 2 , i , j , 1 : this % solution % nvar , iEl ) END DO END DO END DO CLOSE ( UNIT = fUnit ) CALL x % Free () CALL solution % Free () CALL interp % Free () END SUBROUTINE WriteTecplot_Model2D","tags":"","loc":"proc/writetecplot_model2d.html"},{"title":"Write_Model2D – SELF","text":"public subroutine Write_Model2D(this, fileName) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in), optional :: fileName Contents Source Code Write_Model2D Source Code SUBROUTINE Write_Model2D ( this , fileName ) #undef __FUNC__ #define __FUNC__ \"Write_Model2D\" IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CHARACTER ( * ), OPTIONAL , INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId TYPE ( Scalar2D ) :: solution TYPE ( Vector2D ) :: x TYPE ( Lagrange ), TARGET :: interp CHARACTER ( LEN = self_FileNameLength ) :: pickupFile CHARACTER ( 13 ) :: timeStampString IF ( PRESENT ( filename )) THEN pickupFile = filename ELSE WRITE ( timeStampString , '(I13.13)' ) this % ioIterate pickupFile = 'solution.' // timeStampString // '.h5' END IF IF ( this % gpuAccel ) THEN CALL this % solution % UpdateHost () CALL this % solutionGradient % UpdateHost () END IF INFO ( \"Writing pickup file : \" // TRIM ( pickupFile )) IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId , this % decomp % mpiComm ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file INFO ( \"Writing control grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid/mesh' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/mesh/coords' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) CALL Close_HDF5 ( fileId ) ELSE CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' ) ! Write the geometry to file INFO ( \"Writing control grid  geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file INFO ( \"Writing target grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' ) ! Write the geometry to file INFO ( \"Writing target grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid/geometry' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/geometry/x' ) CALL Close_HDF5 ( fileId ) END IF CALL x % Free () CALL solution % Free () CALL interp % Free () END SUBROUTINE Write_Model2D","tags":"","loc":"proc/write_model2d.html"},{"title":"CalculateDSDt_Model2D_gpu_wrapper – SELF","text":"interface public subroutine CalculateDSDt_Model2D_gpu_wrapper(fluxDivergence, source, dSdt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: fluxDivergence type(C_PTR) :: source type(C_PTR) :: dSdt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/calculatedsdt_model2d_gpu_wrapper.html"},{"title":"UpdateGAB2_Model2D_gpu_wrapper – SELF","text":"interface public subroutine UpdateGAB2_Model2D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updategab2_model2d_gpu_wrapper.html"},{"title":"UpdateGAB3_Model2D_gpu_wrapper – SELF","text":"interface public subroutine UpdateGAB3_Model2D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updategab3_model2d_gpu_wrapper.html"},{"title":"UpdateGAB4_Model2D_gpu_wrapper – SELF","text":"interface public subroutine UpdateGAB4_Model2D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updategab4_model2d_gpu_wrapper.html"},{"title":"UpdateGRK_Model2D_gpu_wrapper – SELF","text":"interface public subroutine UpdateGRK_Model2D_gpu_wrapper(grk, solution, dSdt, rk_a, rk_g, dt, nWork, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: grk type(C_PTR) :: solution type(C_PTR) :: dSdt real(kind=c_prec), VALUE :: rk_a real(kind=c_prec), VALUE :: rk_g real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: nWork integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updategrk_model2d_gpu_wrapper.html"},{"title":"UpdateSolution_Model2D_gpu_wrapper – SELF","text":"interface public subroutine UpdateSolution_Model2D_gpu_wrapper(solution, dSdt, dt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: solution type(C_PTR) :: dSdt real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updatesolution_model2d_gpu_wrapper.html"},{"title":"DomainDecomp – SELF","text":"public subroutine DomainDecomp(nElems, nDomains, offsetElem) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nElems integer, intent(in) :: nDomains integer, intent(out) :: offsetElem (0:nDomains) Contents Source Code DomainDecomp Source Code SUBROUTINE DomainDecomp ( nElems , nDomains , offSetElem ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 4 IMPLICIT NONE INTEGER , INTENT ( in ) :: nElems INTEGER , INTENT ( in ) :: nDomains INTEGER , INTENT ( out ) :: offsetElem ( 0 : nDomains ) ! Local INTEGER :: nLocalElems INTEGER :: remainElems INTEGER :: iDom nLocalElems = nElems / nDomains remainElems = nElems - nLocalElems * nDomains DO iDom = 0 , nDomains - 1 offSetElem ( iDom ) = iDom * nLocalElems + MIN ( iDom , remainElems ) END DO offSetElem ( nDomains ) = nElems END SUBROUTINE DomainDecomp","tags":"","loc":"proc/domaindecomp.html"},{"title":"ElemToRank – SELF","text":"public subroutine ElemToRank(nDomains, offsetElem, elemID, domain) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDomains integer, intent(in) :: offsetElem (0:nDomains) integer, intent(in) :: elemID integer, intent(out) :: domain Contents Source Code ElemToRank Source Code SUBROUTINE ElemToRank ( nDomains , offsetElem , elemID , domain ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 7 !   \"Find domain containing element index\" ! IMPLICIT NONE INTEGER , INTENT ( in ) :: nDomains INTEGER , INTENT ( in ) :: offsetElem ( 0 : nDomains ) INTEGER , INTENT ( in ) :: elemID INTEGER , INTENT ( out ) :: domain ! Local INTEGER :: maxSteps INTEGER :: low , up , mid INTEGER :: i domain = 0 maxSteps = INT ( LOG10 ( REAL ( nDomains )) / LOG10 ( 2.0 )) + 1 low = 0 up = nDomains - 1 IF ( offsetElem ( low ) < elemID . AND . elemID <= offsetElem ( low + 1 )) THEN domain = low ELSEIF ( offsetElem ( up ) < elemID . AND . elemID <= offsetElem ( up + 1 )) THEN domain = up ELSE DO i = 1 , maxSteps mid = ( up - low ) / 2 + low IF ( offsetElem ( mid ) < elemID . AND . elemID <= offsetElem ( mid + 1 )) THEN domain = mid RETURN ELSEIF ( elemID > offsetElem ( mid + 1 )) THEN low = mid + 1 ELSE up = mid END IF END DO END IF END SUBROUTINE ElemToRank","tags":"","loc":"proc/elemtorank.html"},{"title":"FinalizeMPIExchangeAsync – SELF","text":"public subroutine FinalizeMPIExchangeAsync(mpiHandler) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: mpiHandler Contents Source Code FinalizeMPIExchangeAsync Source Code SUBROUTINE FinalizeMPIExchangeAsync ( mpiHandler ) CLASS ( MPILayer ), INTENT ( inout ) :: mpiHandler ! Local INTEGER :: ierror IF ( mpiHandler % mpiEnabled ) THEN CALL MPI_WaitAll ( mpiHandler % msgCount , & mpiHandler % requests ( 1 : mpiHandler % msgCount ), & mpiHandler % stats ( 1 : MPI_STATUS_SIZE , 1 : mpiHandler % msgCount ), & iError ) ENDIF END SUBROUTINE FinalizeMPIExchangeAsync","tags":"","loc":"proc/finalizempiexchangeasync.html"},{"title":"Finalize_MPILayer – SELF","text":"public subroutine Finalize_MPILayer(this) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this Contents Source Code Finalize_MPILayer Source Code SUBROUTINE Finalize_MPILayer ( this ) #undef __FUNC__ #define __FUNC__ \"Finalize_MPILayer\" IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this ! Local INTEGER :: ierror CHARACTER ( 30 ) :: msg IF ( this % mpiEnabled ) THEN WRITE ( msg , '(I5)' ) this % rankId msg = \"Goodbye from rank \" // TRIM ( msg ) // \".\" INFO ( TRIM ( msg )) CALL MPI_FINALIZE ( ierror ) ENDIF END SUBROUTINE Finalize_MPILayer","tags":"","loc":"proc/finalize_mpilayer.html"},{"title":"Free_MPILayer – SELF","text":"public subroutine Free_MPILayer(this) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this Contents Source Code Free_MPILayer Source Code SUBROUTINE Free_MPILayer ( this ) IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this IF ( ASSOCIATED ( this % offSetElem % hostData )) THEN CALL this % offSetElem % Free () ENDIF IF ( ASSOCIATED ( this % elemToRank % hostData )) THEN CALL this % elemToRank % Free () ENDIF DEALLOCATE ( this % requests ) DEALLOCATE ( this % stats ) END SUBROUTINE Free_MPILayer","tags":"","loc":"proc/free_mpilayer.html"},{"title":"Free_Mesh1D – SELF","text":"public subroutine Free_Mesh1D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh Contents Source Code Free_Mesh1D Source Code SUBROUTINE Free_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nNodes = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % elemInfo % Free () CALL myMesh % nodeCoords % Free () CALL myMesh % globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh1D","tags":"","loc":"proc/free_mesh1d.html"},{"title":"Free_Mesh2D – SELF","text":"public subroutine Free_Mesh2D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh Contents Source Code Free_Mesh2D Source Code SUBROUTINE Free_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nNodes = 0 myMesh % nSides = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % elemInfo % Free () CALL myMesh % sideInfo % Free () CALL myMesh % nodeCoords % Free () CALL myMesh % CGNSCornerMap % Free () CALL myMesh % globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh2D","tags":"","loc":"proc/free_mesh2d.html"},{"title":"Free_Mesh3D – SELF","text":"public subroutine Free_Mesh3D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh Contents Source Code Free_Mesh3D Source Code SUBROUTINE Free_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nSides = 0 myMesh % nNodes = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % elemInfo % Free () CALL myMesh % sideInfo % Free () CALL myMesh % nodeCoords % Free () CALL myMesh % CGNSCornerMap % Free () CALL myMesh % globalNodeIDs % Free () CALL myMesh % sideMap % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh3D","tags":"","loc":"proc/free_mesh3d.html"},{"title":"GenerateDecomposition_MPILayer – SELF","text":"public subroutine GenerateDecomposition_MPILayer(this, nGlobalElem, maxMsg) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this integer, intent(in) :: nGlobalElem integer, intent(in) :: maxMsg Contents Source Code GenerateDecomposition_MPILayer Source Code SUBROUTINE GenerateDecomposition_MPILayer ( this , nGlobalElem , maxMsg ) #undef __FUNC__ #define __FUNC__ \"GenerateDecomposition_MPILayer\" IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: nGlobalElem INTEGER , INTENT ( in ) :: maxMsg ! Local INTEGER :: maxMsgLoc CHARACTER ( 50 ) :: msg CHARACTER ( 5 ) :: msg2 CALL this % setElemToRank ( nGlobalElem ) CALL this % SetMaxMsg ( maxMsg ) WRITE ( msg , '(I5)' ) this % rankId WRITE ( msg2 , '(I5)' ) this % offSetElem % hostData ( this % rankId + 1 ) - & this % offSetElem % hostData ( this % rankId ) msg = \"Rank \" // TRIM ( msg ) // \": nElem = \" // TRIM ( msg2 ) INFO ( TRIM ( msg )) END SUBROUTINE GenerateDecomposition_MPILayer","tags":"","loc":"proc/generatedecomposition_mpilayer.html"},{"title":"GlobalReduce_RealScalar – SELF","text":"public subroutine GlobalReduce_RealScalar(mpiHandler, sendBuf, recvBuf) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(in) :: mpiHandler real(kind=prec), intent(in) :: sendBuf real(kind=prec), intent(out) :: recvBuf Contents Source Code GlobalReduce_RealScalar Source Code SUBROUTINE GlobalReduce_RealScalar ( mpiHandler , sendBuf , recvBuf ) CLASS ( MPILayer ), INTENT ( in ) :: mpiHandler REAL ( prec ), INTENT ( in ) :: sendBuf REAL ( prec ), INTENT ( out ) :: recvBuf ! Local INTEGER :: iError IF ( mpiHandler % mpiEnabled ) THEN CALL MPI_ALLREDUCE ( sendBuf , & recvBuf , & 1 , & mpiHandler % mpiPrec , & MPI_SUM , & mpiHandler % mpiComm , & iError ) ELSE recvBuf = sendBuf ENDIF END SUBROUTINE GlobalReduce_RealScalar","tags":"","loc":"proc/globalreduce_realscalar.html"},{"title":"Init_MPILayer – SELF","text":"public subroutine Init_MPILayer(this, enableMPI) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(out) :: this logical, intent(in) :: enableMPI Contents Source Code Init_MPILayer Source Code SUBROUTINE Init_MPILayer ( this , enableMPI ) #undef __FUNC__ #define __FUNC__ \"Init_MPILayer\" IMPLICIT NONE CLASS ( MPILayer ), INTENT ( out ) :: this LOGICAL , INTENT ( in ) :: enableMPI ! Local INTEGER :: ierror CHARACTER ( 50 ) :: msg INTEGER :: nGPU , gpuID CHARACTER ( 2 ) :: msg2 this % mpiComm = 0 this % mpiPrec = prec this % rankId = 0 this % nRanks = 1 this % nElem = 0 this % mpiEnabled = enableMPI IF ( enableMPI ) THEN this % mpiComm = MPI_COMM_WORLD CALL MPI_INIT ( ierror ) CALL MPI_COMM_RANK ( this % mpiComm , this % rankId , ierror ) CALL MPI_COMM_SIZE ( this % mpiComm , this % nRanks , ierror ) END IF IF ( prec == real32 ) THEN this % mpiPrec = MPI_FLOAT ELSE this % mpiPrec = MPI_DOUBLE END IF CALL this % offSetElem % Alloc ( 0 , this % nRanks ) WRITE ( msg , '(I5)' ) this % rankId msg = \"Greetings from rank \" // TRIM ( msg ) // \".\" INFO ( TRIM ( msg )) IF ( GPUAvailable () ) THEN ! Get the number of GPUs per node CALL hipCheck ( hipGetDeviceCount ( nGPU )) ! Assume that we have the 1 GPU per rank ! implying that nMPIRanksPerNode = nGPU ! Assume that all nodes have the same number of GPUs per node gpuID = MOD ( this % rankId , nGPU ) CALL hipCheck ( hipSetDevice ( gpuID )) WRITE ( msg , '(I5)' ) this % rankId WRITE ( msg2 , '(I2)' ) gpuID msg = \"Rank \" // TRIM ( msg ) // \": Setting device to GPU\" // TRIM ( msg2 ) INFO ( TRIM ( msg )) ENDIF END SUBROUTINE Init_MPILayer","tags":"","loc":"proc/init_mpilayer.html"},{"title":"Init_Mesh1D – SELF","text":"public subroutine Init_Mesh1D(myMesh, nGeo, nElem, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nNodes integer, intent(in) :: nBCs Contents Source Code Init_Mesh1D Source Code SUBROUTINE Init_Mesh1D ( myMesh , nGeo , nElem , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs myMesh % nGeo = nGeo myMesh % nElem = nElem myMesh % nGlobalElem = nElem myMesh % nNodes = nNodes myMesh % nCornerNodes = nElem * 2 myMesh % nUniqueNodes = 0 myMesh % nBCs = nBCs CALL myMesh % elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nElem / )) CALL myMesh % nodeCoords % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % globalNodeIDs % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) END SUBROUTINE Init_Mesh1D","tags":"","loc":"proc/init_mesh1d.html"},{"title":"Init_Mesh2D – SELF","text":"public subroutine Init_Mesh2D(myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs Contents Source Code Init_Mesh2D Source Code SUBROUTINE Init_Mesh2D ( myMesh , nGeo , nElem , nSides , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nSides INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs ! Local INTEGER :: i , j , l myMesh % nGeo = nGeo myMesh % nElem = nElem myMesh % nGlobalElem = nElem myMesh % nNodes = nNodes myMesh % nSides = nSides myMesh % nCornerNodes = 0 myMesh % nUniqueNodes = 0 myMesh % nUniqueSides = 0 myMesh % nBCs = nBCs CALL myMesh % elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nElem / )) CALL myMesh % sideInfo % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / 5 , 4 , nElem / )) CALL myMesh % nodeCoords % Alloc ( loBound = ( / 1 , 0 , 0 , 1 / ), & upBound = ( / 2 , nGeo , nGeo , nElem / )) CALL myMesh % globalNodeIDs % Alloc ( loBound = ( / 0 , 0 , 1 / ), & upBound = ( / nGeo , nGeo , nElem / )) CALL myMesh % CGNSCornerMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , 4 / )) CALL myMesh % CGNSSideMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , 4 / )) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation myMesh % CGNSCornerMap % hostData ( 1 : 2 , 1 ) = ( / 0 , 0 / ) myMesh % CGNSCornerMap % hostData ( 1 : 2 , 2 ) = ( / nGeo , 0 / ) myMesh % CGNSCornerMap % hostData ( 1 : 2 , 3 ) = ( / nGeo , nGeo / ) myMesh % CGNSCornerMap % hostData ( 1 : 2 , 4 ) = ( / 0 , nGeo / ) ! Maps from local corner node id to CGNS side myMesh % CGNSSideMap % hostData ( 1 : 2 , 1 ) = ( / 1 , 2 / ) myMesh % CGNSSideMap % hostData ( 1 : 2 , 2 ) = ( / 2 , 3 / ) myMesh % CGNSSideMap % hostData ( 1 : 2 , 3 ) = ( / 4 , 3 / ) myMesh % CGNSSideMap % hostData ( 1 : 2 , 4 ) = ( / 1 , 4 / ) END SUBROUTINE Init_Mesh2D","tags":"","loc":"proc/init_mesh2d.html"},{"title":"Init_Mesh3D – SELF","text":"public subroutine Init_Mesh3D(myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs Contents Source Code Init_Mesh3D Source Code SUBROUTINE Init_Mesh3D ( myMesh , nGeo , nElem , nSides , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nSides INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs ! Local INTEGER :: i , j , k , l myMesh % nElem = nElem myMesh % nGlobalElem = nElem myMesh % nGeo = nGeo myMesh % nSides = nSides myMesh % nNodes = nNodes myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = nBCs CALL myMesh % elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nElem / )) CALL myMesh % sideInfo % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / 5 , 6 , nElem / )) CALL myMesh % nodeCoords % Alloc ( loBound = ( / 1 , 0 , 0 , 0 , 1 / ), & upBound = ( / 3 , nGeo , nGeo , nGeo , nElem / )) CALL myMesh % globalNodeIDs % Alloc ( loBound = ( / 0 , 0 , 0 , 1 / ), & upBound = ( / nGeo , nGeo , nGeo , nElem / )) CALL myMesh % CGNSCornerMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , 8 / )) CALL myMesh % sideMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , 6 / )) CALL myMesh % CGNSSideMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , 6 / )) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation myMesh % CGNSCornerMap % hostData ( 1 : 3 , 1 ) = ( / 0 , 0 , 0 / ) ! Bottom-South-West myMesh % CGNSCornerMap % hostData ( 1 : 3 , 2 ) = ( / nGeo , 0 , 0 / ) ! Bottom-South-East myMesh % CGNSCornerMap % hostData ( 1 : 3 , 3 ) = ( / nGeo , nGeo , 0 / ) ! Bottom-North-East myMesh % CGNSCornerMap % hostData ( 1 : 3 , 4 ) = ( / 0 , nGeo , 0 / ) ! Bottom-North-West myMesh % CGNSCornerMap % hostData ( 1 : 3 , 5 ) = ( / 0 , 0 , nGeo / ) ! Top-South-West myMesh % CGNSCornerMap % hostData ( 1 : 3 , 6 ) = ( / nGeo , 0 , nGeo / ) ! Top-South-East myMesh % CGNSCornerMap % hostData ( 1 : 3 , 7 ) = ( / nGeo , nGeo , nGeo / ) ! Top-North-East myMesh % CGNSCornerMap % hostData ( 1 : 3 , 8 ) = ( / 0 , nGeo , nGeo / ) ! Top-North-West ! Maps from local corner node id to CGNS side myMesh % CGNSSideMap % hostData ( 1 : 4 , 1 ) = ( / 1 , 4 , 3 , 2 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 4 ) = ( / 3 , 4 , 8 , 7 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 5 ) = ( / 1 , 5 , 8 , 4 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) myMesh % sideMap % hostData ( 1 : 4 , 1 ) = ( / 1 , 2 , 3 , 4 / ) ! Bottom myMesh % sideMap % hostData ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) ! South myMesh % sideMap % hostData ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) ! East myMesh % sideMap % hostData ( 1 : 4 , 4 ) = ( / 4 , 3 , 7 , 8 / ) ! North myMesh % sideMap % hostData ( 1 : 4 , 5 ) = ( / 1 , 4 , 8 , 5 / ) ! West myMesh % sideMap % hostData ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) ! Top END SUBROUTINE Init_Mesh3D","tags":"","loc":"proc/init_mesh3d.html"},{"title":"Read_HOPr_Mesh2D – SELF","text":"public subroutine Read_HOPr_Mesh2D(myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh character, intent(in) :: meshFile type( MPILayer ), intent(inout) :: decomp Contents Source Code Read_HOPr_Mesh2D Source Code SUBROUTINE Read_HOPr_Mesh2D ( myMesh , meshFile , decomp ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 ! Adapted for 2D Mesh : Note that HOPR does not have 2D mesh output. IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile TYPE ( MPILayer ), INTENT ( inout ) :: decomp ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) INTEGER :: nGlobalElem INTEGER :: firstElem INTEGER :: firstNode INTEGER :: firstSide INTEGER :: nLocalElems INTEGER :: nLocalNodes3D INTEGER :: nLocalSides3D INTEGER :: nUniqueSides3D INTEGER :: nLocalNodes2D INTEGER :: nLocalSides2D INTEGER :: nUniqueSides2D INTEGER :: nGeo , nBCs INTEGER :: eid , lsid , iSide INTEGER :: i , j , nid TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType IF ( decomp % mpiEnabled ) THEN CALL Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId , decomp % mpiComm ) ELSE CALL Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId ) ENDIF CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) CALL ReadAttribute_HDF5 ( fileId , 'nUniqueSides' , nUniqueSides3D ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) IF ( decomp % mpiEnabled ) THEN offset (:) = 0 CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) ELSE CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType ) ENDIF ! Read local subarray of ElemInfo CALL decomp % GenerateDecomposition ( nGlobalElem , nUniqueSides3D ) firstElem = decomp % offsetElem % hostData ( decomp % rankId ) + 1 nLocalElems = decomp % offsetElem % hostData ( decomp % rankId + 1 ) - & decomp % offsetElem % hostData ( decomp % rankId ) ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nLocalElems / )) IF ( decomp % mpiEnabled ) THEN offset = ( / 0 , firstElem - 1 / ) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) ELSE CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) ENDIF ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo % hostData ( 5 , 1 ) + 1 nLocalNodes3D = hopr_elemInfo % hostData ( 6 , nLocalElems ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , nLocalNodes3D / )) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes3D ) IF ( decomp % mpiEnabled ) THEN offset = ( / 0 , firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) ELSE CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) ENDIF ! Read local subarray of SideInfo firstSide = hopr_elemInfo % hostData ( 3 , 1 ) + 1 nLocalSides3D = hopr_elemInfo % hostData ( 4 , nLocalElems ) - hopr_elemInfo % hostData ( 3 , 1 ) ! Allocate space for hopr_sideInfo CALL hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nLocalSides3D / )) IF ( decomp % mpiEnabled ) THEN offset = ( / 0 , firstSide - 1 / ) CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) ELSE CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) ENDIF CALL Close_HDF5 ( fileID ) ! ---- Done reading 3-D Mesh information ---- ! ! Now we need to convert from 3-D to 2-D ! nLocalSides2D = nLocalSides3D - 2 * nGlobalElem nUniqueSides2D = nUniqueSides3D - 2 * nGlobalElem ! Remove the \"top\" and \"bottom\" faces nLocalNodes2D = nLocalNodes2D - nGlobalElem * nGeo * ( nGeo + 1 ) ** 2 ! Remove the third dimension CALL myMesh % Init ( nGeo , nLocalElems , nLocalSides2D , nLocalNodes2D , nBCs ) ! Copy data from local arrays into myMesh !  elemInfo(1:6,iEl) !    1 - Element Type !    2 - Zone !    3 - offset index for side array (not needed when all quads are assumed) !    4 - last index for side array (not needed when all quads are assumed) !    5 - offset index for node array (not needed when all quads are assumed) !    6 - last index for node array (not needed when all quads are assumed) myMesh % elemInfo % hostData = hopr_elemInfo % hostData myMesh % quadrature = UNIFORM ! HOPr uses uniformly spaced points ! Grab the node coordinates (x and y only) from the \"bottom\" layer of the extruded mesh DO eid = 1 , myMesh % nElem DO j = 0 , nGeo DO i = 0 , nGeo nid = i + 1 + ( nGeo + 1 ) * ( j + ( nGeo + 1 ) * (( nGeo + 1 ) * ( eid - 1 ))) myMesh % nodeCoords % hostData ( 1 : 2 , i , j , eid ) = hopr_nodeCoords % hostData ( 1 : 2 , nid ) myMesh % globalNodeIDs % hostData ( i , j , eid ) = hopr_globalNodeIDs % hostData ( nid ) ENDDO ENDDO ENDDO ! Grab the south, west, north, and south sides of the elements !  sideInfo(1:5,iSide,iEl) ! !    1 - Side Type (currently unused in SELF) !    2 - Global Side ID (Used for message passing. Don't need to change) !    3 - Neighbor Element ID (Can stay the same) !    4 - 10*( neighbor local side )  + flip (Need to recalculate flip) !    5 - Boundary Condition ID (Can stay the same) DO eid = 1 , myMesh % nElem DO lsid = 1 , 4 ! Calculate the 3-D side ID from the 2-D local side id and element ID iSide = lsid + 1 + 6 * ( eid - 1 ) myMesh % sideInfo % hostData ( 1 : 5 , lsid , eid ) = hopr_sideInfo % hostData ( 1 : 5 , iSide ) ! Adjust the secondary side index for 2-D myMesh % sideInfo % hostData ( 4 , lsid , eid ) = myMesh % sideInfo % hostData ( 4 , lsid , eid ) - 10 ENDDO ENDDO CALL myMesh % RecalculateFlip () CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () CALL hopr_sideInfo % Free () END SUBROUTINE Read_HOPr_Mesh2D","tags":"","loc":"proc/read_hopr_mesh2d.html"},{"title":"Read_HOPr_Mesh3D – SELF","text":"public subroutine Read_HOPr_Mesh3D(myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh character, intent(in) :: meshFile type( MPILayer ), intent(inout) :: decomp Contents Source Code Read_HOPr_Mesh3D Source Code SUBROUTINE Read_HOPr_Mesh3D ( myMesh , meshFile , decomp ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile TYPE ( MPILayer ), INTENT ( inout ) :: decomp ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) INTEGER :: nGlobalElem INTEGER :: firstElem INTEGER :: firstNode INTEGER :: firstSide INTEGER :: nLocalElems INTEGER :: nLocalNodes INTEGER :: nLocalSides INTEGER :: nUniqueSides INTEGER :: nGeo , nBCs INTEGER :: eid , lsid , iSide INTEGER :: i , j , k , nid TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType IF ( decomp % mpiEnabled ) THEN CALL Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId , decomp % mpiComm ) ELSE CALL Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId ) ENDIF CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) CALL ReadAttribute_HDF5 ( fileId , 'nUniqueSides' , nUniqueSides ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) IF ( decomp % mpiEnabled ) THEN offset (:) = 0 CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) ELSE CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType ) ENDIF ! Read local subarray of ElemInfo CALL decomp % GenerateDecomposition ( nGlobalElem , nUniqueSides ) firstElem = decomp % offsetElem % hostData ( decomp % rankId ) + 1 nLocalElems = decomp % offsetElem % hostData ( decomp % rankId + 1 ) - & decomp % offsetElem % hostData ( decomp % rankId ) ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nLocalElems / )) IF ( decomp % mpiEnabled ) THEN offset = ( / 0 , firstElem - 1 / ) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) ELSE CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) ENDIF ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo % hostData ( 5 , 1 ) + 1 nLocalNodes = hopr_elemInfo % hostData ( 6 , nLocalElems ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , nLocalNodes / )) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes ) IF ( decomp % mpiEnabled ) THEN offset = ( / 0 , firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) ELSE CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) ENDIF ! Read local subarray of SideInfo firstSide = hopr_elemInfo % hostData ( 3 , 1 ) + 1 nLocalSides = hopr_elemInfo % hostData ( 4 , nLocalElems ) - hopr_elemInfo % hostData ( 3 , 1 ) ! Allocate space for hopr_sideInfo CALL hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nLocalSides / )) IF ( decomp % mpiEnabled ) THEN offset = ( / 0 , firstSide - 1 / ) CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) ELSE CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) ENDIF CALL Close_HDF5 ( fileID ) ! ---- Done reading 3-D Mesh information ---- ! ! Load hopr data into mesh data structure CALL myMesh % Init ( nGeo , nLocalElems , nLocalSides , nLocalNodes , nBCs ) ! Copy data from local arrays into myMesh myMesh % elemInfo % hostData = hopr_elemInfo % hostData myMesh % nUniqueSides = nUniqueSides myMesh % quadrature = UNIFORM ! Grab the node coordinates DO eid = 1 , myMesh % nElem DO k = 0 , nGeo DO j = 0 , nGeo DO i = 0 , nGeo nid = i + 1 + ( nGeo + 1 ) * ( j + ( nGeo + 1 ) * ( k + ( nGeo + 1 ) * ( eid - 1 ))) myMesh % nodeCoords % hostData ( 1 : 3 , i , j , k , eid ) = hopr_nodeCoords % hostData ( 1 : 3 , nid ) myMesh % globalNodeIDs % hostData ( i , j , k , eid ) = hopr_globalNodeIDs % hostData ( nid ) ENDDO ENDDO ENDDO ENDDO iSide = 0 DO eid = 1 , myMesh % nElem DO lsid = 1 , 6 iSide = iSide + 1 myMesh % sideInfo % hostData ( 1 : 5 , lsid , eid ) = hopr_sideInfo % hostData ( 1 : 5 , iSide ) ENDDO ENDDO CALL myMesh % RecalculateFlip () CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () CALL hopr_sideInfo % Free () END SUBROUTINE Read_HOPr_Mesh3D","tags":"","loc":"proc/read_hopr_mesh3d.html"},{"title":"RecalculateFlip_Mesh2D – SELF","text":"public subroutine RecalculateFlip_Mesh2D(myMesh, decomp) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh type( MPILayer ), intent(inout), optional :: decomp Contents Source Code RecalculateFlip_Mesh2D Source Code SUBROUTINE RecalculateFlip_Mesh2D ( myMesh , decomp ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh TYPE ( MPILayer ), INTENT ( inout ), OPTIONAL :: decomp ! Local INTEGER :: e1 INTEGER :: s1 INTEGER :: e2 INTEGER :: e2Global INTEGER :: s2 INTEGER :: flip INTEGER :: bcid INTEGER :: lnid1 ( 1 : 2 ) INTEGER :: lnid2 ( 1 : 2 ) INTEGER :: nid1 ( 1 : 2 , 1 : 4 , 1 : myMesh % nElem ) INTEGER :: nid2 ( 1 : 2 , 1 : 4 , 1 : myMesh % nElem ) INTEGER :: nloc1 ( 1 : 2 ) INTEGER :: nloc2 ( 1 : 2 ) INTEGER :: n1 INTEGER :: n1Global INTEGER :: n2 INTEGER :: n2Global INTEGER :: c1 INTEGER :: c2 INTEGER :: i , j INTEGER :: l INTEGER :: nShifts INTEGER :: neighborRank INTEGER :: rankId INTEGER :: offset INTEGER :: msgCount INTEGER :: globalSideId INTEGER , ALLOCATABLE :: requests (:) INTEGER , ALLOCATABLE :: stats (:,:) INTEGER :: iError LOGICAL :: theyMatch ALLOCATE ( requests ( 1 : myMesh % nSides * 2 )) ALLOCATE ( stats ( MPI_STATUS_SIZE , 1 : myMesh % nSides * 2 )) IF ( PRESENT ( decomp )) THEN rankId = decomp % rankId offset = decomp % offsetElem % hostData ( rankId ) ELSE rankId = 0 offset = 0 ENDIF msgCount = 0 DO e1 = 1 , myMesh % nElem DO s1 = 1 , 4 e2Global = myMesh % sideInfo % hostData ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = myMesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = myMesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = myMesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN IF ( PRESENT ( decomp )) THEN neighborRank = decomp % elemToRank % hostData ( e2Global ) ELSE neighborRank = 0 ENDIF IF ( neighborRank == rankId ) THEN lnid1 = myMesh % CGNSSideMap % hostData ( 1 : 2 , s1 ) ! local CGNS corner node ids for element 1 side lnid2 = myMesh % CGNSSideMap % hostData ( 1 : 2 , s2 ) ! local CGNS corner node ids for element 2 side DO l = 1 , 2 i = myMesh % CGNSCornerMap % hostData ( 1 , lnid1 ( l )) j = myMesh % CGNSCornerMap % hostData ( 2 , lnid1 ( l )) nid1 ( l , s1 , e1 ) = myMesh % globalNodeIDs % hostData ( i , j , e1 ) i = myMesh % CGNSCornerMap % hostData ( 1 , lnid2 ( l )) j = myMesh % CGNSCornerMap % hostData ( 2 , lnid2 ( l )) nid2 ( l , s1 , e1 ) = myMesh % globalNodeIDs % hostData ( i , j , e2 ) ENDDO ELSE ! In this case, we need to exchange globalSideId = ABS ( myMesh % sideInfo % hostdata ( 2 , s1 , e1 )) lnid1 = myMesh % CGNSSideMap % hostData ( 1 : 2 , s1 ) ! local CGNS corner node ids for element 1 side DO l = 1 , 2 i = myMesh % CGNSCornerMap % hostData ( 1 , lnid1 ( l )) j = myMesh % CGNSCornerMap % hostData ( 2 , lnid1 ( l )) nid1 ( l , s1 , e1 ) = myMesh % globalNodeIDs % hostData ( i , j , e1 ) msgCount = msgCount + 1 CALL MPI_IRECV ( nid2 ( l , s1 , e1 ), & 1 , & MPI_INTEGER , & neighborRank , globalSideId , & decomp % mpiComm , & requests ( msgCount ), iError ) ! Send nid1(l) from this rank to nid2(l) on the other rank msgCount = msgCount + 1 CALL MPI_ISEND ( nid1 ( l , s1 , e1 ), & 1 , & MPI_INTEGER , & neighborRank , globalSideId , & decomp % mpiComm , & requests ( msgCount ), iError ) ENDDO ENDIF ! MPI or not ENDIF ! If not physical boundary ENDDO ENDDO IF ( PRESENT ( decomp ) . AND . msgCount > 0 ) THEN CALL MPI_WaitAll ( msgCount , & requests ( 1 : msgCount ), & stats ( 1 : MPI_STATUS_SIZE , 1 : msgCount ), & iError ) ENDIF DO e1 = 1 , myMesh % nElem DO s1 = 1 , 4 s2 = myMesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 bcid = myMesh % sideInfo % hostData ( 5 , s1 , e1 ) nloc1 ( 1 : 2 ) = nid1 ( 1 : 2 , s1 , e1 ) nloc2 ( 1 : 2 ) = nid2 ( 1 : 2 , s1 , e1 ) IF ( bcid == 0 ) THEN theyMatch = CompareArray ( nloc1 , nloc2 , 2 ) IF ( theyMatch ) THEN myMesh % sideInfo % hostData ( 4 , s1 , e1 ) = 10 * s2 ELSE myMesh % sideInfo % hostData ( 4 , s1 , e1 ) = 10 * s2 + 1 ENDIF ENDIF ENDDO ENDDO DEALLOCATE ( requests ) DEALLOCATE ( stats ) END SUBROUTINE RecalculateFlip_Mesh2D","tags":"","loc":"proc/recalculateflip_mesh2d.html"},{"title":"RecalculateFlip_Mesh3D – SELF","text":"public subroutine RecalculateFlip_Mesh3D(myMesh, decomp) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh type( MPILayer ), intent(inout), optional :: decomp Contents Source Code RecalculateFlip_Mesh3D Source Code SUBROUTINE RecalculateFlip_Mesh3D ( myMesh , decomp ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh TYPE ( MPILayer ), INTENT ( inout ), OPTIONAL :: decomp ! Local INTEGER :: e1 INTEGER :: s1 INTEGER :: e2 INTEGER :: e2Global INTEGER :: s2 INTEGER :: flip INTEGER :: bcid INTEGER :: lnid1 ( 1 : 4 ) INTEGER :: lnid2 ( 1 : 4 ) INTEGER :: nid1 ( 1 : 4 , 1 : 6 , 1 : myMesh % nElem ) INTEGER :: nid2 ( 1 : 4 , 1 : 6 , 1 : myMesh % nElem ) INTEGER :: nloc1 ( 1 : 4 ) INTEGER :: nloc2 ( 1 : 4 ) INTEGER :: n1 INTEGER :: n1Global INTEGER :: n2 INTEGER :: n2Global INTEGER :: c1 INTEGER :: c2 INTEGER :: i , j , k INTEGER :: l INTEGER :: nShifts INTEGER :: neighborRank INTEGER :: rankId INTEGER :: offset INTEGER :: msgCount INTEGER :: globalSideId INTEGER , ALLOCATABLE :: requests (:) INTEGER , ALLOCATABLE :: stats (:,:) INTEGER :: iError LOGICAL :: theyMatch ALLOCATE ( requests ( 1 : myMesh % nSides * 2 )) ALLOCATE ( stats ( MPI_STATUS_SIZE , 1 : myMesh % nSides * 2 )) IF ( PRESENT ( decomp )) THEN rankId = decomp % rankId offset = decomp % offsetElem % hostData ( rankId ) ELSE rankId = 0 offset = 0 ENDIF msgCount = 0 DO e1 = 1 , myMesh % nElem DO s1 = 1 , 6 e2Global = myMesh % sideInfo % hostData ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = myMesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = myMesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = myMesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN IF ( PRESENT ( decomp )) THEN neighborRank = decomp % elemToRank % hostData ( e2Global ) ELSE neighborRank = 0 ENDIF IF ( neighborRank == rankId ) THEN lnid1 = myMesh % sideMap % hostData ( 1 : 4 , s1 ) ! local CGNS corner node ids for element 1 side lnid2 = myMesh % sideMap % hostData ( 1 : 4 , s2 ) ! local CGNS corner node ids for element 2 side DO l = 1 , 4 i = myMesh % CGNSCornerMap % hostData ( 1 , lnid1 ( l )) j = myMesh % CGNSCornerMap % hostData ( 2 , lnid1 ( l )) k = myMesh % CGNSCornerMap % hostData ( 3 , lnid1 ( l )) nid1 ( l , s1 , e1 ) = myMesh % globalNodeIDs % hostData ( i , j , k , e1 ) i = myMesh % CGNSCornerMap % hostData ( 1 , lnid2 ( l )) j = myMesh % CGNSCornerMap % hostData ( 2 , lnid2 ( l )) k = myMesh % CGNSCornerMap % hostData ( 3 , lnid2 ( l )) nid2 ( l , s1 , e1 ) = myMesh % globalNodeIDs % hostData ( i , j , k , e1 ) ENDDO ELSE ! In this case, we need to exchange globalSideId = ABS ( myMesh % sideInfo % hostdata ( 2 , s1 , e1 )) lnid1 = myMesh % sideMap % hostData ( 1 : 4 , s1 ) ! local CGNS corner node ids for element 1 side DO l = 1 , 4 i = myMesh % CGNSCornerMap % hostData ( 1 , lnid1 ( l )) j = myMesh % CGNSCornerMap % hostData ( 2 , lnid1 ( l )) k = myMesh % CGNSCornerMap % hostData ( 3 , lnid1 ( l )) nid1 ( l , s1 , e1 ) = myMesh % globalNodeIDs % hostData ( i , j , k , e1 ) ! Receive nid2(l) on this rank from  nid1(l) on the other rank msgCount = msgCount + 1 CALL MPI_IRECV ( nid2 ( l , s1 , e1 ), & 1 , & MPI_INTEGER , & neighborRank , globalSideId , & decomp % mpiComm , & requests ( msgCount ), iError ) ! Send nid1(l) from this rank to nid2(l) on the other rank msgCount = msgCount + 1 CALL MPI_ISEND ( nid1 ( l , s1 , e1 ), & 1 , & MPI_INTEGER , & neighborRank , globalSideId , & decomp % mpiComm , & requests ( msgCount ), iError ) ENDDO ENDIF ! MPI or not ENDIF ! If not physical boundary ENDDO ENDDO IF ( PRESENT ( decomp ) . AND . msgCount > 0 ) THEN CALL MPI_WaitAll ( msgCount , & requests ( 1 : msgCount ), & stats ( 1 : MPI_STATUS_SIZE , 1 : msgCount ), & iError ) ENDIF DO e1 = 1 , myMesh % nElem DO s1 = 1 , 6 s2 = myMesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 bcid = myMesh % sideInfo % hostData ( 5 , s1 , e1 ) nloc1 ( 1 : 4 ) = nid1 ( 1 : 4 , s1 , e1 ) nloc2 ( 1 : 4 ) = nid2 ( 1 : 4 , s1 , e1 ) IF ( bcid == 0 ) THEN nShifts = 0 theyMatch = . FALSE . DO i = 1 , 4 theyMatch = CompareArray ( nloc1 , nloc2 , 4 ) IF ( theyMatch ) THEN EXIT ELSE nShifts = nShifts + 1 CALL ForwardShift ( nloc1 , 4 ) ENDIF ENDDO myMesh % sideInfo % hostData ( 4 , s1 , e1 ) = 10 * s2 + nShifts ENDIF ENDDO ENDDO DEALLOCATE ( requests ) DEALLOCATE ( stats ) END SUBROUTINE RecalculateFlip_Mesh3D","tags":"","loc":"proc/recalculateflip_mesh3d.html"},{"title":"ResetBoundaryConditionType_Mesh2D – SELF","text":"public subroutine ResetBoundaryConditionType_Mesh2D(myMesh, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Note that ALL physical boundaries will be set to have this boundary \ncondition Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh integer, intent(in) :: bcid Contents Source Code ResetBoundaryConditionType_Mesh2D Source Code SUBROUTINE ResetBoundaryConditionType_Mesh2D ( myMesh , bcid ) !! This method can be used to reset all of the boundary elements !! boundary condition type to the desired value. !! !! Note that ALL physical boundaries will be set to have this boundary !! condition IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh INTEGER , INTENT ( in ) :: bcid ! Local INTEGER :: iSide , iEl , e2 DO iEl = 1 , myMesh % nElem DO iSide = 1 , 4 e2 = myMesh % sideInfo % hostData ( 3 , iSide , iEl ) IF ( e2 == 0 ) THEN myMesh % sideInfo % hostData ( 5 , iSide , iEl ) = bcid ENDIF ENDDO ENDDO END SUBROUTINE ResetBoundaryConditionType_Mesh2D","tags":"","loc":"proc/resetboundaryconditiontype_mesh2d.html"},{"title":"ResetBoundaryConditionType_Mesh3D – SELF","text":"public subroutine ResetBoundaryConditionType_Mesh3D(myMesh, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Note that ALL physical boundaries will be set to have this boundary \ncondition Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh integer, intent(in) :: bcid Contents Source Code ResetBoundaryConditionType_Mesh3D Source Code SUBROUTINE ResetBoundaryConditionType_Mesh3D ( myMesh , bcid ) !! This method can be used to reset all of the boundary elements !! boundary condition type to the desired value. !! !! Note that ALL physical boundaries will be set to have this boundary !! condition IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh INTEGER , INTENT ( in ) :: bcid ! Local INTEGER :: iSide , iEl , e2 DO iEl = 1 , myMesh % nElem DO iSide = 1 , 6 e2 = myMesh % sideInfo % hostData ( 3 , iSide , iEl ) IF ( e2 == 0 ) THEN myMesh % sideInfo % hostData ( 5 , iSide , iEl ) = bcid ENDIF ENDDO ENDDO END SUBROUTINE ResetBoundaryConditionType_Mesh3D","tags":"","loc":"proc/resetboundaryconditiontype_mesh3d.html"},{"title":"SetElemToRank – SELF","text":"public subroutine SetElemToRank(this, nElem) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this integer, intent(in) :: nElem Contents Source Code SetElemToRank Source Code SUBROUTINE SetElemToRank ( this , nElem ) IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: nElem ! Local INTEGER :: iel this % nElem = nElem CALL this % elemToRank % Alloc ( 1 , nElem ) CALL DomainDecomp ( nElem , & this % nRanks , & this % offSetElem % hostData ) DO iel = 1 , nElem CALL ElemToRank ( this % nRanks , & this % offSetElem % hostData , & iel , & this % elemToRank % hostData ( iel )) END DO CALL this % offSetElem % UpdateDevice () CALL this % elemToRank % UpdateDevice () END SUBROUTINE SetElemToRank","tags":"","loc":"proc/setelemtorank.html"},{"title":"SetMaxMsg – SELF","text":"public subroutine SetMaxMsg(this, maxMsg) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this integer, intent(in) :: maxMsg Contents Source Code SetMaxMsg Source Code SUBROUTINE SetMaxMsg ( this , maxMsg ) IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: maxMsg IF ( ALLOCATED ( this % requests ) ) DEALLOCATE ( this % requests ) IF ( ALLOCATED ( this % stats ) ) DEALLOCATE ( this % stats ) ALLOCATE ( this % requests ( 1 : maxMsg ) ) ALLOCATE ( this % stats ( MPI_STATUS_SIZE , 1 : maxMsg ) ) this % maxMsg = maxMsg END SUBROUTINE SetMaxMsg","tags":"","loc":"proc/setmaxmsg.html"},{"title":"UniformBlockMesh_Mesh1D – SELF","text":"public subroutine UniformBlockMesh_Mesh1D(myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem real(kind=prec), intent(in) :: x (1:2) Contents Source Code UniformBlockMesh_Mesh1D Source Code SUBROUTINE UniformBlockMesh_Mesh1D ( myMesh , nGeo , nElem , x ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem REAL ( prec ), INTENT ( in ) :: x ( 1 : 2 ) ! Local INTEGER :: iel INTEGER :: nid , nNodes INTEGER :: i REAL ( prec ) :: xU ( 1 : nElem + 1 ) TYPE ( Lagrange ), TARGET :: linearInterp TYPE ( Lagrange ), TARGET :: nGeoInterp TYPE ( Scalar1D ) :: xLinear TYPE ( Scalar1D ) :: xGeo nNodes = nElem * ( nGeo + 1 ) CALL myMesh % Init ( nGeo , nElem , nNodes , 2 ) myMesh % quadrature = GAUSS_LOBATTO ! Set the hopr_nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem + 1 ) CALL linearInterp % Init ( 1 , GAUSS_LOBATTO ,& nGeo , GAUSS_LOBATTO ) CALL nGeoInterp % Init ( nGeo , GAUSS_LOBATTO ,& nGeo , GAUSS_LOBATTO ) ! Create a linear interpolant to interpolate to nGeo grid CALL xLinear % Init ( linearInterp , 1 , nElem ) CALL xGeo % Init ( nGeoInterp , 1 , nElem ) DO iel = 1 , nElem xLinear % interior % hostData ( 0 : 1 , 1 , iel ) = xU ( iel : iel + 1 ) END DO CALL xLinear % GridInterp ( xGeo ,. FALSE .) ! Set the element information nid = 1 DO iel = 1 , nElem myMesh % elemInfo % hostData ( 1 , iel ) = selfLineLinear ! Element Type myMesh % elemInfo % hostData ( 2 , iel ) = 1 ! Element Zone myMesh % elemInfo % hostData ( 3 , iel ) = nid ! Node Index Start DO i = 0 , nGeo myMesh % nodeCoords % hostData ( nid ) = xGeo % interior % hostData ( i , 1 , iel ) nid = nid + 1 END DO myMesh % elemInfo % hostData ( 4 , iel ) = nid - 1 ! Node Index End END DO CALL myMesh % UpdateDevice () CALL xLinear % Free () CALL xGeo % Free () CALL linearInterp % Free () CALL nGeoInterp % Free () END SUBROUTINE UniformBlockMesh_Mesh1D","tags":"","loc":"proc/uniformblockmesh_mesh1d.html"},{"title":"UpdateDevice_Mesh1D – SELF","text":"public subroutine UpdateDevice_Mesh1D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh Contents Source Code UpdateDevice_Mesh1D Source Code SUBROUTINE UpdateDevice_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh CALL myMesh % elemInfo % UpdateDevice () CALL myMesh % nodeCoords % UpdateDevice () CALL myMesh % globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () END SUBROUTINE UpdateDevice_Mesh1D","tags":"","loc":"proc/updatedevice_mesh1d.html"},{"title":"UpdateDevice_Mesh2D – SELF","text":"public subroutine UpdateDevice_Mesh2D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh Contents Source Code UpdateDevice_Mesh2D Source Code SUBROUTINE UpdateDevice_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh CALL myMesh % elemInfo % UpdateDevice () CALL myMesh % sideInfo % UpdateDevice () CALL myMesh % nodeCoords % UpdateDevice () CALL myMesh % globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () END SUBROUTINE UpdateDevice_Mesh2D","tags":"","loc":"proc/updatedevice_mesh2d.html"},{"title":"UpdateDevice_Mesh3D – SELF","text":"public subroutine UpdateDevice_Mesh3D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh Contents Source Code UpdateDevice_Mesh3D Source Code SUBROUTINE UpdateDevice_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh CALL myMesh % elemInfo % UpdateDevice () CALL myMesh % sideInfo % UpdateDevice () CALL myMesh % nodeCoords % UpdateDevice () CALL myMesh % globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () END SUBROUTINE UpdateDevice_Mesh3D","tags":"","loc":"proc/updatedevice_mesh3d.html"},{"title":"UpdateHost_Mesh1D – SELF","text":"public subroutine UpdateHost_Mesh1D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh Contents Source Code UpdateHost_Mesh1D Source Code SUBROUTINE UpdateHost_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh CALL myMesh % elemInfo % UpdateHost () CALL myMesh % nodeCoords % UpdateHost () CALL myMesh % globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () END SUBROUTINE UpdateHost_Mesh1D","tags":"","loc":"proc/updatehost_mesh1d.html"},{"title":"UpdateHost_Mesh2D – SELF","text":"public subroutine UpdateHost_Mesh2D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh Contents Source Code UpdateHost_Mesh2D Source Code SUBROUTINE UpdateHost_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh CALL myMesh % elemInfo % UpdateHost () CALL myMesh % sideInfo % UpdateHost () CALL myMesh % nodeCoords % UpdateHost () CALL myMesh % globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () END SUBROUTINE UpdateHost_Mesh2D","tags":"","loc":"proc/updatehost_mesh2d.html"},{"title":"UpdateHost_Mesh3D – SELF","text":"public subroutine UpdateHost_Mesh3D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh Contents Source Code UpdateHost_Mesh3D Source Code SUBROUTINE UpdateHost_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh CALL myMesh % elemInfo % UpdateHost () CALL myMesh % sideInfo % UpdateHost () CALL myMesh % nodeCoords % UpdateHost () CALL myMesh % globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () END SUBROUTINE UpdateHost_Mesh3D","tags":"","loc":"proc/updatehost_mesh3d.html"},{"title":"Write_Mesh1D – SELF","text":"public subroutine Write_Mesh1D(myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh character, intent(in) :: meshFile Contents Source Code Write_Mesh1D Source Code SUBROUTINE Write_Mesh1D ( myMesh , meshFile ) ! Writes mesh output in HOPR format (serial IO only) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL WriteAttribute_HDF5 ( fileId , 'nElems' , myMesh % nElem ) CALL WriteAttribute_HDF5 ( fileId , 'Ngeo' , myMesh % nGeo ) CALL WriteAttribute_HDF5 ( fileId , 'nBCs' , myMesh % nBCs ) CALL WriteArray_HDF5 ( fileId , 'BCType' , myMesh % bcType ) ! Read local subarray of ElemInfo CALL WriteArray_HDF5 ( fileId , 'ElemInfo' , myMesh % elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs CALL WriteArray_HDF5 ( fileId , 'NodeCoords' , myMesh % nodeCoords ) CALL WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , myMesh % globalNodeIDs ) CALL Close_HDF5 ( fileID ) END SUBROUTINE Write_Mesh1D","tags":"","loc":"proc/write_mesh1d.html"},{"title":"Write_Mesh2D – SELF","text":"public subroutine Write_Mesh2D(myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh character, intent(in) :: meshFile Contents Source Code Write_Mesh2D Source Code SUBROUTINE Write_Mesh2D ( myMesh , meshFile ) ! Writes mesh output in HOPR format (serial only) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL WriteAttribute_HDF5 ( fileId , 'nElems' , myMesh % nElem ) CALL WriteAttribute_HDF5 ( fileId , 'Ngeo' , myMesh % nGeo ) CALL WriteAttribute_HDF5 ( fileId , 'nBCs' , myMesh % nBCs ) CALL WriteArray_HDF5 ( fileId , 'BCType' , myMesh % bcType ) ! Write local subarray of ElemInfo CALL WriteArray_HDF5 ( fileId , 'ElemInfo' , myMesh % elemInfo ) ! Write local subarray of NodeCoords and GlobalNodeIDs CALL WriteArray_HDF5 ( fileId , 'NodeCoords' , myMesh % nodeCoords ) CALL WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , myMesh % globalNodeIDs ) ! Write local subarray of SideInfo CALL WriteArray_HDF5 ( fileId , 'SideInfo' , myMesh % sideInfo ) CALL Close_HDF5 ( fileID ) END SUBROUTINE Write_Mesh2D","tags":"","loc":"proc/write_mesh2d.html"},{"title":"Write_Mesh3D – SELF","text":"public subroutine Write_Mesh3D(myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh character, intent(in) :: meshFile Contents Source Code Write_Mesh3D Source Code SUBROUTINE Write_Mesh3D ( myMesh , meshFile ) ! Writes mesh output in HOPR format (serial only) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL WriteAttribute_HDF5 ( fileId , 'nElems' , myMesh % nElem ) CALL WriteAttribute_HDF5 ( fileId , 'Ngeo' , myMesh % nGeo ) CALL WriteAttribute_HDF5 ( fileId , 'nBCs' , myMesh % nBCs ) CALL WriteArray_HDF5 ( fileId , 'BCType' , myMesh % bcType ) CALL WriteArray_HDF5 ( fileId , 'ElemInfo' , myMesh % elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs CALL WriteArray_HDF5 ( fileId , 'NodeCoords' , myMesh % nodeCoords ) CALL WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , myMesh % globalNodeIDs ) ! Read local subarray of SideInfo CALL WriteArray_HDF5 ( fileId , 'SideInfo' , myMesh % sideInfo ) CALL Close_HDF5 ( fileID ) END SUBROUTINE Write_Mesh3D","tags":"","loc":"proc/write_mesh3d.html"},{"title":"ChebyshevGauss – SELF","text":"private subroutine ChebyshevGauss(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Contents Source Code ChebyshevGauss Source Code SUBROUTINE ChebyshevGauss ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local INTEGER :: j DO j = 0 , N weights ( j ) = pi / ( REAL ( N , real64 ) + 1.0_real64 ) nodes ( j ) = - cos ( pi * ( 2.0_real64 * REAL ( j , real64 ) + 1.0_real64 ) / ( 2.0_real64 * REAL ( N , real64 ) + 2.0_real64 )) END DO END SUBROUTINE ChebyshevGauss","tags":"","loc":"proc/chebyshevgauss.html"},{"title":"ChebyshevGaussLobatto – SELF","text":"private subroutine ChebyshevGaussLobatto(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Contents Source Code ChebyshevGaussLobatto Source Code SUBROUTINE ChebyshevGaussLobatto ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! LOCAL INTEGER :: j DO j = 0 , N weights ( j ) = pi / REAL ( N , real64 ) nodes ( j ) = - cos ( pi * REAL ( j , real64 ) / REAL ( N , real64 )) END DO weights ( 0 ) = weights ( 0 ) * 0.5_real64 weights ( N ) = weights ( N ) * 0.5_real64 END SUBROUTINE ChebyshevGaussLobatto","tags":"","loc":"proc/chebyshevgausslobatto.html"},{"title":"ChebyshevQuadrature – SELF","text":"public subroutine ChebyshevQuadrature(N, nodes, weights, QuadType) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=prec), intent(out) :: nodes (0:N) real(kind=prec), intent(out) :: weights (0:N) integer, intent(in) :: QuadType Contents Source Code ChebyshevQuadrature Source Code SUBROUTINE ChebyshevQuadrature ( N , nodes , weights , quadType ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N REAL ( prec ), INTENT ( out ) :: nodes ( 0 : N ) REAL ( prec ), INTENT ( out ) :: weights ( 0 : N ) INTEGER , INTENT ( in ) :: QuadType ! Local REAL ( real64 ) :: nodesLocal ( 0 : N ) REAL ( real64 ) :: weightsLocal ( 0 : N ) INTEGER :: i IF ( QuadType == CHEBYSHEV_GAUSS_LOBATTO ) then CALL ChebyshevGaussLobatto ( N , nodesLocal , weightsLocal ) ELSEIF ( QuadType == CHEBYSHEV_GAUSS ) then CALL ChebyshevGauss ( N , nodesLocal , weightsLocal ) END IF DO i = 0 , N nodes ( i ) = REAL ( nodesLocal ( i ), prec ) weights ( i ) = REAL ( weightsLocal ( i ), prec ) END DO END SUBROUTINE ChebyshevQuadrature","tags":"","loc":"proc/chebyshevquadrature.html"},{"title":"LegendreGauss – SELF","text":"private subroutine LegendreGauss(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Contents Source Code LegendreGauss Source Code SUBROUTINE LegendreGauss ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local REAL ( real64 ) :: nodes_local ( 0 : N ) REAL ( real64 ) :: weights_local ( 0 : N ) REAL ( real64 ) :: lN1 , dlN1 REAL ( real64 ) :: delta INTEGER :: j , kIt IF ( N == 0 ) then nodes_local ( 0 ) = 0.0_real64 weights_local ( 0 ) = 2.0_real64 ELSEIF ( N == 1 ) then nodes_local ( 0 ) = - SQRT ( 1.0_real64 / 3.0_real64 ) weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = - nodes ( 0 ) weights_local ( 1 ) = weights ( 0 ) ELSE DO j = 0 , (( N + 1 ) / 2 ) nodes_local ( j ) = - cos (( 2.0_real64 * REAL ( j , real64 ) + 1.0_real64 ) * pi / ( 2.0_real64 * REAL ( N , real64 ) + 1.0_real64 )) DO kIt = 1 , newtonMax CALL LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) delta = - lN1 / dlN1 nodes_local ( j ) = nodes_local ( j ) + delta IF ( abs ( delta ) <= TOL * nodes_local ( j )) EXIT END DO CALL LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) weights_local ( j ) = 2.0_real64 / (( 1.0_real64 - nodes_local ( j ) * nodes_local ( j )) * dlN1 * dlN1 ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) END DO END IF IF ( MOD ( REAL ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) then CALL LegendrePolynomial ( N + 1 , 0.0_real64 , lN1 , dlN1 ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0 / ( dlN1 * dlN1 ) END IF DO j = 0 , N nodes ( j ) = REAL ( nodes_local ( j ), real64 ) weights ( j ) = REAL ( weights_local ( j ), real64 ) END DO END SUBROUTINE LegendreGauss","tags":"","loc":"proc/legendregauss.html"},{"title":"LegendreGaussLobatto – SELF","text":"private subroutine LegendreGaussLobatto(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Contents Source Code LegendreGaussLobatto Source Code SUBROUTINE LegendreGaussLobatto ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local REAL ( real64 ) :: nodes_local ( 0 : N ) REAL ( real64 ) :: weights_local ( 0 : N ) REAL ( real64 ) :: delta , q , qprime , lN INTEGER :: j , kIt IF ( N == 1 ) then nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = 1.0_real64 weights_local ( 1 ) = 1.0_real64 ELSE nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 )) nodes_local ( N ) = 1.0_real64 weights_local ( N ) = weights_local ( 0 ) DO j = 1 , (( N + 1 ) / 2 - 1 ) nodes_local ( j ) = - COS (( REAL ( j , real64 ) + 0.25_real64 ) * pi / REAL ( N , real64 ) - & 3.0_real64 / ( 8.0_real64 * REAL ( N , real64 ) * pi * ( REAL ( j , real64 ) + 0.25_real64 ))) DO kIt = 1 , newtonMax CALL LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) delta = - q / qprime nodes_local ( j ) = nodes_local ( j ) + delta IF ( ABS ( delta ) <= TOL * nodes_local ( j )) EXIT END DO CALL LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) weights_local ( j ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 ) * lN * lN ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) END DO END IF IF ( MOD ( REAL ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) THEN CALL LegendreQandL ( N , 0.0_real64 , q , qprime , lN ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 ) * lN * lN ) END IF DO j = 0 , N nodes ( j ) = REAL ( nodes_local ( j ), real64 ) weights ( j ) = REAL ( weights_local ( j ), real64 ) END DO END SUBROUTINE LegendreGaussLobatto","tags":"","loc":"proc/legendregausslobatto.html"},{"title":"LegendrePolynomial – SELF","text":"public subroutine LegendrePolynomial(N, x, lAtX, dLdxAtX) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: lAtX real(kind=real64) :: dLdxAtX Contents Source Code LegendrePolynomial Source Code SUBROUTINE LegendrePolynomial ( N , x , lAtX , dLdxAtX ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: x REAL ( real64 ) :: lAtX , dLdxAtX ! Local REAL ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 INTEGER :: i IF ( N == 0 ) then lAtX = 1.0_real64 dLdxAtX = 0.0_real64 ELSEIF ( N == 1 ) then lAtX = x dLdxAtX = 1.0_real64 ELSE lnM2 = 1.0_real64 lnM1 = x dlnM2 = 0.0_real64 dlnM1 = 1.0_real64 DO i = 2 , N lAtX = (( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * x * lnM1 - & ( REAL ( i , real64 ) - 1.0_real64 ) * lnM2 ) / ( REAL ( i , real64 )) dldxAtX = dlnM2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lnM1 lnM2 = lnM1 lnM1 = lAtX dlnM2 = dlnM1 dlnM1 = dldxAtX END DO END IF END SUBROUTINE LegendrePolynomial","tags":"","loc":"proc/legendrepolynomial.html"},{"title":"LegendreQandL – SELF","text":"private subroutine LegendreQandL(N, x, q, qprime, lN) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: q real(kind=real64) :: qprime real(kind=real64) :: lN Contents Source Code LegendreQandL Source Code SUBROUTINE LegendreQandL ( N , x , q , qprime , lN ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: x REAL ( real64 ) :: lN , q , qprime ! Local REAL ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 , dlN , lN1 , dlN1 INTEGER :: i lNm2 = 1.0_real64 lNm1 = x dlNm2 = 0.0_real64 dlNm1 = 1.0_real64 DO i = 2 , N lN = ( 2.0_real64 * i - 1.0_real64 ) / ( REAL ( i , real64 )) * x * lNm1 - ( REAL ( i , real64 ) - 1.0_real64 ) / ( REAL ( i , real64 )) * lNm2 dlN = dlNm2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lNm1 lNm2 = lNm1 lNm1 = lN dlNm2 = dlNm1 dlNm1 = dlN END DO i = N + 1 lN1 = ( 2.0_real64 * i - 1.0_real64 ) / ( REAL ( i , real64 )) * x * lN - ( REAL ( i , real64 ) - 1.0_real64 ) / ( REAL ( i , real64 )) * lNm2 dlN1 = dlNm2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lNm1 q = lN1 - lNm2 qprime = dlN1 - dlNm2 END SUBROUTINE LegendreQandL","tags":"","loc":"proc/legendreqandl.html"},{"title":"LegendreQuadrature – SELF","text":"public subroutine LegendreQuadrature(N, nodes, weights, QuadType) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=prec), intent(out) :: nodes (0:N) real(kind=prec), intent(out) :: weights (0:N) integer, intent(in) :: QuadType Contents Source Code LegendreQuadrature Source Code SUBROUTINE LegendreQuadrature ( N , nodes , weights , QuadType ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N REAL ( prec ), INTENT ( out ) :: nodes ( 0 : N ) REAL ( prec ), INTENT ( out ) :: weights ( 0 : N ) INTEGER , INTENT ( in ) :: QuadType ! Local REAL ( real64 ) :: nodesLocal ( 0 : N ) REAL ( real64 ) :: weightsLocal ( 0 : N ) INTEGER :: i IF ( QuadType == GAUSS_LOBATTO ) THEN CALL LegendreGaussLobatto ( N , nodesLocal , weightsLocal ) ELSEIF ( QuadType == GAUSS ) THEN CALL LegendreGauss ( N , nodesLocal , weightsLocal ) END IF DO i = 0 , N nodes ( i ) = REAL ( nodesLocal ( i ), prec ) weights ( i ) = REAL ( weightsLocal ( i ), prec ) END DO END SUBROUTINE LegendreQuadrature","tags":"","loc":"proc/legendrequadrature.html"},{"title":"BoundaryInterp_Scalar1D – SELF","text":"public subroutine BoundaryInterp_Scalar1D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Scalar1D Source Code SUBROUTINE BoundaryInterp_Scalar1D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_1D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_1D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar1D","tags":"","loc":"proc/boundaryinterp_scalar1d.html"},{"title":"BoundaryInterp_Scalar2D – SELF","text":"public subroutine BoundaryInterp_Scalar2D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Scalar2D Source Code SUBROUTINE BoundaryInterp_Scalar2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar2D","tags":"","loc":"proc/boundaryinterp_scalar2d.html"},{"title":"BoundaryInterp_Scalar3D – SELF","text":"public subroutine BoundaryInterp_Scalar3D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Scalar3D Source Code SUBROUTINE BoundaryInterp_Scalar3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar3D","tags":"","loc":"proc/boundaryinterp_scalar3d.html"},{"title":"BoundaryInterp_Tensor2D – SELF","text":"public subroutine BoundaryInterp_Tensor2D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Tensor2D Source Code SUBROUTINE BoundaryInterp_Tensor2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Tensor2D","tags":"","loc":"proc/boundaryinterp_tensor2d.html"},{"title":"BoundaryInterp_Tensor3D – SELF","text":"public subroutine BoundaryInterp_Tensor3D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Tensor3D Source Code SUBROUTINE BoundaryInterp_Tensor3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Tensor3D","tags":"","loc":"proc/boundaryinterp_tensor3d.html"},{"title":"BoundaryInterp_Vector2D – SELF","text":"public subroutine BoundaryInterp_Vector2D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Vector2D Source Code SUBROUTINE BoundaryInterp_Vector2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Vector2D","tags":"","loc":"proc/boundaryinterp_vector2d.html"},{"title":"BoundaryInterp_Vector3D – SELF","text":"public subroutine BoundaryInterp_Vector3D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Vector3D Source Code SUBROUTINE BoundaryInterp_Vector3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Vector3D","tags":"","loc":"proc/boundaryinterp_vector3d.html"},{"title":"Derivative_Scalar1D – SELF","text":"public subroutine Derivative_Scalar1D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Derivative_Scalar1D Source Code SUBROUTINE Derivative_Scalar1D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar1D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % Derivative_1D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % Derivative_1D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Derivative_Scalar1D","tags":"","loc":"proc/derivative_scalar1d.html"},{"title":"Determinant_Tensor2D – SELF","text":"public subroutine Determinant_Tensor2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Determinant_Tensor2D Source Code SUBROUTINE Determinant_Tensor2D ( SELFStorage , SELFout , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"Determinant_Tensor2D\" IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j IF ( gpuAccel ) THEN CALL Determinant_Tensor2D_gpu_wrapper ( SELFStorage % interior % deviceData , & SELFOut % interior % deviceData , & SELFStorage % interp % N , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE DO iEl = 1 , SELFStorage % nElem DO iVar = 1 , SELFStorage % nVar DO j = 0 , SELFStorage % interp % N DO i = 0 , SELFStorage % interp % N SELFOut % interior % hostData ( i , j , iVar , iEl ) = SELFStorage % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE Determinant_Tensor2D","tags":"","loc":"proc/determinant_tensor2d.html"},{"title":"Determinant_Tensor3D – SELF","text":"public subroutine Determinant_Tensor3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Determinant_Tensor3D Source Code SUBROUTINE Determinant_Tensor3D ( SELFStorage , SELFOut , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"Determinant_Tensor3D\" IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k IF ( gpuAccel ) THEN CALL Determinant_Tensor3D_gpu_wrapper ( SELFStorage % interior % deviceData , & SELFOut % interior % deviceData , & SELFStorage % interp % N , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE DO iEl = 1 , SELFStorage % nElem DO iVar = 1 , SELFStorage % nVar DO k = 0 , SELFStorage % interp % N DO j = 0 , SELFStorage % interp % N DO i = 0 , SELFStorage % interp % N SELFOut % interior % hostData ( i , j , k , iVar , iEl ) = & SELFStorage % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl )) - & SELFStorage % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl )) + & SELFStorage % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl )) END DO END DO END DO END DO END DO END IF END SUBROUTINE Determinant_Tensor3D","tags":"","loc":"proc/determinant_tensor3d.html"},{"title":"Divergence_Vector2D – SELF","text":"public subroutine Divergence_Vector2D(SELFStorage, SELFOut, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Divergence_Vector2D Source Code SUBROUTINE Divergence_Vector2D ( SELFStorage , SELFOut , dForm , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDGDivergence_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundaryNormal % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDGDivergence_2D ( SELFStorage % interior % hostData , & SELFStorage % boundaryNormal % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDivergence_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDivergence_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END IF END SUBROUTINE Divergence_Vector2D","tags":"","loc":"proc/divergence_vector2d.html"},{"title":"Divergence_Vector3D – SELF","text":"public subroutine Divergence_Vector3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Divergence_Vector3D Source Code SUBROUTINE Divergence_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDivergence_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDivergence_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Divergence_Vector3D","tags":"","loc":"proc/divergence_vector3d.html"},{"title":"Free_Scalar1D – SELF","text":"public subroutine Free_Scalar1D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage Contents Source Code Free_Scalar1D Source Code SUBROUTINE Free_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage SELFStorage % interp => NULL () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () CALL SELFStorage % avgBoundary % Free () CALL SELFStorage % jumpBoundary % Free () DEALLOCATE ( SELFStorage % meta ) DEALLOCATE ( SELFStorage % eqn ) END SUBROUTINE Free_Scalar1D","tags":"","loc":"proc/free_scalar1d.html"},{"title":"Free_Scalar2D – SELF","text":"public subroutine Free_Scalar2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage Contents Source Code Free_Scalar2D Source Code SUBROUTINE Free_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage SELFStorage % nVar = 0 SELFStorage % nElem = 0 SELFStorage % interp => NULL () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () CALL SELFStorage % avgBoundary % Free () CALL SELFStorage % jumpBoundary % Free () DEALLOCATE ( SELFStorage % meta ) DEALLOCATE ( SELFStorage % eqn ) END SUBROUTINE Free_Scalar2D","tags":"","loc":"proc/free_scalar2d.html"},{"title":"Free_Scalar3D – SELF","text":"public subroutine Free_Scalar3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage Contents Source Code Free_Scalar3D Source Code SUBROUTINE Free_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage SELFStorage % nVar = 0 SELFStorage % nElem = 0 SELFStorage % interp => NULL () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () CALL SELFStorage % avgBoundary % Free () CALL SELFStorage % jumpBoundary % Free () DEALLOCATE ( SELFStorage % meta ) DEALLOCATE ( SELFStorage % eqn ) END SUBROUTINE Free_Scalar3D","tags":"","loc":"proc/free_scalar3d.html"},{"title":"Free_Tensor2D – SELF","text":"public subroutine Free_Tensor2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage Contents Source Code Free_Tensor2D Source Code SUBROUTINE Free_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage SELFStorage % interp => NULL () SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () DEALLOCATE ( SELFStorage % meta ) DEALLOCATE ( SELFStorage % eqn ) END SUBROUTINE Free_Tensor2D","tags":"","loc":"proc/free_tensor2d.html"},{"title":"Free_Tensor3D – SELF","text":"public subroutine Free_Tensor3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage Contents Source Code Free_Tensor3D Source Code SUBROUTINE Free_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage SELFStorage % interp => NULL () SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () DEALLOCATE ( SELFStorage % meta ) DEALLOCATE ( SELFStorage % eqn ) END SUBROUTINE Free_Tensor3D","tags":"","loc":"proc/free_tensor3d.html"},{"title":"Free_Vector2D – SELF","text":"public subroutine Free_Vector2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage Contents Source Code Free_Vector2D Source Code SUBROUTINE Free_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage SELFStorage % interp => NULL () SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % boundaryNormal % Free () CALL SELFStorage % extBoundary % Free () DEALLOCATE ( SELFStorage % meta ) DEALLOCATE ( SELFStorage % eqn ) END SUBROUTINE Free_Vector2D","tags":"","loc":"proc/free_vector2d.html"},{"title":"Free_Vector3D – SELF","text":"public subroutine Free_Vector3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage Contents Source Code Free_Vector3D Source Code SUBROUTINE Free_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage SELFStorage % interp => NULL () SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % boundaryNormal % Free () CALL SELFStorage % extBoundary % Free () DEALLOCATE ( SELFStorage % meta ) DEALLOCATE ( SELFStorage % eqn ) END SUBROUTINE Free_Vector3D","tags":"","loc":"proc/free_vector3d.html"},{"title":"Gradient_Scalar2D – SELF","text":"public subroutine Gradient_Scalar2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Gradient_Scalar2D Source Code SUBROUTINE Gradient_Scalar2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGradient_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGradient_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Scalar2D","tags":"","loc":"proc/gradient_scalar2d.html"},{"title":"Gradient_Scalar3D – SELF","text":"public subroutine Gradient_Scalar3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Gradient_Scalar3D Source Code SUBROUTINE Gradient_Scalar3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGradient_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGradient_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Scalar3D","tags":"","loc":"proc/gradient_scalar3d.html"},{"title":"Gradient_Vector2D – SELF","text":"public subroutine Gradient_Vector2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Gradient_Vector2D Source Code SUBROUTINE Gradient_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGradient_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGradient_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Vector2D","tags":"","loc":"proc/gradient_vector2d.html"},{"title":"Gradient_Vector3D – SELF","text":"public subroutine Gradient_Vector3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Gradient_Vector3D Source Code SUBROUTINE Gradient_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGradient_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGradient_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Vector3D","tags":"","loc":"proc/gradient_vector3d.html"},{"title":"GridInterp_Scalar1D – SELF","text":"public subroutine GridInterp_Scalar1D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Scalar1D Source Code SUBROUTINE GridInterp_Scalar1D ( SELFStorage , SELFout , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar1D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_1D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_1D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar1D","tags":"","loc":"proc/gridinterp_scalar1d.html"},{"title":"GridInterp_Scalar2D – SELF","text":"public subroutine GridInterp_Scalar2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Scalar2D Source Code SUBROUTINE GridInterp_Scalar2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar2D","tags":"","loc":"proc/gridinterp_scalar2d.html"},{"title":"GridInterp_Scalar3D – SELF","text":"public subroutine GridInterp_Scalar3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Scalar3D Source Code SUBROUTINE GridInterp_Scalar3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar3D","tags":"","loc":"proc/gridinterp_scalar3d.html"},{"title":"GridInterp_Vector2D – SELF","text":"public subroutine GridInterp_Vector2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Vector2D Source Code SUBROUTINE GridInterp_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Vector2D","tags":"","loc":"proc/gridinterp_vector2d.html"},{"title":"GridInterp_Vector3D – SELF","text":"public subroutine GridInterp_Vector3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Vector3D Source Code SUBROUTINE GridInterp_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Vector3D","tags":"","loc":"proc/gridinterp_vector3d.html"},{"title":"Init_Scalar1D – SELF","text":"public subroutine Init_Scalar1D(SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar1D Source Code SUBROUTINE Init_Scalar1D ( SELFStorage , interp , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( out ) :: SELFStorage TYPE ( Lagrange ), INTENT ( in ), TARGET :: interp INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % interp => interp SELFStorage % nVar = nVar SELFStorage % nElem = nElem CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 1 , 1 / ), & upBound = ( / interp % N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / nVar , 2 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / nVar , 2 , nElem / )) CALL SELFStorage % avgBoundary % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / nVar , 2 , nElem / )) CALL SELFStorage % jumpBoundary % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / nVar , 2 , nElem / )) ALLOCATE ( SELFStorage % meta ( 1 : nVar ) ) ALLOCATE ( SELFStorage % eqn ( 1 : nVar ) ) END SUBROUTINE Init_Scalar1D","tags":"","loc":"proc/init_scalar1d.html"},{"title":"Init_Scalar2D – SELF","text":"public subroutine Init_Scalar2D(SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar2D Source Code SUBROUTINE Init_Scalar2D ( SELFStorage , interp , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( out ) :: SELFStorage TYPE ( Lagrange ), INTENT ( in ), TARGET :: interp INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % interp => interp SELFStorage % nVar = nVar SELFStorage % nElem = nElem CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 0 , 1 , 1 / ), & upBound = ( / interp % N , interp % N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / interp % N , nVar , 4 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / interp % N , nVar , 4 , nElem / )) CALL SELFStorage % avgBoundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / interp % N , nVar , 4 , nElem / )) CALL SELFStorage % jumpBoundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / interp % N , nVar , 4 , nElem / )) ALLOCATE ( SELFStorage % meta ( 1 : nVar ) ) ALLOCATE ( SELFStorage % eqn ( 1 : nVar ) ) END SUBROUTINE Init_Scalar2D","tags":"","loc":"proc/init_scalar2d.html"},{"title":"Init_Scalar3D – SELF","text":"public subroutine Init_Scalar3D(SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar3D Source Code SUBROUTINE Init_Scalar3D ( SELFStorage , interp , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( out ) :: SELFStorage TYPE ( Lagrange ), TARGET , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem ! Local INTEGER :: N SELFStorage % interp => interp SELFStorage % nVar = nVar SELFStorage % nElem = nElem N = interp % N CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) CALL SELFStorage % avgBoundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) CALL SELFStorage % jumpBoundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) ALLOCATE ( SELFStorage % meta ( 1 : nVar ) ) ALLOCATE ( SELFStorage % eqn ( 1 : nVar ) ) END SUBROUTINE Init_Scalar3D","tags":"","loc":"proc/init_scalar3d.html"},{"title":"Init_Tensor2D – SELF","text":"public subroutine Init_Tensor2D(SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Tensor2D Source Code SUBROUTINE Init_Tensor2D ( SELFStorage , interp , nVar , nElem ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( out ) :: SELFStorage TYPE ( Lagrange ), TARGET , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem ! Local INTEGER :: N SELFStorage % interp => interp SELFStorage % nVar = nVar SELFStorage % nElem = nElem N = interp % N CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , nVar , 4 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , nVar , 4 , nElem / )) ALLOCATE ( SELFStorage % meta ( 1 : nVar ) ) ALLOCATE ( SELFStorage % eqn ( 1 : 4 * nVar ) ) END SUBROUTINE Init_Tensor2D","tags":"","loc":"proc/init_tensor2d.html"},{"title":"Init_Tensor3D – SELF","text":"public subroutine Init_Tensor3D(SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Tensor3D Source Code SUBROUTINE Init_Tensor3D ( SELFStorage , interp , nVar , nElem ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( out ) :: SELFStorage TYPE ( Lagrange ), TARGET , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem ! Local INTEGER :: N SELFStorage % interp => interp SELFStorage % nVar = nVar SELFStorage % nElem = nElem N = interp % N CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , nVar , 6 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , nVar , 6 , nElem / )) ALLOCATE ( SELFStorage % meta ( 1 : nVar ) ) ALLOCATE ( SELFStorage % eqn ( 1 : 9 * nVar ) ) END SUBROUTINE Init_Tensor3D","tags":"","loc":"proc/init_tensor3d.html"},{"title":"Init_Vector2D – SELF","text":"public subroutine Init_Vector2D(SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Vector2D Source Code SUBROUTINE Init_Vector2D ( SELFStorage , interp , nVar , nElem ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( out ) :: SELFStorage TYPE ( Lagrange ), TARGET , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem ! Local INTEGER :: N SELFStorage % interp => interp SELFStorage % nVar = nVar SELFStorage % nElem = nElem N = interp % N CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 / ), & upBound = ( / 2 , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , N , nVar , 4 , nElem / )) CALL SELFStorage % boundaryNormal % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / N , nVar , 4 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , N , nVar , 4 , nElem / )) ALLOCATE ( SELFStorage % meta ( 1 : nVar ) ) ALLOCATE ( SELFStorage % eqn ( 1 : 2 * nVar ) ) END SUBROUTINE Init_Vector2D","tags":"","loc":"proc/init_vector2d.html"},{"title":"Init_Vector3D – SELF","text":"public subroutine Init_Vector3D(SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Vector3D Source Code SUBROUTINE Init_Vector3D ( SELFStorage , interp , nVar , nElem ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( out ) :: SELFStorage TYPE ( Lagrange ), TARGET , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem ! Local INTEGER :: N SELFStorage % interp => interp SELFStorage % nVar = nVar SELFStorage % nElem = nElem N = interp % N CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / 3 , N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , N , N , nVar , 6 , nElem / )) CALL SELFStorage % boundaryNormal % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , N , N , nVar , 6 , nElem / )) ALLOCATE ( SELFStorage % meta ( 1 : nVar ) ) ALLOCATE ( SELFStorage % eqn ( 1 : 3 * nVar ) ) END SUBROUTINE Init_Vector3D","tags":"","loc":"proc/init_vector3d.html"},{"title":"SetDescription_DataObj – SELF","text":"public subroutine SetDescription_DataObj(SELFStorage, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: description Contents Source Code SetDescription_DataObj Source Code SUBROUTINE SetDescription_DataObj ( SELFStorage , ivar , description ) !! Set the description of the `ivar-th` variable IMPLICIT NONE CLASS ( SELF_DataObj ), INTENT ( inout ) :: SELFStorage INTEGER , INTENT ( in ) :: ivar CHARACTER ( * ), INTENT ( in ) :: description CALL SELFStorage % meta ( ivar ) % SetDescription ( description ) END SUBROUTINE SetDescription_DataObj","tags":"","loc":"proc/setdescription_dataobj.html"},{"title":"SetEquation_DataObj – SELF","text":"public subroutine SetEquation_DataObj(SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar Contents Source Code SetEquation_DataObj Source Code SUBROUTINE SetEquation_DataObj ( SELFStorage , ivar , eqnChar ) !! Sets the equation parser for the `ivar-th` variable IMPLICIT NONE CLASS ( SELF_DataObj ), INTENT ( inout ) :: SELFStorage INTEGER , INTENT ( in ) :: ivar CHARACTER ( * ), INTENT ( in ) :: eqnChar SELFStorage % eqn ( ivar ) = EquationParser ( TRIM ( eqnChar ), & ( / 'x' , 'y' , 'z' , 't' / ) ) END SUBROUTINE SetEquation_DataObj","tags":"","loc":"proc/setequation_dataobj.html"},{"title":"SetEquation_Vector2D – SELF","text":"public subroutine SetEquation_Vector2D(SELFStorage, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar Contents Source Code SetEquation_Vector2D Source Code SUBROUTINE SetEquation_Vector2D ( SELFStorage , idir , ivar , eqnChar ) !! Sets the equation parser for the `idir` direction and `ivar-th` variable IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage INTEGER , INTENT ( in ) :: idir , ivar CHARACTER ( * ), INTENT ( in ) :: eqnChar SELFStorage % eqn ( idir + 2 * ( ivar - 1 )) = EquationParser ( TRIM ( eqnChar ), & ( / 'x' , 'y' , 'z' , 't' / ) ) END SUBROUTINE SetEquation_Vector2D","tags":"","loc":"proc/setequation_vector2d.html"},{"title":"SetEquation_Vector3D – SELF","text":"public subroutine SetEquation_Vector3D(SELFStorage, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar Contents Source Code SetEquation_Vector3D Source Code SUBROUTINE SetEquation_Vector3D ( SELFStorage , idir , ivar , eqnChar ) !! Sets the equation parser for the `idir` direction and `ivar-th` variable IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage INTEGER , INTENT ( in ) :: idir , ivar CHARACTER ( * ), INTENT ( in ) :: eqnChar SELFStorage % eqn ( idir + 3 * ( ivar - 1 )) = EquationParser ( TRIM ( eqnChar ), & ( / 'x' , 'y' , 'z' , 't' / ) ) END SUBROUTINE SetEquation_Vector3D","tags":"","loc":"proc/setequation_vector3d.html"},{"title":"SetName_DataObj – SELF","text":"public subroutine SetName_DataObj(SELFStorage, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: name Contents Source Code SetName_DataObj Source Code SUBROUTINE SetName_DataObj ( SELFStorage , ivar , name ) !! Set the name of the `ivar-th` variable IMPLICIT NONE CLASS ( SELF_DataObj ), INTENT ( inout ) :: SELFStorage INTEGER , INTENT ( in ) :: ivar CHARACTER ( * ), INTENT ( in ) :: name CALL SELFStorage % meta ( ivar ) % SetName ( name ) END SUBROUTINE SetName_DataObj","tags":"","loc":"proc/setname_dataobj.html"},{"title":"SetUnits_DataObj – SELF","text":"public subroutine SetUnits_DataObj(SELFStorage, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: units Contents Source Code SetUnits_DataObj Source Code SUBROUTINE SetUnits_DataObj ( SELFStorage , ivar , units ) !! Set the units of the `ivar-th` variable IMPLICIT NONE CLASS ( SELF_DataObj ), INTENT ( inout ) :: SELFStorage INTEGER , INTENT ( in ) :: ivar CHARACTER ( * ), INTENT ( in ) :: units CALL SELFStorage % meta ( ivar ) % SetUnits ( units ) END SUBROUTINE SetUnits_DataObj","tags":"","loc":"proc/setunits_dataobj.html"},{"title":"UpdateDevice_Scalar1D – SELF","text":"public subroutine UpdateDevice_Scalar1D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Scalar1D Source Code SUBROUTINE UpdateDevice_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () CALL SELFStorage % avgBoundary % UpdateDevice () CALL SELFStorage % jumpBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Scalar1D","tags":"","loc":"proc/updatedevice_scalar1d.html"},{"title":"UpdateDevice_Scalar2D – SELF","text":"public subroutine UpdateDevice_Scalar2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Scalar2D Source Code SUBROUTINE UpdateDevice_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () CALL SELFStorage % avgBoundary % UpdateDevice () CALL SELFStorage % jumpBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Scalar2D","tags":"","loc":"proc/updatedevice_scalar2d.html"},{"title":"UpdateDevice_Scalar3D – SELF","text":"public subroutine UpdateDevice_Scalar3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Scalar3D Source Code SUBROUTINE UpdateDevice_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () CALL SELFStorage % avgBoundary % UpdateDevice () CALL SELFStorage % jumpBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Scalar3D","tags":"","loc":"proc/updatedevice_scalar3d.html"},{"title":"UpdateDevice_Tensor2D – SELF","text":"public subroutine UpdateDevice_Tensor2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Tensor2D Source Code SUBROUTINE UpdateDevice_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Tensor2D","tags":"","loc":"proc/updatedevice_tensor2d.html"},{"title":"UpdateDevice_Tensor3D – SELF","text":"public subroutine UpdateDevice_Tensor3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Tensor3D Source Code SUBROUTINE UpdateDevice_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateDevice_Tensor3D","tags":"","loc":"proc/updatedevice_tensor3d.html"},{"title":"UpdateDevice_Vector2D – SELF","text":"public subroutine UpdateDevice_Vector2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Vector2D Source Code SUBROUTINE UpdateDevice_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % boundaryNormal % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Vector2D","tags":"","loc":"proc/updatedevice_vector2d.html"},{"title":"UpdateDevice_Vector3D – SELF","text":"public subroutine UpdateDevice_Vector3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Vector3D Source Code SUBROUTINE UpdateDevice_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % boundaryNormal % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Vector3D","tags":"","loc":"proc/updatedevice_vector3d.html"},{"title":"UpdateHost_Scalar1D – SELF","text":"public subroutine UpdateHost_Scalar1D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Scalar1D Source Code SUBROUTINE UpdateHost_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () CALL SELFStorage % avgBoundary % UpdateHost () CALL SELFStorage % jumpBoundary % UpdateHost () END SUBROUTINE UpdateHost_Scalar1D","tags":"","loc":"proc/updatehost_scalar1d.html"},{"title":"UpdateHost_Scalar2D – SELF","text":"public subroutine UpdateHost_Scalar2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Scalar2D Source Code SUBROUTINE UpdateHost_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () CALL SELFStorage % avgBoundary % UpdateHost () CALL SELFStorage % jumpBoundary % UpdateHost () END SUBROUTINE UpdateHost_Scalar2D","tags":"","loc":"proc/updatehost_scalar2d.html"},{"title":"UpdateHost_Scalar3D – SELF","text":"public subroutine UpdateHost_Scalar3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Scalar3D Source Code SUBROUTINE UpdateHost_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () CALL SELFStorage % avgBoundary % UpdateHost () CALL SELFStorage % jumpBoundary % UpdateHost () END SUBROUTINE UpdateHost_Scalar3D","tags":"","loc":"proc/updatehost_scalar3d.html"},{"title":"UpdateHost_Tensor2D – SELF","text":"public subroutine UpdateHost_Tensor2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Tensor2D Source Code SUBROUTINE UpdateHost_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Tensor2D","tags":"","loc":"proc/updatehost_tensor2d.html"},{"title":"UpdateHost_Tensor3D – SELF","text":"public subroutine UpdateHost_Tensor3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Tensor3D Source Code SUBROUTINE UpdateHost_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Tensor3D","tags":"","loc":"proc/updatehost_tensor3d.html"},{"title":"UpdateHost_Vector2D – SELF","text":"public subroutine UpdateHost_Vector2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Vector2D Source Code SUBROUTINE UpdateHost_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % boundaryNormal % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Vector2D","tags":"","loc":"proc/updatehost_vector2d.html"},{"title":"UpdateHost_Vector3D – SELF","text":"public subroutine UpdateHost_Vector3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Vector3D Source Code SUBROUTINE UpdateHost_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % boundaryNormal % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Vector3D","tags":"","loc":"proc/updatehost_vector3d.html"},{"title":"WriteHDF5_MPI_Scalar1D – SELF","text":"public subroutine WriteHDF5_MPI_Scalar1D(this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem Contents Source Code WriteHDF5_MPI_Scalar1D Source Code SUBROUTINE WriteHDF5_MPI_Scalar1D ( this , fileId , group , elemoffset , nglobalelem ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: this CHARACTER ( * ), INTENT ( in ) :: group INTEGER ( HID_T ), INTENT ( in ) :: fileId INTEGER , INTENT ( in ) :: elemoffset INTEGER , INTENT ( in ) :: nglobalelem ! Local INTEGER ( HID_T ) :: offset ( 1 : 3 ) INTEGER ( HID_T ) :: bOffset ( 1 : 3 ) INTEGER ( HID_T ) :: globalDims ( 1 : 3 ) INTEGER ( HID_T ) :: bGlobalDims ( 1 : 3 ) INTEGER :: ivar offset ( 1 : 3 ) = ( / 0 , 0 , elemoffset / ) globalDims ( 1 : 3 ) = ( / this % interp % N + 1 , & this % nVar , & nGlobalElem / ) ! Offsets and dimensions for element boundary data bOffset ( 1 : 3 ) = ( / 0 , 0 , elemoffset / ) bGlobalDims ( 1 : 3 ) = ( / this % nVar , & 2 , & nGlobalElem / ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior , offset , globalDims ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary , bOffset , bGlobalDims ) END SUBROUTINE WriteHDF5_MPI_Scalar1D","tags":"","loc":"proc/writehdf5_mpi_scalar1d.html"},{"title":"WriteHDF5_MPI_Scalar2D – SELF","text":"public subroutine WriteHDF5_MPI_Scalar2D(this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem Contents Source Code WriteHDF5_MPI_Scalar2D Source Code SUBROUTINE WriteHDF5_MPI_Scalar2D ( this , fileId , group , elemoffset , nglobalelem ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: this CHARACTER ( * ), INTENT ( in ) :: group INTEGER ( HID_T ), INTENT ( in ) :: fileId INTEGER , INTENT ( in ) :: elemoffset INTEGER , INTENT ( in ) :: nglobalelem ! Local INTEGER ( HID_T ) :: offset ( 1 : 4 ) INTEGER ( HID_T ) :: bOffset ( 1 : 4 ) INTEGER ( HID_T ) :: globalDims ( 1 : 4 ) INTEGER ( HID_T ) :: bGlobalDims ( 1 : 4 ) INTEGER :: ivar offset ( 1 : 4 ) = ( / 0 , 0 , 0 , elemoffset / ) globalDims ( 1 : 4 ) = ( / this % interp % N + 1 , & this % interp % N + 1 , & this % nVar , & nglobalelem / ) ! Offsets and dimensions for element boundary data bOffset ( 1 : 4 ) = ( / 0 , 0 , 0 , elemoffset / ) bGlobalDims ( 1 : 4 ) = ( / this % interp % N + 1 , & this % nVar , & 4 , & nglobalelem / ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior , offset , globalDims ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary , bOffset , bGlobalDims ) END SUBROUTINE WriteHDF5_MPI_Scalar2D","tags":"","loc":"proc/writehdf5_mpi_scalar2d.html"},{"title":"WriteHDF5_MPI_Scalar3D – SELF","text":"public subroutine WriteHDF5_MPI_Scalar3D(this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem Contents Source Code WriteHDF5_MPI_Scalar3D Source Code SUBROUTINE WriteHDF5_MPI_Scalar3D ( this , fileId , group , elemoffset , nglobalelem ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: this CHARACTER ( * ), INTENT ( in ) :: group INTEGER ( HID_T ), INTENT ( in ) :: fileId INTEGER , INTENT ( in ) :: elemoffset INTEGER , INTENT ( in ) :: nglobalelem ! Local INTEGER ( HID_T ) :: offset ( 1 : 5 ) INTEGER ( HID_T ) :: bOffset ( 1 : 5 ) INTEGER ( HID_T ) :: globalDims ( 1 : 5 ) INTEGER ( HID_T ) :: bGlobalDims ( 1 : 5 ) INTEGER :: ivar offset ( 1 : 5 ) = ( / 0 , 0 , 0 , 0 , elemoffset / ) globalDims ( 1 : 5 ) = ( / this % interp % N + 1 , & this % interp % N + 1 , & this % interp % N + 1 , & this % nVar , & nglobalelem / ) ! Offsets and dimensions for element boundary data bOffset ( 1 : 5 ) = ( / 0 , 0 , 0 , 0 , elemoffset / ) bGlobalDims ( 1 : 5 ) = ( / this % interp % N + 1 , & this % interp % N + 1 , & this % nVar , & 6 , & nglobalelem / ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior , offset , globalDims ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary , bOffset , bGlobalDims ) END SUBROUTINE WriteHDF5_MPI_Scalar3D","tags":"","loc":"proc/writehdf5_mpi_scalar3d.html"},{"title":"WriteHDF5_MPI_Vector2D – SELF","text":"public subroutine WriteHDF5_MPI_Vector2D(this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem Contents Source Code WriteHDF5_MPI_Vector2D Source Code SUBROUTINE WriteHDF5_MPI_Vector2D ( this , fileId , group , elemoffset , nglobalelem ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: this CHARACTER ( * ), INTENT ( in ) :: group INTEGER ( HID_T ), INTENT ( in ) :: fileId INTEGER , INTENT ( in ) :: elemoffset INTEGER , INTENT ( in ) :: nglobalelem ! Local INTEGER ( HID_T ) :: offset ( 1 : 5 ) INTEGER ( HID_T ) :: bOffset ( 1 : 5 ) INTEGER ( HID_T ) :: globalDims ( 1 : 5 ) INTEGER ( HID_T ) :: bGlobalDims ( 1 : 5 ) INTEGER :: ivar offset ( 1 : 5 ) = ( / 0 , 0 , 0 , 0 , elemoffset / ) globalDims ( 1 : 5 ) = ( / 2 , & this % interp % N + 1 , & this % interp % N + 1 , & this % nVar , & nglobalelem / ) ! Offsets and dimensions for element boundary data bOffset ( 1 : 5 ) = ( / 0 , 0 , 0 , 0 , elemoffset / ) bGlobalDims ( 1 : 5 ) = ( / 2 , & this % interp % N + 1 , & this % nVar , & 4 , & nglobalelem / ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior , offset , globalDims ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary , bOffset , bGlobalDims ) END SUBROUTINE WriteHDF5_MPI_Vector2D","tags":"","loc":"proc/writehdf5_mpi_vector2d.html"},{"title":"WriteHDF5_MPI_Vector3D – SELF","text":"public subroutine WriteHDF5_MPI_Vector3D(this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem Contents Source Code WriteHDF5_MPI_Vector3D Source Code SUBROUTINE WriteHDF5_MPI_Vector3D ( this , fileId , group , elemoffset , nglobalelem ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: this CHARACTER ( * ), INTENT ( in ) :: group INTEGER ( HID_T ), INTENT ( in ) :: fileId INTEGER , INTENT ( in ) :: elemoffset INTEGER , INTENT ( in ) :: nglobalelem ! Local INTEGER ( HID_T ) :: offset ( 1 : 6 ) INTEGER ( HID_T ) :: bOffset ( 1 : 6 ) INTEGER ( HID_T ) :: globalDims ( 1 : 6 ) INTEGER ( HID_T ) :: bGlobalDims ( 1 : 6 ) INTEGER :: ivar offset ( 1 : 6 ) = ( / 0 , 0 , 0 , 0 , 0 , elemoffset / ) globalDims ( 1 : 6 ) = ( / 3 , & this % interp % N + 1 , & this % interp % N + 1 , & this % interp % N + 1 , & this % nVar , & nglobalelem / ) ! Offsets and dimensions for element boundary data bOffset ( 1 : 6 ) = ( / 0 , 0 , 0 , 0 , 0 , elemoffset / ) bGlobalDims ( 1 : 6 ) = ( / 3 , & this % interp % N + 1 , & this % interp % N + 1 , & this % nVar , & 6 , & nglobalelem / ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior , offset , globalDims ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary , bOffset , bGlobalDims ) END SUBROUTINE WriteHDF5_MPI_Vector3D","tags":"","loc":"proc/writehdf5_mpi_vector3d.html"},{"title":"WriteHDF5_Scalar1D – SELF","text":"public subroutine WriteHDF5_Scalar1D(this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Contents Source Code WriteHDF5_Scalar1D Source Code SUBROUTINE WriteHDF5_Scalar1D ( this , fileId , group ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: this INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: group ! Local INTEGER :: ivar CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary ) END SUBROUTINE WriteHDF5_Scalar1D","tags":"","loc":"proc/writehdf5_scalar1d.html"},{"title":"WriteHDF5_Scalar2D – SELF","text":"public subroutine WriteHDF5_Scalar2D(this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Contents Source Code WriteHDF5_Scalar2D Source Code SUBROUTINE WriteHDF5_Scalar2D ( this , fileId , group ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: this INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: group ! Local INTEGER :: ivar CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary ) END SUBROUTINE WriteHDF5_Scalar2D","tags":"","loc":"proc/writehdf5_scalar2d.html"},{"title":"WriteHDF5_Scalar3D – SELF","text":"public subroutine WriteHDF5_Scalar3D(this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Contents Source Code WriteHDF5_Scalar3D Source Code SUBROUTINE WriteHDF5_Scalar3D ( this , fileId , group ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: this INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: group ! Local INTEGER :: ivar CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary ) END SUBROUTINE WriteHDF5_Scalar3D","tags":"","loc":"proc/writehdf5_scalar3d.html"},{"title":"WriteHDF5_Vector2D – SELF","text":"public subroutine WriteHDF5_Vector2D(this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Contents Source Code WriteHDF5_Vector2D Source Code SUBROUTINE WriteHDF5_Vector2D ( this , fileId , group ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: this INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: group ! Local INTEGER :: ivar CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary ) END SUBROUTINE WriteHDF5_Vector2D","tags":"","loc":"proc/writehdf5_vector2d.html"},{"title":"WriteHDF5_Vector3D – SELF","text":"public subroutine WriteHDF5_Vector3D(this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Contents Source Code WriteHDF5_Vector3D Source Code SUBROUTINE WriteHDF5_Vector3D ( this , fileId , group ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: this INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: group ! Local INTEGER :: ivar CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary ) END SUBROUTINE WriteHDF5_Vector3D","tags":"","loc":"proc/writehdf5_vector3d.html"},{"title":"Determinant_Tensor2D_gpu_wrapper – SELF","text":"interface public subroutine Determinant_Tensor2D_gpu_wrapper(tensor_dev, detTensor_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor_dev type(c_ptr) :: detTensor_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/determinant_tensor2d_gpu_wrapper.html"},{"title":"Determinant_Tensor3D_gpu_wrapper – SELF","text":"interface public subroutine Determinant_Tensor3D_gpu_wrapper(tensor_dev, detTensor_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor_dev type(c_ptr) :: detTensor_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/determinant_tensor3d_gpu_wrapper.html"},{"title":"hipCheck – SELF","text":"public subroutine hipCheck(hipError_t) Uses SELF_HIP_enums Arguments Type Intent Optional Attributes Name integer(kind=KIND(hipSuccess)) :: hipError_t Contents Source Code hipCheck Source Code SUBROUTINE hipCheck ( hipError_t ) USE SELF_HIP_enums IMPLICIT NONE INTEGER ( KIND ( hipSuccess )) :: hipError_t IF ( hipError_t /= hipSuccess ) THEN WRITE ( * , * ) \"HIP ERROR: Error code = \" , hipError_t CALL EXIT ( hipError_t ) END IF END SUBROUTINE hipCheck","tags":"","loc":"proc/hipcheck.html"},{"title":"hipFree – SELF","text":"public interface hipFree Contents Functions hipFree_ Functions public function hipFree_(ptr) bind(c,name=\"hipFree\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: ptr Return Value integer(kind=KIND(hipSuccess))","tags":"","loc":"interface/hipfree.html"},{"title":"hipGetDeviceCount – SELF","text":"public interface hipGetDeviceCount Contents Functions hipGetDeviceCount_ Functions public function hipGetDeviceCount_(count) bind(c,name=\"hipGetDeviceCount\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT) :: count Return Value integer(kind=KIND(hipSuccess))","tags":"","loc":"interface/hipgetdevicecount.html"},{"title":"hipMalloc – SELF","text":"public interface hipMalloc Contents Functions hipMalloc_ Functions public function hipMalloc_(ptr, mySize) bind(c,name=\"hipMalloc\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: ptr integer(kind=C_SIZE_T), VALUE :: mySize Return Value integer(kind=KIND(hipSuccess))","tags":"","loc":"interface/hipmalloc.html"},{"title":"hipMemcpy – SELF","text":"public interface hipMemcpy Contents Functions hipMemcpy_ Functions public function hipMemcpy_(dest, src, sizeBytes, myKind) bind(c,name=\"hipMemcpy\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: dest type(C_PTR), VALUE :: src integer(kind=C_SIZE_T), VALUE :: sizeBytes integer(kind=KIND(hipMemcpyHostToHost)), VALUE :: myKind Return Value integer(kind=KIND(hipSuccess))","tags":"","loc":"interface/hipmemcpy.html"},{"title":"hipSetDevice – SELF","text":"public interface hipSetDevice Contents Functions hipSetDevice_ Functions public function hipSetDevice_(deviceId) bind(c,name=\"hipSetDevice\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT), VALUE :: deviceId Return Value integer(kind=KIND(hipSuccess))","tags":"","loc":"interface/hipsetdevice.html"},{"title":"CalculateFluxDivergence_ECModel2D – SELF","text":"public subroutine CalculateFluxDivergence_ECModel2D(this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this Contents Source Code CalculateFluxDivergence_ECModel2D Source Code SUBROUTINE CalculateFluxDivergence_ECModel2D ( this ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CALL this % flux % Divergence ( this % geometry , & this % fluxDivergence , & selfWeakDGForm , & this % gpuAccel ) END SUBROUTINE CalculateFluxDivergence_ECModel2D","tags":"","loc":"proc/calculatefluxdivergence_ecmodel2d.html"},{"title":"CalculateTendency_ECModel2D – SELF","text":"public subroutine CalculateTendency_ECModel2D(this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this Contents Source Code CalculateTendency_ECModel2D Source Code SUBROUTINE CalculateTendency_ECModel2D ( this ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER :: i , j , iVar , iEl CALL this % PreTendency () CALL this % UpdateBoundary () CALL this % SetBoundaryCondition () CALL this % SourceMethod () CALL this % PreFlux () CALL this % RiemannSolver () CALL this % FluxMethod () CALL this % ReprojectFlux () CALL this % CalculateFluxDivergence () IF ( this % gpuAccel ) THEN CALL CalculateDSDt_Model2D_gpu_wrapper ( this % fluxDivergence % interior % deviceData , & this % source % interior % deviceData , & this % dSdt % interior % deviceData , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % dSdt % interior % hostData ( i , j , iVar , iEl ) = & this % source % interior % hostData ( i , j , iVar , iEl ) - & this % fluxDivergence % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE CalculateTendency_ECModel2D","tags":"","loc":"proc/calculatetendency_ecmodel2d.html"},{"title":"Free_ECModel2D – SELF","text":"public subroutine Free_ECModel2D(this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this Contents Source Code Free_ECModel2D Source Code SUBROUTINE Free_ECModel2D ( this ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CALL this % solution % Free () CALL this % workSol % Free () CALL this % prevSol % Free () CALL this % dSdt % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () END SUBROUTINE Free_ECModel2D","tags":"","loc":"proc/free_ecmodel2d.html"},{"title":"Init_ECModel2D – SELF","text":"public subroutine Init_ECModel2D(this, nvar, mesh, geometry, decomp) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), TARGET :: mesh type( SEMQuad ), intent(in), TARGET :: geometry type( MPILayer ), intent(in), TARGET :: decomp Contents Source Code Init_ECModel2D Source Code SUBROUTINE Init_ECModel2D ( this , nvar , mesh , geometry , decomp ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: nvar TYPE ( Mesh2D ), INTENT ( in ), TARGET :: mesh TYPE ( SEMQuad ), INTENT ( in ), TARGET :: geometry TYPE ( MPILayer ), INTENT ( in ), TARGET :: decomp ! Local INTEGER :: ivar CHARACTER ( LEN = 3 ) :: ivarChar CHARACTER ( LEN = 25 ) :: varname this % decomp => decomp this % mesh => mesh this % geometry => geometry this % gpuAccel = . FALSE . CALL this % solution % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % workSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % prevSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % dSdt % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % solutionGradient % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % flux % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % source % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % fluxDivergence % Init ( geometry % x % interp , nVar , this % mesh % nElem ) ! set default metadata DO ivar = 1 , nvar WRITE ( ivarChar , '(I3.3)' ) ivar varname = \"solution\" // TRIM ( ivarChar ) CALL this % solution % SetName ( ivar , varname ) CALL this % solution % SetUnits ( ivar , \"[null]\" ) END DO END SUBROUTINE Init_ECModel2D","tags":"","loc":"proc/init_ecmodel2d.html"},{"title":"Read_ECModel2D – SELF","text":"public subroutine Read_ECModel2D(this, fileName) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this character, intent(in) :: fileName Contents Source Code Read_ECModel2D Source Code SUBROUTINE Read_ECModel2D ( this , fileName ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 4 ) INTEGER :: firstElem INTEGER :: N IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % decomp % mpiComm ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) END IF ! CALL ReadAttribute_HDF5(fileId,'N',N) ! IF (this % solution % interp % N /= N) THEN !   STOP 'Error : Solution polynomial degree does not match input file' ! END IF IF ( this % decomp % mpiEnabled ) THEN firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 4 ) = ( / 0 , 0 , 1 , firstElem / ) CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , & this % solution % interior , solOffset ) ELSE CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , this % solution % interior ) END IF CALL Close_HDF5 ( fileId ) IF ( this % gpuAccel ) THEN CALL this % solution % interior % UpdateDevice () END IF END SUBROUTINE Read_ECModel2D","tags":"","loc":"proc/read_ecmodel2d.html"},{"title":"ReprojectFlux_ECModel2D – SELF","text":"public subroutine ReprojectFlux_ECModel2D(this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this Contents Source Code ReprojectFlux_ECModel2D Source Code SUBROUTINE ReprojectFlux_ECModel2D ( this ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CALL this % flux % ContravariantProjection ( this % geometry , this % gpuAccel ) END SUBROUTINE ReprojectFlux_ECModel2D","tags":"","loc":"proc/reprojectflux_ecmodel2d.html"},{"title":"ResizePrevSol_ECModel2D – SELF","text":"public subroutine ResizePrevSol_ECModel2D(this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code ResizePrevSol_ECModel2D Source Code SUBROUTINE ResizePrevSol_ECModel2D ( this , m ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: nVar ! Free space, if necessary CALL this % prevSol % Free () ! Reallocate with increased variable dimension for ! storing \"m\" copies of solution data nVar = this % solution % nVar CALL this % prevSol % Init ( this % geometry % x % interp , m * nVar , this % mesh % nElem ) END SUBROUTINE ResizePrevSol_ECModel2D","tags":"","loc":"proc/resizeprevsol_ecmodel2d.html"},{"title":"SetSolutionFromChar_ECModel2D – SELF","text":"public subroutine SetSolutionFromChar_ECModel2D(this, eqnChar) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) Contents Source Code SetSolutionFromChar_ECModel2D Source Code SUBROUTINE SetSolutionFromChar_ECModel2D ( this , eqnChar ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CHARACTER ( LEN = SELF_EQUATION_LENGTH ), INTENT ( in ) :: eqnChar ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar DO iVar = 1 , this % solution % nVar CALL this % solution % SetEquation ( ivar , eqnChar ( iVar )) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromChar_ECModel2D","tags":"","loc":"proc/setsolutionfromchar_ecmodel2d.html"},{"title":"SetSolutionFromEqn_ECModel2D – SELF","text":"public subroutine SetSolutionFromEqn_ECModel2D(this, eqn) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) Contents Source Code SetSolutionFromEqn_ECModel2D Source Code SUBROUTINE SetSolutionFromEqn_ECModel2D ( this , eqn ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar ! Copy the equation parser DO iVar = 1 , this % solution % nVar CALL this % solution % SetEquation ( ivar , eqn ( iVar ) % equation ) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromEqn_ECModel2D","tags":"","loc":"proc/setsolutionfromeqn_ecmodel2d.html"},{"title":"UpdateBoundary_ECModel2D – SELF","text":"public subroutine UpdateBoundary_ECModel2D(this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this Contents Source Code UpdateBoundary_ECModel2D Source Code SUBROUTINE UpdateBoundary_ECModel2D ( this ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CALL this % solution % BoundaryInterp ( this % gpuAccel ) CALL this % solution % SideExchange ( this % mesh , this % decomp , this % gpuAccel ) END SUBROUTINE UpdateBoundary_ECModel2D","tags":"","loc":"proc/updateboundary_ecmodel2d.html"},{"title":"UpdateDevice_ECModel2D – SELF","text":"public subroutine UpdateDevice_ECModel2D(this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this Contents Source Code UpdateDevice_ECModel2D Source Code SUBROUTINE UpdateDevice_ECModel2D ( this ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CALL this % mesh % UpdateDevice () CALL this % geometry % UpdateDevice () CALL this % dSdt % UpdateDevice () CALL this % solution % UpdateDevice () CALL this % solutionGradient % UpdateDevice () CALL this % flux % UpdateDevice () CALL this % source % UpdateDevice () CALL this % fluxDivergence % UpdateDevice () END SUBROUTINE UpdateDevice_ECModel2D","tags":"","loc":"proc/updatedevice_ecmodel2d.html"},{"title":"UpdateGAB2_ECModel2D – SELF","text":"public subroutine UpdateGAB2_ECModel2D(this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGAB2_ECModel2D Source Code SUBROUTINE UpdateGAB2_ECModel2D ( this , m ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB2_Model2D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE ! ab2_weight IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Reset solution DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last solution this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & 1.5_PREC * this % prevSol % interior % hostData ( i , j , iVar , iEl ) - & 0.5_PREC * this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) END DO END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB2_ECModel2D","tags":"","loc":"proc/updategab2_ecmodel2d.html"},{"title":"UpdateGAB3_ECModel2D – SELF","text":"public subroutine UpdateGAB3_ECModel2D(this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGAB3_ECModel2D Source Code SUBROUTINE UpdateGAB3_ECModel2D ( this , m ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB3_Model2D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 2 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & ( 2 3.0_PREC * this % prevSol % interior % hostData ( i , j , iVar , iEl ) - & 1 6.0_PREC * this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) + & 5.0_PREC * this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl )) / 1 2.0_PREC END DO END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB3_ECModel2D","tags":"","loc":"proc/updategab3_ecmodel2d.html"},{"title":"UpdateGAB4_ECModel2D – SELF","text":"public subroutine UpdateGAB4_ECModel2D(this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGAB4_ECModel2D Source Code SUBROUTINE UpdateGAB4_ECModel2D ( this , m ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB4_Model2D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 2 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 3 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions this % prevSol % interior % hostData ( i , j , 3 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & ( 5 5.0_PREC * this % prevSol % interior % hostData ( i , j , iVar , iEl ) - & 5 9.0_PREC * this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) + & 3 7.0_PREC * this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) - & 9.0_PREC * this % prevSol % interior % hostData ( i , j , 3 * nVar + iVar , iEl )) / 2 4.0_PREC END DO END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB4_ECModel2D","tags":"","loc":"proc/updategab4_ecmodel2d.html"},{"title":"UpdateGRK2_ECModel2D – SELF","text":"public subroutine UpdateGRK2_ECModel2D(this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK2_ECModel2D Source Code SUBROUTINE UpdateGRK2_ECModel2D ( this , m ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model2D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk2_a ( m ), rk2_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , iVar , iEl ) = rk2_a ( m ) * & this % workSol % interior % hostData ( i , j , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & rk2_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateGRK2_ECModel2D","tags":"","loc":"proc/updategrk2_ecmodel2d.html"},{"title":"UpdateGRK3_ECModel2D – SELF","text":"public subroutine UpdateGRK3_ECModel2D(this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK3_ECModel2D Source Code SUBROUTINE UpdateGRK3_ECModel2D ( this , m ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model2D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk3_a ( m ), rk3_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , iVar , iEl ) = rk3_a ( m ) * & this % workSol % interior % hostData ( i , j , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & rk3_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateGRK3_ECModel2D","tags":"","loc":"proc/updategrk3_ecmodel2d.html"},{"title":"UpdateGRK4_ECModel2D – SELF","text":"public subroutine UpdateGRK4_ECModel2D(this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK4_ECModel2D Source Code SUBROUTINE UpdateGRK4_ECModel2D ( this , m ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model2D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk4_a ( m ), rk4_g ( m ), this % dt , & this % workSol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , iVar , iEl ) = rk4_a ( m ) * & this % workSol % interior % hostData ( i , j , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & rk4_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateGRK4_ECModel2D","tags":"","loc":"proc/updategrk4_ecmodel2d.html"},{"title":"UpdateHost_ECModel2D – SELF","text":"public subroutine UpdateHost_ECModel2D(this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this Contents Source Code UpdateHost_ECModel2D Source Code SUBROUTINE UpdateHost_ECModel2D ( this ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CALL this % mesh % UpdateHost () CALL this % geometry % UpdateHost () CALL this % solution % UpdateHost () CALL this % dSdt % UpdateHost () CALL this % solution % UpdateHost () CALL this % solutionGradient % UpdateHost () CALL this % flux % UpdateHost () CALL this % source % UpdateHost () CALL this % fluxDivergence % UpdateHost () END SUBROUTINE UpdateHost_ECModel2D","tags":"","loc":"proc/updatehost_ecmodel2d.html"},{"title":"UpdateSolution_ECModel2D – SELF","text":"public subroutine UpdateSolution_ECModel2D(this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the ECModel's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt Contents Source Code UpdateSolution_ECModel2D Source Code SUBROUTINE UpdateSolution_ECModel2D ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the ECModel's stored time step size (model % dt) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this REAL ( prec ), OPTIONAL , INTENT ( in ) :: dt ! Local REAL ( prec ) :: dtLoc INTEGER :: i , j , iVar , iEl IF ( PRESENT ( dt )) THEN dtLoc = dt ELSE dtLoc = this % dt END IF IF ( this % gpuAccel ) THEN CALL UpdateSolution_Model2D_gpu_wrapper ( this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & dtLoc , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & dtLoc * this % dSdt % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateSolution_ECModel2D","tags":"","loc":"proc/updatesolution_ecmodel2d.html"},{"title":"WriteTecplot_ECModel2D – SELF","text":"public subroutine WriteTecplot_ECModel2D(this, filename) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this character, intent(in), optional :: filename Contents Source Code WriteTecplot_ECModel2D Source Code SUBROUTINE WriteTecplot_ECModel2D ( this , filename ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ), OPTIONAL :: filename ! Local CHARACTER ( 8 ) :: zoneID INTEGER :: fUnit INTEGER :: iEl , i , j , iVar CHARACTER ( LEN = self_FileNameLength ) :: tecFile CHARACTER ( LEN = self_TecplotHeaderLength ) :: tecHeader CHARACTER ( LEN = self_FormatLength ) :: fmat CHARACTER ( 13 ) :: timeStampString CHARACTER ( 5 ) :: rankString TYPE ( Scalar2D ) :: solution TYPE ( Vector2D ) :: solutionGradient TYPE ( Vector2D ) :: x TYPE ( Lagrange ), TARGET :: interp IF ( PRESENT ( filename )) THEN tecFile = filename ELSE timeStampString = TimeStamp ( this % t , 's' ) IF ( this % decomp % mpiEnabled ) THEN WRITE ( rankString , '(I5.5)' ) this % decomp % rankId tecFile = 'solution.' // rankString // '.' // timeStampString // '.tec' ELSE tecFile = 'solution.' // timeStampString // '.tec' END IF END IF ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL solutionGradient % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solutionGradient % GridInterp ( solutionGradient , gpuAccel = . FALSE .) OPEN ( UNIT = NEWUNIT ( fUnit ), & FILE = TRIM ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) tecHeader = 'VARIABLES = \"X\", \"Y\"' DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"' // TRIM ( this % solution % meta ( iVar ) % name ) // '\"' END DO DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"d/dx(' // TRIM ( this % solution % meta ( iVar ) % name ) // ')\"' END DO DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"d/dy(' // TRIM ( this % solution % meta ( iVar ) % name ) // ')\"' END DO WRITE ( fUnit , * ) TRIM ( tecHeader ) ! Create format statement WRITE ( fmat , * ) 3 * this % solution % nvar + 2 fmat = '(' // TRIM ( fmat ) // '(ES16.7E3,1x))' DO iEl = 1 , this % solution % nElem ! TO DO :: Get the global element ID WRITE ( zoneID , '(I8.8)' ) iEl WRITE ( fUnit , * ) 'ZONE T=\"el' // TRIM ( zoneID ) // '\", I=' , this % solution % interp % M + 1 , & ', J=' , this % solution % interp % M + 1 DO j = 0 , this % solution % interp % M DO i = 0 , this % solution % interp % M WRITE ( fUnit , fmat ) x % interior % hostData ( 1 , i , j , 1 , iEl ), & x % interior % hostData ( 2 , i , j , 1 , iEl ), & solution % interior % hostData ( i , j , 1 : this % solution % nvar , iEl ), & solutionGradient % interior % hostData ( 1 , i , j , 1 : this % solution % nvar , iEl ), & solutionGradient % interior % hostData ( 2 , i , j , 1 : this % solution % nvar , iEl ) END DO END DO END DO CLOSE ( UNIT = fUnit ) CALL x % Free () CALL solution % Free () CALL solutionGradient % Free () CALL interp % Free () END SUBROUTINE WriteTecplot_ECModel2D","tags":"","loc":"proc/writetecplot_ecmodel2d.html"},{"title":"Write_ECModel2D – SELF","text":"public subroutine Write_ECModel2D(this, fileName) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this character, intent(in), optional :: fileName Contents Source Code Write_ECModel2D Source Code SUBROUTINE Write_ECModel2D ( this , fileName ) #undef __FUNC__ #define __FUNC__ \"Write_ECModel2D\" IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CHARACTER ( * ), OPTIONAL , INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId TYPE ( Scalar2D ) :: solution TYPE ( Vector2D ) :: x TYPE ( Lagrange ), TARGET :: interp CHARACTER ( LEN = self_FileNameLength ) :: pickupFile CHARACTER ( 13 ) :: timeStampString IF ( PRESENT ( filename )) THEN pickupFile = filename ELSE WRITE ( timeStampString , '(I13.13)' ) this % ioIterate pickupFile = 'solution.' // timeStampString // '.h5' END IF IF ( this % gpuAccel ) THEN CALL this % solution % UpdateHost () CALL this % solutionGradient % UpdateHost () END IF INFO ( \"Writing pickup file : \" // TRIM ( pickupFile )) IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId , this % decomp % mpiComm ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file INFO ( \"Writing control grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid/mesh' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/mesh/coords' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) CALL Close_HDF5 ( fileId ) ELSE CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' ) ! Write the geometry to file INFO ( \"Writing control grid  geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file INFO ( \"Writing target grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' ) ! Write the geometry to file INFO ( \"Writing target grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid/geometry' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/geometry/x' ) CALL Close_HDF5 ( fileId ) END IF CALL x % Free () CALL solution % Free () CALL interp % Free () END SUBROUTINE Write_ECModel2D","tags":"","loc":"proc/write_ecmodel2d.html"},{"title":"SELF_SupportRoutines – SELF","text":"\\file SELF_SupportRoutines.f90\nContains the \\ref SELF_SupportRoutines module\n\\defgroup SELF_SupportRoutines SELF_SupportRoutines\nThis module defines a set of general purpose routines. Uses iso_fortran_env SELF_Constants Contents Variables tolerance Interfaces AlmostEqual Functions AlmostEqual_r64 CompareArray UniformPoints UpperCase newunit Subroutines ForwardShift Variables Type Visibility Attributes Name Initial real(kind=prec), private, parameter :: tolerance = 10.0**(-10) Interfaces public interface AlmostEqual public function AlmostEqual_r64 (a, b) result(AisB) \\addtogroup SELF_SupportRoutines\n @{\n \\fn AlmostEqual\n Compares two floating point numbers and determines if they are equal (to machine precision). Read more… Arguments Type Intent Optional Attributes Name real(kind=real64) :: a real(kind=real64) :: b Return Value logical Functions public function AlmostEqual_r64 (a, b) result(AisB) \\addtogroup SELF_SupportRoutines\n @{\n \\fn AlmostEqual\n Compares two floating point numbers and determines if they are equal (to machine precision). Read more… Arguments Type Intent Optional Attributes Name real(kind=real64) :: a real(kind=real64) :: b Return Value logical public function CompareArray (arrayOne, arrayTwo, N) result(arraysMatch) \\addtogroup SELF_SupportRoutines\n @{\n \\fn CompareArray\n Compares to INTEGER arrays and determines if they are identical. Read more… Arguments Type Intent Optional Attributes Name integer :: arrayOne (1:N) integer :: arrayTwo (1:N) integer :: N Return Value logical public function UniformPoints (a, b, firstInd, lastInd) result(xU) \\addtogroup SELF_SupportRoutines\n @{\n \\fn UniformPoints\n Generates a REAL(prec) array of N points evenly spaced between two points. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec) :: a real(kind=prec) :: b integer :: firstInd integer :: lastInd Return Value real(kind=prec)(firstInd:lastInd) public function UpperCase (str) result(Upper) Arguments Type Intent Optional Attributes Name character, intent(in) :: str Return Value character public function newunit (unit) Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: unit Return Value integer Subroutines public subroutine ForwardShift (myArray, N) \\addtogroup SELF_SupportRoutines\n @{\n \\fn ForwardShift\n Shift an array integers by one index forward, moving the last index to the first. Read more… Arguments Type Intent Optional Attributes Name integer, intent(inout) :: myArray (1:N) integer, intent(in) :: N","tags":"","loc":"module/self_supportroutines.html"},{"title":"SELF_Model3D – SELF","text":"Uses FEQParse SELF_Metadata SELF_Mesh SELF_HDF5 HDF5 SELF_Model SELF_SupportRoutines SELF_MappedData Contents Interfaces CalculateDSDt_Model3D_gpu_wrapper UpdateGAB2_Model3D_gpu_wrapper UpdateGAB3_Model3D_gpu_wrapper UpdateGAB4_Model3D_gpu_wrapper UpdateGRK_Model3D_gpu_wrapper UpdateSolution_Model3D_gpu_wrapper Derived Types Model3D Subroutines CalculateFluxDivergence_Model3D CalculateTendency_Model3D Free_Model3D Init_Model3D Read_Model3D ReprojectFlux_Model3D ResizePrevSol_Model3D SetSolutionFromChar_Model3D SetSolutionFromEqn_Model3D UpdateDevice_Model3D UpdateGAB2_Model3D UpdateGAB3_Model3D UpdateGAB4_Model3D UpdateGRK2_Model3D UpdateGRK3_Model3D UpdateGRK4_Model3D UpdateHost_Model3D UpdateSolution_Model3D WriteTecplot_Model3D Write_Model3D Interfaces interface public subroutine CalculateDSDt_Model3D_gpu_wrapper(fluxDivergence, source, dSdt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: fluxDivergence type(C_PTR) :: source type(C_PTR) :: dSdt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateGAB2_Model3D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateGAB3_Model3D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateGAB4_Model3D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateGRK_Model3D_gpu_wrapper(grk, solution, dSdt, rk_a, rk_g, dt, nWork, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: grk type(C_PTR) :: solution type(C_PTR) :: dSdt real(kind=c_prec), VALUE :: rk_a real(kind=c_prec), VALUE :: rk_g real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: nWork integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateSolution_Model3D_gpu_wrapper(solution, dSdt, dt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: solution type(C_PTR) :: dSdt real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl Derived Types type, public, extends( Model ) :: Model3D Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, POINTER :: geometry logical, public :: gpuAccel integer, public :: ioIterate = 0 type( Mesh3D ), public, POINTER :: mesh type( MappedScalar3D ), public :: prevSol type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator procedure, public :: AdamsBashforth3_timeIntegrator procedure, public :: AdamsBashforth4_timeIntegrator procedure, public :: CalculateEntropy => CalculateEntropy_Model procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_Model3D procedure, public :: CalculateTendency => CalculateTendency_Model3D procedure, public :: DisableGPUAccel => DisableGPUAccel_Model procedure, public :: EnableGPUAccel => EnableGPUAccel_Model procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => Flux_Model procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_Model3D procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_Model3D procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreFlux => PreFlux_Model procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_Model3D procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: ReprojectFlux => ReprojectFlux_Model3D procedure, public :: ResizePrevSol => ResizePrevSol_Model3D procedure, public :: RiemannSolver => RiemannSolver_Model procedure, public :: SetBoundaryCondition => SetBoundaryCondition_Model procedure, public :: SetInitialConditions => SetInitialConditions_Model procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_Model3D, SetSolutionFromEqn_Model3D procedure, private :: SetSolutionFromChar_Model3D procedure, private :: SetSolutionFromEqn_Model3D generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt, SetTimeIntegrator_withChar procedure, public :: SourceMethod => Source_Model procedure, public :: UpdateBoundary => UpdateBoundary_Model procedure, public :: UpdateDevice => UpdateDevice_Model3D procedure, public :: UpdateGAB2 => UpdateGAB2_Model3D procedure, public :: UpdateGAB3 => UpdateGAB3_Model3D procedure, public :: UpdateGAB4 => UpdateGAB4_Model3D procedure, public :: UpdateGRK2 => UpdateGRK2_Model3D procedure, public :: UpdateGRK3 => UpdateGRK3_Model3D procedure, public :: UpdateGRK4 => UpdateGRK4_Model3D procedure, public :: UpdateHost => UpdateHost_Model3D procedure, public :: UpdateSolution => UpdateSolution_Model3D procedure, public :: WriteModel => Write_Model3D procedure, public :: WriteTecplot => WriteTecplot_Model3D Subroutines public subroutine CalculateFluxDivergence_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this public subroutine CalculateTendency_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this public subroutine Free_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this public subroutine Init_Model3D (this, nvar, mesh, geometry, decomp) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(out) :: this integer, intent(in) :: nvar type( Mesh3D ), intent(in), TARGET :: mesh type( SEMHex ), intent(in), TARGET :: geometry type( MPILayer ), intent(in), TARGET :: decomp public subroutine Read_Model3D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in) :: fileName public subroutine ReprojectFlux_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this public subroutine ResizePrevSol_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m public subroutine SetSolutionFromChar_Model3D (this, eqnChar) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_Model3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) public subroutine UpdateDevice_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this public subroutine UpdateGAB2_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGAB3_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGAB4_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK2_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK3_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK4_Model3D (this, m) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateHost_Model3D (this) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this public subroutine UpdateSolution_Model3D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt public subroutine WriteTecplot_Model3D (this, filename) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in), optional :: filename public subroutine Write_Model3D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model3D ), intent(inout) :: this character, intent(in), optional :: fileName","tags":"","loc":"module/self_model3d.html"},{"title":"SELF_Lagrange – SELF","text":"Uses SELF_Quadrature SELF_Memory SELF_HDF5 SELF_SupportRoutines iso_fortran_env HDF5 SELF_Constants iso_c_binding Contents Interfaces DGDerivative_1D_gpu_wrapper Derivative_1D_gpu_wrapper ScalarBoundaryInterp_1D_gpu_wrapper ScalarBoundaryInterp_2D_gpu_wrapper ScalarBoundaryInterp_3D_gpu_wrapper ScalarGradient_2D_gpu_wrapper ScalarGradient_3D_gpu_wrapper ScalarGridInterp_1D_gpu_wrapper ScalarGridInterp_2D_gpu_wrapper ScalarGridInterp_3D_gpu_wrapper TensorBoundaryInterp_2D_gpu_wrapper TensorBoundaryInterp_3D_gpu_wrapper VectorBoundaryInterp_2D_gpu_wrapper VectorBoundaryInterp_3D_gpu_wrapper VectorDGDivergence_2D_gpu_wrapper VectorDGDivergence_3D_gpu_wrapper VectorDGGradient_2D_gpu_wrapper VectorDivergence_2D_gpu_wrapper VectorDivergence_3D_gpu_wrapper VectorGradient_2D_gpu_wrapper VectorGradient_3D_gpu_wrapper VectorGridInterp_2D_gpu_wrapper VectorGridInterp_3D_gpu_wrapper Derived Types Lagrange Functions CalculateLagrangePolynomials Subroutines CalculateBarycentricWeights CalculateDerivativeMatrix CalculateInterpolationMatrix DGDerivative_1D_cpu DGDerivative_1D_gpu Derivative_1D_cpu Derivative_1D_gpu Free_Lagrange Init_Lagrange ScalarBoundaryInterp_1D_cpu ScalarBoundaryInterp_1D_gpu ScalarBoundaryInterp_2D_cpu ScalarBoundaryInterp_2D_gpu ScalarBoundaryInterp_3D_cpu ScalarBoundaryInterp_3D_gpu ScalarGradient_2D_cpu ScalarGradient_2D_gpu ScalarGradient_3D_cpu ScalarGradient_3D_gpu ScalarGridInterp_1D_cpu ScalarGridInterp_1D_gpu ScalarGridInterp_2D_cpu ScalarGridInterp_2D_gpu ScalarGridInterp_3D_cpu ScalarGridInterp_3D_gpu TensorBoundaryInterp_2D_cpu TensorBoundaryInterp_2D_gpu TensorBoundaryInterp_3D_cpu TensorBoundaryInterp_3D_gpu UpdateDevice_Lagrange UpdateHost_Lagrange VectorBoundaryInterp_2D_cpu VectorBoundaryInterp_2D_gpu VectorBoundaryInterp_3D_cpu VectorBoundaryInterp_3D_gpu VectorDGDivergence_2D_cpu VectorDGDivergence_2D_gpu VectorDGDivergence_3D_cpu VectorDGDivergence_3D_gpu VectorDivergence_2D_cpu VectorDivergence_2D_gpu VectorDivergence_3D_cpu VectorDivergence_3D_gpu VectorGradient_2D_cpu VectorGradient_2D_gpu VectorGradient_3D_cpu VectorGradient_3D_gpu VectorGridInterp_2D_cpu VectorGridInterp_2D_gpu VectorGridInterp_3D_cpu VectorGridInterp_3D_gpu WriteHDF5_Lagrange Interfaces interface public subroutine DGDerivative_1D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine Derivative_1D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarBoundaryInterp_1D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarGradient_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarGradient_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarGridInterp_1D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine TensorBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine TensorBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorDGDivergence_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorDGDivergence_3D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorDGGradient_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorDivergence_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorDivergence_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorGradient_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorGradient_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl Derived Types type, public :: Lagrange A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions.\nThe Lagrange data-structure stores the information necessary to interpolate between two\nsets of grid-points and to estimate the derivative of data at native grid points. Routines for\nmultidimensional interpolation are based on the tensor product of 1-D interpolants. It is\nassumed that the polynomial degree (and the interpolation nodes) are the same in each direction.\nThis assumption permits the storage of only one array of interpolation nodes and barycentric\nweights and is what allows this data structure to be flexible. Components Type Visibility Attributes Name Initial integer, public :: M The number of target points. integer, public :: N The number of control points. type( hfReal_r2 ), public :: bMatrix The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. type( hfReal_r1 ), public :: bWeights The barycentric weights that are calculated from the controlPoints and used for interpolation. integer, public :: controlNodeType type( hfReal_r1 ), public :: controlPoints The set of nodes in one dimension where data is known.\nTo create higher dimension interpolation and differentiation operators, structured grids in two and three\ndimensions are created by tensor products of the controlPoints. This design decision implies that all\nspectral element methods supported by the Lagrange class have the same polynomial degree in each\ncomputational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto,\nLegendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over\nthe domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of\nthese quadrature types or uniform points on [-1,1]. type( hfReal_r2 ), public :: dMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The\ndMatrix is based on a strong form of the derivative. type( hfReal_r2 ), public :: dgMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based\non a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. type( hfReal_r2 ), public :: iMatrix The interpolation matrix (transpose) for mapping data from the control grid to the target grid. type( hfReal_r1 ), public :: qWeights The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints\nprovided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss,\nChebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant . integer, public :: targetNodeType type( hfReal_r1 ), public :: targetPoints The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation\nand differentiation operators, structured grids in two and three dimensions are created by tensor products of\nthe targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1]\n(computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. Type-Bound Procedures procedure, private :: CalculateBarycentricWeights procedure, private :: CalculateDerivativeMatrix procedure, private :: CalculateInterpolationMatrix procedure, private :: CalculateLagrangePolynomials generic, public :: DGDerivative_1D => DGDerivative_1D_cpu, DGDerivative_1D_gpu procedure, private :: DGDerivative_1D_cpu procedure, private :: DGDerivative_1D_gpu generic, public :: Derivative_1D => Derivative_1D_cpu, Derivative_1D_gpu procedure, private :: Derivative_1D_cpu procedure, private :: Derivative_1D_gpu procedure, public :: Free => Free_Lagrange procedure, public :: Init => Init_Lagrange generic, public :: ScalarBoundaryInterp_1D => ScalarBoundaryInterp_1D_cpu, ScalarBoundaryInterp_1D_gpu procedure, private :: ScalarBoundaryInterp_1D_cpu procedure, private :: ScalarBoundaryInterp_1D_gpu generic, public :: ScalarBoundaryInterp_2D => ScalarBoundaryInterp_2D_cpu, ScalarBoundaryInterp_2D_gpu procedure, private :: ScalarBoundaryInterp_2D_cpu procedure, private :: ScalarBoundaryInterp_2D_gpu generic, public :: ScalarBoundaryInterp_3D => ScalarBoundaryInterp_3D_cpu, ScalarBoundaryInterp_3D_gpu procedure, private :: ScalarBoundaryInterp_3D_cpu procedure, private :: ScalarBoundaryInterp_3D_gpu generic, public :: ScalarGradient_2D => ScalarGradient_2D_cpu, ScalarGradient_2D_gpu procedure, private :: ScalarGradient_2D_cpu procedure, private :: ScalarGradient_2D_gpu generic, public :: ScalarGradient_3D => ScalarGradient_3D_cpu, ScalarGradient_3D_gpu procedure, private :: ScalarGradient_3D_cpu procedure, private :: ScalarGradient_3D_gpu generic, public :: ScalarGridInterp_1D => ScalarGridInterp_1D_cpu, ScalarGridInterp_1D_gpu procedure, private :: ScalarGridInterp_1D_cpu procedure, private :: ScalarGridInterp_1D_gpu generic, public :: ScalarGridInterp_2D => ScalarGridInterp_2D_cpu, ScalarGridInterp_2D_gpu procedure, private :: ScalarGridInterp_2D_cpu procedure, private :: ScalarGridInterp_2D_gpu generic, public :: ScalarGridInterp_3D => ScalarGridInterp_3D_cpu, ScalarGridInterp_3D_gpu procedure, private :: ScalarGridInterp_3D_cpu procedure, private :: ScalarGridInterp_3D_gpu generic, public :: TensorBoundaryInterp_2D => TensorBoundaryInterp_2D_cpu, TensorBoundaryInterp_2D_gpu procedure, private :: TensorBoundaryInterp_2D_cpu procedure, private :: TensorBoundaryInterp_2D_gpu generic, public :: TensorBoundaryInterp_3D => TensorBoundaryInterp_3D_cpu, TensorBoundaryInterp_3D_gpu procedure, private :: TensorBoundaryInterp_3D_cpu procedure, private :: TensorBoundaryInterp_3D_gpu procedure, public :: UpdateDevice => UpdateDevice_Lagrange procedure, public :: UpdateHost => UpdateHost_Lagrange generic, public :: VectorBoundaryInterp_2D => VectorBoundaryInterp_2D_cpu, VectorBoundaryInterp_2D_gpu procedure, private :: VectorBoundaryInterp_2D_cpu procedure, private :: VectorBoundaryInterp_2D_gpu generic, public :: VectorBoundaryInterp_3D => VectorBoundaryInterp_3D_cpu, VectorBoundaryInterp_3D_gpu procedure, private :: VectorBoundaryInterp_3D_cpu procedure, private :: VectorBoundaryInterp_3D_gpu generic, public :: VectorDGDivergence_2D => VectorDGDivergence_2D_cpu, VectorDGDivergence_2D_gpu procedure, private :: VectorDGDivergence_2D_cpu procedure, private :: VectorDGDivergence_2D_gpu generic, public :: VectorDGDivergence_3D => VectorDGDivergence_3D_cpu, VectorDGDivergence_3D_gpu procedure, private :: VectorDGDivergence_3D_cpu procedure, private :: VectorDGDivergence_3D_gpu generic, public :: VectorDivergence_2D => VectorDivergence_2D_cpu, VectorDivergence_2D_gpu procedure, private :: VectorDivergence_2D_cpu procedure, private :: VectorDivergence_2D_gpu generic, public :: VectorDivergence_3D => VectorDivergence_3D_cpu, VectorDivergence_3D_gpu procedure, private :: VectorDivergence_3D_cpu procedure, private :: VectorDivergence_3D_gpu generic, public :: VectorGradient_2D => VectorGradient_2D_cpu, VectorGradient_2D_gpu procedure, private :: VectorGradient_2D_cpu procedure, private :: VectorGradient_2D_gpu generic, public :: VectorGradient_3D => VectorGradient_3D_cpu, VectorGradient_3D_gpu procedure, private :: VectorGradient_3D_cpu procedure, private :: VectorGradient_3D_gpu generic, public :: VectorGridInterp_2D => VectorGridInterp_2D_cpu, VectorGridInterp_2D_gpu procedure, private :: VectorGridInterp_2D_cpu procedure, private :: VectorGridInterp_2D_gpu generic, public :: VectorGridInterp_3D => VectorGridInterp_3D_cpu, VectorGridInterp_3D_gpu procedure, private :: VectorGridInterp_3D_cpu procedure, private :: VectorGridInterp_3D_gpu procedure, public :: WriteHDF5 => WriteHDF5_Lagrange Functions public function CalculateLagrangePolynomials (myPoly, sE) result(lAtS) Arguments Type Intent Optional Attributes Name class( Lagrange ) :: myPoly real(kind=prec) :: sE Return Value real(kind=prec)(0:myPoly%N) Subroutines public subroutine CalculateBarycentricWeights (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly public subroutine CalculateDerivativeMatrix (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly public subroutine CalculateInterpolationMatrix (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly public subroutine DGDerivative_1D_cpu (myPoly, f, bf, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:nVariables,1:2,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine DGDerivative_1D_gpu (myPoly, f_dev, bf_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine Derivative_1D_cpu (myPoly, f, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine Derivative_1D_gpu (myPoly, f_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine Free_Lagrange (myPoly) Frees all memory (host and device) associated with an instance of the Lagrange class Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance public subroutine Init_Lagrange (myPoly, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange class\nOn output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(out) :: myPoly Lagrange class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) public subroutine ScalarBoundaryInterp_1D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:nVariables,1:2,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_1D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGridInterp_1D_cpu (myPoly, f, fInterp, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fInterp (0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine ScalarGridInterp_1D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_1D_gpu_wrapper\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine ScalarGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine ScalarGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_2D_gpu_wrapper\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine ScalarGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine UpdateDevice_Lagrange (myPoly) Copy the Lagrange attributes from the host (CPU) to the device (GPU) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance public subroutine UpdateHost_Lagrange (myPoly) Copy the Lagrange attributes from the device (GPU) to the host (CPU) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance public subroutine VectorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_2D_cpu (myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_2D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_3D_cpu (myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_3D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine VectorGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:VectorGridInterp_2D_gpu_wrapper\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine VectorGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine WriteHDF5_Lagrange (this, fileId) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId","tags":"","loc":"module/self_lagrange.html"},{"title":"SELF_Model – SELF","text":"Uses FEQParse SELF_Metadata SELF_Mesh SELF_HDF5 HDF5 SELF_SupportRoutines SELF_MappedData Contents Variables SELF_AB2 SELF_AB3 SELF_AB4 SELF_BC_NONORMALFLOW SELF_BC_NOSTRESS SELF_BC_PRESCRIBED SELF_BC_PRESCRIBED_STRESS SELF_BC_RADIATION SELF_EQUATION_LENGTH SELF_EULER SELF_FORMULATION_LENGTH SELF_INTEGRATOR_LENGTH SELF_RK2 SELF_RK3 SELF_RK4 rk2_a rk2_b rk2_g rk3_a rk3_b rk3_g rk4_a rk4_b rk4_g Interfaces CalculateTendency ReadModel ResizePrevSol SELF_timeIntegrator UpdateGAB UpdateGRK UpdateSolution WriteModel WriteTecplot Derived Types Model Functions GetBCFlagForChar Subroutines AdamsBashforth2_timeIntegrator AdamsBashforth3_timeIntegrator AdamsBashforth4_timeIntegrator CalculateEntropy_Model DisableGPUAccel_Model EnableGPUAccel_Model Euler_timeIntegrator Flux_Model ForwardStep_Model GetSimulationTime IncrementIOCounter LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreFlux_Model PreTendency_Model PrintType_Model ReportEntropy_Model RiemannSolver_Model SetBoundaryCondition_Model SetInitialConditions_Model SetSimulationTime SetTimeIntegrator_withChar SetTimeIntegrator_withInt Source_Model UpdateBoundary_Model Variables Type Visibility Attributes Name Initial integer, public, parameter :: SELF_AB2 = 201 integer, public, parameter :: SELF_AB3 = 301 integer, public, parameter :: SELF_AB4 = 401 integer, public, parameter :: SELF_BC_NONORMALFLOW = 102 integer, public, parameter :: SELF_BC_NOSTRESS = 201 integer, public, parameter :: SELF_BC_PRESCRIBED = 100 integer, public, parameter :: SELF_BC_PRESCRIBED_STRESS = 200 integer, public, parameter :: SELF_BC_RADIATION = 101 integer, public, parameter :: SELF_EQUATION_LENGTH = 500 integer, public, parameter :: SELF_EULER = 100 integer, public, parameter :: SELF_FORMULATION_LENGTH = 30 integer, public, parameter :: SELF_INTEGRATOR_LENGTH = 10 integer, public, parameter :: SELF_RK2 = 200 integer, public, parameter :: SELF_RK3 = 300 integer, public, parameter :: SELF_RK4 = 400 real(kind=prec), public, parameter :: rk2_a (1:2) = (/0.0_PREC, -0.5_PREC/) real(kind=prec), public, parameter :: rk2_b (1:2) = (/0.5_PREC, 0.5_PREC/) real(kind=prec), public, parameter :: rk2_g (1:2) = (/0.5_PREC, 1.0_PREC/) real(kind=prec), public, parameter :: rk3_a (1:3) = (/0.0_PREC, -5.0_PREC/9.0_PREC, -153.0_PREC/128.0_PREC/) real(kind=prec), public, parameter :: rk3_b (1:3) = (/0.0_PREC, 1.0_PREC/3.0_PREC, 3.0_PREC/4.0_PREC/) real(kind=prec), public, parameter :: rk3_g (1:3) = (/1.0_PREC/3.0_PREC, 15.0_PREC/16.0_PREC, 8.0_PREC/15.0_PREC/) real(kind=prec), public, parameter :: rk4_a (1:5) = (/0.0_PREC, -1.0_PREC, -1.0_PREC/3.0_PREC+2.0_PREC**(2.0_PREC/3.0_PREC)/6.0_PREC, -2.0_PREC**(1.0_PREC/3.0_PREC)-2.0_PREC**(2.0_PREC/3.0_PREC)-2.0_PREC, -1.0_PREC+2.0_PREC**(1.0_PREC/3.0_PREC)/) real(kind=prec), public, parameter :: rk4_b (1:5) = (/0.0_PREC, 2.0_PREC/3.0_PREC+2.0_PREC**(1.0_PREC/3.0_PREC)/3.0_PREC+2.0_PREC**(2.0_PREC/3.0_PREC)/6.0_PREC, 2.0_PREC/3.0_PREC+2.0_PREC**(1.0_PREC/3.0_PREC)/3.0_PREC+2.0_PREC**(2.0_PREC/3.0_PREC)/6.0_PREC, 1.0_PREC/3.0_PREC-2.0_PREC**(1.0_PREC/3.0_PREC)/3.0_PREC-2.0_PREC**(2.0_PREC/3.0_PREC)/6.0_PREC, 1.0_PREC/) real(kind=prec), public, parameter :: rk4_g (1:5) = (/2.0_PREC/3.0_PREC+2.0_PREC**(1.0_PREC/3.0_PREC)/3.0_PREC+2.0_PREC**(2.0_PREC/3.0_PREC)/6.0_PREC, -2.0_PREC**(2.0_PREC/3.0_PREC)/6.0_PREC+1.0_PREC/6.0_PREC, -1.0_PREC/3.0_PREC-2.0_PREC*2.0_PREC**(1.0_PREC/3.0_PREC)/3.0_PREC-2.0_PREC**(2.0_PREC/3.0_PREC)/3.0_PREC, 1.0_PREC/3.0_PREC-2.0_PREC**(1.0_PREC/3.0_PREC)/3.0_PREC-2.0_PREC**(2.0_PREC/3.0_PREC)/6.0_PREC, 1.0_PREC/3.0_PREC+2.0_PREC**(1.0_PREC/3.0_PREC)/6.0_PREC+2.0_PREC**(2.0_PREC/3.0_PREC)/12.0_PREC/) Interfaces interface public subroutine CalculateTendency(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this interface public subroutine ReadModel(this, filename) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: filename interface public subroutine ResizePrevSol(this, m) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m interface public subroutine SELF_timeIntegrator(this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn interface public subroutine UpdateGAB(this, m) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m interface public subroutine UpdateGRK(this, m) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m interface public subroutine UpdateSolution(this, dt) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt interface public subroutine WriteModel(this, filename) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in), optional :: filename interface public subroutine WriteTecplot(this, filename) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in), optional :: filename Derived Types type, public, ABSTRACT :: Model Components Type Visibility Attributes Name Initial type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy logical, public :: gpuAccel integer, public :: ioIterate = 0 real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator procedure, public :: AdamsBashforth3_timeIntegrator procedure, public :: AdamsBashforth4_timeIntegrator procedure, public :: CalculateEntropy => CalculateEntropy_Model procedure(CalculateTendency), public :: CalculateTendency procedure, public :: DisableGPUAccel => DisableGPUAccel_Model procedure, public :: EnableGPUAccel => EnableGPUAccel_Model procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => Flux_Model procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreFlux => PreFlux_Model procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure(ReadModel), public :: ReadModel procedure, public :: ReportEntropy => ReportEntropy_Model procedure(ResizePrevSol), public :: ResizePrevSol procedure, public :: RiemannSolver => RiemannSolver_Model procedure, public :: SetBoundaryCondition => SetBoundaryCondition_Model procedure, public :: SetInitialConditions => SetInitialConditions_Model procedure, public :: SetSimulationTime generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt, SetTimeIntegrator_withChar procedure, private :: SetTimeIntegrator_withChar procedure, private :: SetTimeIntegrator_withInt procedure, public :: SourceMethod => Source_Model procedure, public :: UpdateBoundary => UpdateBoundary_Model procedure(UpdateGAB), public :: UpdateGAB2 procedure(UpdateGAB), public :: UpdateGAB3 procedure(UpdateGAB), public :: UpdateGAB4 procedure(UpdateGRK), public :: UpdateGRK2 procedure(UpdateGRK), public :: UpdateGRK3 procedure(UpdateGRK), public :: UpdateGRK4 procedure(UpdateSolution), public :: UpdateSolution procedure(WriteModel), public :: WriteModel procedure(WriteTecplot), public :: WriteTecplot Functions public function GetBCFlagForChar (charFlag) result(intFlag) This method is used to return the integer flag from a char for boundary conditions Arguments Type Intent Optional Attributes Name character, intent(in) :: charFlag Return Value integer Subroutines public subroutine AdamsBashforth2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn public subroutine AdamsBashforth3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn public subroutine AdamsBashforth4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn public subroutine CalculateEntropy_Model (this) Base method for calculating entropy of a model\nWhen this method is not overridden, the entropy\nis simply set to 0.0. When you develop a model\nbuilt on top of this abstract class or one of its\nchildren, it is recommended that you define a\nconvex mathematical entropy function that is used\nas a measure of the model stability. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this public subroutine DisableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this public subroutine EnableGPUAccel_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn public subroutine Flux_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: tn real(kind=prec), intent(in), optional :: dt real(kind=prec), intent(in), optional :: ioInterval public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn public subroutine PreFlux_Model (this) PreFlux is a template routine that is used to house any additional calculations\nthat you want to execute just before the calculation of flux terms.\nThis default PreFlux simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this public subroutine RiemannSolver_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this public subroutine SetBoundaryCondition_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this public subroutine SetInitialConditions_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator public subroutine SetTimeIntegrator_withInt (this, integrator) Sets the time integrator method, using an integer flag Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: integrator public subroutine Source_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this public subroutine UpdateBoundary_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this","tags":"","loc":"module/self_model.html"},{"title":"SELF_Memory – SELF","text":"Uses SELF_HIP_enums iso_fortran_env SELF_HIP SELF_Constants iso_c_binding Contents Derived Types hfInt32_r1 hfInt32_r2 hfInt32_r3 hfInt32_r4 hfReal_r1 hfReal_r2 hfReal_r3 hfReal_r4 hfReal_r5 hfReal_r6 hfReal_r7 Functions GPUAvailable Subroutines Alloc_hfInt32_r1 Alloc_hfInt32_r2 Alloc_hfInt32_r3 Alloc_hfInt32_r4 Alloc_hfReal_r1 Alloc_hfReal_r2 Alloc_hfReal_r3 Alloc_hfReal_r4 Alloc_hfReal_r5 Alloc_hfReal_r6 Alloc_hfReal_r7 Free_hfInt32_r1 Free_hfInt32_r2 Free_hfInt32_r3 Free_hfInt32_r4 Free_hfReal_r1 Free_hfReal_r2 Free_hfReal_r3 Free_hfReal_r4 Free_hfReal_r5 Free_hfReal_r6 Free_hfReal_r7 UpdateDevice_hfInt32_r1 UpdateDevice_hfInt32_r2 UpdateDevice_hfInt32_r3 UpdateDevice_hfInt32_r4 UpdateDevice_hfReal_r1 UpdateDevice_hfReal_r2 UpdateDevice_hfReal_r3 UpdateDevice_hfReal_r4 UpdateDevice_hfReal_r5 UpdateDevice_hfReal_r6 UpdateDevice_hfReal_r7 UpdateHost_hfInt32_r1 UpdateHost_hfInt32_r2 UpdateHost_hfInt32_r3 UpdateHost_hfInt32_r4 UpdateHost_hfReal_r1 UpdateHost_hfReal_r2 UpdateHost_hfReal_r3 UpdateHost_hfReal_r4 UpdateHost_hfReal_r5 UpdateHost_hfReal_r6 UpdateHost_hfReal_r7 Derived Types type, public :: hfInt32_r1 Data type for storing one-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r1 procedure, public :: Free => Free_hfInt32_r1 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r1 procedure, public :: UpdateHost => UpdateHost_hfInt32_r1 type, public :: hfInt32_r2 Data type for storing two-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r2 procedure, public :: Free => Free_hfInt32_r2 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r2 procedure, public :: UpdateHost => UpdateHost_hfInt32_r2 type, public :: hfInt32_r3 Data type for storing three-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r3 procedure, public :: Free => Free_hfInt32_r3 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r3 procedure, public :: UpdateHost => UpdateHost_hfInt32_r3 type, public :: hfInt32_r4 Data type for storing four-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r4 procedure, public :: Free => Free_hfInt32_r4 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r4 procedure, public :: UpdateHost => UpdateHost_hfInt32_r4 type, public :: hfReal_r1 Data type for storing one-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r1 procedure, public :: Free => Free_hfReal_r1 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r1 procedure, public :: UpdateHost => UpdateHost_hfReal_r1 type, public :: hfReal_r2 Data type for storing two-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r2 procedure, public :: Free => Free_hfReal_r2 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r2 procedure, public :: UpdateHost => UpdateHost_hfReal_r2 type, public :: hfReal_r3 Data type for storing three-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r3 procedure, public :: Free => Free_hfReal_r3 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r3 procedure, public :: UpdateHost => UpdateHost_hfReal_r3 type, public :: hfReal_r4 Data type for storing four-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r4 procedure, public :: Free => Free_hfReal_r4 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r4 procedure, public :: UpdateHost => UpdateHost_hfReal_r4 type, public :: hfReal_r5 Data type for storing five-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r5 procedure, public :: Free => Free_hfReal_r5 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r5 procedure, public :: UpdateHost => UpdateHost_hfReal_r5 type, public :: hfReal_r6 Data type for storing one-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r6 procedure, public :: Free => Free_hfReal_r6 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r6 procedure, public :: UpdateHost => UpdateHost_hfReal_r6 type, public :: hfReal_r7 Data type for storing seven-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r7 procedure, public :: Free => Free_hfReal_r7 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r7 procedure, public :: UpdateHost => UpdateHost_hfReal_r7 Functions public function GPUAvailable () result(avail) Arguments None Return Value logical Subroutines public subroutine Alloc_hfInt32_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound public subroutine Alloc_hfInt32_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) public subroutine Alloc_hfInt32_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) public subroutine Alloc_hfInt32_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) public subroutine Alloc_hfReal_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound public subroutine Alloc_hfReal_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) public subroutine Alloc_hfReal_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) public subroutine Alloc_hfReal_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) public subroutine Alloc_hfReal_r5 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) public subroutine Alloc_hfReal_r6 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) public subroutine Alloc_hfReal_r7 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) public subroutine Free_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this public subroutine Free_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this public subroutine Free_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this public subroutine Free_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this public subroutine Free_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this public subroutine Free_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this public subroutine Free_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this public subroutine Free_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this public subroutine Free_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this public subroutine Free_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this public subroutine Free_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this","tags":"","loc":"module/self_memory.html"},{"title":"SELF_Geometry – SELF","text":"Uses SELF_Data SELF_Mesh SELF_SupportRoutines SELF_Constants SELF_Lagrange Contents Interfaces AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper CalculateContravariantBasis_SEMHex_gpu_wrapper CalculateContravariantBasis_SEMQuad_gpu_wrapper Derived Types Geometry1D SEMGeometry SEMHex SEMQuad Functions CovariantArcMin_SEMQuad Subroutines CalculateContravariantBasis_SEMHex CalculateContravariantBasis_SEMQuad CalculateMetricTerms_Geometry1D CalculateMetricTerms_SEMHex CalculateMetricTerms_SEMQuad CheckSides_SEMHex Free_Geometry1D Free_SEMHex Free_SEMQuad GenerateFromMesh_Geometry1D GenerateFromMesh_SEMHex GenerateFromMesh_SEMQuad Init_Geometry1D Init_SEMHex Init_SEMQuad UpdateDevice_Geometry1D UpdateDevice_SEMHex UpdateDevice_SEMQuad UpdateHost_Geometry1D UpdateHost_SEMHex UpdateHost_SEMQuad Write_Geometry1D Interfaces interface public subroutine AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper(dsdx, J, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dsdx type(c_ptr) :: J integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl interface public subroutine AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper(dsdx, J, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dsdx type(c_ptr) :: J integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl interface public subroutine CalculateContravariantBasis_SEMHex_gpu_wrapper(dxds, dsdx, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dxds type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl interface public subroutine CalculateContravariantBasis_SEMQuad_gpu_wrapper(dxds, dsdx, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dxds type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl Derived Types type, public, extends( SEMGeometry ) :: Geometry1D Components Type Visibility Attributes Name Initial type( Scalar1D ), public :: dxds integer, public :: nElem type( Scalar1D ), public :: x Type-Bound Procedures procedure, public :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D procedure, public :: Free => Free_Geometry1D procedure, public :: GenerateFromMesh => GenerateFromMesh_Geometry1D procedure, public :: Init => Init_Geometry1D procedure, public :: UpdateDevice => UpdateDevice_Geometry1D procedure, public :: UpdateHost => UpdateHost_Geometry1D procedure, public :: Write => Write_Geometry1D type, public :: SEMGeometry Components Type Visibility Attributes Name Initial integer, public :: nElem type, public, extends( SEMGeometry ) :: SEMHex Components Type Visibility Attributes Name Initial type( Scalar3D ), public :: J type( Tensor3D ), public :: dsdx type( Tensor3D ), public :: dxds integer, public :: nElem type( Vector3D ), public :: nHat type( Scalar3D ), public :: nScale type( Vector3D ), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMHex procedure, private :: CheckSides => CheckSides_SEMHex procedure, public :: Free => Free_SEMHex procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMHex procedure, public :: Init => Init_SEMHex procedure, public :: UpdateDevice => UpdateDevice_SEMHex procedure, public :: UpdateHost => UpdateHost_SEMHex type, public, extends( SEMGeometry ) :: SEMQuad Components Type Visibility Attributes Name Initial type( Scalar2D ), public :: J type( Tensor2D ), public :: dsdx type( Tensor2D ), public :: dxds integer, public :: nElem type( Vector2D ), public :: nHat type( Scalar2D ), public :: nScale type( Vector2D ), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad procedure, public :: CovariantArcMin => CovariantArcMin_SEMQuad procedure, public :: Free => Free_SEMQuad procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMQuad procedure, public :: Init => Init_SEMQuad procedure, public :: UpdateDevice => UpdateDevice_SEMQuad procedure, public :: UpdateHost => UpdateHost_SEMQuad Functions public function CovariantArcMin_SEMQuad (myGeom) result(dxMin) Arguments Type Intent Optional Attributes Name class( SEMQuad ) :: myGeom Return Value real(kind=prec) Subroutines public subroutine CalculateContravariantBasis_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine CalculateContravariantBasis_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine CalculateMetricTerms_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom public subroutine CalculateMetricTerms_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine CalculateMetricTerms_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine CheckSides_SEMHex (myGeom, mesh) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(in) :: myGeom type( Mesh3D ), intent(in) :: mesh public subroutine Free_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom public subroutine Free_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine Free_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine GenerateFromMesh_Geometry1D (myGeom, mesh) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom type( Mesh1D ), intent(in) :: mesh public subroutine GenerateFromMesh_SEMHex (myGeom, mesh) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom type( Mesh3D ), intent(in) :: mesh public subroutine GenerateFromMesh_SEMQuad (myGeom, mesh) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom type( Mesh2D ), intent(in) :: mesh public subroutine Init_Geometry1D (myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom type( Lagrange ), intent(in), POINTER :: interp integer, intent(in) :: nElem public subroutine Init_SEMHex (myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom type( Lagrange ), intent(in), POINTER :: interp integer, intent(in) :: nElem public subroutine Init_SEMQuad (myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom type( Lagrange ), intent(in), POINTER :: interp integer, intent(in) :: nElem public subroutine UpdateDevice_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom public subroutine UpdateDevice_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine UpdateDevice_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine UpdateHost_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom public subroutine UpdateHost_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine UpdateHost_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine Write_Geometry1D (myGeom, fileName) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(in) :: myGeom character, intent(in), optional :: fileName","tags":"","loc":"module/self_geometry.html"},{"title":"SELF_MappedData – SELF","text":"Uses FEQParse SELF_Data SELF_HDF5 iso_c_binding SELF_Mesh HDF5 SELF_Constants SELF_Geometry SELF_Lagrange Contents Interfaces ApplyFlip_MappedScalar2D_gpu_wrapper ApplyFlip_MappedScalar3D_gpu_wrapper ApplyFlip_MappedVector2D_gpu_wrapper ApplyFlip_MappedVector3D_gpu_wrapper BassiRebaySides_MappedScalar2D_gpu_wrapper BassiRebaySides_MappedScalar3D_gpu_wrapper BassiRebaySides_MappedVector2D_gpu_wrapper BassiRebaySides_MappedVector3D_gpu_wrapper ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper ContravariantProjection_MappedVector2D_gpu_wrapper ContravariantProjection_MappedVector3D_gpu_wrapper GradientBR_MappedScalar2D_gpu_wrapper GradientBR_MappedScalar3D_gpu_wrapper GradientSF_MappedScalar2D_gpu_wrapper GradientSF_MappedScalar3D_gpu_wrapper JacobianWeight_MappedScalar1D_gpu_wrapper JacobianWeight_MappedScalar2D_gpu_wrapper JacobianWeight_MappedScalar3D_gpu_wrapper JacobianWeight_MappedVector2D_gpu_wrapper JacobianWeight_MappedVector3D_gpu_wrapper SideExchange_MappedScalar2D_gpu_wrapper SideExchange_MappedScalar3D_gpu_wrapper SideExchange_MappedVector2D_gpu_wrapper SideExchange_MappedVector3D_gpu_wrapper Derived Types MappedScalar1D MappedScalar2D MappedScalar3D MappedVector2D MappedVector3D Functions Integral_MappedScalar2D Subroutines ApplyFlip_MappedScalar2D ApplyFlip_MappedScalar3D ApplyFlip_MappedVector2D ApplyFlip_MappedVector3D BassiRebaySides_MappedScalar1D BassiRebaySides_MappedScalar2D BassiRebaySides_MappedScalar3D BassiRebaySides_MappedVector2D BassiRebaySides_MappedVector3D ContravariantProjection_MappedVector2D ContravariantProjection_MappedVector3D Derivative_MappedScalar1D Divergence_MappedVector2D Divergence_MappedVector3D GradientBR_MappedScalar2D GradientBR_MappedScalar3D GradientSF_MappedScalar2D GradientSF_MappedScalar3D Gradient_MappedScalar2D Gradient_MappedScalar3D JacobianWeight_MappedScalar1D JacobianWeight_MappedScalar2D JacobianWeight_MappedScalar3D JacobianWeight_MappedVector2D JacobianWeight_MappedVector3D MPIExchangeAsync_MappedScalar2D MPIExchangeAsync_MappedScalar3D MPIExchangeAsync_MappedVector2D MPIExchangeAsync_MappedVector3D SetInteriorFromEquation_MappedScalar1D SetInteriorFromEquation_MappedScalar2D SetInteriorFromEquation_MappedScalar3D SetInteriorFromEquation_MappedVector2D SetInteriorFromEquation_MappedVector3D SideExchange_MappedScalar1D SideExchange_MappedScalar2D SideExchange_MappedScalar3D SideExchange_MappedVector2D SideExchange_MappedVector3D Interfaces interface public subroutine ApplyFlip_MappedScalar2D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ApplyFlip_MappedScalar3D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ApplyFlip_MappedVector2D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ApplyFlip_MappedVector3D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine BassiRebaySides_MappedScalar2D_gpu_wrapper(avgBoundary, boundary, extBoundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: avgBoundary type(c_ptr) :: boundary type(c_ptr) :: extBoundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine BassiRebaySides_MappedScalar3D_gpu_wrapper(avgBoundary, boundary, extBoundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: avgBoundary type(c_ptr) :: boundary type(c_ptr) :: extBoundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine BassiRebaySides_MappedVector2D_gpu_wrapper(extBoundary, boundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine BassiRebaySides_MappedVector3D_gpu_wrapper(extBoundary, boundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ContravariantProjection_MappedVector2D_gpu_wrapper(vector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ContravariantProjection_MappedVector3D_gpu_wrapper(vector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine GradientBR_MappedScalar2D_gpu_wrapper(scalar, avgBoundary, dsdx, jacobian, nHat, nScale, gradF, dgMatrix, bMatrix, qWeights, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: avgBoundary type(c_ptr) :: dsdx type(c_ptr) :: jacobian type(c_ptr) :: nHat type(c_ptr) :: nScale type(c_ptr) :: gradF type(c_ptr) :: dgMatrix type(c_ptr) :: bMatrix type(c_ptr) :: qWeights integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine GradientBR_MappedScalar3D_gpu_wrapper(scalar, avgBoundary, dsdx, jacobian, nHat, nScale, gradF, dgMatrix, bMatrix, qWeights, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: avgBoundary type(c_ptr) :: dsdx type(c_ptr) :: jacobian type(c_ptr) :: nHat type(c_ptr) :: nScale type(c_ptr) :: gradF type(c_ptr) :: dgMatrix type(c_ptr) :: bMatrix type(c_ptr) :: qWeights integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine GradientSF_MappedScalar2D_gpu_wrapper(scalar, dsdx, jacobian, gradF, dMatrix, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: dsdx type(c_ptr) :: jacobian type(c_ptr) :: gradF type(c_ptr) :: dMatrix integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine GradientSF_MappedScalar3D_gpu_wrapper(scalar, dsdx, jacobian, gradF, dMatrix, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: dsdx type(c_ptr) :: jacobian type(c_ptr) :: gradF type(c_ptr) :: dMatrix integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine JacobianWeight_MappedScalar1D_gpu_wrapper(scalar, dxds, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: dxds integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine JacobianWeight_MappedScalar2D_gpu_wrapper(scalar, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine JacobianWeight_MappedScalar3D_gpu_wrapper(scalar, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine JacobianWeight_MappedVector2D_gpu_wrapper(vector, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine JacobianWeight_MappedVector3D_gpu_wrapper(vector, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine SideExchange_MappedScalar2D_gpu_wrapper(extBoundary, boundary, sideInfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: offset integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine SideExchange_MappedScalar3D_gpu_wrapper(extBoundary, boundary, sideInfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: offset integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine SideExchange_MappedVector2D_gpu_wrapper(extBoundary, boundary, sideInfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: offset integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine SideExchange_MappedVector3D_gpu_wrapper(extBoundary, boundary, sideInfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: offset integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl Derived Types type, public, extends( Scalar1D ) :: MappedScalar1D Components Type Visibility Attributes Name Initial type( hfReal_r3 ), public :: avgBoundary type( hfReal_r3 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r3 ), public :: extBoundary type( hfReal_r3 ), public :: interior type( Lagrange ), public, POINTER :: interp type( hfReal_r3 ), public :: jumpBoundary type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BassiRebaySides => BassiRebaySides_MappedScalar1D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D generic, public :: Derivative => Derivative_Scalar1D, Derivative_MappedScalar1D procedure, private :: Derivative_MappedScalar1D procedure, public :: Free => Free_Scalar1D procedure, public :: GridInterp => GridInterp_Scalar1D procedure, public :: Init => Init_Scalar1D procedure, public :: JacobianWeight => JacobianWeight_MappedScalar1D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar1D procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedScalar1D procedure, public :: UpdateDevice => UpdateDevice_Scalar1D procedure, public :: UpdateHost => UpdateHost_Scalar1D generic, public :: WriteHDF5 => WriteHDF5_Scalar1D, WriteHDF5_MPI_Scalar1D type, public, extends( Scalar2D ) :: MappedScalar2D Components Type Visibility Attributes Name Initial type( hfReal_r4 ), public :: avgBoundary type( hfReal_r4 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r4 ), public :: extBoundary type( hfReal_r4 ), public :: interior type( Lagrange ), public, POINTER :: interp type( hfReal_r4 ), public :: jumpBoundary type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedScalar2D procedure, public :: BassiRebaySides => BassiRebaySides_MappedScalar2D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D procedure, public :: Free => Free_Scalar2D generic, public :: Gradient => Gradient_Scalar2D, Gradient_MappedScalar2D procedure, private :: GradientBR_MappedScalar2D procedure, private :: GradientSF_MappedScalar2D procedure, private :: Gradient_MappedScalar2D procedure, public :: GridInterp => GridInterp_Scalar2D procedure, public :: Init => Init_Scalar2D procedure, public :: Integral => Integral_MappedScalar2D procedure, public :: JacobianWeight => JacobianWeight_MappedScalar2D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar2D procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedScalar2D procedure, public :: UpdateDevice => UpdateDevice_Scalar2D procedure, public :: UpdateHost => UpdateHost_Scalar2D generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D, WriteHDF5_Scalar2D type, public, extends( Scalar3D ) :: MappedScalar3D Components Type Visibility Attributes Name Initial type( hfReal_r5 ), public :: avgBoundary type( hfReal_r5 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r5 ), public :: extBoundary type( hfReal_r5 ), public :: interior type( Lagrange ), public, POINTER :: interp type( hfReal_r5 ), public :: jumpBoundary type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedScalar3D procedure, public :: BassiRebaySides => BassiRebaySides_MappedScalar3D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D procedure, public :: Free => Free_Scalar3D generic, public :: Gradient => Gradient_Scalar3D, Gradient_MappedScalar3D procedure, private :: GradientBR_MappedScalar3D procedure, private :: GradientSF_MappedScalar3D procedure, private :: Gradient_MappedScalar3D procedure, public :: GridInterp => GridInterp_Scalar3D procedure, public :: Init => Init_Scalar3D procedure, public :: JacobianWeight => JacobianWeight_MappedScalar3D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar3D procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedScalar3D procedure, public :: UpdateDevice => UpdateDevice_Scalar3D procedure, public :: UpdateHost => UpdateHost_Scalar3D generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D, WriteHDF5_Scalar3D type, public, extends( Vector2D ) :: MappedVector2D Components Type Visibility Attributes Name Initial type( hfReal_r5 ), public :: boundary type( hfReal_r4 ), public :: boundaryNormal type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r5 ), public :: extBoundary type( hfReal_r5 ), public :: interior type( Lagrange ), public, POINTER :: interp type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedVector2D procedure, public :: BassiRebaySides => BassiRebaySides_MappedVector2D procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D procedure, public :: ContravariantProjection => ContravariantProjection_MappedVector2D generic, public :: Divergence => Divergence_Vector2D, Divergence_MappedVector2D procedure, private :: Divergence_MappedVector2D procedure, public :: Free => Free_Vector2D generic, public :: Gradient => Gradient_Vector2D procedure, public :: GridInterp => GridInterp_Vector2D procedure, public :: Init => Init_Vector2D procedure, public :: JacobianWeight => JacobianWeight_MappedVector2D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector2D procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector2D procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedVector2D procedure, public :: UpdateDevice => UpdateDevice_Vector2D procedure, public :: UpdateHost => UpdateHost_Vector2D generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D, WriteHDF5_Vector2D type, public, extends( Vector3D ) :: MappedVector3D Components Type Visibility Attributes Name Initial type( hfReal_r6 ), public :: boundary type( hfReal_r5 ), public :: boundaryNormal type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r6 ), public :: extBoundary type( hfReal_r6 ), public :: interior type( Lagrange ), public, POINTER :: interp type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedVector3D procedure, public :: BassiRebaySides => BassiRebaySides_MappedVector3D procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D procedure, public :: ContravariantProjection => ContravariantProjection_MappedVector3D generic, public :: Divergence => Divergence_Vector3D, Divergence_MappedVector3D procedure, private :: Divergence_MappedVector3D procedure, public :: Free => Free_Vector3D generic, public :: Gradient => Gradient_Vector3D procedure, public :: GridInterp => GridInterp_Vector3D procedure, public :: Init => Init_Vector3D procedure, public :: JacobianWeight => JacobianWeight_MappedVector3D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector3D procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector3D procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedVector3D procedure, public :: UpdateDevice => UpdateDevice_Vector3D procedure, public :: UpdateHost => UpdateHost_Vector3D generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D, WriteHDF5_Vector3D Functions public function Integral_MappedScalar2D (this, geometry, decomp, gpuAccel) result(fRes) Calculates the area integral the scalar over all of the geometry.\nGlobal reduction is done across all MPI ranks when the domain\ndecomposition indicates MPI is enabled. Arguments Type Intent Optional Attributes Name class( MappedScalar2D ) :: this type( SEMQuad ) :: geometry type( MPILayer ) :: decomp logical :: gpuAccel Return Value real(kind=prec) Subroutines public subroutine ApplyFlip_MappedScalar2D (scalar, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( MPILayer ), intent(inout) :: mpiHandler type( Mesh2D ), intent(in) :: mesh logical, intent(in) :: gpuAccel public subroutine ApplyFlip_MappedScalar3D (scalar, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( MPILayer ), intent(inout) :: mpiHandler type( Mesh3D ), intent(in) :: mesh logical, intent(in) :: gpuAccel public subroutine ApplyFlip_MappedVector2D (vector, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( MPILayer ), intent(inout) :: mpiHandler type( Mesh2D ), intent(in) :: mesh logical, intent(in) :: gpuAccel public subroutine ApplyFlip_MappedVector3D (vector, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( MPILayer ), intent(inout) :: mpiHandler type( Mesh3D ), intent(in) :: mesh logical, intent(in) :: gpuAccel public subroutine BassiRebaySides_MappedScalar1D (scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel public subroutine BassiRebaySides_MappedScalar2D (scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel public subroutine BassiRebaySides_MappedScalar3D (scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel public subroutine BassiRebaySides_MappedVector2D (vector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector logical, intent(in) :: gpuAccel public subroutine BassiRebaySides_MappedVector3D (vector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector logical, intent(in) :: gpuAccel public subroutine ContravariantProjection_MappedVector2D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( SEMQuad ), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine ContravariantProjection_MappedVector3D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( SEMHex ), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine Derivative_MappedScalar1D (scalar, geometry, dF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: scalar type( Geometry1D ), intent(in) :: geometry type( MappedScalar1D ), intent(inout) :: dF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Divergence_MappedVector2D (compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: compVector type( SEMQuad ), intent(in) :: geometry type( MappedScalar2D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Divergence_MappedVector3D (compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: compVector type( SEMHex ), intent(in) :: geometry type( MappedScalar3D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine GradientBR_MappedScalar2D (scalar, geometry, gradF, gpuAccel) Calculates the gradient of a scalar 2D function using a bassi-rebay method Read more… Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( SEMQuad ), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF logical, intent(in) :: gpuAccel public subroutine GradientBR_MappedScalar3D (scalar, geometry, gradF, gpuAccel) Calculates the gradient of a scalar 3D function using a bassi-rebay method Read more… Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( SEMHex ), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF logical, intent(in) :: gpuAccel public subroutine GradientSF_MappedScalar2D (scalar, geometry, gradF, gpuAccel) Calculates the gradient of a scalar 2D function using the conservative form of the\nmapped gradient operator Read more… Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type( SEMQuad ), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF logical, intent(in) :: gpuAccel public subroutine GradientSF_MappedScalar3D (scalar, geometry, gradF, gpuAccel) Calculates the gradient of a scalar 3D function using the conservative form of the\nmapped gradient operator Read more… Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type( SEMHex ), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF logical, intent(in) :: gpuAccel public subroutine Gradient_MappedScalar2D (scalar, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( SEMQuad ), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Gradient_MappedScalar3D (scalar, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( SEMHex ), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedScalar1D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar type( Geometry1D ), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedScalar2D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( SEMQuad ), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedScalar3D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( SEMHex ), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedVector2D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( SEMQuad ), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedVector3D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( SEMHex ), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine MPIExchangeAsync_MappedScalar2D (scalar, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( MPILayer ), intent(inout) :: mpiHandler type( Mesh2D ), intent(in) :: mesh logical, intent(in) :: resetCount public subroutine MPIExchangeAsync_MappedScalar3D (scalar, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( MPILayer ), intent(inout) :: mpiHandler type( Mesh3D ), intent(in) :: mesh logical, intent(in) :: resetCount public subroutine MPIExchangeAsync_MappedVector2D (vector, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( MPILayer ), intent(inout) :: mpiHandler type( Mesh2D ), intent(in) :: mesh logical, intent(in) :: resetCount public subroutine MPIExchangeAsync_MappedVector3D (vector, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( MPILayer ), intent(inout) :: mpiHandler type( Mesh3D ), intent(in) :: mesh logical, intent(in) :: resetCount public subroutine SetInteriorFromEquation_MappedScalar1D (scalar, geometry, time) Sets the scalar % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar type( Geometry1D ), intent(in) :: geometry real(kind=prec), intent(in) :: time public subroutine SetInteriorFromEquation_MappedScalar2D (scalar, geometry, time) Sets the scalar % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time public subroutine SetInteriorFromEquation_MappedScalar3D (scalar, geometry, time) Sets the scalar % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time public subroutine SetInteriorFromEquation_MappedVector2D (vector, geometry, time) Sets the scalar % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time public subroutine SetInteriorFromEquation_MappedVector3D (vector, geometry, time) Sets the scalar % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time public subroutine SideExchange_MappedScalar1D (scalar, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar type( Mesh1D ), intent(in) :: mesh type( MPILayer ), intent(inout) :: decomp logical, intent(in) :: gpuAccel public subroutine SideExchange_MappedScalar2D (scalar, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type( Mesh2D ), intent(in) :: mesh type( MPILayer ), intent(inout) :: decomp logical, intent(in) :: gpuAccel public subroutine SideExchange_MappedScalar3D (scalar, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type( Mesh3D ), intent(in) :: mesh type( MPILayer ), intent(inout) :: decomp logical, intent(in) :: gpuAccel public subroutine SideExchange_MappedVector2D (vector, mesh, decomp, gpuAccel) SideExchange_MappedVectorvector2D is used to populate vector % extBoundary\nby finding neighboring elements that share a side and copying the neighboring\nelements solution % boundary data. Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type( Mesh2D ), intent(in) :: mesh type( MPILayer ), intent(inout) :: decomp logical, intent(in) :: gpuAccel public subroutine SideExchange_MappedVector3D (vector, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type( Mesh3D ), intent(in) :: mesh type( MPILayer ), intent(inout) :: decomp logical, intent(in) :: gpuAccel","tags":"","loc":"module/self_mappeddata.html"},{"title":"SELF_Metadata – SELF","text":"Uses SELF_HDF5 HDF5 Contents Variables SELF_MTD_DescriptionLength SELF_MTD_NameLength SELF_MTD_UnitsLength Derived Types Metadata Subroutines SetDescription_Metadata SetName_Metadata SetUnits_Metadata WriteHDF5_Metadata Variables Type Visibility Attributes Name Initial integer, public, parameter :: SELF_MTD_DescriptionLength = 1000 integer, public, parameter :: SELF_MTD_NameLength = 250 integer, public, parameter :: SELF_MTD_UnitsLength = 20 Derived Types type, public :: Metadata Components Type Visibility Attributes Name Initial character, public :: description character, public :: name character, public :: units Type-Bound Procedures procedure, public :: SetDescription => SetDescription_Metadata procedure, public :: SetName => SetName_Metadata procedure, public :: SetUnits => SetUnits_Metadata procedure, public :: WriteHDF5 => WriteHDF5_Metadata Subroutines public subroutine SetDescription_Metadata (mtd, description) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: description public subroutine SetName_Metadata (mtd, name) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: name public subroutine SetUnits_Metadata (mtd, units) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: units public subroutine WriteHDF5_Metadata (mtd, group, varid, fileId) Writes the metadata to a HDF5 file using the \nfields :\n * /metadata/{group}/name/{varid} * /metadata/{group}/description/{varid} * /metadata/{group}/units/{varid} Read more… Arguments Type Intent Optional Attributes Name class( Metadata ), intent(in) :: mtd character, intent(in) :: group integer, intent(in) :: varid integer(kind=HID_T), intent(in) :: fileId","tags":"","loc":"module/self_metadata.html"},{"title":"SELF_Model1D – SELF","text":"Uses FEQParse SELF_Metadata SELF_Mesh SELF_HDF5 HDF5 SELF_Model SELF_SupportRoutines SELF_MappedData Contents Interfaces CalculateDSDt_Model1D_gpu_wrapper UpdateGAB2_Model1D_gpu_wrapper UpdateGAB3_Model1D_gpu_wrapper UpdateGAB4_Model1D_gpu_wrapper UpdateGRK_Model1D_gpu_wrapper UpdateSolution_Model1D_gpu_wrapper Derived Types Model1D Subroutines CalculateFluxDivergence_Model1D CalculateTendency_Model1D Free_Model1D Init_Model1D Read_Model1D ResizePrevSol_Model1D SetSolutionFromChar_Model1D SetSolutionFromEqn_Model1D UpdateDevice_Model1D UpdateGAB2_Model1D UpdateGAB3_Model1D UpdateGAB4_Model1D UpdateGRK2_Model1D UpdateGRK3_Model1D UpdateGRK4_Model1D UpdateHost_Model1D UpdateSolution_Model1D WriteTecplot_Model1D Write_Model1D Interfaces interface public subroutine CalculateDSDt_Model1D_gpu_wrapper(fluxDivergence, source, dSdt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: fluxDivergence type(C_PTR) :: source type(C_PTR) :: dSdt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateGAB2_Model1D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateGAB3_Model1D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateGAB4_Model1D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateGRK_Model1D_gpu_wrapper(grk, solution, dSdt, rk_a, rk_g, dt, nWork, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: grk type(C_PTR) :: solution type(C_PTR) :: dSdt real(kind=c_prec), VALUE :: rk_a real(kind=c_prec), VALUE :: rk_g real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: nWork integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateSolution_Model1D_gpu_wrapper(solution, dSdt, dt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: solution type(C_PTR) :: dSdt real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl Derived Types type, public, extends( Model ) :: Model1D Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, POINTER :: geometry logical, public :: gpuAccel integer, public :: ioIterate = 0 type( Mesh1D ), public, POINTER :: mesh type( MappedScalar1D ), public :: prevSol type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: velocity type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator procedure, public :: AdamsBashforth3_timeIntegrator procedure, public :: AdamsBashforth4_timeIntegrator procedure, public :: CalculateEntropy => CalculateEntropy_Model procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_Model1D procedure, public :: CalculateTendency => CalculateTendency_Model1D procedure, public :: DisableGPUAccel => DisableGPUAccel_Model procedure, public :: EnableGPUAccel => EnableGPUAccel_Model procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => Flux_Model procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_Model1D procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_Model1D procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreFlux => PreFlux_Model procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_Model1D procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: ResizePrevSol => ResizePrevSol_Model1D procedure, public :: RiemannSolver => RiemannSolver_Model procedure, public :: SetBoundaryCondition => SetBoundaryCondition_Model procedure, public :: SetInitialConditions => SetInitialConditions_Model procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_Model1D, SetSolutionFromEqn_Model1D procedure, private :: SetSolutionFromChar_Model1D procedure, private :: SetSolutionFromEqn_Model1D generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt, SetTimeIntegrator_withChar procedure, public :: SourceMethod => Source_Model procedure, public :: UpdateBoundary => UpdateBoundary_Model procedure, public :: UpdateDevice => UpdateDevice_Model1D procedure, public :: UpdateGAB2 => UpdateGAB2_Model1D procedure, public :: UpdateGAB3 => UpdateGAB3_Model1D procedure, public :: UpdateGAB4 => UpdateGAB4_Model1D procedure, public :: UpdateGRK2 => UpdateGRK2_Model1D procedure, public :: UpdateGRK3 => UpdateGRK3_Model1D procedure, public :: UpdateGRK4 => UpdateGRK4_Model1D procedure, public :: UpdateHost => UpdateHost_Model1D procedure, public :: UpdateSolution => UpdateSolution_Model1D procedure, public :: WriteModel => Write_Model1D procedure, public :: WriteTecplot => WriteTecplot_Model1D Subroutines public subroutine CalculateFluxDivergence_Model1D (this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this public subroutine CalculateTendency_Model1D (this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this public subroutine Free_Model1D (this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this public subroutine Init_Model1D (this, nvar, mesh, geometry, decomp) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), TARGET :: mesh type( Geometry1D ), intent(in), TARGET :: geometry type( MPILayer ), intent(in), TARGET :: decomp public subroutine Read_Model1D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character, intent(in) :: fileName public subroutine ResizePrevSol_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m public subroutine SetSolutionFromChar_Model1D (this, eqnChar) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_Model1D (this, eqn) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) public subroutine UpdateDevice_Model1D (this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this public subroutine UpdateGAB2_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGAB3_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGAB4_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK2_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK3_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK4_Model1D (this, m) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateHost_Model1D (this) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this public subroutine UpdateSolution_Model1D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt public subroutine WriteTecplot_Model1D (this, filename) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character, intent(in), optional :: filename public subroutine Write_Model1D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model1D ), intent(inout) :: this character, intent(in), optional :: fileName","tags":"","loc":"module/self_model1d.html"},{"title":"SELF_HDF5 – SELF","text":"Uses iso_fortran_env SELF_Memory SELF_Constants HDF5 Contents Interfaces Open_HDF5 ReadArray_HDF5 ReadAttribute_HDF5 WriteArray_HDF5 WriteAttribute_HDF5 WriteCharacter_HDF5 Subroutines Close_HDF5 CreateGroup_HDF5 Open_HDF5_parallel Open_HDF5_serial ReadArray_HDF5_int32_r1_parallel ReadArray_HDF5_int32_r1_serial ReadArray_HDF5_int32_r2_parallel ReadArray_HDF5_int32_r2_serial ReadArray_HDF5_real_r1_parallel ReadArray_HDF5_real_r1_serial ReadArray_HDF5_real_r2_parallel ReadArray_HDF5_real_r2_serial ReadArray_HDF5_real_r3_parallel ReadArray_HDF5_real_r3_serial ReadArray_HDF5_real_r4_parallel ReadArray_HDF5_real_r4_serial ReadArray_HDF5_real_r5_parallel ReadArray_HDF5_real_r5_serial ReadArray_HDF5_real_r6_parallel ReadArray_HDF5_real_r6_serial ReadAttribute_HDF5_character ReadAttribute_HDF5_int32 ReadAttribute_HDF5_real WriteArray_HDF5_int32_r1_parallel WriteArray_HDF5_int32_r1_serial WriteArray_HDF5_int32_r2_parallel WriteArray_HDF5_int32_r2_serial WriteArray_HDF5_int32_r3_parallel WriteArray_HDF5_int32_r3_serial WriteArray_HDF5_int32_r4_parallel WriteArray_HDF5_int32_r4_serial WriteArray_HDF5_real_r1_parallel WriteArray_HDF5_real_r1_serial WriteArray_HDF5_real_r2_parallel WriteArray_HDF5_real_r2_serial WriteArray_HDF5_real_r3_parallel WriteArray_HDF5_real_r3_serial WriteArray_HDF5_real_r4_parallel WriteArray_HDF5_real_r4_serial WriteArray_HDF5_real_r5_parallel WriteArray_HDF5_real_r5_serial WriteArray_HDF5_real_r6_parallel WriteArray_HDF5_real_r6_serial WriteAttribute_HDF5_int32 WriteCharacter_HDF5_serial Interfaces public interface Open_HDF5 private subroutine Open_HDF5_serial (fileName, accessFlag, fileId) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId private subroutine Open_HDF5_parallel (fileName, accessFlag, fileId, mpiComm) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId integer, intent(in) :: mpiComm public interface ReadArray_HDF5 private subroutine ReadArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_real_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) private subroutine ReadArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) private subroutine ReadArray_HDF5_real_r5_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) private subroutine ReadArray_HDF5_real_r6_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) private subroutine ReadArray_HDF5_int32_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_int32_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) public interface ReadAttribute_HDF5 private subroutine ReadAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(out) :: attribute private subroutine ReadAttribute_HDF5_real (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(out) :: attribute private subroutine ReadAttribute_HDF5_character (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(out) :: attribute public interface WriteArray_HDF5 private subroutine WriteArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r3 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r4 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r1_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) private subroutine WriteArray_HDF5_real_r2_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) private subroutine WriteArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) private subroutine WriteArray_HDF5_real_r5_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) private subroutine WriteArray_HDF5_real_r6_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) private subroutine WriteArray_HDF5_int32_r1_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) private subroutine WriteArray_HDF5_int32_r2_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) private subroutine WriteArray_HDF5_int32_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r3 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_int32_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r4 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) public interface WriteAttribute_HDF5 private subroutine WriteAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(in) :: attribute public interface WriteCharacter_HDF5 private subroutine WriteCharacter_HDF5_serial (fileId, name, hfField) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character(len=*), intent(in) :: name character(len=*), intent(in) :: hfField Subroutines public subroutine Close_HDF5 (fileId) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId public subroutine CreateGroup_HDF5 (fileId, groupName) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: groupName private subroutine Open_HDF5_parallel (fileName, accessFlag, fileId, mpiComm) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId integer, intent(in) :: mpiComm private subroutine Open_HDF5_serial (fileName, accessFlag, fileId) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId private subroutine ReadArray_HDF5_int32_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) private subroutine ReadArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) private subroutine ReadArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r5_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) private subroutine ReadArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r6_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) private subroutine ReadArray_HDF5_real_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(inout) :: hfArray private subroutine ReadAttribute_HDF5_character (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(out) :: attribute private subroutine ReadAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(out) :: attribute private subroutine ReadAttribute_HDF5_real (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(out) :: attribute private subroutine WriteArray_HDF5_int32_r1_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) private subroutine WriteArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r1 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r2_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) private subroutine WriteArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r2 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r3 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_int32_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r3 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r4 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) private subroutine WriteArray_HDF5_int32_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfInt32_r4 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r1_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) private subroutine WriteArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r1 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r2_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) private subroutine WriteArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r2 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r3 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) private subroutine WriteArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r4 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r5_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) private subroutine WriteArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r5 ), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r6_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) private subroutine WriteArray_HDF5_real_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type( hfReal_r6 ), intent(in) :: hfArray private subroutine WriteAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(in) :: attribute private subroutine WriteCharacter_HDF5_serial (fileId, name, hfField) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character(len=*), intent(in) :: name character(len=*), intent(in) :: hfField","tags":"","loc":"module/self_hdf5.html"},{"title":"self_advection_diffusion_2d – SELF","text":"Uses SELF_Mesh SELF_Model SELF_Model2D Contents Derived Types advection_diffusion_2d Subroutines fluxmethod_advection_diffusion_2d pretendency_advection_diffusion_2d riemannsolver_advection_diffusion_2d setboundarycondition_advection_diffusion_2d Derived Types type, public, extends( Model2D ) :: advection_diffusion_2d Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, POINTER :: geometry logical, public :: gpuAccel integer, public :: ioIterate = 0 type( Mesh2D ), public, POINTER :: mesh real(kind=prec), public :: nu type( MappedScalar2D ), public :: prevSol type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator procedure, public :: AdamsBashforth3_timeIntegrator procedure, public :: AdamsBashforth4_timeIntegrator procedure, public :: CalculateEntropy => CalculateEntropy_Model procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_Model2D procedure, public :: CalculateTendency => CalculateTendency_Model2D procedure, public :: DisableGPUAccel => DisableGPUAccel_Model procedure, public :: EnableGPUAccel => EnableGPUAccel_Model procedure, public :: Euler_timeIntegrator procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_Model2D procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_Model2D procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreFlux => PreFlux_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_Model2D procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: ReprojectFlux => ReprojectFlux_Model2D procedure, public :: ResizePrevSol => ResizePrevSol_Model2D procedure, public :: SetInitialConditions => SetInitialConditions_Model procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_Model2D, SetSolutionFromEqn_Model2D generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt, SetTimeIntegrator_withChar procedure, public :: SourceMethod => Source_Model procedure, public :: UpdateBoundary => UpdateBoundary_Model procedure, public :: UpdateDevice => UpdateDevice_Model2D procedure, public :: UpdateGAB2 => UpdateGAB2_Model2D procedure, public :: UpdateGAB3 => UpdateGAB3_Model2D procedure, public :: UpdateGAB4 => UpdateGAB4_Model2D procedure, public :: UpdateGRK2 => UpdateGRK2_Model2D procedure, public :: UpdateGRK3 => UpdateGRK3_Model2D procedure, public :: UpdateGRK4 => UpdateGRK4_Model2D procedure, public :: UpdateHost => UpdateHost_Model2D procedure, public :: UpdateSolution => UpdateSolution_Model2D procedure, public :: WriteModel => Write_Model2D procedure, public :: WriteTecplot => WriteTecplot_Model2D procedure, public :: fluxmethod => fluxmethod_advection_diffusion_2d procedure, public :: pretendency => pretendency_advection_diffusion_2d procedure, public :: riemannsolver => riemannsolver_advection_diffusion_2d procedure, public :: setboundarycondition => setboundarycondition_advection_diffusion_2d Subroutines public subroutine fluxmethod_advection_diffusion_2d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this public subroutine pretendency_advection_diffusion_2d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this public subroutine riemannsolver_advection_diffusion_2d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this public subroutine setboundarycondition_advection_diffusion_2d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this","tags":"","loc":"module/self_advection_diffusion_2d.html"},{"title":"self_advection_diffusion_1d – SELF","text":"Uses SELF_Model1D SELF_Model SELF_Mesh Contents Derived Types advection_diffusion_1d Subroutines fluxmethod_advection_diffusion_1d pretendency_advection_diffusion_1d riemannsolver_advection_diffusion_1d setboundarycondition_advection_diffusion_1d Derived Types type, public, extends( Model1D ) :: advection_diffusion_1d Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, POINTER :: geometry logical, public :: gpuAccel integer, public :: ioIterate = 0 type( Mesh1D ), public, POINTER :: mesh real(kind=prec), public :: nu type( MappedScalar1D ), public :: prevSol type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u type( MappedScalar1D ), public :: velocity type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator procedure, public :: AdamsBashforth3_timeIntegrator procedure, public :: AdamsBashforth4_timeIntegrator procedure, public :: CalculateEntropy => CalculateEntropy_Model procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_Model1D procedure, public :: CalculateTendency => CalculateTendency_Model1D procedure, public :: DisableGPUAccel => DisableGPUAccel_Model procedure, public :: EnableGPUAccel => EnableGPUAccel_Model procedure, public :: Euler_timeIntegrator procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_Model1D procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_Model1D procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreFlux => PreFlux_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_Model1D procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: ResizePrevSol => ResizePrevSol_Model1D procedure, public :: SetInitialConditions => SetInitialConditions_Model procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_Model1D, SetSolutionFromEqn_Model1D generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt, SetTimeIntegrator_withChar procedure, public :: SourceMethod => Source_Model procedure, public :: UpdateBoundary => UpdateBoundary_Model procedure, public :: UpdateDevice => UpdateDevice_Model1D procedure, public :: UpdateGAB2 => UpdateGAB2_Model1D procedure, public :: UpdateGAB3 => UpdateGAB3_Model1D procedure, public :: UpdateGAB4 => UpdateGAB4_Model1D procedure, public :: UpdateGRK2 => UpdateGRK2_Model1D procedure, public :: UpdateGRK3 => UpdateGRK3_Model1D procedure, public :: UpdateGRK4 => UpdateGRK4_Model1D procedure, public :: UpdateHost => UpdateHost_Model1D procedure, public :: UpdateSolution => UpdateSolution_Model1D procedure, public :: WriteModel => Write_Model1D procedure, public :: WriteTecplot => WriteTecplot_Model1D procedure, public :: fluxmethod => fluxmethod_advection_diffusion_1d procedure, public :: pretendency => pretendency_advection_diffusion_1d procedure, public :: riemannsolver => riemannsolver_advection_diffusion_1d procedure, public :: setboundarycondition => setboundarycondition_advection_diffusion_1d Subroutines public subroutine fluxmethod_advection_diffusion_1d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this public subroutine pretendency_advection_diffusion_1d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this public subroutine riemannsolver_advection_diffusion_1d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this public subroutine setboundarycondition_advection_diffusion_1d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this","tags":"","loc":"module/self_advection_diffusion_1d.html"},{"title":"self_advection_diffusion_3d – SELF","text":"Uses SELF_Mesh SELF_Model SELF_Model3D Contents Derived Types advection_diffusion_3d Subroutines fluxmethod_advection_diffusion_3d pretendency_advection_diffusion_3d riemannsolver_advection_diffusion_3d setboundarycondition_advection_diffusion_3d Derived Types type, public, extends( Model3D ) :: advection_diffusion_3d Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, POINTER :: geometry logical, public :: gpuAccel integer, public :: ioIterate = 0 type( Mesh3D ), public, POINTER :: mesh real(kind=prec), public :: nu type( MappedScalar3D ), public :: prevSol type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v real(kind=prec), public :: w type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator procedure, public :: AdamsBashforth3_timeIntegrator procedure, public :: AdamsBashforth4_timeIntegrator procedure, public :: CalculateEntropy => CalculateEntropy_Model procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_Model3D procedure, public :: CalculateTendency => CalculateTendency_Model3D procedure, public :: DisableGPUAccel => DisableGPUAccel_Model procedure, public :: EnableGPUAccel => EnableGPUAccel_Model procedure, public :: Euler_timeIntegrator procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_Model3D procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_Model3D procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreFlux => PreFlux_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_Model3D procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: ReprojectFlux => ReprojectFlux_Model3D procedure, public :: ResizePrevSol => ResizePrevSol_Model3D procedure, public :: SetInitialConditions => SetInitialConditions_Model procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_Model3D, SetSolutionFromEqn_Model3D generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt, SetTimeIntegrator_withChar procedure, public :: SourceMethod => Source_Model procedure, public :: UpdateBoundary => UpdateBoundary_Model procedure, public :: UpdateDevice => UpdateDevice_Model3D procedure, public :: UpdateGAB2 => UpdateGAB2_Model3D procedure, public :: UpdateGAB3 => UpdateGAB3_Model3D procedure, public :: UpdateGAB4 => UpdateGAB4_Model3D procedure, public :: UpdateGRK2 => UpdateGRK2_Model3D procedure, public :: UpdateGRK3 => UpdateGRK3_Model3D procedure, public :: UpdateGRK4 => UpdateGRK4_Model3D procedure, public :: UpdateHost => UpdateHost_Model3D procedure, public :: UpdateSolution => UpdateSolution_Model3D procedure, public :: WriteModel => Write_Model3D procedure, public :: WriteTecplot => WriteTecplot_Model3D procedure, public :: fluxmethod => fluxmethod_advection_diffusion_3d procedure, public :: pretendency => pretendency_advection_diffusion_3d procedure, public :: riemannsolver => riemannsolver_advection_diffusion_3d procedure, public :: setboundarycondition => setboundarycondition_advection_diffusion_3d Subroutines public subroutine fluxmethod_advection_diffusion_3d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this public subroutine pretendency_advection_diffusion_3d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this public subroutine riemannsolver_advection_diffusion_3d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this public subroutine setboundarycondition_advection_diffusion_3d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this","tags":"","loc":"module/self_advection_diffusion_3d.html"},{"title":"SELF_Model2D – SELF","text":"Uses FEQParse SELF_Metadata SELF_Mesh SELF_HDF5 HDF5 SELF_Model SELF_SupportRoutines SELF_MappedData Contents Interfaces CalculateDSDt_Model2D_gpu_wrapper UpdateGAB2_Model2D_gpu_wrapper UpdateGAB3_Model2D_gpu_wrapper UpdateGAB4_Model2D_gpu_wrapper UpdateGRK_Model2D_gpu_wrapper UpdateSolution_Model2D_gpu_wrapper Derived Types Model2D Subroutines CalculateFluxDivergence_Model2D CalculateTendency_Model2D Free_Model2D Init_Model2D Read_Model2D ReprojectFlux_Model2D ResizePrevSol_Model2D SetSolutionFromChar_Model2D SetSolutionFromEqn_Model2D UpdateDevice_Model2D UpdateGAB2_Model2D UpdateGAB3_Model2D UpdateGAB4_Model2D UpdateGRK2_Model2D UpdateGRK3_Model2D UpdateGRK4_Model2D UpdateHost_Model2D UpdateSolution_Model2D WriteTecplot_Model2D Write_Model2D Interfaces interface public subroutine CalculateDSDt_Model2D_gpu_wrapper(fluxDivergence, source, dSdt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: fluxDivergence type(C_PTR) :: source type(C_PTR) :: dSdt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateGAB2_Model2D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateGAB3_Model2D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateGAB4_Model2D_gpu_wrapper(prevsol, solution, m, nPrev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: prevsol type(C_PTR) :: solution integer(kind=C_INT), VALUE :: m integer(kind=C_INT), VALUE :: nPrev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateGRK_Model2D_gpu_wrapper(grk, solution, dSdt, rk_a, rk_g, dt, nWork, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: grk type(C_PTR) :: solution type(C_PTR) :: dSdt real(kind=c_prec), VALUE :: rk_a real(kind=c_prec), VALUE :: rk_g real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: nWork integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateSolution_Model2D_gpu_wrapper(solution, dSdt, dt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: solution type(C_PTR) :: dSdt real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl Derived Types type, public, extends( Model ) :: Model2D Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, POINTER :: geometry logical, public :: gpuAccel integer, public :: ioIterate = 0 type( Mesh2D ), public, POINTER :: mesh type( MappedScalar2D ), public :: prevSol type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator procedure, public :: AdamsBashforth3_timeIntegrator procedure, public :: AdamsBashforth4_timeIntegrator procedure, public :: CalculateEntropy => CalculateEntropy_Model procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_Model2D procedure, public :: CalculateTendency => CalculateTendency_Model2D procedure, public :: DisableGPUAccel => DisableGPUAccel_Model procedure, public :: EnableGPUAccel => EnableGPUAccel_Model procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => Flux_Model procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_Model2D procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_Model2D procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreFlux => PreFlux_Model procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_Model2D procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: ReprojectFlux => ReprojectFlux_Model2D procedure, public :: ResizePrevSol => ResizePrevSol_Model2D procedure, public :: RiemannSolver => RiemannSolver_Model procedure, public :: SetBoundaryCondition => SetBoundaryCondition_Model procedure, public :: SetInitialConditions => SetInitialConditions_Model procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_Model2D, SetSolutionFromEqn_Model2D procedure, private :: SetSolutionFromChar_Model2D procedure, private :: SetSolutionFromEqn_Model2D generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt, SetTimeIntegrator_withChar procedure, public :: SourceMethod => Source_Model procedure, public :: UpdateBoundary => UpdateBoundary_Model procedure, public :: UpdateDevice => UpdateDevice_Model2D procedure, public :: UpdateGAB2 => UpdateGAB2_Model2D procedure, public :: UpdateGAB3 => UpdateGAB3_Model2D procedure, public :: UpdateGAB4 => UpdateGAB4_Model2D procedure, public :: UpdateGRK2 => UpdateGRK2_Model2D procedure, public :: UpdateGRK3 => UpdateGRK3_Model2D procedure, public :: UpdateGRK4 => UpdateGRK4_Model2D procedure, public :: UpdateHost => UpdateHost_Model2D procedure, public :: UpdateSolution => UpdateSolution_Model2D procedure, public :: WriteModel => Write_Model2D procedure, public :: WriteTecplot => WriteTecplot_Model2D Subroutines public subroutine CalculateFluxDivergence_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this public subroutine CalculateTendency_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this public subroutine Free_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this public subroutine Init_Model2D (this, nvar, mesh, geometry, decomp) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), TARGET :: mesh type( SEMQuad ), intent(in), TARGET :: geometry type( MPILayer ), intent(in), TARGET :: decomp public subroutine Read_Model2D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in) :: fileName public subroutine ReprojectFlux_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this public subroutine ResizePrevSol_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m public subroutine SetSolutionFromChar_Model2D (this, eqnChar) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_Model2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) public subroutine UpdateDevice_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this public subroutine UpdateGAB2_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGAB3_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGAB4_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK2_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK3_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK4_Model2D (this, m) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateHost_Model2D (this) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this public subroutine UpdateSolution_Model2D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt public subroutine WriteTecplot_Model2D (this, filename) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in), optional :: filename public subroutine Write_Model2D (this, fileName) Arguments Type Intent Optional Attributes Name class( Model2D ), intent(inout) :: this character, intent(in), optional :: fileName","tags":"","loc":"module/self_model2d.html"},{"title":"SELF_Mesh – SELF","text":"Uses SELF_Data SELF_HDF5 iso_c_binding SELF_SupportRoutines HDF5 SELF_HIP SELF_Constants SELF_Lagrange Contents Variables SELF_MESH_HOPR_2D SELF_MESH_HOPR_3D SELF_MESH_ISM_V2_2D SELF_MESH_ISM_V2_3D selfHexahedronBilinear selfHexahedronLinear selfHexahedronNonlinear selfLineLinear selfLineNonlinear selfMaxNodalValence2D selfMaxNodalValence3D selfMinNodalValence2D selfMinNodalValence3D selfPrismBilinear selfPrismLinear selfPrismNonlinear selfPyramidBilinear selfPyramidLinear selfPyramidNonlinear selfQuadBilinear selfQuadLinear selfQuadNonlinear selfSide2D_East selfSide2D_North selfSide2D_South selfSide2D_West selfSide3D_Bottom selfSide3D_East selfSide3D_North selfSide3D_South selfSide3D_Top selfSide3D_West selfTetrahedronLinear selfTetrahedronNonlinear selfTriangleLinear selfTriangleNonlinear self_BCDefault self_nBCsDefault Derived Types MPILayer Mesh1D Mesh2D Mesh3D MeshSpec SEMMesh Subroutines DomainDecomp ElemToRank FinalizeMPIExchangeAsync Finalize_MPILayer Free_MPILayer Free_Mesh1D Free_Mesh2D Free_Mesh3D GenerateDecomposition_MPILayer GlobalReduce_RealScalar Init_MPILayer Init_Mesh1D Init_Mesh2D Init_Mesh3D Read_HOPr_Mesh2D Read_HOPr_Mesh3D RecalculateFlip_Mesh2D RecalculateFlip_Mesh3D ResetBoundaryConditionType_Mesh2D ResetBoundaryConditionType_Mesh3D SetElemToRank SetMaxMsg UniformBlockMesh_Mesh1D UpdateDevice_Mesh1D UpdateDevice_Mesh2D UpdateDevice_Mesh3D UpdateHost_Mesh1D UpdateHost_Mesh2D UpdateHost_Mesh3D Write_Mesh1D Write_Mesh2D Write_Mesh3D Variables Type Visibility Attributes Name Initial integer, public, parameter :: SELF_MESH_HOPR_2D = 3 integer, public, parameter :: SELF_MESH_HOPR_3D = 4 integer, public, parameter :: SELF_MESH_ISM_V2_2D = 1 integer, public, parameter :: SELF_MESH_ISM_V2_3D = 2 integer, public, parameter :: selfHexahedronBilinear = 118 integer, public, parameter :: selfHexahedronLinear = 108 integer, public, parameter :: selfHexahedronNonlinear = 208 integer, public, parameter :: selfLineLinear = 1 integer, public, parameter :: selfLineNonlinear = 2 integer, public, parameter :: selfMaxNodalValence2D = 6 integer, public, parameter :: selfMaxNodalValence3D = 10 integer, public, parameter :: selfMinNodalValence2D = 4 integer, public, parameter :: selfMinNodalValence3D = 8 integer, public, parameter :: selfPrismBilinear = 116 integer, public, parameter :: selfPrismLinear = 106 integer, public, parameter :: selfPrismNonlinear = 206 integer, public, parameter :: selfPyramidBilinear = 115 integer, public, parameter :: selfPyramidLinear = 105 integer, public, parameter :: selfPyramidNonlinear = 205 integer, public, parameter :: selfQuadBilinear = 14 integer, public, parameter :: selfQuadLinear = 4 integer, public, parameter :: selfQuadNonlinear = 24 integer, public, parameter :: selfSide2D_East = 2 integer, public, parameter :: selfSide2D_North = 3 integer, public, parameter :: selfSide2D_South = 1 integer, public, parameter :: selfSide2D_West = 4 integer, public, parameter :: selfSide3D_Bottom = 1 integer, public, parameter :: selfSide3D_East = 3 integer, public, parameter :: selfSide3D_North = 4 integer, public, parameter :: selfSide3D_South = 2 integer, public, parameter :: selfSide3D_Top = 6 integer, public, parameter :: selfSide3D_West = 5 integer, public, parameter :: selfTetrahedronLinear = 104 integer, public, parameter :: selfTetrahedronNonlinear = 204 integer, public, parameter :: selfTriangleLinear = 3 integer, public, parameter :: selfTriangleNonlinear = 23 integer, public, parameter :: self_BCDefault = 1 integer, public, parameter :: self_nBCsDefault = 5 Derived Types type, public :: MPILayer Components Type Visibility Attributes Name Initial type( hfInt32_r1 ), public :: elemToRank integer, public :: maxMsg integer, public :: mpiComm logical, public :: mpiEnabled integer, public :: mpiPrec integer, public :: msgCount integer, public :: nElem integer, public :: nRanks type( hfInt32_r1 ), public :: offSetElem integer, public :: rankId integer, public, ALLOCATABLE :: requests (:) integer, public, ALLOCATABLE :: stats (:,:) Type-Bound Procedures procedure, public :: Finalize => Finalize_MPILayer procedure, public :: FinalizeMPIExchangeAsync procedure, public :: Free => Free_MPILayer procedure, public :: GenerateDecomposition => GenerateDecomposition_MPILayer generic, public :: GlobalReduce => GlobalReduce_RealScalar procedure, private :: GlobalReduce_RealScalar procedure, public :: Init => Init_MPILayer procedure, public :: SetElemToRank procedure, public :: SetMaxMsg type, public, extends( SEMMesh ) :: Mesh1D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type( hfInt32_r2 ), public :: BCType type( hfInt32_r2 ), public :: elemInfo type( hfInt32_r1 ), public :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides type( hfReal_r1 ), public :: nodeCoords integer, public :: quadrature Type-Bound Procedures procedure, public :: Free => Free_Mesh1D procedure, public :: Init => Init_Mesh1D procedure, public :: UniformBlockMesh => UniformBlockMesh_Mesh1D procedure, public :: UpdateDevice => UpdateDevice_Mesh1D procedure, public :: UpdateHost => UpdateHost_Mesh1D procedure, public :: Write_Mesh => Write_Mesh1D type, public, extends( SEMMesh ) :: Mesh2D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type( hfInt32_r2 ), public :: BCType type( hfInt32_r2 ), public :: CGNSCornerMap type( hfInt32_r2 ), public :: CGNSSideMap type( hfInt32_r2 ), public :: elemInfo type( hfInt32_r3 ), public :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides type( hfReal_r4 ), public :: nodeCoords integer, public :: quadrature type( hfInt32_r3 ), public :: sideInfo Type-Bound Procedures procedure, public :: Free => Free_Mesh2D procedure, public :: Init => Init_Mesh2D procedure, public :: Read_HOPr => Read_HOPr_Mesh2D procedure, private :: RecalculateFlip => RecalculateFlip_Mesh2D procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh2D procedure, public :: UpdateDevice => UpdateDevice_Mesh2D procedure, public :: UpdateHost => UpdateHost_Mesh2D procedure, public :: Write_Mesh => Write_Mesh2D type, public, extends( SEMMesh ) :: Mesh3D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type( hfInt32_r2 ), public :: BCType type( hfInt32_r2 ), public :: CGNSCornerMap type( hfInt32_r2 ), public :: CGNSSideMap type( hfInt32_r2 ), public :: elemInfo type( hfInt32_r4 ), public :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides type( hfReal_r5 ), public :: nodeCoords integer, public :: quadrature type( hfInt32_r3 ), public :: sideInfo type( hfInt32_r2 ), public :: sideMap Type-Bound Procedures procedure, public :: Free => Free_Mesh3D procedure, public :: Init => Init_Mesh3D procedure, public :: Read_HOPr => Read_HOPr_Mesh3D procedure, private :: RecalculateFlip => RecalculateFlip_Mesh3D procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh3D procedure, public :: UpdateDevice => UpdateDevice_Mesh3D procedure, public :: UpdateHost => UpdateHost_Mesh3D procedure, public :: Write_Mesh => Write_Mesh3D type, public :: MeshSpec Components Type Visibility Attributes Name Initial logical, public :: blockMesh integer, public :: blockMesh_nElemX integer, public :: blockMesh_nElemY integer, public :: blockMesh_nElemZ integer, public :: blockMesh_nGeo real(kind=prec), public :: blockMesh_x0 real(kind=prec), public :: blockMesh_x1 real(kind=prec), public :: blockMesh_y0 real(kind=prec), public :: blockMesh_y1 real(kind=prec), public :: blockMesh_z0 real(kind=prec), public :: blockMesh_z1 integer, public :: fileType character, public :: filename type, public :: SEMMesh Components Type Visibility Attributes Name Initial integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides integer, public :: quadrature Subroutines public subroutine DomainDecomp (nElems, nDomains, offsetElem) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nElems integer, intent(in) :: nDomains integer, intent(out) :: offsetElem (0:nDomains) public subroutine ElemToRank (nDomains, offsetElem, elemID, domain) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDomains integer, intent(in) :: offsetElem (0:nDomains) integer, intent(in) :: elemID integer, intent(out) :: domain public subroutine FinalizeMPIExchangeAsync (mpiHandler) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: mpiHandler public subroutine Finalize_MPILayer (this) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this public subroutine Free_MPILayer (this) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this public subroutine Free_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh public subroutine Free_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh public subroutine Free_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh public subroutine GenerateDecomposition_MPILayer (this, nGlobalElem, maxMsg) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this integer, intent(in) :: nGlobalElem integer, intent(in) :: maxMsg public subroutine GlobalReduce_RealScalar (mpiHandler, sendBuf, recvBuf) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(in) :: mpiHandler real(kind=prec), intent(in) :: sendBuf real(kind=prec), intent(out) :: recvBuf public subroutine Init_MPILayer (this, enableMPI) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(out) :: this logical, intent(in) :: enableMPI public subroutine Init_Mesh1D (myMesh, nGeo, nElem, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nNodes integer, intent(in) :: nBCs public subroutine Init_Mesh2D (myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs public subroutine Init_Mesh3D (myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs public subroutine Read_HOPr_Mesh2D (myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh character, intent(in) :: meshFile type( MPILayer ), intent(inout) :: decomp public subroutine Read_HOPr_Mesh3D (myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh character, intent(in) :: meshFile type( MPILayer ), intent(inout) :: decomp public subroutine RecalculateFlip_Mesh2D (myMesh, decomp) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh type( MPILayer ), intent(inout), optional :: decomp public subroutine RecalculateFlip_Mesh3D (myMesh, decomp) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh type( MPILayer ), intent(inout), optional :: decomp public subroutine ResetBoundaryConditionType_Mesh2D (myMesh, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Read more… Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh integer, intent(in) :: bcid public subroutine ResetBoundaryConditionType_Mesh3D (myMesh, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Read more… Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh integer, intent(in) :: bcid public subroutine SetElemToRank (this, nElem) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this integer, intent(in) :: nElem public subroutine SetMaxMsg (this, maxMsg) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this integer, intent(in) :: maxMsg public subroutine UniformBlockMesh_Mesh1D (myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem real(kind=prec), intent(in) :: x (1:2) public subroutine UpdateDevice_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh public subroutine UpdateDevice_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh public subroutine UpdateDevice_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh public subroutine UpdateHost_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh public subroutine UpdateHost_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh public subroutine UpdateHost_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh public subroutine Write_Mesh1D (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh character, intent(in) :: meshFile public subroutine Write_Mesh2D (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh character, intent(in) :: meshFile public subroutine Write_Mesh3D (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh character, intent(in) :: meshFile","tags":"","loc":"module/self_mesh.html"},{"title":"SELF_Quadrature – SELF","text":"Uses iso_fortran_env SELF_Constants Contents Subroutines ChebyshevGauss ChebyshevGaussLobatto ChebyshevQuadrature LegendreGauss LegendreGaussLobatto LegendrePolynomial LegendreQandL LegendreQuadrature Subroutines private subroutine ChebyshevGauss (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) private subroutine ChebyshevGaussLobatto (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) public subroutine ChebyshevQuadrature (N, nodes, weights, QuadType) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=prec), intent(out) :: nodes (0:N) real(kind=prec), intent(out) :: weights (0:N) integer, intent(in) :: QuadType private subroutine LegendreGauss (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) private subroutine LegendreGaussLobatto (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) public subroutine LegendrePolynomial (N, x, lAtX, dLdxAtX) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: lAtX real(kind=real64) :: dLdxAtX private subroutine LegendreQandL (N, x, q, qprime, lN) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: q real(kind=real64) :: qprime real(kind=real64) :: lN public subroutine LegendreQuadrature (N, nodes, weights, QuadType) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=prec), intent(out) :: nodes (0:N) real(kind=prec), intent(out) :: weights (0:N) integer, intent(in) :: QuadType","tags":"","loc":"module/self_quadrature.html"},{"title":"SELF_Data – SELF","text":"Uses FEQParse SELF_Metadata SELF_Lagrange SELF_Constants iso_c_binding Contents Variables selfStrongForm selfWeakBRForm selfWeakCGForm selfWeakDGForm Interfaces Determinant_Tensor2D_gpu_wrapper Determinant_Tensor3D_gpu_wrapper Derived Types SELF_DataObj Scalar1D Scalar2D Scalar3D Tensor2D Tensor3D Vector2D Vector3D Subroutines BoundaryInterp_Scalar1D BoundaryInterp_Scalar2D BoundaryInterp_Scalar3D BoundaryInterp_Tensor2D BoundaryInterp_Tensor3D BoundaryInterp_Vector2D BoundaryInterp_Vector3D Derivative_Scalar1D Determinant_Tensor2D Determinant_Tensor3D Divergence_Vector2D Divergence_Vector3D Free_Scalar1D Free_Scalar2D Free_Scalar3D Free_Tensor2D Free_Tensor3D Free_Vector2D Free_Vector3D Gradient_Scalar2D Gradient_Scalar3D Gradient_Vector2D Gradient_Vector3D GridInterp_Scalar1D GridInterp_Scalar2D GridInterp_Scalar3D GridInterp_Vector2D GridInterp_Vector3D Init_Scalar1D Init_Scalar2D Init_Scalar3D Init_Tensor2D Init_Tensor3D Init_Vector2D Init_Vector3D SetDescription_DataObj SetEquation_DataObj SetEquation_Vector2D SetEquation_Vector3D SetName_DataObj SetUnits_DataObj UpdateDevice_Scalar1D UpdateDevice_Scalar2D UpdateDevice_Scalar3D UpdateDevice_Tensor2D UpdateDevice_Tensor3D UpdateDevice_Vector2D UpdateDevice_Vector3D UpdateHost_Scalar1D UpdateHost_Scalar2D UpdateHost_Scalar3D UpdateHost_Tensor2D UpdateHost_Tensor3D UpdateHost_Vector2D UpdateHost_Vector3D WriteHDF5_MPI_Scalar1D WriteHDF5_MPI_Scalar2D WriteHDF5_MPI_Scalar3D WriteHDF5_MPI_Vector2D WriteHDF5_MPI_Vector3D WriteHDF5_Scalar1D WriteHDF5_Scalar2D WriteHDF5_Scalar3D WriteHDF5_Vector2D WriteHDF5_Vector3D Variables Type Visibility Attributes Name Initial integer, public, parameter :: selfStrongForm = 0 integer, public, parameter :: selfWeakBRForm = 3 integer, public, parameter :: selfWeakCGForm = 2 integer, public, parameter :: selfWeakDGForm = 1 Interfaces interface public subroutine Determinant_Tensor2D_gpu_wrapper(tensor_dev, detTensor_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor_dev type(c_ptr) :: detTensor_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine Determinant_Tensor3D_gpu_wrapper(tensor_dev, detTensor_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor_dev type(c_ptr) :: detTensor_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl Derived Types type, public :: SELF_DataObj The SELF_DataObj class is a base class for all data objects in SELF.\nA data object in SELF is a multidimensional array of data, represented\non both host and device, that is associated with an interpolant, metadata,\nand (optionally) an equation string.\nType extensions of the SELF_DataObj include scalars, vectors, and tensors\nin 1-D, 2-D, and 3-D using the storage patterns that are expected for\nderivative and interpolation operations defined in SELF_Lagrange.f90\nAdditionally, each extended type has the necessary attributes to store\ninformation on element interiors and element boundaries, both of which\nare commonly used for spectral element solvers. Components Type Visibility Attributes Name Initial type(EquationParser), public, ALLOCATABLE :: eqn (:) type( Lagrange ), public, POINTER :: interp type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, private :: SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj type, public, extends( SELF_DataObj ) :: Scalar1D Components Type Visibility Attributes Name Initial type( hfReal_r3 ), public :: avgBoundary type( hfReal_r3 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r3 ), public :: extBoundary type( hfReal_r3 ), public :: interior type( Lagrange ), public, POINTER :: interp type( hfReal_r3 ), public :: jumpBoundary type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D generic, public :: Derivative => Derivative_Scalar1D procedure, private :: Derivative_Scalar1D procedure, public :: Free => Free_Scalar1D procedure, public :: GridInterp => GridInterp_Scalar1D procedure, public :: Init => Init_Scalar1D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Scalar1D procedure, public :: UpdateHost => UpdateHost_Scalar1D generic, public :: WriteHDF5 => WriteHDF5_Scalar1D, WriteHDF5_MPI_Scalar1D procedure, private :: WriteHDF5_MPI_Scalar1D procedure, private :: WriteHDF5_Scalar1D type, public, extends( SELF_DataObj ) :: Scalar2D Components Type Visibility Attributes Name Initial type( hfReal_r4 ), public :: avgBoundary type( hfReal_r4 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r4 ), public :: extBoundary type( hfReal_r4 ), public :: interior type( Lagrange ), public, POINTER :: interp type( hfReal_r4 ), public :: jumpBoundary type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D procedure, public :: Free => Free_Scalar2D generic, public :: Gradient => Gradient_Scalar2D procedure, private :: Gradient_Scalar2D procedure, public :: GridInterp => GridInterp_Scalar2D procedure, public :: Init => Init_Scalar2D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Scalar2D procedure, public :: UpdateHost => UpdateHost_Scalar2D generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D, WriteHDF5_Scalar2D procedure, private :: WriteHDF5_MPI_Scalar2D procedure, private :: WriteHDF5_Scalar2D type, public, extends( SELF_DataObj ) :: Scalar3D Components Type Visibility Attributes Name Initial type( hfReal_r5 ), public :: avgBoundary type( hfReal_r5 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r5 ), public :: extBoundary type( hfReal_r5 ), public :: interior type( Lagrange ), public, POINTER :: interp type( hfReal_r5 ), public :: jumpBoundary type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D procedure, public :: Free => Free_Scalar3D generic, public :: Gradient => Gradient_Scalar3D procedure, private :: Gradient_Scalar3D procedure, public :: GridInterp => GridInterp_Scalar3D procedure, public :: Init => Init_Scalar3D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Scalar3D procedure, public :: UpdateHost => UpdateHost_Scalar3D generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D, WriteHDF5_Scalar3D procedure, private :: WriteHDF5_MPI_Scalar3D procedure, private :: WriteHDF5_Scalar3D type, public, extends( SELF_DataObj ) :: Tensor2D Components Type Visibility Attributes Name Initial type( hfReal_r6 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r6 ), public :: extBoundary type( hfReal_r6 ), public :: interior type( Lagrange ), public, POINTER :: interp type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor2D procedure, public :: Determinant => Determinant_Tensor2D procedure, public :: Free => Free_Tensor2D procedure, public :: Init => Init_Tensor2D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Tensor2D procedure, public :: UpdateHost => UpdateHost_Tensor2D type, public, extends( SELF_DataObj ) :: Tensor3D Components Type Visibility Attributes Name Initial type( hfReal_r7 ), public :: boundary type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r7 ), public :: extBoundary type( hfReal_r7 ), public :: interior type( Lagrange ), public, POINTER :: interp type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor3D procedure, public :: Determinant => Determinant_Tensor3D procedure, public :: Free => Free_Tensor3D procedure, public :: Init => Init_Tensor3D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Tensor3D procedure, public :: UpdateHost => UpdateHost_Tensor3D type, public, extends( SELF_DataObj ) :: Vector2D Components Type Visibility Attributes Name Initial type( hfReal_r5 ), public :: boundary type( hfReal_r4 ), public :: boundaryNormal type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r5 ), public :: extBoundary type( hfReal_r5 ), public :: interior type( Lagrange ), public, POINTER :: interp type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D generic, public :: Divergence => Divergence_Vector2D procedure, private :: Divergence_Vector2D procedure, public :: Free => Free_Vector2D generic, public :: Gradient => Gradient_Vector2D procedure, private :: Gradient_Vector2D procedure, public :: GridInterp => GridInterp_Vector2D procedure, public :: Init => Init_Vector2D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector2D procedure, private :: SetEquation_Vector2D procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Vector2D procedure, public :: UpdateHost => UpdateHost_Vector2D generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D, WriteHDF5_Vector2D procedure, private :: WriteHDF5_MPI_Vector2D procedure, private :: WriteHDF5_Vector2D type, public, extends( SELF_DataObj ) :: Vector3D Components Type Visibility Attributes Name Initial type( hfReal_r6 ), public :: boundary type( hfReal_r5 ), public :: boundaryNormal type(EquationParser), public, ALLOCATABLE :: eqn (:) type( hfReal_r6 ), public :: extBoundary type( hfReal_r6 ), public :: interior type( Lagrange ), public, POINTER :: interp type( Metadata ), public, ALLOCATABLE :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D generic, public :: Divergence => Divergence_Vector3D procedure, private :: Divergence_Vector3D procedure, public :: Free => Free_Vector3D generic, public :: Gradient => Gradient_Vector3D procedure, private :: Gradient_Vector3D procedure, public :: GridInterp => GridInterp_Vector3D procedure, public :: Init => Init_Vector3D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector3D procedure, private :: SetEquation_Vector3D procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Vector3D procedure, public :: UpdateHost => UpdateHost_Vector3D generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D, WriteHDF5_Vector3D procedure, private :: WriteHDF5_MPI_Vector3D procedure, private :: WriteHDF5_Vector3D Subroutines public subroutine BoundaryInterp_Scalar1D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Scalar2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Scalar3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Tensor2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Tensor3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Vector2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Vector3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine Derivative_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Determinant_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Determinant_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Divergence_Vector2D (SELFStorage, SELFOut, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Divergence_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Free_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage public subroutine Free_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage public subroutine Free_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage public subroutine Free_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage public subroutine Free_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage public subroutine Free_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage public subroutine Free_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage public subroutine Gradient_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Gradient_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Gradient_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Gradient_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Init_Scalar1D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Scalar2D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Scalar3D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Tensor2D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Tensor3D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Vector2D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Vector3D (SELFStorage, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: SELFStorage type( Lagrange ), intent(in), TARGET :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine SetDescription_DataObj (SELFStorage, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: description public subroutine SetEquation_DataObj (SELFStorage, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector2D (SELFStorage, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector3D (SELFStorage, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetName_DataObj (SELFStorage, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: name public subroutine SetUnits_DataObj (SELFStorage, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: SELFStorage integer, intent(in) :: ivar character, intent(in) :: units public subroutine UpdateDevice_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage public subroutine WriteHDF5_MPI_Scalar1D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_MPI_Scalar2D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_MPI_Scalar3D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_MPI_Vector2D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_MPI_Vector3D (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar1D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group public subroutine WriteHDF5_Scalar2D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group public subroutine WriteHDF5_Scalar3D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group public subroutine WriteHDF5_Vector2D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group public subroutine WriteHDF5_Vector3D (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group","tags":"","loc":"module/self_data.html"},{"title":"SELF_Constants – SELF","text":"Uses iso_fortran_env iso_c_binding Contents Variables CG CHEBYSHEV_GAUSS CHEBYSHEV_GAUSS_LOBATTO DG GAUSS GAUSS_LOBATTO MsgFmt SELF_EQN_DEFAULT_LENGTH SELF_FILE_DEFAULT_LENGTH TOL UNIFORM c_prec c_prec daysToMonths daysToSeconds fillValue fillValueInt hoursToDays maxInverseIters minutesToHours monthsToYears nada newtonMax newtonTolerance pi prec prec secondsToMinutes self_EquationLength self_FileNameLength self_FormatLength self_IntegratorTypeCharLength self_QuadratureTypeCharLength self_TecplotHeaderLength Variables Type Visibility Attributes Name Initial integer, public, parameter :: CG = 2001 integer, public, parameter :: CHEBYSHEV_GAUSS = 3 integer, public, parameter :: CHEBYSHEV_GAUSS_LOBATTO = 4 integer, public, parameter :: DG = 2000 integer, public, parameter :: GAUSS = 1 integer, public, parameter :: GAUSS_LOBATTO = 2 character(len=6), public, parameter :: MsgFmt = '(2x,A)' integer, public, parameter :: SELF_EQN_DEFAULT_LENGTH = 100 integer, public, parameter :: SELF_FILE_DEFAULT_LENGTH = 500 real(kind=prec), public, parameter :: TOL = epsilon(1.0_prec) integer, public, parameter :: UNIFORM = 5 integer, public, parameter :: c_prec = C_DOUBLE integer, public, parameter :: c_prec = C_FLOAT real(kind=prec), public, parameter :: daysToMonths = 12.0_prec/365.25_prec real(kind=prec), public, parameter :: daysToSeconds = 86400.0_prec real(kind=prec), public, parameter :: fillValue = -9999.99_prec integer, public, parameter :: fillValueInt = -99999 real(kind=prec), public, parameter :: hoursToDays = 1.0_prec/24.0_prec integer, public, parameter :: maxInverseIters = 1000 real(kind=prec), public, parameter :: minutesToHours = 1.0_prec/60.0_prec real(kind=prec), public, parameter :: monthsToYears = 1.0_prec/12.0_prec character(len=1), public, parameter :: nada = ' ' integer, public, parameter :: newtonMax = 500 real(kind=prec), public, parameter :: newtonTolerance = 10.0**(-8) real(kind=prec), public, parameter :: pi = 4.0_prec*atan(1.0_prec) integer, public, parameter :: prec = real64 integer, public, parameter :: prec = real32 real(kind=prec), public, parameter :: secondsToMinutes = 1.0_prec/60.0_prec integer, public, parameter :: self_EquationLength = 210 integer, public, parameter :: self_FileNameLength = 500 integer, public, parameter :: self_FormatLength = 30 integer, public, parameter :: self_IntegratorTypeCharLength = 50 integer, public, parameter :: self_QuadratureTypeCharLength = 50 integer, public, parameter :: self_TecplotHeaderLength = 500","tags":"","loc":"module/self_constants.html"},{"title":"SELF_HIP – SELF","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses iso_c_binding Contents Interfaces hipFree hipGetDeviceCount hipMalloc hipMemcpy hipSetDevice Subroutines hipCheck Interfaces public interface hipFree public function hipFree_(ptr) bind(c,name=\"hipFree\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: ptr Return Value integer(kind=KIND(hipSuccess)) public interface hipGetDeviceCount public function hipGetDeviceCount_(count) bind(c,name=\"hipGetDeviceCount\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT) :: count Return Value integer(kind=KIND(hipSuccess)) public interface hipMalloc public function hipMalloc_(ptr, mySize) bind(c,name=\"hipMalloc\") Arguments Type Intent Optional Attributes Name type(C_PTR) :: ptr integer(kind=C_SIZE_T), VALUE :: mySize Return Value integer(kind=KIND(hipSuccess)) public interface hipMemcpy public function hipMemcpy_(dest, src, sizeBytes, myKind) bind(c,name=\"hipMemcpy\") Arguments Type Intent Optional Attributes Name type(C_PTR), VALUE :: dest type(C_PTR), VALUE :: src integer(kind=C_SIZE_T), VALUE :: sizeBytes integer(kind=KIND(hipMemcpyHostToHost)), VALUE :: myKind Return Value integer(kind=KIND(hipSuccess)) public interface hipSetDevice public function hipSetDevice_(deviceId) bind(c,name=\"hipSetDevice\") Arguments Type Intent Optional Attributes Name integer(kind=C_INT), VALUE :: deviceId Return Value integer(kind=KIND(hipSuccess)) Subroutines public subroutine hipCheck (hipError_t) Arguments Type Intent Optional Attributes Name integer(kind=KIND(hipSuccess)) :: hipError_t","tags":"","loc":"module/self_hip.html"},{"title":"SELF_ECModel2D – SELF","text":"Uses FEQParse SELF_Metadata SELF_Mesh SELF_HDF5 SELF_Model2D HDF5 SELF_Model SELF_SupportRoutines SELF_MappedData Contents Derived Types ECModel2D Subroutines CalculateFluxDivergence_ECModel2D CalculateTendency_ECModel2D Free_ECModel2D Init_ECModel2D Read_ECModel2D ReprojectFlux_ECModel2D ResizePrevSol_ECModel2D SetSolutionFromChar_ECModel2D SetSolutionFromEqn_ECModel2D UpdateBoundary_ECModel2D UpdateDevice_ECModel2D UpdateGAB2_ECModel2D UpdateGAB3_ECModel2D UpdateGAB4_ECModel2D UpdateGRK2_ECModel2D UpdateGRK3_ECModel2D UpdateGRK4_ECModel2D UpdateHost_ECModel2D UpdateSolution_ECModel2D WriteTecplot_ECModel2D Write_ECModel2D Derived Types type, public, extends( Model ) :: ECModel2D Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt type( MPILayer ), public, POINTER :: decomp real(kind=prec), public :: dt real(kind=prec), public :: entropy type(MappedP2Vector2D), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, POINTER :: geometry logical, public :: gpuAccel integer, public :: ioIterate = 0 type( Mesh2D ), public, POINTER :: mesh type( MappedScalar2D ), public :: prevSol type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, POINTER :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: AdamsBashforth2_timeIntegrator procedure, public :: AdamsBashforth3_timeIntegrator procedure, public :: AdamsBashforth4_timeIntegrator procedure, public :: CalculateEntropy => CalculateEntropy_Model procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_ECModel2D procedure, public :: CalculateTendency => CalculateTendency_ECModel2D procedure, public :: DisableGPUAccel => DisableGPUAccel_Model procedure, public :: EnableGPUAccel => EnableGPUAccel_Model procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => Flux_Model procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_ECModel2D procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_ECModel2D procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreFlux => PreFlux_Model procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_ECModel2D procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: ReprojectFlux => ReprojectFlux_ECModel2D procedure, public :: ResizePrevSol => ResizePrevSol_ECModel2D procedure, public :: RiemannSolver => RiemannSolver_Model procedure, public :: SetBoundaryCondition => SetBoundaryCondition_Model procedure, public :: SetInitialConditions => SetInitialConditions_Model procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_ECModel2D, SetSolutionFromEqn_ECModel2D procedure, private :: SetSolutionFromChar_ECModel2D procedure, private :: SetSolutionFromEqn_ECModel2D generic, public :: SetTimeIntegrator => SetTimeIntegrator_withInt, SetTimeIntegrator_withChar procedure, public :: SourceMethod => Source_Model procedure, public :: UpdateBoundary => UpdateBoundary_ECModel2D procedure, public :: UpdateDevice => UpdateDevice_ECModel2D procedure, public :: UpdateGAB2 => UpdateGAB2_ECModel2D procedure, public :: UpdateGAB3 => UpdateGAB3_ECModel2D procedure, public :: UpdateGAB4 => UpdateGAB4_ECModel2D procedure, public :: UpdateGRK2 => UpdateGRK2_ECModel2D procedure, public :: UpdateGRK3 => UpdateGRK3_ECModel2D procedure, public :: UpdateGRK4 => UpdateGRK4_ECModel2D procedure, public :: UpdateHost => UpdateHost_ECModel2D procedure, public :: UpdateSolution => UpdateSolution_ECModel2D procedure, public :: WriteModel => Write_ECModel2D procedure, public :: WriteTecplot => WriteTecplot_ECModel2D Subroutines public subroutine CalculateFluxDivergence_ECModel2D (this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this public subroutine CalculateTendency_ECModel2D (this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this public subroutine Free_ECModel2D (this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this public subroutine Init_ECModel2D (this, nvar, mesh, geometry, decomp) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), TARGET :: mesh type( SEMQuad ), intent(in), TARGET :: geometry type( MPILayer ), intent(in), TARGET :: decomp public subroutine Read_ECModel2D (this, fileName) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this character, intent(in) :: fileName public subroutine ReprojectFlux_ECModel2D (this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this public subroutine ResizePrevSol_ECModel2D (this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m public subroutine SetSolutionFromChar_ECModel2D (this, eqnChar) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_ECModel2D (this, eqn) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) public subroutine UpdateBoundary_ECModel2D (this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this public subroutine UpdateDevice_ECModel2D (this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this public subroutine UpdateGAB2_ECModel2D (this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGAB3_ECModel2D (this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGAB4_ECModel2D (this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK2_ECModel2D (this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK3_ECModel2D (this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK4_ECModel2D (this, m) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateHost_ECModel2D (this) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this public subroutine UpdateSolution_ECModel2D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the ECModel's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt public subroutine WriteTecplot_ECModel2D (this, filename) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this character, intent(in), optional :: filename public subroutine Write_ECModel2D (this, fileName) Arguments Type Intent Optional Attributes Name class( ECModel2D ), intent(inout) :: this character, intent(in), optional :: fileName","tags":"","loc":"module/self_ecmodel2d.html"},{"title":"SELF_SupportRoutines.f90 – SELF","text":"Contents Modules SELF_SupportRoutines Source Code SELF_SupportRoutines.f90 Source Code ! SELF_SupportRoutines.f90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! !> \\file SELF_SupportRoutines.f90 !! Contains the \\ref SELF_SupportRoutines module !> \\defgroup SELF_SupportRoutines SELF_SupportRoutines !! This module defines a set of general purpose routines. MODULE SELF_SupportRoutines USE ISO_FORTRAN_ENV USE SELF_Constants IMPLICIT NONE INTERFACE AlmostEqual MODULE PROCEDURE AlmostEqual_r64 END INTERFACE AlmostEqual REAL ( prec ), PRIVATE , PARAMETER :: tolerance = 1 0.0 ** ( - 10 ) CONTAINS !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! Function AlmostEqual ! !> \\fn AlmostEqual !! Compares two floating point numbers and determines if they are equal (to machine precision). !! !!   This function is from Alg. 139 on pg. 359 of D.A. Kopriva, 2009, \"Implementing Spectral Element !!    Methods for Scientists and Engineers\" !! !! <H2> Usage : </H2> !! <B>Logical</B> :: AisB <BR> !! <B>REAL</B>(prec) :: a, b <BR> !!         .... <BR> !!     AisB = AlmostEqual( a, b ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> a <td> REAL(prec) <td> scalar !!   <tr> <td> in <th> b <td> REAL(prec) <td> scalar !!   <tr> <td> in <th> AisB <td> Logical <td> !!                     <B>.TRUE.</B> IF a=b to machine precision <BR> !!                     <B>.FALSE.</B> otherwise !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION AlmostEqual_r64 ( a , b ) RESULT ( AisB ) IMPLICIT NONE REAL ( real64 ) :: a , b LOGICAL :: AisB IF ( a == 0.0_real64 . OR . b == 0.0_real64 ) THEN IF ( ABS ( a - b ) <= EPSILON ( 1.0_real64 )) THEN AisB = . TRUE . ELSE AisB = . FALSE . END IF ELSE IF (( abs ( a - b ) <= EPSILON ( 1.0_real64 ) * abs ( a )) . OR . ( abs ( a - b ) <= EPSILON ( 1.0_real64 ) * abs ( b ))) THEN AisB = . TRUE . ELSE AisB = . FALSE . END IF END IF END FUNCTION AlmostEqual_r64 !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R ForwardShift ! !> \\fn ForwardShift !! Shift an array integers by one index forward, moving the last index to the first. !! !! Shifts the array entries as follows : <BR> !!  myArray(1) <-- myArray(N) <BR> !!  myArray(2) <-- myArray(1) <BR> !!  myArray(3) <-- myArray(2) <BR> !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: N !! <B>INTEGER</B> :: myArray(1:N) <BR> !!         .... <BR> !!     <B>CALL</B> ForwardShift( myArray, N ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myArray(1:N) <td> INTEGER <td> !!                         On <B>output</B>, the input array with elements shifted forward by !!                         one index. !!   <tr> <td> in <th> N <td> INTEGER <td> !!                     The number of elements in the array !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE ForwardShift ( myArray , N ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( inout ) :: myArray ( 1 : N ) ! LOCAL INTEGER :: temp ( 1 : N ) temp = myArray myArray ( 1 ) = temp ( N ) myArray ( 2 : N ) = temp ( 1 : N - 1 ) END SUBROUTINE ForwardShift ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R CompareArray ! !> \\fn CompareArray !! Compares to INTEGER arrays and determines if they are identical. !! !! A logical is returned that specifies whether or not two arrays are identical. To determine !! if the two arrays are identical, the sum of the difference between each element in the input !! array is calculated. If the arrays are identical, each contribution to the sum is zero and hence !! the sum is zero. If the sum is non-zero, the arrays are distinct. !! !! This routine is used in the \\ref HexMeshClass module. A face of an element in an unstructured !! mesh is identified by its four corner nodes. When identifying unique faces in an unstructured !! mesh, we need to determine if two elements share a face. This can be accomplished by comparing !! the four corner nodes (from each element) that define each face. !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: N <BR> !! <B>INTEGER</B> :: arrayOne(1:N) <BR> !! <B>INTEGER</B> :: arrayTwo(1:N) <BR> !! <B>LOGICAL</B> :: arraysMatch <BR> !!         .... <BR> !!     arraysMatch = CompareArray( arrayOne, arrayTwo, N ) <BR> !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> arrayOne(1:N) <td> INTEGER <td> !!   <tr> <td> in <th> arrayTwo(1:N) <td> INTEGER <td> !!   <tr> <td> in <th> N <td> INTEGER <td> !!   <tr> <td> out <th> arraysMatch <td> INTEGER <td> !! !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION CompareArray ( arrayOne , arrayTwo , N ) RESULT ( arraysMatch ) IMPLICIT NONE INTEGER :: N INTEGER :: arrayOne ( 1 : N ), arrayTwo ( 1 : N ) LOGICAL :: arraysMatch ! LOCAL INTEGER :: i , theSumOfDiffs theSumOfDiffs = 0 DO i = 1 , N theSumOfDiffs = theSumOfDiffs + ABS ( arrayOne ( i ) - arrayTwo ( i )) END DO IF ( theSumOfDiffs == 0 ) THEN arraysMatch = . TRUE . ELSE arraysMatch = . FALSE . END IF END FUNCTION CompareArray ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R UniformPoints ! !> \\fn UniformPoints !! Generates a REAL(prec) array of N points evenly spaced between two points. !! !! !! <H2> Usage : </H2> !! <B>REAL</B>(prec) :: a <BR> !! <B>REAL</B>(prec) :: b <BR> !! <B>REAL</B>(prec) :: xU(0:N) <BR> !! <B>INTEGER</B> :: N <BR> !!         .... <BR> !!     xU = UniformPoints( a, b, N ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> a <td> REAL(prec) <td> Starting point of the interval !!   <tr> <td> in <th> b <td> REAL(prec) <td> Ending point of the interval !!   <tr> <td> in <th> N <td> INTEGER <td> The number of points in the interval \\f$[a,b]\\f$ !!   <tr> <td> in <th> xU(0:N) <td> REAL(prec) <td> !!                     Array of evenly spaced points in the interval \\f$[a,b]\\f$ !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION UniformPoints ( a , b , firstInd , lastInd ) RESULT ( xU ) IMPLICIT NONE REAL ( prec ) :: a , b INTEGER :: firstInd , lastInd REAL ( prec ) :: xU ( firstInd : lastInd ) ! LOCAL REAL ( prec ) :: dx INTEGER :: i dx = ( b - a ) / REAL (( lastInd - firstInd ), prec ) DO i = firstInd , lastInd xU ( i ) = a + dx * REAL ( i - firstInd , prec ) END DO END FUNCTION UniformPoints integer function newunit ( unit ) !  https://fortranwiki.org/fortran/show/newunit integer , intent ( out ), optional :: unit ! local integer , parameter :: LUN_MIN = 10 , LUN_MAX = 1000 logical :: opened integer :: lun ! begin newunit =- 1 do lun = LUN_MIN , LUN_MAX inquire ( unit = lun , opened = opened ) if (. not . opened ) then newunit = lun exit end if end do if ( present ( unit )) unit = newunit end function newunit FUNCTION UpperCase ( str ) RESULT ( upper ) Implicit None CHARACTER ( * ), INTENT ( In ) :: str CHARACTER ( LEN ( str )) :: Upper INTEGER :: ic , i CHARACTER ( 27 ), PARAMETER :: cap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ ' CHARACTER ( 27 ), PARAMETER :: low = 'abcdefghijklmnopqrstuvwxyz ' DO i = 1 , LEN ( str ) ic = INDEX ( low , str ( i : i )) IF ( ic > 0 ) THEN Upper ( i : i ) = cap ( ic : ic ) ELSE Upper ( i : i ) = str ( i : i ) END IF END DO END FUNCTION UpperCase END MODULE SELF_SupportRoutines","tags":"","loc":"sourcefile/self_supportroutines.f90.html"},{"title":"SELF_Model3D.f90 – SELF","text":"Contents Modules SELF_Model3D Source Code SELF_Model3D.f90 Source Code ! ! Copyright 2020-2022 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : support@fluidnumerics.com ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Model3D USE SELF_SupportRoutines USE SELF_Metadata USE SELF_Mesh USE SELF_MappedData USE SELF_HDF5 USE HDF5 USE FEQParse USE SELF_Model IMPLICIT NONE #include \"SELF_Macros.h\" TYPE , EXTENDS ( Model ) :: Model3D TYPE ( MappedScalar3D ) :: solution TYPE ( MappedVector3D ) :: solutionGradient TYPE ( MappedVector3D ) :: flux TYPE ( MappedScalar3D ) :: source TYPE ( MappedScalar3D ) :: fluxDivergence TYPE ( MappedScalar3D ) :: dSdt TYPE ( MappedScalar3D ) :: workSol TYPE ( MappedScalar3D ) :: prevSol TYPE ( Mesh3D ), POINTER :: mesh TYPE ( SEMHex ), POINTER :: geometry CONTAINS PROCEDURE :: Init => Init_Model3D PROCEDURE :: Free => Free_Model3D PROCEDURE :: UpdateHost => UpdateHost_Model3D PROCEDURE :: UpdateDevice => UpdateDevice_Model3D PROCEDURE :: UpdateSolution => UpdateSolution_Model3D PROCEDURE :: ResizePrevSol => ResizePrevSol_Model3D PROCEDURE :: UpdateGAB2 => UpdateGAB2_Model3D PROCEDURE :: UpdateGAB3 => UpdateGAB3_Model3D PROCEDURE :: UpdateGAB4 => UpdateGAB4_Model3D PROCEDURE :: UpdateGRK2 => UpdateGRK2_Model3D PROCEDURE :: UpdateGRK3 => UpdateGRK3_Model3D PROCEDURE :: UpdateGRK4 => UpdateGRK4_Model3D PROCEDURE :: CalculateTendency => CalculateTendency_Model3D PROCEDURE :: CalculateFluxDivergence => CalculateFluxDivergence_Model3D GENERIC :: SetSolution => SetSolutionFromChar_Model3D , & SetSolutionFromEqn_Model3D PROCEDURE , PRIVATE :: SetSolutionFromChar_Model3D PROCEDURE , PRIVATE :: SetSolutionFromEqn_Model3D PROCEDURE :: ReprojectFlux => ReprojectFlux_Model3D PROCEDURE :: ReadModel => Read_Model3D PROCEDURE :: WriteModel => Write_Model3D PROCEDURE :: WriteTecplot => WriteTecplot_Model3D END TYPE Model3D INTERFACE SUBROUTINE UpdateSolution_Model3D_gpu_wrapper ( solution , dSdt , dt , N , nVar , nEl ) & BIND ( c , name = \"UpdateSolution_Model3D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( C_PTR ) :: solution , dSdt INTEGER ( C_INT ), VALUE :: N , nVar , nEl REAL ( c_prec ), VALUE :: dt END SUBROUTINE UpdateSolution_Model3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE UpdateGAB2_Model3D_gpu_wrapper ( prevsol , solution , m , nPrev , N , nVar , nEl ) & BIND ( c , name = \"UpdateGAB2_Model3D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( C_PTR ) :: prevsol , solution INTEGER ( C_INT ), VALUE :: m , nPrev , N , nVar , nEl END SUBROUTINE UpdateGAB2_Model3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE UpdateGAB3_Model3D_gpu_wrapper ( prevsol , solution , m , nPrev , N , nVar , nEl ) & BIND ( c , name = \"UpdateGAB3_Model3D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( C_PTR ) :: prevsol , solution INTEGER ( C_INT ), VALUE :: m , nPrev , N , nVar , nEl END SUBROUTINE UpdateGAB3_Model3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE UpdateGAB4_Model3D_gpu_wrapper ( prevsol , solution , m , nPrev , N , nVar , nEl ) & BIND ( c , name = \"UpdateGAB4_Model3D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( C_PTR ) :: prevsol , solution INTEGER ( C_INT ), VALUE :: m , nPrev , N , nVar , nEl END SUBROUTINE UpdateGAB4_Model3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE UpdateGRK_Model3D_gpu_wrapper ( grk , solution , dSdt , rk_a , rk_g , dt , nWork , N , nVar , nEl ) & BIND ( c , name = \"UpdateGRK_Model3D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( C_PTR ) :: grk , solution , dSdt INTEGER ( C_INT ), VALUE :: nWork , N , nVar , nEl REAL ( c_prec ), VALUE :: rk_a , rk_g , dt END SUBROUTINE UpdateGRK_Model3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE CalculateDSDt_Model3D_gpu_wrapper ( fluxDivergence , source , dSdt , N , nVar , nEl ) & BIND ( c , name = \"CalculateDSDt_Model3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( C_PTR ) :: fluxDivergence , source , dSdt INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE CalculateDSDt_Model3D_gpu_wrapper END INTERFACE CONTAINS SUBROUTINE Init_Model3D ( this , nvar , mesh , geometry , decomp ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: nvar TYPE ( Mesh3D ), INTENT ( in ), TARGET :: mesh TYPE ( SEMHex ), INTENT ( in ), TARGET :: geometry TYPE ( MPILayer ), INTENT ( in ), TARGET :: decomp ! Local INTEGER :: ivar CHARACTER ( LEN = 3 ) :: ivarChar CHARACTER ( LEN = 25 ) :: varname this % decomp => decomp this % mesh => mesh this % geometry => geometry this % gpuAccel = . FALSE . CALL this % solution % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % workSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % prevSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % dSdt % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % solutionGradient % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % flux % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % source % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % fluxDivergence % Init ( geometry % x % interp , nVar , this % mesh % nElem ) ! set default metadata DO ivar = 1 , nvar WRITE ( ivarChar , '(I3.3)' ) ivar varname = \"solution\" // TRIM ( ivarChar ) CALL this % solution % SetName ( ivar , varname ) CALL this % solution % SetUnits ( ivar , \"[null]\" ) END DO END SUBROUTINE Init_Model3D SUBROUTINE Free_Model3D ( this ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CALL this % solution % Free () CALL this % workSol % Free () CALL this % prevSol % Free () CALL this % dSdt % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () END SUBROUTINE Free_Model3D SUBROUTINE ResizePrevSol_Model3D ( this , m ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: nVar ! Free space, if necessary CALL this % prevSol % Free () ! Reallocate with increased variable dimension for ! storing \"m\" copies of solution data nVar = this % solution % nVar CALL this % prevSol % Init ( this % geometry % x % interp , m * nVar , this % mesh % nElem ) END SUBROUTINE ResizePrevSol_Model3D SUBROUTINE UpdateHost_Model3D ( this ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CALL this % mesh % UpdateHost () CALL this % geometry % UpdateHost () CALL this % solution % UpdateHost () CALL this % dSdt % UpdateHost () CALL this % solution % UpdateHost () CALL this % solutionGradient % UpdateHost () CALL this % flux % UpdateHost () CALL this % source % UpdateHost () CALL this % fluxDivergence % UpdateHost () END SUBROUTINE UpdateHost_Model3D SUBROUTINE UpdateDevice_Model3D ( this ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CALL this % mesh % UpdateDevice () CALL this % geometry % UpdateDevice () CALL this % dSdt % UpdateDevice () CALL this % solution % UpdateDevice () CALL this % solutionGradient % UpdateDevice () CALL this % flux % UpdateDevice () CALL this % source % UpdateDevice () CALL this % fluxDivergence % UpdateDevice () END SUBROUTINE UpdateDevice_Model3D SUBROUTINE SetSolutionFromEqn_Model3D ( this , eqn ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar ! Copy the equation parser DO iVar = 1 , this % solution % nVar CALL this % solution % SetEquation ( ivar , eqn ( iVar ) % equation ) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromEqn_Model3D SUBROUTINE SetSolutionFromChar_Model3D ( this , eqnChar ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: eqnChar ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar DO iVar = 1 , this % solution % nVar CALL this % solution % SetEquation ( ivar , TRIM ( eqnChar ( iVar ))) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromChar_Model3D SUBROUTINE UpdateSolution_Model3D ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this REAL ( prec ), OPTIONAL , INTENT ( in ) :: dt ! Local REAL ( prec ) :: dtLoc INTEGER :: i , j , k , iVar , iEl IF ( PRESENT ( dt )) THEN dtLoc = dt ELSE dtLoc = this % dt END IF IF ( this % gpuAccel ) THEN CALL UpdateSolution_Model3D_gpu_wrapper ( this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & dtLoc , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & this % solution % interior % hostData ( i , j , k , iVar , iEl ) + & dtLoc * this % dSdt % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO END IF END SUBROUTINE UpdateSolution_Model3D SUBROUTINE UpdateGAB2_Model3D ( this , m ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , k , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB2_Model3D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE ! ab2_weight IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSEIF ( m == 1 ) THEN ! Reset solution DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , k , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last solution this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & 1.5_PREC * this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) - & 0.5_PREC * this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) END DO END DO ENDDO END DO END DO END IF END IF END SUBROUTINE UpdateGAB2_Model3D SUBROUTINE UpdateGAB3_Model3D ( this , m ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , k , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB3_Model3D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSEIF ( m == 2 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , k , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions this % prevSol % interior % hostData ( i , j , k , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & ( 2 3.0_PREC * this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) - & 1 6.0_PREC * this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) + & 5.0_PREC * this % prevSol % interior % hostData ( i , j , k , 2 * nVar + iVar , iEl )) / 1 2.0_PREC END DO END DO ENDDO END DO END DO END IF END IF END SUBROUTINE UpdateGAB3_Model3D SUBROUTINE UpdateGAB4_Model3D ( this , m ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , k , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB4_Model3D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , k , 2 * nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSEIF ( m == 2 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO ELSEIF ( m == 3 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , k , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) END DO ENDDO END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions this % prevSol % interior % hostData ( i , j , k , 3 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , 2 * nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , k , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) = this % solution % interior % hostData ( i , j , k , iVar , iEl ) this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & ( 5 5.0_PREC * this % prevSol % interior % hostData ( i , j , k , iVar , iEl ) - & 5 9.0_PREC * this % prevSol % interior % hostData ( i , j , k , nVar + iVar , iEl ) + & 3 7.0_PREC * this % prevSol % interior % hostData ( i , j , k , 2 * nVar + iVar , iEl ) - & 9.0_PREC * this % prevSol % interior % hostData ( i , j , k , 3 * nVar + iVar , iEl )) / 2 4.0_PREC END DO END DO ENDDO END DO END DO END IF END IF END SUBROUTINE UpdateGAB4_Model3D SUBROUTINE UpdateGRK2_Model3D ( this , m ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , k , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model3D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk2_a ( m ), rk2_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , k , iVar , iEl ) = rk2_a ( m ) * & this % workSol % interior % hostData ( i , j , k , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , k , iVar , iEl ) this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & this % solution % interior % hostData ( i , j , k , iVar , iEl ) + & rk2_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , k , iVar , iEl ) END DO ENDDO END DO END DO END DO END IF END SUBROUTINE UpdateGRK2_Model3D SUBROUTINE UpdateGRK3_Model3D ( this , m ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , k , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model3D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk3_a ( m ), rk3_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , k , iVar , iEl ) = rk3_a ( m ) * & this % workSol % interior % hostData ( i , j , k , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , k , iVar , iEl ) this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & this % solution % interior % hostData ( i , j , k , iVar , iEl ) + & rk3_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO END IF END SUBROUTINE UpdateGRK3_Model3D SUBROUTINE UpdateGRK4_Model3D ( this , m ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , k , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model3D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk4_a ( m ), rk4_g ( m ), this % dt , & this % workSol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , k , iVar , iEl ) = rk4_a ( m ) * & this % workSol % interior % hostData ( i , j , k , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , k , iVar , iEl ) this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & this % solution % interior % hostData ( i , j , k , iVar , iEl ) + & rk4_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO END IF END SUBROUTINE UpdateGRK4_Model3D SUBROUTINE ReprojectFlux_Model3D ( this ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CALL this % flux % ContravariantProjection ( this % geometry , this % gpuAccel ) END SUBROUTINE ReprojectFlux_Model3D SUBROUTINE CalculateFluxDivergence_Model3D ( this ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CALL this % flux % Divergence ( this % geometry , & this % fluxDivergence , & selfWeakDGForm , & this % gpuAccel ) END SUBROUTINE CalculateFluxDivergence_Model3D SUBROUTINE CalculateTendency_Model3D ( this ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this ! Local INTEGER :: i , j , k , iVar , iEl CALL this % PreTendency () CALL this % solution % BoundaryInterp ( this % gpuAccel ) CALL this % solution % SideExchange ( this % mesh , this % decomp , this % gpuAccel ) CALL this % SetBoundaryCondition () CALL this % SourceMethod () CALL this % RiemannSolver () CALL this % FluxMethod () CALL this % ReprojectFlux () CALL this % CalculateFluxDivergence () IF ( this % gpuAccel ) THEN CALL CalculateDSDt_Model3D_gpu_wrapper ( this % fluxDivergence % interior % deviceData , & this % source % interior % deviceData , & this % dSdt % interior % deviceData , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % interp % N DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % dSdt % interior % hostData ( i , j , k , iVar , iEl ) = & this % source % interior % hostData ( i , j , k , iVar , iEl ) - & this % fluxDivergence % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO ENDDO END DO END DO END IF END SUBROUTINE CalculateTendency_Model3D SUBROUTINE Write_Model3D ( this , fileName ) #undef __FUNC__ #define __FUNC__ \"Write_Model3D\" IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CHARACTER ( * ), OPTIONAL , INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId TYPE ( Scalar3D ) :: solution TYPE ( Vector3D ) :: x TYPE ( Lagrange ), TARGET :: interp CHARACTER ( LEN = self_FileNameLength ) :: pickupFile CHARACTER ( 13 ) :: timeStampString IF ( PRESENT ( filename )) THEN pickupFile = filename ELSE WRITE ( timeStampString , '(I13.13)' ) this % ioIterate pickupFile = 'solution.' // timeStampString // '.h5' END IF IF ( this % gpuAccel ) THEN CALL this % solution % UpdateHost () CALL this % solutionGradient % UpdateHost () END IF INFO ( \"Writing pickup file : \" // TRIM ( pickupFile )) IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId , this % decomp % mpiComm ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file INFO ( \"Writing control grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid/mesh' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/mesh/coords' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) CALL Close_HDF5 ( fileId ) ELSE CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' ) ! Write the geometry to file INFO ( \"Writing control grid  geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file INFO ( \"Writing target grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' ) ! Write the geometry to file INFO ( \"Writing target grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid/geometry' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/geometry/x' ) CALL Close_HDF5 ( fileId ) END IF CALL x % Free () CALL solution % Free () CALL interp % Free () END SUBROUTINE Write_Model3D SUBROUTINE Read_Model3D ( this , fileName ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 5 ) INTEGER :: firstElem INTEGER :: N IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % decomp % mpiComm ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) END IF ! CALL ReadAttribute_HDF5(fileId,'N',N) ! IF (this % solution % interp % N /= N) THEN !   STOP 'Error : Solution polynomial degree does not match input file' ! END IF IF ( this % decomp % mpiEnabled ) THEN firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 5 ) = ( / 0 , 0 , 0 , 1 , firstElem / ) CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , & this % solution % interior , solOffset ) ELSE CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , this % solution % interior ) END IF CALL Close_HDF5 ( fileId ) IF ( this % gpuAccel ) THEN CALL this % solution % interior % UpdateDevice () END IF END SUBROUTINE Read_Model3D SUBROUTINE WriteTecplot_Model3D ( this , filename ) IMPLICIT NONE CLASS ( Model3D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ), OPTIONAL :: filename ! Local CHARACTER ( 8 ) :: zoneID INTEGER :: fUnit INTEGER :: iEl , i , j , k , iVar CHARACTER ( LEN = self_FileNameLength ) :: tecFile CHARACTER ( LEN = self_TecplotHeaderLength ) :: tecHeader CHARACTER ( LEN = self_FormatLength ) :: fmat CHARACTER ( 13 ) :: timeStampString CHARACTER ( 5 ) :: rankString TYPE ( Scalar3D ) :: solution TYPE ( Vector3D ) :: solutionGradient TYPE ( Vector3D ) :: x TYPE ( Lagrange ), TARGET :: interp IF ( PRESENT ( filename )) THEN tecFile = filename ELSE WRITE ( timeStampString , '(I13.13)' ) this % ioIterate IF ( this % decomp % mpiEnabled ) THEN WRITE ( rankString , '(I5.5)' ) this % decomp % rankId tecFile = 'solution.' // rankString // '.' // timeStampString // '.tec' ELSE tecFile = 'solution.' // timeStampString // '.tec' END IF END IF ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL solutionGradient % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solutionGradient % GridInterp ( solutionGradient , gpuAccel = . FALSE .) OPEN ( UNIT = NEWUNIT ( fUnit ), & FILE = TRIM ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) tecHeader = 'VARIABLES = \"X\", \"Y\", \"Z\"' DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"' // TRIM ( this % solution % meta ( iVar ) % name ) // '\"' END DO DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"d/dx(' // TRIM ( this % solution % meta ( iVar ) % name ) // ')\"' END DO DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"d/dy(' // TRIM ( this % solution % meta ( iVar ) % name ) // ')\"' END DO WRITE ( fUnit , * ) TRIM ( tecHeader ) ! Create format statement WRITE ( fmat , * ) 3 * this % solution % nvar + 3 fmat = '(' // TRIM ( fmat ) // '(ES16.7E3,1x))' DO iEl = 1 , this % solution % nElem ! TO DO :: Get the global element ID WRITE ( zoneID , '(I8.8)' ) iEl WRITE ( fUnit , * ) 'ZONE T=\"el' // TRIM ( zoneID ) // '\", I=' , this % solution % interp % M + 1 , & ', J=' , this % solution % interp % M + 1 DO k = 0 , this % solution % interp % M DO j = 0 , this % solution % interp % M DO i = 0 , this % solution % interp % M WRITE ( fUnit , fmat ) x % interior % hostData ( 1 , i , j , k , 1 , iEl ), & x % interior % hostData ( 2 , i , j , k , 1 , iEl ), & x % interior % hostData ( 3 , i , j , k , 1 , iEl ), & solution % interior % hostData ( i , j , k , 1 : this % solution % nvar , iEl ), & solutionGradient % interior % hostData ( 1 , i , j , k , 1 : this % solution % nvar , iEl ), & solutionGradient % interior % hostData ( 2 , i , j , k , 1 : this % solution % nvar , iEl ), & solutionGradient % interior % hostData ( 3 , i , j , k , 1 : this % solution % nvar , iEl ) END DO END DO ENDDO END DO CLOSE ( UNIT = fUnit ) CALL x % Free () CALL solution % Free () CALL interp % Free () END SUBROUTINE WriteTecplot_Model3D END MODULE SELF_Model3D","tags":"","loc":"sourcefile/self_model3d.f90.html"},{"title":"SELF_Lagrange.f90 – SELF","text":"Contents Modules SELF_Lagrange Source Code SELF_Lagrange.f90 Source Code ! SELF_Lagrange.f90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Lagrange USE ISO_FORTRAN_ENV USE SELF_Constants USE SELF_Memory USE SELF_SupportRoutines USE SELF_Quadrature USE SELF_HDF5 USE HDF5 USE ISO_C_BINDING IMPLICIT NONE TYPE , PUBLIC :: Lagrange !! A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions. !! The Lagrange data-structure stores the information necessary to interpolate between two !! sets of grid-points and to estimate the derivative of data at native grid points. Routines for !! multidimensional interpolation are based on the tensor product of 1-D interpolants. It is !! assumed that the polynomial degree (and the interpolation nodes) are the same in each direction. !! This assumption permits the storage of only one array of interpolation nodes and barycentric !! weights and is what allows this data structure to be flexible. INTEGER :: N !! The number of control points. INTEGER :: controlNodeType INTEGER :: M !! The number of target points. INTEGER :: targetNodeType TYPE ( hfReal_r1 ) :: controlPoints !! The set of nodes in one dimension where data is known. !! To create higher dimension interpolation and differentiation operators, structured grids in two and three !! dimensions are created by tensor products of the controlPoints. This design decision implies that all !! spectral element methods supported by the Lagrange class have the same polynomial degree in each !! computational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto, !! Legendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over !! the domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of !! these quadrature types or uniform points on [-1,1]. TYPE ( hfReal_r1 ) :: targetPoints !! The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation !! and differentiation operators, structured grids in two and three dimensions are created by tensor products of !! the targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1] !! (computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. TYPE ( hfReal_r1 ) :: bWeights !! The barycentric weights that are calculated from the controlPoints and used for interpolation. TYPE ( hfReal_r1 ) :: qWeights !! The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints !! provided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss, !! Chebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant !! dx = \\frac{2.0}{N+1}. TYPE ( hfReal_r2 ) :: iMatrix !! The interpolation matrix (transpose) for mapping data from the control grid to the target grid. TYPE ( hfReal_r2 ) :: dMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The !! dMatrix is based on a strong form of the derivative. TYPE ( hfReal_r2 ) :: dgMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based !! on a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. TYPE ( hfReal_r2 ) :: bMatrix !! The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. CONTAINS PROCEDURE , PUBLIC :: Init => Init_Lagrange PROCEDURE , PUBLIC :: Free => Free_Lagrange PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Lagrange PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Lagrange GENERIC , PUBLIC :: ScalarGridInterp_1D => ScalarGridInterp_1D_cpu , ScalarGridInterp_1D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_1D_cpu , ScalarGridInterp_1D_gpu GENERIC , PUBLIC :: ScalarGridInterp_2D => ScalarGridInterp_2D_cpu , ScalarGridInterp_2D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_2D_cpu , ScalarGridInterp_2D_gpu GENERIC , PUBLIC :: VectorGridInterp_2D => VectorGridInterp_2D_cpu , VectorGridInterp_2D_gpu PROCEDURE , PRIVATE :: VectorGridInterp_2D_cpu , VectorGridInterp_2D_gpu ! GENERIC,PUBLIC :: TensorGridInterp_2D => TensorGridInterp_2D_cpu,TensorGridInterp_2D_gpu ! PROCEDURE,PRIVATE :: TensorGridInterp_2D_cpu,TensorGridInterp_2D_gpu GENERIC , PUBLIC :: ScalarGridInterp_3D => ScalarGridInterp_3D_cpu , ScalarGridInterp_3D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_3D_cpu , ScalarGridInterp_3D_gpu GENERIC , PUBLIC :: VectorGridInterp_3D => VectorGridInterp_3D_cpu , VectorGridInterp_3D_gpu PROCEDURE , PRIVATE :: VectorGridInterp_3D_cpu , VectorGridInterp_3D_gpu ! GENERIC,PUBLIC :: TensorGridInterp_3D => TensorGridInterp_3D_cpu,TensorGridInterp_3D_gpu ! PROCEDURE,PRIVATE :: TensorGridInterp_3D_cpu,TensorGridInterp_3D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_1D => ScalarBoundaryInterp_1D_cpu , ScalarBoundaryInterp_1D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_1D_cpu , ScalarBoundaryInterp_1D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_2D => ScalarBoundaryInterp_2D_cpu , ScalarBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_2D_cpu , ScalarBoundaryInterp_2D_gpu GENERIC , PUBLIC :: VectorBoundaryInterp_2D => VectorBoundaryInterp_2D_cpu , VectorBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: VectorBoundaryInterp_2D_cpu , VectorBoundaryInterp_2D_gpu GENERIC , PUBLIC :: TensorBoundaryInterp_2D => TensorBoundaryInterp_2D_cpu , TensorBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: TensorBoundaryInterp_2D_cpu , TensorBoundaryInterp_2D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_3D => ScalarBoundaryInterp_3D_cpu , ScalarBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_3D_cpu , ScalarBoundaryInterp_3D_gpu GENERIC , PUBLIC :: VectorBoundaryInterp_3D => VectorBoundaryInterp_3D_cpu , VectorBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: VectorBoundaryInterp_3D_cpu , VectorBoundaryInterp_3D_gpu GENERIC , PUBLIC :: TensorBoundaryInterp_3D => TensorBoundaryInterp_3D_cpu , TensorBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: TensorBoundaryInterp_3D_cpu , TensorBoundaryInterp_3D_gpu GENERIC , PUBLIC :: Derivative_1D => Derivative_1D_cpu , Derivative_1D_gpu PROCEDURE , PRIVATE :: Derivative_1D_cpu , Derivative_1D_gpu GENERIC , PUBLIC :: DGDerivative_1D => DGDerivative_1D_cpu , DGDerivative_1D_gpu PROCEDURE , PRIVATE :: DGDerivative_1D_cpu , DGDerivative_1D_gpu GENERIC , PUBLIC :: ScalarGradient_2D => ScalarGradient_2D_cpu , ScalarGradient_2D_gpu PROCEDURE , PRIVATE :: ScalarGradient_2D_cpu , ScalarGradient_2D_gpu ! GENERIC,PUBLIC :: ScalarDGGradient_2D => ScalarDGGradient_2D_cpu,ScalarDGGradient_2D_gpu ! PROCEDURE,PRIVATE :: ScalarDGGradient_2D_cpu,ScalarDGGradient_2D_gpu GENERIC , PUBLIC :: VectorGradient_2D => VectorGradient_2D_cpu , VectorGradient_2D_gpu PROCEDURE , PRIVATE :: VectorGradient_2D_cpu , VectorGradient_2D_gpu ! GENERIC,PUBLIC :: VectorDGGradient_2D => VectorDGGradient_2D_cpu,VectorDGGradient_2D_gpu ! PROCEDURE,PRIVATE :: VectorDGGradient_2D_cpu,VectorDGGradient_2D_gpu GENERIC , PUBLIC :: VectorDivergence_2D => VectorDivergence_2D_cpu , VectorDivergence_2D_gpu PROCEDURE , PRIVATE :: VectorDivergence_2D_cpu , VectorDivergence_2D_gpu GENERIC , PUBLIC :: VectorDGDivergence_2D => VectorDGDivergence_2D_cpu , VectorDGDivergence_2D_gpu PROCEDURE , PRIVATE :: VectorDGDivergence_2D_cpu , VectorDGDivergence_2D_gpu ! GENERIC,PUBLIC :: P2VectorDivergence_2D => P2VectorDivergence_2D_cpu,P2VectorDivergence_2D_gpu ! PROCEDURE,PRIVATE :: P2VectorDivergence_2D_cpu,P2VectorDivergence_2D_gpu ! GENERIC,PUBLIC :: P2VectorDGDivergence_2D => P2VectorDGDivergence_2D_cpu,P2VectorDGDivergence_2D_gpu ! PROCEDURE,PRIVATE :: P2VectorDGDivergence_2D_cpu,P2VectorDGDivergence_2D_gpu ! GENERIC,PUBLIC :: VectorCurl_2D => VectorCurl_2D_cpu,VectorCurl_2D_gpu ! PROCEDURE,PRIVATE :: VectorCurl_2D_cpu,VectorCurl_2D_gpu ! GENERIC,PUBLIC :: TensorDivergence_2D => TensorDivergence_2D_cpu,TensorDivergence_2D_gpu ! PROCEDURE,PRIVATE :: TensorDivergence_2D_cpu,TensorDivergence_2D_gpu ! GENERIC,PUBLIC :: TensorDGDivergence_2D => TensorDGDivergence_2D_cpu,TensorDGDivergence_2D_gpu ! PROCEDURE,PRIVATE :: TensorDGDivergence_2D_cpu,TensorDGDivergence_2D_gpu GENERIC , PUBLIC :: ScalarGradient_3D => ScalarGradient_3D_cpu , ScalarGradient_3D_gpu PROCEDURE , PRIVATE :: ScalarGradient_3D_cpu , ScalarGradient_3D_gpu GENERIC , PUBLIC :: VectorGradient_3D => VectorGradient_3D_cpu , VectorGradient_3D_gpu PROCEDURE , PRIVATE :: VectorGradient_3D_cpu , VectorGradient_3D_gpu GENERIC , PUBLIC :: VectorDivergence_3D => VectorDivergence_3D_cpu , VectorDivergence_3D_gpu PROCEDURE , PRIVATE :: VectorDivergence_3D_cpu , VectorDivergence_3D_gpu GENERIC , PUBLIC :: VectorDGDivergence_3D => VectorDGDivergence_3D_cpu , VectorDGDivergence_3D_gpu PROCEDURE , PRIVATE :: VectorDGDivergence_3D_cpu , VectorDGDivergence_3D_gpu ! GENERIC,PUBLIC :: VectorCurl_3D => VectorCurl_3D_cpu,VectorCurl_3D_gpu ! PROCEDURE,PRIVATE :: VectorCurl_3D_cpu,VectorCurl_3D_gpu ! GENERIC,PUBLIC :: TensorDivergence_3D => TensorDivergence_3D_cpu,TensorDivergence_3D_gpu ! PROCEDURE,PRIVATE :: TensorDivergence_3D_cpu,TensorDivergence_3D_gpu ! GENERIC,PUBLIC :: TensorDGDivergence_3D => TensorDGDivergence_3D_cpu,TensorDGDivergence_3D_gpu ! PROCEDURE,PRIVATE :: TensorDGDivergence_3D_cpu,TensorDGDivergence_3D_gpu PROCEDURE , PUBLIC :: WriteHDF5 => WriteHDF5_Lagrange PROCEDURE , PRIVATE :: CalculateBarycentricWeights PROCEDURE , PRIVATE :: CalculateInterpolationMatrix PROCEDURE , PRIVATE :: CalculateDerivativeMatrix PROCEDURE , PRIVATE :: CalculateLagrangePolynomials END TYPE Lagrange INTERFACE SUBROUTINE ScalarGridInterp_1D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"ScalarGridInterp_1D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER ( C_INT ), VALUE :: N , M , nVar , nEl END SUBROUTINE ScalarGridInterp_1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarGridInterp_2D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"ScalarGridInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER ( C_INT ), VALUE :: N , M , nVar , nEl END SUBROUTINE ScalarGridInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorGridInterp_2D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"VectorGridInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER ( C_INT ), VALUE :: N , M , nVar , nEl END SUBROUTINE VectorGridInterp_2D_gpu_wrapper END INTERFACE ! INTERFACE !   SUBROUTINE TensorGridInterp_2D_gpu_wrapper(iMatrixT_dev,f_dev,fInterp_dev,N,M,nVar,nEl) & !     bind(c,name=\"TensorGridInterp_2D_gpu_wrapper\") !     USE iso_c_binding !     IMPLICIT NONE !     TYPE(c_ptr) :: iMatrixT_dev,f_dev,fInterp_dev !     INTEGER(C_INT),VALUE :: N,M,nVar,nEl !   END SUBROUTINE TensorGridInterp_2D_gpu_wrapper ! END INTERFACE INTERFACE SUBROUTINE ScalarGridInterp_3D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"ScalarGridInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER ( C_INT ), VALUE :: N , M , nVar , nEl END SUBROUTINE ScalarGridInterp_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorGridInterp_3D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"VectorGridInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER ( C_INT ), VALUE :: N , M , nVar , nEl END SUBROUTINE VectorGridInterp_3D_gpu_wrapper END INTERFACE ! INTERFACE !   SUBROUTINE TensorGridInterp_3D_gpu_wrapper(iMatrixT_dev,f_dev,fInterp_dev,N,M,nVar,nEl) & !     bind(c,name=\"TensorGridInterp_3D_gpu_wrapper\") !     USE iso_c_binding !     IMPLICIT NONE !     TYPE(c_ptr) :: iMatrixT_dev,f_dev,fInterp_dev !     INTEGER(C_INT),VALUE :: N,M,nVar,nEl !   END SUBROUTINE TensorGridInterp_3D_gpu_wrapper ! END INTERFACE ! /////////////// ! ! Boundary Interpolation Routines INTERFACE SUBROUTINE ScalarBoundaryInterp_1D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarBoundaryInterp_1D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ScalarBoundaryInterp_1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarBoundaryInterp_2D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarBoundaryInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ScalarBoundaryInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorBoundaryInterp_2D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"VectorBoundaryInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorBoundaryInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorBoundaryInterp_2D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"TensorBoundaryInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE TensorBoundaryInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarBoundaryInterp_3D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarBoundaryInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ScalarBoundaryInterp_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorBoundaryInterp_3D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"VectorBoundaryInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorBoundaryInterp_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorBoundaryInterp_3D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"TensorBoundaryInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE TensorBoundaryInterp_3D_gpu_wrapper END INTERFACE ! /////////////// ! INTERFACE SUBROUTINE Derivative_1D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"Derivative_1D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE Derivative_1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE DGDerivative_1D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"DGDerivative_1D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE DGDerivative_1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarGradient_2D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarGradient_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ScalarGradient_2D_gpu_wrapper END INTERFACE ! INTERFACE !   SUBROUTINE ScalarDGGradient_2D_gpu_wrapper(dgMatrixT_dev,bMatrix_dev,qWeights_dev,f_dev,bf_dev,df_dev,N,nVar,nEl) & !     bind(c,name=\"ScalarDGGradient_2D_gpu_wrapper\") !     USE iso_c_binding !     IMPLICIT NONE !     TYPE(c_ptr) :: dgMatrixT_dev,bMatrix_dev,qWeights_dev,f_dev,bf_dev,df_dev !     INTEGER(C_INT),VALUE :: N,nVar,nEl !   END SUBROUTINE ScalarDGGradient_2D_gpu_wrapper ! END INTERFACE INTERFACE SUBROUTINE VectorGradient_2D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorGradient_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorGradient_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorDGGradient_2D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorDGGradient_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorDGGradient_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorDivergence_2D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorDivergence_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorDivergence_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorDGDivergence_2D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorDGDivergence_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorDGDivergence_2D_gpu_wrapper END INTERFACE ! INTERFACE !   SUBROUTINE P2VectorDivergence_2D_gpu_wrapper(dMatrixT_dev,f_dev,df_dev,N,nVar,nEl) & !     bind(c,name=\"P2VectorDivergence_2D_gpu_wrapper\") !     USE iso_c_binding !     IMPLICIT NONE !     TYPE(c_ptr) :: dMatrixT_dev,f_dev,df_dev !     INTEGER(C_INT),VALUE :: N,nVar,nEl !   END SUBROUTINE P2VectorDivergence_2D_gpu_wrapper ! END INTERFACE ! INTERFACE !  SUBROUTINE P2VectorDGDivergence_2D_gpu_wrapper(dgMatrixT_dev,bMatrix_dev,qWeights_dev,f_dev,bf_dev,df_dev,N,nVar,nEl) & !     bind(c,name=\"P2VectorDGDivergence_2D_gpu_wrapper\") !     USE iso_c_binding !     IMPLICIT NONE !     TYPE(c_ptr) :: dgMatrixT_dev,bMatrix_dev,qWeights_dev,f_dev,bf_dev,df_dev !     INTEGER(C_INT),VALUE :: N,nVar,nEl !   END SUBROUTINE P2VectorDGDivergence_2D_gpu_wrapper ! END INTERFACE ! INTERFACE !   SUBROUTINE VectorCurl_2D_gpu_wrapper(dMatrixT_dev,f_dev,df_dev,N,nVar,nEl) & !     bind(c,name=\"VectorCurl_2D_gpu_wrapper\") !     USE iso_c_binding !     IMPLICIT NONE !     TYPE(c_ptr) :: dMatrixT_dev,f_dev,df_dev !     INTEGER(C_INT),VALUE :: N,nVar,nEl !   END SUBROUTINE VectorCurl_2D_gpu_wrapper ! END INTERFACE ! INTERFACE !   SUBROUTINE TensorDivergence_2D_gpu_wrapper(dMatrixT_dev,f_dev,df_dev,N,nVar,nEl) & !     bind(c,name=\"TensorDivergence_2D_gpu_wrapper\") !     USE iso_c_binding !     IMPLICIT NONE !     TYPE(c_ptr) :: dMatrixT_dev,f_dev,df_dev !     INTEGER(C_INT),VALUE :: N,nVar,nEl !   END SUBROUTINE TensorDivergence_2D_gpu_wrapper ! END INTERFACE ! INTERFACE !   SUBROUTINE TensorDGDivergence_2D_gpu_wrapper(dMatrixT_dev,bMatrix_dev,qWeights_dev,f_dev,bf_dev,df_dev,N,nVar,nEl) & !     bind(c,name=\"TensorDGDivergence_2D_gpu_wrapper\") !     USE iso_c_binding !     IMPLICIT NONE !     TYPE(c_ptr) :: dMatrixT_dev,bMatrix_dev,qWeights_dev,f_dev,bf_dev,df_dev !     INTEGER(C_INT),VALUE :: N,nVar,nEl !   END SUBROUTINE TensorDGDivergence_2D_gpu_wrapper ! END INTERFACE INTERFACE SUBROUTINE ScalarGradient_3D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarGradient_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ScalarGradient_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorGradient_3D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorGradient_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorGradient_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorDivergence_3D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorDivergence_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorDivergence_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorDGDivergence_3D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorDGDivergence_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorDGDivergence_3D_gpu_wrapper END INTERFACE ! INTERFACE !   SUBROUTINE VectorCurl_3D_gpu_wrapper(dMatrixT_dev,f_dev,df_dev,N,nVar,nEl) & !     bind(c,name=\"VectorCurl_3D_gpu_wrapper\") !     USE iso_c_binding !     IMPLICIT NONE !     TYPE(c_ptr) :: dMatrixT_dev,f_dev,df_dev !     INTEGER(C_INT),VALUE :: N,nVar,nEl !   END SUBROUTINE VectorCurl_3D_gpu_wrapper ! END INTERFACE ! INTERFACE !   SUBROUTINE TensorDivergence_3D_gpu_wrapper(dMatrixT_dev,f_dev,df_dev,N,nVar,nEl) & !     bind(c,name=\"TensorDivergence_3D_gpu_wrapper\") !     USE iso_c_binding !     IMPLICIT NONE !     TYPE(c_ptr) :: dMatrixT_dev,f_dev,df_dev !     INTEGER(C_INT),VALUE :: N,nVar,nEl !   END SUBROUTINE TensorDivergence_3D_gpu_wrapper ! END INTERFACE ! INTERFACE !  SUBROUTINE TensorDGDivergence_3D_gpu_wrapper(dgMatrixT_dev,bMatrix_dev,qWeights_dev,f_dev,bf_dev,df_dev,N,nVar,nEl) & !     bind(c,name=\"TensorDGDivergence_3D_gpu_wrapper\") !     USE iso_c_binding !     IMPLICIT NONE !     TYPE(c_ptr) :: dgMatrixT_dev,bMatrix_dev,qWeights_dev,f_dev,bf_dev,df_dev !     INTEGER(C_INT),VALUE :: N,nVar,nEl !   END SUBROUTINE TensorDGDivergence_3D_gpu_wrapper ! END INTERFACE CONTAINS SUBROUTINE Init_Lagrange ( myPoly , N , controlNodeType , M , targetNodeType ) !! Initialize an instance of the Lagrange class !! On output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of !! control points, number of target points, and the types for the control and target nodes. !! If a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. IMPLICIT NONE CLASS ( Lagrange ), INTENT ( out ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: N !! The number of control points for interpolant INTEGER , INTENT ( in ) :: M !! The number of target points for the interpolant INTEGER , INTENT ( in ) :: controlNodeType !! The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) INTEGER , INTENT ( in ) :: targetNodeType !! The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) ! -------! ! Local REAL ( prec ) :: q ( 0 : M ) myPoly % N = N myPoly % M = M myPoly % controlNodeType = controlNodeType myPoly % targetNodeType = targetNodeType CALL myPoly % controlPoints % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % targetPoints % Alloc ( loBound = 0 , & upBound = M ) CALL myPoly % bWeights % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % qWeights % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % iMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , M / )) CALL myPoly % dMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , N / )) CALL myPoly % dgMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , N / )) CALL myPoly % bMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , 1 / )) IF ( controlNodeType == GAUSS . OR . controlNodeType == GAUSS_LOBATTO ) THEN CALL LegendreQuadrature ( N , & myPoly % controlPoints % hostData , & myPoly % qWeights % hostData , & controlNodeType ) ELSEIF ( controlNodeType == CHEBYSHEV_GAUSS . OR . controlNodeType == CHEBYSHEV_GAUSS_LOBATTO ) THEN CALL ChebyshevQuadrature ( N , & myPoly % controlPoints % hostData , & myPoly % qWeights % hostData , & controlNodeType ) ELSEIF ( controlNodeType == UNIFORM ) THEN myPoly % controlPoints % hostData = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , N ) myPoly % qWeights % hostData = 2.0_prec / REAL ( N , prec ) END IF ! Target Points IF ( targetNodeType == GAUSS . OR . targetNodeType == GAUSS_LOBATTO ) THEN CALL LegendreQuadrature ( M , & myPoly % targetPoints % hostData , & q , & targetNodeType ) ELSEIF ( targetNodeType == UNIFORM ) THEN myPoly % targetPoints % hostData = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , M ) END IF CALL myPoly % CalculateBarycentricWeights () CALL myPoly % CalculateInterpolationMatrix () CALL myPoly % CalculateDerivativeMatrix () myPoly % bMatrix % hostData ( 0 : N , 0 ) = myPoly % CalculateLagrangePolynomials ( - 1.0_prec ) myPoly % bMatrix % hostData ( 0 : N , 1 ) = myPoly % CalculateLagrangePolynomials ( 1.0_prec ) CALL myPoly % UpdateDevice () END SUBROUTINE Init_Lagrange SUBROUTINE Free_Lagrange ( myPoly ) !! Frees all memory (host and device) associated with an instance of the Lagrange class IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly !! Lagrange class instance CALL myPoly % controlPoints % Free () CALL myPoly % targetPoints % Free () CALL myPoly % bWeights % Free () CALL myPoly % qWeights % Free () CALL myPoly % iMatrix % Free () CALL myPoly % dMatrix % Free () CALL myPoly % dgMatrix % Free () CALL myPoly % bMatrix % Free () END SUBROUTINE Free_Lagrange SUBROUTINE UpdateDevice_Lagrange ( myPoly ) !! Copy the Lagrange attributes from the host (CPU) to the device (GPU) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly !! Lagrange class instance CALL myPoly % controlPoints % UpdateDevice () CALL myPoly % targetPoints % UpdateDevice () CALL myPoly % bWeights % UpdateDevice () CALL myPoly % qWeights % UpdateDevice () CALL myPoly % iMatrix % UpdateDevice () CALL myPoly % dMatrix % UpdateDevice () CALL myPoly % dgMatrix % UpdateDevice () CALL myPoly % bMatrix % UpdateDevice () END SUBROUTINE UpdateDevice_Lagrange SUBROUTINE UpdateHost_Lagrange ( myPoly ) !! Copy the Lagrange attributes from the device (GPU) to the host (CPU) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly !! Lagrange class instance CALL myPoly % controlPoints % UpdateHost () CALL myPoly % targetPoints % UpdateHost () CALL myPoly % bWeights % UpdateHost () CALL myPoly % qWeights % UpdateHost () CALL myPoly % iMatrix % UpdateHost () CALL myPoly % dMatrix % UpdateHost () CALL myPoly % dgMatrix % UpdateHost () CALL myPoly % bMatrix % UpdateHost () END SUBROUTINE UpdateHost_Lagrange SUBROUTINE ScalarGridInterp_1D_cpu ( myPoly , f , fInterp , nVariables , nElements ) !! Host (CPU) implementation of the ScalarGridInterp_1D interface. !! In most cases, you should use the `ScalarGridInterp_1D` generic interface, !! rather than calling this routine directly. !! Interpolate a scalar-1D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,ivar,iel} = \\sum_{i=0}&#94;N f_{i,ivar,iel} I_{i,m}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) !! (Input) Array of function values, defined on the control grid REAL ( prec ), INTENT ( out ) :: fInterp ( 0 : myPoly % M , 1 : nVariables , 1 : nElements ) !! (Output) Array of function values, defined on the target grid ! Local INTEGER :: iVar , iEl , i , ii DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % M fInterp ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N fInterp ( i , iVar , iEl ) = fInterp ( i , iVar , iEl ) + myPoly % iMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_1D_cpu SUBROUTINE ScalarGridInterp_1D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) !! Device (GPU) implementation of the ScalarGridInterp_1D interface. !! In most cases, you should use the `ScalarGridInterp_1D` generic interface, !! rather than calling this routine directly. !! This routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_1D_gpu_wrapper !! Interpolate a scalar-1D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,ivar,iel} = \\sum_{i=0}&#94;N f_{i,ivar,iel} I_{i,m}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid TYPE ( c_ptr ), INTENT ( in ) :: f_dev !! (Input) Array of function values, defined on the control grid TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev !! (Output) Array of function values, defined on the target grid CALL ScalarGridInterp_1D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE ScalarGridInterp_1D_gpu SUBROUTINE ScalarGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) !! Host (CPU) implementation of the ScalarGridInterp_2D interface. !! In most cases, you should use the `ScalarGridInterp_2D` generic interface, !! rather than calling this routine directly. !! Interpolate a scalar-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) !! (Input) Array of function values, defined on the control grid REAL ( prec ), INTENT ( out ) :: fNew ( 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) !! (Output) Array of function values, defined on the target grid ! Local INTEGER :: i , j , ii , jj , iEl , iVar REAL ( prec ) :: fi , fij DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fij = 0.0_prec DO jj = 0 , myPoly % N fi = 0.0_prec DO ii = 0 , myPoly % N fi = fi + f ( ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij = fij + fi * myPoly % iMatrix % hostData ( jj , j ) END DO fNew ( i , j , iVar , iEl ) = fij END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_2D_cpu SUBROUTINE ScalarGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) !! Device (GPU) implementation of the ScalarGridInterp_2D interface. !! In most cases, you should use the `ScalarGridInterp_2D` generic interface, !! rather than calling this routine directly. !! This routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_2D_gpu_wrapper !! Interpolate a scalar-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid TYPE ( c_ptr ), INTENT ( in ) :: f_dev !! (Input) Array of function values, defined on the control grid TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev !! (Output) Array of function values, defined on the target grid CALL ScalarGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE ScalarGridInterp_2D_gpu SUBROUTINE VectorGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) !! Host (CPU) implementation of the VectorGridInterp_2D interface. !! In most cases, you should use the `VectorGridInterp_2D` generic interface, !! rather than calling this routine directly. !! Interpolate a vector-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{dir,m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{dir,i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) !! (Input) Array of function values, defined on the control grid REAL ( prec ), INTENT ( out ) :: fNew ( 1 : 2 , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) !! (Output) Array of function values, defined on the target grid ! Local INTEGER :: i , j , ii , jj , iEl , iVar REAL ( prec ) :: fi ( 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fNew ( 1 , i , j , iVar , iEl ) = 0.0_prec fNew ( 2 , i , j , iVar , iEl ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 2 ) = fi ( 1 : 2 ) + f ( 1 : 2 , ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fNew ( 1 : 2 , i , j , iVar , iEl ) = fNew ( 1 : 2 , i , j , iVar , iEl ) + fi ( 1 : 2 ) * myPoly % iMatrix % hostData ( jj , j ) END DO END DO END DO END DO END DO END SUBROUTINE VectorGridInterp_2D_cpu ! SUBROUTINE VectorGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) !! Device (GPU) implementation of the VectorGridInterp_2D interface. !! In most cases, you should use the `VectorGridInterp_2D` generic interface, !! rather than calling this routine directly. !! This routine calls hip/SELF_Lagrange.cpp:VectorGridInterp_2D_gpu_wrapper !! Interpolate a vector-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{dir,m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{dir,i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid TYPE ( c_ptr ), INTENT ( in ) :: f_dev !! (Input) Array of function values, defined on the control grid TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev !! (Output) Array of function values, defined on the target grid CALL VectorGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE VectorGridInterp_2D_gpu !   SUBROUTINE TensorGridInterp_2D_cpu(myPoly,f,fNew,nVariables,nElements) !     !! Host (CPU) implementation of the TensorGridInterp_2D interface. !     !! In most cases, you should use the `TensorGridInterp_2D` generic interface, !     !! rather than calling this routine directly. !     !! Interpolate a tensor-2D (real) array from the control grid to the target grid. !     !! The control and target grids are the ones associated with an initialized !     !! Lagrange instance. !     !! !     !! Interpolation is applied using a series of matrix-tensor multiplications, using !     !! the Lagrange class's interpolation matrix !     !! !     !!  \\tilde{f}_{row,col,m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{row,col,i,j,ivar,iel} I_{i,m} I_{j,n}  !     !! !     IMPLICIT NONE !     CLASS(Lagrange),INTENT(in) :: myPoly !     !! Lagrange class instance !     INTEGER,INTENT(in)     :: nVariables !     !! The number of variables/functions that are interpolated !     INTEGER,INTENT(in)     :: nElements !     !! The number of spectral elements in the SEM grid !     REAL(prec),INTENT(in)  :: f(1:2,1:2,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !     !! (Input) Array of function values, defined on the control grid !     REAL(prec),INTENT(out) :: fNew(1:2,1:2,0:myPoly % M,0:myPoly % M,1:nVariables,1:nElements) !     !! (Output) Array of function values, defined on the target grid !     ! Local !     INTEGER :: i,j,ii,jj,iEl,iVar !     REAL(prec) :: fi(1:2,1:2) !     DO iEl = 1,nElements !       DO iVar = 1,nVariables !         DO j = 0,myPoly % M !           DO i = 0,myPoly % M !             fNew(1:2,1:2,i,j,iVar,iEl) = 0.0_prec !             DO jj = 0,myPoly % N !               fi(1:2,1:2) = 0.0_prec !               DO ii = 0,myPoly % N !                 fi(1:2,1:2) = fi(1:2,1:2) + f(1:2,1:2,ii,jj,iVar,iEl)*myPoly % iMatrix % hostData(ii,i) !               END DO !               fNew(1:2,1:2,i,j,iVar,iEl) = fNew(1:2,1:2,i,j,iVar,iEl) + fi(1:2,1:2)*myPoly % iMatrix % hostData(jj,j) !             END DO !           END DO !         END DO !       END DO !     END DO !   END SUBROUTINE TensorGridInterp_2D_cpu ! ! !   SUBROUTINE TensorGridInterp_2D_gpu(myPoly,f_dev,fInterp_dev,nVariables,nElements) !     !! Device (GPU) implementation of the TensorGridInterp_2D interface. !     !! In most cases, you should use the `TensorGridInterp_2D` generic interface, !     !! rather than calling this routine directly. !     !! This routine calls hip/SELF_Lagrange.cpp:TensorGridInterp_2D_gpu_wrapper !     !! Interpolate a tensor-2D (real) array from the control grid to the target grid. !     !! The control and target grids are the ones associated with an initialized !     !! Lagrange instance. !     !! !     !! Interpolation is applied using a series of matrix-vector multiplications, using !     !! the Lagrange class's interpolation matrix !     !! !     !!  \\tilde{f}_{row,col,m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{row,col,i,j,ivar,iel} I_{i,m} I_{j,n}  !     !! !     IMPLICIT NONE !     CLASS(Lagrange),INTENT(in) :: myPoly !     !! Lagrange class instance !     INTEGER,INTENT(in) :: nVariables !     !! The number of variables/functions that are interpolated !     INTEGER,INTENT(in) :: nElements !     !! The number of spectral elements in the SEM grid !     TYPE(c_ptr),INTENT(in)  :: f_dev !     !! (Input) Array of function values, defined on the control grid !     TYPE(c_ptr),INTENT(out) :: fInterp_dev !     !! (Output) Array of function values, defined on the target grid !     CALL TensorGridInterp_2D_gpu_wrapper(myPoly % iMatrix % deviceData, & !                                          f_dev,fInterp_dev, & !                                          myPoly % N,myPoly % M, & !                                          nVariables,nElements) !   END SUBROUTINE TensorGridInterp_2D_gpu SUBROUTINE ScalarGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi , fij , fijk DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fijk = 0.0_prec DO kk = 0 , myPoly % N fij = 0.0_prec DO jj = 0 , myPoly % N fi = 0.0_prec DO ii = 0 , myPoly % N fi = fi + f ( ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij = fij + fi * myPoly % iMatrix % hostData ( jj , j ) END DO fijk = fijk + fij * myPoly % iMatrix % hostData ( kk , k ) END DO fInterp ( i , j , k , iVar , iEl ) = fijk END DO END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_3D_cpu ! SUBROUTINE ScalarGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev CALL ScalarGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE ScalarGridInterp_3D_gpu SUBROUTINE VectorGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 1 : 3 , 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi ( 1 : 3 ), fij ( 1 : 3 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fInterp ( 1 : 3 , i , j , k , iVar , iEl ) = 0.0_prec DO kk = 0 , myPoly % N fij ( 1 : 3 ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 3 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 3 ) = fi ( 1 : 3 ) + f ( 1 : 3 , ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij ( 1 : 3 ) = fij ( 1 : 3 ) + fi ( 1 : 3 ) * myPoly % iMatrix % hostData ( jj , j ) END DO fInterp ( 1 : 3 , i , j , k , iVar , iEl ) = fInterp ( 1 : 3 , i , j , k , iVar , iEl ) + fij ( 1 : 3 ) * myPoly % iMatrix % hostData ( kk , k ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorGridInterp_3D_cpu ! SUBROUTINE VectorGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev CALL VectorGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE VectorGridInterp_3D_gpu !   SUBROUTINE TensorGridInterp_3D_cpu(myPoly,f,fInterp,nVariables,nElements) !     IMPLICIT NONE !     CLASS(Lagrange),INTENT(in) :: myPoly !     INTEGER,INTENT(in)     :: nVariables,nElements !     REAL(prec),INTENT(in)  :: f(1:3,1:3,0:myPoly % N,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !     REAL(prec),INTENT(out) :: fInterp(1:3,1:3,0:myPoly % M,0:myPoly % M,0:myPoly % M,1:nVariables,1:nElements) !     ! Local !     INTEGER :: iEl,iVar,i,j,k,ii,jj,kk !     REAL(prec) :: fi(1:3,1:3),fij(1:3,1:3) !     DO iEl = 1,nElements !       DO iVar = 1,nVariables !         DO k = 0,myPoly % M !           DO j = 0,myPoly % M !             DO i = 0,myPoly % M !               fInterp(1:3,1:3,i,j,k,iVar,iEl) = 0.0_prec !               DO kk = 0,myPoly % N !                 fij(1:3,1:3) = 0.0_prec !                 DO jj = 0,myPoly % N !                   fi(1:3,1:3) = 0.0_prec !                   DO ii = 0,myPoly % N !                     fi(1:3,1:3) = fi(1:3,1:3) + f(1:3,1:3,ii,jj,kk,iVar,iEl)*myPoly % iMatrix % hostData(ii,i) !                   END DO !                   fij(1:3,1:3) = fij(1:3,1:3) + fi(1:3,1:3)*myPoly % iMatrix % hostData(jj,j) !                 END DO !                 fInterp(1:3,1:3,i,j,k,iVar,iEl) = fInterp(1:3,1:3,i,j,k,iVar,iEl) + & !                                                   fij(1:3,1:3)*myPoly % iMatrix % hostData(kk,k) !               END DO !             END DO !           END DO !         END DO !       END DO !     END DO !   END SUBROUTINE TensorGridInterp_3D_cpu ! ! !   SUBROUTINE TensorGridInterp_3D_gpu(myPoly,f_dev,fInterp_dev,nVariables,nElements) !     IMPLICIT NONE !     CLASS(Lagrange),INTENT(in) :: myPoly !     INTEGER,INTENT(in) :: nVariables,nElements !     TYPE(c_ptr),INTENT(in)  :: f_dev !     TYPE(c_ptr),INTENT(out) :: fInterp_dev !     CALL TensorGridInterp_3D_gpu_wrapper(myPoly % iMatrix % deviceData, & !                                          f_dev,fInterp_dev, & !                                          myPoly % N,myPoly % M, & !                                          nVariables,nElements) !   END SUBROUTINE TensorGridInterp_3D_gpu ! ================================================================================================ ! ! ! Derivative_1D ! !   Calculates the derivative of the Lagrange interpolant given a set of nodal function values at !   the native interpolation nodes ! !   Given a set of nodal values at the interpolation nodes, the derivative of a function through !   the interpolation nodes can be estimated by ! !                       f'_a = \\sum_{i=0}&#94;N f_{i} l'_i(\\xi_a),   a=0,1,2,...,N ! !   where l_i(\\xi) are the Lagrange interpolating polynomials through the interpolation points. !   The derivative matrix is D_{a,i} = l'_i(\\xi_a) maps an array of nodal values at the interpolation !   nodes to its estimated derivative. This routine serves as a wrapper to call either the CUDA !   kernel (if CUDA is enabled) or the CPU version. ! !   Usage : ! !     TYPE(Lagrange) :: interp !     INTEGER        :: nVariables, nElements !     REAL(prec)     :: f(0:interp % N,1:nVariables,1:nElements) !     REAL(prec)     :: derF(0:interp % N,1:nVariables,1:nElements) ! !       CALL interp % Derivative_1D( f, derF, nVariables, nElements ) ! !     * If CUDA is enabled, the fnative and ftarget arrays must be CUDA device variables. ! !   Parameters : ! !     interp (in) !       A previously constructed Lagrange data-structure. ! !     f (in) !       Array of function nodal values at the native interpolation nodes. ! !     nVariables (in) ! !     nElements (in) ! !     derF (out) !      Array of derivative values at the target interpolation nodes. ! ! ================================================================================================ ! SUBROUTINE Derivative_1D_cpu ( myPoly , f , df , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: df ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N df ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO END DO END DO END DO END SUBROUTINE Derivative_1D_cpu SUBROUTINE Derivative_1D_gpu ( myPoly , f_dev , df_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: df_dev CALL Derivative_1D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , df_dev , & myPoly % N , & nVariables , nElements ) END SUBROUTINE Derivative_1D_gpu SUBROUTINE DGDerivative_1D_cpu ( myPoly , f , bf , df , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : nVariables , 1 : 2 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: df ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N ! Interior Derivative Matrix Application df ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO ! Boundary Contribution df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + ( bf ( iVar , 2 , iEl ) * myPoly % bMatrix % hostData ( i , 1 ) + & bf ( iVar , 1 , iEl ) * myPoly % bMatrix % hostData ( i , 0 )) / & myPoly % qWeights % hostData ( i ) END DO END DO END DO END SUBROUTINE DGDerivative_1D_cpu SUBROUTINE DGDerivative_1D_gpu ( myPoly , f_dev , bf_dev , df_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: df_dev CALL DGDerivative_1D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bf_dev , df_dev , & myPoly % N , & nVariables , nElements ) END SUBROUTINE DGDerivative_1D_gpu ! ================================================================================================ ! ! ! CalculateGradient_2D ! !   Calculates the gradient of a 2-D function, represented by a 2-D array of nodal values. ! !   Given a set of nodal values at the interpolation nodes, the gradient of a function through !   the interpolation nodes can be estimated by ! !                       (df/dx)_{a,b} = \\sum_{i=0}&#94;N f_{i,b} l'_i(\\xi_a),   a,b=0,1,2,...,N !                       (df/dy)_{a,b} = \\sum_{j=0}&#94;N f_{a,j} l'_j(\\xi_b),   a,b=0,1,2,...,N ! !   where l_i(\\xi) are the Lagrange interpolating polynomials through the interpolation points. !   The derivative matrix is D_{a,i} = l'_i(\\xi_a) maps an array of nodal values at the interpolation !   nodes to its estimated derivative. This routine serves as a wrapper to call either the CUDA !   kernel (if CUDA is enabled) or the CPU version. ! !   Usage : ! !     TYPE(Lagrange) :: interp !     INTEGER        :: nVariables, nElements !     REAL(prec)     :: f(0:interp % N,0:interp % N,1:nVariables,1:nElements) !     REAL(prec)     :: gradF(1:2,0:interp % N,0:interp % N,1:nVariables,1:nElements) ! !       CALL interp % CalculateGradient_2D( f, gradF, nVariables, nElements ) ! !     * If CUDA is enabled, the fnative and ftarget arrays must be CUDA device variables. ! !   Parameters : ! !     interp (in) !       A previously constructed Lagrange data-structure. ! !     f (in) !       Array of function nodal values at the native interpolation nodes. ! !     nVariables (in) ! !     nElements (in) ! !     gradF (out) !      Array of derivative values at the target interpolation nodes. ! ! ================================================================================================ ! ! SUBROUTINE ScalarGradient_2D_cpu ( myPoly , f , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = gradF ( 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , j , iVar , iEl ) gradF ( 2 , i , j , iVar , iEl ) = gradF ( 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE ScalarGradient_2D_cpu SUBROUTINE ScalarGradient_2D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL ScalarGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE ScalarGradient_2D_gpu ! ! ! SUBROUTINE ScalarDGGradient_2D_cpu(myPoly,f,bf,gradF,nVariables,nElements) !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)     :: nVariables,nElements !   REAL(prec),INTENT(in)  :: f(0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   REAL(prec),INTENT(in)  :: bf(0:myPoly % N,1:nVariables,1:4,1:nElements) !   REAL(prec),INTENT(out) :: gradF(1:2,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   ! Local !   INTEGER    :: i,j,ii,iVar,iEl !   DO iEl = 1,nElements !     DO iVar = 1,nVariables !       DO j = 0,myPoly % N !         DO i = 0,myPoly % N !           gradF(1,i,j,iVar,iEl) = 0.0_prec !           gradF(2,i,j,iVar,iEl) = 0.0_prec !           DO ii = 0,myPoly % N !             gradF(1,i,j,iVar,iEl) = gradF(1,i,j,iVar,iEl) + myPoly % dgMatrix % hostData(ii,i)*f(ii,j,iVar,iEl) !             gradF(2,i,j,iVar,iEl) = gradF(2,i,j,iVar,iEl) + myPoly % dgMatrix % hostData(ii,j)*f(i,ii,iVar,iEl) !           END DO !           ! Boundary Contribution !           gradF(1,i,j,iVar,iEl) = gradF(1,i,j,iVar,iEl) + (bf(j,iVar,2,iEl)*myPoly % bMatrix % hostData(i,1) + & !                                                            bf(j,iVar,4,iEl)*myPoly % bMatrix % hostData(i,0))/ & !                                   myPoly % qWeights % hostData(i) !           gradF(2,i,j,iVar,iEl) = gradF(2,i,j,iVar,iEl) + (bf(i,iVar,3,iEl)*myPoly % bMatrix % hostData(j,1) + & !                                                            bf(i,iVar,1,iEl)*myPoly % bMatrix % hostData(j,0))/ & !                                   myPoly % qWeights % hostData(j) !         END DO !       END DO !     END DO !   END DO ! END SUBROUTINE ScalarDGGradient_2D_cpu ! SUBROUTINE ScalarDGGradient_2D_gpu(myPoly,f_dev,bf_dev,gradF_dev,nVariables,nElements) !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)         :: nVariables,nElements !   TYPE(c_ptr),INTENT(in)     :: f_dev !   TYPE(c_ptr),INTENT(in)     :: bf_dev !   TYPE(c_ptr),INTENT(out)    :: gradF_dev !   CALL ScalarDGGradient_2D_gpu_wrapper(myPoly % dgMatrix % deviceData, & !                                        myPoly % bMatrix % deviceData, & !                                        myPoly % qWeights % deviceData, & !                                        f_dev,bf_dev,gradF_dev,myPoly % N, & !                                        nVariables,nElements) ! END SUBROUTINE ScalarDGGradient_2D_gpu SUBROUTINE VectorGradient_2D_cpu ( myPoly , f , gradF , nVariables , nElements ) ! ! Input : Vector(1:2,...) ! Output : Tensor(1:2,1:2,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: gf ( 1 : 2 , 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gf ( 1 , 1 ) = 0.0_prec gf ( 2 , 1 ) = 0.0_prec gf ( 1 , 2 ) = 0.0_prec gf ( 2 , 2 ) = 0.0_prec DO ii = 0 , myPoly % N gf ( 1 , 1 ) = gf ( 1 , 1 ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) gf ( 2 , 1 ) = gf ( 2 , 1 ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , iVar , iEl ) gf ( 1 , 2 ) = gf ( 1 , 2 ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , iVar , iEl ) gf ( 2 , 2 ) = gf ( 2 , 2 ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO gradF ( 1 : 2 , 1 : 2 , i , j , iVar , iEl ) = gf ( 1 : 2 , 1 : 2 ) END DO END DO END DO END DO END SUBROUTINE VectorGradient_2D_cpu SUBROUTINE VectorGradient_2D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL VectorGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorGradient_2D_gpu ! SUBROUTINE VectorDGGradient_2D_cpu(myPoly,f,bf,gradF,nVariables,nElements) !   ! !   ! Input : Vector(1:2,...) !   ! Output : Tensor(1:2,1:2,....) !   !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !   !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !   !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !   !          > Tensor(2,2) = d/ds2( Vector(2,...) ) !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)     :: nVariables,nElements !   REAL(prec),INTENT(in)  :: f(1:2,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   REAL(prec),INTENT(in)  :: bf(1:2,0:myPoly % N,1:nVariables,1:4,1:nElements) !   REAL(prec),INTENT(out) :: gradF(1:2,1:2,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   ! Local !   INTEGER    :: i,j,ii,iVar,iEl !   DO iEl = 1,nElements !     DO iVar = 1,nVariables !       DO j = 0,myPoly % N !         DO i = 0,myPoly % N !           gradF(1,1,i,j,iVar,iEl) = 0.0_prec !           gradF(2,1,i,j,iVar,iEl) = 0.0_prec !           gradF(1,2,i,j,iVar,iEl) = 0.0_prec !           gradF(2,2,i,j,iVar,iEl) = 0.0_prec !           DO ii = 0,myPoly % N !             gradF(1,1,i,j,iVar,iEl) = gradF(1,1,i,j,iVar,iEl) + myPoly % dgMatrix % hostData(ii,i)*f(1,ii,j,iVar,iEl) !             gradF(2,1,i,j,iVar,iEl) = gradF(2,1,i,j,iVar,iEl) + myPoly % dgMatrix % hostData(ii,i)*f(2,ii,j,iVar,iEl) !             gradF(1,2,i,j,iVar,iEl) = gradF(1,2,i,j,iVar,iEl) + myPoly % dgMatrix % hostData(ii,j)*f(1,i,ii,iVar,iEl) !             gradF(2,2,i,j,iVar,iEl) = gradF(2,2,i,j,iVar,iEl) + myPoly % dgMatrix % hostData(ii,j)*f(2,i,ii,iVar,iEl) !           END DO !           gradF(1,1,i,j,iVar,iEl) = gradF(1,1,i,j,iVar,iEl) + (myPoly % bMatrix % hostData(i,1)*bf(1,j,iVar,2,iEl) + & !                                                                myPoly % bMatrix % hostData(i,0)*bf(1,j,iVar,4,iEl))/ & !                                     myPoly % qWeights % hostData(i) !           gradF(2,1,i,j,iVar,iEl) = gradF(2,1,i,j,iVar,iEl) + (myPoly % bMatrix % hostData(i,1)*bf(2,j,iVar,2,iEl) + & !                                                                myPoly % bMatrix % hostData(i,0)*bf(2,j,iVar,4,iEl))/ & !                                     myPoly % qWeights % hostData(i) !           gradF(1,2,i,j,iVar,iEl) = gradF(1,2,i,j,iVar,iEl) + (myPoly % bMatrix % hostData(j,1)*bf(1,i,iVar,3,iEl) + & !                                                                myPoly % bMatrix % hostData(j,0)*bf(1,i,iVar,1,iEl))/ & !                                     myPoly % qWeights % hostData(j) !           gradF(2,2,i,j,iVar,iEl) = gradF(2,2,i,j,iVar,iEl) + (myPoly % bMatrix % hostData(j,1)*bf(2,i,iVar,3,iEl) + & !                                                                myPoly % bMatrix % hostData(j,0)*bf(2,i,iVar,1,iEl))/ & !                                     myPoly % qWeights % hostData(j) !         END DO !       END DO !     END DO !   END DO ! END SUBROUTINE VectorDGGradient_2D_cpu ! SUBROUTINE VectorDGGradient_2D_gpu(myPoly,f_dev,bf_dev,gradF_dev,nVariables,nElements) !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)         :: nVariables,nElements !   TYPE(c_ptr),INTENT(in)     :: f_dev !   TYPE(c_ptr),INTENT(in)     :: bf_dev !   TYPE(c_ptr),INTENT(out)    :: gradF_dev !   CALL VectorDGGradient_2D_gpu_wrapper(myPoly % dMatrix % deviceData, & !                                        myPoly % bMatrix % deviceData, & !                                        myPoly % qWeights % deviceData, & !                                        f_dev,bf_dev,gradF_dev,myPoly % N, & !                                        nVariables,nElements) ! END SUBROUTINE VectorDGGradient_2D_gpu SUBROUTINE VectorDivergence_2D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE VectorDivergence_2D_cpu SUBROUTINE VectorDivergence_2D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDivergence_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDivergence_2D_gpu SUBROUTINE VectorDGDivergence_2D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Assumes bF is the vector component in the direction normal to the boundary IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bF ( 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local REAL ( prec ) :: dfLoc INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dfLoc = 0.0_prec DO ii = 0 , myPoly % N dfLoc = dfLoc + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO dfLoc = dfLoc + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bF ( j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bF ( i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) dF ( i , j , iVar , iEl ) = dFLoc END DO END DO END DO END DO END SUBROUTINE VectorDGDivergence_2D_cpu SUBROUTINE VectorDGDivergence_2D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDGDivergence_2D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDGDivergence_2D_gpu ! SUBROUTINE VectorCurl_2D_cpu(myPoly,f,dF,nVariables,nElements) !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)     :: nVariables,nElements !   REAL(prec),INTENT(in)  :: f(1:2,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   REAL(prec),INTENT(out) :: dF(0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   ! Local !   INTEGER    :: i,j,ii,iVar,iEl !   DO iEl = 1,nElements !     DO iVar = 1,nVariables !       DO j = 0,myPoly % N !         DO i = 0,myPoly % N !           dF(i,j,iVar,iEl) = 0.0_prec !           DO ii = 0,myPoly % N !             dF(i,j,iVar,iEl) = dF(i,j,iVar,iEl) + myPoly % dMatrix % hostData(ii,j)*f(1,i,ii,iVar,iEl) - & !                                myPoly % dMatrix % hostData(ii,i)*f(2,ii,j,iVar,iEl) !           END DO !         END DO !       END DO !     END DO !   END DO ! END SUBROUTINE VectorCurl_2D_cpu ! SUBROUTINE VectorCurl_2D_gpu(myPoly,f_dev,dF_dev,nVariables,nElements) !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)         :: nVariables,nElements !   TYPE(c_ptr),INTENT(in)     :: f_dev !   TYPE(c_ptr),INTENT(out)    :: dF_dev !   CALL VectorCurl_2D_gpu_wrapper(myPoly % dMatrix % deviceData, & !                                  f_dev,dF_dev,myPoly % N, & !                                  nVariables,nElements) ! END SUBROUTINE VectorCurl_2D_gpu ! SUBROUTINE P2VectorDivergence_2D_cpu(myPoly,f,dF,nVariables,nElements) !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)     :: nVariables,nElements !   REAL(prec),INTENT(in)  :: f(1:2,0:myPoly % N,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   REAL(prec),INTENT(out) :: dF(0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   ! Local !   INTEGER    :: i,j,n,iVar,iEl !   REAL(prec) :: dfloc !   DO iEl = 1,nElements !     DO iVar = 1,nVariables !       DO j = 0,myPoly % N !         DO i = 0,myPoly % N !           dfloc = 0.0_prec !           DO n = 0,myPoly % N !             dfloc = dfloc + myPoly % dMatrix % hostData(n,i)*f(1,n,i,j,iVar,iEl) + & !                             myPoly % dMatrix % hostData(n,j)*f(2,n,i,j,iVar,iEl) !           END DO !           dF(i,j,iVar,iEl) = 2.0_prec*dfloc !         END DO !       END DO !     END DO !   END DO ! END SUBROUTINE P2VectorDivergence_2D_cpu ! SUBROUTINE P2VectorDivergence_2D_gpu(myPoly,f_dev,dF_dev,nVariables,nElements) !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)         :: nVariables,nElements !   TYPE(c_ptr),INTENT(in)     :: f_dev !   TYPE(c_ptr),INTENT(out)    :: dF_dev !   CALL P2VectorDivergence_2D_gpu_wrapper(myPoly % dMatrix % deviceData, & !                                        f_dev,dF_dev,myPoly % N, & !                                        nVariables,nElements) ! END SUBROUTINE P2VectorDivergence_2D_gpu ! SUBROUTINE P2VectorDGDivergence_2D_cpu(myPoly,f,bF,dF,nVariables,nElements) !   ! Assumes bF is the vector component in the direction normal to the boundary !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)     :: nVariables,nElements !   REAL(prec),INTENT(in)  :: f(1:2,0:myPoly % N,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   REAL(prec),INTENT(in)  :: bF(0:myPoly % N,1:nVariables,1:4,1:nElements) !   REAL(prec),INTENT(out) :: dF(0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   ! Local !   REAL(prec) :: dfLoc !   INTEGER    :: i,j,n,iVar,iEl !   DO iEl = 1,nElements !     DO iVar = 1,nVariables !       DO j = 0,myPoly % N !         DO i = 0,myPoly % N !           dfLoc = 0.0_prec !           DO n = 0,myPoly % N !             dfLoc = dfLoc + myPoly % dgMatrix % hostData(n,i)*f(1,n,i,j,iVar,iEl) + & !                             myPoly % dgMatrix % hostData(n,j)*f(2,n,i,j,iVar,iEl) !           END DO !           dfLoc = dfLoc + (myPoly % bMatrix % hostData(i,1)*bF(j,iVar,2,iEl) + & !                            myPoly % bMatrix % hostData(i,0)*bF(j,iVar,4,iEl))/ & !                              myPoly % qWeights % hostData(i) + & !                           (myPoly % bMatrix % hostData(j,1)*bF(i,iVar,3,iEl) + & !                            myPoly % bMatrix % hostData(j,0)*bF(i,iVar,1,iEl))/ & !                              myPoly % qWeights % hostData(j) !           dF(i,j,iVar,iEl) = dFLoc !         END DO !       END DO !     END DO !   END DO ! END SUBROUTINE P2VectorDGDivergence_2D_cpu ! SUBROUTINE P2VectorDGDivergence_2D_gpu(myPoly,f_dev,bF_dev,dF_dev,nVariables,nElements) !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)         :: nVariables,nElements !   TYPE(c_ptr),INTENT(in)     :: f_dev !   TYPE(c_ptr),INTENT(in)     :: bF_dev !   TYPE(c_ptr),INTENT(out)    :: dF_dev !   CALL P2VectorDGDivergence_2D_gpu_wrapper(myPoly % dgMatrix % deviceData, & !                                          myPoly % bMatrix % deviceData, & !                                          myPoly % qWeights % deviceData, & !                                          f_dev,bF_dev,dF_dev,myPoly % N, & !                                          nVariables,nElements) ! END SUBROUTINE P2VectorDGDivergence_2D_gpu ! SUBROUTINE TensorDivergence_2D_cpu(myPoly,f,dF,nVariables,nElements) !   ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)     :: nVariables,nElements !   REAL(prec),INTENT(in)  :: f(1:2,1:2,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   REAL(prec),INTENT(out) :: dF(1:2,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   ! Local !   INTEGER    :: i,j,ii,iVar,iEl !   DO iEl = 1,nElements !     DO iVar = 1,nVariables !       DO j = 0,myPoly % N !         DO i = 0,myPoly % N !           dF(1,i,j,iVar,iEl) = 0.0_prec !           dF(2,i,j,iVar,iEl) = 0.0_prec !           DO ii = 0,myPoly % N !             dF(1,i,j,iVar,iEl) = dF(1,i,j,iVar,iEl) + myPoly % dMatrix % hostData(ii,i)*f(1,1,ii,j,iVar,iEl) + & !                                  myPoly % dMatrix % hostData(ii,j)*f(2,1,i,ii,iVar,iEl) !             dF(2,i,j,iVar,iEl) = dF(2,i,j,iVar,iEl) + myPoly % dMatrix % hostData(ii,i)*f(1,2,ii,j,iVar,iEl) + & !                                  myPoly % dMatrix % hostData(ii,j)*f(2,2,i,ii,iVar,iEl) !           END DO !         END DO !       END DO !     END DO !   END DO ! END SUBROUTINE TensorDivergence_2D_cpu ! SUBROUTINE TensorDivergence_2D_gpu(myPoly,f_dev,dF_dev,nVariables,nElements) !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)         :: nVariables,nElements !   TYPE(c_ptr),INTENT(in)     :: f_dev !   TYPE(c_ptr),INTENT(out)    :: dF_dev !   CALL TensorDivergence_2D_gpu_wrapper(myPoly % dMatrix % deviceData, & !                                        f_dev,dF_dev,myPoly % N, & !                                        nVariables,nElements) ! END SUBROUTINE TensorDivergence_2D_gpu ! SUBROUTINE TensorDGDivergence_2D_cpu(myPoly,f,bF,dF,nVariables,nElements) !   ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)     :: nVariables,nElements !   REAL(prec),INTENT(in)  :: f(1:2,1:2,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   REAL(prec),INTENT(in)  :: bf(1:2,1:2,0:myPoly % N,1:nVariables,1:4,1:nElements) !   REAL(prec),INTENT(out) :: dF(1:2,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   ! Local !   INTEGER    :: i,j,ii,iVar,iEl !   DO iEl = 1,nElements !     DO iVar = 1,nVariables !       DO j = 0,myPoly % N !         DO i = 0,myPoly % N !           dF(1,i,j,iVar,iEl) = 0.0_prec !           dF(2,i,j,iVar,iEl) = 0.0_prec !           DO ii = 0,myPoly % N !             dF(1,i,j,iVar,iEl) = dF(1,i,j,iVar,iEl) + myPoly % dgMatrix % hostData(ii,i)*f(1,1,ii,j,iVar,iEl) + & !                                  myPoly % dgMatrix % hostData(ii,j)*f(2,1,i,ii,iVar,iEl) !             dF(2,i,j,iVar,iEl) = dF(2,i,j,iVar,iEl) + myPoly % dgMatrix % hostData(ii,i)*f(1,2,ii,j,iVar,iEl) + & !                                  myPoly % dgMatrix % hostData(ii,j)*f(2,2,i,ii,iVar,iEl) !           END DO !           dF(1,i,j,iVar,iEl) = dF(1,i,j,iVar,iEl) + (myPoly % bMatrix % hostData(i,1)*bf(1,1,j,iVar,2,iEl) + & !                                                      myPoly % bMatrix % hostData(i,0)*bf(1,1,j,iVar,4,iEl))/ & !                                myPoly % qWeights % hostData(i) + & !                                (myPoly % bMatrix % hostData(j,1)*bf(2,1,i,iVar,3,iEl) + & !                                 myPoly % bMatrix % hostData(j,0)*bf(2,1,i,iVar,1,iEl))/ & !                                myPoly % qWeights % hostData(j) !           dF(2,i,j,iVar,iEl) = dF(2,i,j,iVar,iEl) + (myPoly % bMatrix % hostData(i,1)*bf(1,2,j,iVar,2,iEl) + & !                                                      myPoly % bMatrix % hostData(i,0)*bf(1,2,j,iVar,4,iEl))/ & !                                myPoly % qWeights % hostData(i) + & !                                (myPoly % bMatrix % hostData(j,1)*bf(2,2,i,iVar,3,iEl) + & !                                 myPoly % bMatrix % hostData(j,0)*bf(2,2,i,iVar,1,iEl))/ & !                                myPoly % qWeights % hostData(j) !         END DO !       END DO !     END DO !   END DO ! END SUBROUTINE TensorDGDivergence_2D_cpu ! SUBROUTINE TensorDGDivergence_2D_gpu(myPoly,f_dev,bF_dev,dF_dev,nVariables,nElements) !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)         :: nVariables,nElements !   TYPE(c_ptr),INTENT(in)     :: f_dev !   TYPE(c_ptr),INTENT(in)     :: bf_dev !   TYPE(c_ptr),INTENT(out)    :: dF_dev !   CALL TensorDGDivergence_2D_gpu_wrapper(myPoly % dgMatrix % deviceData, & !                                          myPoly % bMatrix % deviceData, & !                                          myPoly % qWeights % deviceData, & !                                          f_dev,bF_dev,dF_dev,myPoly % N, & !                                          nVariables,nElements) ! END SUBROUTINE TensorDGDivergence_2D_gpu SUBROUTINE ScalarGradient_3D_cpu ( myPoly , f , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl REAL ( prec ) :: gf ( 1 : 3 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N gF ( 1 ) = 0.0_prec gF ( 2 ) = 0.0_prec gF ( 3 ) = 0.0_prec DO ii = 0 , myPoly % N gF ( 1 ) = gF ( 1 ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , j , k , iVar , iEl ) gF ( 2 ) = gF ( 2 ) + myPoly % dMatrix % hostData ( ii , j ) * f ( i , ii , k , iVar , iEl ) gF ( 3 ) = gF ( 3 ) + myPoly % dMatrix % hostData ( ii , k ) * f ( i , j , ii , iVar , iEl ) END DO gradF ( 1 , i , j , k , iVar , iEl ) = gF ( 1 ) gradF ( 2 , i , j , k , iVar , iEl ) = gF ( 2 ) gradF ( 3 , i , j , k , iVar , iEl ) = gF ( 3 ) END DO END DO END DO END DO END DO END SUBROUTINE ScalarGradient_3D_cpu SUBROUTINE ScalarGradient_3D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL ScalarGradient_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE ScalarGradient_3D_gpu ! SUBROUTINE VectorGradient_3D_cpu ( myPoly , f , gradF , nVariables , nElements ) ! ! Input : Vector(1:3,...) ! Output : Tensor(1:3,1:3,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(3,1) = d/ds1( Vector(3,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) !          > Tensor(3,2) = d/ds2( Vector(3,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl REAL ( prec ) :: gF ( 1 : 3 , 1 : 3 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N gF = 0.0_prec DO ii = 0 , myPoly % N gF ( 1 , 1 ) = gF ( 1 , 1 ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) gF ( 2 , 1 ) = gF ( 2 , 1 ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , k , iVar , iEl ) gF ( 3 , 1 ) = gF ( 3 , 1 ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 3 , ii , j , k , iVar , iEl ) gF ( 1 , 2 ) = gF ( 1 , 2 ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , k , iVar , iEl ) gF ( 2 , 2 ) = gF ( 2 , 2 ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) gF ( 3 , 2 ) = gF ( 3 , 2 ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 3 , i , ii , k , iVar , iEl ) gF ( 1 , 3 ) = gF ( 1 , 3 ) + myPoly % dMatrix % hostData ( ii , k ) * f ( 1 , i , j , ii , iVar , iEl ) gF ( 2 , 3 ) = gF ( 2 , 3 ) + myPoly % dMatrix % hostData ( ii , k ) * f ( 2 , i , j , ii , iVar , iEl ) gF ( 3 , 3 ) = gF ( 3 , 3 ) + myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO gradF ( 1 , 1 , i , j , k , iVar , iEl ) = gF ( 1 , 1 ) gradF ( 2 , 1 , i , j , k , iVar , iEl ) = gF ( 2 , 1 ) gradF ( 3 , 1 , i , j , k , iVar , iEl ) = gF ( 3 , 1 ) gradF ( 1 , 2 , i , j , k , iVar , iEl ) = gF ( 1 , 2 ) gradF ( 2 , 2 , i , j , k , iVar , iEl ) = gF ( 2 , 2 ) gradF ( 3 , 2 , i , j , k , iVar , iEl ) = gF ( 3 , 2 ) gradF ( 1 , 3 , i , j , k , iVar , iEl ) = gF ( 1 , 3 ) gradF ( 2 , 3 , i , j , k , iVar , iEl ) = gF ( 2 , 3 ) gradF ( 3 , 3 , i , j , k , iVar , iEl ) = gF ( 3 , 3 ) END DO END DO END DO END DO END DO END SUBROUTINE VectorGradient_3D_cpu SUBROUTINE VectorGradient_3D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL VectorGradient_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorGradient_3D_gpu SUBROUTINE VectorDivergence_3D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorDivergence_3D_cpu SUBROUTINE VectorDivergence_3D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDivergence_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDivergence_3D_gpu SUBROUTINE VectorDGDivergence_3D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Assumes bF is the vector component in the direction normal to the element boundaries IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) END DO END DO END DO END DO END DO END SUBROUTINE VectorDGDivergence_3D_cpu SUBROUTINE VectorDGDivergence_3D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDGDivergence_3D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDGDivergence_3D_gpu ! SUBROUTINE VectorCurl_3D_cpu(myPoly,f,dF,nVariables,nElements) !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)     :: nVariables,nElements !   REAL(prec),INTENT(in)  :: f(1:3,0:myPoly % N,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   REAL(prec),INTENT(out) :: dF(1:3,0:myPoly % N,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   ! Local !   INTEGER    :: i,j,k,ii,iVar,iEl !   DO iEl = 1,nElements !     DO iVar = 1,nVariables !       DO k = 0,myPoly % N !         DO j = 0,myPoly % N !           DO i = 0,myPoly % N !             dF(1,i,j,k,iVar,iEl) = 0.0_prec !             dF(2,i,j,k,iVar,iEl) = 0.0_prec !             dF(3,i,j,k,iVar,iEl) = 0.0_prec !             DO ii = 0,myPoly % N !               dF(1,i,j,k,iVar,iEl) = dF(1,i,j,k,iVar,iEl) + myPoly % dMatrix % hostData(ii,j)*f(3,i,ii,k,iVar,iEl) - & !                                      myPoly % dMatrix % hostData(ii,k)*f(2,i,j,ii,iVar,iEl) !               dF(2,i,j,k,iVar,iEl) = dF(2,i,j,k,iVar,iEl) + myPoly % dMatrix % hostData(ii,k)*f(1,i,j,ii,iVar,iEl) - & !                                      myPoly % dMatrix % hostData(ii,i)*f(3,ii,j,k,iVar,iEl) !               dF(3,i,j,k,iVar,iEl) = dF(3,i,j,k,iVar,iEl) + myPoly % dMatrix % hostData(ii,i)*f(2,ii,j,k,iVar,iEl) - & !                                      myPoly % dMatrix % hostData(ii,j)*f(1,i,ii,k,iVar,iEl) !             END DO !           END DO !         END DO !       END DO !     END DO !   END DO ! END SUBROUTINE VectorCurl_3D_cpu ! SUBROUTINE VectorCurl_3D_gpu(myPoly,f_dev,dF_dev,nVariables,nElements) !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)         :: nVariables,nElements !   TYPE(c_ptr),INTENT(in)     :: f_dev !   TYPE(c_ptr),INTENT(out)    :: dF_dev !   CALL VectorCurl_3D_gpu_wrapper(myPoly % dMatrix % deviceData, & !                                  f_dev,dF_dev,myPoly % N, & !                                  nVariables,nElements) ! END SUBROUTINE VectorCurl_3D_gpu ! SUBROUTINE TensorDivergence_3D_cpu(myPoly,f,dF,nVariables,nElements) !   ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)     :: nVariables,nElements !   REAL(prec),INTENT(in)  :: f(1:3,1:3,0:myPoly % N,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   REAL(prec),INTENT(out) :: dF(1:3,0:myPoly % N,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   ! Local !   INTEGER    :: i,j,k,ii,iVar,iEl !   DO iEl = 1,nElements !     DO iVar = 1,nVariables !       DO k = 0,myPoly % N !         DO j = 0,myPoly % N !           DO i = 0,myPoly % N !             dF(1,i,j,k,iVar,iEl) = 0.0_prec !             dF(2,i,j,k,iVar,iEl) = 0.0_prec !             dF(3,i,j,k,iVar,iEl) = 0.0_prec !             DO ii = 0,myPoly % N !               dF(1,i,j,k,iVar,iEl) = dF(1,i,j,k,iVar,iEl) + & !                                      myPoly % dMatrix % hostData(ii,i)*f(1,1,ii,j,k,iVar,iEl) + & !                                      myPoly % dMatrix % hostData(ii,j)*f(2,1,i,ii,k,iVar,iEl) + & !                                      myPoly % dMatrix % hostData(ii,k)*f(3,1,i,j,ii,iVar,iEl) !               dF(2,i,j,k,iVar,iEl) = dF(2,i,j,k,iVar,iEl) + & !                                      myPoly % dMatrix % hostData(ii,i)*f(1,2,ii,j,k,iVar,iEl) + & !                                      myPoly % dMatrix % hostData(ii,j)*f(2,2,i,ii,k,iVar,iEl) + & !                                      myPoly % dMatrix % hostData(ii,k)*f(3,2,i,j,ii,iVar,iEl) !               dF(3,i,j,k,iVar,iEl) = dF(3,i,j,k,iVar,iEl) + & !                                      myPoly % dMatrix % hostData(ii,i)*f(1,3,ii,j,k,iVar,iEl) + & !                                      myPoly % dMatrix % hostData(ii,j)*f(2,3,i,ii,k,iVar,iEl) + & !                                      myPoly % dMatrix % hostData(ii,k)*f(3,3,i,j,ii,iVar,iEl) !             END DO !           END DO !         END DO !       END DO !     END DO !   END DO ! END SUBROUTINE TensorDivergence_3D_cpu ! SUBROUTINE TensorDivergence_3D_gpu(myPoly,f_dev,dF_dev,nVariables,nElements) !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)         :: nVariables,nElements !   TYPE(c_ptr),INTENT(in)     :: f_dev !   TYPE(c_ptr),INTENT(out)    :: dF_dev !   CALL TensorDivergence_3D_gpu_wrapper(myPoly % dMatrix % deviceData, & !                                        f_dev,dF_dev,myPoly % N, & !                                        nVariables,nElements) ! END SUBROUTINE TensorDivergence_3D_gpu ! SUBROUTINE TensorDGDivergence_3D_cpu(myPoly,f,bF,dF,nVariables,nElements) !   ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)     :: nVariables,nElements !   REAL(prec),INTENT(in)  :: f(1:3,1:3,0:myPoly % N,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   REAL(prec),INTENT(in)  :: bF(1:3,1:3,0:myPoly % N,0:myPoly % N,1:nVariables,1:6,1:nElements) !   REAL(prec),INTENT(out) :: dF(1:3,0:myPoly % N,0:myPoly % N,0:myPoly % N,1:nVariables,1:nElements) !   ! Local !   INTEGER    :: i,j,k,ii,iVar,iEl !   DO iEl = 1,nElements !     DO iVar = 1,nVariables !       DO k = 0,myPoly % N !         DO j = 0,myPoly % N !           DO i = 0,myPoly % N !             dF(1,i,j,k,iVar,iEl) = 0.0_prec !             dF(2,i,j,k,iVar,iEl) = 0.0_prec !             dF(3,i,j,k,iVar,iEl) = 0.0_prec !             DO ii = 0,myPoly % N !               dF(1,i,j,k,iVar,iEl) = dF(1,i,j,k,iVar,iEl) + & !                                      myPoly % dgMatrix % hostData(ii,i)*f(1,1,ii,j,k,iVar,iEl) + & !                                      myPoly % dgMatrix % hostData(ii,j)*f(2,1,i,ii,k,iVar,iEl) + & !                                      myPoly % dgMatrix % hostData(ii,k)*f(3,1,i,j,ii,iVar,iEl) !               dF(2,i,j,k,iVar,iEl) = dF(2,i,j,k,iVar,iEl) + & !                                      myPoly % dgMatrix % hostData(ii,i)*f(1,2,ii,j,k,iVar,iEl) + & !                                      myPoly % dgMatrix % hostData(ii,j)*f(2,2,i,ii,k,iVar,iEl) + & !                                      myPoly % dgMatrix % hostData(ii,k)*f(3,2,i,j,ii,iVar,iEl) !               dF(3,i,j,k,iVar,iEl) = dF(3,i,j,k,iVar,iEl) + & !                                      myPoly % dgMatrix % hostData(ii,i)*f(1,3,ii,j,k,iVar,iEl) + & !                                      myPoly % dgMatrix % hostData(ii,j)*f(2,3,i,ii,k,iVar,iEl) + & !                                      myPoly % dgMatrix % hostData(ii,k)*f(3,3,i,j,ii,iVar,iEl) !             END DO !             dF(1,i,j,k,iVar,iEl) = dF(1,i,j,k,iVar,iEl) + (myPoly % bMatrix % hostData(i,1)*bF(1,1,j,k,iVar,3,iEl) + & ! east !                                                    myPoly % bMatrix % hostData(i,0)*bF(1,1,j,k,iVar,5,iEl))/ &  ! west !                                    myPoly % qWeights % hostData(i) + & !                                    (myPoly % bMatrix % hostData(j,1)*bF(2,1,i,k,iVar,4,iEl) + & ! north !                                     myPoly % bMatrix % hostData(j,0)*bF(2,1,i,k,iVar,2,iEl))/ &  ! south !                                    myPoly % qWeights % hostData(j) + & !                                    (myPoly % bMatrix % hostData(k,1)*bF(3,1,i,j,iVar,6,iEl) + & ! top !                                     myPoly % bMatrix % hostData(k,0)*bF(3,1,i,j,iVar,1,iEl))/ &  ! bottom !                                    myPoly % qWeights % hostData(k) !             dF(2,i,j,k,iVar,iEl) = dF(2,i,j,k,iVar,iEl) + (myPoly % bMatrix % hostData(i,1)*bF(1,2,j,k,iVar,3,iEl) + & ! east !                                                    myPoly % bMatrix % hostData(i,0)*bF(1,2,j,k,iVar,5,iEl))/ &  ! west !                                    myPoly % qWeights % hostData(i) + & !                                    (myPoly % bMatrix % hostData(j,1)*bF(2,2,i,k,iVar,4,iEl) + & ! north !                                     myPoly % bMatrix % hostData(j,0)*bF(2,2,i,k,iVar,2,iEl))/ &  ! south !                                    myPoly % qWeights % hostData(j) + & !                                    (myPoly % bMatrix % hostData(k,1)*bF(3,2,i,j,iVar,6,iEl) + & ! top !                                     myPoly % bMatrix % hostData(k,0)*bF(3,2,i,j,iVar,1,iEl))/ &  ! bottom !                                    myPoly % qWeights % hostData(k) !             dF(3,i,j,k,iVar,iEl) = dF(3,i,j,k,iVar,iEl) + (myPoly % bMatrix % hostData(i,1)*bF(1,3,j,k,iVar,3,iEl) + & ! east !                                                    myPoly % bMatrix % hostData(i,0)*bF(1,3,j,k,iVar,5,iEl))/ &  ! west !                                    myPoly % qWeights % hostData(i) + & !                                    (myPoly % bMatrix % hostData(j,1)*bF(2,3,i,k,iVar,4,iEl) + & ! north !                                     myPoly % bMatrix % hostData(j,0)*bF(2,3,i,k,iVar,2,iEl))/ &  ! south !                                    myPoly % qWeights % hostData(j) + & !                                    (myPoly % bMatrix % hostData(k,1)*bF(3,3,i,j,iVar,6,iEl) + & ! top !                                     myPoly % bMatrix % hostData(k,0)*bF(3,3,i,j,iVar,1,iEl))/ &  ! bottom !                                    myPoly % qWeights % hostData(k) !           END DO !         END DO !       END DO !     END DO !   END DO ! END SUBROUTINE TensorDGDivergence_3D_cpu ! SUBROUTINE TensorDGDivergence_3D_gpu(myPoly,f_dev,bF_dev,dF_dev,nVariables,nElements) !   IMPLICIT NONE !   CLASS(Lagrange),INTENT(in) :: myPoly !   INTEGER,INTENT(in)         :: nVariables,nElements !   TYPE(c_ptr),INTENT(in)     :: f_dev !   TYPE(c_ptr),INTENT(in)     :: bF_dev !   TYPE(c_ptr),INTENT(out)    :: dF_dev !   CALL TensorDGDivergence_3D_gpu_wrapper(myPoly % dgMatrix % deviceData, & !                                          myPoly % bMatrix % deviceData, & !                                          myPoly % qWeights % deviceData, & !                                          f_dev,bF_dev,dF_dev,myPoly % N, & !                                          nVariables,nElements) ! END SUBROUTINE TensorDGDivergence_3D_gpu ! /////////////////////////////// ! ! Boundary Interpolation Routines ! SUBROUTINE ScalarBoundaryInterp_1D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : nVariables , 1 : 2 , 1 : nElements ) ! Local INTEGER :: ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables fb ( 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , iVar , iEl ) ! West fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , iVar , iEl ) ! East END DO fBound ( iVar , 1 : 2 , iEl ) = fb ( 1 : 2 ) END DO END DO END SUBROUTINE ScalarBoundaryInterp_1D_cpu SUBROUTINE ScalarBoundaryInterp_1D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL ScalarBoundaryInterp_1D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE ScalarBoundaryInterp_1D_gpu SUBROUTINE ScalarBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , ii , iVar , iEl ) ! South fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , i , iVar , iEl ) ! East fb ( 3 ) = fb ( 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , ii , iVar , iEl ) ! North fb ( 4 ) = fb ( 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , i , iVar , iEl ) ! West END DO fBound ( i , iVar , 1 : 4 , iEl ) = fb ( 1 : 4 ) END DO END DO END DO END SUBROUTINE ScalarBoundaryInterp_2D_cpu SUBROUTINE ScalarBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL ScalarBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE ScalarBoundaryInterp_2D_gpu SUBROUTINE VectorBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , ii , idir , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 , 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 2 , 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N DO idir = 1 , 2 fb ( idir , 1 ) = fb ( idir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , ii , iVar , iEl ) ! South fb ( idir , 2 ) = fb ( idir , 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , ii , i , iVar , iEl ) ! East fb ( idir , 3 ) = fb ( idir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , ii , iVar , iEl ) ! North fb ( idir , 4 ) = fb ( idir , 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , ii , i , iVar , iEl ) ! West END DO END DO DO idir = 1 , 2 fBound ( idir , i , iVar , 1 : 4 , iEl ) = fb ( idir , 1 : 4 ) END DO END DO END DO END DO END SUBROUTINE VectorBoundaryInterp_2D_cpu SUBROUTINE VectorBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL VectorBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE VectorBoundaryInterp_2D_gpu SUBROUTINE TensorBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , ii , idir , jdir , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 , 1 : 2 , 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 2 , 1 : 2 , 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N DO jdir = 1 , 2 DO idir = 1 , 2 fb ( idir , jdir , 1 ) = fb ( idir , jdir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , ii , iVar , iEl ) ! South fb ( idir , jdir , 2 ) = fb ( idir , jdir , 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , ii , i , iVar , iEl ) ! East fb ( idir , jdir , 3 ) = fb ( idir , jdir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , ii , iVar , iEl ) ! North fb ( idir , jdir , 4 ) = fb ( idir , jdir , 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , ii , i , iVar , iEl ) ! West END DO END DO END DO DO jdir = 1 , 2 DO idir = 1 , 2 fBound ( idir , jdir , i , iVar , 1 : 4 , iEl ) = fb ( idir , jdir , 1 : 4 ) END DO END DO END DO END DO END DO END SUBROUTINE TensorBoundaryInterp_2D_cpu SUBROUTINE TensorBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL TensorBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE TensorBoundaryInterp_2D_gpu SUBROUTINE ScalarBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , j , ii , iVar , iEl ) ! Bottom fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , ii , j , iVar , iEl ) ! South fb ( 3 ) = fb ( 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , i , j , iVar , iEl ) ! East fb ( 4 ) = fb ( 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , ii , j , iVar , iEl ) ! North fb ( 5 ) = fb ( 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , i , j , iVar , iEl ) ! West fb ( 6 ) = fb ( 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , j , ii , iVar , iEl ) ! Top END DO fBound ( i , j , iVar , 1 : 6 , iEl ) = fb ( 1 : 6 ) END DO END DO END DO END DO END SUBROUTINE ScalarBoundaryInterp_3D_cpu SUBROUTINE ScalarBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL ScalarBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE ScalarBoundaryInterp_3D_gpu SUBROUTINE VectorBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , iVar , iEl REAL ( prec ) :: fb ( 1 : 3 , 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 3 , 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N DO idir = 1 , 3 fb ( idir , 1 ) = fb ( idir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , j , ii , iVar , iEl ) ! Bottom fb ( idir , 2 ) = fb ( idir , 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , ii , j , iVar , iEl ) ! South fb ( idir , 3 ) = fb ( idir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , ii , i , j , iVar , iEl ) ! East fb ( idir , 4 ) = fb ( idir , 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , ii , j , iVar , iEl ) ! North fb ( idir , 5 ) = fb ( idir , 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , ii , i , j , iVar , iEl ) ! West fb ( idir , 6 ) = fb ( idir , 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , j , ii , iVar , iEl ) ! Top END DO END DO DO idir = 1 , 3 fBound ( idir , i , j , iVar , 1 : 6 , iEl ) = fb ( idir , 1 : 6 ) END DO END DO END DO END DO END DO END SUBROUTINE VectorBoundaryInterp_3D_cpu SUBROUTINE VectorBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL VectorBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE VectorBoundaryInterp_3D_gpu SUBROUTINE TensorBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , jdir , iVar , iEl REAL ( prec ) :: fb ( 1 : 3 , 1 : 3 , 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 3 , 1 : 3 , 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N DO jdir = 1 , 3 DO idir = 1 , 3 fb ( idir , jdir , 1 ) = fb ( idir , jdir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , j , ii , iVar , iEl ) ! Bottom fb ( idir , jdir , 2 ) = fb ( idir , jdir , 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , ii , j , iVar , iEl ) ! South fb ( idir , jdir , 3 ) = fb ( idir , jdir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , ii , i , j , iVar , iEl ) ! East fb ( idir , jdir , 4 ) = fb ( idir , jdir , 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , ii , j , iVar , iEl ) ! North fb ( idir , jdir , 5 ) = fb ( idir , jdir , 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , ii , i , j , iVar , iEl ) ! West fb ( idir , jdir , 6 ) = fb ( idir , jdir , 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , j , ii , iVar , iEl ) ! Top END DO END DO END DO DO jdir = 1 , 3 DO idir = 1 , 3 fBound ( idir , jdir , i , j , iVar , 1 : 6 , iEl ) = fb ( idir , jdir , 1 : 6 ) END DO END DO END DO END DO END DO END DO END SUBROUTINE TensorBoundaryInterp_3D_cpu SUBROUTINE TensorBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL TensorBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE TensorBoundaryInterp_3D_gpu ! ================================================================================================ ! ! ! CalculateBarycentricWeights (PRIVATE) ! !   A PRIVATE routine that calculates and stores the barycentric weights for the Lagrange !   data-structure. ! !   This routine is from Alg. 30 on pg. 75 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! SUBROUTINE CalculateBarycentricWeights ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: i , j REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) DO i = 0 , myPoly % N bWeights ( i ) = 1.0_real64 controlPoints ( i ) = REAL ( myPoly % controlPoints % hostData ( i ), real64 ) END DO ! Computes the product w_k = w_k*(s_k - s_j), k /= j DO j = 1 , myPoly % N DO i = 0 , j - 1 bWeights ( i ) = bWeights ( i ) * ( controlPoints ( i ) - controlPoints ( j )) bWeights ( j ) = bWeights ( j ) * ( controlPoints ( j ) - controlPoints ( i )) END DO END DO DO j = 0 , myPoly % N bWeights ( j ) = 1.0_prec / bWeights ( j ) myPoly % bWeights % hostData ( j ) = REAL ( bWeights ( j ), prec ) END DO END SUBROUTINE CalculateBarycentricWeights ! ================================================================================================ ! ! ! CalculateInterpolationMatrix (PRIVATE) ! !   A PRIVATE routine that fills in the interpolation matrix for the Lagrange data structure. ! !   This function is from Alg. 32 on pg. 76 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! SUBROUTINE CalculateInterpolationMatrix ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: row , col LOGICAL :: rowHasMatch REAL ( real64 ) :: temp1 , temp2 REAL ( real64 ) :: iMatrix ( 0 : myPoly % M , 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) REAL ( real64 ) :: targetPoints ( 0 : myPoly % M ) DO col = 0 , myPoly % N controlPoints ( col ) = REAL ( myPoly % controlPoints % hostData ( col ), real64 ) bWeights ( col ) = REAL ( myPoly % bWeights % hostData ( col ), real64 ) END DO DO row = 0 , myPoly % M targetPoints ( row ) = REAL ( myPoly % targetPoints % hostData ( row ), real64 ) END DO DO row = 0 , myPoly % M rowHasMatch = . FALSE . DO col = 0 , myPoly % N iMatrix ( row , col ) = 0.0_real64 IF ( AlmostEqual ( targetPoints ( row ), controlPoints ( col ))) THEN rowHasMatch = . TRUE . iMatrix ( row , col ) = 1.0_real64 END IF END DO IF (. NOT . ( rowHasMatch )) THEN temp1 = 0.0_real64 DO col = 0 , myPoly % N temp2 = bWeights ( col ) / & ( targetPoints ( row ) - & controlPoints ( col )) iMatrix ( row , col ) = temp2 temp1 = temp1 + temp2 END DO DO col = 0 , myPoly % N iMatrix ( row , col ) = iMatrix ( row , col ) / temp1 END DO END IF END DO DO row = 0 , myPoly % M DO col = 0 , myPoly % N myPoly % iMatrix % hostData ( col , row ) = REAL ( iMatrix ( row , col ), prec ) END DO END DO END SUBROUTINE CalculateInterpolationMatrix ! ================================================================================================ ! ! ! CalculateDerivativeMatrix (PRIVATE) ! !   Calculates and stores the derivative matrix and its transpose. !   Generates a matrix that can be used to approximate derivatives at the interpolation nodes. ! !   This function is from Alg. 37 on pg. 82 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! SUBROUTINE CalculateDerivativeMatrix ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: row , col REAL ( real64 ) :: dmat ( 0 : myPoly % N , 0 : myPoly % N ) REAL ( real64 ) :: dgmat ( 0 : myPoly % N , 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: qWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) DO row = 0 , myPoly % N bWeights ( row ) = REAL ( myPoly % bWeights % hostData ( row ), real64 ) qWeights ( row ) = REAL ( myPoly % qWeights % hostData ( row ), real64 ) controlPoints ( row ) = REAL ( myPoly % controlPoints % hostData ( row ), real64 ) END DO DO row = 0 , myPoly % N dmat ( row , row ) = 0.0_prec DO col = 0 , myPoly % N IF (. NOT . ( col == row )) THEN dmat ( row , col ) = bWeights ( col ) / & ( bWeights ( row ) * & ( controlPoints ( row ) - & controlPoints ( col ))) dmat ( row , row ) = dmat ( row , row ) - dmat ( row , col ) END IF END DO END DO DO row = 0 , myPoly % N DO col = 0 , myPoly % N dgmat ( row , col ) = - dmat ( col , row ) * & qWeights ( col ) / & qWeights ( row ) END DO END DO DO row = 0 , myPoly % N DO col = 0 , myPoly % N myPoly % dMatrix % hostData ( row , col ) = REAL ( dmat ( col , row ), prec ) myPoly % dgMatrix % hostData ( row , col ) = REAL ( dgmat ( col , row ), prec ) END DO END DO END SUBROUTINE CalculateDerivativeMatrix ! ================================================================================================ ! ! ! CalculateLagrangePolynomials ! !   Evaluates each of the 1-D Lagrange interpolating polynomials at a specified point. ! !   This function is from Alg. 34 on pg. 77 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! FUNCTION CalculateLagrangePolynomials ( myPoly , sE ) RESULT ( lAtS ) IMPLICIT NONE CLASS ( Lagrange ) :: myPoly REAL ( prec ) :: sE REAL ( prec ) :: lAtS ( 0 : myPoly % N ) ! Local INTEGER :: j LOGICAL :: xMatchesNode REAL ( real64 ) :: temp1 , temp2 REAL ( real64 ) :: sELocal REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: lS ( 0 : myPoly % N ) sELocal = REAL ( sE , real64 ) DO j = 0 , myPoly % N controlPoints ( j ) = REAL ( myPoly % controlPoints % hostData ( j ), real64 ) bWeights ( j ) = REAL ( myPoly % bWeights % hostData ( j ), real64 ) END DO xMatchesNode = . FALSE . DO j = 0 , myPoly % N lS ( j ) = 0.0_real64 IF ( AlmostEqual ( sELocal , controlPoints ( j ))) THEN lS ( j ) = 1.0_real64 xMatchesNode = . TRUE . END IF END DO IF ( xMatchesNode ) THEN DO j = 0 , myPoly % N lAtS ( j ) = REAL ( lS ( j ), prec ) END DO RETURN END IF temp1 = 0.0_real64 DO j = 0 , myPoly % N temp2 = bWeights ( j ) / ( sE - controlPoints ( j )) lS ( j ) = temp2 temp1 = temp1 + temp2 END DO lS = lS / temp1 DO j = 0 , myPoly % N lAtS ( j ) = REAL ( lS ( j ), prec ) END DO END FUNCTION CalculateLagrangePolynomials SUBROUTINE WriteHDF5_Lagrange ( this , fileId ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: this INTEGER ( HID_T ), INTENT ( in ) :: fileId CALL CreateGroup_HDF5 ( fileId , '/interp' ) CALL WriteArray_HDF5 ( fileId , '/interp/controlpoints' , & this % controlPoints ) CALL WriteArray_HDF5 ( fileId , '/interp/qweights' , & this % qWeights ) CALL WriteArray_HDF5 ( fileId , '/interp/dgmatrix' , & this % dgMatrix ) CALL WriteArray_HDF5 ( fileId , '/interp/dmatrix' , & this % dMatrix ) CALL WriteArray_HDF5 ( fileId , '/interp/bmatrix' , & this % bMatrix ) CALL WriteArray_HDF5 ( fileId , '/interp/imatrix' , & this % iMatrix ) END SUBROUTINE WriteHDF5_Lagrange END MODULE SELF_Lagrange","tags":"","loc":"sourcefile/self_lagrange.f90.html"},{"title":"SELF_Model.f90 – SELF","text":"Contents Modules SELF_Model Source Code SELF_Model.f90 Source Code ! ! Copyright 2020-2022 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : support@fluidnumerics.com ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Model USE SELF_SupportRoutines USE SELF_Metadata USE SELF_Mesh USE SELF_MappedData USE SELF_HDF5 USE HDF5 USE FEQParse IMPLICIT NONE #include \"SELF_Macros.h\" ! //////////////////////////////////////////////// ! !   Time integration parameters ! Runge-Kutta 2nd Order (Low Storage) REAL ( prec ), PARAMETER :: rk2_a ( 1 : 2 ) = ( / 0.0_PREC , - 0.5_PREC / ) REAL ( prec ), PARAMETER :: rk2_b ( 1 : 2 ) = ( / 0.5_PREC , 0.5_PREC / ) REAL ( prec ), PARAMETER :: rk2_g ( 1 : 2 ) = ( / 0.5_PREC , 1.0_PREC / ) ! Williamson's Runge-Kutta 3rd Order (Low Storage) REAL ( prec ), PARAMETER :: rk3_a ( 1 : 3 ) = ( / 0.0_PREC , - 5.0_PREC / 9.0_PREC , - 15 3.0_PREC / 12 8.0_PREC / ) REAL ( prec ), PARAMETER :: rk3_b ( 1 : 3 ) = ( / 0.0_PREC , 1.0_PREC / 3.0_PREC , 3.0_PREC / 4.0_PREC / ) REAL ( prec ), PARAMETER :: rk3_g ( 1 : 3 ) = ( / 1.0_PREC / 3.0_PREC , 1 5.0_PREC / 1 6.0_PREC , 8.0_PREC / 1 5.0_PREC / ) ! Carpenter-Kennedy Runge-Kuttta 4th Order (Low Storage) REAL ( prec ), PARAMETER :: rk4_a ( 1 : 5 ) = ( / 0.0_PREC , & - 1.0_PREC , & - 1.0_PREC / 3.0_PREC + 2.0_PREC ** ( 2.0_PREC / 3.0_PREC ) / 6.0_PREC , & - 2.0_PREC ** ( 1.0_PREC / 3.0_PREC ) - 2.0_PREC ** ( 2.0_PREC / 3.0_PREC ) - 2.0_PREC , & - 1.0_PREC + 2.0_PREC ** ( 1.0_PREC / 3.0_PREC ) / ) REAL ( prec ), PARAMETER :: rk4_b ( 1 : 5 ) = ( / 0.0_PREC , & 2.0_PREC / 3.0_PREC + 2.0_PREC ** ( 1.0_PREC / 3.0_PREC ) / 3.0_PREC + 2.0_PREC ** ( 2.0_PREC / 3.0_PREC ) / 6.0_PREC , & 2.0_PREC / 3.0_PREC + 2.0_PREC ** ( 1.0_PREC / 3.0_PREC ) / 3.0_PREC + 2.0_PREC ** ( 2.0_PREC / 3.0_PREC ) / 6.0_PREC , & 1.0_PREC / 3.0_PREC - 2.0_PREC ** ( 1.0_PREC / 3.0_PREC ) / 3.0_PREC - 2.0_PREC ** ( 2.0_PREC / 3.0_PREC ) / 6.0_PREC , & 1.0_PREC / ) REAL ( prec ), PARAMETER :: rk4_g ( 1 : 5 ) = ( / & 2.0_PREC / 3.0_PREC + 2.0_PREC ** ( 1.0_PREC / 3.0_PREC ) / 3.0_PREC + 2.0_PREC ** ( 2.0_PREC / 3.0_PREC ) / 6.0_PREC , & - 2.0_PREC ** ( 2.0_PREC / 3.0_PREC ) / 6.0_PREC + 1.0_PREC / 6.0_PREC , & - 1.0_PREC / 3.0_PREC - 2.0_PREC * 2.0_PREC ** ( 1.0_PREC / 3.0_PREC ) / 3.0_PREC - 2.0_PREC ** ( 2.0_PREC / 3.0_PREC ) / 3.0_PREC , & 1.0_PREC / 3.0_PREC - 2.0_PREC ** ( 1.0_PREC / 3.0_PREC ) / 3.0_PREC - 2.0_PREC ** ( 2.0_PREC / 3.0_PREC ) / 6.0_PREC , & 1.0_PREC / 3.0_PREC + 2.0_PREC ** ( 1.0_PREC / 3.0_PREC ) / 6.0_PREC + 2.0_PREC ** ( 2.0_PREC / 3.0_PREC ) / 1 2.0_PREC / ) ! INTEGER , PARAMETER :: SELF_EULER = 100 INTEGER , PARAMETER :: SELF_RK2 = 200 INTEGER , PARAMETER :: SELF_RK3 = 300 INTEGER , PARAMETER :: SELF_RK4 = 400 INTEGER , PARAMETER :: SELF_AB2 = 201 INTEGER , PARAMETER :: SELF_AB3 = 301 INTEGER , PARAMETER :: SELF_AB4 = 401 INTEGER , PARAMETER :: SELF_INTEGRATOR_LENGTH = 10 ! max length of integrator methods when specified as char INTEGER , PARAMETER :: SELF_EQUATION_LENGTH = 500 ! //////////////////////////////////////////////// ! !   Boundary Condition parameters ! ! Conditions on the solution INTEGER , PARAMETER :: SELF_BC_PRESCRIBED = 100 INTEGER , PARAMETER :: SELF_BC_RADIATION = 101 INTEGER , PARAMETER :: SELF_BC_NONORMALFLOW = 102 ! Conditions on the solution gradients INTEGER , PARAMETER :: SELF_BC_PRESCRIBED_STRESS = 200 INTEGER , PARAMETER :: SELF_BC_NOSTRESS = 201 ! //////////////////////////////////////////////// ! !   Model Formulations ! INTEGER , PARAMETER :: SELF_FORMULATION_LENGTH = 30 ! max length of integrator methods when specified as char TYPE , ABSTRACT :: Model LOGICAL :: gpuAccel ! Time integration attributes PROCEDURE ( SELF_timeIntegrator ), POINTER :: timeIntegrator => Euler_timeIntegrator REAL ( prec ) :: dt REAL ( prec ) :: t INTEGER :: ioIterate = 0 ! Standard Diagnostics REAL ( prec ) :: entropy ! Mathematical entropy function for the model ! Domain Decomposition TYPE ( MPILayer ), POINTER :: decomp CONTAINS PROCEDURE :: IncrementIOCounter PROCEDURE :: PrintType => PrintType_Model PROCEDURE :: SetInitialConditions => SetInitialConditions_Model PROCEDURE :: ForwardStep => ForwardStep_Model PROCEDURE :: Euler_timeIntegrator ! Adams-Bashforth Methods PROCEDURE ( ResizePrevSol ), DEFERRED :: ResizePrevSol PROCEDURE :: AdamsBashforth2_timeIntegrator PROCEDURE ( UpdateGAB ), DEFERRED :: UpdateGAB2 PROCEDURE :: AdamsBashforth3_timeIntegrator PROCEDURE ( UpdateGAB ), DEFERRED :: UpdateGAB3 PROCEDURE :: AdamsBashforth4_timeIntegrator PROCEDURE ( UpdateGAB ), DEFERRED :: UpdateGAB4 ! Runge-Kutta methods PROCEDURE :: LowStorageRK2_timeIntegrator PROCEDURE ( UpdateGRK ), DEFERRED :: UpdateGRK2 PROCEDURE :: LowStorageRK3_timeIntegrator PROCEDURE ( UpdateGRK ), DEFERRED :: UpdateGRK3 PROCEDURE :: LowStorageRK4_timeIntegrator PROCEDURE ( UpdateGRK ), DEFERRED :: UpdateGRK4 !    PROCEDURE :: CrankNicholson_timeIntegrator PROCEDURE :: PreTendency => PreTendency_Model PROCEDURE :: PreFlux => PreFlux_Model PROCEDURE :: SourceMethod => Source_Model PROCEDURE :: FluxMethod => Flux_Model PROCEDURE :: RiemannSolver => RiemannSolver_Model PROCEDURE :: UpdateBoundary => UpdateBoundary_Model PROCEDURE :: SetBoundaryCondition => SetBoundaryCondition_Model PROCEDURE :: ReportEntropy => ReportEntropy_Model PROCEDURE :: CalculateEntropy => CalculateEntropy_Model PROCEDURE ( UpdateSolution ), DEFERRED :: UpdateSolution PROCEDURE ( CalculateTendency ), DEFERRED :: CalculateTendency PROCEDURE ( ReadModel ), DEFERRED :: ReadModel PROCEDURE ( WriteModel ), DEFERRED :: WriteModel PROCEDURE ( WriteTecplot ), DEFERRED :: WriteTecplot GENERIC :: SetTimeIntegrator => SetTimeIntegrator_withInt , & SetTimeIntegrator_withChar PROCEDURE , PRIVATE :: SetTimeIntegrator_withInt PROCEDURE , PRIVATE :: SetTimeIntegrator_withChar PROCEDURE :: SetSimulationTime PROCEDURE :: GetSimulationTime PROCEDURE :: EnableGPUAccel => EnableGPUAccel_Model PROCEDURE :: DisableGPUAccel => DisableGPUAccel_Model END TYPE Model INTERFACE SUBROUTINE SELF_timeIntegrator ( this , tn ) USE SELF_Constants , ONLY : prec IMPORT Model IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: tn END SUBROUTINE SELF_timeIntegrator END INTERFACE INTERFACE SUBROUTINE ResizePrevSol ( this , m ) IMPORT Model IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m END SUBROUTINE ResizePrevSol END INTERFACE INTERFACE SUBROUTINE UpdateGAB ( this , m ) IMPORT Model IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m END SUBROUTINE UpdateGAB END INTERFACE INTERFACE SUBROUTINE UpdateGRK ( this , m ) IMPORT Model IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m END SUBROUTINE UpdateGRK END INTERFACE INTERFACE SUBROUTINE UpdateSolution ( this , dt ) USE SELF_Constants , ONLY : prec IMPORT Model IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), OPTIONAL , INTENT ( in ) :: dt END SUBROUTINE UpdateSolution END INTERFACE INTERFACE SUBROUTINE CalculateTendency ( this ) IMPORT Model IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this END SUBROUTINE CalculateTendency END INTERFACE INTERFACE SUBROUTINE WriteModel ( this , filename ) IMPORT Model IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ), OPTIONAL :: filename END SUBROUTINE WriteModel END INTERFACE INTERFACE SUBROUTINE ReadModel ( this , filename ) IMPORT Model IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: filename END SUBROUTINE ReadModel END INTERFACE INTERFACE SUBROUTINE WriteTecplot ( this , filename ) IMPORT Model IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ), OPTIONAL :: filename END SUBROUTINE WriteTecplot END INTERFACE CONTAINS SUBROUTINE IncrementIOCounter ( this ) IMPLICIT NONE CLASS ( Model ), intent ( inout ) :: this ! Increment the ioIterate this % ioIterate = this % ioIterate + 1 END SUBROUTINE IncrementIOCounter FUNCTION GetBCFlagForChar ( charFlag ) RESULT ( intFlag ) !! This method is used to return the integer flag from a char for boundary conditions !! IMPLICIT NONE CHARACTER ( * ), INTENT ( in ) :: charFlag INTEGER :: intFlag SELECT CASE ( UpperCase ( TRIM ( charFlag )) ) CASE ( \"PRESCRIBED\" ) intFlag = SELF_BC_PRESCRIBED CASE ( \"RADIATION\" ) intFlag = SELF_BC_RADIATION CASE ( \"NO_NORMAL_FLOW\" ) intFlag = SELF_BC_NONORMALFLOW CASE ( \"PRESCRIBED_STRESS\" ) intFlag = SELF_BC_PRESCRIBED_STRESS CASE ( \"NO_STRESS\" ) intFlag = SELF_BC_NOSTRESS CASE DEFAULT intFlag = 0 END SELECT END FUNCTION GetBCFlagForChar SUBROUTINE PrintType_Model ( this ) #undef __FUNC__ #define __FUNC__ \"PrintType\" IMPLICIT NONE CLASS ( Model ), INTENT ( in ) :: this INFO ( \"None\" ) END SUBROUTINE PrintType_Model SUBROUTINE PreTendency_Model ( this ) !! PreTendency is a template routine that is used to house any additional calculations !! that you want to execute at the beginning of the tendency calculation routine. !! This default PreTendency simply returns back to the caller without executing any instructions !! !! The intention is to provide a method that can be overridden through type-extension, to handle !! any steps that need to be executed before proceeding with the usual tendency calculation methods. !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this RETURN END SUBROUTINE PreTendency_Model SUBROUTINE PreFlux_Model ( this ) !! PreFlux is a template routine that is used to house any additional calculations !! that you want to execute just before the calculation of flux terms. !! This default PreFlux simply returns back to the caller without executing any instructions !! !! The intention is to provide a method that can be overridden through type-extension, to handle !! any steps that need to be executed before proceeding with the usual tendency calculation methods. !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this RETURN END SUBROUTINE PreFlux_Model SUBROUTINE Source_Model ( this ) !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this RETURN END SUBROUTINE Source_Model SUBROUTINE RiemannSolver_Model ( this ) !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this RETURN END SUBROUTINE RiemannSolver_Model SUBROUTINE Flux_Model ( this ) !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this RETURN END SUBROUTINE Flux_Model SUBROUTINE UpdateBoundary_Model ( this ) !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this RETURN END SUBROUTINE UpdateBoundary_Model SUBROUTINE SetBoundaryCondition_Model ( this ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this RETURN END SUBROUTINE SetBoundaryCondition_Model SUBROUTINE SetTimeIntegrator_withInt ( this , integrator ) !! Sets the time integrator method, using an integer flag !! !! Valid options for  are !! !!    SELF_EULER !!    SELF_RK3 !!    SELF_RK4 !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: integrator SELECT CASE ( integrator ) CASE ( SELF_EULER ) this % timeIntegrator => Euler_timeIntegrator CASE ( SELF_AB2 ) this % timeIntegrator => AdamsBashforth2_timeIntegrator CALL this % ResizePrevSol ( 2 ) CASE ( SELF_AB3 ) this % timeIntegrator => AdamsBashforth3_timeIntegrator CALL this % ResizePrevSol ( 3 ) CASE ( SELF_AB4 ) this % timeIntegrator => AdamsBashforth4_timeIntegrator CALL this % ResizePrevSol ( 4 ) CASE ( SELF_RK2 ) this % timeIntegrator => LowStorageRK2_timeIntegrator CASE ( SELF_RK3 ) this % timeIntegrator => LowStorageRK3_timeIntegrator CASE ( SELF_RK4 ) this % timeIntegrator => LowStorageRK4_timeIntegrator CASE DEFAULT this % timeIntegrator => LowStorageRK3_timeIntegrator END SELECT END SUBROUTINE SetTimeIntegrator_withInt SUBROUTINE SetTimeIntegrator_withChar ( this , integrator ) !! Sets the time integrator method, using a character input !! !! Valid options for integrator are !! !!   \"euler\" !!   \"rk3\" !!   \"rk4\" !! !! Note that the character provided is not case-sensitive !! IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: integrator ! Local CHARACTER ( SELF_INTEGRATOR_LENGTH ) :: upperCaseInt upperCaseInt = UpperCase ( TRIM ( integrator )) SELECT CASE ( TRIM ( upperCaseInt )) CASE ( \"EULER\" ) this % timeIntegrator => Euler_timeIntegrator CASE ( \"AB2\" ) this % timeIntegrator => AdamsBashforth2_timeIntegrator CALL this % ResizePrevSol ( 2 ) CASE ( \"AB3\" ) this % timeIntegrator => AdamsBashforth3_timeIntegrator CALL this % ResizePrevSol ( 3 ) CASE ( \"AB4\" ) this % timeIntegrator => AdamsBashforth4_timeIntegrator CALL this % ResizePrevSol ( 4 ) CASE ( \"RK2\" ) this % timeIntegrator => LowStorageRK2_timeIntegrator CASE ( \"RK3\" ) this % timeIntegrator => LowStorageRK3_timeIntegrator CASE ( \"RK4\" ) this % timeIntegrator => LowStorageRK4_timeIntegrator CASE DEFAULT this % timeIntegrator => LowStorageRK3_timeIntegrator END SELECT END SUBROUTINE SetTimeIntegrator_withChar SUBROUTINE GetSimulationTime ( this , t ) !! Returns the current simulation time stored in the model % t attribute IMPLICIT NONE CLASS ( Model ), INTENT ( in ) :: this REAL ( prec ), INTENT ( out ) :: t t = this % t END SUBROUTINE GetSimulationTime SUBROUTINE SetSimulationTime ( this , t ) !! Sets the model % t attribute with the provided simulation time IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: t this % t = t END SUBROUTINE SetSimulationTime SUBROUTINE EnableGPUAccel_Model ( this ) #undef __FUNC__ #define __FUNC__ \"EnableGPUAccel\" IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN this % gpuAccel = . TRUE . ELSE this % gpuAccel = . FALSE . WARNING ( \"GPU acceleration requested, but no GPU is available\" ) END IF END SUBROUTINE EnableGPUAccel_Model SUBROUTINE SetInitialConditions_Model ( this ) #undef __FUNC__ #define __FUNC__ \"SetInitialConditions\" IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this INFO ( \"No model, so nothing to set\" ) END SUBROUTINE SetInitialConditions_Model SUBROUTINE DisableGPUAccel_Model ( this ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this this % gpuAccel = . FALSE . END SUBROUTINE DisableGPUAccel_Model SUBROUTINE CalculateEntropy_Model ( this ) !! Base method for calculating entropy of a model !! When this method is not overridden, the entropy !! is simply set to 0.0. When you develop a model !! built on top of this abstract class or one of its !! children, it is recommended that you define a !! convex mathematical entropy function that is used !! as a measure of the model stability. IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this this % entropy = 0.0_PREC END SUBROUTINE CalculateEntropy_Model SUBROUTINE ReportEntropy_Model ( this ) #undef __FUNC__ #define __FUNC__ \"ReportEntropy\" !! Base method for reporting the entropy of a model !! to stdout. Only override this procedure if additional !! reporting is needed. Alternatively, if you think !! additional reporting would be valuable for all models, !! open a pull request with modifications to this base !! method. USE , INTRINSIC :: ISO_FORTRAN_ENV IMPLICIT NONE CLASS ( Model ), INTENT ( in ) :: this ! Local INTEGER , PARAMETER :: ucs2 = SELECTED_CHAR_KIND ( 'ISO_10646' ) CHARACTER ( KIND = ucs2 , len = 20 ) :: modelTime CHARACTER ( KIND = ucs2 , len = 20 ) :: entropy CHARACTER ( KIND = ucs2 , len = :), ALLOCATABLE :: str IF ( this % decomp % rankId == 0 ) THEN ! Copy the time and entropy to a string WRITE ( modelTime , \"(ES16.7E3)\" ) this % t WRITE ( entropy , \"(ES16.7E3)\" ) this % entropy ! Write the output to STDOUT OPEN ( OUTPUT_UNIT , ENCODING = 'utf-8' ) WRITE ( OUTPUT_UNIT , '(\"INFO : [\",A,\"] : \")' , ADVANCE = 'no' ) __ FUNC__ str = ucs2_ 't\\u1D62 =' // TRIM ( modelTime ) WRITE ( OUTPUT_UNIT , '(A)' , ADVANCE = 'no' ) str str = ucs2_ '  |  e\\u1D62 =' // TRIM ( entropy ) WRITE ( OUTPUT_UNIT , '(A)' , ADVANCE = 'yes' ) str END IF END SUBROUTINE ReportEntropy_Model ! ////////////////////////////////////// ! !       Time Integrators                 ! SUBROUTINE ForwardStep_Model ( this , tn , dt , ioInterval ) !!  Forward steps the model using the associated tendency procedure and time integrator !! !!  If the final time  is provided, the model is forward stepped to that final time, !!  otherwise, the model is forward stepped only a single time step !! !!  If a time step is provided through the interface, the model time step size is updated !!  and that time step is used to update the model !! !! If ioInterval is provided, file IO will be conducted every ioInterval seconds until tn !! is reached IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), OPTIONAL , INTENT ( in ) :: tn REAL ( prec ), OPTIONAL , INTENT ( in ) :: dt REAL ( prec ), OPTIONAL , INTENT ( in ) :: ioInterval ! Local REAL ( prec ) :: targetTime , tNext INTEGER :: i , nIO IF ( PRESENT ( dt )) THEN this % dt = dt END IF IF ( PRESENT ( tn )) THEN targetTime = tn ELSE targetTime = this % t + this % dt END IF IF ( PRESENT ( ioInterval )) THEN nIO = INT (( targetTime - this % t ) / ioInterval ) DO i = 1 , nIO tNext = this % t + ioInterval CALL this % timeIntegrator ( tNext ) this % t = tNext CALL this % WriteModel () CALL this % IncrementIOCounter () CALL this % CalculateEntropy () CALL this % ReportEntropy () END DO ELSE CALL this % timeIntegrator ( targetTime ) this % t = targetTime CALL this % CalculateEntropy () CALL this % ReportEntropy () END IF END SUBROUTINE ForwardStep_Model SUBROUTINE Euler_timeIntegrator ( this , tn ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: tn ! Local REAL ( prec ) :: tRemain REAL ( prec ) :: dtLim dtLim = this % dt ! Get the max time step size from the dt attribute DO WHILE ( this % t < tn ) tRemain = tn - this % t this % dt = MIN ( dtLim , tRemain ) CALL this % CalculateTendency () CALL this % UpdateSolution () this % t = this % t + this % dt END DO this % dt = dtLim END SUBROUTINE Euler_timeIntegrator SUBROUTINE AdamsBashforth2_timeIntegrator ( this , tn ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: tn ! Local INTEGER :: m REAL ( prec ) :: tRemain REAL ( prec ) :: dtLim REAL ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute t0 = this % t ! Do a single step with RK2 ! Initialize the PrevSol attribute CALL this % UpdateGAB2 ( 0 ) CALL this % LowStorageRK2_timeIntegrator ( t0 + this % dt ) DO WHILE ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = MIN ( dtLim , tRemain ) CALL this % UpdateGAB2 ( 2 ) ! Store the solution in PrevSol and store the interpolated ! solution in the solution attribute for tendency calculation CALL this % CalculateTendency () CALL this % UpdateGAB2 ( 1 ) ! Reset the solution from the PrevSol CALL this % UpdateSolution () this % t = t0 + this % dt END DO this % dt = dtLim END SUBROUTINE AdamsBashforth2_timeIntegrator SUBROUTINE AdamsBashforth3_timeIntegrator ( this , tn ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: tn ! Local INTEGER :: m REAL ( prec ) :: tRemain REAL ( prec ) :: dtLim REAL ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute ! Do two time steps with RK3 ! Initialize the PrevSol attribute t0 = this % t CALL this % UpdateGAB3 ( 0 ) CALL this % LowStorageRK3_timeIntegrator ( t0 + this % dt ) t0 = this % t CALL this % UpdateGAB3 ( 1 ) CALL this % LowStorageRK3_timeIntegrator ( t0 + this % dt ) DO WHILE ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = MIN ( dtLim , tRemain ) CALL this % UpdateGAB3 ( 3 ) ! Store the solution in PrevSol and store the interpolated ! solution in the solution attribute for tendency calculation CALL this % CalculateTendency () CALL this % UpdateGAB3 ( 2 ) ! Reset the solution from the PrevSol CALL this % UpdateSolution () this % t = t0 + this % dt END DO this % dt = dtLim END SUBROUTINE AdamsBashforth3_timeIntegrator SUBROUTINE AdamsBashforth4_timeIntegrator ( this , tn ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: tn ! Local INTEGER :: m REAL ( prec ) :: tRemain REAL ( prec ) :: dtLim REAL ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute ! Do three time steps with RK4 ! Initialize the PrevSol attribute t0 = this % t CALL this % UpdateGAB4 ( 0 ) CALL this % LowStorageRK4_timeIntegrator ( t0 + this % dt ) t0 = this % t CALL this % UpdateGAB4 ( 1 ) CALL this % LowStorageRK4_timeIntegrator ( t0 + this % dt ) t0 = this % t CALL this % UpdateGAB4 ( 2 ) CALL this % LowStorageRK4_timeIntegrator ( t0 + this % dt ) DO WHILE ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = MIN ( dtLim , tRemain ) CALL this % UpdateGAB4 ( 4 ) ! Store the solution in PrevSol and store the interpolated ! solution in the solution attribute for tendency calculation CALL this % CalculateTendency () CALL this % UpdateGAB4 ( 3 ) ! Reset the solution from the PrevSol CALL this % UpdateSolution () this % t = t0 + this % dt END DO this % dt = dtLim END SUBROUTINE AdamsBashforth4_timeIntegrator SUBROUTINE LowStorageRK2_timeIntegrator ( this , tn ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: tn ! Local INTEGER :: m REAL ( prec ) :: tRemain REAL ( prec ) :: dtLim REAL ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute DO WHILE ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = MIN ( dtLim , tRemain ) DO m = 1 , 2 CALL this % CalculateTendency () CALL this % UpdateGRK2 ( m ) this % t = t0 + rk2_b ( m ) * this % dt END DO this % t = t0 + this % dt END DO this % dt = dtLim END SUBROUTINE LowStorageRK2_timeIntegrator SUBROUTINE LowStorageRK3_timeIntegrator ( this , tn ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: tn ! Local INTEGER :: m REAL ( prec ) :: tRemain REAL ( prec ) :: dtLim REAL ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute DO WHILE ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = MIN ( dtLim , tRemain ) DO m = 1 , 3 CALL this % CalculateTendency () CALL this % UpdateGRK3 ( m ) this % t = t0 + rk3_b ( m ) * this % dt END DO this % t = t0 + this % dt END DO this % dt = dtLim END SUBROUTINE LowStorageRK3_timeIntegrator SUBROUTINE LowStorageRK4_timeIntegrator ( this , tn ) IMPLICIT NONE CLASS ( Model ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: tn ! Local INTEGER :: m REAL ( prec ) :: tRemain REAL ( prec ) :: dtLim REAL ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute DO WHILE ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = MIN ( dtLim , tRemain ) DO m = 1 , 5 CALL this % CalculateTendency () CALL this % UpdateGRK4 ( m ) this % t = t0 + rk4_b ( m ) * this % dt END DO this % t = t0 + this % dt END DO this % dt = dtLim END SUBROUTINE LowStorageRK4_timeIntegrator !  SUBROUTINE CrankNicholson_timeIntegrator(this,tn) !    !! Solves the equation formed by the Crank Nicholson method !    !! using JFNK, where the Krylov solver is chosen to be !    !! BiCG-Stabilized. !    IMPLICIT NONE !    CLASS(Model),INTENT(inout) :: this !    REAL(prec), INTENT(in) :: tn !    ! Local !    INTEGER :: m !    REAL(prec) :: tRemain !    REAL(prec) :: dtLim !    REAL(prec) :: t0 ! !    dtLim = this % dt ! Get the max time step size from the dt attribute !    DO WHILE (this % t < tn) ! !      t0 = this % t !      tRemain = tn - this % t !      this % dt = MIN( dtLim, tRemain ) !      ! Copy existing solution to old solution ! !      ! Evaluate tendency with old solution ! !      ! Calculate r_k (fixed) -> Store in PrevSol ! !      ! Calculate Fk(m-1) ! !      DO m = 1, SELF_maxJFNKiterations ! ! !        ! Linear iterations on Jk(m-1) dS(m) = -Fk(m-1) !        CALL this % JFNKLinearSolver(t0+dt) ! Use PrevSol to store Fk(m-1), sk(m-1), dSm, rk !                                            ! Linear solver updates !                                            ! dSm, sk(m), and Fk(m) ! !        ! Check for convergence !        !  >> global reduction on dSm (either l2 or lmax) !        !  >> global reduction on Fkm1 (either l2 or lmax) !        ! !        !    -> Both done as reduction on PrevSol attribute - reduction over grid, not variables !        ! ! !      ENDDO ! !      this % t = t0 + this % dt ! !    ENDDO ! !    this % dt = dtLim ! !  END SUBROUTINE CrankNicholson_timeIntegrator END MODULE SELF_Model","tags":"","loc":"sourcefile/self_model.f90.html"},{"title":"SELF_Memory.f90 – SELF","text":"Contents Modules SELF_Memory Source Code SELF_Memory.f90 Source Code ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Memory USE SELF_Constants USE SELF_HIP USE SELF_HIP_enums ! External USE ISO_FORTRAN_ENV USE ISO_C_BINDING IMPLICIT NONE TYPE hfReal_r1 !! Data type for storing one-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r1 PROCEDURE , PUBLIC :: Free => Free_hfReal_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r1 END TYPE hfReal_r1 TYPE hfReal_r2 !! Data type for storing two-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r2 PROCEDURE , PUBLIC :: Free => Free_hfReal_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r2 END TYPE hfReal_r2 TYPE hfReal_r3 !! Data type for storing three-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r3 PROCEDURE , PUBLIC :: Free => Free_hfReal_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r3 END TYPE hfReal_r3 TYPE hfReal_r4 !! Data type for storing four-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r4 PROCEDURE , PUBLIC :: Free => Free_hfReal_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r4 END TYPE hfReal_r4 TYPE hfReal_r5 !! Data type for storing five-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r5 PROCEDURE , PUBLIC :: Free => Free_hfReal_r5 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r5 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r5 END TYPE hfReal_r5 TYPE hfReal_r6 !! Data type for storing one-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r6 PROCEDURE , PUBLIC :: Free => Free_hfReal_r6 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r6 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r6 END TYPE hfReal_r6 TYPE hfReal_r7 !! Data type for storing seven-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r7 PROCEDURE , PUBLIC :: Free => Free_hfReal_r7 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r7 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r7 END TYPE hfReal_r7 TYPE hfInt32_r1 !! Data type for storing one-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r1 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r1 END TYPE hfInt32_r1 TYPE hfInt32_r2 !! Data type for storing two-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r2 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r2 END TYPE hfInt32_r2 TYPE hfInt32_r3 !! Data type for storing three-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r3 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r3 END TYPE hfInt32_r3 TYPE hfInt32_r4 !! Data type for storing four-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r4 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r4 END TYPE hfInt32_r4 CONTAINS FUNCTION GPUAvailable () RESULT ( avail ) IMPLICIT NONE LOGICAL :: avail ! Local INTEGER ( C_INT ) :: gpuCount INTEGER ( KIND ( hipSuccess )) :: err err = hipGetDeviceCount ( gpuCount ) IF ( gpuCount > 0 . AND . err == hipSuccess ) THEN avail = . TRUE . ELSE avail = . FALSE . END IF END FUNCTION GPUAvailable SUBROUTINE Alloc_hfReal_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) this % hostData = 0.0_prec IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r1 SUBROUTINE Alloc_hfReal_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) this % hostData = 0.0_prec IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r2 SUBROUTINE Alloc_hfReal_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) this % hostData = 0.0_prec IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r3 SUBROUTINE Alloc_hfReal_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) this % hostData = 0.0_prec IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r4 SUBROUTINE Alloc_hfReal_r5 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 5 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 5 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ))) this % hostData = 0.0_prec IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r5 SUBROUTINE Alloc_hfReal_r6 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 6 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 6 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ))) this % hostData = 0.0_prec IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r6 SUBROUTINE Alloc_hfReal_r7 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 7 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 7 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ), & loBound ( 7 ): upBound ( 7 ))) this % hostData = 0.0_prec IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r7 SUBROUTINE Alloc_hfInt32_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) this % hostData = 0 IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r1 SUBROUTINE Alloc_hfInt32_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) this % hostData = 0 IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r2 SUBROUTINE Alloc_hfInt32_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) this % hostData = 0 IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r3 SUBROUTINE Alloc_hfInt32_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) this % hostData = 0 IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r4 SUBROUTINE Free_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r1 SUBROUTINE Free_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r2 SUBROUTINE Free_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r3 SUBROUTINE Free_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r4 SUBROUTINE Free_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r5 SUBROUTINE Free_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r6 SUBROUTINE Free_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r7 SUBROUTINE Free_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r1 SUBROUTINE Free_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r2 SUBROUTINE Free_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r3 SUBROUTINE Free_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r4 SUBROUTINE UpdateHost_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r1 SUBROUTINE UpdateHost_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r2 SUBROUTINE UpdateHost_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r3 SUBROUTINE UpdateHost_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r4 SUBROUTINE UpdateHost_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r5 SUBROUTINE UpdateHost_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r6 SUBROUTINE UpdateHost_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r7 SUBROUTINE UpdateHost_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r1 SUBROUTINE UpdateHost_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r2 SUBROUTINE UpdateHost_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r3 SUBROUTINE UpdateHost_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r4 SUBROUTINE UpdateDevice_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r1 SUBROUTINE UpdateDevice_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r2 SUBROUTINE UpdateDevice_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r3 SUBROUTINE UpdateDevice_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r4 SUBROUTINE UpdateDevice_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r5 SUBROUTINE UpdateDevice_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r6 SUBROUTINE UpdateDevice_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r7 SUBROUTINE UpdateDevice_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r1 SUBROUTINE UpdateDevice_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r2 SUBROUTINE UpdateDevice_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r3 SUBROUTINE UpdateDevice_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r4 END MODULE SELF_Memory","tags":"","loc":"sourcefile/self_memory.f90.html"},{"title":"SELF_Geometry.f90 – SELF","text":"Contents Modules SELF_Geometry Source Code SELF_Geometry.f90 Source Code ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Geometry USE SELF_Constants USE SELF_Lagrange USE SELF_Data USE SELF_SupportRoutines USE SELF_Mesh IMPLICIT NONE #include \"SELF_Macros.h\" TYPE , PUBLIC :: SEMGeometry INTEGER :: nElem END TYPE SEMGeometry TYPE , EXTENDS ( SEMGeometry ), PUBLIC :: Geometry1D TYPE ( Scalar1D ) :: x ! Physical Positions TYPE ( Scalar1D ) :: dxds ! Conversion from computational to physical space CONTAINS PROCEDURE , PUBLIC :: Init => Init_Geometry1D PROCEDURE , PUBLIC :: Free => Free_Geometry1D PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_Geometry1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Geometry1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Geometry1D PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D PROCEDURE :: Write => Write_Geometry1D END TYPE Geometry1D TYPE , EXTENDS ( SEMGeometry ), PUBLIC :: SEMQuad TYPE ( Vector2D ) :: x ! Physical positions TYPE ( Tensor2D ) :: dxds ! Covariant basis vectors TYPE ( Tensor2D ) :: dsdx ! Contavariant basis vectors TYPE ( Vector2D ) :: nHat ! Normal Vectors pointing across coordinate lines TYPE ( Scalar2D ) :: nScale ! Boundary scale TYPE ( Scalar2D ) :: J ! Jacobian of the transformation CONTAINS PROCEDURE , PUBLIC :: Init => Init_SEMQuad PROCEDURE , PUBLIC :: Free => Free_SEMQuad PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_SEMQuad PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_SEMQuad PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_SEMQuad PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad PROCEDURE , PRIVATE :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad PROCEDURE , PUBLIC :: CovariantArcMin => CovariantArcMin_SEMQuad !PROCEDURE :: Write => Write_SEMQuad END TYPE SEMQuad TYPE , EXTENDS ( SEMGeometry ), PUBLIC :: SEMHex TYPE ( Vector3D ) :: x ! Physical positions TYPE ( Tensor3D ) :: dxds ! Covariant basis vectors TYPE ( Tensor3D ) :: dsdx ! Contavariant basis vectors TYPE ( Vector3D ) :: nHat ! Normal Vectors pointing across coordinate lines TYPE ( Scalar3D ) :: nScale ! Boundary scale TYPE ( Scalar3D ) :: J ! Jacobian of the transformation CONTAINS PROCEDURE , PUBLIC :: Init => Init_SEMHex PROCEDURE , PUBLIC :: Free => Free_SEMHex PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_SEMHex PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_SEMHex PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_SEMHex PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_SEMHex PROCEDURE , PRIVATE :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex PROCEDURE , PRIVATE :: CheckSides => CheckSides_SEMHex !PROCEDURE :: Write => Write_SEMHex END TYPE SEMHex INTERFACE SUBROUTINE CalculateContravariantBasis_SEMQuad_gpu_wrapper ( dxds , dsdx , N , nEl ) & bind ( c , name = \"CalculateContravariantBasis_SEMQuad_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dxds , dsdx INTEGER ( C_INT ), VALUE :: N , nEl END SUBROUTINE CalculateContravariantBasis_SEMQuad_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper ( dsdx , J , N , nEl ) & bind ( c , name = \"AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dsdx , J INTEGER ( C_INT ), VALUE :: N , nEl END SUBROUTINE AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE CalculateContravariantBasis_SEMHex_gpu_wrapper ( dxds , dsdx , N , nEl ) & bind ( c , name = \"CalculateContravariantBasis_SEMHex_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dxds , dsdx INTEGER ( C_INT ), VALUE :: N , nEl END SUBROUTINE CalculateContravariantBasis_SEMHex_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper ( dsdx , J , N , nEl ) & bind ( c , name = \"AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dsdx , J INTEGER ( C_INT ), VALUE :: N , nEl END SUBROUTINE AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper END INTERFACE CONTAINS SUBROUTINE Init_Geometry1D ( myGeom , interp , nElem ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( out ) :: myGeom TYPE ( Lagrange ), POINTER , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nElem myGeom % nElem = nElem CALL myGeom % x % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_Geometry1D SUBROUTINE Free_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () END SUBROUTINE Free_Geometry1D SUBROUTINE UpdateHost_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () END SUBROUTINE UpdateHost_Geometry1D SUBROUTINE UpdateDevice_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () END SUBROUTINE UpdateDevice_Geometry1D SUBROUTINE GenerateFromMesh_Geometry1D ( myGeom , mesh ) ! Generates the geometry for a 1-D mesh ( set of line segments ) ! Assumes that mesh is using Gauss-Lobatto quadrature and the degree is given by mesh % nGeo IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom TYPE ( Mesh1D ), INTENT ( in ) :: mesh ! Local INTEGER :: iel , i , nid TYPE ( Lagrange ), TARGET :: meshToModel TYPE ( Scalar1D ) :: xMesh CALL meshToModel % Init ( mesh % nGeo , mesh % quadrature ,& myGeom % x % interp % N , & myGeom % x % interp % controlNodeType ) CALL xMesh % Init ( meshToModel ,& 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 DO iel = 1 , mesh % nElem DO i = 0 , mesh % nGeo xMesh % interior % hostData ( i , 1 , iel ) = mesh % nodeCoords % hostData ( nid ) nid = nid + 1 END DO END DO ! Interpolate from the mesh hopr_nodeCoords to the geometry (Possibly not gauss_lobatto quadrature) CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () CALL myGeom % UpdateDevice () CALL xMesh % Free () CALL meshToModel % Free () END SUBROUTINE GenerateFromMesh_Geometry1D SUBROUTINE CalculateMetricTerms_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % Derivative ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % UpdateDevice () END SUBROUTINE CalculateMetricTerms_Geometry1D SUBROUTINE Write_Geometry1D ( myGeom , fileName ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( in ) :: myGeom CHARACTER ( * ), OPTIONAL , INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId ! Local CHARACTER ( LEN = self_FileNameLength ) :: pickupFile IF ( PRESENT ( filename ) ) THEN pickupFile = filename ELSE pickupFile = 'mesh.h5' ENDIF CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) CALL CreateGroup_HDF5 ( fileId , '/quadrature' ) CALL WriteArray_HDF5 ( fileId , '/quadrature/xi' , & myGeom % x % interp % controlPoints ) CALL WriteArray_HDF5 ( fileId , '/quadrature/weights' , & myGeom % x % interp % qWeights ) CALL WriteArray_HDF5 ( fileId , '/quadrature/dgmatrix' , & myGeom % x % interp % dgMatrix ) CALL WriteArray_HDF5 ( fileId , '/quadrature/dmatrix' , & myGeom % x % interp % dMatrix ) CALL CreateGroup_HDF5 ( fileId , '/mesh' ) CALL CreateGroup_HDF5 ( fileId , '/mesh/interior' ) CALL CreateGroup_HDF5 ( fileId , '/mesh/boundary' ) CALL WriteArray_HDF5 ( fileId , '/mesh/interior/x' , myGeom % x % interior ) CALL WriteArray_HDF5 ( fileId , '/mesh/interior/dxds' , myGeom % dxds % interior ) CALL WriteArray_HDF5 ( fileId , '/mesh/boundary/x' , myGeom % x % boundary ) CALL WriteArray_HDF5 ( fileId , '/mesh/boundary/dxds' , myGeom % dxds % boundary ) CALL Close_HDF5 ( fileId ) END SUBROUTINE Write_Geometry1D SUBROUTINE Init_SEMQuad ( myGeom , interp , nElem ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( out ) :: myGeom TYPE ( Lagrange ), POINTER , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nElem myGeom % nElem = nElem CALL myGeom % x % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % dsdx % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % nHat % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % nScale % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % J % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_SEMQuad SUBROUTINE Free_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () CALL myGeom % dsdx % Free () CALL myGeom % nHat % Free () CALL myGeom % nScale % Free () CALL myGeom % J % Free () END SUBROUTINE Free_SEMQuad SUBROUTINE UpdateHost_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () CALL myGeom % dsdx % UpdateHost () CALL myGeom % nHat % UpdateHost () CALL myGeom % nScale % UpdateHost () CALL myGeom % J % UpdateHost () END SUBROUTINE UpdateHost_SEMQuad SUBROUTINE UpdateDevice_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () CALL myGeom % dsdx % UpdateDevice () CALL myGeom % nHat % UpdateDevice () CALL myGeom % nScale % UpdateDevice () CALL myGeom % J % UpdateDevice () END SUBROUTINE UpdateDevice_SEMQuad SUBROUTINE GenerateFromMesh_SEMQuad ( myGeom , mesh ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom TYPE ( Mesh2D ), INTENT ( in ) :: mesh ! Local INTEGER :: iel INTEGER :: i , j , nid TYPE ( Lagrange ), TARGET :: meshToModel TYPE ( Vector2D ) :: xMesh CALL meshToModel % Init ( mesh % nGeo , & mesh % quadrature , & myGeom % x % interp % N , & myGeom % x % interp % controlNodeType ) CALL xMesh % Init ( meshToModel , 1 , mesh % nElem ) ! Set the element internal mesh locations DO iel = 1 , mesh % nElem DO j = 0 , mesh % nGeo DO i = 0 , mesh % nGeo xMesh % interior % hostData ( 1 : 2 , i , j , 1 , iel ) = mesh % nodeCoords % hostData ( 1 : 2 , i , j , iel ) END DO END DO END DO !IF (GPUAvailable()) THEN !  CALL xMesh % UpdateDevice() !  CALL xMesh % GridInterp(myGeom % x,.TRUE.) !  CALL myGeom % x % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % CalculateMetricTerms() !  CALL myGeom % UpdateHost() !ELSE CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () !END IF CALL myGeom % UpdateDevice () CALL xMesh % Free () CALL meshToModel % Free () END SUBROUTINE GenerateFromMesh_SEMQuad SUBROUTINE CalculateContravariantBasis_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom ! Local INTEGER :: iEl , i , j , k REAL ( prec ) :: fac REAL ( prec ) :: mag ! Now calculate the contravariant basis vectors ! In this convention, dsdx(j,i) is contravariant vector i, component j ! To project onto contravariant vector i, dot vector along the first dimension DO iEl = 1 , myGeom % nElem DO j = 0 , myGeom % dxds % interp % N DO i = 0 , myGeom % dxds % interp % N myGeom % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iEl ) = myGeom % dxds % interior % hostData ( 2 , 2 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iEl ) = - myGeom % dxds % interior % hostData ( 1 , 2 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iEl ) = - myGeom % dxds % interior % hostData ( 2 , 1 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iEl ) = myGeom % dxds % interior % hostData ( 1 , 1 , i , j , 1 , iEl ) END DO END DO END DO ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . FALSE .) ! Now, modify the sign of dsdx so that ! myGeom % dsdx % boundary is equal to the outward pointing normal vector DO iEl = 1 , myGeom % nElem DO k = 1 , 4 DO i = 0 , myGeom % J % interp % N IF ( k == selfSide2D_East . OR . k == selfSide2D_North ) THEN fac = SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , 1 , k , iEl )) ELSE fac = - SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , 1 , k , iEl )) END IF IF ( k == 1 ) THEN ! South mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 2 , i , 1 , k , iEl ) / mag ELSEIF ( k == 2 ) THEN ! East mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 , i , 1 , k , iEl ) / mag ELSEIF ( k == 3 ) THEN ! North mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 2 , i , 1 , k , iEl ) / mag ELSEIF ( k == 4 ) THEN ! West mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 , i , 1 , k , iEl ) / mag ENDIF ! Set the directionality for dsdx on the boundaries myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 : 2 , i , 1 , k , iEl ) = & myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 : 2 , i , 1 , k , iEl ) * fac END DO END DO END DO END SUBROUTINE CalculateContravariantBasis_SEMQuad SUBROUTINE CalculateMetricTerms_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom !    IF (GPUAvailable()) THEN !      CALL myGeom % x % Gradient(myGeom % dxds,gpuAccel=.TRUE.) !      CALL myGeom % dxds % BoundaryInterp(gpuAccel=.TRUE.) !      CALL myGeom % dxds % Determinant(myGeom % J,gpuAccel=.TRUE.) !      CALL myGeom % J % BoundaryInterp(gpuAccel=.TRUE.) !      CALL myGeom % UpdateHost() !    ELSE CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . FALSE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . FALSE .) !    END IF CALL myGeom % CalculateContravariantBasis () IF ( GPUAvailable ()) THEN CALL myGeom % dsdx % UpdateDevice () CALL myGeom % nHat % UpdateDevice () CALL myGeom % nScale % UpdateDevice () ENDIF END SUBROUTINE CalculateMetricTerms_SEMQuad FUNCTION CovariantArcMin_SEMQuad ( myGeom ) RESULT ( dxMin ) IMPLICIT NONE CLASS ( SEMQuad ) :: myGeom REAL ( prec ) :: dxMin ! Local INTEGER :: i , j , iEl , N REAL ( prec ) :: dx , dy REAL ( prec ) :: dxds ( 1 : 2 , 1 : 2 ) REAL ( prec ) :: ds ( 0 : myGeom % dxds % interp % N ,& 0 : myGeom % dxds % interp % N ,& 1 : myGeom % nElem ) N = myGeom % dxds % interp % N DO iEl = 1 , myGeom % nElem DO j = 0 , N DO i = 0 , N dxds = myGeom % dxds % interior % hostData ( 1 : 2 , 1 : 2 , i , j , 1 , iEl ) dx = SQRT ( dxds ( 1 , 1 ) ** 2 + dxds ( 1 , 2 ) ** 2 ) dy = SQRT ( dxds ( 2 , 1 ) ** 2 + dxds ( 2 , 2 ) ** 2 ) ds ( i , j , iEl ) = 2.0_prec * MIN ( dx , dy ) / ( REAL ( N , prec ) ** 2 ) ENDDO ENDDO ENDDO dxMin = MINVAL ( ds ) END FUNCTION CovariantArcMin_SEMQuad ! SUBROUTINE Write_SEMQuad(myGeom,fileName) !   IMPLICIT NONE !   CLASS(SEMQuad),INTENT(in) :: myGeom !   CHARACTER(*),OPTIONAL,INTENT(in) :: fileName !   ! Local !   INTEGER(HID_T) :: fileId !   ! Local !   CHARACTER(LEN=self_FileNameLength) :: pickupFile !   IF( PRESENT(filename) )THEN !     pickupFile = filename !   ELSE !     pickupFile = 'mesh.h5' !   ENDIF !   CALL Open_HDF5(pickupFile,H5F_ACC_TRUNC_F,fileId) !   CALL CreateGroup_HDF5(fileId,'/quadrature') !   CALL WriteArray_HDF5(fileId,'/quadrature/xi', & !                        myGeom % x % interp % controlPoints) !   CALL WriteArray_HDF5(fileId,'/quadrature/weights', & !                        myGeom % x % interp % qWeights) !   CALL WriteArray_HDF5(fileId,'/quadrature/dgmatrix', & !                        myGeom % x % interp % dgMatrix) !   CALL WriteArray_HDF5(fileId,'/quadrature/dmatrix', & !                        myGeom % x % interp % dMatrix) !   CALL CreateGroup_HDF5(fileId,'/mesh') !   CALL CreateGroup_HDF5(fileId,'/mesh/interior') !   CALL CreateGroup_HDF5(fileId,'/mesh/boundary') !   CALL WriteArray_HDF5(fileId,'/mesh/interior/x',myGeom % x % interior) !   CALL WriteArray_HDF5(fileId,'/mesh/interior/dxds',myGeom % dxds % interior) !   CALL WriteArray_HDF5(fileId,'/mesh/interior/dsdx',myGeom % dsdx % interior) !   CALL WriteArray_HDF5(fileId,'/mesh/interior/J',myGeom % J % interior) !   CALL WriteArray_HDF5(fileId,'/mesh/boundary/x',myGeom % x % boundary) !   CALL WriteArray_HDF5(fileId,'/mesh/boundary/dxds',myGeom % dxds % boundary) !   CALL WriteArray_HDF5(fileId,'/mesh/boundary/dsdx',myGeom % dsdx % boundary) !   CALL WriteArray_HDF5(fileId,'/mesh/boundary/nHat',myGeom % nHat % boundary) !   CALL WriteArray_HDF5(fileId,'/mesh/boundary/nScale',myGeom % nScale % boundary) !   CALL WriteArray_HDF5(fileId,'/mesh/boundary/J',myGeom % J % boundary) !   CALL Close_HDF5(fileId) ! END SUBROUTINE Write_SEMQuad SUBROUTINE Init_SEMHex ( myGeom , interp , nElem ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( out ) :: myGeom TYPE ( Lagrange ), POINTER , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nElem myGeom % nElem = nElem CALL myGeom % x % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % dsdx % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % nHat % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % nScale % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) CALL myGeom % J % Init ( interp = interp ,& nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_SEMHex SUBROUTINE Free_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () CALL myGeom % dsdx % Free () CALL myGeom % nHat % Free () CALL myGeom % nScale % Free () CALL myGeom % J % Free () END SUBROUTINE Free_SEMHex SUBROUTINE UpdateHost_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () CALL myGeom % dsdx % UpdateHost () CALL myGeom % nHat % UpdateHost () CALL myGeom % nScale % UpdateHost () CALL myGeom % J % UpdateHost () END SUBROUTINE UpdateHost_SEMHex SUBROUTINE UpdateDevice_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () CALL myGeom % dsdx % UpdateDevice () CALL myGeom % nHat % UpdateDevice () CALL myGeom % nScale % UpdateDevice () CALL myGeom % J % UpdateDevice () END SUBROUTINE UpdateDevice_SEMHex SUBROUTINE GenerateFromMesh_SEMHex ( myGeom , mesh ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom TYPE ( Mesh3D ), INTENT ( in ) :: mesh ! Local INTEGER :: iel INTEGER :: i , j , k , nid TYPE ( Lagrange ), TARGET :: meshToModel TYPE ( Vector3D ) :: xMesh CALL meshToModel % Init ( mesh % nGeo , mesh % quadrature ,& myGeom % x % interp % N , & myGeom % x % interp % controlNodeType ) CALL xMesh % Init ( meshToModel ,& 1 , mesh % nElem ) ! Set the element internal mesh locations DO iel = 1 , mesh % nElem DO k = 0 , mesh % nGeo DO j = 0 , mesh % nGeo DO i = 0 , mesh % nGeo xMesh % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) = mesh % nodeCoords % hostData ( 1 : 3 , i , j , k , iel ) END DO END DO END DO END DO ! Interpolate from the mesh hopr_nodeCoords to the geometry (Possibly not gauss_lobatto quadrature) !IF (GPUAvailable()) THEN !  CALL xMesh % UpdateDevice() !  CALL xMesh % GridInterp(myGeom % x,.TRUE.) !  CALL myGeom % x % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % CalculateMetricTerms() !  CALL myGeom % UpdateHost() !ELSE CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () !END IF !    CALL myGeom % CheckSides(mesh) CALL myGeom % UpdateDevice () CALL xMesh % Free () CALL meshToModel % Free () END SUBROUTINE GenerateFromMesh_SEMHex SUBROUTINE CheckSides_SEMHex ( myGeom , mesh ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( in ) :: myGeom TYPE ( Mesh3D ), INTENT ( in ) :: mesh ! INTEGER :: e1 , s1 INTEGER :: e2 , s2 INTEGER :: i1 , j1 INTEGER :: i2 , j2 INTEGER :: flip , bcid REAL ( prec ) :: rms DO e1 = 1 , mesh % nElem DO s1 = 1 , 6 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN ! Interior rms = 0.0_prec IF ( flip == 0 ) THEN DO j1 = 0 , myGeom % x % interp % N DO i1 = 0 , myGeom % x % interp % N rms = rms + & sqrt ( ( myGeom % x % boundary % hostdata ( 1 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 1 , i1 , j1 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 2 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 2 , i1 , j1 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 3 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 3 , i1 , j1 , 1 , s2 , e2 )) ** 2 ) END DO END DO ELSEIF ( flip == 1 ) THEN DO j1 = 0 , myGeom % x % interp % N DO i1 = 0 , myGeom % x % interp % N i2 = j1 j2 = myGeom % x % interp % N - i1 rms = rms + & sqrt ( ( myGeom % x % boundary % hostdata ( 1 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 1 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 2 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 2 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 3 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 3 , i2 , j2 , 1 , s2 , e2 )) ** 2 ) END DO END DO ELSEIF ( flip == 2 ) THEN DO j1 = 0 , myGeom % x % interp % N DO i1 = 0 , myGeom % x % interp % N i2 = myGeom % x % interp % N - i1 j2 = myGeom % x % interp % N - j1 rms = rms + & sqrt ( ( myGeom % x % boundary % hostdata ( 1 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 1 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 2 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 2 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 3 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 3 , i2 , j2 , 1 , s2 , e2 )) ** 2 ) END DO END DO ELSEIF ( flip == 3 ) THEN DO j1 = 0 , myGeom % x % interp % N DO i1 = 0 , myGeom % x % interp % N i2 = myGeom % x % interp % N - j1 j2 = i1 rms = rms + & sqrt ( ( myGeom % x % boundary % hostdata ( 1 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 1 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 2 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 2 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 3 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 3 , i2 , j2 , 1 , s2 , e2 )) ** 2 ) END DO END DO ELSEIF ( flip == 4 ) THEN DO j1 = 0 , myGeom % x % interp % N DO i1 = 0 , myGeom % x % interp % N i2 = j1 j2 = i1 rms = rms + & sqrt ( ( myGeom % x % boundary % hostdata ( 1 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 1 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 2 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 2 , i2 , j2 , 1 , s2 , e2 )) ** 2 + & ( myGeom % x % boundary % hostdata ( 3 , i1 , j1 , 1 , s1 , e1 ) - & myGeom % x % boundary % hostdata ( 3 , i2 , j2 , 1 , s2 , e2 )) ** 2 ) END DO END DO END IF END IF END DO END DO END SUBROUTINE CheckSides_SEMHex SUBROUTINE CalculateContravariantBasis_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom ! Local INTEGER :: iEl , i , j , k REAL ( prec ) :: fac REAL ( prec ) :: mag ! Now calculate the contravariant basis vectors ! In this convention, dsdx(j,i) is contravariant vector i, component j ! To project onto contravariant vector i, dot vector along the first dimension ! TO DO : Curl Invariant Form DO iEl = 1 , myGeom % nElem DO k = 0 , myGeom % dxds % interp % N DO j = 0 , myGeom % dxds % interp % N DO i = 0 , myGeom % dxds % interp % N ! Ja1 myGeom % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) ! Ja2 myGeom % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) ! Ja3 myGeom % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) END DO END DO END DO END DO ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . FALSE .) ! Now, calculate nHat (outward pointing normal) DO iEl = 1 , myGeom % nElem DO k = 1 , 6 DO j = 0 , myGeom % J % interp % N DO i = 0 , myGeom % J % interp % N IF ( k == selfSide3D_Top . OR . k == selfSide3D_East . OR . k == selfSide3D_North ) THEN fac = SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , j , 1 , k , iEl )) ELSE fac = - SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , j , 1 , k , iEl )) END IF IF ( k == 1 ) THEN ! Bottom mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 3 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 3 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 2 ) THEN ! South mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 2 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 2 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 3 ) THEN ! East mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 1 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 4 ) THEN ! North mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 2 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 2 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 5 ) THEN ! West mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 1 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 6 ) THEN ! Top mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 3 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 3 , i , j , 1 , k , iEl ) / mag ENDIF ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , 1 , k , iEl ) = & myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , 1 , k , iEl ) * fac END DO END DO END DO END DO END SUBROUTINE CalculateContravariantBasis_SEMHex SUBROUTINE CalculateMetricTerms_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom !IF (GPUAvailable()) THEN !  CALL myGeom % x % Gradient(myGeom % dxds,gpuAccel=.TRUE.) !  CALL myGeom % dxds % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % dxds % Determinant(myGeom % J,gpuAccel=.TRUE.) !  CALL myGeom % J % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % UpdateHost() !ELSE CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . FALSE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . FALSE .) !END IF CALL myGeom % CalculateContravariantBasis () IF ( GPUAvailable ()) THEN CALL myGeom % UpdateDevice () ENDIF END SUBROUTINE CalculateMetricTerms_SEMHex ! SUBROUTINE Write_SEMHex(myGeom,fileName) !   IMPLICIT NONE !   CLASS(SEMHex),INTENT(in) :: myGeom !   CHARACTER(*),OPTIONAL,INTENT(in) :: fileName !   ! Local !   INTEGER(HID_T) :: fileId !   ! Local !   CHARACTER(LEN=self_FileNameLength) :: pickupFile !   IF( PRESENT(filename) )THEN !     pickupFile = filename !   ELSE !     pickupFile = 'mesh.h5' !   ENDIF !   CALL Open_HDF5(pickupFile,H5F_ACC_TRUNC_F,fileId) !   CALL CreateGroup_HDF5(fileId,'/quadrature') !   CALL WriteArray_HDF5(fileId,'/quadrature/xi', & !                        myGeom % x % interp % controlPoints) !   CALL WriteArray_HDF5(fileId,'/quadrature/weights', & !                        myGeom % x % interp % qWeights) !   CALL WriteArray_HDF5(fileId,'/quadrature/dgmatrix', & !                        myGeom % x % interp % dgMatrix) !   CALL WriteArray_HDF5(fileId,'/quadrature/dmatrix', & !                        myGeom % x % interp % dMatrix) !   CALL CreateGroup_HDF5(fileId,'/mesh') !   CALL CreateGroup_HDF5(fileId,'/mesh/interior') !   CALL CreateGroup_HDF5(fileId,'/mesh/boundary') !   CALL WriteArray_HDF5(fileId,'/mesh/interior/x',myGeom % x % interior) !   CALL WriteArray_HDF5(fileId,'/mesh/interior/dxds',myGeom % dxds % interior) !   CALL WriteArray_HDF5(fileId,'/mesh/interior/dsdx',myGeom % dsdx % interior) !   CALL WriteArray_HDF5(fileId,'/mesh/interior/J',myGeom % J % interior) !   CALL WriteArray_HDF5(fileId,'/mesh/boundary/x',myGeom % x % boundary) !   CALL WriteArray_HDF5(fileId,'/mesh/boundary/dxds',myGeom % dxds % boundary) !   CALL WriteArray_HDF5(fileId,'/mesh/boundary/dsdx',myGeom % dsdx % boundary) !   CALL WriteArray_HDF5(fileId,'/mesh/boundary/nHat',myGeom % nHat % boundary) !   CALL WriteArray_HDF5(fileId,'/mesh/boundary/nScale',myGeom % nScale % boundary) !   CALL WriteArray_HDF5(fileId,'/mesh/boundary/J',myGeom % J % boundary) !   CALL Close_HDF5(fileId) ! END SUBROUTINE Write_SEMHex END MODULE SELF_Geometry","tags":"","loc":"sourcefile/self_geometry.f90.html"},{"title":"SELF_MappedData.f90 – SELF","text":"Contents Modules SELF_MappedData Source Code SELF_MappedData.f90 Source Code ! SELF_MappedData.F90 ! ! Copyright 2020-2022 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : support@fluidnumerics.com ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_MappedData USE SELF_Constants USE SELF_Lagrange USE SELF_Data USE SELF_Mesh USE SELF_Geometry USE SELF_HDF5 USE HDF5 USE FEQParse USE ISO_C_BINDING IMPLICIT NONE #include \"SELF_Macros.h\" TYPE , EXTENDS ( Scalar1D ), PUBLIC :: MappedScalar1D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedScalar1D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedScalar1D GENERIC , PUBLIC :: Derivative => Derivative_MappedScalar1D PROCEDURE , PRIVATE :: Derivative_MappedScalar1D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedScalar1D PROCEDURE , PUBLIC :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar1D END TYPE MappedScalar1D TYPE , EXTENDS ( Scalar2D ), PUBLIC :: MappedScalar2D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedScalar2D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedScalar2D GENERIC , PUBLIC :: Gradient => Gradient_MappedScalar2D PROCEDURE , PRIVATE :: Gradient_MappedScalar2D PROCEDURE , PRIVATE :: GradientSF_MappedScalar2D ! Strong-Form Gradient PROCEDURE , PRIVATE :: GradientBR_MappedScalar2D ! Bassi-Rebay Gradient PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedScalar2D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedScalar2D PROCEDURE , PUBLIC :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar2D PROCEDURE , PUBLIC :: Integral => Integral_MappedScalar2D END TYPE MappedScalar2D TYPE , EXTENDS ( Scalar3D ), PUBLIC :: MappedScalar3D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedScalar3D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedScalar3D GENERIC , PUBLIC :: Gradient => Gradient_MappedScalar3D PROCEDURE , PRIVATE :: Gradient_MappedScalar3D PROCEDURE , PRIVATE :: GradientSF_MappedScalar3D ! Strong-Form Gradient PROCEDURE , PRIVATE :: GradientBR_MappedScalar3D ! Bassi-Rebay Gradient PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedScalar3D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedScalar3D PROCEDURE , PUBLIC :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar3D END TYPE MappedScalar3D TYPE , EXTENDS ( Vector2D ), PUBLIC :: MappedVector2D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedVector2D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedVector2D GENERIC , PUBLIC :: Divergence => Divergence_MappedVector2D PROCEDURE , PRIVATE :: Divergence_MappedVector2D PROCEDURE , PUBLIC :: ContravariantProjection => ContravariantProjection_MappedVector2D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedVector2D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedVector2D PROCEDURE , PUBLIC :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector2D END TYPE MappedVector2D TYPE , EXTENDS ( Vector3D ), PUBLIC :: MappedVector3D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedVector3D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedVector3D GENERIC , PUBLIC :: Divergence => Divergence_MappedVector3D PROCEDURE , PRIVATE :: Divergence_MappedVector3D PROCEDURE , PUBLIC :: ContravariantProjection => ContravariantProjection_MappedVector3D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedVector3D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedVector3D PROCEDURE , PUBLIC :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector3D END TYPE MappedVector3D ! TYPE,EXTENDS(P2Vector2D),PUBLIC :: MappedP2Vector2D ! CONTAINS !   PROCEDURE,PUBLIC :: SideExchange => SideExchange_MappedP2Vector2D !   GENERIC,PUBLIC :: Divergence => Divergence_MappedP2Vector2D !   PROCEDURE,PRIVATE :: Divergence_MappedP2Vector2D !   PROCEDURE,PUBLIC :: ContravariantProjection => ContravariantProjection_MappedP2Vector2D !   !PROCEDURE,PUBLIC :: JacobianWeight => JacobianWeight_MappedP2Vector2D !   PROCEDURE,PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedP2Vector2D !   PROCEDURE,PRIVATE :: ApplyFlip => ApplyFlip_MappedP2Vector2D ! END TYPE MappedP2Vector2D INTERFACE SUBROUTINE GradientBR_MappedScalar2D_gpu_wrapper ( scalar , avgBoundary , dsdx , jacobian , nHat , nScale ,& gradF , dgMatrix , bMatrix , qWeights , N , nVar , nEl ) & bind ( c , name = \"GradientBR_MappedScalar2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , avgBoundary , dsdx , jacobian , nHat , nScale , gradF , dgMatrix , bMatrix , qWeights INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE GradientBR_MappedScalar2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE GradientSF_MappedScalar2D_gpu_wrapper ( scalar , dsdx , jacobian , gradF , dMatrix , N , nVar , nEl ) & bind ( c , name = \"GradientSF_MappedScalar2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , dsdx , jacobian , gradF , dMatrix INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE GradientSF_MappedScalar2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE GradientBR_MappedScalar3D_gpu_wrapper ( scalar , avgBoundary , dsdx , jacobian , nHat , nScale ,& gradF , dgMatrix , bMatrix , qWeights , N , nVar , nEl ) & bind ( c , name = \"GradientBR_MappedScalar3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , avgBoundary , dsdx , jacobian , nHat , nScale , gradF , dgMatrix , bMatrix , qWeights INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE GradientBR_MappedScalar3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE GradientSF_MappedScalar3D_gpu_wrapper ( scalar , dsdx , jacobian , gradF , dMatrix , N , nVar , nEl ) & bind ( c , name = \"GradientSF_MappedScalar3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , dsdx , jacobian , gradF , dMatrix INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE GradientSF_MappedScalar3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedScalar1D_gpu_wrapper ( scalar , dxds , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedScalar1D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , dxds INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedScalar1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedScalar2D_gpu_wrapper ( scalar , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedScalar2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , jacobian INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedScalar2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedScalar3D_gpu_wrapper ( scalar , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedScalar3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , jacobian INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedScalar3D_gpu_wrapper END INTERFACE !  INTERFACE !    SUBROUTINE ContravariantWeight_MappedScalar2D_gpu_wrapper(scalar,workTensor,dsdx,N,nVar,nEl) & !      bind(c,name=\"ContravariantWeight_MappedScalar2D_gpu_wrapper\") !      USE ISO_C_BINDING !      IMPLICIT NONE !      TYPE(c_ptr) :: scalar,workTensor,dsdx !      INTEGER(C_INT),VALUE :: N,nVar,nEl !    END SUBROUTINE ContravariantWeight_MappedScalar2D_gpu_wrapper !  END INTERFACE !  INTERFACE !    SUBROUTINE ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper(scalar,workTensor,dsdx,N,nVar,nEl) & !      bind(c,name=\"ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper\") !      USE ISO_C_BINDING !      IMPLICIT NONE !      TYPE(c_ptr) :: scalar,workTensor,dsdx !      INTEGER(C_INT),VALUE :: N,nVar,nEl !    END SUBROUTINE ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper !  END INTERFACE ! !  INTERFACE !    SUBROUTINE ContravariantWeight_MappedScalar3D_gpu_wrapper(scalar,workTensor,dsdx,N,nVar,nEl) & !      bind(c,name=\"ContravariantWeight_MappedScalar3D_gpu_wrapper\") !      USE ISO_C_BINDING !      IMPLICIT NONE !      TYPE(c_ptr) :: scalar,workTensor,dsdx !      INTEGER(C_INT),VALUE :: N,nVar,nEl !    END SUBROUTINE ContravariantWeight_MappedScalar3D_gpu_wrapper !  END INTERFACE ! !  INTERFACE !    SUBROUTINE ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper(scalar,workTensor,dsdx,N,nVar,nEl) & !      bind(c,name=\"ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper\") !      USE ISO_C_BINDING !      IMPLICIT NONE !      TYPE(c_ptr) :: scalar,workTensor,dsdx !      INTEGER(C_INT),VALUE :: N,nVar,nEl !    END SUBROUTINE ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper !  END INTERFACE INTERFACE SUBROUTINE ContravariantProjection_MappedVector2D_gpu_wrapper ( vector , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantProjection_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: vector , dsdx INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ContravariantProjection_MappedVector2D_gpu_wrapper END INTERFACE ! INTERFACE !   SUBROUTINE ContravariantProjection_MappedP2Vector2D_gpu_wrapper(vector,physical,dsdx,N,nVar,nEl) & !     bind(c,name=\"ContravariantProjection_MappedP2Vector2D_gpu_wrapper\") !     USE ISO_C_BINDING !     IMPLICIT NONE !     TYPE(c_ptr) :: vector,physical,dsdx !     INTEGER(C_INT),VALUE :: N,nVar,nEl !   END SUBROUTINE ContravariantProjection_MappedP2Vector2D_gpu_wrapper ! END INTERFACE INTERFACE SUBROUTINE ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper ( physVector , compVector , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: physVector , compVector , dsdx INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedVector2D_gpu_wrapper ( vector , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: vector , jacobian INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantProjection_MappedVector3D_gpu_wrapper ( vector , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantProjection_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: vector , dsdx INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ContravariantProjection_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper ( physVector , compVector , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: physVector , compVector , dsdx INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedVector3D_gpu_wrapper ( vector , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: vector , jacobian INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE SideExchange_MappedScalar2D_gpu_wrapper ( extBoundary , boundary , & sideInfo , elemToRank , rankId , offset , N , nVar , nEl ) & bind ( c , name = \"SideExchange_MappedScalar2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary , sideInfo , elemToRank INTEGER ( C_INT ), VALUE :: rankId , offset , N , nVar , nEl END SUBROUTINE SideExchange_MappedScalar2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE SideExchange_MappedVector2D_gpu_wrapper ( extBoundary , boundary , & sideInfo , elemToRank , rankId , offset , N , nVar , nEl ) & bind ( c , name = \"SideExchange_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary , sideInfo , elemToRank INTEGER ( C_INT ), VALUE :: rankId , offset , N , nVar , nEl END SUBROUTINE SideExchange_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE SideExchange_MappedScalar3D_gpu_wrapper ( extBoundary , boundary , & sideInfo , elemToRank , rankId , offset , N , nVar , nEl ) & bind ( c , name = \"SideExchange_MappedScalar3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary , sideInfo , elemToRank INTEGER ( C_INT ), VALUE :: rankId , offset , N , nVar , nEl END SUBROUTINE SideExchange_MappedScalar3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE SideExchange_MappedVector3D_gpu_wrapper ( extBoundary , boundary , & sideInfo , elemToRank , rankId , offset , N , nVar , nEl ) & bind ( c , name = \"SideExchange_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary , sideInfo , elemToRank INTEGER ( C_INT ), VALUE :: rankId , offset , N , nVar , nEl END SUBROUTINE SideExchange_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE BassiRebaySides_MappedScalar2D_gpu_wrapper ( avgBoundary , boundary , extBoundary , N , nVar , nEl ) & bind ( c , name = \"BassiRebaySides_MappedScalar2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary , avgBoundary INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE BassiRebaySides_MappedScalar2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE BassiRebaySides_MappedVector2D_gpu_wrapper ( extBoundary , boundary , N , nVar , nEl ) & bind ( c , name = \"BassiRebaySides_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE BassiRebaySides_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE BassiRebaySides_MappedScalar3D_gpu_wrapper ( avgBoundary , boundary , extBoundary , N , nVar , nEl ) & bind ( c , name = \"BassiRebaySides_MappedScalar3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: avgBoundary , extBoundary , boundary INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE BassiRebaySides_MappedScalar3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE BassiRebaySides_MappedVector3D_gpu_wrapper ( extBoundary , boundary , N , nVar , nEl ) & bind ( c , name = \"BassiRebaySides_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE BassiRebaySides_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ApplyFlip_MappedScalar2D_gpu_wrapper ( extBoundary , selfSideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"ApplyFlip_MappedScalar2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: selfSideInfo , elemToRank , extBoundary INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE ApplyFlip_MappedScalar2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ApplyFlip_MappedVector2D_gpu_wrapper ( extBoundary , selfSideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"ApplyFlip_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: selfSideInfo , elemToRank , extBoundary INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE ApplyFlip_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ApplyFlip_MappedScalar3D_gpu_wrapper ( extBoundary , selfSideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"ApplyFlip_MappedScalar3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: selfSideInfo , elemToRank , extBoundary INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE ApplyFlip_MappedScalar3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ApplyFlip_MappedVector3D_gpu_wrapper ( extBoundary , selfSideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"ApplyFlip_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: selfSideInfo , elemToRank , extBoundary INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE ApplyFlip_MappedVector3D_gpu_wrapper END INTERFACE CONTAINS ! ---------------------- Scalars ---------------------- ! SUBROUTINE SetInteriorFromEquation_MappedScalar1D ( scalar , geometry , time ) !!  Sets the scalar % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( inout ) :: scalar TYPE ( Geometry1D ), INTENT ( in ) :: geometry REAL ( prec ), INTENT ( in ) :: time ! Local INTEGER :: i , iEl , iVar REAL ( prec ) :: x ! TO DO : Check if scalar % eqn is set before proceeding DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO i = 0 , scalar % interp % N ! Get the mesh positions x = geometry % x % interior % hostData ( i , 1 , iEl ) scalar % interior % hostData ( i , iVar , iEl ) = & scalar % eqn ( iVar ) % Evaluate (( / x , 0.0_prec , 0.0_prec , time / )) ENDDO ENDDO ENDDO END SUBROUTINE SetInteriorFromEquation_MappedScalar1D SUBROUTINE SideExchange_MappedScalar1D ( scalar , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( inout ) :: scalar TYPE ( Mesh1D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 , e2Global INTEGER :: flip , bcid INTEGER :: i1 , i2 , ivar INTEGER :: neighborRank INTEGER :: rankId , offset rankId = decomp % rankId offset = decomp % offsetElem % hostData ( rankId ) if ( gpuAccel ) then call scalar % boundary % updatehost () endif DO e1 = 1 , mesh % nElem IF ( e1 == 1 ) THEN s1 = 2 e2 = e1 + 1 s2 = 1 !neighborRank = decomp % elemToRank % hostData(e2Global) DO ivar = 1 , scalar % nvar scalar % extBoundary % hostData ( ivar , s1 , e1 ) = scalar % boundary % hostData ( ivar , s2 , e2 ) ENDDO ELSEIF ( e1 == mesh % nElem ) THEN s1 = 1 e2 = e1 - 1 s2 = 2 !neighborRank = decomp % elemToRank % hostData(e2Global) DO ivar = 1 , scalar % nvar scalar % extBoundary % hostData ( ivar , s1 , e1 ) = scalar % boundary % hostData ( ivar , s2 , e2 ) ENDDO ELSE s1 = 1 e2 = e1 - 1 s2 = 2 !neighborRank = decomp % elemToRank % hostData(e2Global) DO ivar = 1 , scalar % nvar scalar % extBoundary % hostData ( ivar , s1 , e1 ) = scalar % boundary % hostData ( ivar , s2 , e2 ) ENDDO s1 = 2 e2 = e1 + 1 s2 = 1 !neighborRank = decomp % elemToRank % hostData(e2Global) DO ivar = 1 , scalar % nvar scalar % extBoundary % hostData ( ivar , s1 , e1 ) = scalar % boundary % hostData ( ivar , s2 , e2 ) ENDDO ENDIF ENDDO if ( gpuAccel ) then call scalar % extBoundary % updatedevice () endif END SUBROUTINE SideExchange_MappedScalar1D SUBROUTINE BassiRebaySides_MappedScalar1D ( scalar , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i if ( gpuAccel ) then call scalar % boundary % updatehost () call scalar % extBoundary % updatehost () endif DO iel = 1 , scalar % nElem DO ivar = 1 , scalar % nVar ! Left side - we account for the -\\hat{x} normal scalar % avgBoundary % hostData ( ivar , 1 , iel ) = - 0.5_prec * ( & scalar % boundary % hostData ( ivar , 1 , iel ) + & scalar % extBoundary % hostData ( ivar , 1 , iel )) ! Right side - we account for the +\\hat{x} normal scalar % avgBoundary % hostData ( ivar , 2 , iel ) = 0.5_prec * ( & scalar % boundary % hostData ( ivar , 2 , iel ) + & scalar % extBoundary % hostData ( ivar , 2 , iel )) END DO END DO if ( gpuAccel ) then call scalar % avgBoundary % updateDevice () endif END SUBROUTINE BassiRebaySides_MappedScalar1D SUBROUTINE Derivative_MappedScalar1D ( scalar , geometry , dF , dForm , gpuAccel ) ! Strong Form Operator ! ! Calculates the gradient of a scalar 1D function using the conservative form of the ! mapped gradient operator ! ! df/dx =  d\\xi/dx( df/d\\xi ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( in ) :: scalar TYPE ( Geometry1D ), INTENT ( in ) :: geometry TYPE ( MappedScalar1D ), INTENT ( inout ) :: dF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL scalar % interp % DGDerivative_1D ( scalar % interior % deviceData , & scalar % boundary % deviceData , & df % interior % deviceData , & scalar % nVar , & scalar % nElem ) ELSE CALL scalar % interp % DGDerivative_1D ( scalar % interior % hostData , & scalar % boundary % hostData , & df % interior % hostData , & scalar % nVar , & scalar % nElem ) END IF ELSEIF ( dForm == selfWeakBRForm ) THEN IF ( gpuAccel ) THEN CALL scalar % interp % DGDerivative_1D ( scalar % interior % deviceData , & scalar % avgBoundary % deviceData , & df % interior % deviceData , & scalar % nVar , & scalar % nElem ) ELSE CALL scalar % interp % DGDerivative_1D ( scalar % interior % hostData , & scalar % avgBoundary % hostData , & df % interior % hostData , & scalar % nVar , & scalar % nElem ) END IF ELSEIF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL scalar % interp % Derivative_1D ( scalar % interior % deviceData , & df % interior % deviceData , & scalar % nVar , & scalar % nElem ) ELSE CALL scalar % interp % Derivative_1D ( scalar % interior % hostData , & df % interior % hostData , & scalar % nVar , & scalar % nElem ) END IF END IF CALL df % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Derivative_MappedScalar1D SUBROUTINE JacobianWeight_MappedScalar1D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar1D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( inout ) :: scalar TYPE ( Geometry1D ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i IF ( gpuAccel ) THEN CALL JacobianWeight_MappedScalar1D_gpu_wrapper ( scalar % interior % deviceData , & geometry % dxds % interior % deviceData , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO i = 0 , scalar % interp % N scalar % interior % hostData ( i , iVar , iEl ) = scalar % interior % hostData ( i , iVar , iEl ) / & geometry % dxds % interior % hostData ( i , 1 , iEl ) END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedScalar1D SUBROUTINE SetInteriorFromEquation_MappedScalar2D ( scalar , geometry , time ) !!  Sets the scalar % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry REAL ( prec ), INTENT ( in ) :: time ! Local INTEGER :: i , j , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N ! Get the mesh positions x = geometry % x % interior % hostData ( 1 , i , j , 1 , iEl ) y = geometry % x % interior % hostData ( 2 , i , j , 1 , iEl ) scalar % interior % hostData ( i , j , iVar , iEl ) = & scalar % eqn ( iVar ) % Evaluate (( / x , y , 0.0_prec , time / )) ENDDO ENDDO ENDDO ENDDO END SUBROUTINE SetInteriorFromEquation_MappedScalar2D SUBROUTINE SideExchange_MappedScalar2D ( scalar , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( Mesh2D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 , e2Global INTEGER :: flip , bcid INTEGER :: i1 , i2 , ivar INTEGER :: neighborRank INTEGER :: rankId , offset rankId = decomp % rankId offset = decomp % offsetElem % hostData ( rankId ) IF ( gpuAccel ) THEN CALL scalar % boundary % UpdateHost () CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL decomp % FinalizeMPIExchangeAsync () CALL scalar % extBoundary % UpdateDevice () CALL SideExchange_MappedScalar2D_gpu_wrapper ( scalar % extBoundary % deviceData , & scalar % boundary % deviceData , & mesh % sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & offset , & scalar % interp % N , & scalar % nvar , & scalar % nElem ) ELSE CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 4 e2Global = mesh % sideInfo % hostData ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2Global ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , scalar % nvar DO i1 = 0 , scalar % interp % N scalar % extBoundary % hostData ( i1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i1 , ivar , s2 , e2 ) END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , scalar % nvar DO i1 = 0 , scalar % interp % N i2 = scalar % interp % N - i1 scalar % extBoundary % hostData ( i1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , ivar , s2 , e2 ) END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL scalar % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedScalar2D SUBROUTINE BassiRebaySides_MappedScalar2D ( scalar , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedScalar2D_gpu_wrapper ( scalar % avgBoundary % deviceData , & scalar % boundary % deviceData , & scalar % extBoundary % deviceData , & scalar % interp % N , & scalar % nvar , & scalar % nElem ) ELSE DO iel = 1 , scalar % nElem DO iside = 1 , 4 DO ivar = 1 , scalar % nVar DO i = 0 , scalar % interp % N scalar % avgBoundary % hostData ( i , ivar , iside , iel ) = 0.5_prec * ( & scalar % boundary % hostData ( i , ivar , iside , iel ) + & scalar % extBoundary % hostData ( i , ivar , iside , iel )) END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedScalar2D SUBROUTINE Gradient_MappedScalar2D ( scalar , geometry , gradF , dForm , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedVector2D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel if ( dForm == selfStrongForm ) then call scalar % GradientSF_MappedScalar2D ( geometry , gradF , gpuAccel ) elseif ( dForm == selfWeakBRForm ) then call scalar % GradientBR_MappedScalar2D ( geometry , gradF , gpuAccel ) endif END SUBROUTINE Gradient_MappedScalar2D SUBROUTINE GradientBR_MappedScalar2D ( scalar , geometry , gradF , gpuAccel ) !! Calculates the gradient of a scalar 2D function using a bassi-rebay method !! !! This method will call the BassiRebaySides method, which assumes the SideExchange !! has already been completed, to update the avgBoundary attribute. !! IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedVector2D ), INTENT ( inout ) :: gradF LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: gFx , gFy REAL ( prec ) :: f1 , f2 CALL scalar % BassiRebaySides ( gpuAccel ) IF ( gpuAccel ) THEN CALL GradientBR_MappedScalar2D_gpu_wrapper ( scalar % interior % deviceData , & scalar % avgBoundary % deviceData , & geometry % dsdx % interior % deviceData , & geometry % J % interior % deviceData , & geometry % nHat % boundary % deviceData , & geometry % nScale % boundary % deviceData , & gradF % interior % deviceData , & scalar % interp % dgMatrix % deviceData , & scalar % interp % bMatrix % deviceData , & scalar % interp % qWeights % deviceData , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N gFx = 0.0_prec gFy = 0.0_prec DO ii = 0 , scalar % interp % N f1 = scalar % interior % hostData ( ii , j , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 1 , ii , j , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 2 , i , ii , 1 , iEl ) gFx = gFx + scalar % interp % dgMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dgMatrix % hostData ( ii , j ) * f2 f1 = scalar % interior % hostData ( ii , j , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 1 , ii , j , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 2 , i , ii , 1 , iEl ) gFy = gFy + scalar % interp % dgMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dgMatrix % hostData ( ii , j ) * f2 END DO ! Boundary Contribution f1 = scalar % avgBoundary % hostData ( j , iVar , 2 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , j , 1 , 2 , iEl ) * & geometry % nScale % boundary % hostData ( j , 1 , 2 , iEl ) ! East f2 = scalar % avgBoundary % hostData ( j , iVar , 4 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , j , 1 , 4 , iEl ) * & geometry % nScale % boundary % hostData ( j , 1 , 4 , iEl ) ! West gFx = gFx + ( f1 * scalar % interp % bMatrix % hostData ( i , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( i , 0 )) / & scalar % interp % qWeights % hostData ( i ) f1 = scalar % avgBoundary % hostData ( i , iVar , 3 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , i , 1 , 3 , iEl ) * & geometry % nScale % boundary % hostData ( i , 1 , 3 , iEl ) ! North f2 = scalar % avgBoundary % hostData ( i , iVar , 1 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , i , 1 , 1 , iEl ) * & geometry % nScale % boundary % hostData ( i , 1 , 1 , iEl ) ! South gFx = gFx + ( f1 * scalar % interp % bMatrix % hostData ( j , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( j , 0 )) / & scalar % interp % qWeights % hostData ( j ) f1 = scalar % avgBoundary % hostData ( j , iVar , 2 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , j , 1 , 2 , iEl ) * & geometry % nScale % boundary % hostData ( j , 1 , 2 , iEl ) ! East f2 = scalar % avgBoundary % hostData ( j , iVar , 4 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , j , 1 , 4 , iEl ) * & geometry % nScale % boundary % hostData ( j , 1 , 4 , iEl ) ! West gFy = gFy + ( f1 * scalar % interp % bMatrix % hostData ( i , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( i , 0 )) / & scalar % interp % qWeights % hostData ( i ) f1 = scalar % avgBoundary % hostData ( i , iVar , 3 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , i , 1 , 3 , iEl ) * & geometry % nScale % boundary % hostData ( i , 1 , 3 , iEl ) ! North f2 = scalar % avgBoundary % hostData ( i , iVar , 1 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , i , 1 , 1 , iEl ) * & geometry % nScale % boundary % hostData ( i , 1 , 1 , iEl ) ! South gFy = gFy + ( f1 * scalar % interp % bMatrix % hostData ( j , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( j , 0 )) / & scalar % interp % qWeights % hostData ( j ) gradF % interior % hostData ( 1 , i , j , iVar , iEl ) = gFx / geometry % J % interior % hostData ( i , j , 1 , iEl ) gradF % interior % hostData ( 2 , i , j , iVar , iEl ) = gFy / geometry % J % interior % hostData ( i , j , 1 , iEl ) END DO END DO END DO END DO ENDIF END SUBROUTINE GradientBR_MappedScalar2D SUBROUTINE GradientSF_MappedScalar2D ( scalar , geometry , gradF , gpuAccel ) !! Calculates the gradient of a scalar 2D function using the conservative form of the !! mapped gradient operator !! !! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) !! !! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( in ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedVector2D ), INTENT ( inout ) :: gradF LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: gFx , gFy REAL ( prec ) :: f1 , f2 IF ( gpuAccel ) THEN CALL GradientSF_MappedScalar2D_gpu_wrapper ( scalar % interior % deviceData , & geometry % dsdx % interior % deviceData , & geometry % J % interior % deviceData , & gradF % interior % deviceData , & scalar % interp % dMatrix % deviceData , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N gFx = 0.0_prec gFy = 0.0_prec DO ii = 0 , scalar % interp % N f1 = scalar % interior % hostData ( ii , j , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 1 , ii , j , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 2 , i , ii , 1 , iEl ) gFx = gFx + scalar % interp % dMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dMatrix % hostData ( ii , j ) * f2 f1 = scalar % interior % hostData ( ii , j , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 1 , ii , j , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 2 , i , ii , 1 , iEl ) gFy = gFy + scalar % interp % dMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dMatrix % hostData ( ii , j ) * f2 END DO gradF % interior % hostData ( 1 , i , j , iVar , iEl ) = gFx / geometry % J % interior % hostData ( i , j , 1 , iEl ) gradF % interior % hostData ( 2 , i , j , iVar , iEl ) = gFy / geometry % J % interior % hostData ( i , j , 1 , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE GradientSF_MappedScalar2D SUBROUTINE JacobianWeight_MappedScalar2D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j IF ( gpuAccel ) THEN CALL JacobianWeight_MappedScalar2D_gpu_wrapper ( scalar % interior % deviceData , & geometry % J % interior % deviceData , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N scalar % interior % hostData ( i , j , iVar , iEl ) = scalar % interior % hostData ( i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedScalar2D FUNCTION Integral_MappedScalar2D ( this , geometry , decomp , gpuAccel ) RESULT ( fRes ) !! Calculates the area integral the scalar over all of the geometry. !! Global reduction is done across all MPI ranks when the domain !! decomposition indicates MPI is enabled. IMPLICIT NONE CLASS ( MappedScalar2D ) :: this TYPE ( SEMQuad ) :: geometry TYPE ( MPILayer ) :: decomp LOGICAL :: gpuAccel REAL ( prec ) :: fRes ! Local INTEGER :: i , j , iEl REAL ( prec ) :: wi , wj , fint , Jacobian , f IF ( gpuAccel ) THEN CALL this % interior % UpdateHost () ENDIF fint = 0.0_prec DO iEl = 1 , geometry % x % nElem DO j = 0 , geometry % x % interp % N DO i = 0 , geometry % x % interp % N ! Coordinate mapping Jacobian Jacobian = geometry % J % interior % hostData ( i , j , 1 , iEl ) ! Quadrature weights wi = geometry % x % interp % qWeights % hostData ( i ) wj = geometry % x % interp % qWeights % hostData ( j ) f = this % interior % hostData ( i , j , 4 , iEl ) fint = fint + f * wi * wj * Jacobian ENDDO ENDDO ENDDO CALL decomp % GlobalReduce ( fint , fRes ) END FUNCTION Integral_MappedScalar2D ! SideExchange_MappedScalar3D is used to populate scalar % extBoundary ! by finding neighboring elements that share a side and copying the neighboring ! elements solution % boundary data. SUBROUTINE SetInteriorFromEquation_MappedScalar3D ( scalar , geometry , time ) !!  Sets the scalar % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry REAL ( prec ), INTENT ( in ) :: time ! Local INTEGER :: i , j , k , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: z DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % interp % N DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N ! Get the mesh positions x = geometry % x % interior % hostData ( 1 , i , j , k , 1 , iEl ) y = geometry % x % interior % hostData ( 2 , i , j , k , 1 , iEl ) z = geometry % x % interior % hostData ( 3 , i , j , k , 1 , iEl ) scalar % interior % hostData ( i , j , k , iVar , iEl ) = & scalar % eqn ( iVar ) % Evaluate (( / x , y , z , time / )) ENDDO ENDDO ENDDO ENDDO ENDDO END SUBROUTINE SetInteriorFromEquation_MappedScalar3D SUBROUTINE SideExchange_MappedScalar3D ( scalar , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( Mesh3D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 , e2Global INTEGER :: flip , bcid INTEGER :: neighborRank INTEGER :: i1 , i2 , j1 , j2 , ivar INTEGER :: rankId , offset rankId = decomp % rankId offset = decomp % offsetElem % hostData ( rankId ) IF ( gpuAccel ) THEN CALL scalar % boundary % UpdateHost () CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL decomp % FinalizeMPIExchangeAsync () CALL scalar % extBoundary % UpdateDevice () CALL SideExchange_MappedScalar3D_gpu_wrapper ( scalar % extBoundary % deviceData , & scalar % boundary % deviceData , & mesh % sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & offset , & scalar % interp % N , & scalar % nvar , & scalar % nElem ) ELSE CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 6 e2Global = mesh % sideInfo % hostData ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2Global ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN ! Orientation matches on both sides of the face DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % interp % N DO i1 = 0 , scalar % interp % N scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i1 , j1 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % interp % N DO i1 = 0 , scalar % interp % N i2 = j1 j2 = scalar % interp % N - i1 scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 2 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % interp % N DO i1 = 0 , scalar % interp % N i2 = scalar % interp % N - i1 j2 = scalar % interp % N - j1 scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % interp % N DO i1 = 0 , scalar % interp % N i2 = scalar % interp % N - j1 j2 = i1 scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 4 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % interp % N DO i1 = 0 , scalar % interp % N i2 = j1 j2 = i1 scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL scalar % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedScalar3D SUBROUTINE BassiRebaySides_MappedScalar3D ( scalar , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i , j IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedScalar3D_gpu_wrapper ( scalar % avgBoundary % deviceData , & scalar % boundary % deviceData , & scalar % extBoundary % deviceData , & scalar % interp % N , & scalar % nvar , & scalar % nElem ) ELSE DO iel = 1 , scalar % nElem DO iside = 1 , 6 DO ivar = 1 , scalar % nVar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N scalar % avgBoundary % hostData ( i , j , ivar , iside , iel ) = 0.5_prec * ( & scalar % boundary % hostData ( i , j , ivar , iside , iel ) + & scalar % extBoundary % hostData ( i , j , ivar , iside , iel )) END DO END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedScalar3D SUBROUTINE Gradient_MappedScalar3D ( scalar , geometry , gradF , dForm , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedVector3D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel if ( dForm == selfStrongForm ) then call scalar % GradientSF_MappedScalar3D ( geometry , gradF , gpuAccel ) elseif ( dForm == selfWeakBRForm ) then call scalar % GradientBR_MappedScalar3D ( geometry , gradF , gpuAccel ) endif END SUBROUTINE Gradient_MappedScalar3D SUBROUTINE GradientBR_MappedScalar3D ( scalar , geometry , gradF , gpuAccel ) !! Calculates the gradient of a scalar 3D function using a bassi-rebay method !! !! This method will call the BassiRebaySides method, which assumes the SideExchange !! has already been completed, to update the avgBoundary attribute. !! IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedVector3D ), INTENT ( inout ) :: gradF LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , k , ii , iVar , iEl REAL ( prec ) :: gFx , gFy , gFz REAL ( prec ) :: f1 , f2 , f3 CALL scalar % BassiRebaySides ( gpuAccel ) IF ( gpuAccel ) THEN CALL GradientBR_MappedScalar3D_gpu_wrapper ( scalar % interior % deviceData , & scalar % avgBoundary % deviceData , & geometry % dsdx % interior % deviceData , & geometry % J % interior % deviceData , & geometry % nHat % boundary % deviceData , & geometry % nScale % boundary % deviceData , & gradF % interior % deviceData , & scalar % interp % dgMatrix % deviceData , & scalar % interp % bMatrix % deviceData , & scalar % interp % qWeights % deviceData , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % interp % N DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N gFx = 0.0_prec gFy = 0.0_prec gFz = 0.0_prec DO ii = 0 , scalar % interp % N f1 = scalar % interior % hostData ( ii , j , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 1 , ii , j , k , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 2 , i , ii , k , 1 , iEl ) f3 = scalar % interior % hostData ( i , j , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 3 , i , j , ii , 1 , iEl ) gFx = gFx + scalar % interp % dgMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dgMatrix % hostData ( ii , j ) * f2 + & scalar % interp % dgMatrix % hostData ( ii , k ) * f3 f1 = scalar % interior % hostData ( ii , j , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 1 , ii , j , k , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 2 , i , ii , k , 1 , iEl ) f3 = scalar % interior % hostData ( i , j , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 3 , i , j , ii , 1 , iEl ) gFy = gFy + scalar % interp % dgMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dgMatrix % hostData ( ii , j ) * f2 + & scalar % interp % dgMatrix % hostData ( ii , k ) * f3 f1 = scalar % interior % hostData ( ii , j , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 3 , 1 , ii , j , k , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 3 , 2 , i , ii , k , 1 , iEl ) f3 = scalar % interior % hostData ( i , j , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 3 , 3 , i , j , ii , 1 , iEl ) gFz = gFz + scalar % interp % dgMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dgMatrix % hostData ( ii , j ) * f2 + & scalar % interp % dgMatrix % hostData ( ii , k ) * f3 END DO ! Boundary Contribution f1 = scalar % avgBoundary % hostData ( j , k , iVar , 2 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , j , k , 1 , 2 , iEl ) * & geometry % nScale % boundary % hostData ( j , k , 1 , 2 , iEl ) ! East f2 = scalar % avgBoundary % hostData ( j , k , iVar , 4 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , j , k , 1 , 4 , iEl ) * & geometry % nScale % boundary % hostData ( j , k , 1 , 4 , iEl ) ! West gFx = gFx + ( f1 * scalar % interp % bMatrix % hostData ( i , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( i , 0 )) / & scalar % interp % qWeights % hostData ( i ) f1 = scalar % avgBoundary % hostData ( i , k , iVar , 3 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , i , k , 1 , 3 , iEl ) * & geometry % nScale % boundary % hostData ( i , k , 1 , 3 , iEl ) ! North f2 = scalar % avgBoundary % hostData ( i , k , iVar , 1 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , i , k , 1 , 1 , iEl ) * & geometry % nScale % boundary % hostData ( i , k , 1 , 1 , iEl ) ! South gFx = gFx + ( f1 * scalar % interp % bMatrix % hostData ( j , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( j , 0 )) / & scalar % interp % qWeights % hostData ( j ) f1 = scalar % avgBoundary % hostData ( i , j , iVar , 6 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , i , j , 1 , 6 , iEl ) * & geometry % nScale % boundary % hostData ( i , j , 1 , 6 , iEl ) ! Top f2 = scalar % avgBoundary % hostData ( i , j , iVar , 5 , iEl ) * & geometry % nHat % boundary % hostData ( 1 , i , j , 1 , 5 , iEl ) * & geometry % nScale % boundary % hostData ( i , j , 1 , 5 , iEl ) ! Bottom gFx = gFx + ( f1 * scalar % interp % bMatrix % hostData ( k , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( k , 0 )) / & scalar % interp % qWeights % hostData ( k ) f1 = scalar % avgBoundary % hostData ( j , k , iVar , 2 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , j , k , 1 , 2 , iEl ) * & geometry % nScale % boundary % hostData ( j , k , 1 , 2 , iEl ) ! East f2 = scalar % avgBoundary % hostData ( j , k , iVar , 4 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , j , k , 1 , 4 , iEl ) * & geometry % nScale % boundary % hostData ( j , k , 1 , 4 , iEl ) ! West gFy = gFy + ( f1 * scalar % interp % bMatrix % hostData ( i , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( i , 0 )) / & scalar % interp % qWeights % hostData ( i ) f1 = scalar % avgBoundary % hostData ( i , k , iVar , 3 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , i , k , 1 , 3 , iEl ) * & geometry % nScale % boundary % hostData ( i , k , 1 , 3 , iEl ) ! North f2 = scalar % avgBoundary % hostData ( i , k , iVar , 1 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , i , k , 1 , 1 , iEl ) * & geometry % nScale % boundary % hostData ( i , k , 1 , 1 , iEl ) ! South gFy = gFy + ( f1 * scalar % interp % bMatrix % hostData ( j , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( j , 0 )) / & scalar % interp % qWeights % hostData ( j ) f1 = scalar % avgBoundary % hostData ( i , j , iVar , 6 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , i , j , 1 , 6 , iEl ) * & geometry % nScale % boundary % hostData ( i , j , 1 , 6 , iEl ) ! Top f2 = scalar % avgBoundary % hostData ( i , j , iVar , 5 , iEl ) * & geometry % nHat % boundary % hostData ( 2 , i , j , 1 , 5 , iEl ) * & geometry % nScale % boundary % hostData ( i , j , 1 , 5 , iEl ) ! Bottom gFy = gFy + ( f1 * scalar % interp % bMatrix % hostData ( k , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( k , 0 )) / & scalar % interp % qWeights % hostData ( k ) f1 = scalar % avgBoundary % hostData ( j , k , iVar , 2 , iEl ) * & geometry % nHat % boundary % hostData ( 3 , j , k , 1 , 2 , iEl ) * & geometry % nScale % boundary % hostData ( j , k , 1 , 2 , iEl ) ! East f2 = scalar % avgBoundary % hostData ( j , k , iVar , 4 , iEl ) * & geometry % nHat % boundary % hostData ( 3 , j , k , 1 , 4 , iEl ) * & geometry % nScale % boundary % hostData ( j , k , 1 , 4 , iEl ) ! West gFz = gFz + ( f1 * scalar % interp % bMatrix % hostData ( i , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( i , 0 )) / & scalar % interp % qWeights % hostData ( i ) f1 = scalar % avgBoundary % hostData ( i , k , iVar , 3 , iEl ) * & geometry % nHat % boundary % hostData ( 3 , i , k , 1 , 3 , iEl ) * & geometry % nScale % boundary % hostData ( i , k , 1 , 3 , iEl ) ! North f2 = scalar % avgBoundary % hostData ( i , k , iVar , 1 , iEl ) * & geometry % nHat % boundary % hostData ( 3 , i , k , 1 , 1 , iEl ) * & geometry % nScale % boundary % hostData ( i , k , 1 , 1 , iEl ) ! South gFz = gFz + ( f1 * scalar % interp % bMatrix % hostData ( j , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( j , 0 )) / & scalar % interp % qWeights % hostData ( j ) f1 = scalar % avgBoundary % hostData ( i , j , iVar , 6 , iEl ) * & geometry % nHat % boundary % hostData ( 3 , i , j , 1 , 6 , iEl ) * & geometry % nScale % boundary % hostData ( i , j , 1 , 6 , iEl ) ! Top f2 = scalar % avgBoundary % hostData ( i , j , iVar , 5 , iEl ) * & geometry % nHat % boundary % hostData ( 3 , i , j , 1 , 5 , iEl ) * & geometry % nScale % boundary % hostData ( i , j , 1 , 5 , iEl ) ! Bottom gFz = gFz + ( f1 * scalar % interp % bMatrix % hostData ( k , 1 ) + & f2 * scalar % interp % bMatrix % hostData ( k , 0 )) / & scalar % interp % qWeights % hostData ( k ) gradF % interior % hostData ( 1 , i , j , k , iVar , iEl ) = gFx / geometry % J % interior % hostData ( i , j , k , 1 , iEl ) gradF % interior % hostData ( 2 , i , j , k , iVar , iEl ) = gFy / geometry % J % interior % hostData ( i , j , k , 1 , iEl ) gradF % interior % hostData ( 3 , i , j , k , iVar , iEl ) = gFz / geometry % J % interior % hostData ( i , j , k , 1 , iEl ) END DO END DO END DO END DO END DO ENDIF END SUBROUTINE GradientBR_MappedScalar3D SUBROUTINE GradientSF_MappedScalar3D ( scalar , geometry , gradF , gpuAccel ) !! Calculates the gradient of a scalar 3D function using the conservative form of the !! mapped gradient operator !! !! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) !! !! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( in ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedVector3D ), INTENT ( inout ) :: gradF LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , k , ii , iVar , iEl REAL ( prec ) :: gFx , gFy , gFz REAL ( prec ) :: f1 , f2 , f3 IF ( gpuAccel ) THEN CALL GradientSF_MappedScalar3D_gpu_wrapper ( scalar % interior % deviceData , & geometry % dsdx % interior % deviceData , & geometry % J % interior % deviceData , & gradF % interior % deviceData , & scalar % interp % dMatrix % deviceData , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % interp % N DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N gFx = 0.0_prec gFy = 0.0_prec gFz = 0.0_prec DO ii = 0 , scalar % interp % N f1 = scalar % interior % hostData ( ii , j , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 1 , ii , j , k , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 2 , i , ii , k , 1 , iEl ) f3 = scalar % interior % hostData ( i , j , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 1 , 3 , i , j , ii , 1 , iEl ) gFx = gFx + scalar % interp % dMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dMatrix % hostData ( ii , j ) * f2 + & scalar % interp % dMatrix % hostData ( ii , k ) * f3 f1 = scalar % interior % hostData ( ii , j , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 1 , ii , j , k , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 2 , i , ii , k , 1 , iEl ) f3 = scalar % interior % hostData ( i , j , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 2 , 2 , i , j , ii , 1 , iEl ) gFy = gFy + scalar % interp % dMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dMatrix % hostData ( ii , j ) * f2 + & scalar % interp % dMatrix % hostData ( ii , k ) * f3 f1 = scalar % interior % hostData ( ii , j , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 3 , 1 , ii , j , k , 1 , iEl ) f2 = scalar % interior % hostData ( i , ii , k , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 3 , 2 , i , ii , k , 1 , iEl ) f3 = scalar % interior % hostData ( i , j , ii , iVar , iEl ) * & geometry % dsdx % interior % hostData ( 3 , 2 , i , j , ii , 1 , iEl ) gFz = gFz + scalar % interp % dMatrix % hostData ( ii , i ) * f1 + & scalar % interp % dMatrix % hostData ( ii , j ) * f2 + & scalar % interp % dMatrix % hostData ( ii , k ) * f3 END DO gradF % interior % hostData ( 1 , i , j , k , iVar , iEl ) = gFx / geometry % J % interior % hostData ( i , j , k , 1 , iEl ) gradF % interior % hostData ( 2 , i , j , k , iVar , iEl ) = gFy / geometry % J % interior % hostData ( i , j , k , 1 , iEl ) gradF % interior % hostData ( 3 , i , j , k , iVar , iEl ) = gFz / geometry % J % interior % hostData ( i , j , k , 1 , iEl ) END DO END DO ENDDO END DO END DO END IF END SUBROUTINE GradientSF_MappedScalar3D SUBROUTINE JacobianWeight_MappedScalar3D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k IF ( gpuAccel ) THEN CALL JacobianWeight_MappedScalar3D_gpu_wrapper ( scalar % interior % deviceData , & geometry % J % interior % deviceData , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % interp % N DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N scalar % interior % hostData ( i , j , k , iVar , iEl ) = scalar % interior % hostData ( i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) END DO END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedScalar3D ! ---------------------- Vectors ---------------------- ! SUBROUTINE SetInteriorFromEquation_MappedVector2D ( vector , geometry , time ) !!  Sets the scalar % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( SEMQuad ), INTENT ( in ) :: geometry REAL ( prec ), INTENT ( in ) :: time ! Local INTEGER :: i , j , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N ! Get the mesh positions x = geometry % x % interior % hostData ( 1 , i , j , 1 , iEl ) y = geometry % x % interior % hostData ( 2 , i , j , 1 , iEl ) vector % interior % hostData ( 1 , i , j , iVar , iEl ) = & vector % eqn ( 1 + 2 * ( iVar - 1 )) % Evaluate (( / x , y , 0.0_prec , time / )) vector % interior % hostData ( 2 , i , j , iVar , iEl ) = & vector % eqn ( 2 + 2 * ( iVar - 1 )) % Evaluate (( / x , y , 0.0_prec , time / )) ENDDO ENDDO ENDDO ENDDO END SUBROUTINE SetInteriorFromEquation_MappedVector2D SUBROUTINE SideExchange_MappedVector2D ( vector , mesh , decomp , gpuAccel ) !! SideExchange_MappedVectorvector2D is used to populate vector % extBoundary !! by finding neighboring elements that share a side and copying the neighboring !! elements solution % boundary data. IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( Mesh2D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 , e2Global INTEGER :: flip , bcid INTEGER :: neighborRank INTEGER :: i1 , i2 , ivar INTEGER :: rankId , offset rankId = decomp % rankId offset = decomp % offsetElem % hostData ( rankId ) IF ( gpuAccel ) THEN CALL vector % boundary % UpdateHost () CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL decomp % FinalizeMPIExchangeAsync () CALL vector % extBoundary % UpdateDevice () CALL SideExchange_MappedVector2D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & mesh % sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & offset , & vector % interp % N , & vector % nvar , & vector % nElem ) ELSE CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 4 e2Global = mesh % sideInfo % hostData ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2Global ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , vector % nvar DO i1 = 0 , vector % interp % N vector % extBoundary % hostData ( 1 : 2 , i1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 2 , i1 , ivar , s2 , e2 ) END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , vector % nvar DO i1 = 0 , vector % interp % N i2 = vector % interp % N - i1 vector % extBoundary % hostData ( 1 : 2 , i1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 2 , i2 , ivar , s2 , e2 ) END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL vector % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedVector2D SUBROUTINE BassiRebaySides_MappedVector2D ( vector , gpuAccel ) IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedVector2D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & vector % interp % N , & vector % nvar , & vector % nElem ) ELSE DO iel = 1 , vector % nElem DO iside = 1 , 4 DO ivar = 1 , vector % nVar DO i = 0 , vector % interp % N vector % boundary % hostData ( 1 : 2 , i , ivar , iside , iel ) = 0.5_prec * ( & vector % boundary % hostData ( 1 : 2 , i , ivar , iside , iel ) + & vector % extBoundary % hostData ( 1 : 2 , i , ivar , iside , iel )) END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedVector2D SUBROUTINE Divergence_MappedVector2D ( compVector , geometry , divVector , dForm , gpuAccel ) ! Strong Form Operator ! ! DG Weak Form Operator ! ! Assumes vector has been projected to computational coordinates ! IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: compVector TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedScalar2D ), INTENT ( inout ) :: divVector INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDGDivergence_2D ( compVector % interior % deviceData , & compVector % boundaryNormal % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDGDivergence_2D ( compVector % interior % hostData , & compVector % boundaryNormal % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDivergence_2D ( compVector % interior % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDivergence_2D ( compVector % interior % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF END IF CALL divVector % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Divergence_MappedVector2D SUBROUTINE ContravariantProjection_MappedVector2D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantProjection_MappedVector2D\" ! Takes a vector that has physical space coordinate directions (x,y,z) and projects the vector ! into the the contravariant basis vector directions. Keep in mind that the contravariant basis ! vectors are really the Jacobian weighted contravariant basis vectors IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , ivar , iel REAL ( prec ) :: Fx , Fy IF ( gpuAccel ) THEN CALL ContravariantProjection_MappedVector2D_gpu_wrapper ( vector % interior % deviceData , & geometry % dsdx % interior % deviceData , & vector % interp % N , & vector % nVar , & vector % nElem ) ELSE ! Assume that tensor(j,i) is vector i, component j ! => dot product is done along first dimension ! to project onto computational space DO iel = 1 , vector % nElem DO ivar = 1 , vector % nVar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N Fx = vector % interior % hostData ( 1 , i , j , ivar , iel ) Fy = vector % interior % hostData ( 2 , i , j , ivar , iel ) vector % interior % hostData ( 1 , i , j , ivar , iel ) = & geometry % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iel ) * Fx + & geometry % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iel ) * Fy vector % interior % hostData ( 2 , i , j , ivar , iel ) = & geometry % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iel ) * Fx + & geometry % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iel ) * Fy END DO END DO END DO END DO END IF END SUBROUTINE ContravariantProjection_MappedVector2D SUBROUTINE JacobianWeight_MappedVector2D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedVector2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j IF ( gpuAccel ) THEN CALL JacobianWeight_MappedVector2D_gpu_wrapper ( vector % interior % deviceData , & geometry % J % interior % deviceData , & vector % interp % N , & vector % nVar , & vector % nElem ) ELSE DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N vector % interior % hostData ( 1 , i , j , iVar , iEl ) = vector % interior % hostData ( 1 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) vector % interior % hostData ( 2 , i , j , iVar , iEl ) = vector % interior % hostData ( 2 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedVector2D SUBROUTINE SetInteriorFromEquation_MappedVector3D ( vector , geometry , time ) !!  Sets the scalar % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( SEMHex ), INTENT ( in ) :: geometry REAL ( prec ), INTENT ( in ) :: time ! Local INTEGER :: i , j , k , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: z DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO k = 0 , vector % interp % N DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N ! Get the mesh positions x = geometry % x % interior % hostData ( 1 , i , j , k , 1 , iEl ) y = geometry % x % interior % hostData ( 2 , i , j , k , 1 , iEl ) z = geometry % x % interior % hostData ( 3 , i , j , k , 1 , iEl ) vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) = & vector % eqn ( 1 + 3 * ( iVar - 1 )) % Evaluate (( / x , y , z , time / )) vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) = & vector % eqn ( 2 + 3 * ( iVar - 1 )) % Evaluate (( / x , y , z , time / )) vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) = & vector % eqn ( 3 + 3 * ( iVar - 1 )) % Evaluate (( / x , y , z , time / )) ENDDO ENDDO ENDDO ENDDO ENDDO END SUBROUTINE SetInteriorFromEquation_MappedVector3D ! SideExchange_MappedVector3D is used to populate vector % extBoundary ! by finding neighboring elements that share a side and copying the neighboring ! elements solution % boundary data. SUBROUTINE SideExchange_MappedVector3D ( vector , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( Mesh3D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 , e2Global INTEGER :: flip , bcid INTEGER :: neighborRank INTEGER :: i1 , i2 , j1 , j2 , ivar INTEGER :: rankId , offset rankId = decomp % rankId offset = decomp % offsetElem % hostData ( rankId ) IF ( gpuAccel ) THEN CALL vector % boundary % UpdateHost () CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL decomp % FinalizeMPIExchangeAsync () CALL vector % extBoundary % UpdateDevice () CALL SideExchange_MappedVector3D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & mesh % sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & offset , & vector % interp % N , & vector % nvar , & vector % nElem ) ELSE CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 6 e2Global = mesh % sideInfo % hostData ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN ! Interior neighborRank = decomp % elemToRank % hostData ( e2Global ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % interp % N DO i1 = 0 , vector % interp % N vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i1 , j1 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % interp % N DO i1 = 0 , vector % interp % N i2 = j1 j2 = vector % interp % N - i1 vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 2 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % interp % N DO i1 = 0 , vector % interp % N i2 = vector % interp % N - i1 j2 = vector % interp % N - j1 vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % interp % N DO i1 = 0 , vector % interp % N i2 = vector % interp % N - j1 j2 = i1 vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 4 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % interp % N DO i1 = 0 , vector % interp % N i2 = j1 j2 = i1 vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL vector % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedVector3D SUBROUTINE BassiRebaySides_MappedVector3D ( vector , gpuAccel ) IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i , j IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedVector3D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & vector % interp % N , & vector % nvar , & vector % nElem ) ELSE DO iel = 1 , vector % nElem DO iside = 1 , 6 DO ivar = 1 , vector % nVar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N vector % boundary % hostData ( 1 : 3 , i , j , ivar , iside , iel ) = 0.5_prec * ( & vector % boundary % hostData ( 1 : 3 , i , j , ivar , iside , iel ) + & vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , iside , iel )) END DO END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedVector3D SUBROUTINE Divergence_MappedVector3D ( compVector , geometry , divVector , dForm , gpuAccel ) ! IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: compVector TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedScalar3D ), INTENT ( inout ) :: divVector INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDGDivergence_3D ( compVector % interior % deviceData , & compVector % boundaryNormal % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDGDivergence_3D ( compVector % interior % hostData , & compVector % boundaryNormal % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDivergence_3D ( compVector % interior % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDivergence_3D ( compVector % interior % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF END IF CALL divVector % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Divergence_MappedVector3D SUBROUTINE ContravariantProjection_MappedVector3D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantProjection_MappedVector3D\" ! Takes a vector that has physical space coordinate directions (x,y,z) and projects the vector ! into the the contravariant basis vector directions. Keep in mind that the contravariant basis ! vectors are really the Jacobian weighted contravariant basis vectors IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , k , iVar , iEl REAL ( prec ) :: Fx , Fy , Fz IF ( gpuAccel ) THEN CALL ContravariantProjection_MappedVector3D_gpu_wrapper ( vector % interior % deviceData , & geometry % dsdx % interior % deviceData , & vector % interp % N , & vector % nVar , & vector % nElem ) ELSE ! Assume that tensor(j,i) is vector i, component j ! => dot product is done along first dimension to ! project onto computational space DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO k = 0 , vector % interp % N DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N Fx = vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) Fy = vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) Fz = vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * Fx + & geometry % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * Fy + & geometry % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * Fz vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * Fx + & geometry % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * Fy + & geometry % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * Fz vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * Fx + & geometry % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * Fy + & geometry % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * Fz END DO END DO END DO END DO END DO END IF END SUBROUTINE ContravariantProjection_MappedVector3D SUBROUTINE JacobianWeight_MappedVector3D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedVector3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k IF ( gpuAccel ) THEN CALL JacobianWeight_MappedVector3D_gpu_wrapper ( vector % interior % deviceData , & geometry % J % interior % deviceData , & vector % interp % N , & vector % nVar , & vector % nElem ) ELSE DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO k = 0 , vector % interp % N DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) END DO END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedVector3D ! --- MPI Routines --- ! SUBROUTINE MPIExchangeAsync_MappedScalar2D ( scalar , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , scalar % nElem DO s1 = 1 , 4 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element IF ( e2 > 0 ) THEN r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = ABS ( mesh % sideInfo % hostdata ( 2 , s1 , e1 )) msgCount = msgCount + 1 CALL MPI_IRECV ( scalar % extBoundary % hostData (:,:, s1 , e1 ), & ( scalar % interp % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( scalar % boundary % hostData (:,:, s1 , e1 ), & ( scalar % interp % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) END IF END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedScalar2D ! SUBROUTINE ApplyFlip_MappedScalar2D ( scalar , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId INTEGER :: bcid REAL ( prec ) :: extBuff ( 0 : scalar % interp % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedScalar2D_gpu_wrapper ( scalar % extBoundary % deviceData , & mesh % sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO e1 = 1 , scalar % nElem DO s1 = 1 , 4 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN ! Interior Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % sideInfo % hostdata ( 2 , s1 , e1 ) ! Need to update extBoundary with flip applied IF ( flip == 1 ) THEN DO ivar = 1 , scalar % nvar DO i = 0 , scalar % interp % N i2 = scalar % interp % N - i extBuff ( i ) = scalar % extBoundary % hostData ( i2 , ivar , s1 , e1 ) END DO DO i = 0 , scalar % interp % N scalar % extBoundary % hostData ( i , ivar , s1 , e1 ) = extBuff ( i ) END DO END DO END IF END IF ENDIF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedScalar2D SUBROUTINE MPIExchangeAsync_MappedVector2D ( vector , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , vector % nElem DO s1 = 1 , 4 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element IF ( e2 > 0 ) THEN r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = ABS ( mesh % sideInfo % hostdata ( 2 , s1 , e1 )) msgCount = msgCount + 1 CALL MPI_IRECV ( vector % extBoundary % hostData (:,:,:, s1 , e1 ), & 2 * ( vector % interp % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( vector % boundary % hostData (:,:,:, s1 , e1 ), & 2 * ( vector % interp % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) END IF ENDIF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedVector2D SUBROUTINE ApplyFlip_MappedVector2D ( vector , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId INTEGER :: bcid REAL ( prec ) :: extBuff ( 1 : 2 , 0 : vector % interp % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedVector2D_gpu_wrapper ( vector % extBoundary % deviceData , & mesh % sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & vector % interp % N , & vector % nVar , & vector % nElem ) ELSE DO e1 = 1 , vector % nElem DO s1 = 1 , 4 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN ! Interior Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % sideInfo % hostdata ( 2 , s1 , e1 ) ! Need to update extBoundary with flip applied IF ( flip == 1 ) THEN DO ivar = 1 , vector % nvar DO i = 0 , vector % interp % N i2 = vector % interp % N - i extBuff ( 1 : 2 , i ) = vector % extBoundary % hostData ( 1 : 2 , i2 , ivar , s1 , e1 ) END DO DO i = 0 , vector % interp % N vector % extBoundary % hostData ( 1 : 2 , i , ivar , s1 , e1 ) = extBuff ( 1 : 2 , i ) END DO END DO END IF END IF ENDIF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedVector2D SUBROUTINE MPIExchangeAsync_MappedScalar3D ( scalar , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , scalar % nElem DO s1 = 1 , 6 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element IF ( e2 > 0 ) THEN r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = ABS ( mesh % sideInfo % hostdata ( 2 , s1 , e1 )) msgCount = msgCount + 1 CALL MPI_IRECV ( scalar % extBoundary % hostData (:,:,:, s1 , e1 ), & ( scalar % interp % N + 1 ) * ( scalar % interp % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( scalar % boundary % hostData (:,:,:, s1 , e1 ), & ( scalar % interp % N + 1 ) * ( scalar % interp % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) END IF ENDIF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedScalar3D ! SUBROUTINE ApplyFlip_MappedScalar3D ( scalar , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 , j , j2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId INTEGER :: bcid REAL ( prec ) :: extBuff ( 0 : scalar % interp % N , 0 : scalar % interp % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedScalar3D_gpu_wrapper ( scalar % extBoundary % deviceData , & mesh % sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & scalar % interp % N , & scalar % nVar , & scalar % nElem ) ELSE DO e1 = 1 , scalar % nElem DO s1 = 1 , 6 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN ! Interior Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % sideInfo % hostdata ( 2 , s1 , e1 ) ! Need to update extBoundary with flip applied IF ( flip == 1 ) THEN DO ivar = 1 , scalar % nvar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N i2 = j j2 = scalar % interp % N - i extBuff ( i , j ) = scalar % extBoundary % hostData ( i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N scalar % extBoundary % hostData ( i , j , ivar , s1 , e1 ) = extBuff ( i , j ) END DO END DO END DO ELSEIF ( flip == 2 ) THEN DO ivar = 1 , scalar % nvar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N i2 = scalar % interp % N - i j2 = scalar % interp % N - j extBuff ( i , j ) = scalar % extBoundary % hostData ( i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N scalar % extBoundary % hostData ( i , j , ivar , s1 , e1 ) = extBuff ( i , j ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , scalar % nvar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N i2 = scalar % interp % N - j j2 = i extBuff ( i , j ) = scalar % extBoundary % hostData ( i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N scalar % extBoundary % hostData ( i , j , ivar , s1 , e1 ) = extBuff ( i , j ) END DO END DO END DO ELSEIF ( flip == 4 ) THEN DO ivar = 1 , scalar % nvar DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N i2 = j j2 = i extBuff ( i , j ) = scalar % extBoundary % hostData ( i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , scalar % interp % N DO i = 0 , scalar % interp % N scalar % extBoundary % hostData ( i , j , ivar , s1 , e1 ) = extBuff ( i , j ) END DO END DO END DO END IF END IF ENDIF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedScalar3D SUBROUTINE MPIExchangeAsync_MappedVector3D ( vector , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , vector % nElem DO s1 = 1 , 6 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = ABS ( mesh % sideInfo % hostdata ( 2 , s1 , e1 )) msgCount = msgCount + 1 CALL MPI_IRECV ( vector % extBoundary % hostData (:,:,:,:, s1 , e1 ), & 3 * ( vector % interp % N + 1 ) * ( vector % interp % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( vector % boundary % hostData (:,:,:,:, s1 , e1 ), & 3 * ( vector % interp % N + 1 ) * ( vector % interp % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests ( msgCount ), iError ) END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedVector3D SUBROUTINE ApplyFlip_MappedVector3D ( vector , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 , j , j2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId INTEGER :: bcid REAL ( prec ) :: extBuff ( 1 : 3 , 0 : vector % interp % N , 0 : vector % interp % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedVector3D_gpu_wrapper ( vector % extBoundary % deviceData , & mesh % sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & vector % interp % N , & vector % nVar , & vector % nElem ) ELSE DO e1 = 1 , vector % nElem DO s1 = 1 , 6 e2 = mesh % sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element bcid = mesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN ! Interior Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % sideInfo % hostdata ( 2 , s1 , e1 ) IF ( flip == 1 ) THEN DO ivar = 1 , vector % nvar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N i2 = j j2 = vector % interp % N - i extBuff ( 1 : 3 , i , j ) = vector % extBoundary % hostData ( 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , i , j ) END DO END DO END DO ELSEIF ( flip == 2 ) THEN DO ivar = 1 , vector % nvar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N i2 = vector % interp % N - i j2 = vector % interp % N - j extBuff ( 1 : 3 , i , j ) = vector % extBoundary % hostData ( 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , i , j ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , vector % nvar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N i2 = vector % interp % N - j j2 = i extBuff ( 1 : 3 , i , j ) = vector % extBoundary % hostData ( 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , i , j ) END DO END DO END DO ELSEIF ( flip == 4 ) THEN DO ivar = 1 , vector % nvar DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N i2 = j j2 = i extBuff ( 1 : 3 , i , j ) = vector % extBoundary % hostData ( 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , vector % interp % N DO i = 0 , vector % interp % N vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , i , j ) END DO END DO END DO END IF END IF ENDIF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedVector3D !   ! ---------------------- Two point Vectors ---------------------- ! !   SUBROUTINE SideExchange_MappedP2Vector2D(vector,mesh,decomp,gpuAccel) !   !! SideExchange_MappedP2Vectorvector2D is used to populate vector % extBoundary !   !! by finding neighboring elements that share a side and copying the neighboring !   !! elements solution % boundary data. !     IMPLICIT NONE !     CLASS(MappedP2Vector2D),INTENT(inout) :: vector !     TYPE(Mesh2D),INTENT(in) :: mesh !     TYPE(MPILayer),INTENT(inout) :: decomp !     LOGICAL,INTENT(in) :: gpuAccel !     ! Local !     INTEGER :: e1,e2,s1,s2,e2Global !     INTEGER :: flip,bcid !     INTEGER :: neighborRank !     INTEGER :: i1,i2,ivar !     INTEGER :: rankId, offset !       rankId = decomp % rankId !       offset = decomp % offsetElem % hostData(rankId) !     IF (gpuAccel) THEN !       CALL vector % boundary % UpdateHost() !       CALL vector % MPIExchangeAsync(decomp,mesh,resetCount=.TRUE.) !       CALL decomp % FinalizeMPIExchangeAsync() !       CALL vector % extBoundary % UpdateDevice() !       CALL SideExchange_MappedVector2D_gpu_wrapper(vector % extBoundary % deviceData, & !                                                    vector % boundary % deviceData, & !                                                    mesh % sideInfo % deviceData, & !                                                    decomp % elemToRank % deviceData, & !                                                    decomp % rankId, & !                                                    offset, & !                                                    vector % interp % N, & !                                                    vector % nvar, & !                                                    vector % nElem) !     ELSE !       CALL vector % MPIExchangeAsync(decomp,mesh,resetCount=.TRUE.) !       DO e1 = 1,mesh % nElem !         DO s1 = 1,4 !           e2Global = mesh % sideInfo % hostData(3,s1,e1) !           e2 = e2Global - offset !           s2 = mesh % sideInfo % hostData(4,s1,e1)/10 !           flip = mesh % sideInfo % hostData(4,s1,e1) - s2*10 !           bcid = mesh % sideInfo % hostData(5,s1,e1) !           IF (bcid == 0) THEN !             neighborRank = decomp % elemToRank % hostData(e2Global) !             IF (neighborRank == decomp % rankId) THEN !               IF (flip == 0) THEN !                 DO ivar = 1,vector % nvar !                   DO i1 = 0,vector % interp % N !                     vector % extBoundary % hostData(1:2,i1,ivar,s1,e1) = & !                       vector % boundary % hostData(1:2,i1,ivar,s2,e2) !                   END DO !                 END DO !               ELSEIF (flip == 1) THEN !                 DO ivar = 1,vector % nvar !                   DO i1 = 0,vector % interp % N !                     i2 = vector % interp % N - i1 !                     vector % extBoundary % hostData(1:2,i1,ivar,s1,e1) = & !                       vector % boundary % hostData(1:2,i2,ivar,s2,e2) !                   END DO !                 END DO !               END IF !             END IF !           END IF !         END DO !       END DO !       CALL decomp % FinalizeMPIExchangeAsync() !     END IF !     CALL vector % ApplyFlip(decomp,mesh,gpuAccel) !   END SUBROUTINE SideExchange_MappedP2Vector2D !   SUBROUTINE Divergence_MappedP2Vector2D(compVector,geometry,divVector,dForm,gpuAccel) !     ! Strong Form Operator !     ! !     ! DG Weak Form Operator !     ! !     ! Assumes vector has been projected to computational coordinates !     ! !     IMPLICIT NONE !     CLASS(MappedP2Vector2D),INTENT(in) :: compVector !     TYPE(SEMQuad),INTENT(in) :: geometry !     TYPE(MappedScalar2D),INTENT(inout) :: divVector !     INTEGER,INTENT(in) :: dForm !     LOGICAL,INTENT(in) :: gpuAccel !     IF (dForm == selfWeakDGForm) THEN !       IF (gpuAccel) THEN !         CALL compVector % interp % P2VectorDGDivergence_2D(compVector % interior % deviceData, & !                                                          compVector % boundaryNormal % deviceData, & !                                                          divVector % interior % deviceData, & !                                                          compVector % nvar, & !                                                          compVector % nelem) !       ELSE !         CALL compVector % interp % P2VectorDGDivergence_2D(compVector % interior % hostData, & !                                                          compVector % boundaryNormal % hostData, & !                                                          divVector % interior % hostData, & !                                                          compVector % nvar, & !                                                          compVector % nelem) !       END IF !     ELSE IF (dForm == selfStrongForm) THEN !       IF (gpuAccel) THEN !         CALL compVector % interp % P2VectorDivergence_2D(compVector % interior % deviceData, & !                                                        divVector % interior % deviceData, & !                                                        compVector % nvar, & !                                                        compVector % nelem) !       ELSE !         CALL compVector % interp % P2VectorDivergence_2D(compVector % interior % hostData, & !                                                        divVector % interior % hostData, & !                                                        compVector % nvar, & !                                                        compVector % nelem) !       END IF !     END IF !     CALL divVector % JacobianWeight(geometry,gpuAccel) !   END SUBROUTINE Divergence_MappedP2Vector2D !   SUBROUTINE ContravariantProjection_MappedP2Vector2D(vector,geometry,gpuAccel) ! #undef __FUNC__ ! #define __FUNC__ \"ContravariantProjection_MappedP2Vector2D\" !     ! Takes a vector that has physical space coordinate directions (x,y,z) and projects the vector !     ! into the the contravariant basis vector directions. Keep in mind that the contravariant basis !     ! vectors are really the Jacobian weighted contravariant basis vectors !     IMPLICIT NONE !     CLASS(MappedP2Vector2D),INTENT(inout) :: vector !     TYPE(SEMQuad),INTENT(in) :: geometry !     LOGICAL,INTENT(in) :: gpuAccel !     ! Local !     INTEGER :: i,j,n,ivar,iel !     REAL(prec) :: Fx, Fy !     IF (gpuAccel) THEN !       CALL ContravariantProjection_MappedP2Vector2D_gpu_wrapper(vector % interior % deviceData, & !                                                               vector % physical % deviceData, & !                                                               geometry % dsdx % interior % deviceData, & !                                                               vector % interp % N, & !                                                               vector % nVar, & !                                                               vector % nElem) !     ELSE !       ! Assume that tensor(j,i) is vector i, component j !       ! => dot product is done along first dimension !       ! to project onto computational space !       DO iel = 1,vector % nElem !         DO ivar = 1,vector % nVar !           DO j = 0,vector % interp % N !             DO i = 0,vector % interp % N !               ! From Winters et al. 2020, Kopriva and Gassner 2014, and Kopriva et al. 2019,  we use two point averaging of the !               ! metric terms for dealiasing !               ! > See pages 60-62 of \"Construction of Modern Robust Nodal Discontinuous Galerkin Spectral Element Methods for !               !   the Compressible Navier-Stokes Equations\", Winters et al. 2020 !               DO n = 0, vector % interp % N !                 ! I think we need another attribute here, where !                 ! two point values are stored for each Fx, Fy !                 ! for each computational dimension !                 ! Fx_{(i,n),j}, Fx_{i,(j,n)} !                 ! Fy_{(i,n),j}, Fy_{i,(j,n)} !                 ! Fx_{(i,n),j} !                 Fx = vector % physical % hostData(1,1,n,i,j,ivar,iel) !                 ! Fy_{(i,n),j} !                 Fy = vector % physical % hostData(2,1,n,i,j,ivar,iel) !                 vector % interior % hostData(1,n,i,j,ivar,iel) = & !                   0.5_prec*( geometry % dsdx % interior % hostData(1,1,i,j,1,iel) + & !                              geometry % dsdx % interior % hostData(1,1,n,j,1,iel) )*Fx + & !                   0.5_prec*( geometry % dsdx % interior % hostData(2,1,i,j,1,iel) + & !                              geometry % dsdx % interior % hostData(2,1,n,j,1,iel) )*Fy !                 ! Fx_{i,(j,n)} !                 Fx = vector % physical % hostData(1,2,n,i,j,ivar,iel) !                 ! Fy_{i,(j,n)} !                 Fy = vector % physical % hostData(2,2,n,i,j,ivar,iel) !                 vector % interior % hostData(2,n,i,j,ivar,iel) = & !                   0.5_prec*( geometry % dsdx % interior % hostData(1,2,i,j,1,iel) + & !                              geometry % dsdx % interior % hostData(1,2,i,n,1,iel) )*Fx + & !                   0.5_prec*( geometry % dsdx % interior % hostData(2,2,i,j,1,iel) + & !                              geometry % dsdx % interior % hostData(2,2,i,n,1,iel) )*Fy !               ENDDO !             END DO !           END DO !         END DO !       END DO !     END IF !   END SUBROUTINE ContravariantProjection_MappedP2Vector2D !   SUBROUTINE MPIExchangeAsync_MappedP2Vector2D(vector,mpiHandler,mesh,resetCount) !     IMPLICIT NONE !     CLASS(MappedP2Vector2D),INTENT(inout) :: vector !     TYPE(MPILayer),INTENT(inout) :: mpiHandler !     TYPE(Mesh2D),INTENT(in) :: mesh !     LOGICAL,INTENT(in) :: resetCount !     ! Local !     INTEGER :: e1,s1,e2,s2 !     INTEGER :: globalSideId,r2 !     INTEGER :: iError !     INTEGER :: msgCount !     IF (mpiHandler % mpiEnabled) THEN !       IF (resetCount) THEN !         msgCount = 0 !       ELSE !         msgCount = mpiHandler % msgCount !       END IF !       DO e1 = 1,vector % nElem !         DO s1 = 1,4 !           e2 = mesh % sideInfo % hostData(3,s1,e1) ! Neighbor Element !           IF( e2 > 0 )THEN !             r2 = mpiHandler % elemToRank % hostData(e2) ! Neighbor Rank !             IF (r2 /= mpiHandler % rankId) THEN !               s2 = mesh % sideInfo % hostData(4,s1,e1)/10 !               globalSideId = ABS(mesh % sideInfo % hostdata(2,s1,e1)) !               msgCount = msgCount + 1 !               CALL MPI_IRECV(vector % extBoundary % hostData(:,:,:,s1,e1), & !                              2*(vector % interp % N + 1)*vector % nVar, & !                              mpiHandler % mpiPrec, & !                              r2,globalSideId, & !                              mpiHandler % mpiComm, & !                              mpiHandler % requests(msgCount),iError) !               msgCount = msgCount + 1 !               CALL MPI_ISEND(vector % boundary % hostData(:,:,:,s1,e1), & !                              2*(vector % interp % N + 1)*vector % nVar, & !                              mpiHandler % mpiPrec, & !                              r2,globalSideId, & !                              mpiHandler % mpiComm, & !                              mpiHandler % requests(msgCount),iError) !             END IF !           ENDIF !         END DO !       END DO !       mpiHandler % msgCount = msgCount !     END IF !   END SUBROUTINE MPIExchangeAsync_MappedP2Vector2D !   SUBROUTINE ApplyFlip_MappedP2Vector2D(vector,mpiHandler,mesh,gpuAccel) !     ! Apply side flips to sides where MPI exchanges took place. !     IMPLICIT NONE !     CLASS(MappedP2Vector2D),INTENT(inout) :: vector !     TYPE(MPILayer),INTENT(inout) :: mpiHandler !     TYPE(Mesh2D),INTENT(in) :: mesh !     LOGICAL,INTENT(in) :: gpuAccel !     ! Local !     INTEGER :: e1,s1,e2,s2 !     INTEGER :: i,i2 !     INTEGER :: r2,flip,ivar !     INTEGER :: globalSideId !     INTEGER :: bcid !     REAL(prec) :: extBuff(1:2,0:vector % interp % N) !     IF (mpiHandler % mpiEnabled) THEN !       IF (gpuAccel) THEN !         ! Since the boundary data for a p2 vector and a vector are identical, !         ! we can reuse the applyFlip method for MappedVector here !         CALL ApplyFlip_MappedVector2D_gpu_wrapper(vector % extBoundary % deviceData, & !                                                   mesh % sideInfo % deviceData, & !                                                   mpiHandler % elemToRank % deviceData, & !                                                   mpiHandler % rankId, & !                                                   vector % interp % N, & !                                                   vector % nVar, & !                                                   vector % nElem) !       ELSE !         DO e1 = 1,vector % nElem !           DO s1 = 1,4 !             e2 = mesh % sideInfo % hostData(3,s1,e1) ! Neighbor Element !             bcid = mesh % sideInfo % hostData(5,s1,e1) !             IF (bcid == 0) THEN ! Interior Element !               r2 = mpiHandler % elemToRank % hostData(e2) ! Neighbor Rank !               IF (r2 /= mpiHandler % rankId) THEN !                 s2 = mesh % sideInfo % hostData(4,s1,e1)/10 !                 flip = mesh % sideInfo % hostData(4,s1,e1) - s2*10 !                 globalSideId = mesh % sideInfo % hostdata(2,s1,e1) !                 ! Need to update extBoundary with flip applied !                 IF (flip == 1) THEN !                   DO ivar = 1,vector % nvar !                     DO i = 0,vector % interp % N !                       i2 = vector % interp % N - i !                       extBuff(1:2,i) = vector % extBoundary % hostData(1:2,i2,ivar,s1,e1) !                     END DO !                     DO i = 0,vector % interp % N !                       vector % extBoundary % hostData(1:2,i,ivar,s1,e1) = extBuff(1:2,i) !                     END DO !                   END DO !                 END IF !               END IF !             ENDIF !           END DO !         END DO !       END IF !     END IF !   END SUBROUTINE ApplyFlip_MappedP2Vector2D END MODULE SELF_MappedData","tags":"","loc":"sourcefile/self_mappeddata.f90.html"},{"title":"SELF_Metadata.f90 – SELF","text":"Contents Modules SELF_Metadata Source Code SELF_Metadata.f90 Source Code ! SELF_Metadata.F90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Metadata USE SELF_HDF5 USE HDF5 INTEGER , PARAMETER , PUBLIC :: SELF_MTD_NameLength = 250 INTEGER , PARAMETER , PUBLIC :: SELF_MTD_DescriptionLength = 1000 INTEGER , PARAMETER , PUBLIC :: SELF_MTD_UnitsLength = 20 ! A class for storing metadata information, intended for file IO TYPE Metadata CHARACTER ( SELF_MTD_NameLength ) :: name CHARACTER ( SELF_MTD_DescriptionLength ) :: description CHARACTER ( SELF_MTD_UnitsLength ) :: units CONTAINS PROCEDURE , PUBLIC :: SetName => SetName_Metadata PROCEDURE , PUBLIC :: SetDescription => SetDescription_Metadata PROCEDURE , PUBLIC :: SetUnits => SetUnits_Metadata PROCEDURE , PUBLIC :: WriteHDF5 => WriteHDF5_Metadata END TYPE Metadata CONTAINS SUBROUTINE SetName_Metadata ( mtd , name ) IMPLICIT NONE CLASS ( Metadata ), INTENT ( inout ) :: mtd CHARACTER ( * ), INTENT ( in ) :: name mtd % name = name END SUBROUTINE SetName_Metadata SUBROUTINE SetDescription_Metadata ( mtd , description ) IMPLICIT NONE CLASS ( Metadata ), INTENT ( inout ) :: mtd CHARACTER ( * ), INTENT ( in ) :: description mtd % description = description END SUBROUTINE SetDescription_Metadata SUBROUTINE SetUnits_Metadata ( mtd , units ) IMPLICIT NONE CLASS ( Metadata ), INTENT ( inout ) :: mtd CHARACTER ( * ), INTENT ( in ) :: units mtd % units = units END SUBROUTINE SetUnits_Metadata SUBROUTINE WriteHDF5_Metadata ( mtd , group , varid , fileId ) !! Writes the metadata to a HDF5 file using the !! fields : !!  * `/metadata/{group}/name/{varid}` !!  * `/metadata/{group}/description/{varid}` !!  * `/metadata/{group}/units/{varid}` !! !! This method assumes that an HDF5 file is already !! open for writing and is associated with the `fileId` !! input. CLASS ( Metadata ), INTENT ( in ) :: mtd CHARACTER ( * ), INTENT ( in ) :: group INTEGER , INTENT ( in ) :: varid INTEGER ( HID_T ), INTENT ( in ) :: fileId ! Local CHARACTER ( 4 ) :: varNumber ! Add variable names to the file CALL CreateGroup_HDF5 ( fileId , TRIM ( group ) // \"/metadata\" ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group ) // \"/metadata/name\" ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group ) // \"/metadata/description\" ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group ) // \"/metadata/units\" ) WRITE ( varNumber , \"(I0)\" ) varid CALL WriteCharacter_HDF5 ( fileId , TRIM ( group ) // \"/metadata/name/\" // TRIM ( varnumber ), & TRIM ( mtd % name )) CALL WriteCharacter_HDF5 ( fileId , TRIM ( group ) // \"/metadata/description/\" // TRIM ( varnumber ), & TRIM ( mtd % description )) CALL WriteCharacter_HDF5 ( fileId , TRIM ( group ) // \"/metadata/units/\" // TRIM ( varnumber ), & TRIM ( mtd % units )) END SUBROUTINE WriteHDF5_Metadata END MODULE SELF_Metadata","tags":"","loc":"sourcefile/self_metadata.f90.html"},{"title":"SELF_Model1D.f90 – SELF","text":"Contents Modules SELF_Model1D Source Code SELF_Model1D.f90 Source Code ! ! Copyright 2020-2022 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : support@fluidnumerics.com ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Model1D USE SELF_SupportRoutines USE SELF_Metadata USE SELF_Mesh USE SELF_MappedData USE SELF_HDF5 USE HDF5 USE FEQParse USE SELF_Model IMPLICIT NONE #include \"SELF_Macros.h\" TYPE , EXTENDS ( Model ) :: Model1D TYPE ( MappedScalar1D ) :: solution TYPE ( MappedScalar1D ) :: solutionGradient TYPE ( MappedScalar1D ) :: velocity TYPE ( MappedScalar1D ) :: flux TYPE ( MappedScalar1D ) :: source TYPE ( MappedScalar1D ) :: fluxDivergence TYPE ( MappedScalar1D ) :: dSdt TYPE ( MappedScalar1D ) :: workSol TYPE ( MappedScalar1D ) :: prevSol TYPE ( Mesh1D ), POINTER :: mesh TYPE ( Geometry1D ), POINTER :: geometry CONTAINS PROCEDURE :: Init => Init_Model1D PROCEDURE :: Free => Free_Model1D PROCEDURE :: UpdateHost => UpdateHost_Model1D PROCEDURE :: UpdateDevice => UpdateDevice_Model1D PROCEDURE :: UpdateSolution => UpdateSolution_Model1D PROCEDURE :: ResizePrevSol => ResizePrevSol_Model1D PROCEDURE :: UpdateGAB2 => UpdateGAB2_Model1D PROCEDURE :: UpdateGAB3 => UpdateGAB3_Model1D PROCEDURE :: UpdateGAB4 => UpdateGAB4_Model1D PROCEDURE :: UpdateGRK2 => UpdateGRK2_Model1D PROCEDURE :: UpdateGRK3 => UpdateGRK3_Model1D PROCEDURE :: UpdateGRK4 => UpdateGRK4_Model1D PROCEDURE :: CalculateTendency => CalculateTendency_Model1D PROCEDURE :: CalculateFluxDivergence => CalculateFluxDivergence_Model1D GENERIC :: SetSolution => SetSolutionFromChar_Model1D , & SetSolutionFromEqn_Model1D PROCEDURE , PRIVATE :: SetSolutionFromChar_Model1D PROCEDURE , PRIVATE :: SetSolutionFromEqn_Model1D PROCEDURE :: ReadModel => Read_Model1D PROCEDURE :: WriteModel => Write_Model1D PROCEDURE :: WriteTecplot => WriteTecplot_Model1D END TYPE Model1D INTERFACE SUBROUTINE UpdateSolution_Model1D_gpu_wrapper ( solution , dSdt , dt , N , nVar , nEl ) & BIND ( c , name = \"UpdateSolution_Model1D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( C_PTR ) :: solution , dSdt INTEGER ( C_INT ), VALUE :: N , nVar , nEl REAL ( c_prec ), VALUE :: dt END SUBROUTINE UpdateSolution_Model1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE UpdateGAB2_Model1D_gpu_wrapper ( prevsol , solution , m , nPrev , N , nVar , nEl ) & BIND ( c , name = \"UpdateGAB2_Model1D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( C_PTR ) :: prevsol , solution INTEGER ( C_INT ), VALUE :: m , nPrev , N , nVar , nEl END SUBROUTINE UpdateGAB2_Model1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE UpdateGAB3_Model1D_gpu_wrapper ( prevsol , solution , m , nPrev , N , nVar , nEl ) & BIND ( c , name = \"UpdateGAB3_Model1D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( C_PTR ) :: prevsol , solution INTEGER ( C_INT ), VALUE :: m , nPrev , N , nVar , nEl END SUBROUTINE UpdateGAB3_Model1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE UpdateGAB4_Model1D_gpu_wrapper ( prevsol , solution , m , nPrev , N , nVar , nEl ) & BIND ( c , name = \"UpdateGAB4_Model1D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( C_PTR ) :: prevsol , solution INTEGER ( C_INT ), VALUE :: m , nPrev , N , nVar , nEl END SUBROUTINE UpdateGAB4_Model1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE UpdateGRK_Model1D_gpu_wrapper ( grk , solution , dSdt , rk_a , rk_g , dt , nWork , N , nVar , nEl ) & BIND ( c , name = \"UpdateGRK_Model1D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( C_PTR ) :: grk , solution , dSdt INTEGER ( C_INT ), VALUE :: nWork , N , nVar , nEl REAL ( c_prec ), VALUE :: rk_a , rk_g , dt END SUBROUTINE UpdateGRK_Model1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE CalculateDSDt_Model1D_gpu_wrapper ( fluxDivergence , source , dSdt , N , nVar , nEl ) & BIND ( c , name = \"CalculateDSDt_Model1D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( C_PTR ) :: fluxDivergence , source , dSdt INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE CalculateDSDt_Model1D_gpu_wrapper END INTERFACE CONTAINS SUBROUTINE Init_Model1D ( this , nvar , mesh , geometry , decomp ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: nvar TYPE ( Mesh1D ), INTENT ( in ), TARGET :: mesh TYPE ( Geometry1D ), INTENT ( in ), TARGET :: geometry TYPE ( MPILayer ), INTENT ( in ), TARGET :: decomp this % decomp => decomp this % mesh => mesh this % geometry => geometry this % gpuAccel = . FALSE . CALL this % solution % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % workSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % prevSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % velocity % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % dSdt % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % solutionGradient % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % flux % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % source % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % fluxDivergence % Init ( geometry % x % interp , nVar , this % mesh % nElem ) END SUBROUTINE Init_Model1D SUBROUTINE Free_Model1D ( this ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CALL this % solution % Free () CALL this % workSol % Free () CALL this % prevSol % Free () CALL this % velocity % Free () CALL this % dSdt % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () END SUBROUTINE Free_Model1D SUBROUTINE ResizePrevSol_Model1D ( this , m ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: nVar ! Free space, if necessary CALL this % prevSol % Free () ! Reallocate with increased variable dimension for ! storing \"m\" copies of solution data nVar = this % solution % nVar CALL this % prevSol % Init ( this % geometry % x % interp , m * nVar , this % mesh % nElem ) END SUBROUTINE ResizePrevSol_Model1D SUBROUTINE UpdateHost_Model1D ( this ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CALL this % mesh % UpdateHost () CALL this % geometry % UpdateHost () CALL this % velocity % UpdateHost () CALL this % solution % UpdateHost () CALL this % dSdt % UpdateHost () CALL this % solutionGradient % UpdateHost () CALL this % flux % UpdateHost () CALL this % source % UpdateHost () CALL this % fluxDivergence % UpdateHost () END SUBROUTINE UpdateHost_Model1D SUBROUTINE UpdateDevice_Model1D ( this ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CALL this % mesh % UpdateDevice () CALL this % geometry % UpdateDevice () CALL this % dSdt % UpdateDevice () CALL this % solution % UpdateDevice () CALL this % velocity % UpdateDevice () CALL this % solutionGradient % UpdateDevice () CALL this % flux % UpdateDevice () CALL this % source % UpdateDevice () CALL this % fluxDivergence % UpdateDevice () END SUBROUTINE UpdateDevice_Model1D SUBROUTINE SetSolutionFromEqn_Model1D ( this , eqn ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar ! Copy the equation parser DO iVar = 1 , this % solution % nVar CALL this % solution % SetEquation ( ivar , eqn ( iVar ) % equation ) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromEqn_Model1D SUBROUTINE SetSolutionFromChar_Model1D ( this , eqnChar ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CHARACTER ( LEN = SELF_EQUATION_LENGTH ), INTENT ( in ) :: eqnChar ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar DO iVar = 1 , this % solution % nVar PRINT * , iVar , eqnChar ( iVar ) CALL this % solution % SetEquation ( ivar , eqnChar ( iVar )) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromChar_Model1D SUBROUTINE UpdateSolution_Model1D ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this REAL ( prec ), OPTIONAL , INTENT ( in ) :: dt ! Local REAL ( prec ) :: dtLoc INTEGER :: i , iVar , iEl IF ( PRESENT ( dt )) THEN dtLoc = dt ELSE dtLoc = this % dt END IF IF ( this % gpuAccel ) THEN CALL UpdateSolution_Model1D_gpu_wrapper ( this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & dtLoc , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , iVar , iEl ) = & this % solution % interior % hostData ( i , iVar , iEl ) + & dtLoc * this % dSdt % interior % hostData ( i , iVar , iEl ) END DO END DO END DO END IF END SUBROUTINE UpdateSolution_Model1D SUBROUTINE UpdateGAB2_Model1D ( this , m ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB2_Model1D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE ! ab2_weight IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Copy the solution back from prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , iVar , iEl ) = this % prevSol % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N ! Bump the last solution nVar = this % solution % nVar this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) this % solution % interior % hostData ( i , iVar , iEl ) = & 1.5_PREC * this % prevSol % interior % hostData ( i , iVar , iEl ) - & 0.5_PREC * this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB2_Model1D SUBROUTINE UpdateGAB3_Model1D ( this , m ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB3_Model1D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSEIF ( m == 2 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , iVar , iEl ) = this % prevSol % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions nVar = this % solution % nVar this % prevSol % interior % hostData ( i , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) this % solution % interior % hostData ( i , iVar , iEl ) = & ( 2 3.0_PREC * this % prevSol % interior % hostData ( i , iVar , iEl ) - & 1 6.0_PREC * this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) + & 5.0_PREC * this % prevSol % interior % hostData ( i , 2 * nVar + iVar , iEl )) / 1 2.0_PREC END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB3_Model1D SUBROUTINE UpdateGAB4_Model1D ( this , m ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB4_Model1D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , 2 * nVar + iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSEIF ( m == 2 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSEIF ( m == 3 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , iVar , iEl ) = this % prevSol % interior % hostData ( i , iVar , iEl ) END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions this % prevSol % interior % hostData ( i , 3 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , 2 * nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , iVar , iEl ) = this % solution % interior % hostData ( i , iVar , iEl ) this % solution % interior % hostData ( i , iVar , iEl ) = & ( 5 5.0_PREC * this % prevSol % interior % hostData ( i , iVar , iEl ) - & 5 9.0_PREC * this % prevSol % interior % hostData ( i , nVar + iVar , iEl ) + & 3 7.0_PREC * this % prevSol % interior % hostData ( i , 2 * nVar + iVar , iEl ) - & 9.0_PREC * this % prevSol % interior % hostData ( i , 3 * nVar + iVar , iEl )) / 2 4.0_PREC END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB4_Model1D SUBROUTINE UpdateGRK2_Model1D ( this , m ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model1D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk2_a ( m ), rk2_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , iVar , iEl ) = rk2_a ( m ) * & this % workSol % interior % hostData ( i , iVar , iEl ) + & this % dSdt % interior % hostData ( i , iVar , iEl ) this % solution % interior % hostData ( i , iVar , iEl ) = & this % solution % interior % hostData ( i , iVar , iEl ) + & rk2_g ( m ) * this % dt * this % workSol % interior % hostData ( i , iVar , iEl ) END DO END DO END DO END IF END SUBROUTINE UpdateGRK2_Model1D SUBROUTINE UpdateGRK3_Model1D ( this , m ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model1D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk3_a ( m ), rk3_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , iVar , iEl ) = rk3_a ( m ) * & this % workSol % interior % hostData ( i , iVar , iEl ) + & this % dSdt % interior % hostData ( i , iVar , iEl ) this % solution % interior % hostData ( i , iVar , iEl ) = & this % solution % interior % hostData ( i , iVar , iEl ) + & rk3_g ( m ) * this % dt * this % workSol % interior % hostData ( i , iVar , iEl ) END DO END DO END DO END IF END SUBROUTINE UpdateGRK3_Model1D SUBROUTINE UpdateGRK4_Model1D ( this , m ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model1D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk4_a ( m ), rk4_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , iVar , iEl ) = rk4_a ( m ) * & this % workSol % interior % hostData ( i , iVar , iEl ) + & this % dSdt % interior % hostData ( i , iVar , iEl ) this % solution % interior % hostData ( i , iVar , iEl ) = & this % solution % interior % hostData ( i , iVar , iEl ) + & rk4_g ( m ) * this % dt * this % workSol % interior % hostData ( i , iVar , iEl ) END DO END DO END DO END IF END SUBROUTINE UpdateGRK4_Model1D SUBROUTINE CalculateFluxDivergence_Model1D ( this ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CALL this % flux % Derivative ( this % geometry , & this % fluxDivergence , & selfWeakDGForm , & this % gpuAccel ) END SUBROUTINE CalculateFluxDivergence_Model1D SUBROUTINE CalculateTendency_Model1D ( this ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this ! Local INTEGER :: i , iVar , iEl CALL this % solution % BoundaryInterp ( this % gpuAccel ) CALL this % solution % SideExchange ( this % mesh , this % decomp , this % gpuAccel ) CALL this % PreTendency () CALL this % SetBoundaryCondition () CALL this % SourceMethod () CALL this % RiemannSolver () CALL this % FluxMethod () CALL this % CalculateFluxDivergence () IF ( this % gpuAccel ) THEN CALL CalculateDSDt_Model1D_gpu_wrapper ( this % fluxDivergence % interior % deviceData , & this % source % interior % deviceData , & this % dSdt % interior % deviceData , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % interp % N this % dSdt % interior % hostData ( i , iVar , iEl ) = & this % source % interior % hostData ( i , iVar , iEl ) - & this % fluxDivergence % interior % hostData ( i , iVar , iEl ) END DO END DO END DO END IF END SUBROUTINE CalculateTendency_Model1D SUBROUTINE Write_Model1D ( this , fileName ) #undef __FUNC__ #define __FUNC__ \"Write_Model1D\" IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CHARACTER ( * ), OPTIONAL , INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId TYPE ( Scalar1D ) :: solution TYPE ( Scalar1D ) :: x TYPE ( Lagrange ), TARGET :: interp CHARACTER ( LEN = self_FileNameLength ) :: pickupFile CHARACTER ( 13 ) :: timeStampString WRITE ( timeStampString , '(I13.13)' ) this % ioIterate IF ( PRESENT ( filename )) THEN pickupFile = TRIM ( filename ) // timeStampString // '.h5' ELSE pickupFile = 'solution.' // timeStampString // '.h5' END IF IF ( this % gpuAccel ) THEN CALL this % solution % UpdateHost () CALL this % solutionGradient % UpdateHost () END IF INFO ( \"Writing pickup file : \" // TRIM ( pickupFile )) IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId , this % decomp % mpiComm ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file INFO ( \"Writing control grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid/mesh' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/mesh/coords' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) CALL Close_HDF5 ( fileId ) ELSE CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' ) ! Write the geometry to file INFO ( \"Writing control grid  geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file INFO ( \"Writing target grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' ) ! Write the geometry to file INFO ( \"Writing target grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid/geometry' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/geometry/x' ) CALL Close_HDF5 ( fileId ) END IF CALL x % Free () CALL solution % Free () CALL interp % Free () END SUBROUTINE Write_Model1D SUBROUTINE Read_Model1D ( this , fileName ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 3 ) INTEGER :: firstElem INTEGER :: N IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % decomp % mpiComm ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) END IF ! CALL ReadAttribute_HDF5(fileId,'N',N) ! IF (this % solution % interp % N /= N) THEN !   STOP 'Error : Solution polynomial degree does not match input file' ! END IF IF ( this % decomp % mpiEnabled ) THEN firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 3 ) = ( / 0 , 1 , firstElem / ) CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , & this % solution % interior , solOffset ) ELSE CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , this % solution % interior ) END IF CALL Close_HDF5 ( fileId ) IF ( this % gpuAccel ) THEN CALL this % solution % interior % UpdateDevice () END IF END SUBROUTINE Read_Model1D SUBROUTINE WriteTecplot_Model1D ( this , filename ) IMPLICIT NONE CLASS ( Model1D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ), OPTIONAL :: filename ! Local CHARACTER ( 8 ) :: zoneID INTEGER :: fUnit INTEGER :: iEl , i , iVar CHARACTER ( LEN = self_FileNameLength ) :: tecFile CHARACTER ( LEN = self_TecplotHeaderLength ) :: tecHeader CHARACTER ( LEN = self_FormatLength ) :: fmat CHARACTER ( 13 ) :: timeStampString CHARACTER ( 5 ) :: rankString TYPE ( Scalar1D ) :: solution TYPE ( Scalar1D ) :: x TYPE ( Lagrange ), TARGET :: interp IF ( PRESENT ( filename )) THEN tecFile = filename ELSE ! Create a 0-padded integer for the output iterate WRITE ( timeStampString , '(I13.13)' ) this % ioIterate ! Increment the ioIterate this % ioIterate = this % ioIterate + 1 tecFile = 'solution.' // timeStampString // '.curve' END IF ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) fmat = '(2(ES16.7E3,1x))' ! Let's write some tecplot!! OPEN ( UNIT = NEWUNIT ( fUnit ), & FILE = TRIM ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) DO iVar = 1 , this % solution % nVar WRITE ( tecHeader , '(E15.6)' ) this % t tecHeader = \"#TIME \" // TRIM ( tecHeader ) WRITE ( fUnit , * ) TRIM ( tecHeader ) tecHeader = \"#\" // TRIM ( this % solution % meta ( iVar ) % name ) // \" vs position\" WRITE ( fUnit , * ) TRIM ( tecHeader ) DO iEl = 1 , this % solution % nElem !WRITE (zoneID,'(I8.8)') iEl !WRITE (fUnit,*) 'ZONE T=\"el'//TRIM(zoneID)//'\", I=',this % solution % interp % M + 1 DO i = 0 , this % solution % interp % M WRITE ( fUnit , fmat ) x % interior % hostData ( i , 1 , iEl ), & solution % interior % hostData ( i , ivar , iEl ) END DO END DO END DO CLOSE ( UNIT = fUnit ) CALL x % Free () CALL solution % Free () CALL interp % Free () END SUBROUTINE WriteTecplot_Model1D END MODULE SELF_Model1D","tags":"","loc":"sourcefile/self_model1d.f90.html"},{"title":"SELF_HDF5.f90 – SELF","text":"Contents Modules SELF_HDF5 Source Code SELF_HDF5.f90 Source Code ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_HDF5 USE SELF_Constants USE SELF_Memory USE ISO_FORTRAN_ENV USE HDF5 #ifdef DOUBLE_PRECISION #define HDF5_IO_PREC H5T_IEEE_F64LE #else #define HDF5_IO_PREC H5T_IEEE_F32LE #endif IMPLICIT NONE #include \"SELF_Macros.h\" INTERFACE Open_HDF5 MODULE PROCEDURE :: Open_HDF5_serial MODULE PROCEDURE :: Open_HDF5_parallel END INTERFACE INTERFACE ReadAttribute_HDF5 MODULE PROCEDURE :: ReadAttribute_HDF5_int32 MODULE PROCEDURE :: ReadAttribute_HDF5_real MODULE PROCEDURE :: ReadAttribute_HDF5_character END INTERFACE INTERFACE WriteAttribute_HDF5 MODULE PROCEDURE :: WriteAttribute_HDF5_int32 ! MODULE PROCEDURE :: WriteAttribute_HDF5_real ! MODULE PROCEDURE :: WriteAttribute_HDF5_character END INTERFACE INTERFACE ReadArray_HDF5 MODULE PROCEDURE :: ReadArray_HDF5_real_r1_serial MODULE PROCEDURE :: ReadArray_HDF5_real_r2_serial MODULE PROCEDURE :: ReadArray_HDF5_real_r3_serial MODULE PROCEDURE :: ReadArray_HDF5_real_r4_serial MODULE PROCEDURE :: ReadArray_HDF5_real_r5_serial MODULE PROCEDURE :: ReadArray_HDF5_real_r6_serial ! MODULE PROCEDURE :: ReadArray_HDF5_real_r7_serial MODULE PROCEDURE :: ReadArray_HDF5_int32_r1_serial MODULE PROCEDURE :: ReadArray_HDF5_int32_r2_serial !  MODULE PROCEDURE :: ReadArray_HDF5_int32_r3_serial !  MODULE PROCEDURE :: ReadArray_HDF5_int32_r4_serial MODULE PROCEDURE :: ReadArray_HDF5_real_r1_parallel MODULE PROCEDURE :: ReadArray_HDF5_real_r2_parallel MODULE PROCEDURE :: ReadArray_HDF5_real_r3_parallel MODULE PROCEDURE :: ReadArray_HDF5_real_r4_parallel MODULE PROCEDURE :: ReadArray_HDF5_real_r5_parallel MODULE PROCEDURE :: ReadArray_HDF5_real_r6_parallel ! MODULE PROCEDURE :: ReadArray_HDF5_real_r7_parallel MODULE PROCEDURE :: ReadArray_HDF5_int32_r1_parallel MODULE PROCEDURE :: ReadArray_HDF5_int32_r2_parallel ! MODULE PROCEDURE :: ReadArray_HDF5_int32_r3_parallel ! MODULE PROCEDURE :: ReadArray_HDF5_int32_r4_parallel END INTERFACE INTERFACE WriteCharacter_HDF5 MODULE PROCEDURE :: WriteCharacter_HDF5_serial END INTERFACE WriteCharacter_HDF5 INTERFACE WriteArray_HDF5 MODULE PROCEDURE :: WriteArray_HDF5_real_r1_serial MODULE PROCEDURE :: WriteArray_HDF5_real_r2_serial MODULE PROCEDURE :: WriteArray_HDF5_real_r3_serial MODULE PROCEDURE :: WriteArray_HDF5_real_r4_serial MODULE PROCEDURE :: WriteArray_HDF5_real_r5_serial MODULE PROCEDURE :: WriteArray_HDF5_real_r6_serial ! MODULE PROCEDURE :: WriteArray_HDF5_real_r7_serial MODULE PROCEDURE :: WriteArray_HDF5_int32_r1_serial MODULE PROCEDURE :: WriteArray_HDF5_int32_r2_serial MODULE PROCEDURE :: WriteArray_HDF5_int32_r3_serial MODULE PROCEDURE :: WriteArray_HDF5_int32_r4_serial MODULE PROCEDURE :: WriteArray_HDF5_real_r1_parallel MODULE PROCEDURE :: WriteArray_HDF5_real_r2_parallel MODULE PROCEDURE :: WriteArray_HDF5_real_r3_parallel MODULE PROCEDURE :: WriteArray_HDF5_real_r4_parallel MODULE PROCEDURE :: WriteArray_HDF5_real_r5_parallel MODULE PROCEDURE :: WriteArray_HDF5_real_r6_parallel ! MODULE PROCEDURE :: WriteArray_HDF5_real_r7_parallel MODULE PROCEDURE :: WriteArray_HDF5_int32_r1_parallel MODULE PROCEDURE :: WriteArray_HDF5_int32_r2_parallel MODULE PROCEDURE :: WriteArray_HDF5_int32_r3_parallel MODULE PROCEDURE :: WriteArray_HDF5_int32_r4_parallel END INTERFACE PRIVATE PUBLIC :: Open_HDF5 PUBLIC :: Close_HDF5 PUBLIC :: CreateGroup_HDF5 PUBLIC :: ReadAttribute_HDF5 PUBLIC :: WriteAttribute_HDF5 PUBLIC :: ReadArray_HDF5 PUBLIC :: WriteArray_HDF5 PUBLIC :: WriteCharacter_HDF5 CONTAINS SUBROUTINE Open_HDF5_serial ( fileName , accessFlag , fileId ) IMPLICIT NONE CHARACTER ( * ), INTENT ( in ) :: fileName INTEGER , INTENT ( in ) :: accessFlag INTEGER ( HID_T ), INTENT ( inout ) :: fileId ! Local INTEGER :: error CALL h5open_f ( error ) IF ( accessFlag == H5F_ACC_TRUNC_F ) THEN CALL h5fcreate_f ( TRIM ( fileName ), accessFlag , fileId , error ) ELSE CALL h5fopen_f ( TRIM ( fileName ), accessFlag , fileId , error ) END IF IF ( error == - 1 ) THEN PRINT * , 'Failed to open ' // TRIM ( fileName ) // '.' STOP - 1 END IF END SUBROUTINE Open_HDF5_serial SUBROUTINE Open_HDF5_parallel ( fileName , accessFlag , fileId , mpiComm ) IMPLICIT NONE CHARACTER ( * ), INTENT ( in ) :: fileName INTEGER , INTENT ( in ) :: accessFlag INTEGER ( HID_T ), INTENT ( inout ) :: fileId INTEGER , INTENT ( in ) :: mpiComm ! Local INTEGER ( HID_T ) :: plistId INTEGER :: error CALL h5open_f ( error ) CALL h5pcreate_f ( H5P_FILE_ACCESS_F , plistId , error ) CALL h5pset_fapl_mpio_f ( plistId , mpiComm , MPI_INFO_NULL , error ) IF ( accessFlag == H5F_ACC_TRUNC_F ) THEN CALL h5fcreate_f ( TRIM ( fileName ), accessFlag , fileId , error , access_prp = plistId ) ELSE CALL h5fopen_f ( TRIM ( fileName ), accessFlag , fileId , error , access_prp = plistId ) END IF CALL h5pclose_f ( plistId , error ) IF ( error == - 1 ) THEN PRINT * , 'Failed to open ' // TRIM ( fileName ) // '.' STOP - 1 END IF END SUBROUTINE Open_HDF5_parallel SUBROUTINE Close_HDF5 ( fileId ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId ! Local INTEGER :: error CALL h5fclose_f ( fileId , error ) CALL h5close_f ( error ) END SUBROUTINE Close_HDF5 SUBROUTINE CreateGroup_HDF5 ( fileId , groupName ) #undef __FUNC__ #define __FUNC__ \"CreateGroup_HDF5\" IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: groupName ! Local INTEGER ( HID_T ) :: groupId LOGICAL :: groupExists INTEGER :: error CALL h5lexists_f ( fileId , TRIM ( groupName ), groupExists , error ) IF ( error /= 0 ) THEN ERROR ( \"Link check failure for \" // TRIM ( groupName ) ) ELSE IF ( . NOT . groupExists ) THEN INFO ( \"Creating group \" // TRIM ( groupName )) ! Create groups CALL h5gcreate_f ( fileId , TRIM ( groupName ), groupId , error ) IF ( error /= 0 ) THEN ERROR ( \"Failed to create group \" // TRIM ( groupName ) ) ENDIF CALL h5gclose_f ( groupId , error ) IF ( error /= 0 ) THEN ERROR ( \"Failed to close group \" // TRIM ( groupName ) ) ENDIF ENDIF ENDIF END SUBROUTINE CreateGroup_HDF5 SUBROUTINE ReadAttribute_HDF5_int32 ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName INTEGER , INTENT ( out ) :: attribute ! Local INTEGER ( HID_T ) :: attrId INTEGER ( HID_T ) :: typeId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5aopen_f ( fileId , TRIM ( attributeName ), attrId , error ) CALL h5aget_type_f ( attrId , typeId , error ) CALL h5aread_f ( attrId , typeId , attribute , dims , error ) CALL h5tclose_f ( typeId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE ReadAttribute_HDF5_int32 SUBROUTINE ReadAttribute_HDF5_real ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName REAL ( prec ), INTENT ( out ) :: attribute ! Local INTEGER ( HID_T ) :: attrId INTEGER ( HID_T ) :: typeId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5aopen_f ( fileId , TRIM ( attributeName ), attrId , error ) CALL h5aget_type_f ( attrId , typeId , error ) CALL h5aread_f ( attrId , typeId , attribute , dims , error ) CALL h5tclose_f ( typeId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE ReadAttribute_HDF5_real SUBROUTINE ReadAttribute_HDF5_character ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName CHARACTER ( * ), INTENT ( out ) :: attribute ! Local INTEGER ( HID_T ) :: attrId INTEGER ( HID_T ) :: typeId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5aopen_f ( fileId , TRIM ( attributeName ), attrId , error ) CALL h5aget_type_f ( attrId , typeId , error ) CALL h5aread_f ( attrId , typeId , attribute , dims , error ) CALL h5tclose_f ( typeId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE ReadAttribute_HDF5_character SUBROUTINE WriteAttribute_HDF5_int32 ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName INTEGER , INTENT ( in ) :: attribute ! Local INTEGER ( HID_T ) :: aspaceId INTEGER ( HID_T ) :: attrId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5screate_f ( H5S_SCALAR_F , aspaceId , error ) CALL h5acreate_f ( fileId , TRIM ( attributeName ), H5T_STD_I32LE , & aspaceId , attrId , error ) CALL h5awrite_f ( attrId , H5T_STD_I32LE , attribute , dims , error ) CALL h5sclose_f ( aspaceId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE WriteAttribute_HDF5_int32 ! SUBROUTINE WriteAttribute_HDF5_real(fileId,attributeName,attribute) !   IMPLICIT NONE !   INTEGER(HID_T),INTENT(in) :: fileId !   CHARACTER(*),INTENT(in) :: attributeName !   REAL(prec),INTENT(in) :: attribute !   ! Local !   INTEGER(HID_T) :: aspaceId !   INTEGER(HID_T) :: attrId !   INTEGER(HSIZE_T) :: dims(1:1) !   INTEGER :: error !   dims(1) = 1 !   CALL h5screate_f(H5S_SCALAR_F,aspaceId,error) !   CALL h5acreate_f(fileId,TRIM(attributeName),HDF5_IO_PREC, & !                    aspaceId,attrId,error) !   CALL h5awrite_f(attrId,HDF5_IO_PREC,attribute,dims,error) !   CALL h5sclose_f(aspaceId,error) !   CALL h5aclose_f(attrId,error) ! END SUBROUTINE WriteAttribute_HDF5_real ! SUBROUTINE WriteAttribute_HDF5_character(fileId,attributeName,attribute) !   IMPLICIT NONE !   INTEGER(HID_T),INTENT(in) :: fileId !   CHARACTER(*),INTENT(in) :: attributeName !   CHARACTER(*),INTENT(in) :: attribute !   ! Local !   INTEGER(HID_T) :: aspaceId !   INTEGER(HID_T) :: attrId !   INTEGER(HSIZE_T) :: dims(1:1) !   INTEGER :: error !   dims(1) = 1 !   CALL h5screate_f(H5S_SCALAR_F,aspaceId,error) !   CALL h5acreate_f(fileId,TRIM(attributeName),H5T_STRING, & !                    aspaceId,attrId,error) !   CALL h5awrite_f(attrId,H5T_STRING,TRIM(attribute),dims,error) !   CALL h5sclose_f(aspaceId,error) !   CALL h5aclose_f(attrId,error) ! END SUBROUTINE WriteAttribute_HDF5_character SUBROUTINE WriteArray_HDF5_real_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r1 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r1_serial SUBROUTINE WriteArray_HDF5_real_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r2 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r2_serial SUBROUTINE WriteArray_HDF5_real_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r3 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r3_serial SUBROUTINE WriteArray_HDF5_real_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r4 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r4_serial SUBROUTINE WriteArray_HDF5_real_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r5 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r5_serial SUBROUTINE WriteArray_HDF5_real_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r6 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r6_serial ! SUBROUTINE WriteArray_HDF5_real_r7_serial(fileId,arrayName,hfArray) !   IMPLICIT NONE !   INTEGER(HID_T),INTENT(in) :: fileId !   CHARACTER(*),INTENT(in) :: arrayName !   TYPE(hfReal_r7),INTENT(in) :: hfArray !   ! Local !   INTEGER(HID_T) :: dsetId !   INTEGER(HID_T) :: memspace !   INTEGER(HSIZE_T) :: dims(1:7) !   INTEGER :: error !   INTEGER :: aRank !   aRank = RANK(hfArray % hostData) !   dims = SHAPE(hfArray % hostData) !   CALL h5screate_simple_f(aRank,dims,memspace,error) !   CALL h5dcreate_f(fileId,TRIM(arrayName),HDF5_IO_PREC,memspace, & !                    dsetId,error) !   CALL h5dwrite_f(dsetId,HDF5_IO_PREC, & !                   hfArray % hostData,dims,error) !   CALL h5dclose_f(dSetId,error) !   CALL h5sclose_f(memspace,error) ! END SUBROUTINE WriteArray_HDF5_real_r7_serial SUBROUTINE WriteArray_HDF5_int32_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r1 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r1_serial SUBROUTINE WriteArray_HDF5_int32_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r2 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r2_serial SUBROUTINE WriteArray_HDF5_int32_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r3 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r3_serial SUBROUTINE WriteArray_HDF5_int32_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r4 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r4_serial SUBROUTINE WriteArray_HDF5_real_r1_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfReal_r1 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r1_parallel SUBROUTINE WriteArray_HDF5_real_r2_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfReal_r2 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 2 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r2_parallel SUBROUTINE WriteArray_HDF5_real_r3_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfReal_r3 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 3 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r3_parallel SUBROUTINE WriteArray_HDF5_real_r4_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfReal_r4 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 4 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( filespace , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r4_parallel SUBROUTINE WriteArray_HDF5_real_r5_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfReal_r5 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 5 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r5_parallel SUBROUTINE WriteArray_HDF5_real_r6_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfReal_r6 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 6 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r6_parallel ! SUBROUTINE WriteArray_HDF5_real_r7_parallel(fileId,arrayName,hfArray,offset,globalDims) !   IMPLICIT NONE !   INTEGER(HID_T),INTENT(in) :: fileId !   CHARACTER(*),INTENT(in) :: arrayName !   INTEGER(HID_T),INTENT(in) :: offset(1:7) !   TYPE(hfReal_r7),INTENT(in) :: hfArray !   INTEGER(HID_T),INTENT(in) :: globalDims(1:7) !   ! Local !   INTEGER(HID_T) :: plistId !   INTEGER(HID_T) :: dsetId !   INTEGER(HID_T) :: filespace !   INTEGER(HID_T) :: memspace !   INTEGER(HSIZE_T) :: dims(1:7) !   INTEGER :: error !   INTEGER :: aRank !   aRank = RANK(hfArray % hostData) !   dims = SHAPE(hfArray % hostData) !   CALL h5pcreate_f(H5P_DATASET_XFER_F,plistId,error) !   CALL h5pset_dxpl_mpio_f(plistId,H5FD_MPIO_INDEPENDENT_F,error) !   CALL h5screate_simple_f(aRank,globalDims,filespace,error) !   CALL h5screate_simple_f(aRank,dims,memspace,error) !   CALL h5dcreate_f(fileId,TRIM(arrayName),HDF5_IO_PREC,filespace,dsetId,error) !   CALL h5sselect_hyperslab_f(filespace,& !                              H5S_SELECT_SET_F,& !                              offset,& !                              dims,& !                              error) !   CALL h5dwrite_f(dsetId,HDF5_IO_PREC,hfArray % hostData,dims,error,memspace,filespace,plistId) !   IF( error /= 0 )THEN !     PRINT*, 'Failure to write dataset' !     STOP !   ENDIF !   CALL h5pclose_f(plistId,error) !   CALL h5sclose_f(filespace,error) !   CALL h5dclose_f(dSetId,error) !   CALL h5sclose_f(memspace,error) ! END SUBROUTINE WriteArray_HDF5_real_r7_parallel SUBROUTINE WriteArray_HDF5_int32_r1_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfint32_r1 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r1_parallel SUBROUTINE WriteArray_HDF5_int32_r2_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfint32_r2 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 2 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r2_parallel SUBROUTINE WriteArray_HDF5_int32_r3_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfint32_r3 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 3 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r3_parallel SUBROUTINE WriteArray_HDF5_int32_r4_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfint32_r4 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 4 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_INDEPENDENT_F , error ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) CALL h5sselect_hyperslab_f ( filespace ,& H5S_SELECT_SET_F ,& offset ,& dims ,& error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray % hostData , dims , error , memspace , filespace , plistId ) IF ( error /= 0 ) THEN PRINT * , 'Failure to write dataset' STOP ENDIF CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r4_parallel subroutine WriteCharacter_HDF5_serial ( fileid , name , hfField ) ! adapted from https://forum.hdfgroup.org/t/writing-a-string-array-as-attribute-in-fortran/8503/6 IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: hfField ! Local integer ( HID_T ) :: h5_strtype , h5_dspace , h5_dset integer ( HSIZE_T ), dimension ( 2 ) :: size character ( len = len ( hfField ) + 1 ), dimension ( 1 ) :: str_data integer ( SIZE_T ), dimension ( 1 ) :: str_len INTEGER :: error ! string output requires to open a file local = non-parallel str_len ( 1 ) = len_trim ( hfField ) size ( 1 ) = str_len ( 1 ) size ( 2 ) = 1 str_data ( 1 ) = hfField // char ( 0 ) ! create data space call H5Tcopy_f ( H5T_STRING , h5_strtype , error ) call H5Tset_strpad_f ( h5_strtype , H5T_STR_NULLPAD_F , error ) call h5screate_simple_f ( 1 , size ( 2 ), h5_dspace , error ) call h5dcreate_f ( fileid , trim ( name ), h5_strtype , h5_dspace , h5_dset , error ) call h5dwrite_vl_f ( h5_dset , h5_strtype , str_data , size , str_len , error , h5_dspace ) call h5dclose_f ( h5_dset , error ) call h5sclose_f ( h5_dspace , error ) end subroutine WriteCharacter_HDF5_serial SUBROUTINE ReadArray_HDF5_real_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r1_serial SUBROUTINE ReadArray_HDF5_real_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r2_serial SUBROUTINE ReadArray_HDF5_real_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r3_serial SUBROUTINE ReadArray_HDF5_real_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r4_serial SUBROUTINE ReadArray_HDF5_real_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r5_serial SUBROUTINE ReadArray_HDF5_real_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r6_serial ! SUBROUTINE ReadArray_HDF5_real_r7_serial(fileId,arrayName,hfArray) !   IMPLICIT NONE !   INTEGER(HID_T),INTENT(in) :: fileId !   CHARACTER(*),INTENT(in) :: arrayName !   TYPE(hfReal_r7),INTENT(inout) :: hfArray !   ! Local !   INTEGER(HID_T) :: dsetId !   INTEGER(HID_T) :: dims(1:7) !   INTEGER :: error !   dims = SHAPE(hfArray % hostData) !   CALL h5dopen_f(fileId,arrayName,dsetId,error) !   CALL h5dread_f(dsetId,h5kind_to_type(prec,H5_REAL_KIND),hfArray % hostData,dims,error) !   CALL h5dclose_f(dsetId,error) ! END SUBROUTINE ReadArray_HDF5_real_r7_serial SUBROUTINE ReadArray_HDF5_int32_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( INT32 , H5_INTEGER_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r1_serial SUBROUTINE ReadArray_HDF5_int32_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error dims = SHAPE ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dread_f ( dsetId , h5kind_to_type ( INT32 , H5_INTEGER_KIND ), hfArray % hostData , dims , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r2_serial ! SUBROUTINE ReadArray_HDF5_int32_r3_serial(fileId,arrayName,hfArray) !   IMPLICIT NONE !   INTEGER(HID_T),INTENT(in) :: fileId !   CHARACTER(*),INTENT(in) :: arrayName !   TYPE(hfInt32_r3),INTENT(inout) :: hfArray !   ! Local !   INTEGER(HID_T) :: dsetId !   INTEGER(HID_T) :: dims(1:3) !   INTEGER :: error !   dims = SHAPE(hfArray % hostData) !   CALL h5dopen_f(fileId,arrayName,dsetId,error) !   CALL h5dread_f(dsetId,h5kind_to_type(INT32,H5_INTEGER_KIND),hfArray % hostData,dims,error) !   CALL h5dclose_f(dsetId,error) ! END SUBROUTINE ReadArray_HDF5_int32_r3_serial ! SUBROUTINE ReadArray_HDF5_int32_r4_serial(fileId,arrayName,hfArray) !   IMPLICIT NONE !   INTEGER(HID_T),INTENT(in) :: fileId !   CHARACTER(*),INTENT(in) :: arrayName !   TYPE(hfInt32_r4),INTENT(inout) :: hfArray !   ! Local !   INTEGER(HID_T) :: dsetId !   INTEGER(HID_T) :: dims(1:4) !   INTEGER :: error !   dims = SHAPE(hfArray % hostData) !   CALL h5dopen_f(fileId,arrayName,dsetId,error) !   CALL h5dread_f(dsetId,h5kind_to_type(INT32,H5_INTEGER_KIND),hfArray % hostData,dims,error) !   CALL h5dclose_f(dsetId,error) ! END SUBROUTINE ReadArray_HDF5_int32_r4_serial SUBROUTINE ReadArray_HDF5_real_r1_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfReal_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r1_parallel SUBROUTINE ReadArray_HDF5_real_r2_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfReal_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r2_parallel SUBROUTINE ReadArray_HDF5_real_r3_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfReal_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r3_parallel SUBROUTINE ReadArray_HDF5_real_r4_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfReal_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r4_parallel SUBROUTINE ReadArray_HDF5_real_r5_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfReal_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r5_parallel SUBROUTINE ReadArray_HDF5_real_r6_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfReal_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r6_parallel ! SUBROUTINE ReadArray_HDF5_real_r7_parallel(fileId,arrayName,hfArray,offset) !   IMPLICIT NONE !   INTEGER(HID_T),INTENT(in) :: fileId !   CHARACTER(*),INTENT(in) :: arrayName !   INTEGER(HID_T),INTENT(in) :: offset(1:7) !   TYPE(hfReal_r7),INTENT(inout) :: hfArray !   ! Local !   INTEGER(HID_T) :: plistId !   INTEGER(HID_T) :: dsetId !   INTEGER(HID_T) :: dtypeId !   INTEGER(HID_T) :: filespace !   INTEGER(HID_T) :: memspace !   INTEGER(HID_T) :: dims(1:7) !   INTEGER :: error !   INTEGER :: aRank !   aRank = RANK(hfArray % hostData) !   dims = SHAPE(hfArray % hostData) !   CALL h5screate_simple_f(aRank,dims,memspace,error) !   CALL h5dopen_f(fileId,arrayName,dsetId,error) !   CALL h5dget_space_f(dsetId,filespace,error) !   CALL h5sselect_hyperslab_f(filespace,H5S_SELECT_SET_F,offset,dims,error) !   CALL h5pcreate_f(H5P_DATASET_XFER_F,plistId,error) !   CALL h5pset_dxpl_mpio_f(plistId,H5FD_MPIO_COLLECTIVE_F,error) !   CALL h5dget_type_f(dsetId,dtypeId,error) !   CALL h5dread_f(dsetId,dtypeId,hfArray % hostData,dims, & !                  error,memspace,filespace,plistId) !   CALL h5tclose_f(dtypeId,error) !   CALL h5pclose_f(plistId,error) !   CALL h5sclose_f(filespace,error) !   CALL h5dclose_f(dsetId,error) !   CALL h5sclose_f(memspace,error) ! END SUBROUTINE ReadArray_HDF5_real_r7_parallel SUBROUTINE ReadArray_HDF5_int32_r1_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfInt32_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( 1 , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r1_parallel SUBROUTINE ReadArray_HDF5_int32_r2_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfInt32_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r2_parallel ! SUBROUTINE ReadArray_HDF5_int32_r3_parallel(fileId,arrayName,hfArray,offset) !   IMPLICIT NONE !   INTEGER(HID_T),INTENT(in) :: fileId !   CHARACTER(*),INTENT(in) :: arrayName !   INTEGER(HID_T),INTENT(in) :: offset(1:3) !   TYPE(hfInt32_r3),INTENT(inout) :: hfArray !   ! Local !   INTEGER(HID_T) :: plistId !   INTEGER(HID_T) :: dsetId !   INTEGER(HID_T) :: dtypeId !   INTEGER(HID_T) :: filespace !   INTEGER(HID_T) :: memspace !   INTEGER(HID_T) :: dims(1:3) !   INTEGER :: error !   INTEGER :: aRank !   aRank = RANK(hfArray % hostData) !   dims = SHAPE(hfArray % hostData) !   CALL h5screate_simple_f(aRank,dims,memspace,error) !   CALL h5dopen_f(fileId,arrayName,dsetId,error) !   CALL h5dget_space_f(dsetId,filespace,error) !   CALL h5sselect_hyperslab_f(filespace,H5S_SELECT_SET_F,offset,dims,error) !   CALL h5pcreate_f(H5P_DATASET_XFER_F,plistId,error) !   CALL h5pset_dxpl_mpio_f(plistId,H5FD_MPIO_COLLECTIVE_F,error) !   CALL h5dget_type_f(dsetId,dtypeId,error) !   CALL h5dread_f(dsetId,dtypeId,hfArray % hostData,dims, & !                  error,memspace,filespace,plistId) !   CALL h5tclose_f(dtypeId,error) !   CALL h5pclose_f(plistId,error) !   CALL h5sclose_f(filespace,error) !   CALL h5dclose_f(dsetId,error) !   CALL h5sclose_f(memspace,error) ! END SUBROUTINE ReadArray_HDF5_int32_r3_parallel ! SUBROUTINE ReadArray_HDF5_int32_r4_parallel(fileId,arrayName,hfArray,offset) !   IMPLICIT NONE !   INTEGER(HID_T),INTENT(in) :: fileId !   CHARACTER(*),INTENT(in) :: arrayName !   INTEGER(HID_T),INTENT(in) :: offset(1:4) !   TYPE(hfInt32_r4),INTENT(inout) :: hfArray !   ! Local !   INTEGER(HID_T) :: plistId !   INTEGER(HID_T) :: dsetId !   INTEGER(HID_T) :: dtypeId !   INTEGER(HID_T) :: filespace !   INTEGER(HID_T) :: memspace !   INTEGER(HID_T) :: dims(1:4) !   INTEGER :: error !   INTEGER :: aRank !   aRank = RANK(hfArray % hostData) !   dims = SHAPE(hfArray % hostData) !   CALL h5screate_simple_f(aRank,dims,memspace,error) !   CALL h5dopen_f(fileId,arrayName,dsetId,error) !   CALL h5dget_space_f(dsetId,filespace,error) !   CALL h5sselect_hyperslab_f(filespace,H5S_SELECT_SET_F,offset,dims,error) !   CALL h5pcreate_f(H5P_DATASET_XFER_F,plistId,error) !   CALL h5pset_dxpl_mpio_f(plistId,H5FD_MPIO_COLLECTIVE_F,error) !   CALL h5dget_type_f(dsetId,dtypeId,error) !   CALL h5dread_f(dsetId,dtypeId,hfArray % hostData,dims, & !                  error,memspace,filespace,plistId) !   CALL h5tclose_f(dtypeId,error) !   CALL h5pclose_f(plistId,error) !   CALL h5sclose_f(filespace,error) !   CALL h5dclose_f(dsetId,error) !   CALL h5sclose_f(memspace,error) ! END SUBROUTINE ReadArray_HDF5_int32_r4_parallel END MODULE SELF_HDF5","tags":"","loc":"sourcefile/self_hdf5.f90.html"},{"title":"SELF_advection_diffusion_2d.f90 – SELF","text":"Contents Modules self_advection_diffusion_2d Source Code SELF_advection_diffusion_2d.f90 Source Code module self_advection_diffusion_2d use self_model use self_model2d use self_mesh implicit none type , extends ( model2d ) :: advection_diffusion_2d real ( prec ) :: nu ! diffusion coefficient real ( prec ) :: u ! constant x-component of velocity real ( prec ) :: v ! constant y-component of velocity contains procedure :: pretendency => pretendency_advection_diffusion_2d procedure :: setboundarycondition => setboundarycondition_advection_diffusion_2d procedure :: riemannsolver => riemannsolver_advection_diffusion_2d procedure :: fluxmethod => fluxmethod_advection_diffusion_2d end type advection_diffusion_2d ! Remember, the order of operations for the tendency calculation is ! !    solution % BoundaryInterp(this % gpuAccel) !    solution % SideExchange(this % mesh,this % decomp,this % gpuAccel) !    PreTendency() !    SetBoundaryCondition() !    SourceMethod() !    RiemannSolver() !    FluxMethod() !    CalculateFluxDivergence() contains subroutine pretendency_advection_diffusion_2d ( this ) ! Here, we use the pre-tendency method to calculate the ! derivative of the solution using a bassi-rebay method ! We then do a boundary interpolation and side exchange ! on the gradient field implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this ! local integer :: i , ivar , iEl , iSide , e2 do iEl = 1 , this % solution % nElem ! Loop over all elements do iSide = 1 , 4 ! Loop over all sides !bcid = this % mesh % sideInfo % hostData(5,iSide,iEl) ! Boundary Condition ID e2 = this % mesh % sideInfo % hostData ( 3 , iSide , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then do ivar = 1 , this % solution % nvar do i = 0 , this % solution % interp % N ! Loop over quadrature points this % solution % extBoundary % hostData ( i , ivar , iSide , iEl ) = 0.0_prec enddo enddo end if end do end do ! calculate the averages of the solutions on the element ! boundaries and store is this % solution % avgBoundary call this % solution % BassiRebaySides ( this % gpuaccel ) ! calculate the derivative using the bassi-rebay form call this % solution % Gradient ( this % geometry , & this % solutionGradient , selfWeakBRForm , & this % gpuaccel ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp ( this % gpuaccel ) ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh , & this % decomp , this % gpuaccel ) end subroutine pretendency_advection_diffusion_2d subroutine setboundarycondition_advection_diffusion_2d ( this ) ! Here, we set the boundary conditions for the ! solution and the solution gradient at the left ! and right most boundaries. ! ! Here, we use periodic boundary conditions implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this ! local integer :: i , ivar , iEl , iSide , e2 do iEl = 1 , this % solution % nElem ! Loop over all elements do iSide = 1 , 4 ! Loop over all sides !bcid = this % mesh % sideInfo % hostData(5,iSide,iEl) ! Boundary Condition ID e2 = this % mesh % sideInfo % hostData ( 3 , iSide , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then do ivar = 1 , this % solution % nvar do i = 0 , this % solution % interp % N ! Loop over quadrature points this % solutionGradient % extBoundary % hostData ( 1 : 2 , i , ivar , iSide , iEl ) = 0.0_prec enddo enddo end if end do end do call this % solutionGradient % BassiRebaySides ( this % gpuaccel ) end subroutine setboundarycondition_advection_diffusion_2d subroutine fluxmethod_advection_diffusion_2d ( this ) implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this ! Local integer :: iel integer :: ivar integer :: i integer :: j real ( prec ) :: u , v , nu , f , dfdx , dfdy u = this % u v = this % v nu = this % nu do iel = 1 , this % mesh % nelem do ivar = 1 , this % solution % nvar do j = 0 , this % solution % interp % N do i = 0 , this % solution % interp % N f = this % solution % interior % hostdata ( i , j , ivar , iel ) dfdx = this % solutionGradient % interior % hostdata ( 1 , i , j , ivar , iel ) dfdy = this % solutionGradient % interior % hostdata ( 2 , i , j , ivar , iel ) this % flux % interior % hostdata ( 1 , i , j , ivar , iel ) = u * f - nu * dfdx ! advective flux + diffusive flux (x-component) this % flux % interior % hostdata ( 2 , i , j , ivar , iel ) = v * f - nu * dfdy ! advective flux + diffusive flux (y-component) enddo enddo enddo enddo end subroutine fluxmethod_advection_diffusion_2d subroutine riemannsolver_advection_diffusion_2d ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this ! Local integer :: iel integer :: ivar integer :: iside integer :: i real ( prec ) :: fin , fout , dfdn , un real ( prec ) :: nhat ( 1 : 2 ), nmag do iEl = 1 , this % solution % nElem do iSide = 1 , 4 do ivar = 1 , this % solution % nvar do i = 0 , this % solution % interp % N ! Get the boundary normals on cell edges from the mesh geometry nhat ( 1 : 2 ) = this % geometry % nHat % boundary % hostData ( 1 : 2 , i , 1 , iSide , iEl ) nmag = this % geometry % nScale % boundary % hostData ( i , 1 , iSide , iEl ) un = this % u * nhat ( 1 ) + this % v * nhat ( 2 ) dfdn = this % solutionGradient % boundary % hostData ( 1 , i , ivar , iSide , iEl ) * nhat ( 1 ) + & this % solutionGradient % boundary % hostData ( 2 , i , ivar , iSide , iEl ) * nhat ( 2 ) fin = this % solution % boundary % hostdata ( i , ivar , iside , iel ) ! interior solution fout = this % solution % extboundary % hostdata ( i , ivar , iside , iel ) ! exterior solution this % flux % boundaryNormal % hostData ( i , 1 , iSide , iEl ) = ( 0.5_prec * ( & un * ( fin + fout ) + abs ( un ) * ( fin - fout ) ) - & ! advective flux this % nu * dfdn ) * nmag enddo enddo enddo enddo end subroutine riemannsolver_advection_diffusion_2d end module self_advection_diffusion_2d","tags":"","loc":"sourcefile/self_advection_diffusion_2d.f90.html"},{"title":"SELF_advection_diffusion_1d.f90 – SELF","text":"Contents Modules self_advection_diffusion_1d Source Code SELF_advection_diffusion_1d.f90 Source Code module self_advection_diffusion_1d use self_model use self_model1d use self_mesh implicit none type , extends ( model1d ) :: advection_diffusion_1d real ( prec ) :: nu ! diffusion coefficient real ( prec ) :: u ! constant velocity contains procedure :: pretendency => pretendency_advection_diffusion_1d procedure :: setboundarycondition => setboundarycondition_advection_diffusion_1d procedure :: riemannsolver => riemannsolver_advection_diffusion_1d procedure :: fluxmethod => fluxmethod_advection_diffusion_1d end type advection_diffusion_1d ! Remember, the order of operations for the tendency calculation is ! !    solution % BoundaryInterp(this % gpuAccel) !    solution % SideExchange(this % mesh,this % decomp,this % gpuAccel) !    PreTendency() !    SetBoundaryCondition() !    SourceMethod() !    RiemannSolver() !    FluxMethod() !    CalculateFluxDivergence() contains subroutine pretendency_advection_diffusion_1d ( this ) ! Here, we use the pre-tendency method to calculate the ! derivative of the solution using a bassi-rebay method ! We then do a boundary interpolation and side exchange ! on the gradient field implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this ! local integer :: ivar integer :: N , nelem nelem = this % geometry % nelem ! number of elements in the mesh N = this % solution % interp % N ! polynomial degree do ivar = 1 , this % solution % nvar ! left-most boundary this % solution % extBoundary % hostdata ( ivar , 1 , 1 ) = & this % solution % boundary % hostdata ( ivar , 2 , nelem ) ! right-most boundary this % solution % extBoundary % hostdata ( ivar , 2 , nelem ) = & this % solution % boundary % hostdata ( ivar , 1 , 1 ) enddo ! calculate the averages of the solutions on the element ! boundaries and store is this % solution % avgBoundary call this % solution % BassiRebaySides ( this % gpuaccel ) ! calculate the derivative using the bassi-rebay form call this % solution % Derivative ( this % geometry , & this % solutionGradient , selfWeakBRForm , & this % gpuaccel ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp ( this % gpuaccel ) ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh , & this % decomp , this % gpuaccel ) call this % solutionGradient % BassiRebaySides ( this % gpuaccel ) end subroutine pretendency_advection_diffusion_1d subroutine setboundarycondition_advection_diffusion_1d ( this ) ! Here, we set the boundary conditions for the ! solution and the solution gradient at the left ! and right most boundaries. ! ! Here, we use periodic boundary conditions implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this ! local integer :: ivar integer :: N , nelem nelem = this % geometry % nelem ! number of elements in the mesh N = this % solution % interp % N ! polynomial degree do ivar = 1 , this % solution % nvar ! left-most boundary this % solutionGradient % extBoundary % hostdata ( ivar , 1 , 1 ) = & this % solutionGradient % boundary % hostdata ( ivar , 2 , nelem ) this % solutionGradient % avgBoundary % hostdata ( ivar , 1 , 1 ) = & - 0.5_prec * ( this % solutionGradient % extBoundary % hostdata ( ivar , 1 , 1 ) + & this % solutionGradient % boundary % hostdata ( ivar , 1 , 1 )) ! right-most boundary this % solutionGradient % extBoundary % hostdata ( ivar , 2 , nelem ) = & this % solutionGradient % boundary % hostdata ( ivar , 1 , 1 ) this % solutionGradient % avgBoundary % hostdata ( ivar , 2 , nelem ) = & 0.5_prec * ( this % solutionGradient % extBoundary % hostdata ( ivar , 2 , nelem ) + & this % solutionGradient % boundary % hostdata ( ivar , 2 , nelem )) enddo end subroutine setboundarycondition_advection_diffusion_1d subroutine fluxmethod_advection_diffusion_1d ( this ) implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this ! Local integer :: iel integer :: ivar integer :: i real ( prec ) :: u , nu , f , dfdx u = this % u nu = this % nu do iel = 1 , this % mesh % nelem do ivar = 1 , this % solution % nvar do i = 0 , this % solution % interp % N f = this % solution % interior % hostdata ( i , ivar , iel ) dfdx = this % solutionGradient % interior % hostdata ( i , ivar , iel ) this % flux % interior % hostdata ( i , ivar , iel ) = u * f - nu * dfdx ! advective flux + diffusive flux enddo enddo enddo end subroutine fluxmethod_advection_diffusion_1d subroutine riemannsolver_advection_diffusion_1d ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this ! Local integer :: iel integer :: ivar integer :: iside real ( prec ) :: fin , fout , dfavg , un call this % solutionGradient % BassiRebaySides ( this % gpuaccel ) do iel = 1 , this % mesh % nelem do iside = 1 , 2 ! set the normal velocity if ( iside == 1 ) then un = - this % u else un = this % u endif do ivar = 1 , this % solution % nvar fin = this % solution % boundary % hostdata ( ivar , iside , iel ) ! interior solution fout = this % solution % extboundary % hostdata ( ivar , iside , iel ) ! exterior solution dfavg = this % solutionGradient % avgboundary % hostdata ( ivar , iside , iel ) ! average solution gradient (with direction taken into account) this % flux % boundary % hostdata ( ivar , iside , iel ) = 0.5_prec * ( un * ( fin + fout ) + abs ( un ) * ( fin - fout ) ) - & ! advective flux this % nu * dfavg ! diffusive flux enddo enddo enddo end subroutine riemannsolver_advection_diffusion_1d end module self_advection_diffusion_1d","tags":"","loc":"sourcefile/self_advection_diffusion_1d.f90.html"},{"title":"SELF_advection_diffusion_3d.f90 – SELF","text":"Contents Modules self_advection_diffusion_3d Source Code SELF_advection_diffusion_3d.f90 Source Code module self_advection_diffusion_3d use self_model use self_model3d use self_mesh implicit none type , extends ( model3d ) :: advection_diffusion_3d real ( prec ) :: nu ! diffusion coefficient real ( prec ) :: u ! constant x-component of velocity real ( prec ) :: v ! constant y-component of velocity real ( prec ) :: w ! constant z-component of velocity contains procedure :: pretendency => pretendency_advection_diffusion_3d procedure :: setboundarycondition => setboundarycondition_advection_diffusion_3d procedure :: riemannsolver => riemannsolver_advection_diffusion_3d procedure :: fluxmethod => fluxmethod_advection_diffusion_3d end type advection_diffusion_3d ! Remember, the order of operations for the tendency calculation is ! !    solution % BoundaryInterp(this % gpuAccel) !    solution % SideExchange(this % mesh,this % decomp,this % gpuAccel) !    PreTendency() !    SetBoundaryCondition() !    SourceMethod() !    RiemannSolver() !    FluxMethod() !    CalculateFluxDivergence() contains subroutine pretendency_advection_diffusion_3d ( this ) ! Here, we use the pre-tendency method to calculate the ! derivative of the solution using a bassi-rebay method ! We then do a boundary interpolation and side exchange ! on the gradient field implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this ! local integer :: i , j , ivar , iEl , iSide , e2 do iEl = 1 , this % solution % nElem ! Loop over all elements do iSide = 1 , 6 ! Loop over all sides !bcid = this % mesh % sideInfo % hostData(5,iSide,iEl) ! Boundary Condition ID e2 = this % mesh % sideInfo % hostData ( 3 , iSide , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then do ivar = 1 , this % solution % nvar do j = 0 , this % solution % interp % N ! Loop over quadrature point do i = 0 , this % solution % interp % N ! Loop over quadrature points this % solution % extBoundary % hostData ( i , j , ivar , iSide , iEl ) = 0.0_prec enddo enddo enddo end if end do end do ! calculate the averages of the solutions on the element ! boundaries and store is this % solution % avgBoundary call this % solution % BassiRebaySides ( this % gpuaccel ) ! calculate the derivative using the bassi-rebay form call this % solution % Gradient ( this % geometry , & this % solutionGradient , selfWeakBRForm , & this % gpuaccel ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp ( this % gpuaccel ) ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh , & this % decomp , this % gpuaccel ) end subroutine pretendency_advection_diffusion_3d subroutine setboundarycondition_advection_diffusion_3d ( this ) ! Here, we set the boundary conditions for the ! solution and the solution gradient at the left ! and right most boundaries. ! ! Here, we use periodic boundary conditions implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this ! local integer :: i , j , ivar , iEl , iSide , e2 do iEl = 1 , this % solution % nElem ! Loop over all elements do iSide = 1 , 6 ! Loop over all sides !bcid = this % mesh % sideInfo % hostData(5,iSide,iEl) ! Boundary Condition ID e2 = this % mesh % sideInfo % hostData ( 3 , iSide , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then do ivar = 1 , this % solution % nvar do j = 0 , this % solution % interp % N ! Loop over quadrature points do i = 0 , this % solution % interp % N ! Loop over quadrature points this % solutionGradient % extBoundary % hostData ( 1 : 3 , i , j , ivar , iSide , iEl ) = 0.0_prec enddo enddo enddo end if end do end do call this % solutionGradient % BassiRebaySides ( this % gpuaccel ) end subroutine setboundarycondition_advection_diffusion_3d subroutine fluxmethod_advection_diffusion_3d ( this ) implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this ! Local integer :: iel integer :: ivar integer :: i integer :: j integer :: k real ( prec ) :: u , v , w , nu , f , dfdx , dfdy , dfdz u = this % u v = this % v nu = this % nu do iel = 1 , this % mesh % nelem do ivar = 1 , this % solution % nvar do k = 0 , this % solution % interp % N do j = 0 , this % solution % interp % N do i = 0 , this % solution % interp % N f = this % solution % interior % hostdata ( i , j , k , ivar , iel ) dfdx = this % solutionGradient % interior % hostdata ( 1 , i , j , k , ivar , iel ) dfdy = this % solutionGradient % interior % hostdata ( 2 , i , j , k , ivar , iel ) dfdz = this % solutionGradient % interior % hostdata ( 3 , i , j , k , ivar , iel ) this % flux % interior % hostdata ( 1 , i , j , k , ivar , iel ) = u * f - nu * dfdx ! advective flux + diffusive flux (x-component) this % flux % interior % hostdata ( 2 , i , j , k , ivar , iel ) = v * f - nu * dfdy ! advective flux + diffusive flux (y-component) this % flux % interior % hostdata ( 3 , i , j , k , ivar , iel ) = w * f - nu * dfdz ! advective flux + diffusive flux (z-component) enddo enddo enddo enddo enddo end subroutine fluxmethod_advection_diffusion_3d subroutine riemannsolver_advection_diffusion_3d ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this ! Local integer :: iel integer :: ivar integer :: iside integer :: i , j real ( prec ) :: fin , fout , dfdn , un real ( prec ) :: nhat ( 1 : 3 ), nmag do iEl = 1 , this % solution % nElem do iSide = 1 , 6 do ivar = 1 , this % solution % nvar do j = 0 , this % solution % interp % N do i = 0 , this % solution % interp % N ! Get the boundary normals on cell edges from the mesh geometry nhat ( 1 : 3 ) = this % geometry % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , iSide , iEl ) nmag = this % geometry % nScale % boundary % hostData ( i , j , 1 , iSide , iEl ) un = this % u * nhat ( 1 ) + this % v * nhat ( 2 ) + this % w * nhat ( 3 ) dfdn = this % solutionGradient % boundary % hostData ( 1 , i , j , ivar , iSide , iEl ) * nhat ( 1 ) + & this % solutionGradient % boundary % hostData ( 2 , i , j , ivar , iSide , iEl ) * nhat ( 2 ) + & this % solutionGradient % boundary % hostData ( 3 , i , j , ivar , iSide , iEl ) * nhat ( 3 ) fin = this % solution % boundary % hostdata ( i , j , ivar , iside , iel ) ! interior solution fout = this % solution % extboundary % hostdata ( i , j , ivar , iside , iel ) ! exterior solution this % flux % boundaryNormal % hostData ( i , j , 1 , iSide , iEl ) = ( 0.5_prec * ( & un * ( fin + fout ) + abs ( un ) * ( fin - fout ) ) - & ! advective flux this % nu * dfdn ) * nmag enddo enddo enddo enddo enddo end subroutine riemannsolver_advection_diffusion_3d end module self_advection_diffusion_3d","tags":"","loc":"sourcefile/self_advection_diffusion_3d.f90.html"},{"title":"SELF_Model2D.f90 – SELF","text":"Contents Modules SELF_Model2D Source Code SELF_Model2D.f90 Source Code ! ! Copyright 2020-2022 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : support@fluidnumerics.com ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Model2D USE SELF_SupportRoutines USE SELF_Metadata USE SELF_Mesh USE SELF_MappedData USE SELF_HDF5 USE HDF5 USE FEQParse USE SELF_Model IMPLICIT NONE #include \"SELF_Macros.h\" TYPE , EXTENDS ( Model ) :: Model2D TYPE ( MappedScalar2D ) :: solution TYPE ( MappedVector2D ) :: solutionGradient TYPE ( MappedVector2D ) :: flux TYPE ( MappedScalar2D ) :: source TYPE ( MappedScalar2D ) :: fluxDivergence TYPE ( MappedScalar2D ) :: dSdt TYPE ( MappedScalar2D ) :: workSol TYPE ( MappedScalar2D ) :: prevSol TYPE ( Mesh2D ), POINTER :: mesh TYPE ( SEMQuad ), POINTER :: geometry CONTAINS PROCEDURE :: Init => Init_Model2D PROCEDURE :: Free => Free_Model2D PROCEDURE :: UpdateHost => UpdateHost_Model2D PROCEDURE :: UpdateDevice => UpdateDevice_Model2D PROCEDURE :: UpdateSolution => UpdateSolution_Model2D PROCEDURE :: ResizePrevSol => ResizePrevSol_Model2D PROCEDURE :: UpdateGAB2 => UpdateGAB2_Model2D PROCEDURE :: UpdateGAB3 => UpdateGAB3_Model2D PROCEDURE :: UpdateGAB4 => UpdateGAB4_Model2D PROCEDURE :: UpdateGRK2 => UpdateGRK2_Model2D PROCEDURE :: UpdateGRK3 => UpdateGRK3_Model2D PROCEDURE :: UpdateGRK4 => UpdateGRK4_Model2D PROCEDURE :: CalculateTendency => CalculateTendency_Model2D PROCEDURE :: CalculateFluxDivergence => CalculateFluxDivergence_Model2D GENERIC :: SetSolution => SetSolutionFromChar_Model2D , & SetSolutionFromEqn_Model2D PROCEDURE , PRIVATE :: SetSolutionFromChar_Model2D PROCEDURE , PRIVATE :: SetSolutionFromEqn_Model2D PROCEDURE :: ReprojectFlux => ReprojectFlux_Model2D PROCEDURE :: ReadModel => Read_Model2D PROCEDURE :: WriteModel => Write_Model2D PROCEDURE :: WriteTecplot => WriteTecplot_Model2D END TYPE Model2D INTERFACE SUBROUTINE UpdateSolution_Model2D_gpu_wrapper ( solution , dSdt , dt , N , nVar , nEl ) & BIND ( c , name = \"UpdateSolution_Model2D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( C_PTR ) :: solution , dSdt INTEGER ( C_INT ), VALUE :: N , nVar , nEl REAL ( c_prec ), VALUE :: dt END SUBROUTINE UpdateSolution_Model2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE UpdateGAB2_Model2D_gpu_wrapper ( prevsol , solution , m , nPrev , N , nVar , nEl ) & BIND ( c , name = \"UpdateGAB2_Model2D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( C_PTR ) :: prevsol , solution INTEGER ( C_INT ), VALUE :: m , nPrev , N , nVar , nEl END SUBROUTINE UpdateGAB2_Model2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE UpdateGAB3_Model2D_gpu_wrapper ( prevsol , solution , m , nPrev , N , nVar , nEl ) & BIND ( c , name = \"UpdateGAB3_Model2D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( C_PTR ) :: prevsol , solution INTEGER ( C_INT ), VALUE :: m , nPrev , N , nVar , nEl END SUBROUTINE UpdateGAB3_Model2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE UpdateGAB4_Model2D_gpu_wrapper ( prevsol , solution , m , nPrev , N , nVar , nEl ) & BIND ( c , name = \"UpdateGAB4_Model2D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( C_PTR ) :: prevsol , solution INTEGER ( C_INT ), VALUE :: m , nPrev , N , nVar , nEl END SUBROUTINE UpdateGAB4_Model2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE UpdateGRK_Model2D_gpu_wrapper ( grk , solution , dSdt , rk_a , rk_g , dt , nWork , N , nVar , nEl ) & BIND ( c , name = \"UpdateGRK_Model2D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( C_PTR ) :: grk , solution , dSdt INTEGER ( C_INT ), VALUE :: nWork , N , nVar , nEl REAL ( c_prec ), VALUE :: rk_a , rk_g , dt END SUBROUTINE UpdateGRK_Model2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE CalculateDSDt_Model2D_gpu_wrapper ( fluxDivergence , source , dSdt , N , nVar , nEl ) & BIND ( c , name = \"CalculateDSDt_Model2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( C_PTR ) :: fluxDivergence , source , dSdt INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE CalculateDSDt_Model2D_gpu_wrapper END INTERFACE CONTAINS SUBROUTINE Init_Model2D ( this , nvar , mesh , geometry , decomp ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: nvar TYPE ( Mesh2D ), INTENT ( in ), TARGET :: mesh TYPE ( SEMQuad ), INTENT ( in ), TARGET :: geometry TYPE ( MPILayer ), INTENT ( in ), TARGET :: decomp ! Local INTEGER :: ivar CHARACTER ( LEN = 3 ) :: ivarChar CHARACTER ( LEN = 25 ) :: varname this % decomp => decomp this % mesh => mesh this % geometry => geometry this % gpuAccel = . FALSE . CALL this % solution % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % workSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % prevSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % dSdt % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % solutionGradient % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % flux % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % source % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % fluxDivergence % Init ( geometry % x % interp , nVar , this % mesh % nElem ) ! set default metadata DO ivar = 1 , nvar WRITE ( ivarChar , '(I3.3)' ) ivar varname = \"solution\" // TRIM ( ivarChar ) CALL this % solution % SetName ( ivar , varname ) CALL this % solution % SetUnits ( ivar , \"[null]\" ) END DO END SUBROUTINE Init_Model2D SUBROUTINE Free_Model2D ( this ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CALL this % solution % Free () CALL this % workSol % Free () CALL this % prevSol % Free () CALL this % dSdt % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () END SUBROUTINE Free_Model2D SUBROUTINE ResizePrevSol_Model2D ( this , m ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: nVar ! Free space, if necessary CALL this % prevSol % Free () ! Reallocate with increased variable dimension for ! storing \"m\" copies of solution data nVar = this % solution % nVar CALL this % prevSol % Init ( this % geometry % x % interp , m * nVar , this % mesh % nElem ) END SUBROUTINE ResizePrevSol_Model2D SUBROUTINE UpdateHost_Model2D ( this ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CALL this % mesh % UpdateHost () CALL this % geometry % UpdateHost () CALL this % solution % UpdateHost () CALL this % dSdt % UpdateHost () CALL this % solution % UpdateHost () CALL this % solutionGradient % UpdateHost () CALL this % flux % UpdateHost () CALL this % source % UpdateHost () CALL this % fluxDivergence % UpdateHost () END SUBROUTINE UpdateHost_Model2D SUBROUTINE UpdateDevice_Model2D ( this ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CALL this % mesh % UpdateDevice () CALL this % geometry % UpdateDevice () CALL this % dSdt % UpdateDevice () CALL this % solution % UpdateDevice () CALL this % solutionGradient % UpdateDevice () CALL this % flux % UpdateDevice () CALL this % source % UpdateDevice () CALL this % fluxDivergence % UpdateDevice () END SUBROUTINE UpdateDevice_Model2D SUBROUTINE SetSolutionFromEqn_Model2D ( this , eqn ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar ! Copy the equation parser DO iVar = 1 , this % solution % nVar CALL this % solution % SetEquation ( ivar , eqn ( iVar ) % equation ) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromEqn_Model2D SUBROUTINE SetSolutionFromChar_Model2D ( this , eqnChar ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: eqnChar ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar DO iVar = 1 , this % solution % nVar CALL this % solution % SetEquation ( ivar , TRIM ( eqnChar ( iVar ))) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromChar_Model2D SUBROUTINE UpdateSolution_Model2D ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this REAL ( prec ), OPTIONAL , INTENT ( in ) :: dt ! Local REAL ( prec ) :: dtLoc INTEGER :: i , j , iVar , iEl IF ( PRESENT ( dt )) THEN dtLoc = dt ELSE dtLoc = this % dt END IF IF ( this % gpuAccel ) THEN CALL UpdateSolution_Model2D_gpu_wrapper ( this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & dtLoc , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & dtLoc * this % dSdt % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateSolution_Model2D SUBROUTINE UpdateGAB2_Model2D ( this , m ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB2_Model2D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE ! ab2_weight IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Reset solution DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last solution this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & 1.5_PREC * this % prevSol % interior % hostData ( i , j , iVar , iEl ) - & 0.5_PREC * this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) END DO END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB2_Model2D SUBROUTINE UpdateGAB3_Model2D ( this , m ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB3_Model2D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 2 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & ( 2 3.0_PREC * this % prevSol % interior % hostData ( i , j , iVar , iEl ) - & 1 6.0_PREC * this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) + & 5.0_PREC * this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl )) / 1 2.0_PREC END DO END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB3_Model2D SUBROUTINE UpdateGAB4_Model2D ( this , m ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB4_Model2D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 2 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 3 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions this % prevSol % interior % hostData ( i , j , 3 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & ( 5 5.0_PREC * this % prevSol % interior % hostData ( i , j , iVar , iEl ) - & 5 9.0_PREC * this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) + & 3 7.0_PREC * this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) - & 9.0_PREC * this % prevSol % interior % hostData ( i , j , 3 * nVar + iVar , iEl )) / 2 4.0_PREC END DO END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB4_Model2D SUBROUTINE UpdateGRK2_Model2D ( this , m ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model2D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk2_a ( m ), rk2_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , iVar , iEl ) = rk2_a ( m ) * & this % workSol % interior % hostData ( i , j , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & rk2_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateGRK2_Model2D SUBROUTINE UpdateGRK3_Model2D ( this , m ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model2D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk3_a ( m ), rk3_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , iVar , iEl ) = rk3_a ( m ) * & this % workSol % interior % hostData ( i , j , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & rk3_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateGRK3_Model2D SUBROUTINE UpdateGRK4_Model2D ( this , m ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model2D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk4_a ( m ), rk4_g ( m ), this % dt , & this % workSol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , iVar , iEl ) = rk4_a ( m ) * & this % workSol % interior % hostData ( i , j , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & rk4_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateGRK4_Model2D SUBROUTINE ReprojectFlux_Model2D ( this ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CALL this % flux % ContravariantProjection ( this % geometry , this % gpuAccel ) END SUBROUTINE ReprojectFlux_Model2D SUBROUTINE CalculateFluxDivergence_Model2D ( this ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CALL this % flux % Divergence ( this % geometry , & this % fluxDivergence , & selfWeakDGForm , & this % gpuAccel ) END SUBROUTINE CalculateFluxDivergence_Model2D SUBROUTINE CalculateTendency_Model2D ( this ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this ! Local INTEGER :: i , j , iVar , iEl CALL this % PreTendency () CALL this % solution % BoundaryInterp ( this % gpuAccel ) CALL this % solution % SideExchange ( this % mesh , this % decomp , this % gpuAccel ) CALL this % SetBoundaryCondition () CALL this % SourceMethod () CALL this % RiemannSolver () CALL this % FluxMethod () CALL this % ReprojectFlux () CALL this % CalculateFluxDivergence () IF ( this % gpuAccel ) THEN CALL CalculateDSDt_Model2D_gpu_wrapper ( this % fluxDivergence % interior % deviceData , & this % source % interior % deviceData , & this % dSdt % interior % deviceData , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % dSdt % interior % hostData ( i , j , iVar , iEl ) = & this % source % interior % hostData ( i , j , iVar , iEl ) - & this % fluxDivergence % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE CalculateTendency_Model2D SUBROUTINE Write_Model2D ( this , fileName ) #undef __FUNC__ #define __FUNC__ \"Write_Model2D\" IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CHARACTER ( * ), OPTIONAL , INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId TYPE ( Scalar2D ) :: solution TYPE ( Vector2D ) :: x TYPE ( Lagrange ), TARGET :: interp CHARACTER ( LEN = self_FileNameLength ) :: pickupFile CHARACTER ( 13 ) :: timeStampString IF ( PRESENT ( filename )) THEN pickupFile = filename ELSE WRITE ( timeStampString , '(I13.13)' ) this % ioIterate pickupFile = 'solution.' // timeStampString // '.h5' END IF IF ( this % gpuAccel ) THEN CALL this % solution % UpdateHost () CALL this % solutionGradient % UpdateHost () END IF INFO ( \"Writing pickup file : \" // TRIM ( pickupFile )) IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId , this % decomp % mpiComm ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file INFO ( \"Writing control grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid/mesh' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/mesh/coords' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) CALL Close_HDF5 ( fileId ) ELSE CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' ) ! Write the geometry to file INFO ( \"Writing control grid  geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file INFO ( \"Writing target grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' ) ! Write the geometry to file INFO ( \"Writing target grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid/geometry' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/geometry/x' ) CALL Close_HDF5 ( fileId ) END IF CALL x % Free () CALL solution % Free () CALL interp % Free () END SUBROUTINE Write_Model2D SUBROUTINE Read_Model2D ( this , fileName ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 4 ) INTEGER :: firstElem INTEGER :: N IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % decomp % mpiComm ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) END IF ! CALL ReadAttribute_HDF5(fileId,'N',N) ! IF (this % solution % interp % N /= N) THEN !   STOP 'Error : Solution polynomial degree does not match input file' ! END IF IF ( this % decomp % mpiEnabled ) THEN firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 4 ) = ( / 0 , 0 , 1 , firstElem / ) CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , & this % solution % interior , solOffset ) ELSE CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , this % solution % interior ) END IF CALL Close_HDF5 ( fileId ) IF ( this % gpuAccel ) THEN CALL this % solution % interior % UpdateDevice () END IF END SUBROUTINE Read_Model2D SUBROUTINE WriteTecplot_Model2D ( this , filename ) IMPLICIT NONE CLASS ( Model2D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ), OPTIONAL :: filename ! Local CHARACTER ( 8 ) :: zoneID INTEGER :: fUnit INTEGER :: iEl , i , j , iVar CHARACTER ( LEN = self_FileNameLength ) :: tecFile CHARACTER ( LEN = self_TecplotHeaderLength ) :: tecHeader CHARACTER ( LEN = self_FormatLength ) :: fmat CHARACTER ( 13 ) :: timeStampString CHARACTER ( 5 ) :: rankString TYPE ( Scalar2D ) :: solution TYPE ( Vector2D ) :: solutionGradient TYPE ( Vector2D ) :: x TYPE ( Lagrange ), TARGET :: interp IF ( PRESENT ( filename )) THEN tecFile = filename ELSE WRITE ( timeStampString , '(I13.13)' ) this % ioIterate IF ( this % decomp % mpiEnabled ) THEN WRITE ( rankString , '(I5.5)' ) this % decomp % rankId tecFile = 'solution.' // rankString // '.' // timeStampString // '.tec' ELSE tecFile = 'solution.' // timeStampString // '.tec' END IF END IF ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL solutionGradient % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solutionGradient % GridInterp ( solutionGradient , gpuAccel = . FALSE .) OPEN ( UNIT = NEWUNIT ( fUnit ), & FILE = TRIM ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) tecHeader = 'VARIABLES = \"X\", \"Y\"' DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"' // TRIM ( this % solution % meta ( iVar ) % name ) // '\"' END DO DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"d/dx(' // TRIM ( this % solution % meta ( iVar ) % name ) // ')\"' END DO DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"d/dy(' // TRIM ( this % solution % meta ( iVar ) % name ) // ')\"' END DO WRITE ( fUnit , * ) TRIM ( tecHeader ) ! Create format statement WRITE ( fmat , * ) 3 * this % solution % nvar + 2 fmat = '(' // TRIM ( fmat ) // '(ES16.7E3,1x))' DO iEl = 1 , this % solution % nElem ! TO DO :: Get the global element ID WRITE ( zoneID , '(I8.8)' ) iEl WRITE ( fUnit , * ) 'ZONE T=\"el' // TRIM ( zoneID ) // '\", I=' , this % solution % interp % M + 1 , & ', J=' , this % solution % interp % M + 1 DO j = 0 , this % solution % interp % M DO i = 0 , this % solution % interp % M WRITE ( fUnit , fmat ) x % interior % hostData ( 1 , i , j , 1 , iEl ), & x % interior % hostData ( 2 , i , j , 1 , iEl ), & solution % interior % hostData ( i , j , 1 : this % solution % nvar , iEl ), & solutionGradient % interior % hostData ( 1 , i , j , 1 : this % solution % nvar , iEl ), & solutionGradient % interior % hostData ( 2 , i , j , 1 : this % solution % nvar , iEl ) END DO END DO END DO CLOSE ( UNIT = fUnit ) CALL x % Free () CALL solution % Free () CALL interp % Free () END SUBROUTINE WriteTecplot_Model2D END MODULE SELF_Model2D","tags":"","loc":"sourcefile/self_model2d.f90.html"},{"title":"SELF_Mesh.f90 – SELF","text":"Contents Modules SELF_Mesh Source Code SELF_Mesh.f90 Source Code ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Mesh USE SELF_Constants USE SELF_HIP USE SELF_Lagrange USE SELF_Data USE SELF_SupportRoutines USE SELF_HDF5 ! External Libs ! USE HDF5 USE ISO_C_BINDING IMPLICIT NONE #include \"SELF_Macros.h\" ! ========================================================================= ! ! Node, Edge, Face, Element and Connectivity Standard ! ========================================================================= ! ! ! To define the element corner nodes, the side order and side connectivity, ! we follow the standard from CGNS SIDS (CFD General Notation System, ! Standard Interface Data Structures, http: //cgns.sourceforge.net/ ). ! ! Computational coordinate directions are defined as follows ! ! xi1 direction points from \"West\" (xi1=-1) to \"East\" (xi1=1) ! xi2 direction points from \"South\" (xi2=-1) to \"North\" (xi2=1) ! xi3 direction points from \"Bottom\" (xi3=-1) to \"Top\" (xi3=1) ! ! 2-D Hexahedreal Element sides are defined as ! ! Side 1 = South  (xi2 = -1) = [CN1, CN2] ! Side 2 = East   (xi1 = 1) = [CN2, CN3] ! Side 3 = North  (xi2 = 1) = [CN4, CN3] ! Side 4 = West   (xi1 = -1) = [CN1, CN4] ! ! 3-D Hexahedreal Element sides are defined as ! ! Side 1 = Bottom (xi3 = -1) = [CN1, CN4, CN3, CN2] ! Side 2 = South  (xi2 = -1) = [CN1, CN2, CN6, CN5] ! Side 3 = East   (xi1 = 1) = [CN2, CN3, CN7, CN6] ! Side 4 = North  (xi2 = 1) = [CN3, CN4, CN8, CN7] ! Side 5 = West   (xi1 = -1) = [CN1, CN5, CN8, CN4] ! Side 6 = Top    (xi3 = 1) = [CN5, CN6, CN7, CN8] ! ! In 2-D, corner nodes are order counter-clockwise (looking in the -xi3 direction). ! ! CornerNode 1 = South-West = (-1,-1) ! CornerNode 2 = South-East = ( 1,-1) ! CornerNode 3 = North-East = ( 1, 1) ! CornerNode 4 = North-West = (-1, 1) ! ! In 3-D, corner nodes are order counter-clockwise (looking in the -xi3 direction) from ! bottom to top. ! ! CornerNode 1 = Bottom-South-West = (-1,-1,-1) ! CornerNode 2 = Bottom-South-East = ( 1,-1,-1) ! CornerNode 3 = Bottom-North-East = ( 1, 1,-1) ! CornerNode 4 = Bottom-North-West = (-1, 1,-1) ! CornerNode 5 = Top-South-West = (-1,-1, 1) ! CornerNode 6 = Top-South-East = ( 1,-1, 1) ! CornerNode 7 = Top-North-East = ( 1, 1, 1) ! CornerNode 8 = Top-North-West = (-1, 1, 1) ! ! ! Notes: !  * cornerNode attributes have not been implemented yet ! !  * For line segments, quads, and hexes, SELF uses Legendre-Gauss-Lobatto quadrature ! ! ! Connectivity information ! !  sideInfo(1:5,iSide,iEl) ! !    1 - Side Type !    2 - Global Side ID !    3 - Neighbor Element ID !    4 - 10*( neighbor local side )  + flip !    5 - Boundary Condition ID ! ! ! ========================================================================= ! ! Element Types - From Table 4.1 of https://www.hopr-project.org/externals/Meshformat.pdf INTEGER , PARAMETER :: selfLineLinear = 1 INTEGER , PARAMETER :: selfLineNonlinear = 2 INTEGER , PARAMETER :: selfTriangleLinear = 3 INTEGER , PARAMETER :: selfQuadLinear = 4 INTEGER , PARAMETER :: selfQuadBilinear = 14 INTEGER , PARAMETER :: selfTriangleNonlinear = 23 INTEGER , PARAMETER :: selfQuadNonlinear = 24 INTEGER , PARAMETER :: selfTetrahedronLinear = 104 INTEGER , PARAMETER :: selfPyramidLinear = 105 INTEGER , PARAMETER :: selfPrismLinear = 106 INTEGER , PARAMETER :: selfHexahedronLinear = 108 INTEGER , PARAMETER :: selfPyramidBilinear = 115 INTEGER , PARAMETER :: selfPrismBilinear = 116 INTEGER , PARAMETER :: selfHexahedronBilinear = 118 INTEGER , PARAMETER :: selfTetrahedronNonlinear = 204 INTEGER , PARAMETER :: selfPyramidNonlinear = 205 INTEGER , PARAMETER :: selfPrismNonlinear = 206 INTEGER , PARAMETER :: selfHexahedronNonlinear = 208 ! INTEGER , PARAMETER :: selfMinNodalValence2D = 4 INTEGER , PARAMETER :: selfMinNodalValence3D = 8 INTEGER , PARAMETER :: selfMaxNodalValence2D = 6 INTEGER , PARAMETER :: selfMaxNodalValence3D = 10 ! Side Ordering INTEGER , PARAMETER :: selfSide2D_South = 1 INTEGER , PARAMETER :: selfSide2D_East = 2 INTEGER , PARAMETER :: selfSide2D_North = 3 INTEGER , PARAMETER :: selfSide2D_West = 4 INTEGER , PARAMETER :: selfSide3D_Bottom = 1 INTEGER , PARAMETER :: selfSide3D_South = 2 INTEGER , PARAMETER :: selfSide3D_East = 3 INTEGER , PARAMETER :: selfSide3D_North = 4 INTEGER , PARAMETER :: selfSide3D_West = 5 INTEGER , PARAMETER :: selfSide3D_Top = 6 ! INTEGER , PARAMETER :: self_BCDefault = 1 INTEGER , PARAMETER :: self_nBCsDefault = 5 !==============================================! ! --------------- File Types------------------ ! !==============================================! INTEGER , PARAMETER :: SELF_MESH_ISM_V2_2D = 1 INTEGER , PARAMETER :: SELF_MESH_ISM_V2_3D = 2 INTEGER , PARAMETER :: SELF_MESH_HOPR_2D = 3 INTEGER , PARAMETER :: SELF_MESH_HOPR_3D = 4 TYPE MeshSpec CHARACTER ( self_FileNameLength ) :: filename INTEGER :: fileType LOGICAL :: blockMesh INTEGER :: blockMesh_nGeo INTEGER :: blockMesh_nElemX INTEGER :: blockMesh_nElemY INTEGER :: blockMesh_nElemZ REAL ( prec ) :: blockMesh_x0 , blockMesh_x1 REAL ( prec ) :: blockMesh_y0 , blockMesh_y1 REAL ( prec ) :: blockMesh_z0 , blockMesh_z1 END TYPE MeshSpec TYPE MPILayer LOGICAL :: mpiEnabled INTEGER :: mpiComm INTEGER :: mpiPrec INTEGER :: rankId INTEGER :: nRanks INTEGER :: nElem INTEGER :: maxMsg INTEGER :: msgCount TYPE ( hfInt32_r1 ) :: elemToRank TYPE ( hfInt32_r1 ) :: offSetElem INTEGER , ALLOCATABLE :: requests (:) INTEGER , ALLOCATABLE :: stats (:,:) CONTAINS PROCEDURE :: Init => Init_MPILayer PROCEDURE :: Free => Free_MPILayer PROCEDURE :: Finalize => Finalize_MPILayer PROCEDURE :: GenerateDecomposition => GenerateDecomposition_MPILayer PROCEDURE :: SetElemToRank PROCEDURE :: SetMaxMsg PROCEDURE , PUBLIC :: FinalizeMPIExchangeAsync GENERIC , PUBLIC :: GlobalReduce => GlobalReduce_RealScalar PROCEDURE , PRIVATE :: GlobalReduce_RealScalar END TYPE MPILayer TYPE :: SEMMesh INTEGER :: nGeo INTEGER :: nElem INTEGER :: nGlobalElem INTEGER :: nNodes INTEGER :: nSides INTEGER :: nCornerNodes INTEGER :: nUniqueNodes INTEGER :: nUniqueSides INTEGER :: nBCs INTEGER :: quadrature END TYPE SEMMesh TYPE , EXTENDS ( SEMMesh ) :: Mesh1D TYPE ( hfInt32_r2 ) :: elemInfo TYPE ( hfReal_r1 ) :: nodeCoords TYPE ( hfInt32_r1 ) :: globalNodeIDs TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh1D PROCEDURE , PUBLIC :: Free => Free_Mesh1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh1D PROCEDURE , PUBLIC :: UniformBlockMesh => UniformBlockMesh_Mesh1D PROCEDURE , PUBLIC :: Write_Mesh => Write_Mesh1D END TYPE Mesh1D ! Mesh format is set up similar to the HOPr format ! See https://hopr-project.org/externals/MeshFormat.pdf TYPE , EXTENDS ( SEMMesh ) :: Mesh2D TYPE ( hfInt32_r3 ) :: sideInfo TYPE ( hfReal_r4 ) :: nodeCoords TYPE ( hfInt32_r2 ) :: elemInfo TYPE ( hfInt32_r3 ) :: globalNodeIDs TYPE ( hfInt32_r2 ) :: CGNSCornerMap TYPE ( hfInt32_r2 ) :: CGNSSideMap TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh2D PROCEDURE , PUBLIC :: Free => Free_Mesh2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh2D PROCEDURE , PUBLIC :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh2D PROCEDURE , PUBLIC :: Read_HOPr => Read_HOPr_Mesh2D PROCEDURE , PUBLIC :: Write_Mesh => Write_Mesh2D PROCEDURE , PRIVATE :: RecalculateFlip => RecalculateFlip_Mesh2D END TYPE Mesh2D TYPE , EXTENDS ( SEMMesh ) :: Mesh3D TYPE ( hfInt32_r3 ) :: sideInfo TYPE ( hfReal_r5 ) :: nodeCoords TYPE ( hfInt32_r2 ) :: elemInfo TYPE ( hfInt32_r4 ) :: globalNodeIDs TYPE ( hfInt32_r2 ) :: CGNSCornerMap TYPE ( hfInt32_r2 ) :: CGNSSideMap TYPE ( hfInt32_r2 ) :: sideMap TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh3D PROCEDURE , PUBLIC :: Free => Free_Mesh3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh3D PROCEDURE , PUBLIC :: Read_HOPr => Read_HOPr_Mesh3D PROCEDURE , PUBLIC :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh3D PROCEDURE , PUBLIC :: Write_Mesh => Write_Mesh3D PROCEDURE , PRIVATE :: RecalculateFlip => RecalculateFlip_Mesh3D END TYPE Mesh3D CONTAINS SUBROUTINE Init_Mesh1D ( myMesh , nGeo , nElem , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs myMesh % nGeo = nGeo myMesh % nElem = nElem myMesh % nGlobalElem = nElem myMesh % nNodes = nNodes myMesh % nCornerNodes = nElem * 2 myMesh % nUniqueNodes = 0 myMesh % nBCs = nBCs CALL myMesh % elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nElem / )) CALL myMesh % nodeCoords % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % globalNodeIDs % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) END SUBROUTINE Init_Mesh1D SUBROUTINE Free_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nNodes = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % elemInfo % Free () CALL myMesh % nodeCoords % Free () CALL myMesh % globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh1D SUBROUTINE UpdateHost_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh CALL myMesh % elemInfo % UpdateHost () CALL myMesh % nodeCoords % UpdateHost () CALL myMesh % globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () END SUBROUTINE UpdateHost_Mesh1D SUBROUTINE UpdateDevice_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh CALL myMesh % elemInfo % UpdateDevice () CALL myMesh % nodeCoords % UpdateDevice () CALL myMesh % globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () END SUBROUTINE UpdateDevice_Mesh1D SUBROUTINE UniformBlockMesh_Mesh1D ( myMesh , nGeo , nElem , x ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem REAL ( prec ), INTENT ( in ) :: x ( 1 : 2 ) ! Local INTEGER :: iel INTEGER :: nid , nNodes INTEGER :: i REAL ( prec ) :: xU ( 1 : nElem + 1 ) TYPE ( Lagrange ), TARGET :: linearInterp TYPE ( Lagrange ), TARGET :: nGeoInterp TYPE ( Scalar1D ) :: xLinear TYPE ( Scalar1D ) :: xGeo nNodes = nElem * ( nGeo + 1 ) CALL myMesh % Init ( nGeo , nElem , nNodes , 2 ) myMesh % quadrature = GAUSS_LOBATTO ! Set the hopr_nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem + 1 ) CALL linearInterp % Init ( 1 , GAUSS_LOBATTO ,& nGeo , GAUSS_LOBATTO ) CALL nGeoInterp % Init ( nGeo , GAUSS_LOBATTO ,& nGeo , GAUSS_LOBATTO ) ! Create a linear interpolant to interpolate to nGeo grid CALL xLinear % Init ( linearInterp , 1 , nElem ) CALL xGeo % Init ( nGeoInterp , 1 , nElem ) DO iel = 1 , nElem xLinear % interior % hostData ( 0 : 1 , 1 , iel ) = xU ( iel : iel + 1 ) END DO CALL xLinear % GridInterp ( xGeo ,. FALSE .) ! Set the element information nid = 1 DO iel = 1 , nElem myMesh % elemInfo % hostData ( 1 , iel ) = selfLineLinear ! Element Type myMesh % elemInfo % hostData ( 2 , iel ) = 1 ! Element Zone myMesh % elemInfo % hostData ( 3 , iel ) = nid ! Node Index Start DO i = 0 , nGeo myMesh % nodeCoords % hostData ( nid ) = xGeo % interior % hostData ( i , 1 , iel ) nid = nid + 1 END DO myMesh % elemInfo % hostData ( 4 , iel ) = nid - 1 ! Node Index End END DO CALL myMesh % UpdateDevice () CALL xLinear % Free () CALL xGeo % Free () CALL linearInterp % Free () CALL nGeoInterp % Free () END SUBROUTINE UniformBlockMesh_Mesh1D SUBROUTINE Write_Mesh1D ( myMesh , meshFile ) ! Writes mesh output in HOPR format (serial IO only) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL WriteAttribute_HDF5 ( fileId , 'nElems' , myMesh % nElem ) CALL WriteAttribute_HDF5 ( fileId , 'Ngeo' , myMesh % nGeo ) CALL WriteAttribute_HDF5 ( fileId , 'nBCs' , myMesh % nBCs ) CALL WriteArray_HDF5 ( fileId , 'BCType' , myMesh % bcType ) ! Read local subarray of ElemInfo CALL WriteArray_HDF5 ( fileId , 'ElemInfo' , myMesh % elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs CALL WriteArray_HDF5 ( fileId , 'NodeCoords' , myMesh % nodeCoords ) CALL WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , myMesh % globalNodeIDs ) CALL Close_HDF5 ( fileID ) END SUBROUTINE Write_Mesh1D SUBROUTINE Init_Mesh2D ( myMesh , nGeo , nElem , nSides , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nSides INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs ! Local INTEGER :: i , j , l myMesh % nGeo = nGeo myMesh % nElem = nElem myMesh % nGlobalElem = nElem myMesh % nNodes = nNodes myMesh % nSides = nSides myMesh % nCornerNodes = 0 myMesh % nUniqueNodes = 0 myMesh % nUniqueSides = 0 myMesh % nBCs = nBCs CALL myMesh % elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nElem / )) CALL myMesh % sideInfo % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / 5 , 4 , nElem / )) CALL myMesh % nodeCoords % Alloc ( loBound = ( / 1 , 0 , 0 , 1 / ), & upBound = ( / 2 , nGeo , nGeo , nElem / )) CALL myMesh % globalNodeIDs % Alloc ( loBound = ( / 0 , 0 , 1 / ), & upBound = ( / nGeo , nGeo , nElem / )) CALL myMesh % CGNSCornerMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , 4 / )) CALL myMesh % CGNSSideMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , 4 / )) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation myMesh % CGNSCornerMap % hostData ( 1 : 2 , 1 ) = ( / 0 , 0 / ) myMesh % CGNSCornerMap % hostData ( 1 : 2 , 2 ) = ( / nGeo , 0 / ) myMesh % CGNSCornerMap % hostData ( 1 : 2 , 3 ) = ( / nGeo , nGeo / ) myMesh % CGNSCornerMap % hostData ( 1 : 2 , 4 ) = ( / 0 , nGeo / ) ! Maps from local corner node id to CGNS side myMesh % CGNSSideMap % hostData ( 1 : 2 , 1 ) = ( / 1 , 2 / ) myMesh % CGNSSideMap % hostData ( 1 : 2 , 2 ) = ( / 2 , 3 / ) myMesh % CGNSSideMap % hostData ( 1 : 2 , 3 ) = ( / 4 , 3 / ) myMesh % CGNSSideMap % hostData ( 1 : 2 , 4 ) = ( / 1 , 4 / ) END SUBROUTINE Init_Mesh2D SUBROUTINE Free_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nNodes = 0 myMesh % nSides = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % elemInfo % Free () CALL myMesh % sideInfo % Free () CALL myMesh % nodeCoords % Free () CALL myMesh % CGNSCornerMap % Free () CALL myMesh % globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh2D SUBROUTINE UpdateHost_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh CALL myMesh % elemInfo % UpdateHost () CALL myMesh % sideInfo % UpdateHost () CALL myMesh % nodeCoords % UpdateHost () CALL myMesh % globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () END SUBROUTINE UpdateHost_Mesh2D SUBROUTINE UpdateDevice_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh CALL myMesh % elemInfo % UpdateDevice () CALL myMesh % sideInfo % UpdateDevice () CALL myMesh % nodeCoords % UpdateDevice () CALL myMesh % globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () END SUBROUTINE UpdateDevice_Mesh2D SUBROUTINE ResetBoundaryConditionType_Mesh2D ( myMesh , bcid ) !! This method can be used to reset all of the boundary elements !! boundary condition type to the desired value. !! !! Note that ALL physical boundaries will be set to have this boundary !! condition IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh INTEGER , INTENT ( in ) :: bcid ! Local INTEGER :: iSide , iEl , e2 DO iEl = 1 , myMesh % nElem DO iSide = 1 , 4 e2 = myMesh % sideInfo % hostData ( 3 , iSide , iEl ) IF ( e2 == 0 ) THEN myMesh % sideInfo % hostData ( 5 , iSide , iEl ) = bcid ENDIF ENDDO ENDDO END SUBROUTINE ResetBoundaryConditionType_Mesh2D SUBROUTINE Read_HOPr_Mesh2D ( myMesh , meshFile , decomp ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 ! Adapted for 2D Mesh : Note that HOPR does not have 2D mesh output. IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile TYPE ( MPILayer ), INTENT ( inout ) :: decomp ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) INTEGER :: nGlobalElem INTEGER :: firstElem INTEGER :: firstNode INTEGER :: firstSide INTEGER :: nLocalElems INTEGER :: nLocalNodes3D INTEGER :: nLocalSides3D INTEGER :: nUniqueSides3D INTEGER :: nLocalNodes2D INTEGER :: nLocalSides2D INTEGER :: nUniqueSides2D INTEGER :: nGeo , nBCs INTEGER :: eid , lsid , iSide INTEGER :: i , j , nid TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType IF ( decomp % mpiEnabled ) THEN CALL Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId , decomp % mpiComm ) ELSE CALL Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId ) ENDIF CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) CALL ReadAttribute_HDF5 ( fileId , 'nUniqueSides' , nUniqueSides3D ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) IF ( decomp % mpiEnabled ) THEN offset (:) = 0 CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) ELSE CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType ) ENDIF ! Read local subarray of ElemInfo CALL decomp % GenerateDecomposition ( nGlobalElem , nUniqueSides3D ) firstElem = decomp % offsetElem % hostData ( decomp % rankId ) + 1 nLocalElems = decomp % offsetElem % hostData ( decomp % rankId + 1 ) - & decomp % offsetElem % hostData ( decomp % rankId ) ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nLocalElems / )) IF ( decomp % mpiEnabled ) THEN offset = ( / 0 , firstElem - 1 / ) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) ELSE CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) ENDIF ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo % hostData ( 5 , 1 ) + 1 nLocalNodes3D = hopr_elemInfo % hostData ( 6 , nLocalElems ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , nLocalNodes3D / )) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes3D ) IF ( decomp % mpiEnabled ) THEN offset = ( / 0 , firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) ELSE CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) ENDIF ! Read local subarray of SideInfo firstSide = hopr_elemInfo % hostData ( 3 , 1 ) + 1 nLocalSides3D = hopr_elemInfo % hostData ( 4 , nLocalElems ) - hopr_elemInfo % hostData ( 3 , 1 ) ! Allocate space for hopr_sideInfo CALL hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nLocalSides3D / )) IF ( decomp % mpiEnabled ) THEN offset = ( / 0 , firstSide - 1 / ) CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) ELSE CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) ENDIF CALL Close_HDF5 ( fileID ) ! ---- Done reading 3-D Mesh information ---- ! ! Now we need to convert from 3-D to 2-D ! nLocalSides2D = nLocalSides3D - 2 * nGlobalElem nUniqueSides2D = nUniqueSides3D - 2 * nGlobalElem ! Remove the \"top\" and \"bottom\" faces nLocalNodes2D = nLocalNodes2D - nGlobalElem * nGeo * ( nGeo + 1 ) ** 2 ! Remove the third dimension CALL myMesh % Init ( nGeo , nLocalElems , nLocalSides2D , nLocalNodes2D , nBCs ) ! Copy data from local arrays into myMesh !  elemInfo(1:6,iEl) !    1 - Element Type !    2 - Zone !    3 - offset index for side array (not needed when all quads are assumed) !    4 - last index for side array (not needed when all quads are assumed) !    5 - offset index for node array (not needed when all quads are assumed) !    6 - last index for node array (not needed when all quads are assumed) myMesh % elemInfo % hostData = hopr_elemInfo % hostData myMesh % quadrature = UNIFORM ! HOPr uses uniformly spaced points ! Grab the node coordinates (x and y only) from the \"bottom\" layer of the extruded mesh DO eid = 1 , myMesh % nElem DO j = 0 , nGeo DO i = 0 , nGeo nid = i + 1 + ( nGeo + 1 ) * ( j + ( nGeo + 1 ) * (( nGeo + 1 ) * ( eid - 1 ))) myMesh % nodeCoords % hostData ( 1 : 2 , i , j , eid ) = hopr_nodeCoords % hostData ( 1 : 2 , nid ) myMesh % globalNodeIDs % hostData ( i , j , eid ) = hopr_globalNodeIDs % hostData ( nid ) ENDDO ENDDO ENDDO ! Grab the south, west, north, and south sides of the elements !  sideInfo(1:5,iSide,iEl) ! !    1 - Side Type (currently unused in SELF) !    2 - Global Side ID (Used for message passing. Don't need to change) !    3 - Neighbor Element ID (Can stay the same) !    4 - 10*( neighbor local side )  + flip (Need to recalculate flip) !    5 - Boundary Condition ID (Can stay the same) DO eid = 1 , myMesh % nElem DO lsid = 1 , 4 ! Calculate the 3-D side ID from the 2-D local side id and element ID iSide = lsid + 1 + 6 * ( eid - 1 ) myMesh % sideInfo % hostData ( 1 : 5 , lsid , eid ) = hopr_sideInfo % hostData ( 1 : 5 , iSide ) ! Adjust the secondary side index for 2-D myMesh % sideInfo % hostData ( 4 , lsid , eid ) = myMesh % sideInfo % hostData ( 4 , lsid , eid ) - 10 ENDDO ENDDO CALL myMesh % RecalculateFlip () CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () CALL hopr_sideInfo % Free () END SUBROUTINE Read_HOPr_Mesh2D SUBROUTINE RecalculateFlip_Mesh2D ( myMesh , decomp ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh TYPE ( MPILayer ), INTENT ( inout ), OPTIONAL :: decomp ! Local INTEGER :: e1 INTEGER :: s1 INTEGER :: e2 INTEGER :: e2Global INTEGER :: s2 INTEGER :: flip INTEGER :: bcid INTEGER :: lnid1 ( 1 : 2 ) INTEGER :: lnid2 ( 1 : 2 ) INTEGER :: nid1 ( 1 : 2 , 1 : 4 , 1 : myMesh % nElem ) INTEGER :: nid2 ( 1 : 2 , 1 : 4 , 1 : myMesh % nElem ) INTEGER :: nloc1 ( 1 : 2 ) INTEGER :: nloc2 ( 1 : 2 ) INTEGER :: n1 INTEGER :: n1Global INTEGER :: n2 INTEGER :: n2Global INTEGER :: c1 INTEGER :: c2 INTEGER :: i , j INTEGER :: l INTEGER :: nShifts INTEGER :: neighborRank INTEGER :: rankId INTEGER :: offset INTEGER :: msgCount INTEGER :: globalSideId INTEGER , ALLOCATABLE :: requests (:) INTEGER , ALLOCATABLE :: stats (:,:) INTEGER :: iError LOGICAL :: theyMatch ALLOCATE ( requests ( 1 : myMesh % nSides * 2 )) ALLOCATE ( stats ( MPI_STATUS_SIZE , 1 : myMesh % nSides * 2 )) IF ( PRESENT ( decomp )) THEN rankId = decomp % rankId offset = decomp % offsetElem % hostData ( rankId ) ELSE rankId = 0 offset = 0 ENDIF msgCount = 0 DO e1 = 1 , myMesh % nElem DO s1 = 1 , 4 e2Global = myMesh % sideInfo % hostData ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = myMesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = myMesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = myMesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN IF ( PRESENT ( decomp )) THEN neighborRank = decomp % elemToRank % hostData ( e2Global ) ELSE neighborRank = 0 ENDIF IF ( neighborRank == rankId ) THEN lnid1 = myMesh % CGNSSideMap % hostData ( 1 : 2 , s1 ) ! local CGNS corner node ids for element 1 side lnid2 = myMesh % CGNSSideMap % hostData ( 1 : 2 , s2 ) ! local CGNS corner node ids for element 2 side DO l = 1 , 2 i = myMesh % CGNSCornerMap % hostData ( 1 , lnid1 ( l )) j = myMesh % CGNSCornerMap % hostData ( 2 , lnid1 ( l )) nid1 ( l , s1 , e1 ) = myMesh % globalNodeIDs % hostData ( i , j , e1 ) i = myMesh % CGNSCornerMap % hostData ( 1 , lnid2 ( l )) j = myMesh % CGNSCornerMap % hostData ( 2 , lnid2 ( l )) nid2 ( l , s1 , e1 ) = myMesh % globalNodeIDs % hostData ( i , j , e2 ) ENDDO ELSE ! In this case, we need to exchange globalSideId = ABS ( myMesh % sideInfo % hostdata ( 2 , s1 , e1 )) lnid1 = myMesh % CGNSSideMap % hostData ( 1 : 2 , s1 ) ! local CGNS corner node ids for element 1 side DO l = 1 , 2 i = myMesh % CGNSCornerMap % hostData ( 1 , lnid1 ( l )) j = myMesh % CGNSCornerMap % hostData ( 2 , lnid1 ( l )) nid1 ( l , s1 , e1 ) = myMesh % globalNodeIDs % hostData ( i , j , e1 ) msgCount = msgCount + 1 CALL MPI_IRECV ( nid2 ( l , s1 , e1 ), & 1 , & MPI_INTEGER , & neighborRank , globalSideId , & decomp % mpiComm , & requests ( msgCount ), iError ) ! Send nid1(l) from this rank to nid2(l) on the other rank msgCount = msgCount + 1 CALL MPI_ISEND ( nid1 ( l , s1 , e1 ), & 1 , & MPI_INTEGER , & neighborRank , globalSideId , & decomp % mpiComm , & requests ( msgCount ), iError ) ENDDO ENDIF ! MPI or not ENDIF ! If not physical boundary ENDDO ENDDO IF ( PRESENT ( decomp ) . AND . msgCount > 0 ) THEN CALL MPI_WaitAll ( msgCount , & requests ( 1 : msgCount ), & stats ( 1 : MPI_STATUS_SIZE , 1 : msgCount ), & iError ) ENDIF DO e1 = 1 , myMesh % nElem DO s1 = 1 , 4 s2 = myMesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 bcid = myMesh % sideInfo % hostData ( 5 , s1 , e1 ) nloc1 ( 1 : 2 ) = nid1 ( 1 : 2 , s1 , e1 ) nloc2 ( 1 : 2 ) = nid2 ( 1 : 2 , s1 , e1 ) IF ( bcid == 0 ) THEN theyMatch = CompareArray ( nloc1 , nloc2 , 2 ) IF ( theyMatch ) THEN myMesh % sideInfo % hostData ( 4 , s1 , e1 ) = 10 * s2 ELSE myMesh % sideInfo % hostData ( 4 , s1 , e1 ) = 10 * s2 + 1 ENDIF ENDIF ENDDO ENDDO DEALLOCATE ( requests ) DEALLOCATE ( stats ) END SUBROUTINE RecalculateFlip_Mesh2D SUBROUTINE Write_Mesh2D ( myMesh , meshFile ) ! Writes mesh output in HOPR format (serial only) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL WriteAttribute_HDF5 ( fileId , 'nElems' , myMesh % nElem ) CALL WriteAttribute_HDF5 ( fileId , 'Ngeo' , myMesh % nGeo ) CALL WriteAttribute_HDF5 ( fileId , 'nBCs' , myMesh % nBCs ) CALL WriteArray_HDF5 ( fileId , 'BCType' , myMesh % bcType ) ! Write local subarray of ElemInfo CALL WriteArray_HDF5 ( fileId , 'ElemInfo' , myMesh % elemInfo ) ! Write local subarray of NodeCoords and GlobalNodeIDs CALL WriteArray_HDF5 ( fileId , 'NodeCoords' , myMesh % nodeCoords ) CALL WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , myMesh % globalNodeIDs ) ! Write local subarray of SideInfo CALL WriteArray_HDF5 ( fileId , 'SideInfo' , myMesh % sideInfo ) CALL Close_HDF5 ( fileID ) END SUBROUTINE Write_Mesh2D SUBROUTINE Init_Mesh3D ( myMesh , nGeo , nElem , nSides , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nSides INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs ! Local INTEGER :: i , j , k , l myMesh % nElem = nElem myMesh % nGlobalElem = nElem myMesh % nGeo = nGeo myMesh % nSides = nSides myMesh % nNodes = nNodes myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = nBCs CALL myMesh % elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nElem / )) CALL myMesh % sideInfo % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / 5 , 6 , nElem / )) CALL myMesh % nodeCoords % Alloc ( loBound = ( / 1 , 0 , 0 , 0 , 1 / ), & upBound = ( / 3 , nGeo , nGeo , nGeo , nElem / )) CALL myMesh % globalNodeIDs % Alloc ( loBound = ( / 0 , 0 , 0 , 1 / ), & upBound = ( / nGeo , nGeo , nGeo , nElem / )) CALL myMesh % CGNSCornerMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , 8 / )) CALL myMesh % sideMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , 6 / )) CALL myMesh % CGNSSideMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , 6 / )) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation myMesh % CGNSCornerMap % hostData ( 1 : 3 , 1 ) = ( / 0 , 0 , 0 / ) ! Bottom-South-West myMesh % CGNSCornerMap % hostData ( 1 : 3 , 2 ) = ( / nGeo , 0 , 0 / ) ! Bottom-South-East myMesh % CGNSCornerMap % hostData ( 1 : 3 , 3 ) = ( / nGeo , nGeo , 0 / ) ! Bottom-North-East myMesh % CGNSCornerMap % hostData ( 1 : 3 , 4 ) = ( / 0 , nGeo , 0 / ) ! Bottom-North-West myMesh % CGNSCornerMap % hostData ( 1 : 3 , 5 ) = ( / 0 , 0 , nGeo / ) ! Top-South-West myMesh % CGNSCornerMap % hostData ( 1 : 3 , 6 ) = ( / nGeo , 0 , nGeo / ) ! Top-South-East myMesh % CGNSCornerMap % hostData ( 1 : 3 , 7 ) = ( / nGeo , nGeo , nGeo / ) ! Top-North-East myMesh % CGNSCornerMap % hostData ( 1 : 3 , 8 ) = ( / 0 , nGeo , nGeo / ) ! Top-North-West ! Maps from local corner node id to CGNS side myMesh % CGNSSideMap % hostData ( 1 : 4 , 1 ) = ( / 1 , 4 , 3 , 2 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 4 ) = ( / 3 , 4 , 8 , 7 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 5 ) = ( / 1 , 5 , 8 , 4 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) myMesh % sideMap % hostData ( 1 : 4 , 1 ) = ( / 1 , 2 , 3 , 4 / ) ! Bottom myMesh % sideMap % hostData ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) ! South myMesh % sideMap % hostData ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) ! East myMesh % sideMap % hostData ( 1 : 4 , 4 ) = ( / 4 , 3 , 7 , 8 / ) ! North myMesh % sideMap % hostData ( 1 : 4 , 5 ) = ( / 1 , 4 , 8 , 5 / ) ! West myMesh % sideMap % hostData ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) ! Top END SUBROUTINE Init_Mesh3D SUBROUTINE Free_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nSides = 0 myMesh % nNodes = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % elemInfo % Free () CALL myMesh % sideInfo % Free () CALL myMesh % nodeCoords % Free () CALL myMesh % CGNSCornerMap % Free () CALL myMesh % globalNodeIDs % Free () CALL myMesh % sideMap % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh3D SUBROUTINE UpdateHost_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh CALL myMesh % elemInfo % UpdateHost () CALL myMesh % sideInfo % UpdateHost () CALL myMesh % nodeCoords % UpdateHost () CALL myMesh % globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () END SUBROUTINE UpdateHost_Mesh3D SUBROUTINE UpdateDevice_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh CALL myMesh % elemInfo % UpdateDevice () CALL myMesh % sideInfo % UpdateDevice () CALL myMesh % nodeCoords % UpdateDevice () CALL myMesh % globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () END SUBROUTINE UpdateDevice_Mesh3D SUBROUTINE ResetBoundaryConditionType_Mesh3D ( myMesh , bcid ) !! This method can be used to reset all of the boundary elements !! boundary condition type to the desired value. !! !! Note that ALL physical boundaries will be set to have this boundary !! condition IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh INTEGER , INTENT ( in ) :: bcid ! Local INTEGER :: iSide , iEl , e2 DO iEl = 1 , myMesh % nElem DO iSide = 1 , 6 e2 = myMesh % sideInfo % hostData ( 3 , iSide , iEl ) IF ( e2 == 0 ) THEN myMesh % sideInfo % hostData ( 5 , iSide , iEl ) = bcid ENDIF ENDDO ENDDO END SUBROUTINE ResetBoundaryConditionType_Mesh3D SUBROUTINE RecalculateFlip_Mesh3D ( myMesh , decomp ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh TYPE ( MPILayer ), INTENT ( inout ), OPTIONAL :: decomp ! Local INTEGER :: e1 INTEGER :: s1 INTEGER :: e2 INTEGER :: e2Global INTEGER :: s2 INTEGER :: flip INTEGER :: bcid INTEGER :: lnid1 ( 1 : 4 ) INTEGER :: lnid2 ( 1 : 4 ) INTEGER :: nid1 ( 1 : 4 , 1 : 6 , 1 : myMesh % nElem ) INTEGER :: nid2 ( 1 : 4 , 1 : 6 , 1 : myMesh % nElem ) INTEGER :: nloc1 ( 1 : 4 ) INTEGER :: nloc2 ( 1 : 4 ) INTEGER :: n1 INTEGER :: n1Global INTEGER :: n2 INTEGER :: n2Global INTEGER :: c1 INTEGER :: c2 INTEGER :: i , j , k INTEGER :: l INTEGER :: nShifts INTEGER :: neighborRank INTEGER :: rankId INTEGER :: offset INTEGER :: msgCount INTEGER :: globalSideId INTEGER , ALLOCATABLE :: requests (:) INTEGER , ALLOCATABLE :: stats (:,:) INTEGER :: iError LOGICAL :: theyMatch ALLOCATE ( requests ( 1 : myMesh % nSides * 2 )) ALLOCATE ( stats ( MPI_STATUS_SIZE , 1 : myMesh % nSides * 2 )) IF ( PRESENT ( decomp )) THEN rankId = decomp % rankId offset = decomp % offsetElem % hostData ( rankId ) ELSE rankId = 0 offset = 0 ENDIF msgCount = 0 DO e1 = 1 , myMesh % nElem DO s1 = 1 , 6 e2Global = myMesh % sideInfo % hostData ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = myMesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = myMesh % sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = myMesh % sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN IF ( PRESENT ( decomp )) THEN neighborRank = decomp % elemToRank % hostData ( e2Global ) ELSE neighborRank = 0 ENDIF IF ( neighborRank == rankId ) THEN lnid1 = myMesh % sideMap % hostData ( 1 : 4 , s1 ) ! local CGNS corner node ids for element 1 side lnid2 = myMesh % sideMap % hostData ( 1 : 4 , s2 ) ! local CGNS corner node ids for element 2 side DO l = 1 , 4 i = myMesh % CGNSCornerMap % hostData ( 1 , lnid1 ( l )) j = myMesh % CGNSCornerMap % hostData ( 2 , lnid1 ( l )) k = myMesh % CGNSCornerMap % hostData ( 3 , lnid1 ( l )) nid1 ( l , s1 , e1 ) = myMesh % globalNodeIDs % hostData ( i , j , k , e1 ) i = myMesh % CGNSCornerMap % hostData ( 1 , lnid2 ( l )) j = myMesh % CGNSCornerMap % hostData ( 2 , lnid2 ( l )) k = myMesh % CGNSCornerMap % hostData ( 3 , lnid2 ( l )) nid2 ( l , s1 , e1 ) = myMesh % globalNodeIDs % hostData ( i , j , k , e1 ) ENDDO ELSE ! In this case, we need to exchange globalSideId = ABS ( myMesh % sideInfo % hostdata ( 2 , s1 , e1 )) lnid1 = myMesh % sideMap % hostData ( 1 : 4 , s1 ) ! local CGNS corner node ids for element 1 side DO l = 1 , 4 i = myMesh % CGNSCornerMap % hostData ( 1 , lnid1 ( l )) j = myMesh % CGNSCornerMap % hostData ( 2 , lnid1 ( l )) k = myMesh % CGNSCornerMap % hostData ( 3 , lnid1 ( l )) nid1 ( l , s1 , e1 ) = myMesh % globalNodeIDs % hostData ( i , j , k , e1 ) ! Receive nid2(l) on this rank from  nid1(l) on the other rank msgCount = msgCount + 1 CALL MPI_IRECV ( nid2 ( l , s1 , e1 ), & 1 , & MPI_INTEGER , & neighborRank , globalSideId , & decomp % mpiComm , & requests ( msgCount ), iError ) ! Send nid1(l) from this rank to nid2(l) on the other rank msgCount = msgCount + 1 CALL MPI_ISEND ( nid1 ( l , s1 , e1 ), & 1 , & MPI_INTEGER , & neighborRank , globalSideId , & decomp % mpiComm , & requests ( msgCount ), iError ) ENDDO ENDIF ! MPI or not ENDIF ! If not physical boundary ENDDO ENDDO IF ( PRESENT ( decomp ) . AND . msgCount > 0 ) THEN CALL MPI_WaitAll ( msgCount , & requests ( 1 : msgCount ), & stats ( 1 : MPI_STATUS_SIZE , 1 : msgCount ), & iError ) ENDIF DO e1 = 1 , myMesh % nElem DO s1 = 1 , 6 s2 = myMesh % sideInfo % hostData ( 4 , s1 , e1 ) / 10 bcid = myMesh % sideInfo % hostData ( 5 , s1 , e1 ) nloc1 ( 1 : 4 ) = nid1 ( 1 : 4 , s1 , e1 ) nloc2 ( 1 : 4 ) = nid2 ( 1 : 4 , s1 , e1 ) IF ( bcid == 0 ) THEN nShifts = 0 theyMatch = . FALSE . DO i = 1 , 4 theyMatch = CompareArray ( nloc1 , nloc2 , 4 ) IF ( theyMatch ) THEN EXIT ELSE nShifts = nShifts + 1 CALL ForwardShift ( nloc1 , 4 ) ENDIF ENDDO myMesh % sideInfo % hostData ( 4 , s1 , e1 ) = 10 * s2 + nShifts ENDIF ENDDO ENDDO DEALLOCATE ( requests ) DEALLOCATE ( stats ) END SUBROUTINE RecalculateFlip_Mesh3D SUBROUTINE Read_HOPr_Mesh3D ( myMesh , meshFile , decomp ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile TYPE ( MPILayer ), INTENT ( inout ) :: decomp ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) INTEGER :: nGlobalElem INTEGER :: firstElem INTEGER :: firstNode INTEGER :: firstSide INTEGER :: nLocalElems INTEGER :: nLocalNodes INTEGER :: nLocalSides INTEGER :: nUniqueSides INTEGER :: nGeo , nBCs INTEGER :: eid , lsid , iSide INTEGER :: i , j , k , nid TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType IF ( decomp % mpiEnabled ) THEN CALL Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId , decomp % mpiComm ) ELSE CALL Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId ) ENDIF CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) CALL ReadAttribute_HDF5 ( fileId , 'nUniqueSides' , nUniqueSides ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) IF ( decomp % mpiEnabled ) THEN offset (:) = 0 CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) ELSE CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType ) ENDIF ! Read local subarray of ElemInfo CALL decomp % GenerateDecomposition ( nGlobalElem , nUniqueSides ) firstElem = decomp % offsetElem % hostData ( decomp % rankId ) + 1 nLocalElems = decomp % offsetElem % hostData ( decomp % rankId + 1 ) - & decomp % offsetElem % hostData ( decomp % rankId ) ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nLocalElems / )) IF ( decomp % mpiEnabled ) THEN offset = ( / 0 , firstElem - 1 / ) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) ELSE CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) ENDIF ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo % hostData ( 5 , 1 ) + 1 nLocalNodes = hopr_elemInfo % hostData ( 6 , nLocalElems ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , nLocalNodes / )) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes ) IF ( decomp % mpiEnabled ) THEN offset = ( / 0 , firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) ELSE CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) ENDIF ! Read local subarray of SideInfo firstSide = hopr_elemInfo % hostData ( 3 , 1 ) + 1 nLocalSides = hopr_elemInfo % hostData ( 4 , nLocalElems ) - hopr_elemInfo % hostData ( 3 , 1 ) ! Allocate space for hopr_sideInfo CALL hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nLocalSides / )) IF ( decomp % mpiEnabled ) THEN offset = ( / 0 , firstSide - 1 / ) CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) ELSE CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) ENDIF CALL Close_HDF5 ( fileID ) ! ---- Done reading 3-D Mesh information ---- ! ! Load hopr data into mesh data structure CALL myMesh % Init ( nGeo , nLocalElems , nLocalSides , nLocalNodes , nBCs ) ! Copy data from local arrays into myMesh myMesh % elemInfo % hostData = hopr_elemInfo % hostData myMesh % nUniqueSides = nUniqueSides myMesh % quadrature = UNIFORM ! Grab the node coordinates DO eid = 1 , myMesh % nElem DO k = 0 , nGeo DO j = 0 , nGeo DO i = 0 , nGeo nid = i + 1 + ( nGeo + 1 ) * ( j + ( nGeo + 1 ) * ( k + ( nGeo + 1 ) * ( eid - 1 ))) myMesh % nodeCoords % hostData ( 1 : 3 , i , j , k , eid ) = hopr_nodeCoords % hostData ( 1 : 3 , nid ) myMesh % globalNodeIDs % hostData ( i , j , k , eid ) = hopr_globalNodeIDs % hostData ( nid ) ENDDO ENDDO ENDDO ENDDO iSide = 0 DO eid = 1 , myMesh % nElem DO lsid = 1 , 6 iSide = iSide + 1 myMesh % sideInfo % hostData ( 1 : 5 , lsid , eid ) = hopr_sideInfo % hostData ( 1 : 5 , iSide ) ENDDO ENDDO CALL myMesh % RecalculateFlip () CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () CALL hopr_sideInfo % Free () END SUBROUTINE Read_HOPr_Mesh3D SUBROUTINE Write_Mesh3D ( myMesh , meshFile ) ! Writes mesh output in HOPR format (serial only) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL WriteAttribute_HDF5 ( fileId , 'nElems' , myMesh % nElem ) CALL WriteAttribute_HDF5 ( fileId , 'Ngeo' , myMesh % nGeo ) CALL WriteAttribute_HDF5 ( fileId , 'nBCs' , myMesh % nBCs ) CALL WriteArray_HDF5 ( fileId , 'BCType' , myMesh % bcType ) CALL WriteArray_HDF5 ( fileId , 'ElemInfo' , myMesh % elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs CALL WriteArray_HDF5 ( fileId , 'NodeCoords' , myMesh % nodeCoords ) CALL WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , myMesh % globalNodeIDs ) ! Read local subarray of SideInfo CALL WriteArray_HDF5 ( fileId , 'SideInfo' , myMesh % sideInfo ) CALL Close_HDF5 ( fileID ) END SUBROUTINE Write_Mesh3D !  FUNCTION TransfiniteInterpolation_2D( interp, bCurves, iEl, a, b ) RESULT( P ) !    ! TransfiniteInterpolation !    !  Takes in the six surfaces (south, east, north, west, bottom, top) and evaluates the !    !  bidirectional mapping at xi&#94;1 = a, xi&#94;2 = b, xi&#94;3 = c. The boundary of the computational !    !  coordinate system is assumed to be at +/- 1 in each direction. !    ! !    ! =============================================================================================== ! !    ! DECLARATIONS !    IMPLICIT NONE !    REAL(prec) :: bCurves(1:2,1:4) !    INTEGER :: i,j !    REAL(prec) :: P(1:2) !    ! LOCAL !    REAL(prec)  :: P1(1:2), P2(1:2), P2(1:2) !    REAL(prec)  :: sSurf(1:2), nSurf(1:2), eSurf(1:2), wSurf(1:2) !    REAL(prec)  :: l1(1:2), l2(1:2), l2(1:2) !    REAL(prec)  :: ref(1:2) !    INTEGER     :: i, j, iSurf ! !    ref = (/ -1.0_prec, 1.0_prec /) ! !    ! Transfinite interpolation with linear blending USEs linear lagrange interpolating polynomials !    ! to blend the bounding surfaces. !    ! The linear blending weights in the first computational direction are calculated. ! !    l1 = LinearBlend(a) !    l2 = LinearBlend(b) !    l3 = LinearBlend(c) ! !    ! The bounding surfaces need to be evaluated at the provided computational coordinates ! !    wSurf = bCurves(1:2,4) !    eSurf = bCurves(1:2,2) !    sSurf = bCurves(1:2,1) !    nSurf = bCurves(1:2,3) ! !    ! P1 CONTAINS the interpolation in the first computational coordinate !    ! The first computational coordinate is assumed to vary between the (computational) east and !    ! west boundaries. ! !    P1 = l1(1)*wSurf + l1(2)*eSurf ! !    ! P2 CONTAINS the interpolation in the second computational coordinate !    ! The second computational coordinate is assumed to vary between the (computational) south and !    ! north boundaries. ! !    P2 = l2(1)*sSurf + l2(2)*nSurf ! !    ! P3 CONTAINS the interpolation in the first computational coordinate !    ! The first computational coordinate is assumed to vary between the (computational) bottom and !    ! top boundaries. ! !    P3 = l3(1)*bSurf + l3(2)*tSurf ! !    DO i = 1, 2 ! !      ! Now we need to compute the tensor product of the first and second computational direction !      ! interpolants and subtract from P1. ! !      wSurf = boundingsurfaces % Evaluate( (/ref(i), c/), west + (iEl-1)*6 ) !      eSurf = boundingsurfaces % Evaluate( (/ref(i), c/), east + (iEl-1)*6 ) !      P1 = P1 - l2(i)*( wSurf*l1(1) + eSurf*l1(2) ) ! !      ! Now we need to compute the tensor product of the first and third computational direction !      ! interpolants and subtract from P1. ! !      wSurf = boundingsurfaces % Evaluate( (/b, ref(i)/), west + (iEl-1)*6 ) !      eSurf = boundingsurfaces % Evaluate( (/b, ref(i)/), east + (iEl-1)*6 ) ! !      P1 = P1 - l3(i)*( wSurf*l1(1) + eSurf*l1(2) ) ! !      ! Now we need to compute the tensor product of the second and third computational direction !      ! interpolants and subtract from P2. ! !      sSurf = boundingsurfaces % Evaluate( (/a, ref(i)/), south + (iEl-1)*6 ) !      nSurf = boundingsurfaces % Evaluate( (/a, ref(i)/), north + (iEl-1)*6 ) ! !      P2 = P2 - l3(i)*( sSurf*l2(1) + nSurf*l2(2) ) ! !    ENDDO ! !    ! Next, the compounded tensor product is computed and added to P3. !    DO j = 1,2 !      DO i = 1,2 ! !        wSurf = boundingsurfaces % Evaluate( (/ref(i), ref(j)/), west + (iEl-1)*6 ) !        eSurf = boundingsurfaces % Evaluate( (/ref(i), ref(j)/), east + (iEl-1)*6 ) !        P3 = P3 + l2(i)*l3(j)*( wSurf*l1(1) + eSurf*l1(2) ) ! !      ENDDO !    ENDDO ! !    !Finally, the sum the interpolants is computed to yield the computational coordinate !    P = P1 + P2 + P3 ! !  END FUNCTION TransfiniteInterpolation_2D !  FUNCTION TransfiniteInterpolation( boundingSurfaces, iEl, a, b, c ) RESULT( P ) !    ! TransfiniteInterpolation !    !  Takes in the six surfaces (south, east, north, west, bottom, top) and evaluates the !    !  bidirectional mapping at xi&#94;1 = a, xi&#94;2 = b, xi&#94;3 = c. The boundary of the computational !    !  coordinate system is assumed to be at +/- 1 in each direction. !    ! !    ! =============================================================================================== ! !    ! DECLARATIONS !    IMPLICIT NONE !    TYPE( Surfaces )  :: boundingSurfaces !    INTEGER           :: iEl !    REAL(prec)       :: a, b, c !    REAL(prec)       :: P(1:3) !    ! LOCAL !    REAL(prec)  :: P1(1:3), P2(1:3), P3(1:3) !    REAL(prec)  :: sSurf(1:3), nSurf(1:3), eSurf(1:3), wSurf(1:3), bSurf(1:3), tSurf(1:3) !    REAL(prec)  :: l1(1:2), l2(1:2), l3(1:2) !    REAL(prec)  :: ref(1:2) !    INTEGER     :: i, j, iSurf ! !    ref = (/ -1.0_prec, 1.0_prec /) ! !    ! Transfinite interpolation with linear blending USEs linear lagrange interpolating polynomials !    ! to blend the bounding surfaces. !    ! The linear blending weights in the first computational direction are calculated. ! !    l1 = LinearBlend( a ) !    l2 = LinearBlend( b ) !    l3 = LinearBlend( c ) ! !    ! The bounding surfaces need to be evaluated at the provided computational coordinates ! !    wSurf = boundingSurfaces % Evaluate( (/b, c/), west + (iEl-1)*6 )   ! west !    eSurf = boundingSurfaces % Evaluate( (/b, c/), east + (iEl-1)*6 )   ! east !    sSurf = boundingSurfaces % Evaluate( (/a, c/), south + (iEl-1)*6 )  ! south !    nSurf = boundingSurfaces % Evaluate( (/a, c/), north + (iEl-1)*6 )  ! north !    bSurf = boundingSurfaces % Evaluate( (/a, b/), bottom + (iEl-1)*6 ) ! bottom !    tSurf = boundingSurfaces % Evaluate( (/a, b/), top + (iEl-1)*6 )    ! top ! !    ! P1 CONTAINS the interpolation in the first computational coordinate !    ! The first computational coordinate is assumed to vary between the (computational) east and !    ! west boundaries. ! !    P1 = l1(1)*wSurf + l1(2)*eSurf ! !    ! P2 CONTAINS the interpolation in the second computational coordinate !    ! The second computational coordinate is assumed to vary between the (computational) south and !    ! north boundaries. ! !    P2 = l2(1)*sSurf + l2(2)*nSurf ! !    ! P3 CONTAINS the interpolation in the first computational coordinate !    ! The first computational coordinate is assumed to vary between the (computational) bottom and !    ! top boundaries. ! !    P3 = l3(1)*bSurf + l3(2)*tSurf ! !    DO i = 1, 2 ! !      ! Now we need to compute the tensor product of the first and second computational direction !      ! interpolants and subtract from P1. ! !      wSurf = boundingsurfaces % Evaluate( (/ref(i), c/), west + (iEl-1)*6 ) !      eSurf = boundingsurfaces % Evaluate( (/ref(i), c/), east + (iEl-1)*6 ) !      P1 = P1 - l2(i)*( wSurf*l1(1) + eSurf*l1(2) ) ! !      ! Now we need to compute the tensor product of the first and third computational direction !      ! interpolants and subtract from P1. ! !      wSurf = boundingsurfaces % Evaluate( (/b, ref(i)/), west + (iEl-1)*6 ) !      eSurf = boundingsurfaces % Evaluate( (/b, ref(i)/), east + (iEl-1)*6 ) ! !      P1 = P1 - l3(i)*( wSurf*l1(1) + eSurf*l1(2) ) ! !      ! Now we need to compute the tensor product of the second and third computational direction !      ! interpolants and subtract from P2. ! !      sSurf = boundingsurfaces % Evaluate( (/a, ref(i)/), south + (iEl-1)*6 ) !      nSurf = boundingsurfaces % Evaluate( (/a, ref(i)/), north + (iEl-1)*6 ) ! !      P2 = P2 - l3(i)*( sSurf*l2(1) + nSurf*l2(2) ) ! !    ENDDO ! !    ! Next, the compounded tensor product is computed and added to P3. !    DO j = 1,2 !      DO i = 1,2 ! !        wSurf = boundingsurfaces % Evaluate( (/ref(i), ref(j)/), west + (iEl-1)*6 ) !        eSurf = boundingsurfaces % Evaluate( (/ref(i), ref(j)/), east + (iEl-1)*6 ) !        P3 = P3 + l2(i)*l3(j)*( wSurf*l1(1) + eSurf*l1(2) ) ! !      ENDDO !    ENDDO ! !    !Finally, the sum the interpolants is computed to yield the computational coordinate !    P = P1 + P2 + P3 ! !  END FUNCTION TransfiniteInterpolation ! FUNCTION Unidirectional(valLeft,valRight,a) RESULT(P) !   ! !   ! =============================================================================================== ! !   ! DECLARATIONS !   IMPLICIT NONE !   REAL(prec) :: valLeft(1:3),valRight(1:3) !   REAL(prec) :: a !   REAL(prec) :: P(1:3) !   P = 0.5_prec*((1.0_prec - a)*valLeft + (1.0_prec + a)*valRight) ! END FUNCTION Unidirectional ! FUNCTION LinearBlend(a) RESULT(weights) !   IMPLICIT NONE !   REAL(prec) :: a !   REAL(prec) :: weights(1:2) !   weights(1) = 0.5_prec*(1.0_prec - a) !   weights(2) = 0.5_prec*(1.0_prec + a) ! END FUNCTION LinearBlend SUBROUTINE Init_MPILayer ( this , enableMPI ) #undef __FUNC__ #define __FUNC__ \"Init_MPILayer\" IMPLICIT NONE CLASS ( MPILayer ), INTENT ( out ) :: this LOGICAL , INTENT ( in ) :: enableMPI ! Local INTEGER :: ierror CHARACTER ( 50 ) :: msg INTEGER :: nGPU , gpuID CHARACTER ( 2 ) :: msg2 this % mpiComm = 0 this % mpiPrec = prec this % rankId = 0 this % nRanks = 1 this % nElem = 0 this % mpiEnabled = enableMPI IF ( enableMPI ) THEN this % mpiComm = MPI_COMM_WORLD CALL MPI_INIT ( ierror ) CALL MPI_COMM_RANK ( this % mpiComm , this % rankId , ierror ) CALL MPI_COMM_SIZE ( this % mpiComm , this % nRanks , ierror ) END IF IF ( prec == real32 ) THEN this % mpiPrec = MPI_FLOAT ELSE this % mpiPrec = MPI_DOUBLE END IF CALL this % offSetElem % Alloc ( 0 , this % nRanks ) WRITE ( msg , '(I5)' ) this % rankId msg = \"Greetings from rank \" // TRIM ( msg ) // \".\" INFO ( TRIM ( msg )) IF ( GPUAvailable () ) THEN ! Get the number of GPUs per node CALL hipCheck ( hipGetDeviceCount ( nGPU )) ! Assume that we have the 1 GPU per rank ! implying that nMPIRanksPerNode = nGPU ! Assume that all nodes have the same number of GPUs per node gpuID = MOD ( this % rankId , nGPU ) CALL hipCheck ( hipSetDevice ( gpuID )) WRITE ( msg , '(I5)' ) this % rankId WRITE ( msg2 , '(I2)' ) gpuID msg = \"Rank \" // TRIM ( msg ) // \": Setting device to GPU\" // TRIM ( msg2 ) INFO ( TRIM ( msg )) ENDIF END SUBROUTINE Init_MPILayer SUBROUTINE Free_MPILayer ( this ) IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this IF ( ASSOCIATED ( this % offSetElem % hostData )) THEN CALL this % offSetElem % Free () ENDIF IF ( ASSOCIATED ( this % elemToRank % hostData )) THEN CALL this % elemToRank % Free () ENDIF DEALLOCATE ( this % requests ) DEALLOCATE ( this % stats ) END SUBROUTINE Free_MPILayer SUBROUTINE Finalize_MPILayer ( this ) #undef __FUNC__ #define __FUNC__ \"Finalize_MPILayer\" IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this ! Local INTEGER :: ierror CHARACTER ( 30 ) :: msg IF ( this % mpiEnabled ) THEN WRITE ( msg , '(I5)' ) this % rankId msg = \"Goodbye from rank \" // TRIM ( msg ) // \".\" INFO ( TRIM ( msg )) CALL MPI_FINALIZE ( ierror ) ENDIF END SUBROUTINE Finalize_MPILayer SUBROUTINE GenerateDecomposition_MPILayer ( this , nGlobalElem , maxMsg ) #undef __FUNC__ #define __FUNC__ \"GenerateDecomposition_MPILayer\" IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: nGlobalElem INTEGER , INTENT ( in ) :: maxMsg ! Local INTEGER :: maxMsgLoc CHARACTER ( 50 ) :: msg CHARACTER ( 5 ) :: msg2 CALL this % setElemToRank ( nGlobalElem ) CALL this % SetMaxMsg ( maxMsg ) WRITE ( msg , '(I5)' ) this % rankId WRITE ( msg2 , '(I5)' ) this % offSetElem % hostData ( this % rankId + 1 ) - & this % offSetElem % hostData ( this % rankId ) msg = \"Rank \" // TRIM ( msg ) // \": nElem = \" // TRIM ( msg2 ) INFO ( TRIM ( msg )) END SUBROUTINE GenerateDecomposition_MPILayer SUBROUTINE SetMaxMsg ( this , maxMsg ) IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: maxMsg IF ( ALLOCATED ( this % requests ) ) DEALLOCATE ( this % requests ) IF ( ALLOCATED ( this % stats ) ) DEALLOCATE ( this % stats ) ALLOCATE ( this % requests ( 1 : maxMsg ) ) ALLOCATE ( this % stats ( MPI_STATUS_SIZE , 1 : maxMsg ) ) this % maxMsg = maxMsg END SUBROUTINE SetMaxMsg SUBROUTINE SetElemToRank ( this , nElem ) IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: nElem ! Local INTEGER :: iel this % nElem = nElem CALL this % elemToRank % Alloc ( 1 , nElem ) CALL DomainDecomp ( nElem , & this % nRanks , & this % offSetElem % hostData ) DO iel = 1 , nElem CALL ElemToRank ( this % nRanks , & this % offSetElem % hostData , & iel , & this % elemToRank % hostData ( iel )) END DO CALL this % offSetElem % UpdateDevice () CALL this % elemToRank % UpdateDevice () END SUBROUTINE SetElemToRank SUBROUTINE DomainDecomp ( nElems , nDomains , offSetElem ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 4 IMPLICIT NONE INTEGER , INTENT ( in ) :: nElems INTEGER , INTENT ( in ) :: nDomains INTEGER , INTENT ( out ) :: offsetElem ( 0 : nDomains ) ! Local INTEGER :: nLocalElems INTEGER :: remainElems INTEGER :: iDom nLocalElems = nElems / nDomains remainElems = nElems - nLocalElems * nDomains DO iDom = 0 , nDomains - 1 offSetElem ( iDom ) = iDom * nLocalElems + MIN ( iDom , remainElems ) END DO offSetElem ( nDomains ) = nElems END SUBROUTINE DomainDecomp SUBROUTINE ElemToRank ( nDomains , offsetElem , elemID , domain ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 7 !   \"Find domain containing element index\" ! IMPLICIT NONE INTEGER , INTENT ( in ) :: nDomains INTEGER , INTENT ( in ) :: offsetElem ( 0 : nDomains ) INTEGER , INTENT ( in ) :: elemID INTEGER , INTENT ( out ) :: domain ! Local INTEGER :: maxSteps INTEGER :: low , up , mid INTEGER :: i domain = 0 maxSteps = INT ( LOG10 ( REAL ( nDomains )) / LOG10 ( 2.0 )) + 1 low = 0 up = nDomains - 1 IF ( offsetElem ( low ) < elemID . AND . elemID <= offsetElem ( low + 1 )) THEN domain = low ELSEIF ( offsetElem ( up ) < elemID . AND . elemID <= offsetElem ( up + 1 )) THEN domain = up ELSE DO i = 1 , maxSteps mid = ( up - low ) / 2 + low IF ( offsetElem ( mid ) < elemID . AND . elemID <= offsetElem ( mid + 1 )) THEN domain = mid RETURN ELSEIF ( elemID > offsetElem ( mid + 1 )) THEN low = mid + 1 ELSE up = mid END IF END DO END IF END SUBROUTINE ElemToRank SUBROUTINE FinalizeMPIExchangeAsync ( mpiHandler ) CLASS ( MPILayer ), INTENT ( inout ) :: mpiHandler ! Local INTEGER :: ierror IF ( mpiHandler % mpiEnabled ) THEN CALL MPI_WaitAll ( mpiHandler % msgCount , & mpiHandler % requests ( 1 : mpiHandler % msgCount ), & mpiHandler % stats ( 1 : MPI_STATUS_SIZE , 1 : mpiHandler % msgCount ), & iError ) ENDIF END SUBROUTINE FinalizeMPIExchangeAsync SUBROUTINE GlobalReduce_RealScalar ( mpiHandler , sendBuf , recvBuf ) CLASS ( MPILayer ), INTENT ( in ) :: mpiHandler REAL ( prec ), INTENT ( in ) :: sendBuf REAL ( prec ), INTENT ( out ) :: recvBuf ! Local INTEGER :: iError IF ( mpiHandler % mpiEnabled ) THEN CALL MPI_ALLREDUCE ( sendBuf , & recvBuf , & 1 , & mpiHandler % mpiPrec , & MPI_SUM , & mpiHandler % mpiComm , & iError ) ELSE recvBuf = sendBuf ENDIF END SUBROUTINE GlobalReduce_RealScalar END MODULE SELF_Mesh","tags":"","loc":"sourcefile/self_mesh.f90.html"},{"title":"test.f90 – SELF","text":"Contents Source Code test.f90 Source Code","tags":"","loc":"sourcefile/test.f90.html"},{"title":"SELF_Quadrature.f90 – SELF","text":"Contents Modules SELF_Quadrature Source Code SELF_Quadrature.f90 Source Code ! SELF_Quadrature.f90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Contains routines from D.A. Kopriva, 2009, \"Implementing Spectral Methods for Partial ! Differential Equations: Algorithms for Scientists and Engineers\", Springer. ! ! Routines are defined for computing Legendre and Chebyshev Gauss and Gauss-Lobatto ! quadrature nodes and weights. MODULE SELF_Quadrature USE ISO_FORTRAN_ENV USE SELF_Constants IMPLICIT NONE PUBLIC :: ChebyshevQuadrature , LegendreQuadrature PRIVATE :: ChebyshevGauss , ChebyshevGaussLobatto , & LegendreGauss , LegendreGaussLobatto , & LegendreQandL CONTAINS ! =============================================================================================== ! ! LegendreQuadrature !   Returns the specified Legendre quadrature nodes and integration weights. ! !   Given a polynomial degree, and quadrature type (Gauss or Gauss Lobatto), this subroutine manages !   the calls to underlying private routines to generate the desired Legendre quadrature. ! !   Usage : ! !     INTEGER    :: N, quadType !     REAL(real64) :: nodes(0:N), weights(0:N) ! !       CALL LegendreQuadrature( N, quadType, nodes, weights ) ! !   Parameters : ! !     N (in) !       Degree of the quadrature ! !     quadType (in) !       Flag specifying the quadrature type. Can be set to GAUSS or GAUSS_LOBATTO ! !     nodes(0:N) (out) !       Array of quadrature nodes ! !     weights(0:N) (out) !       Array of quadrature weights ! ! =============================================================================================== ! SUBROUTINE LegendreQuadrature ( N , nodes , weights , QuadType ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N REAL ( prec ), INTENT ( out ) :: nodes ( 0 : N ) REAL ( prec ), INTENT ( out ) :: weights ( 0 : N ) INTEGER , INTENT ( in ) :: QuadType ! Local REAL ( real64 ) :: nodesLocal ( 0 : N ) REAL ( real64 ) :: weightsLocal ( 0 : N ) INTEGER :: i IF ( QuadType == GAUSS_LOBATTO ) THEN CALL LegendreGaussLobatto ( N , nodesLocal , weightsLocal ) ELSEIF ( QuadType == GAUSS ) THEN CALL LegendreGauss ( N , nodesLocal , weightsLocal ) END IF DO i = 0 , N nodes ( i ) = REAL ( nodesLocal ( i ), prec ) weights ( i ) = REAL ( weightsLocal ( i ), prec ) END DO END SUBROUTINE LegendreQuadrature ! =============================================================================================== ! ! ChebyshevQuadrature ! !   Returns the specified Chebyshev quadrature nodes and integration weights. ! !   Given a polynomial degree, and quadrature type (Gauss or Gauss Lobatto), this subroutine manages !   the calls to underlying private routines to generate the desired Chebyshev quadrature. ! !   Usage : ! !     INTEGER    :: N, quadType !     REAL(real64) :: nodes(0:N), weights(0:N) ! !       CALL ChebyshevQuadrature( N, quadType, nodes, weights ) ! !   Input/Output : ! !     N (in) !       Degree of the quadrature ! !     quadType (in) !       Flag specifying the quadrature type. Can be set to GAUSS or GAUSS_LOBATTO ! !     nodes(0:N) (out) !       Array of quadrature nodes ! !     weights(0:N) (out) !       Array of quadrature weights ! ! ================================================================================================ ! SUBROUTINE ChebyshevQuadrature ( N , nodes , weights , quadType ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N REAL ( prec ), INTENT ( out ) :: nodes ( 0 : N ) REAL ( prec ), INTENT ( out ) :: weights ( 0 : N ) INTEGER , INTENT ( in ) :: QuadType ! Local REAL ( real64 ) :: nodesLocal ( 0 : N ) REAL ( real64 ) :: weightsLocal ( 0 : N ) INTEGER :: i IF ( QuadType == CHEBYSHEV_GAUSS_LOBATTO ) then CALL ChebyshevGaussLobatto ( N , nodesLocal , weightsLocal ) ELSEIF ( QuadType == CHEBYSHEV_GAUSS ) then CALL ChebyshevGauss ( N , nodesLocal , weightsLocal ) END IF DO i = 0 , N nodes ( i ) = REAL ( nodesLocal ( i ), prec ) weights ( i ) = REAL ( weightsLocal ( i ), prec ) END DO END SUBROUTINE ChebyshevQuadrature ! =============================================================================================== ! ! S/R ChebyshevGauss !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 67 !   Algorithm 26 ! =============================================================================================== ! SUBROUTINE ChebyshevGauss ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local INTEGER :: j DO j = 0 , N weights ( j ) = pi / ( REAL ( N , real64 ) + 1.0_real64 ) nodes ( j ) = - cos ( pi * ( 2.0_real64 * REAL ( j , real64 ) + 1.0_real64 ) / ( 2.0_real64 * REAL ( N , real64 ) + 2.0_real64 )) END DO END SUBROUTINE ChebyshevGauss ! =============================================================================================== ! ! S/R ChebyshevGaussLobatto !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 68 !   Algorithm 27 ! =============================================================================================== ! SUBROUTINE ChebyshevGaussLobatto ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! LOCAL INTEGER :: j DO j = 0 , N weights ( j ) = pi / REAL ( N , real64 ) nodes ( j ) = - cos ( pi * REAL ( j , real64 ) / REAL ( N , real64 )) END DO weights ( 0 ) = weights ( 0 ) * 0.5_real64 weights ( N ) = weights ( N ) * 0.5_real64 END SUBROUTINE ChebyshevGaussLobatto ! =============================================================================================== ! ! S/R LegendreGauss !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 64 !   Algorithm 23 ! =============================================================================================== ! SUBROUTINE LegendreGauss ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local REAL ( real64 ) :: nodes_local ( 0 : N ) REAL ( real64 ) :: weights_local ( 0 : N ) REAL ( real64 ) :: lN1 , dlN1 REAL ( real64 ) :: delta INTEGER :: j , kIt IF ( N == 0 ) then nodes_local ( 0 ) = 0.0_real64 weights_local ( 0 ) = 2.0_real64 ELSEIF ( N == 1 ) then nodes_local ( 0 ) = - SQRT ( 1.0_real64 / 3.0_real64 ) weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = - nodes ( 0 ) weights_local ( 1 ) = weights ( 0 ) ELSE DO j = 0 , (( N + 1 ) / 2 ) nodes_local ( j ) = - cos (( 2.0_real64 * REAL ( j , real64 ) + 1.0_real64 ) * pi / ( 2.0_real64 * REAL ( N , real64 ) + 1.0_real64 )) DO kIt = 1 , newtonMax CALL LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) delta = - lN1 / dlN1 nodes_local ( j ) = nodes_local ( j ) + delta IF ( abs ( delta ) <= TOL * nodes_local ( j )) EXIT END DO CALL LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) weights_local ( j ) = 2.0_real64 / (( 1.0_real64 - nodes_local ( j ) * nodes_local ( j )) * dlN1 * dlN1 ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) END DO END IF IF ( MOD ( REAL ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) then CALL LegendrePolynomial ( N + 1 , 0.0_real64 , lN1 , dlN1 ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0 / ( dlN1 * dlN1 ) END IF DO j = 0 , N nodes ( j ) = REAL ( nodes_local ( j ), real64 ) weights ( j ) = REAL ( weights_local ( j ), real64 ) END DO END SUBROUTINE LegendreGauss ! =============================================================================================== ! ! S/R LegendreGaussLobatto !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 66 !   Algorithm 25 ! =============================================================================================== ! SUBROUTINE LegendreGaussLobatto ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local REAL ( real64 ) :: nodes_local ( 0 : N ) REAL ( real64 ) :: weights_local ( 0 : N ) REAL ( real64 ) :: delta , q , qprime , lN INTEGER :: j , kIt IF ( N == 1 ) then nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = 1.0_real64 weights_local ( 1 ) = 1.0_real64 ELSE nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 )) nodes_local ( N ) = 1.0_real64 weights_local ( N ) = weights_local ( 0 ) DO j = 1 , (( N + 1 ) / 2 - 1 ) nodes_local ( j ) = - COS (( REAL ( j , real64 ) + 0.25_real64 ) * pi / REAL ( N , real64 ) - & 3.0_real64 / ( 8.0_real64 * REAL ( N , real64 ) * pi * ( REAL ( j , real64 ) + 0.25_real64 ))) DO kIt = 1 , newtonMax CALL LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) delta = - q / qprime nodes_local ( j ) = nodes_local ( j ) + delta IF ( ABS ( delta ) <= TOL * nodes_local ( j )) EXIT END DO CALL LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) weights_local ( j ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 ) * lN * lN ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) END DO END IF IF ( MOD ( REAL ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) THEN CALL LegendreQandL ( N , 0.0_real64 , q , qprime , lN ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 ) * lN * lN ) END IF DO j = 0 , N nodes ( j ) = REAL ( nodes_local ( j ), real64 ) weights ( j ) = REAL ( weights_local ( j ), real64 ) END DO END SUBROUTINE LegendreGaussLobatto ! =============================================================================================== ! ! S/R LegendrePolynomial !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 63 !   Algorithm 22 ! =============================================================================================== ! SUBROUTINE LegendrePolynomial ( N , x , lAtX , dLdxAtX ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: x REAL ( real64 ) :: lAtX , dLdxAtX ! Local REAL ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 INTEGER :: i IF ( N == 0 ) then lAtX = 1.0_real64 dLdxAtX = 0.0_real64 ELSEIF ( N == 1 ) then lAtX = x dLdxAtX = 1.0_real64 ELSE lnM2 = 1.0_real64 lnM1 = x dlnM2 = 0.0_real64 dlnM1 = 1.0_real64 DO i = 2 , N lAtX = (( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * x * lnM1 - & ( REAL ( i , real64 ) - 1.0_real64 ) * lnM2 ) / ( REAL ( i , real64 )) dldxAtX = dlnM2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lnM1 lnM2 = lnM1 lnM1 = lAtX dlnM2 = dlnM1 dlnM1 = dldxAtX END DO END IF END SUBROUTINE LegendrePolynomial ! =============================================================================================== ! ! S/R LegendreQandL !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 65 !   Algorithm 24 ! =============================================================================================== ! SUBROUTINE LegendreQandL ( N , x , q , qprime , lN ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: x REAL ( real64 ) :: lN , q , qprime ! Local REAL ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 , dlN , lN1 , dlN1 INTEGER :: i lNm2 = 1.0_real64 lNm1 = x dlNm2 = 0.0_real64 dlNm1 = 1.0_real64 DO i = 2 , N lN = ( 2.0_real64 * i - 1.0_real64 ) / ( REAL ( i , real64 )) * x * lNm1 - ( REAL ( i , real64 ) - 1.0_real64 ) / ( REAL ( i , real64 )) * lNm2 dlN = dlNm2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lNm1 lNm2 = lNm1 lNm1 = lN dlNm2 = dlNm1 dlNm1 = dlN END DO i = N + 1 lN1 = ( 2.0_real64 * i - 1.0_real64 ) / ( REAL ( i , real64 )) * x * lN - ( REAL ( i , real64 ) - 1.0_real64 ) / ( REAL ( i , real64 )) * lNm2 dlN1 = dlNm2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lNm1 q = lN1 - lNm2 qprime = dlN1 - dlNm2 END SUBROUTINE LegendreQandL END MODULE SELF_Quadrature","tags":"","loc":"sourcefile/self_quadrature.f90.html"},{"title":"SELF_Data.f90 – SELF","text":"Contents Modules SELF_Data Source Code SELF_Data.f90 Source Code ! SELF_Data.F90 ! ! Copyright 2020-2022 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : support@fluidnumerics.com ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Data USE SELF_Constants USE SELF_Lagrange USE SELF_Metadata USE FEQParse USE ISO_C_BINDING IMPLICIT NONE #include \"SELF_Macros.h\" TYPE , PUBLIC :: SELF_DataObj !! The SELF_DataObj class is a base class for all data objects in SELF. !! A data object in SELF is a multidimensional array of data, represented !! on both host and device, that is associated with an interpolant, metadata, !! and (optionally) an equation string. !! Type extensions of the SELF_DataObj include scalars, vectors, and tensors !! in 1-D, 2-D, and 3-D using the storage patterns that are expected for !! derivative and interpolation operations defined in SELF_Lagrange.f90 !! Additionally, each extended type has the necessary attributes to store !! information on element interiors and element boundaries, both of which !! are commonly used for spectral element solvers. INTEGER :: nVar INTEGER :: nElem TYPE ( Lagrange ), POINTER :: interp TYPE ( Metadata ), ALLOCATABLE :: meta (:) TYPE ( EquationParser ), ALLOCATABLE :: eqn (:) CONTAINS ! PROCEDURE,PUBLIC :: Init => Init_DataObj ! PROCEDURE,PUBLIC :: Free => Free_DataObj ! Procedures for setting metadata for PROCEDURE , PUBLIC :: SetName => SetName_DataObj PROCEDURE , PUBLIC :: SetDescription => SetDescription_DataObj PROCEDURE , PUBLIC :: SetUnits => SetUnits_DataObj GENERIC , PUBLIC :: SetEquation => SetEquation_DataObj PROCEDURE , PRIVATE :: SetEquation_DataObj END TYPE SELF_DataObj ! ---------------------- Scalars ---------------------- ! TYPE , EXTENDS ( SELF_DataObj ), PUBLIC :: Scalar1D TYPE ( hfReal_r3 ) :: interior TYPE ( hfReal_r3 ) :: boundary TYPE ( hfReal_r3 ) :: extBoundary TYPE ( hfReal_r3 ) :: avgBoundary TYPE ( hfReal_r3 ) :: jumpBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar1D PROCEDURE , PUBLIC :: Free => Free_Scalar1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar1D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar1D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar1D GENERIC , PUBLIC :: Derivative => Derivative_Scalar1D PROCEDURE , PRIVATE :: Derivative_Scalar1D ! PROCEDURE,PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar1D ! PROCEDURE,PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar1D ! GENERIC,PUBLIC :: ASSIGNMENT(=) => Equals_Scalar1D ! PROCEDURE,PRIVATE,PASS(SELFOut) :: Equals_Scalar1D GENERIC , PUBLIC :: WriteHDF5 => WriteHDF5_Scalar1D , WriteHDF5_MPI_Scalar1D PROCEDURE , PRIVATE :: WriteHDF5_Scalar1D PROCEDURE , PRIVATE :: WriteHDF5_MPI_Scalar1D END TYPE Scalar1D TYPE , EXTENDS ( SELF_DataObj ), PUBLIC :: Scalar2D TYPE ( hfReal_r4 ) :: interior TYPE ( hfReal_r4 ) :: boundary TYPE ( hfReal_r4 ) :: extBoundary TYPE ( hfReal_r4 ) :: avgBoundary TYPE ( hfReal_r4 ) :: jumpBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar2D PROCEDURE , PUBLIC :: Free => Free_Scalar2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar2D GENERIC , PUBLIC :: Gradient => Gradient_Scalar2D PROCEDURE , PRIVATE :: Gradient_Scalar2D ! PROCEDURE,PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar2D ! PROCEDURE,PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar2D ! GENERIC,PUBLIC :: ASSIGNMENT(=) => Equals_Scalar2D ! PROCEDURE,PRIVATE,PASS(SELFOut) :: Equals_Scalar2D GENERIC , PUBLIC :: WriteHDF5 => WriteHDF5_MPI_Scalar2D , WriteHDF5_Scalar2D PROCEDURE , PRIVATE :: WriteHDF5_MPI_Scalar2D PROCEDURE , PRIVATE :: WriteHDF5_Scalar2D END TYPE Scalar2D TYPE , EXTENDS ( SELF_DataObj ), PUBLIC :: Scalar3D TYPE ( hfReal_r5 ) :: interior TYPE ( hfReal_r5 ) :: boundary TYPE ( hfReal_r5 ) :: extBoundary TYPE ( hfReal_r5 ) :: avgBoundary TYPE ( hfReal_r5 ) :: jumpBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar3D PROCEDURE , PUBLIC :: Free => Free_Scalar3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar3D GENERIC , PUBLIC :: Gradient => Gradient_Scalar3D PROCEDURE , PRIVATE :: Gradient_Scalar3D ! PROCEDURE,PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar3D ! PROCEDURE,PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar3D ! GENERIC,PUBLIC :: ASSIGNMENT(=) => Equals_Scalar3D ! PROCEDURE,PRIVATE,PASS(SELFOut) :: Equals_Scalar3D GENERIC , PUBLIC :: WriteHDF5 => WriteHDF5_MPI_Scalar3D , WriteHDF5_Scalar3D PROCEDURE , PRIVATE :: WriteHDF5_MPI_Scalar3D PROCEDURE , PRIVATE :: WriteHDF5_Scalar3D END TYPE Scalar3D ! ---------------------- Vectors ---------------------- ! TYPE , EXTENDS ( SELF_DataObj ), PUBLIC :: Vector2D TYPE ( hfReal_r5 ) :: interior TYPE ( hfReal_r5 ) :: boundary TYPE ( hfReal_r5 ) :: extBoundary TYPE ( hfReal_r4 ) :: boundaryNormal CONTAINS PROCEDURE , PUBLIC :: Init => Init_Vector2D PROCEDURE , PUBLIC :: Free => Free_Vector2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Vector2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Vector2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Vector2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Vector2D GENERIC , PUBLIC :: Gradient => Gradient_Vector2D PROCEDURE , PRIVATE :: Gradient_Vector2D GENERIC , PUBLIC :: Divergence => Divergence_Vector2D PROCEDURE , PRIVATE :: Divergence_Vector2D ! GENERIC,PUBLIC :: Curl => Curl_Vector2D ! PROCEDURE,PRIVATE :: Curl_Vector2D ! PROCEDURE,PUBLIC :: AbsMaxInterior => AbsMaxInterior_Vector2D ! PROCEDURE,PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Vector2D ! GENERIC,PUBLIC :: ASSIGNMENT(=) => Equals_Vector2D ! PROCEDURE,PRIVATE,PASS(SELFOut) :: Equals_Vector2D GENERIC , PUBLIC :: SetEquation => SetEquation_Vector2D PROCEDURE , PRIVATE :: SetEquation_Vector2D GENERIC , PUBLIC :: WriteHDF5 => WriteHDF5_MPI_Vector2D , WriteHDF5_Vector2D PROCEDURE , PRIVATE :: WriteHDF5_MPI_Vector2D PROCEDURE , PRIVATE :: WriteHDF5_Vector2D END TYPE Vector2D TYPE , EXTENDS ( SELF_DataObj ), PUBLIC :: Vector3D TYPE ( hfReal_r6 ) :: interior TYPE ( hfReal_r6 ) :: boundary TYPE ( hfReal_r6 ) :: extBoundary TYPE ( hfReal_r5 ) :: boundaryNormal CONTAINS PROCEDURE , PUBLIC :: Init => Init_Vector3D PROCEDURE , PUBLIC :: Free => Free_Vector3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Vector3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Vector3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Vector3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Vector3D GENERIC , PUBLIC :: Gradient => Gradient_Vector3D PROCEDURE , PRIVATE :: Gradient_Vector3D GENERIC , PUBLIC :: Divergence => Divergence_Vector3D PROCEDURE , PRIVATE :: Divergence_Vector3D ! GENERIC,PUBLIC :: Curl => Curl_Vector3D ! PROCEDURE,PRIVATE :: Curl_Vector3D ! PROCEDURE,PUBLIC :: AbsMaxInterior => AbsMaxInterior_Vector3D ! PROCEDURE,PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Vector3D ! GENERIC,PUBLIC :: ASSIGNMENT(=) => Equals_Vector3D ! PROCEDURE,PRIVATE,PASS(SELFOut) :: Equals_Vector3D GENERIC , PUBLIC :: SetEquation => SetEquation_Vector3D PROCEDURE , PRIVATE :: SetEquation_Vector3D GENERIC , PUBLIC :: WriteHDF5 => WriteHDF5_MPI_Vector3D , WriteHDF5_Vector3D PROCEDURE , PRIVATE :: WriteHDF5_MPI_Vector3D PROCEDURE , PRIVATE :: WriteHDF5_Vector3D END TYPE Vector3D ! ! ----------------- Two-point Vectors ----------------- ! !   TYPE,EXTENDS(SELF_DataObj),PUBLIC :: P2Vector2D !     TYPE(hfReal_r6) :: interior !     TYPE(hfReal_r7) :: physical !     TYPE(hfReal_r5) :: boundary !     TYPE(hfReal_r5) :: extBoundary !     TYPE(hfReal_r4) :: boundaryNormal !   CONTAINS !     PROCEDURE,PUBLIC :: Init => Init_P2Vector2D !     PROCEDURE,PUBLIC :: Free => Free_P2Vector2D !     PROCEDURE,PUBLIC :: UpdateHost => UpdateHost_P2Vector2D !     PROCEDURE,PUBLIC :: UpdateDevice => UpdateDevice_P2Vector2D !     GENERIC,PUBLIC :: Divergence => Divergence_P2Vector2D !     PROCEDURE,PRIVATE :: Divergence_P2Vector2D !   END TYPE P2Vector2D ! ---------------------- Tensors ---------------------- ! TYPE , EXTENDS ( SELF_DataObj ), PUBLIC :: Tensor2D TYPE ( hfReal_r6 ) :: interior TYPE ( hfReal_r6 ) :: boundary TYPE ( hfReal_r6 ) :: extBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Tensor2D PROCEDURE , PUBLIC :: Free => Free_Tensor2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Tensor2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Tensor2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Tensor2D !PROCEDURE,PUBLIC :: GridInterp => GridInterp_Tensor2D PROCEDURE , PUBLIC :: Determinant => Determinant_Tensor2D !GENERIC,PUBLIC :: Divergence => Divergence_Tensor2D !PROCEDURE,PRIVATE :: Divergence_Tensor2D ! PROCEDURE,PUBLIC :: AbsMaxInterior => AbsMaxInterior_Tensor2D ! PROCEDURE,PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Tensor2D ! GENERIC,PUBLIC :: ASSIGNMENT(=) => Equals_Tensor2D ! PROCEDURE,PRIVATE,PASS(SELFOut) :: Equals_Tensor2D !GENERIC,PUBLIC :: SetEquation => SetEquation_Tensor2D !PROCEDURE,PRIVATE :: SetEquation_Tensor2D END TYPE Tensor2D TYPE , EXTENDS ( SELF_DataObj ), PUBLIC :: Tensor3D TYPE ( hfReal_r7 ) :: interior TYPE ( hfReal_r7 ) :: boundary TYPE ( hfReal_r7 ) :: extBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Tensor3D PROCEDURE , PUBLIC :: Free => Free_Tensor3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Tensor3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Tensor3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Tensor3D ! PROCEDURE,PUBLIC :: GridInterp => GridInterp_Tensor3D PROCEDURE , PUBLIC :: Determinant => Determinant_Tensor3D !GENERIC,PUBLIC :: Divergence => Divergence_Tensor3D !PROCEDURE,PRIVATE :: Divergence_Tensor3D ! PROCEDURE,PUBLIC :: AbsMaxInterior => AbsMaxInterior_Tensor3D ! PROCEDURE,PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Tensor3D ! GENERIC,PUBLIC :: ASSIGNMENT(=) => Equals_Tensor3D ! PROCEDURE,PRIVATE,PASS(SELFOut) :: Equals_Tensor3D !GENERIC,PUBLIC :: SetEquation => SetEquation_Tensor3D !PROCEDURE,PRIVATE :: SetEquation_Tensor3D END TYPE Tensor3D INTEGER , PARAMETER :: selfStrongForm = 0 INTEGER , PARAMETER :: selfWeakDGForm = 1 INTEGER , PARAMETER :: selfWeakCGForm = 2 INTEGER , PARAMETER :: selfWeakBRForm = 3 INTERFACE SUBROUTINE Determinant_Tensor2D_gpu_wrapper ( tensor_dev , detTensor_dev , N , nVar , nEl ) & bind ( c , name = \"Determinant_Tensor2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: tensor_dev , detTensor_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE Determinant_Tensor2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE Determinant_Tensor3D_gpu_wrapper ( tensor_dev , detTensor_dev , N , nVar , nEl ) & bind ( c , name = \"Determinant_Tensor3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: tensor_dev , detTensor_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE Determinant_Tensor3D_gpu_wrapper END INTERFACE CONTAINS ! -- DataObj -- ! ! SUBROUTINE Init_DataObj(SELFStorage,interp,nVar,nElem) !   IMPLICIT NONE !   CLASS(SELF_DataObj),INTENT(out)  :: SELFStorage !   TYPE(Lagrange),INTENT(in),TARGET :: interp !   INTEGER,INTENT(in) :: nVar !   INTEGER,INTENT(in) :: nElem !   SELFStorage % nElem = nElem !   SELFStorage % nVar = nVar !   SELFStorage % interp => interp !   ALLOCATE( SELFStorage % meta(1:nVar) ) !   ALLOCATE( SELFStorage % eqn(1:nVar) ) ! END SUBROUTINE Init_DataObj ! SUBROUTINE Free_DataObj(SELFStorage) !   IMPLICIT NONE !   CLASS(SELF_DataObj),INTENT(inout) :: SELFStorage !   SELFStorage % interp => NULL() !   DEALLOCATE( SELFStorage % meta ) !   DEALLOCATE( SELFStorage % eqn ) ! END SUBROUTINE Free_DataObj SUBROUTINE SetName_DataObj ( SELFStorage , ivar , name ) !! Set the name of the `ivar-th` variable IMPLICIT NONE CLASS ( SELF_DataObj ), INTENT ( inout ) :: SELFStorage INTEGER , INTENT ( in ) :: ivar CHARACTER ( * ), INTENT ( in ) :: name CALL SELFStorage % meta ( ivar ) % SetName ( name ) END SUBROUTINE SetName_DataObj SUBROUTINE SetDescription_DataObj ( SELFStorage , ivar , description ) !! Set the description of the `ivar-th` variable IMPLICIT NONE CLASS ( SELF_DataObj ), INTENT ( inout ) :: SELFStorage INTEGER , INTENT ( in ) :: ivar CHARACTER ( * ), INTENT ( in ) :: description CALL SELFStorage % meta ( ivar ) % SetDescription ( description ) END SUBROUTINE SetDescription_DataObj SUBROUTINE SetUnits_DataObj ( SELFStorage , ivar , units ) !! Set the units of the `ivar-th` variable IMPLICIT NONE CLASS ( SELF_DataObj ), INTENT ( inout ) :: SELFStorage INTEGER , INTENT ( in ) :: ivar CHARACTER ( * ), INTENT ( in ) :: units CALL SELFStorage % meta ( ivar ) % SetUnits ( units ) END SUBROUTINE SetUnits_DataObj SUBROUTINE SetEquation_DataObj ( SELFStorage , ivar , eqnChar ) !! Sets the equation parser for the `ivar-th` variable IMPLICIT NONE CLASS ( SELF_DataObj ), INTENT ( inout ) :: SELFStorage INTEGER , INTENT ( in ) :: ivar CHARACTER ( * ), INTENT ( in ) :: eqnChar SELFStorage % eqn ( ivar ) = EquationParser ( TRIM ( eqnChar ), & ( / 'x' , 'y' , 'z' , 't' / ) ) END SUBROUTINE SetEquation_DataObj ! -- Scalar1D -- ! SUBROUTINE Init_Scalar1D ( SELFStorage , interp , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( out ) :: SELFStorage TYPE ( Lagrange ), INTENT ( in ), TARGET :: interp INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % interp => interp SELFStorage % nVar = nVar SELFStorage % nElem = nElem CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 1 , 1 / ), & upBound = ( / interp % N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / nVar , 2 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / nVar , 2 , nElem / )) CALL SELFStorage % avgBoundary % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / nVar , 2 , nElem / )) CALL SELFStorage % jumpBoundary % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / nVar , 2 , nElem / )) ALLOCATE ( SELFStorage % meta ( 1 : nVar ) ) ALLOCATE ( SELFStorage % eqn ( 1 : nVar ) ) END SUBROUTINE Init_Scalar1D SUBROUTINE Free_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage SELFStorage % interp => NULL () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () CALL SELFStorage % avgBoundary % Free () CALL SELFStorage % jumpBoundary % Free () DEALLOCATE ( SELFStorage % meta ) DEALLOCATE ( SELFStorage % eqn ) END SUBROUTINE Free_Scalar1D SUBROUTINE UpdateHost_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () CALL SELFStorage % avgBoundary % UpdateHost () CALL SELFStorage % jumpBoundary % UpdateHost () END SUBROUTINE UpdateHost_Scalar1D SUBROUTINE UpdateDevice_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () CALL SELFStorage % avgBoundary % UpdateDevice () CALL SELFStorage % jumpBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Scalar1D SUBROUTINE BoundaryInterp_Scalar1D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_1D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_1D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar1D SUBROUTINE GridInterp_Scalar1D ( SELFStorage , SELFout , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar1D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_1D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_1D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar1D SUBROUTINE Derivative_Scalar1D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar1D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % Derivative_1D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % Derivative_1D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Derivative_Scalar1D ! FUNCTION AbsMaxInterior_Scalar1D(scalar) RESULT(absMax) !   IMPLICIT NONE !   CLASS(Scalar1D) :: scalar !   REAL(prec) :: absMax(1:scalar % nVar) !   ! Local !   INTEGER :: iEl,iVar,i !   absMax = 0.0_prec !   DO iEl = 1,scalar % nElem !     DO iVar = 1,scalar % nVar !       DO i = 0,scalar % interp % N !         absMax(iVar) = MAX(ABS(scalar % interior % hostData(i,iVar,iEl)),absMax(iVar)) !       END DO !     END DO !   END DO ! END FUNCTION AbsMaxInterior_Scalar1D ! FUNCTION AbsMaxBoundary_Scalar1D(scalar) RESULT(absMax) !   IMPLICIT NONE !   CLASS(Scalar1D) :: scalar !   REAL(prec) :: absMax(1:scalar % nVar,1:2) !   ! Local !   INTEGER :: iEl,iVar,iSide !   absMax = 0.0_prec !   DO iEl = 1,scalar % nElem !     DO iSide = 1,2 !       DO iVar = 1,scalar % nVar !         absMax(iVar,iSide) = MAX(ABS(scalar % boundary % hostData(iVar,iSide,iEl)),absMax(iVar,iSide)) !       END DO !     END DO !   END DO ! END FUNCTION AbsMaxBoundary_Scalar1D ! SUBROUTINE Equals_Scalar1D(SELFOut,SELFin) !   IMPLICIT NONE !   CLASS(Scalar1D),INTENT(inout) :: SELFOut !   TYPE(Scalar1D),INTENT(in) :: SELFin !   SELFOut % interior % hostData = SELFin % interior % hostData !   SELFOut % boundary % hostData = SELFin % boundary % hostData ! END SUBROUTINE Equals_Scalar1D SUBROUTINE WriteHDF5_MPI_Scalar1D ( this , fileId , group , elemoffset , nglobalelem ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: this CHARACTER ( * ), INTENT ( in ) :: group INTEGER ( HID_T ), INTENT ( in ) :: fileId INTEGER , INTENT ( in ) :: elemoffset INTEGER , INTENT ( in ) :: nglobalelem ! Local INTEGER ( HID_T ) :: offset ( 1 : 3 ) INTEGER ( HID_T ) :: bOffset ( 1 : 3 ) INTEGER ( HID_T ) :: globalDims ( 1 : 3 ) INTEGER ( HID_T ) :: bGlobalDims ( 1 : 3 ) INTEGER :: ivar offset ( 1 : 3 ) = ( / 0 , 0 , elemoffset / ) globalDims ( 1 : 3 ) = ( / this % interp % N + 1 , & this % nVar , & nGlobalElem / ) ! Offsets and dimensions for element boundary data bOffset ( 1 : 3 ) = ( / 0 , 0 , elemoffset / ) bGlobalDims ( 1 : 3 ) = ( / this % nVar , & 2 , & nGlobalElem / ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior , offset , globalDims ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary , bOffset , bGlobalDims ) END SUBROUTINE WriteHDF5_MPI_Scalar1D SUBROUTINE WriteHDF5_Scalar1D ( this , fileId , group ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: this INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: group ! Local INTEGER :: ivar CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary ) END SUBROUTINE WriteHDF5_Scalar1D ! -- Scalar2D -- ! SUBROUTINE Init_Scalar2D ( SELFStorage , interp , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( out ) :: SELFStorage TYPE ( Lagrange ), INTENT ( in ), TARGET :: interp INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % interp => interp SELFStorage % nVar = nVar SELFStorage % nElem = nElem CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 0 , 1 , 1 / ), & upBound = ( / interp % N , interp % N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / interp % N , nVar , 4 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / interp % N , nVar , 4 , nElem / )) CALL SELFStorage % avgBoundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / interp % N , nVar , 4 , nElem / )) CALL SELFStorage % jumpBoundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / interp % N , nVar , 4 , nElem / )) ALLOCATE ( SELFStorage % meta ( 1 : nVar ) ) ALLOCATE ( SELFStorage % eqn ( 1 : nVar ) ) END SUBROUTINE Init_Scalar2D SUBROUTINE Free_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage SELFStorage % nVar = 0 SELFStorage % nElem = 0 SELFStorage % interp => NULL () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () CALL SELFStorage % avgBoundary % Free () CALL SELFStorage % jumpBoundary % Free () DEALLOCATE ( SELFStorage % meta ) DEALLOCATE ( SELFStorage % eqn ) END SUBROUTINE Free_Scalar2D SUBROUTINE UpdateHost_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () CALL SELFStorage % avgBoundary % UpdateHost () CALL SELFStorage % jumpBoundary % UpdateHost () END SUBROUTINE UpdateHost_Scalar2D SUBROUTINE UpdateDevice_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () CALL SELFStorage % avgBoundary % UpdateDevice () CALL SELFStorage % jumpBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Scalar2D SUBROUTINE BoundaryInterp_Scalar2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar2D SUBROUTINE GridInterp_Scalar2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar2D SUBROUTINE Gradient_Scalar2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGradient_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGradient_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Scalar2D ! FUNCTION AbsMaxInterior_Scalar2D(scalar) RESULT(absMax) !   IMPLICIT NONE !   CLASS(Scalar2D) :: scalar !   REAL(prec) :: absMax(1:scalar % nVar) !   ! Local !   INTEGER :: iEl,iVar,i,j !   absMax = 0.0_prec !   DO iEl = 1,scalar % nElem !     DO iVar = 1,scalar % nVar !       DO j = 0,scalar % interp % N !         DO i = 0,scalar % interp % N !           absMax(iVar) = MAX(ABS(scalar % interior % hostData(i,j,iVar,iEl)),absMax(iVar)) !         END DO !       END DO !     END DO !   END DO ! END FUNCTION AbsMaxInterior_Scalar2D ! FUNCTION AbsMaxBoundary_Scalar2D(scalar) RESULT(absMax) !   IMPLICIT NONE !   CLASS(Scalar2D) :: scalar !   REAL(prec) :: absMax(1:scalar % nVar,1:4) !   ! Local !   INTEGER :: iEl,iVar,i,iSide !   absMax = 0.0_prec !   DO iEl = 1,scalar % nElem !     DO iSide = 1,4 !       DO iVar = 1,scalar % nVar !         DO i = 0,scalar % interp % N !           absMax(iVar,iSide) = MAX(ABS(scalar % boundary % hostData(i,iVar,iSide,iEl)),absMax(iVar,iSide)) !         END DO !       END DO !     END DO !   END DO ! END FUNCTION AbsMaxBoundary_Scalar2D ! SUBROUTINE Equals_Scalar2D(SELFOut,SELFin) !   IMPLICIT NONE !   CLASS(Scalar2D),INTENT(inout) :: SELFOut !   TYPE(Scalar2D),INTENT(in) :: SELFin !   SELFOut % interior % hostData = SELFin % interior % hostData !   SELFOut % boundary % hostData = SELFin % boundary % hostData ! END SUBROUTINE Equals_Scalar2D SUBROUTINE WriteHDF5_MPI_Scalar2D ( this , fileId , group , elemoffset , nglobalelem ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: this CHARACTER ( * ), INTENT ( in ) :: group INTEGER ( HID_T ), INTENT ( in ) :: fileId INTEGER , INTENT ( in ) :: elemoffset INTEGER , INTENT ( in ) :: nglobalelem ! Local INTEGER ( HID_T ) :: offset ( 1 : 4 ) INTEGER ( HID_T ) :: bOffset ( 1 : 4 ) INTEGER ( HID_T ) :: globalDims ( 1 : 4 ) INTEGER ( HID_T ) :: bGlobalDims ( 1 : 4 ) INTEGER :: ivar offset ( 1 : 4 ) = ( / 0 , 0 , 0 , elemoffset / ) globalDims ( 1 : 4 ) = ( / this % interp % N + 1 , & this % interp % N + 1 , & this % nVar , & nglobalelem / ) ! Offsets and dimensions for element boundary data bOffset ( 1 : 4 ) = ( / 0 , 0 , 0 , elemoffset / ) bGlobalDims ( 1 : 4 ) = ( / this % interp % N + 1 , & this % nVar , & 4 , & nglobalelem / ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior , offset , globalDims ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary , bOffset , bGlobalDims ) END SUBROUTINE WriteHDF5_MPI_Scalar2D SUBROUTINE WriteHDF5_Scalar2D ( this , fileId , group ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: this INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: group ! Local INTEGER :: ivar CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary ) END SUBROUTINE WriteHDF5_Scalar2D ! -- Scalar3D -- ! SUBROUTINE Init_Scalar3D ( SELFStorage , interp , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( out ) :: SELFStorage TYPE ( Lagrange ), TARGET , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem ! Local INTEGER :: N SELFStorage % interp => interp SELFStorage % nVar = nVar SELFStorage % nElem = nElem N = interp % N CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) CALL SELFStorage % avgBoundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) CALL SELFStorage % jumpBoundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) ALLOCATE ( SELFStorage % meta ( 1 : nVar ) ) ALLOCATE ( SELFStorage % eqn ( 1 : nVar ) ) END SUBROUTINE Init_Scalar3D SUBROUTINE Free_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage SELFStorage % nVar = 0 SELFStorage % nElem = 0 SELFStorage % interp => NULL () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () CALL SELFStorage % avgBoundary % Free () CALL SELFStorage % jumpBoundary % Free () DEALLOCATE ( SELFStorage % meta ) DEALLOCATE ( SELFStorage % eqn ) END SUBROUTINE Free_Scalar3D SUBROUTINE UpdateHost_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () CALL SELFStorage % avgBoundary % UpdateHost () CALL SELFStorage % jumpBoundary % UpdateHost () END SUBROUTINE UpdateHost_Scalar3D SUBROUTINE UpdateDevice_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () CALL SELFStorage % avgBoundary % UpdateDevice () CALL SELFStorage % jumpBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Scalar3D SUBROUTINE BoundaryInterp_Scalar3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar3D SUBROUTINE GridInterp_Scalar3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar3D SUBROUTINE Gradient_Scalar3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGradient_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGradient_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Scalar3D ! SUBROUTINE Equals_Scalar3D(SELFOut,SELFin) !   IMPLICIT NONE !   CLASS(Scalar3D),INTENT(inout) :: SELFOut !   TYPE(Scalar3D),INTENT(in) :: SELFin !   SELFOut % interior % hostData = SELFin % interior % hostData !   SELFOut % boundary % hostData = SELFin % boundary % hostData ! END SUBROUTINE Equals_Scalar3D ! FUNCTION AbsMaxInterior_Scalar3D(scalar) RESULT(absMax) !   IMPLICIT NONE !   CLASS(Scalar3D) :: scalar !   REAL(prec) :: absMax(1:scalar % nVar) !   ! Local !   INTEGER :: iEl,iVar,i,j,k !   absMax = 0.0_prec !   DO iEl = 1,scalar % nElem !     DO iVar = 1,scalar % nVar !       DO k = 0,scalar % interp % N !         DO j = 0,scalar % interp % N !           DO i = 0,scalar % interp % N !             absMax(iVar) = MAX(ABS(scalar % interior % hostData(i,j,k,iVar,iEl)),absMax(iVar)) !           END DO !         END DO !       END DO !     END DO !   END DO ! END FUNCTION AbsMaxInterior_Scalar3D ! FUNCTION AbsMaxBoundary_Scalar3D(scalar) RESULT(absMax) !   IMPLICIT NONE !   CLASS(Scalar3D) :: scalar !   REAL(prec) :: absMax(1:scalar % nVar,1:6) !   ! Local !   INTEGER :: iEl,iVar,i,j,iSide !   absMax = 0.0_prec !   DO iEl = 1,scalar % nElem !     DO iSide = 1,6 !       DO iVar = 1,scalar % nVar !         DO j = 0,scalar % interp % N !           DO i = 0,scalar % interp % N !             absMax(iVar,iSide) = MAX(ABS(scalar % boundary % hostData(i,j,iVar,iSide,iEl)),absMax(iVar,iSide)) !           END DO !         END DO !       END DO !     END DO !   END DO ! END FUNCTION AbsMaxBoundary_Scalar3D SUBROUTINE WriteHDF5_MPI_Scalar3D ( this , fileId , group , elemoffset , nglobalelem ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: this CHARACTER ( * ), INTENT ( in ) :: group INTEGER ( HID_T ), INTENT ( in ) :: fileId INTEGER , INTENT ( in ) :: elemoffset INTEGER , INTENT ( in ) :: nglobalelem ! Local INTEGER ( HID_T ) :: offset ( 1 : 5 ) INTEGER ( HID_T ) :: bOffset ( 1 : 5 ) INTEGER ( HID_T ) :: globalDims ( 1 : 5 ) INTEGER ( HID_T ) :: bGlobalDims ( 1 : 5 ) INTEGER :: ivar offset ( 1 : 5 ) = ( / 0 , 0 , 0 , 0 , elemoffset / ) globalDims ( 1 : 5 ) = ( / this % interp % N + 1 , & this % interp % N + 1 , & this % interp % N + 1 , & this % nVar , & nglobalelem / ) ! Offsets and dimensions for element boundary data bOffset ( 1 : 5 ) = ( / 0 , 0 , 0 , 0 , elemoffset / ) bGlobalDims ( 1 : 5 ) = ( / this % interp % N + 1 , & this % interp % N + 1 , & this % nVar , & 6 , & nglobalelem / ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior , offset , globalDims ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary , bOffset , bGlobalDims ) END SUBROUTINE WriteHDF5_MPI_Scalar3D SUBROUTINE WriteHDF5_Scalar3D ( this , fileId , group ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: this INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: group ! Local INTEGER :: ivar CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary ) END SUBROUTINE WriteHDF5_Scalar3D ! -- Vector2D -- ! SUBROUTINE Init_Vector2D ( SELFStorage , interp , nVar , nElem ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( out ) :: SELFStorage TYPE ( Lagrange ), TARGET , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem ! Local INTEGER :: N SELFStorage % interp => interp SELFStorage % nVar = nVar SELFStorage % nElem = nElem N = interp % N CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 / ), & upBound = ( / 2 , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , N , nVar , 4 , nElem / )) CALL SELFStorage % boundaryNormal % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / N , nVar , 4 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , N , nVar , 4 , nElem / )) ALLOCATE ( SELFStorage % meta ( 1 : nVar ) ) ALLOCATE ( SELFStorage % eqn ( 1 : 2 * nVar ) ) END SUBROUTINE Init_Vector2D SUBROUTINE Free_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage SELFStorage % interp => NULL () SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % boundaryNormal % Free () CALL SELFStorage % extBoundary % Free () DEALLOCATE ( SELFStorage % meta ) DEALLOCATE ( SELFStorage % eqn ) END SUBROUTINE Free_Vector2D SUBROUTINE SetEquation_Vector2D ( SELFStorage , idir , ivar , eqnChar ) !! Sets the equation parser for the `idir` direction and `ivar-th` variable IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage INTEGER , INTENT ( in ) :: idir , ivar CHARACTER ( * ), INTENT ( in ) :: eqnChar SELFStorage % eqn ( idir + 2 * ( ivar - 1 )) = EquationParser ( TRIM ( eqnChar ), & ( / 'x' , 'y' , 'z' , 't' / ) ) END SUBROUTINE SetEquation_Vector2D SUBROUTINE UpdateHost_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % boundaryNormal % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Vector2D SUBROUTINE UpdateDevice_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % boundaryNormal % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Vector2D SUBROUTINE BoundaryInterp_Vector2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Vector2D SUBROUTINE GridInterp_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Vector2D SUBROUTINE Gradient_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGradient_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGradient_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Vector2D SUBROUTINE Divergence_Vector2D ( SELFStorage , SELFOut , dForm , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDGDivergence_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundaryNormal % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDGDivergence_2D ( SELFStorage % interior % hostData , & SELFStorage % boundaryNormal % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDivergence_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDivergence_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END IF END SUBROUTINE Divergence_Vector2D ! SUBROUTINE Curl_Vector2D(SELFStorage,SELFOut,gpuAccel) !   IMPLICIT NONE !   CLASS(Vector2D),INTENT(in) :: SELFStorage !   TYPE(Scalar2D),INTENT(inout) :: SELFOut !   LOGICAL,INTENT(in) :: gpuAccel !   IF (gpuAccel) THEN !     CALL SELFStorage % interp % VectorCurl_2D(SELFStorage % interior % deviceData, & !                                               SELFout % interior % deviceData, & !                                               SELFStorage % nVar, & !                                               SELFStorage % nElem) !   ELSE !     CALL SELFStorage % interp % VectorCurl_2D(SELFStorage % interior % hostData, & !                                               SELFout % interior % hostData, & !                                               SELFStorage % nVar, & !                                               SELFStorage % nElem) !   END IF ! END SUBROUTINE Curl_Vector2D ! SUBROUTINE Equals_Vector2D(SELFOut,SELFin) !   IMPLICIT NONE !   CLASS(Vector2D),INTENT(inout) :: SELFOut !   TYPE(Vector2D),INTENT(in) :: SELFin !   SELFOut % interior % hostData = SELFin % interior % hostData !   SELFOut % boundary % hostData = SELFin % boundary % hostData ! END SUBROUTINE Equals_Vector2D ! FUNCTION AbsMaxInterior_Vector2D(vector) RESULT(absMax) !   IMPLICIT NONE !   CLASS(Vector2D) :: vector !   REAL(prec) :: absMax(1:vector % nVar) !   ! Local !   INTEGER :: iEl,iVar,i,j,iDir !   absMax = 0.0_prec !   DO iEl = 1,vector % nElem !     DO iVar = 1,vector % nVar !       DO j = 0,vector % interp % N !         DO i = 0,vector % interp % N !           DO iDir = 1,2 !             absMax(iVar) = MAX(ABS(vector % interior % hostData(iDir,i,j,iVar,iEl)),absMax(iVar)) !           END DO !         END DO !       END DO !     END DO !   END DO ! END FUNCTION AbsMaxInterior_Vector2D ! FUNCTION AbsMaxBoundary_Vector2D(vector) RESULT(absMax) !   IMPLICIT NONE !   CLASS(Vector2D) :: vector !   REAL(prec) :: absMax(1:vector % nVar,1:4) !   ! Local !   INTEGER :: iEl,iVar,i,iDir,iSide !   absMax = 0.0_prec !   DO iEl = 1,vector % nElem !     DO iSide = 1,4 !       DO iVar = 1,vector % nVar !         DO i = 0,vector % interp % N !           DO iDir = 1,2 !             absMax(iVar,iSide) = MAX(ABS(vector % boundary % hostData(iDir,i,iVar,iSide,iEl)),absMax(iVar,iSide)) !           END DO !         END DO !       END DO !     END DO !   END DO ! END FUNCTION AbsMaxBoundary_Vector2D SUBROUTINE WriteHDF5_MPI_Vector2D ( this , fileId , group , elemoffset , nglobalelem ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: this CHARACTER ( * ), INTENT ( in ) :: group INTEGER ( HID_T ), INTENT ( in ) :: fileId INTEGER , INTENT ( in ) :: elemoffset INTEGER , INTENT ( in ) :: nglobalelem ! Local INTEGER ( HID_T ) :: offset ( 1 : 5 ) INTEGER ( HID_T ) :: bOffset ( 1 : 5 ) INTEGER ( HID_T ) :: globalDims ( 1 : 5 ) INTEGER ( HID_T ) :: bGlobalDims ( 1 : 5 ) INTEGER :: ivar offset ( 1 : 5 ) = ( / 0 , 0 , 0 , 0 , elemoffset / ) globalDims ( 1 : 5 ) = ( / 2 , & this % interp % N + 1 , & this % interp % N + 1 , & this % nVar , & nglobalelem / ) ! Offsets and dimensions for element boundary data bOffset ( 1 : 5 ) = ( / 0 , 0 , 0 , 0 , elemoffset / ) bGlobalDims ( 1 : 5 ) = ( / 2 , & this % interp % N + 1 , & this % nVar , & 4 , & nglobalelem / ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior , offset , globalDims ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary , bOffset , bGlobalDims ) END SUBROUTINE WriteHDF5_MPI_Vector2D SUBROUTINE WriteHDF5_Vector2D ( this , fileId , group ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: this INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: group ! Local INTEGER :: ivar CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary ) END SUBROUTINE WriteHDF5_Vector2D ! -- Vector3D -- ! SUBROUTINE Init_Vector3D ( SELFStorage , interp , nVar , nElem ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( out ) :: SELFStorage TYPE ( Lagrange ), TARGET , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem ! Local INTEGER :: N SELFStorage % interp => interp SELFStorage % nVar = nVar SELFStorage % nElem = nElem N = interp % N CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / 3 , N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , N , N , nVar , 6 , nElem / )) CALL SELFStorage % boundaryNormal % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , N , N , nVar , 6 , nElem / )) ALLOCATE ( SELFStorage % meta ( 1 : nVar ) ) ALLOCATE ( SELFStorage % eqn ( 1 : 3 * nVar ) ) END SUBROUTINE Init_Vector3D SUBROUTINE Free_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage SELFStorage % interp => NULL () SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % boundaryNormal % Free () CALL SELFStorage % extBoundary % Free () DEALLOCATE ( SELFStorage % meta ) DEALLOCATE ( SELFStorage % eqn ) END SUBROUTINE Free_Vector3D SUBROUTINE SetEquation_Vector3D ( SELFStorage , idir , ivar , eqnChar ) !! Sets the equation parser for the `idir` direction and `ivar-th` variable IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage INTEGER , INTENT ( in ) :: idir , ivar CHARACTER ( * ), INTENT ( in ) :: eqnChar SELFStorage % eqn ( idir + 3 * ( ivar - 1 )) = EquationParser ( TRIM ( eqnChar ), & ( / 'x' , 'y' , 'z' , 't' / ) ) END SUBROUTINE SetEquation_Vector3D SUBROUTINE UpdateHost_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % boundaryNormal % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Vector3D SUBROUTINE UpdateDevice_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % boundaryNormal % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Vector3D SUBROUTINE BoundaryInterp_Vector3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Vector3D SUBROUTINE GridInterp_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Vector3D SUBROUTINE Gradient_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGradient_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGradient_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Vector3D SUBROUTINE Divergence_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDivergence_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDivergence_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Divergence_Vector3D ! SUBROUTINE Curl_Vector3D(SELFStorage,SELFOut,gpuAccel) !   IMPLICIT NONE !   CLASS(Vector3D),INTENT(in) :: SELFStorage !   TYPE(Vector3D),INTENT(inout) :: SELFOut !   LOGICAL,INTENT(in) :: gpuAccel !   IF (gpuAccel) THEN !     CALL SELFStorage % interp % VectorCurl_3D(SELFStorage % interior % deviceData, & !                                               SELFout % interior % deviceData, & !                                               SELFStorage % nVar, & !                                               SELFStorage % nElem) !   ELSE !     CALL SELFStorage % interp % VectorCurl_3D(SELFStorage % interior % hostData, & !                                               SELFout % interior % hostData, & !                                               SELFStorage % nVar, & !                                               SELFStorage % nElem) !   END IF ! END SUBROUTINE Curl_Vector3D ! FUNCTION AbsMaxInterior_Vector3D(vector) RESULT(absMax) !   IMPLICIT NONE !   CLASS(Vector3D) :: vector !   REAL(prec) :: absMax(1:vector % nVar) !   ! Local !   INTEGER :: iEl,iVar,i,j,k,iDir !   absMax = 0.0_prec !   DO iEl = 1,vector % nElem !     DO iVar = 1,vector % nVar !       DO k = 0,vector % interp % N !         DO j = 0,vector % interp % N !           DO i = 0,vector % interp % N !             DO iDir = 1,3 !               absMax(iVar) = MAX(ABS(vector % interior % hostData(iDir,i,j,k,iVar,iEl)),absMax(iVar)) !             END DO !           END DO !         END DO !       END DO !     END DO !   END DO ! END FUNCTION AbsMaxInterior_Vector3D ! FUNCTION AbsMaxBoundary_Vector3D(vector) RESULT(absMax) !   IMPLICIT NONE !   CLASS(Vector3D) :: vector !   REAL(prec) :: absMax(1:vector % nVar,1:6) !   ! Local !   INTEGER :: iEl,iVar,i,j,iSide,iDir !   absMax = 0.0_prec !   DO iEl = 1,vector % nElem !     DO iSide = 1,6 !       DO iVar = 1,vector % nVar !         DO j = 0,vector % interp % N !           DO i = 0,vector % interp % N !             DO iDir = 1,3 !               absMax(iVar,iSide) = MAX(ABS(vector % boundary % hostData(iDir,i,j,iVar,iSide,iEl)),absMax(iVar,iSide)) !             END DO !           END DO !         END DO !       END DO !     END DO !   END DO ! END FUNCTION AbsMaxBoundary_Vector3D ! SUBROUTINE Equals_Vector3D(SELFOut,SELFin) !   IMPLICIT NONE !   CLASS(Vector3D),INTENT(inout) :: SELFOut !   TYPE(Vector3D),INTENT(in) :: SELFin !   SELFOut % interior % hostData = SELFin % interior % hostData !   SELFOut % boundary % hostData = SELFin % boundary % hostData ! END SUBROUTINE Equals_Vector3D SUBROUTINE WriteHDF5_MPI_Vector3D ( this , fileId , group , elemoffset , nglobalelem ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: this CHARACTER ( * ), INTENT ( in ) :: group INTEGER ( HID_T ), INTENT ( in ) :: fileId INTEGER , INTENT ( in ) :: elemoffset INTEGER , INTENT ( in ) :: nglobalelem ! Local INTEGER ( HID_T ) :: offset ( 1 : 6 ) INTEGER ( HID_T ) :: bOffset ( 1 : 6 ) INTEGER ( HID_T ) :: globalDims ( 1 : 6 ) INTEGER ( HID_T ) :: bGlobalDims ( 1 : 6 ) INTEGER :: ivar offset ( 1 : 6 ) = ( / 0 , 0 , 0 , 0 , 0 , elemoffset / ) globalDims ( 1 : 6 ) = ( / 3 , & this % interp % N + 1 , & this % interp % N + 1 , & this % interp % N + 1 , & this % nVar , & nglobalelem / ) ! Offsets and dimensions for element boundary data bOffset ( 1 : 6 ) = ( / 0 , 0 , 0 , 0 , 0 , elemoffset / ) bGlobalDims ( 1 : 6 ) = ( / 3 , & this % interp % N + 1 , & this % interp % N + 1 , & this % nVar , & 6 , & nglobalelem / ) CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior , offset , globalDims ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary , bOffset , bGlobalDims ) END SUBROUTINE WriteHDF5_MPI_Vector3D SUBROUTINE WriteHDF5_Vector3D ( this , fileId , group ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: this INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: group ! Local INTEGER :: ivar CALL CreateGroup_HDF5 ( fileId , TRIM ( group )) DO ivar = 1 , this % nVar CALL this % meta ( ivar ) % WriteHDF5 ( group , ivar , fileId ) ENDDO CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/interior\" , & this % interior ) CALL WriteArray_HDF5 ( fileId , TRIM ( group ) // \"/boundary\" , & this % boundary ) END SUBROUTINE WriteHDF5_Vector3D ! ! -- P2Vector2D -- ! !   SUBROUTINE Init_P2Vector2D(SELFStorage,interp,nVar,nElem) !     IMPLICIT NONE !     CLASS(P2Vector2D),INTENT(out) :: SELFStorage !     TYPE(Lagrange),TARGET,INTENT(in) :: interp !     INTEGER,INTENT(in) :: nVar !     INTEGER,INTENT(in) :: nElem !     ! Local !     INTEGER :: N !     SELFStorage % interp => interp !     SELFStorage % nVar = nVar !     SELFStorage % nElem = nElem !     N = interp % N !     CALL SELFStorage % interior % Alloc(loBound=(/1,0,0,0,1,1/), & !                                         upBound=(/2,N,N,N,nVar,nElem/)) !     CALL SELFStorage % physical % Alloc(loBound=(/1,1,0,0,0,1,1/), & !                                         upBound=(/2,2,N,N,N,nVar,nElem/)) !     CALL SELFStorage % boundary % Alloc(loBound=(/1,0,1,1,1/), & !                                         upBound=(/2,N,nVar,4,nElem/)) !     CALL SELFStorage % boundaryNormal % Alloc(loBound=(/0,1,1,1/), & !                                         upBound=(/N,nVar,4,nElem/)) !     CALL SELFStorage % extBoundary % Alloc(loBound=(/1,0,1,1,1/), & !                                            upBound=(/2,N,nVar,4,nElem/)) !     ALLOCATE( SELFStorage % meta(1:nVar) ) !     ALLOCATE( SELFStorage % eqn(1:2*nVar) ) !   END SUBROUTINE Init_P2Vector2D !   SUBROUTINE Free_P2Vector2D(SELFStorage) !     IMPLICIT NONE !     CLASS(P2Vector2D),INTENT(inout) :: SELFStorage !     SELFStorage % interp => NULL() !     SELFStorage % nVar = 0 !     SELFStorage % nElem = 0 !     CALL SELFStorage % interior % Free() !     CALL SELFStorage % physical % Free() !     CALL SELFStorage % boundary % Free() !     CALL SELFStorage % boundaryNormal % Free() !     CALL SELFStorage % extBoundary % Free() !     DEALLOCATE( SELFStorage % meta ) !     DEALLOCATE( SELFStorage % eqn ) !   END SUBROUTINE Free_P2Vector2D !   SUBROUTINE UpdateHost_P2Vector2D(SELFStorage) !     IMPLICIT NONE !     CLASS(P2Vector2D),INTENT(inout) :: SELFStorage !     CALL SELFStorage % interior % UpdateHost() !     CALL SELFStorage % physical % UpdateHost() !     CALL SELFStorage % boundary % UpdateHost() !     CALL SELFStorage % boundaryNormal % UpdateHost() !     CALL SELFStorage % extBoundary % UpdateHost() !   END SUBROUTINE UpdateHost_P2Vector2D !   SUBROUTINE UpdateDevice_P2Vector2D(SELFStorage) !     IMPLICIT NONE !     CLASS(P2Vector2D),INTENT(inout) :: SELFStorage !     CALL SELFStorage % interior % UpdateDevice() !     CALL SELFStorage % physical % UpdateDevice() !     CALL SELFStorage % boundary % UpdateDevice() !     CALL SELFStorage % boundaryNormal % UpdateDevice() !     CALL SELFStorage % extBoundary % UpdateDevice() !   END SUBROUTINE UpdateDevice_P2Vector2D !   SUBROUTINE Divergence_P2Vector2D(SELFStorage,SELFOut,dForm,gpuAccel) !     IMPLICIT NONE !     CLASS(P2Vector2D),INTENT(in) :: SELFStorage !     TYPE(Scalar2D),INTENT(inout) :: SELFOut !     INTEGER,INTENT(in) :: dForm !     LOGICAL,INTENT(in) :: gpuAccel !     IF (dForm == selfWeakDGForm) THEN !       IF (gpuAccel) THEN !         CALL SELFStorage % interp % P2VectorDGDivergence_2D(SELFStorage % interior % deviceData, & !                                                           SELFStorage % boundaryNormal % deviceData, & !                                                           SELFout % interior % deviceData, & !                                                           SELFStorage % nVar, & !                                                           SELFStorage % nElem) !       ELSE !         CALL SELFStorage % interp % P2VectorDGDivergence_2D(SELFStorage % interior % hostData, & !                                                           SELFStorage % boundaryNormal % hostData, & !                                                           SELFout % interior % hostData, & !                                                           SELFStorage % nVar, & !                                                           SELFStorage % nElem) !       END IF !     ELSE IF (dForm == selfStrongForm) THEN !       IF (gpuAccel) THEN !         CALL SELFStorage % interp % P2VectorDivergence_2D(SELFStorage % interior % deviceData, & !                                                         SELFout % interior % deviceData, & !                                                         SELFStorage % nVar, & !                                                         SELFStorage % nElem) !       ELSE !         CALL SELFStorage % interp % P2VectorDivergence_2D(SELFStorage % interior % hostData, & !                                                         SELFout % interior % hostData, & !                                                         SELFStorage % nVar, & !                                                         SELFStorage % nElem) !       END IF !     END IF !   END SUBROUTINE Divergence_P2Vector2D ! -- Tensor2D -- ! SUBROUTINE Init_Tensor2D ( SELFStorage , interp , nVar , nElem ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( out ) :: SELFStorage TYPE ( Lagrange ), TARGET , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem ! Local INTEGER :: N SELFStorage % interp => interp SELFStorage % nVar = nVar SELFStorage % nElem = nElem N = interp % N CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , nVar , 4 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , nVar , 4 , nElem / )) ALLOCATE ( SELFStorage % meta ( 1 : nVar ) ) ALLOCATE ( SELFStorage % eqn ( 1 : 4 * nVar ) ) END SUBROUTINE Init_Tensor2D SUBROUTINE Free_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage SELFStorage % interp => NULL () SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () DEALLOCATE ( SELFStorage % meta ) DEALLOCATE ( SELFStorage % eqn ) END SUBROUTINE Free_Tensor2D ! SUBROUTINE SetEquation_Tensor2D(SELFStorage,row,col,ivar,eqnChar) !   !! Sets the equation parser for row, col  of the ivar-th tensor !   IMPLICIT NONE !   CLASS(Tensor2D),INTENT(inout) :: SELFStorage !   INTEGER,INTENT(in) :: row,col,ivar !   CHARACTER(*),INTENT(in) :: eqnChar !   ! Local !   INTEGER :: ind !   ind = row+2*(col-1+2*(ivar-1)) !   SELFStorage % eqn(ind) = EquationParser( TRIM(eqnChar), & !                                             (/'x','y','z','t'/) ) ! END SUBROUTINE SetEquation_Tensor2D SUBROUTINE UpdateHost_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Tensor2D SUBROUTINE UpdateDevice_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Tensor2D SUBROUTINE BoundaryInterp_Tensor2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Tensor2D ! SUBROUTINE GridInterp_Tensor2D(SELFStorage,SELFOut,gpuAccel) !   IMPLICIT NONE !   CLASS(Tensor2D),INTENT(in) :: SELFStorage !   TYPE(Tensor2D),INTENT(inout) :: SELFOut !   LOGICAL,INTENT(in) :: gpuAccel !   IF (gpuAccel) THEN !     CALL SELFStorage % interp % TensorGridInterp_2D(SELFStorage % interior % deviceData, & !                                                     SELFout % interior % deviceData, & !                                                     SELFStorage % nVar, & !                                                     SELFStorage % nElem) !   ELSE !     CALL SELFStorage % interp % TensorGridInterp_2D(SELFStorage % interior % hostData, & !                                                     SELFout % interior % hostData, & !                                                     SELFStorage % nVar, & !                                                     SELFStorage % nElem) !   END IF ! END SUBROUTINE GridInterp_Tensor2D ! SUBROUTINE Divergence_Tensor2D(SELFStorage,SELFOut,gpuAccel) !   IMPLICIT NONE !   CLASS(Tensor2D),INTENT(in) :: SELFStorage !   TYPE(Vector2D),INTENT(inout) :: SELFOut !   LOGICAL,INTENT(in) :: gpuAccel !   IF (gpuAccel) THEN !     CALL SELFStorage % interp % TensorDivergence_2D(SELFStorage % interior % deviceData, & !                                                     SELFout % interior % deviceData, & !                                                     SELFStorage % nVar, & !                                                     SELFStorage % nElem) !   ELSE !     CALL SELFStorage % interp % TensorDivergence_2D(SELFStorage % interior % hostData, & !                                                     SELFout % interior % hostData, & !                                                     SELFStorage % nVar, & !                                                     SELFStorage % nElem) !   END IF ! END SUBROUTINE Divergence_Tensor2D SUBROUTINE Determinant_Tensor2D ( SELFStorage , SELFout , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"Determinant_Tensor2D\" IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j IF ( gpuAccel ) THEN CALL Determinant_Tensor2D_gpu_wrapper ( SELFStorage % interior % deviceData , & SELFOut % interior % deviceData , & SELFStorage % interp % N , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE DO iEl = 1 , SELFStorage % nElem DO iVar = 1 , SELFStorage % nVar DO j = 0 , SELFStorage % interp % N DO i = 0 , SELFStorage % interp % N SELFOut % interior % hostData ( i , j , iVar , iEl ) = SELFStorage % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE Determinant_Tensor2D ! FUNCTION AbsMaxInterior_Tensor2D(tensor) RESULT(absMax) !   IMPLICIT NONE !   CLASS(Tensor2D) :: tensor !   REAL(prec) :: absMax(1:tensor % nVar) !   ! Local !   INTEGER :: iEl,iVar,i,j,row,col !   absMax = 0.0_prec !   DO iEl = 1,tensor % nElem !     DO iVar = 1,tensor % nVar !       DO j = 0,tensor % interp % N !         DO i = 0,tensor % interp % N !           DO col = 1,2 !             DO row = 1,2 !               absMax(iVar) = MAX(ABS(tensor % interior % hostData(row,col,i,j,iVar,iEl)),absMax(iVar)) !             END DO !           END DO !         END DO !       END DO !     END DO !   END DO ! END FUNCTION AbsMaxInterior_Tensor2D ! FUNCTION AbsMaxBoundary_Tensor2D(tensor) RESULT(absMax) !   IMPLICIT NONE !   CLASS(Tensor2D) :: tensor !   REAL(prec) :: absMax(1:tensor % nVar,1:4) !   ! Local !   INTEGER :: iEl,iVar,i,iSide,row,col !   absMax = 0.0_prec !   DO iEl = 1,tensor % nElem !     DO iSide = 1,4 !       DO iVar = 1,tensor % nVar !         DO i = 0,tensor % interp % N !           DO col = 1,2 !             DO row = 1,2 !               absMax(iVar,iSide) = MAX(ABS(tensor % boundary % hostData(row,col,i,iVar,iSide,iEl)),absMax(iVar,iSide)) !             END DO !           END DO !         END DO !       END DO !     END DO !   END DO ! END FUNCTION AbsMaxBoundary_Tensor2D ! SUBROUTINE Equals_Tensor2D(SELFOut,SELFin) !   IMPLICIT NONE !   CLASS(Tensor2D),INTENT(inout) :: SELFOut !   TYPE(Tensor2D),INTENT(in) :: SELFin !   SELFOut % interior % hostData = SELFin % interior % hostData !   SELFOut % boundary % hostData = SELFin % boundary % hostData ! END SUBROUTINE Equals_Tensor2D ! -- Tensor3D -- ! SUBROUTINE Init_Tensor3D ( SELFStorage , interp , nVar , nElem ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( out ) :: SELFStorage TYPE ( Lagrange ), TARGET , INTENT ( in ) :: interp INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem ! Local INTEGER :: N SELFStorage % interp => interp SELFStorage % nVar = nVar SELFStorage % nElem = nElem N = interp % N CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , nVar , 6 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , nVar , 6 , nElem / )) ALLOCATE ( SELFStorage % meta ( 1 : nVar ) ) ALLOCATE ( SELFStorage % eqn ( 1 : 9 * nVar ) ) END SUBROUTINE Init_Tensor3D SUBROUTINE Free_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage SELFStorage % interp => NULL () SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () DEALLOCATE ( SELFStorage % meta ) DEALLOCATE ( SELFStorage % eqn ) END SUBROUTINE Free_Tensor3D ! SUBROUTINE SetEquation_Tensor3D(SELFStorage,row,col,ivar,eqnChar) !   !! Sets the equation parser for row, col  of the ivar-th tensor !   IMPLICIT NONE !   CLASS(Tensor3D),INTENT(inout) :: SELFStorage !   INTEGER,INTENT(in) :: row,col,ivar !   CHARACTER(*),INTENT(in) :: eqnChar !   ! Local !   INTEGER :: ind !   ind = row+3*(col-1+3*(ivar-1)) !   SELFStorage % eqn(ind) = EquationParser( TRIM(eqnChar), & !                                             (/'x','y','z','t'/) ) ! END SUBROUTINE SetEquation_Tensor3D SUBROUTINE UpdateHost_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Tensor3D SUBROUTINE UpdateDevice_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateDevice_Tensor3D SUBROUTINE BoundaryInterp_Tensor3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Tensor3D ! SUBROUTINE GridInterp_Tensor3D(SELFStorage,SELFOut,gpuAccel) !   IMPLICIT NONE !   CLASS(Tensor3D),INTENT(in) :: SELFStorage !   TYPE(Tensor3D),INTENT(inout) :: SELFOut !   LOGICAL,INTENT(in) :: gpuAccel !   IF (gpuAccel) THEN !     CALL SELFStorage % interp % TensorGridInterp_3D(SELFStorage % interior % deviceData, & !                                                     SELFout % interior % deviceData, & !                                                     SELFStorage % nVar, & !                                                     SELFStorage % nElem) !   ELSE !     CALL SELFStorage % interp % TensorGridInterp_3D(SELFStorage % interior % hostData, & !                                                     SELFout % interior % hostData, & !                                                     SELFStorage % nVar, & !                                                     SELFStorage % nElem) !   END IF ! END SUBROUTINE GridInterp_Tensor3D ! SUBROUTINE Divergence_Tensor3D(SELFStorage,SELFOut,gpuAccel) !   IMPLICIT NONE !   CLASS(Tensor3D),INTENT(in) :: SELFStorage !   TYPE(Vector3D),INTENT(inout) :: SELFOut !   LOGICAL,INTENT(in) :: gpuAccel !   IF (gpuAccel) THEN !     CALL SELFStorage % interp % TensorDivergence_3D(SELFStorage % interior % deviceData, & !                                                     SELFout % interior % deviceData, & !                                                     SELFStorage % nVar, & !                                                     SELFStorage % nElem) !   ELSE !     CALL SELFStorage % interp % TensorDivergence_3D(SELFStorage % interior % hostData, & !                                                     SELFout % interior % hostData, & !                                                     SELFStorage % nVar, & !                                                     SELFStorage % nElem) !   END IF ! END SUBROUTINE Divergence_Tensor3D SUBROUTINE Determinant_Tensor3D ( SELFStorage , SELFOut , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"Determinant_Tensor3D\" IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k IF ( gpuAccel ) THEN CALL Determinant_Tensor3D_gpu_wrapper ( SELFStorage % interior % deviceData , & SELFOut % interior % deviceData , & SELFStorage % interp % N , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE DO iEl = 1 , SELFStorage % nElem DO iVar = 1 , SELFStorage % nVar DO k = 0 , SELFStorage % interp % N DO j = 0 , SELFStorage % interp % N DO i = 0 , SELFStorage % interp % N SELFOut % interior % hostData ( i , j , k , iVar , iEl ) = & SELFStorage % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl )) - & SELFStorage % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl )) + & SELFStorage % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl )) END DO END DO END DO END DO END DO END IF END SUBROUTINE Determinant_Tensor3D ! FUNCTION AbsMaxInterior_Tensor3D(tensor) RESULT(absMax) !   IMPLICIT NONE !   CLASS(Tensor3D) :: tensor !   REAL(prec) :: absMax(1:tensor % nVar) !   ! Local !   INTEGER :: iEl,iVar,i,j,k,row,col !   absMax = 0.0_prec !   DO iEl = 1,tensor % nElem !     DO iVar = 1,tensor % nVar !       DO k = 0,tensor % interp % N !         DO j = 0,tensor % interp % N !           DO i = 0,tensor % interp % N !             DO col = 1,3 !               DO row = 1,3 !                 absMax(iVar) = MAX(ABS(tensor % interior % hostData(row,col,i,j,k,iVar,iEl)),absMax(iVar)) !               END DO !             END DO !           END DO !         END DO !       END DO !     END DO !   END DO ! END FUNCTION AbsMaxInterior_Tensor3D ! FUNCTION AbsMaxBoundary_Tensor3D(tensor) RESULT(absMax) !   IMPLICIT NONE !   CLASS(Tensor3D) :: tensor !   REAL(prec) :: absMax(1:tensor % nVar,1:6) !   ! Local !   INTEGER :: iEl,iVar,i,j,iSide,row,col !   absMax = 0.0_prec !   DO iEl = 1,tensor % nElem !     DO iSide = 1,6 !       DO iVar = 1,tensor % nVar !         DO j = 0,tensor % interp % N !           DO i = 0,tensor % interp % N !             DO col = 1,3 !               DO row = 1,3 !             absMax(iVar,iSide) = MAX(ABS(tensor % boundary % hostData(row,col,i,j,iVar,iSide,iEl)),absMax(iVar,iSide)) !               END DO !             END DO !           END DO !         END DO !       END DO !     END DO !   END DO ! END FUNCTION AbsMaxBoundary_Tensor3D ! SUBROUTINE Equals_Tensor3D(SELFOut,SELFin) !   IMPLICIT NONE !   CLASS(Tensor3D),INTENT(inout) :: SELFOut !   TYPE(Tensor3D),INTENT(in) :: SELFin !   SELFOut % interior % hostData = SELFin % interior % hostData !   SELFOut % boundary % hostData = SELFin % boundary % hostData ! END SUBROUTINE Equals_Tensor3D END MODULE SELF_Data","tags":"","loc":"sourcefile/self_data.f90.html"},{"title":"SELF_Constants.f90 – SELF","text":"Contents Modules SELF_Constants Source Code SELF_Constants.f90 Source Code ! SELF_Constants.f90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Constants USE ISO_C_BINDING USE ISO_FORTRAN_ENV IMPLICIT NONE INCLUDE \"mpif.h\" #include \"SELF_Macros.h\" #ifdef DOUBLE_PRECISION INTEGER , PARAMETER :: prec = real64 INTEGER , PARAMETER :: c_prec = C_DOUBLE #else INTEGER , PARAMETER :: prec = real32 INTEGER , PARAMETER :: c_prec = C_FLOAT #endif !*************************************************************! ! ------------------ CHARACTER LENGTHS----- ------------------! ! ************************************************************! !                                                             ! INTEGER , PARAMETER :: SELF_EQN_DEFAULT_LENGTH = 100 INTEGER , PARAMETER :: SELF_FILE_DEFAULT_LENGTH = 500 ! ------------------------------------------------------------! !*************************************************************! ! ------------------ MATHEMATICAL CONSTANTS ------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! REAL ( prec ), PARAMETER :: pi = 4.0_prec * atan ( 1.0_prec ) REAL ( prec ), PARAMETER :: TOL = epsilon ( 1.0_prec ) REAL ( prec ), PARAMETER :: fillValue = - 999 9.99_prec INTEGER , PARAMETER :: fillValueInt = - 99999 !*************************************************************! ! ----------------- ROOT FINDER CONSTANTS --------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! INTEGER , PARAMETER :: maxInverseIters = 1000 REAL ( prec ), PARAMETER :: newtonTolerance = 1 0.0 ** ( - 8 ) INTEGER , PARAMETER :: newtonMax = 500 !*************************************************************! ! ----------------- TIME STEPPING CONSTANTS ------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! !*************************************************************! ! ------------------- PHYSICAL CONSTANTS ---------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! ! Time conversion factors REAL ( prec ), PARAMETER :: secondsToMinutes = 1.0_prec / 6 0.0_prec ! conversion for seconds to minutes REAL ( prec ), PARAMETER :: minutesToHours = 1.0_prec / 6 0.0_prec ! conversion for minutes to hours REAL ( prec ), PARAMETER :: hoursToDays = 1.0_prec / 2 4.0_prec ! conversion for hours to days REAL ( prec ), PARAMETER :: daysToMonths = 1 2.0_prec / 36 5.25_prec ! conversion for days to months REAL ( prec ), PARAMETER :: monthsToYears = 1.0_prec / 1 2.0_prec ! conversion for months to years REAL ( prec ), PARAMETER :: daysToSeconds = 8640 0.0_prec !==============================================! ! --------------- Quadrature------------------ ! !==============================================! INTEGER , PARAMETER :: GAUSS = 1 INTEGER , PARAMETER :: GAUSS_LOBATTO = 2 INTEGER , PARAMETER :: CHEBYSHEV_GAUSS = 3 INTEGER , PARAMETER :: CHEBYSHEV_GAUSS_LOBATTO = 4 INTEGER , PARAMETER :: UNIFORM = 5 INTEGER , PARAMETER :: DG = 2000 INTEGER , PARAMETER :: CG = 2001 ! Misc. INTEGER and CHARACTER flag definitions CHARACTER ( 1 ), PARAMETER :: nada = ' ' CHARACTER ( 6 ), PARAMETER :: MsgFmt = '(2x,A)' INTEGER , PARAMETER :: self_FileNameLength = 500 INTEGER , PARAMETER :: self_TecplotHeaderLength = 500 INTEGER , PARAMETER :: self_EquationLength = 210 INTEGER , PARAMETER :: self_FormatLength = 30 INTEGER , PARAMETER :: self_QuadratureTypeCharLength = 50 INTEGER , PARAMETER :: self_IntegratorTypeCharLength = 50 END MODULE SELF_Constants","tags":"","loc":"sourcefile/self_constants.f90.html"},{"title":"SELF_HIP.f90 – SELF","text":"Contents Modules SELF_HIP Source Code SELF_HIP.f90 Source Code MODULE SELF_HIP ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! ============================================================================== ! hipfort: FORTRAN INTERFACEs for GPU kernels ! ============================================================================== ! Copyright (c) 2020-2022 Advanced Micro Devices, Inc. All rights reserved. ! [MITx11 License] ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in ! all copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN ! THE SOFTWARE. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! USE ISO_C_BINDING IMPLICIT NONE INTERFACE hipGetDeviceCount FUNCTION hipGetDeviceCount_ ( count ) BIND ( c , name = \"hipGetDeviceCount\" ) USE ISO_C_BINDING USE SELF_HIP_enums IMPLICIT NONE INTEGER ( KIND ( hipSuccess )) :: hipGetDeviceCount_ INTEGER ( C_INT ) :: count END FUNCTION END INTERFACE INTERFACE hipMalloc FUNCTION hipMalloc_ ( ptr , mySize ) BIND ( c , name = \"hipMalloc\" ) USE ISO_C_BINDING USE SELF_HIP_enums IMPLICIT NONE INTEGER ( KIND ( hipSuccess )) :: hipMalloc_ TYPE ( C_PTR ) :: ptr INTEGER ( C_SIZE_T ), VALUE :: mySize END FUNCTION END INTERFACE hipMalloc INTERFACE hipFree FUNCTION hipFree_ ( ptr ) BIND ( c , name = \"hipFree\" ) USE ISO_C_BINDING USE SELF_HIP_enums IMPLICIT NONE INTEGER ( KIND ( hipSuccess )) :: hipFree_ TYPE ( C_PTR ), VALUE :: ptr END FUNCTION END INTERFACE hipFree INTERFACE hipMemcpy FUNCTION hipMemcpy_ ( dest , src , sizeBytes , myKind ) BIND ( c , name = \"hipMemcpy\" ) USE ISO_C_BINDING USE SELF_HIP_enums IMPLICIT NONE INTEGER ( KIND ( hipSuccess )) :: hipMemcpy_ TYPE ( C_PTR ), VALUE :: dest TYPE ( C_PTR ), VALUE :: src INTEGER ( C_SIZE_T ), VALUE :: sizeBytes INTEGER ( KIND ( hipMemcpyHostToHost )), VALUE :: myKind END FUNCTION hipMemcpy_ END INTERFACE hipMemcpy INTERFACE hipSetDevice FUNCTION hipSetDevice_ ( deviceId ) BIND ( c , name = \"hipSetDevice\" ) USE ISO_C_BINDING USE SELF_HIP_enums IMPLICIT NONE INTEGER ( KIND ( hipSuccess )) :: hipSetDevice_ INTEGER ( C_INT ), VALUE :: deviceId END FUNCTION hipSetDevice_ END INTERFACE hipSetDevice CONTAINS SUBROUTINE hipCheck ( hipError_t ) USE SELF_HIP_enums IMPLICIT NONE INTEGER ( KIND ( hipSuccess )) :: hipError_t IF ( hipError_t /= hipSuccess ) THEN WRITE ( * , * ) \"HIP ERROR: Error code = \" , hipError_t CALL EXIT ( hipError_t ) END IF END SUBROUTINE hipCheck END MODULE SELF_HIP","tags":"","loc":"sourcefile/self_hip.f90.html"},{"title":"SELF_ECModel2D.f90 – SELF","text":"Contents Modules SELF_ECModel2D Source Code SELF_ECModel2D.f90 Source Code ! ! Copyright 2020-2022 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : support@fluidnumerics.com ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_ECModel2D USE SELF_SupportRoutines USE SELF_Metadata USE SELF_Mesh USE SELF_MappedData USE SELF_HDF5 USE HDF5 USE FEQParse USE SELF_Model USE SELF_Model2D IMPLICIT NONE #include \"SELF_Macros.h\" TYPE , EXTENDS ( Model ) :: ECModel2D TYPE ( MappedScalar2D ) :: solution TYPE ( MappedVector2D ) :: solutionGradient TYPE ( MappedP2Vector2D ) :: flux TYPE ( MappedScalar2D ) :: source TYPE ( MappedScalar2D ) :: fluxDivergence TYPE ( MappedScalar2D ) :: dSdt TYPE ( MappedScalar2D ) :: workSol TYPE ( MappedScalar2D ) :: prevSol TYPE ( Mesh2D ), POINTER :: mesh TYPE ( SEMQuad ), POINTER :: geometry CONTAINS PROCEDURE :: Init => Init_ECModel2D PROCEDURE :: Free => Free_ECModel2D PROCEDURE :: UpdateHost => UpdateHost_ECModel2D PROCEDURE :: UpdateDevice => UpdateDevice_ECModel2D PROCEDURE :: UpdateSolution => UpdateSolution_ECModel2D PROCEDURE :: ResizePrevSol => ResizePrevSol_ECModel2D PROCEDURE :: UpdateGAB2 => UpdateGAB2_ECModel2D PROCEDURE :: UpdateGAB3 => UpdateGAB3_ECModel2D PROCEDURE :: UpdateGAB4 => UpdateGAB4_ECModel2D PROCEDURE :: UpdateGRK2 => UpdateGRK2_ECModel2D PROCEDURE :: UpdateGRK3 => UpdateGRK3_ECModel2D PROCEDURE :: UpdateGRK4 => UpdateGRK4_ECModel2D PROCEDURE :: CalculateTendency => CalculateTendency_ECModel2D PROCEDURE :: CalculateFluxDivergence => CalculateFluxDivergence_ECModel2D GENERIC :: SetSolution => SetSolutionFromChar_ECModel2D , & SetSolutionFromEqn_ECModel2D PROCEDURE , PRIVATE :: SetSolutionFromChar_ECModel2D PROCEDURE , PRIVATE :: SetSolutionFromEqn_ECModel2D PROCEDURE :: UpdateBoundary => UpdateBoundary_ECModel2D PROCEDURE :: ReprojectFlux => ReprojectFlux_ECModel2D PROCEDURE :: ReadModel => Read_ECModel2D PROCEDURE :: WriteModel => Write_ECModel2D PROCEDURE :: WriteTecplot => WriteTecplot_ECModel2D END TYPE ECModel2D CONTAINS SUBROUTINE Init_ECModel2D ( this , nvar , mesh , geometry , decomp ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: nvar TYPE ( Mesh2D ), INTENT ( in ), TARGET :: mesh TYPE ( SEMQuad ), INTENT ( in ), TARGET :: geometry TYPE ( MPILayer ), INTENT ( in ), TARGET :: decomp ! Local INTEGER :: ivar CHARACTER ( LEN = 3 ) :: ivarChar CHARACTER ( LEN = 25 ) :: varname this % decomp => decomp this % mesh => mesh this % geometry => geometry this % gpuAccel = . FALSE . CALL this % solution % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % workSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % prevSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % dSdt % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % solutionGradient % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % flux % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % source % Init ( geometry % x % interp , nVar , this % mesh % nElem ) CALL this % fluxDivergence % Init ( geometry % x % interp , nVar , this % mesh % nElem ) ! set default metadata DO ivar = 1 , nvar WRITE ( ivarChar , '(I3.3)' ) ivar varname = \"solution\" // TRIM ( ivarChar ) CALL this % solution % SetName ( ivar , varname ) CALL this % solution % SetUnits ( ivar , \"[null]\" ) END DO END SUBROUTINE Init_ECModel2D SUBROUTINE Free_ECModel2D ( this ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CALL this % solution % Free () CALL this % workSol % Free () CALL this % prevSol % Free () CALL this % dSdt % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () END SUBROUTINE Free_ECModel2D SUBROUTINE ResizePrevSol_ECModel2D ( this , m ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: nVar ! Free space, if necessary CALL this % prevSol % Free () ! Reallocate with increased variable dimension for ! storing \"m\" copies of solution data nVar = this % solution % nVar CALL this % prevSol % Init ( this % geometry % x % interp , m * nVar , this % mesh % nElem ) END SUBROUTINE ResizePrevSol_ECModel2D SUBROUTINE UpdateHost_ECModel2D ( this ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CALL this % mesh % UpdateHost () CALL this % geometry % UpdateHost () CALL this % solution % UpdateHost () CALL this % dSdt % UpdateHost () CALL this % solution % UpdateHost () CALL this % solutionGradient % UpdateHost () CALL this % flux % UpdateHost () CALL this % source % UpdateHost () CALL this % fluxDivergence % UpdateHost () END SUBROUTINE UpdateHost_ECModel2D SUBROUTINE UpdateDevice_ECModel2D ( this ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CALL this % mesh % UpdateDevice () CALL this % geometry % UpdateDevice () CALL this % dSdt % UpdateDevice () CALL this % solution % UpdateDevice () CALL this % solutionGradient % UpdateDevice () CALL this % flux % UpdateDevice () CALL this % source % UpdateDevice () CALL this % fluxDivergence % UpdateDevice () END SUBROUTINE UpdateDevice_ECModel2D SUBROUTINE SetSolutionFromEqn_ECModel2D ( this , eqn ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar ! Copy the equation parser DO iVar = 1 , this % solution % nVar CALL this % solution % SetEquation ( ivar , eqn ( iVar ) % equation ) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromEqn_ECModel2D SUBROUTINE SetSolutionFromChar_ECModel2D ( this , eqnChar ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CHARACTER ( LEN = SELF_EQUATION_LENGTH ), INTENT ( in ) :: eqnChar ( 1 : this % solution % nVar ) ! Local INTEGER :: iVar DO iVar = 1 , this % solution % nVar CALL this % solution % SetEquation ( ivar , eqnChar ( iVar )) END DO CALL this % solution % SetInteriorFromEquation ( this % geometry , this % t ) CALL this % solution % BoundaryInterp ( gpuAccel = . FALSE .) IF ( this % gpuAccel ) THEN CALL this % solution % UpdateDevice () END IF END SUBROUTINE SetSolutionFromChar_ECModel2D SUBROUTINE UpdateSolution_ECModel2D ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the ECModel's stored time step size (model % dt) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this REAL ( prec ), OPTIONAL , INTENT ( in ) :: dt ! Local REAL ( prec ) :: dtLoc INTEGER :: i , j , iVar , iEl IF ( PRESENT ( dt )) THEN dtLoc = dt ELSE dtLoc = this % dt END IF IF ( this % gpuAccel ) THEN CALL UpdateSolution_Model2D_gpu_wrapper ( this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & dtLoc , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & dtLoc * this % dSdt % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateSolution_ECModel2D SUBROUTINE UpdateGAB2_ECModel2D ( this , m ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB2_Model2D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE ! ab2_weight IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Reset solution DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last solution this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & 1.5_PREC * this % prevSol % interior % hostData ( i , j , iVar , iEl ) - & 0.5_PREC * this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) END DO END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB2_ECModel2D SUBROUTINE UpdateGAB3_ECModel2D ( this , m ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB3_Model2D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 2 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & ( 2 3.0_PREC * this % prevSol % interior % hostData ( i , j , iVar , iEl ) - & 1 6.0_PREC * this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) + & 5.0_PREC * this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl )) / 1 2.0_PREC END DO END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB3_ECModel2D SUBROUTINE UpdateGAB4_ECModel2D ( this , m ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , nVar , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGAB4_Model2D_gpu_wrapper ( this % prevSol % interior % deviceData , & this % solution % interior % deviceData , & m , & this % prevsol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE IF ( m == 0 ) THEN ! Initialization step - store the solution in the prevSol at nvar+ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 1 ) THEN ! Initialization step - store the solution in the prevSol at ivar nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 2 ) THEN ! Initialization step - store the solution in the prevSol at ivar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSEIF ( m == 3 ) THEN ! Copy the solution back from the most recent prevsol DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % solution % interior % hostData ( i , j , iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ELSE ! Main looping section - nVar the previous solution, store the new solution, and ! create an interpolated solution to use for tendency calculation nVar = this % solution % nVar DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N ! Bump the last two stored solutions this % prevSol % interior % hostData ( i , j , 3 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) = this % prevSol % interior % hostData ( i , j , iVar , iEl ) ! Store the new solution this % prevSol % interior % hostData ( i , j , iVar , iEl ) = this % solution % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & ( 5 5.0_PREC * this % prevSol % interior % hostData ( i , j , iVar , iEl ) - & 5 9.0_PREC * this % prevSol % interior % hostData ( i , j , nVar + iVar , iEl ) + & 3 7.0_PREC * this % prevSol % interior % hostData ( i , j , 2 * nVar + iVar , iEl ) - & 9.0_PREC * this % prevSol % interior % hostData ( i , j , 3 * nVar + iVar , iEl )) / 2 4.0_PREC END DO END DO END DO END DO END IF END IF END SUBROUTINE UpdateGAB4_ECModel2D SUBROUTINE UpdateGRK2_ECModel2D ( this , m ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model2D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk2_a ( m ), rk2_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , iVar , iEl ) = rk2_a ( m ) * & this % workSol % interior % hostData ( i , j , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & rk2_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateGRK2_ECModel2D SUBROUTINE UpdateGRK3_ECModel2D ( this , m ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model2D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk3_a ( m ), rk3_g ( m ), this % dt , & this % worksol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , iVar , iEl ) = rk3_a ( m ) * & this % workSol % interior % hostData ( i , j , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & rk3_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateGRK3_ECModel2D SUBROUTINE UpdateGRK4_ECModel2D ( this , m ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: m ! Local INTEGER :: i , j , iVar , iEl IF ( this % gpuAccel ) THEN CALL UpdateGRK_Model2D_gpu_wrapper ( this % workSol % interior % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk4_a ( m ), rk4_g ( m ), this % dt , & this % workSol % nVar , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % workSol % interior % hostData ( i , j , iVar , iEl ) = rk4_a ( m ) * & this % workSol % interior % hostData ( i , j , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & rk4_g ( m ) * this % dt * this % workSol % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE UpdateGRK4_ECModel2D SUBROUTINE ReprojectFlux_ECModel2D ( this ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CALL this % flux % ContravariantProjection ( this % geometry , this % gpuAccel ) END SUBROUTINE ReprojectFlux_ECModel2D SUBROUTINE CalculateFluxDivergence_ECModel2D ( this ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CALL this % flux % Divergence ( this % geometry , & this % fluxDivergence , & selfWeakDGForm , & this % gpuAccel ) END SUBROUTINE CalculateFluxDivergence_ECModel2D SUBROUTINE UpdateBoundary_ECModel2D ( this ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CALL this % solution % BoundaryInterp ( this % gpuAccel ) CALL this % solution % SideExchange ( this % mesh , this % decomp , this % gpuAccel ) END SUBROUTINE UpdateBoundary_ECModel2D SUBROUTINE CalculateTendency_ECModel2D ( this ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this INTEGER :: i , j , iVar , iEl CALL this % PreTendency () CALL this % UpdateBoundary () CALL this % SetBoundaryCondition () CALL this % SourceMethod () CALL this % PreFlux () CALL this % RiemannSolver () CALL this % FluxMethod () CALL this % ReprojectFlux () CALL this % CalculateFluxDivergence () IF ( this % gpuAccel ) THEN CALL CalculateDSDt_Model2D_gpu_wrapper ( this % fluxDivergence % interior % deviceData , & this % source % interior % deviceData , & this % dSdt % interior % deviceData , & this % solution % interp % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % interp % N DO i = 0 , this % solution % interp % N this % dSdt % interior % hostData ( i , j , iVar , iEl ) = & this % source % interior % hostData ( i , j , iVar , iEl ) - & this % fluxDivergence % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE CalculateTendency_ECModel2D SUBROUTINE Write_ECModel2D ( this , fileName ) #undef __FUNC__ #define __FUNC__ \"Write_ECModel2D\" IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CHARACTER ( * ), OPTIONAL , INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId TYPE ( Scalar2D ) :: solution TYPE ( Vector2D ) :: x TYPE ( Lagrange ), TARGET :: interp CHARACTER ( LEN = self_FileNameLength ) :: pickupFile CHARACTER ( 13 ) :: timeStampString IF ( PRESENT ( filename )) THEN pickupFile = filename ELSE WRITE ( timeStampString , '(I13.13)' ) this % ioIterate pickupFile = 'solution.' // timeStampString // '.h5' END IF IF ( this % gpuAccel ) THEN CALL this % solution % UpdateHost () CALL this % solutionGradient % UpdateHost () END IF INFO ( \"Writing pickup file : \" // TRIM ( pickupFile )) IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId , this % decomp % mpiComm ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file INFO ( \"Writing control grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) ! Write the geometry to file CALL CreateGroup_HDF5 ( fileId , '/targetgrid/mesh' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/mesh/coords' , & this % decomp % offsetElem % hostData ( this % decomp % rankId ), this % decomp % nElem ) CALL Close_HDF5 ( fileId ) ELSE CALL Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) CALL this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid' ) CALL this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' ) ! Write the geometry to file INFO ( \"Writing control grid  geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) CALL this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Write the model state to file INFO ( \"Writing target grid solution to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid' ) CALL solution % WriteHDF5 ( fileId , '/targetgrid/solution' ) ! Write the geometry to file INFO ( \"Writing target grid geometry to file\" ) CALL CreateGroup_HDF5 ( fileId , '/targetgrid/geometry' ) CALL x % WriteHDF5 ( fileId , '/targetgrid/geometry/x' ) CALL Close_HDF5 ( fileId ) END IF CALL x % Free () CALL solution % Free () CALL interp % Free () END SUBROUTINE Write_ECModel2D SUBROUTINE Read_ECModel2D ( this , fileName ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 4 ) INTEGER :: firstElem INTEGER :: N IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % decomp % mpiComm ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) END IF ! CALL ReadAttribute_HDF5(fileId,'N',N) ! IF (this % solution % interp % N /= N) THEN !   STOP 'Error : Solution polynomial degree does not match input file' ! END IF IF ( this % decomp % mpiEnabled ) THEN firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 4 ) = ( / 0 , 0 , 1 , firstElem / ) CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , & this % solution % interior , solOffset ) ELSE CALL ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , this % solution % interior ) END IF CALL Close_HDF5 ( fileId ) IF ( this % gpuAccel ) THEN CALL this % solution % interior % UpdateDevice () END IF END SUBROUTINE Read_ECModel2D SUBROUTINE WriteTecplot_ECModel2D ( this , filename ) IMPLICIT NONE CLASS ( ECModel2D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ), OPTIONAL :: filename ! Local CHARACTER ( 8 ) :: zoneID INTEGER :: fUnit INTEGER :: iEl , i , j , iVar CHARACTER ( LEN = self_FileNameLength ) :: tecFile CHARACTER ( LEN = self_TecplotHeaderLength ) :: tecHeader CHARACTER ( LEN = self_FormatLength ) :: fmat CHARACTER ( 13 ) :: timeStampString CHARACTER ( 5 ) :: rankString TYPE ( Scalar2D ) :: solution TYPE ( Vector2D ) :: solutionGradient TYPE ( Vector2D ) :: x TYPE ( Lagrange ), TARGET :: interp IF ( PRESENT ( filename )) THEN tecFile = filename ELSE timeStampString = TimeStamp ( this % t , 's' ) IF ( this % decomp % mpiEnabled ) THEN WRITE ( rankString , '(I5.5)' ) this % decomp % rankId tecFile = 'solution.' // rankString // '.' // timeStampString // '.tec' ELSE tecFile = 'solution.' // timeStampString // '.tec' END IF END IF ! Create an interpolant for the uniform grid CALL interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) CALL solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL solutionGradient % Init ( interp , & this % solution % nVar , this % solution % nElem ) CALL x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid CALL this % geometry % x % GridInterp ( x , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solution % GridInterp ( solution , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL this % solutionGradient % GridInterp ( solutionGradient , gpuAccel = . FALSE .) OPEN ( UNIT = NEWUNIT ( fUnit ), & FILE = TRIM ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) tecHeader = 'VARIABLES = \"X\", \"Y\"' DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"' // TRIM ( this % solution % meta ( iVar ) % name ) // '\"' END DO DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"d/dx(' // TRIM ( this % solution % meta ( iVar ) % name ) // ')\"' END DO DO iVar = 1 , this % solution % nVar tecHeader = TRIM ( tecHeader ) // ', \"d/dy(' // TRIM ( this % solution % meta ( iVar ) % name ) // ')\"' END DO WRITE ( fUnit , * ) TRIM ( tecHeader ) ! Create format statement WRITE ( fmat , * ) 3 * this % solution % nvar + 2 fmat = '(' // TRIM ( fmat ) // '(ES16.7E3,1x))' DO iEl = 1 , this % solution % nElem ! TO DO :: Get the global element ID WRITE ( zoneID , '(I8.8)' ) iEl WRITE ( fUnit , * ) 'ZONE T=\"el' // TRIM ( zoneID ) // '\", I=' , this % solution % interp % M + 1 , & ', J=' , this % solution % interp % M + 1 DO j = 0 , this % solution % interp % M DO i = 0 , this % solution % interp % M WRITE ( fUnit , fmat ) x % interior % hostData ( 1 , i , j , 1 , iEl ), & x % interior % hostData ( 2 , i , j , 1 , iEl ), & solution % interior % hostData ( i , j , 1 : this % solution % nvar , iEl ), & solutionGradient % interior % hostData ( 1 , i , j , 1 : this % solution % nvar , iEl ), & solutionGradient % interior % hostData ( 2 , i , j , 1 : this % solution % nvar , iEl ) END DO END DO END DO CLOSE ( UNIT = fUnit ) CALL x % Free () CALL solution % Free () CALL solutionGradient % Free () CALL interp % Free () END SUBROUTINE WriteTecplot_ECModel2D END MODULE SELF_ECModel2D","tags":"","loc":"sourcefile/self_ecmodel2d.f90.html"}]}