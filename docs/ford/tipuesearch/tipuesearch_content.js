var tipuesearch = {"pages":[{"title":" SELF ","text":"SELF Developer Info Joe Schoonover Committed to service for science","tags":"home","loc":"index.html"},{"title":"DGModel3D_t – SELF ","text":"type, public, extends( Model ) :: DGModel3D_t Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetSolutionFromChar_DGModel3D_t SetSolutionFromEqn_DGModel3D_t SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code DGModel3D_t Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D_t public subroutine BoundaryFlux_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D_t public subroutine CalculateEntropy_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D_t public subroutine CalculateSolutionGradient_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel3D_t public subroutine CalculateTendency_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel3D_t public subroutine fluxmethod_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel3D_t public subroutine Free_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel3D_t public subroutine Init_DGModel3D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh3D ), intent(in), target :: mesh type( SEMHex ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel3D_t public subroutine Read_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D_t public subroutine setboundarycondition_DGModel3D_t (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D_t public subroutine setgradientboundarycondition_DGModel3D_t (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel3D_t public subroutine SetMetadata_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t , SetSolutionFromEqn_DGModel3D_t public subroutine SetSolutionFromChar_DGModel3D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel3D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) procedure, private :: SetSolutionFromChar_DGModel3D_t public subroutine SetSolutionFromChar_DGModel3D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) procedure, private :: SetSolutionFromEqn_DGModel3D_t public subroutine SetSolutionFromEqn_DGModel3D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel3D_t public subroutine sourcemethod_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D_t public subroutine UpdateGRK2_DGModel3D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D_t public subroutine UpdateGRK3_DGModel3D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D_t public subroutine UpdateGRK4_DGModel3D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel3D_t public subroutine UpdateSolution_DGModel3D_t (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel3D_t public subroutine Write_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t public subroutine WriteTecplot_DGModel3D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( Model ) :: DGModel3D_t type ( MappedScalar3D ) :: solution type ( MappedVector3D ) :: solutionGradient type ( MappedVector3D ) :: flux type ( MappedScalar3D ) :: source type ( MappedScalar3D ) :: fluxDivergence type ( MappedScalar3D ) :: dSdt type ( MappedScalar3D ) :: workSol type ( Mesh3D ), pointer :: mesh type ( SEMHex ), pointer :: geometry contains procedure :: Init => Init_DGModel3D_t procedure :: SetMetadata => SetMetadata_DGModel3D_t procedure :: Free => Free_DGModel3D_t procedure :: CalculateEntropy => CalculateEntropy_DGModel3D_t procedure :: BoundaryFlux => BoundaryFlux_DGModel3D_t procedure :: FluxMethod => fluxmethod_DGModel3D_t procedure :: SourceMethod => sourcemethod_DGModel3D_t procedure :: SetBoundaryCondition => setboundarycondition_DGModel3D_t procedure :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D_t procedure :: UpdateSolution => UpdateSolution_DGModel3D_t procedure :: UpdateGRK2 => UpdateGRK2_DGModel3D_t procedure :: UpdateGRK3 => UpdateGRK3_DGModel3D_t procedure :: UpdateGRK4 => UpdateGRK4_DGModel3D_t procedure :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D_t procedure :: CalculateTendency => CalculateTendency_DGModel3D_t generic :: SetSolution => SetSolutionFromChar_DGModel3D_t , & SetSolutionFromEqn_DGModel3D_t procedure , private :: SetSolutionFromChar_DGModel3D_t procedure , private :: SetSolutionFromEqn_DGModel3D_t procedure :: ReadModel => Read_DGModel3D_t procedure :: WriteModel => Write_DGModel3D_t procedure :: WriteTecplot => WriteTecplot_DGModel3D_t endtype DGModel3D_t","tags":"","loc":"type/dgmodel3d_t.html"},{"title":"advection_diffusion_2d_t – SELF ","text":"type, public, extends( DGModel2D ) :: advection_diffusion_2d_t Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nu nvar solution solutionGradient source t timeIntegrator u v workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2d flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code advection_diffusion_2d_t Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D public subroutine BoundaryFlux_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D public subroutine CalculateEntropy_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D public subroutine CalculateSolutionGradient_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel2D public subroutine CalculateTendency_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel2D public subroutine fluxmethod_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel2D_t public subroutine Free_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel2D_t public subroutine Init_DGModel2D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), target :: mesh type( SEMQuad ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel2D_t public subroutine Read_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D public subroutine setboundarycondition_DGModel2D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D public subroutine setgradientboundarycondition_DGModel2D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel2D_t public subroutine SetMetadata_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t , SetSolutionFromEqn_DGModel2D_t public subroutine SetSolutionFromChar_DGModel2D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel2D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel2D public subroutine sourcemethod_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D public subroutine UpdateGRK2_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D public subroutine UpdateGRK3_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D public subroutine UpdateGRK4_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel2D public subroutine UpdateSolution_DGModel2D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel2D_t public subroutine Write_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t public subroutine WriteTecplot_DGModel2D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_advection_diffusion_2d_t public pure function entropy_func_advection_diffusion_2d_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2d => flux2d_advection_diffusion_2d_t public pure function flux2d_advection_diffusion_2d_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar,1:2) Return Value real(kind=prec)(1:this%solution%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_advection_diffusion_2d_t public pure function riemannflux2d_advection_diffusion_2d_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( dgmodel2d ) :: advection_diffusion_2d_t real ( prec ) :: nu ! diffusion coefficient real ( prec ) :: u ! constant x-component of velocity real ( prec ) :: v ! constant y-component of velocity contains procedure :: riemannflux2d => riemannflux2d_advection_diffusion_2d_t procedure :: flux2d => flux2d_advection_diffusion_2d_t procedure :: entropy_func => entropy_func_advection_diffusion_2d_t endtype advection_diffusion_2d_t","tags":"","loc":"type/advection_diffusion_2d_t.html"},{"title":"Scalar2D_t – SELF ","text":"type, public, extends( SELF_DataObj ) :: Scalar2D_t Contents Variables M N avgBoundary boundary boundarynormal eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Free Gradient Gradient_Scalar2D_t GridInterp GridInterp_Scalar2D_t Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 WriteHDF5_MPI_Scalar2D_t WriteHDF5_Scalar2D_t Source Code Scalar2D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: avgBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundarynormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar2D_t public subroutine AverageSides_Scalar2D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D_t public subroutine BoundaryInterp_Scalar2D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this procedure, public :: Free => Free_Scalar2D_t public subroutine Free_Scalar2D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this generic, public :: Gradient => Gradient_Scalar2D_t public subroutine Gradient_Scalar2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) procedure, private :: Gradient_Scalar2D_t public subroutine Gradient_Scalar2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) generic, public :: GridInterp => GridInterp_Scalar2D_t public subroutine GridInterp_Scalar2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) procedure, private :: GridInterp_Scalar2D_t public subroutine GridInterp_Scalar2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) procedure, public :: Init => Init_Scalar2D_t public subroutine Init_Scalar2D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Scalar2D_t public subroutine UpdateDevice_Scalar2D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar2D_t public subroutine UpdateHost_Scalar2D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D_t , WriteHDF5_Scalar2D_t public subroutine WriteHDF5_MPI_Scalar2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group procedure, private :: WriteHDF5_MPI_Scalar2D_t public subroutine WriteHDF5_MPI_Scalar2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem procedure, private :: WriteHDF5_Scalar2D_t public subroutine WriteHDF5_Scalar2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( SELF_DataObj ), public :: Scalar2D_t real ( prec ), pointer , contiguous , dimension (:,:,:,:) :: interior real ( prec ), pointer , contiguous , dimension (:,:,:,:) :: boundary real ( prec ), pointer , contiguous , dimension (:,:,:,:) :: extBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:) :: avgBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:) :: boundarynormal contains procedure , public :: Init => Init_Scalar2D_t procedure , public :: Free => Free_Scalar2D_t procedure , public :: UpdateHost => UpdateHost_Scalar2D_t procedure , public :: UpdateDevice => UpdateDevice_Scalar2D_t procedure , public :: BoundaryInterp => BoundaryInterp_Scalar2D_t procedure , public :: AverageSides => AverageSides_Scalar2D_t generic , public :: GridInterp => GridInterp_Scalar2D_t procedure , private :: GridInterp_Scalar2D_t generic , public :: Gradient => Gradient_Scalar2D_t procedure , private :: Gradient_Scalar2D_t generic , public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D_t , WriteHDF5_Scalar2D_t procedure , private :: WriteHDF5_MPI_Scalar2D_t procedure , private :: WriteHDF5_Scalar2D_t endtype Scalar2D_t","tags":"","loc":"type/scalar2d_t.html"},{"title":"DGModel2D_t – SELF ","text":"type, public, extends( Model ) :: DGModel2D_t Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetSolutionFromChar_DGModel2D_t SetSolutionFromEqn_DGModel2D_t SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code DGModel2D_t Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D_t public subroutine BoundaryFlux_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D_t public subroutine CalculateEntropy_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D_t public subroutine CalculateSolutionGradient_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel2D_t public subroutine CalculateTendency_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel2D_t public subroutine fluxmethod_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel2D_t public subroutine Free_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel2D_t public subroutine Init_DGModel2D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), target :: mesh type( SEMQuad ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel2D_t public subroutine Read_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D_t public subroutine setboundarycondition_DGModel2D_t (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D_t public subroutine setgradientboundarycondition_DGModel2D_t (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel2D_t public subroutine SetMetadata_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t , SetSolutionFromEqn_DGModel2D_t public subroutine SetSolutionFromChar_DGModel2D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel2D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) procedure, private :: SetSolutionFromChar_DGModel2D_t public subroutine SetSolutionFromChar_DGModel2D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) procedure, private :: SetSolutionFromEqn_DGModel2D_t public subroutine SetSolutionFromEqn_DGModel2D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel2D_t public subroutine sourcemethod_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D_t public subroutine UpdateGRK2_DGModel2D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D_t public subroutine UpdateGRK3_DGModel2D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D_t public subroutine UpdateGRK4_DGModel2D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel2D_t public subroutine UpdateSolution_DGModel2D_t (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel2D_t public subroutine Write_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t public subroutine WriteTecplot_DGModel2D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( Model ) :: DGModel2D_t type ( MappedScalar2D ) :: solution type ( MappedVector2D ) :: solutionGradient type ( MappedVector2D ) :: flux type ( MappedScalar2D ) :: source type ( MappedScalar2D ) :: fluxDivergence type ( MappedScalar2D ) :: dSdt type ( MappedScalar2D ) :: workSol type ( Mesh2D ), pointer :: mesh type ( SEMQuad ), pointer :: geometry contains procedure :: Init => Init_DGModel2D_t procedure :: SetMetadata => SetMetadata_DGModel2D_t procedure :: Free => Free_DGModel2D_t procedure :: CalculateEntropy => CalculateEntropy_DGModel2D_t procedure :: BoundaryFlux => BoundaryFlux_DGModel2D_t procedure :: FluxMethod => fluxmethod_DGModel2D_t procedure :: SourceMethod => sourcemethod_DGModel2D_t procedure :: SetBoundaryCondition => setboundarycondition_DGModel2D_t procedure :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D_t procedure :: UpdateSolution => UpdateSolution_DGModel2D_t procedure :: UpdateGRK2 => UpdateGRK2_DGModel2D_t procedure :: UpdateGRK3 => UpdateGRK3_DGModel2D_t procedure :: UpdateGRK4 => UpdateGRK4_DGModel2D_t procedure :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D_t procedure :: CalculateTendency => CalculateTendency_DGModel2D_t generic :: SetSolution => SetSolutionFromChar_DGModel2D_t , & SetSolutionFromEqn_DGModel2D_t procedure , private :: SetSolutionFromChar_DGModel2D_t procedure , private :: SetSolutionFromEqn_DGModel2D_t procedure :: ReadModel => Read_DGModel2D_t procedure :: WriteModel => Write_DGModel2D_t procedure :: WriteTecplot => WriteTecplot_DGModel2D_t endtype DGModel2D_t","tags":"","loc":"type/dgmodel2d_t.html"},{"title":"MappedScalar1D_t – SELF ","text":"type, public, extends( Scalar1D ) :: MappedScalar1D_t Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundary_gpu boundarynormal boundarynormal_gpu eqn extBoundary extBoundary_gpu geometry geometry_associated interior interior_gpu interp meta nElem nVar Type-Bound Procedures AssociateGeometry AverageSides BoundaryInterp Derivative DissociateGeometry Free GridInterp Init MappedDGDerivative MappedDGDerivative_MappedScalar1D_t MappedDerivative MappedDerivative_MappedScalar1D_t SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedScalar1D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( Geometry1D ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar1D_t public subroutine AssociateGeometry_MappedScalar1D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this type( Geometry1D ), intent(in), target :: geometry procedure, public :: AverageSides => AverageSides_Scalar1D public subroutine AverageSides_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D public subroutine BoundaryInterp_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this generic, public :: Derivative => Derivative_Scalar1D_t , Derivative_Scalar1D public subroutine Derivative_Scalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Derivative_Scalar1D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar1D_t public subroutine DissociateGeometry_MappedScalar1D_t (this) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this procedure, public :: Free => Free_Scalar1D public subroutine Free_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this generic, public :: GridInterp => GridInterp_Scalar1D_t , GridInterp_Scalar1D public subroutine GridInterp_Scalar1D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%nelem,1:this%nvar) public subroutine GridInterp_Scalar1D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Scalar1D public subroutine Init_Scalar1D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: MappedDGDerivative => MappedDGDerivative_MappedScalar1D_t public subroutine MappedDGDerivative_MappedScalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%nelem,1:this%nvar) procedure, private :: MappedDGDerivative_MappedScalar1D_t public subroutine MappedDGDerivative_MappedScalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%nelem,1:this%nvar) generic, public :: MappedDerivative => MappedDerivative_MappedScalar1D_t public subroutine MappedDerivative_MappedScalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%nelem,1:this%nvar) procedure, private :: MappedDerivative_MappedScalar1D_t public subroutine MappedDerivative_MappedScalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar1D_t public subroutine SetInteriorFromEquation_MappedScalar1D_t (this, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedScalar1D_t public subroutine SideExchange_MappedScalar1D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this type( Mesh1D ), intent(inout) :: mesh procedure, public :: UpdateDevice => UpdateDevice_Scalar1D public subroutine UpdateDevice_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar1D public subroutine UpdateHost_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_Scalar1D_t public subroutine WriteHDF5_Scalar1D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Scalar1D ), public :: MappedScalar1D_t logical :: geometry_associated = . false . type ( Geometry1D ), pointer :: geometry => null () contains procedure , public :: AssociateGeometry => AssociateGeometry_MappedScalar1D_t procedure , public :: DissociateGeometry => DissociateGeometry_MappedScalar1D_t procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar1D_t procedure , public :: SideExchange => SideExchange_MappedScalar1D_t generic , public :: MappedDerivative => MappedDerivative_MappedScalar1D_t procedure , private :: MappedDerivative_MappedScalar1D_t generic , public :: MappedDGDerivative => MappedDGDerivative_MappedScalar1D_t procedure , private :: MappedDGDerivative_MappedScalar1D_t endtype MappedScalar1D_t","tags":"","loc":"type/mappedscalar1d_t.html"},{"title":"Geometry1D – SELF ","text":"type, public :: Geometry1D Contents Variables dxds nElem x Type-Bound Procedures CalculateMetricTerms Free GenerateFromMesh Init write Source Code Geometry1D Components Type Visibility Attributes Name Initial type( Scalar1D ), public :: dxds integer, public :: nElem type( Scalar1D ), public :: x Type-Bound Procedures procedure, public :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D public subroutine CalculateMetricTerms_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom procedure, public :: Free => Free_Geometry1D public subroutine Free_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom procedure, public :: GenerateFromMesh => GenerateFromMesh_Geometry1D public subroutine GenerateFromMesh_Geometry1D (myGeom, mesh) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom type( Mesh1D ), intent(in) :: mesh procedure, public :: Init => Init_Geometry1D public subroutine Init_Geometry1D (myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom type( Lagrange ), intent(in), pointer :: interp integer, intent(in) :: nElem procedure, public :: write => Write_Geometry1D public subroutine Write_Geometry1D (myGeom, fileName) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(in) :: myGeom character, intent(in), optional :: fileName Source Code type , public :: Geometry1D type ( Scalar1D ) :: x ! Physical Positions type ( Scalar1D ) :: dxds ! Conversion from computational to physical space integer :: nElem contains procedure , public :: Init => Init_Geometry1D procedure , public :: Free => Free_Geometry1D procedure , public :: GenerateFromMesh => GenerateFromMesh_Geometry1D procedure , public :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D procedure :: write => Write_Geometry1D endtype Geometry1D","tags":"","loc":"type/geometry1d.html"},{"title":"Model – SELF ","text":"type, public, abstract :: Model Contents Variables dt entropy gradient_enabled ioIterate nvar t timeIntegrator Type-Bound Procedures CalculateEntropy CalculateTendency Euler_timeIntegrator ForwardStep GetSimulationTime IncrementIOCounter LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetSimulationTime SetTimeIntegrator SetTimeIntegrator_withChar UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code Model Components Type Visibility Attributes Name Initial real(kind=prec), public :: dt real(kind=prec), public :: entropy logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 integer, public :: nvar real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator Type-Bound Procedures procedure, public :: CalculateEntropy => CalculateEntropy_Model public subroutine CalculateEntropy_Model (this) Base method for calculating entropy of a model\nWhen this method is not overridden, the entropy\nis simply set to 0.0. When you develop a model\nbuilt on top of this abstract class or one of its\nchildren, it is recommended that you define a\nconvex mathematical entropy function that is used\nas a measure of the model stability. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure( CalculateTendency ), public, deferred :: CalculateTendency subroutine CalculateTendency(this) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure( ReadModel ), public, deferred :: ReadModel subroutine ReadModel(this, filename) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: filename procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, private :: SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure( UpdateGRK ), public, deferred :: UpdateGRK2 subroutine UpdateGRK(this, m) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m procedure( UpdateGRK ), public, deferred :: UpdateGRK3 subroutine UpdateGRK(this, m) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m procedure( UpdateGRK ), public, deferred :: UpdateGRK4 subroutine UpdateGRK(this, m) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m procedure( UpdateSolution ), public, deferred :: UpdateSolution subroutine UpdateSolution(this, dt) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure( WriteModel ), public, deferred :: WriteModel subroutine WriteModel(this, filename) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in), optional :: filename procedure( WriteTecplot ), public, deferred :: WriteTecplot subroutine WriteTecplot(this, filename) Prototype Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , abstract :: Model ! Time integration attributes procedure ( SELF_timeIntegrator ), pointer :: timeIntegrator => Euler_timeIntegrator real ( prec ) :: dt real ( prec ) :: t integer :: ioIterate = 0 logical :: gradient_enabled = . false . integer :: nvar ! Standard Diagnostics real ( prec ) :: entropy ! Mathematical entropy function for the model contains procedure :: IncrementIOCounter procedure :: PrintType => PrintType_Model procedure :: ForwardStep => ForwardStep_Model procedure :: Euler_timeIntegrator ! Runge-Kutta methods procedure :: LowStorageRK2_timeIntegrator procedure ( UpdateGRK ), deferred :: UpdateGRK2 procedure :: LowStorageRK3_timeIntegrator procedure ( UpdateGRK ), deferred :: UpdateGRK3 procedure :: LowStorageRK4_timeIntegrator procedure ( UpdateGRK ), deferred :: UpdateGRK4 procedure :: PreTendency => PreTendency_Model procedure :: entropy_func => entropy_func_Model procedure :: flux1D => flux1d_Model procedure :: flux2D => flux2d_Model procedure :: flux3D => flux3d_Model procedure :: riemannflux1d => riemannflux1d_Model procedure :: riemannflux2d => riemannflux2d_Model procedure :: riemannflux3d => riemannflux3d_Model procedure :: source1d => source1d_Model procedure :: source2d => source2d_Model procedure :: source3d => source3d_Model ! Boundary condition functions (hyperbolic) procedure :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure :: hbc1d_Radiation => hbc1d_Generic_Model procedure :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure :: hbc2d_Radiation => hbc2d_Generic_Model procedure :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure :: hbc3d_Radiation => hbc3d_Generic_Model procedure :: hbc3d_NoNormalFlow => hbc3d_Generic_Model ! Boundary condition functions (parabolic) procedure :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure :: pbc1d_Radiation => pbc1d_Generic_Model procedure :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure :: pbc2d_Radiation => pbc2d_Generic_Model procedure :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure :: pbc3d_Radiation => pbc3d_Generic_Model procedure :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure :: ReportEntropy => ReportEntropy_Model procedure :: CalculateEntropy => CalculateEntropy_Model procedure ( UpdateSolution ), deferred :: UpdateSolution procedure ( CalculateTendency ), deferred :: CalculateTendency procedure ( ReadModel ), deferred :: ReadModel procedure ( WriteModel ), deferred :: WriteModel procedure ( WriteTecplot ), deferred :: WriteTecplot generic :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure , private :: SetTimeIntegrator_withChar procedure :: SetSimulationTime procedure :: GetSimulationTime endtype Model","tags":"","loc":"type/model.html"},{"title":"Mesh2D_t – SELF ","text":"type, public, extends( SEMMesh ) :: Mesh2D_t Contents Variables BCNames BCType CGNSCornerMap CGNSSideMap decomp elemInfo globalNodeIDs nBCs nCornerNodes nElem nGeo nGlobalElem nNodes nSides nUniqueNodes nUniqueSides nodeCoords quadrature sideInfo Type-Bound Procedures Free Init Read_HOPr RecalculateFlip ResetBoundaryConditionType StructuredMesh UniformStructuredMesh_Mesh2D_t Write_Mesh Source Code Mesh2D_t Components Type Visibility Attributes Name Initial character(len=255), public, allocatable :: BCNames (:) integer, public, pointer, dimension(:,:) :: BCType integer, public, pointer, dimension(:,:) :: CGNSCornerMap integer, public, pointer, dimension(:,:) :: CGNSSideMap type( DomainDecomposition ), public :: decomp integer, public, pointer, dimension(:,:) :: elemInfo integer, public, pointer, dimension(:,:,:) :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides real(kind=prec), public, pointer, dimension(:,:,:,:) :: nodeCoords integer, public :: quadrature integer, public, pointer, dimension(:,:,:) :: sideInfo Type-Bound Procedures procedure, public :: Free => Free_Mesh2D_t public subroutine Free_Mesh2D_t (this) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this procedure, public :: Init => Init_Mesh2D_t public subroutine Init_Mesh2D_t (this, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs procedure, public :: Read_HOPr => Read_HOPr_Mesh2D_t public subroutine Read_HOPr_Mesh2D_t (this, meshFile, enableDomainDecomposition) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(out) :: this character, intent(in) :: meshFile logical, intent(in), optional :: enableDomainDecomposition procedure, public :: RecalculateFlip => RecalculateFlip_Mesh2D_t public subroutine RecalculateFlip_Mesh2D_t (this) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh2D_t public subroutine ResetBoundaryConditionType_Mesh2D_t (this, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Read more… Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this integer, intent(in) :: bcid generic, public :: StructuredMesh => UniformStructuredMesh_Mesh2D_t public subroutine UniformStructuredMesh_Mesh2D_t (this, nxPerTile, nyPerTile, nTileX, nTileY, dx, dy, bcids, enableDomainDecomposition) Create a structured mesh and store it in SELF's unstructured mesh format.\nThe mesh is created in tiles of size (tnx,tny). Tiling is used to determine\nthe element ordering. Read more… Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(out) :: this integer, intent(in) :: nxPerTile integer, intent(in) :: nyPerTile integer, intent(in) :: nTileX integer, intent(in) :: nTileY real(kind=prec), intent(in) :: dx real(kind=prec), intent(in) :: dy integer, intent(in) :: bcids (1:4) logical, intent(in), optional :: enableDomainDecomposition procedure, private :: UniformStructuredMesh_Mesh2D_t public subroutine UniformStructuredMesh_Mesh2D_t (this, nxPerTile, nyPerTile, nTileX, nTileY, dx, dy, bcids, enableDomainDecomposition) Create a structured mesh and store it in SELF's unstructured mesh format.\nThe mesh is created in tiles of size (tnx,tny). Tiling is used to determine\nthe element ordering. Read more… Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(out) :: this integer, intent(in) :: nxPerTile integer, intent(in) :: nyPerTile integer, intent(in) :: nTileX integer, intent(in) :: nTileY real(kind=prec), intent(in) :: dx real(kind=prec), intent(in) :: dy integer, intent(in) :: bcids (1:4) logical, intent(in), optional :: enableDomainDecomposition procedure, public :: Write_Mesh => Write_Mesh2D_t public subroutine Write_Mesh2D_t (this, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this character, intent(in) :: meshFile Source Code type , extends ( SEMMesh ) :: Mesh2D_t integer , pointer , dimension (:,:,:) :: sideInfo real ( prec ), pointer , dimension (:,:,:,:) :: nodeCoords integer , pointer , dimension (:,:) :: elemInfo integer , pointer , dimension (:,:,:) :: globalNodeIDs integer , pointer , dimension (:,:) :: CGNSCornerMap integer , pointer , dimension (:,:) :: CGNSSideMap integer , pointer , dimension (:,:) :: BCType character ( LEN = 255 ), allocatable :: BCNames (:) contains procedure , public :: Init => Init_Mesh2D_t procedure , public :: Free => Free_Mesh2D_t generic , public :: StructuredMesh => UniformStructuredMesh_Mesh2D_t procedure , private :: UniformStructuredMesh_Mesh2D_t procedure , public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh2D_t procedure , public :: Read_HOPr => Read_HOPr_Mesh2D_t procedure , public :: Write_Mesh => Write_Mesh2D_t procedure , public :: RecalculateFlip => RecalculateFlip_Mesh2D_t endtype Mesh2D_t","tags":"","loc":"type/mesh2d_t.html"},{"title":"SEMQuad – SELF ","text":"type, public :: SEMQuad Contents Variables J dsdx dxds nElem nHat nScale x Type-Bound Procedures CalculateContravariantBasis CalculateMetricTerms Free GenerateFromMesh Init WriteTecplot Source Code SEMQuad Components Type Visibility Attributes Name Initial type( Scalar2D ), public :: J type( Tensor2D ), public :: dsdx type( Tensor2D ), public :: dxds integer, public :: nElem type( Vector2D ), public :: nHat type( Scalar2D ), public :: nScale type( Vector2D ), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad public subroutine CalculateContravariantBasis_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad public subroutine CalculateMetricTerms_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom procedure, public :: Free => Free_SEMQuad public subroutine Free_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMQuad public subroutine GenerateFromMesh_SEMQuad (myGeom, mesh) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom type( Mesh2D ), intent(in) :: mesh procedure, public :: Init => Init_SEMQuad public subroutine Init_SEMQuad (myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom type( Lagrange ), intent(in), pointer :: interp integer, intent(in) :: nElem procedure, public :: WriteTecplot => WriteTecplot_SEMQuad public subroutine WriteTecplot_SEMQuad (this, filename) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: this character, intent(in) :: filename Source Code type , public :: SEMQuad type ( Vector2D ) :: x ! Physical positions type ( Tensor2D ) :: dxds ! Covariant basis vectors type ( Tensor2D ) :: dsdx ! Contavariant basis vectors type ( Vector2D ) :: nHat ! Normal Vectors pointing across coordinate lines type ( Scalar2D ) :: nScale ! Boundary scale type ( Scalar2D ) :: J ! Jacobian of the transformation integer :: nElem contains procedure , public :: Init => Init_SEMQuad procedure , public :: Free => Free_SEMQuad procedure , public :: GenerateFromMesh => GenerateFromMesh_SEMQuad procedure , public :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad procedure , private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad procedure , public :: WriteTecplot => WriteTecplot_SEMQuad endtype SEMQuad","tags":"","loc":"type/semquad.html"},{"title":"NullDGModel1D_t – SELF ","text":"type, public, extends( DGModel1D ) :: NullDGModel1D_t Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code NullDGModel1D_t Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D public subroutine BoundaryFlux_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D public subroutine CalculateEntropy_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D public subroutine CalculateSolutionGradient_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel1D public subroutine CalculateTendency_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel1D public subroutine fluxmethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel1D_t public subroutine Free_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel1D_t public subroutine Init_DGModel1D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), target :: mesh type( Geometry1D ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel1D_t public subroutine Read_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D public subroutine setboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D public subroutine setgradientboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel1D_t public subroutine SetMetadata_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t , SetSolutionFromEqn_DGModel1D_t public subroutine SetSolutionFromChar_DGModel1D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel1D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel1D public subroutine sourcemethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D public subroutine UpdateGRK2_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D public subroutine UpdateGRK3_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D public subroutine UpdateGRK4_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel1D public subroutine UpdateSolution_DGModel1D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel1D_t public subroutine Write_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t public subroutine WriteTecplot_DGModel1D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( dgmodel1d ) :: NullDGModel1D_t ! Add any additional attributes here that are specific to your model contains !   procedure :: hbc1d_Prescribed => hbc1d_Prescribed_Model !   procedure :: hbc1d_Radiation => hbc1d_Generic_Model !   procedure :: hbc1d_NoNormalFlow => hbc1d_Generic_Model !   procedure :: pbc1d_Prescribed => pbc1d_Prescribed_Model !   procedure :: pbc1d_Radiation => pbc1d_Generic_Model !   procedure :: pbc1d_NoNormalFlow => pbc1d_Generic_Model !   procedure :: SetMetadata => SetMetadata_NullDGModel1D_t !   procedure :: pretendency => pretendency_NullDGModel1D_t !   procedure :: entropy_func => entropy_func_NullDGModel1D_t !   procedure :: flux1d => flux1d_NullDGModel1D_t !   procedure :: riemannflux1d => riemannflux1d_NullDGModel1D_t !   procedure :: source1d => source1d_NullDGModel1D_t endtype NullDGModel1D_t","tags":"","loc":"type/nulldgmodel1d_t.html"},{"title":"Metadata – SELF ","text":"type, public :: Metadata Contents Variables description name units Type-Bound Procedures SetDescription SetName SetUnits WriteHDF5 Source Code Metadata Components Type Visibility Attributes Name Initial character, public :: description character, public :: name character, public :: units Type-Bound Procedures procedure, public :: SetDescription => SetDescription_Metadata public subroutine SetDescription_Metadata (mtd, description) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: description procedure, public :: SetName => SetName_Metadata public subroutine SetName_Metadata (mtd, name) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: name procedure, public :: SetUnits => SetUnits_Metadata public subroutine SetUnits_Metadata (mtd, units) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: units procedure, public :: WriteHDF5 => WriteHDF5_Metadata public subroutine WriteHDF5_Metadata (mtd, group, varid, fileId) Writes the metadata to a HDF5 file using the\nfields :\n * /metadata/{group}/name/{varid} * /metadata/{group}/description/{varid} * /metadata/{group}/units/{varid} Read more… Arguments Type Intent Optional Attributes Name class( Metadata ), intent(in) :: mtd character, intent(in) :: group integer, intent(in) :: varid integer(kind=HID_T), intent(in) :: fileId Source Code type Metadata character ( SELF_MTD_NameLength ) :: name character ( SELF_MTD_DescriptionLength ) :: description character ( SELF_MTD_UnitsLength ) :: units contains procedure , public :: SetName => SetName_Metadata procedure , public :: SetDescription => SetDescription_Metadata procedure , public :: SetUnits => SetUnits_Metadata procedure , public :: WriteHDF5 => WriteHDF5_Metadata endtype Metadata","tags":"","loc":"type/metadata.html"},{"title":"MappedVector3D_t – SELF ","text":"type, public, extends( Vector3D ) :: MappedVector3D_t Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundaryNormal boundaryNormal_gpu boundary_gpu eqn extBoundary extBoundary_gpu geometry geometry_associated interior interior_gpu interp interpWork1 interpWork2 meta nElem nVar Type-Bound Procedures ApplyFlip AssociateGeometry AverageSides BoundaryInterp Curl DissociateGeometry Divergence Free Gradient GridInterp Init MPIExchangeAsync MappedDGDivergence MappedDGDivergence_MappedVector3D_t MappedDivergence MappedDivergence_MappedVector3D_t SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedVector3D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMHex ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedVector3D_t public subroutine ApplyFlip_MappedVector3D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh procedure, public :: AssociateGeometry => AssociateGeometry_MappedVector3D_t public subroutine AssociateGeometry_MappedVector3D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( SEMHex ), intent(in), target :: geometry procedure, public :: AverageSides => AverageSides_Vector3D public subroutine AverageSides_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D public subroutine BoundaryInterp_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this generic, public :: Curl => Curl_Vector3D_t public subroutine Curl_Vector3D_t (this, curlf) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: curlf (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) procedure, public :: DissociateGeometry => DissociateGeometry_MappedVector3D_t public subroutine DissociateGeometry_MappedVector3D_t (this) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this generic, public :: Divergence => Divergence_Vector3D_t , Divergence_Vector3D public subroutine Divergence_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Divergence_Vector3D (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, public :: Free => Free_Vector3D public subroutine Free_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this generic, public :: Gradient => Gradient_Vector3D_t , Gradient_Vector3D public subroutine Gradient_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3,1:3) public subroutine Gradient_Vector3D (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Vector3D_t , GridInterp_Vector3D public subroutine GridInterp_Vector3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:3) (Output) Array of function values, defined on the target grid public subroutine GridInterp_Vector3D (this, f) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Vector3D public subroutine Init_Vector3D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D_t public subroutine MPIExchangeAsync_MappedVector3D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh generic, public :: MappedDGDivergence => MappedDGDivergence_MappedVector3D_t public subroutine MappedDGDivergence_MappedVector3D_t (this, df) Computes the divergence of a 3-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, private :: MappedDGDivergence_MappedVector3D_t public subroutine MappedDGDivergence_MappedVector3D_t (this, df) Computes the divergence of a 3-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) generic, public :: MappedDivergence => MappedDivergence_MappedVector3D_t public subroutine MappedDivergence_MappedVector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, private :: MappedDivergence_MappedVector3D_t public subroutine MappedDivergence_MappedVector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector3D_t public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector3D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector3D_t public subroutine SetInteriorFromEquation_MappedVector3D_t (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedVector3D_t public subroutine SideExchange_MappedVector3D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh procedure, public :: UpdateDevice => UpdateDevice_Vector3D public subroutine UpdateDevice_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Vector3D public subroutine UpdateHost_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D_t , WriteHDF5_Vector3D_t public subroutine WriteHDF5_MPI_Vector3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Vector3D ), public :: MappedVector3D_t logical :: geometry_associated = . false . type ( SEMHex ), pointer :: geometry => null () contains procedure , public :: AssociateGeometry => AssociateGeometry_MappedVector3D_t procedure , public :: DissociateGeometry => DissociateGeometry_MappedVector3D_t procedure , public :: SideExchange => SideExchange_MappedVector3D_t generic , public :: MappedDivergence => MappedDivergence_MappedVector3D_t procedure , private :: MappedDivergence_MappedVector3D_t generic , public :: MappedDGDivergence => MappedDGDivergence_MappedVector3D_t procedure , private :: MappedDGDivergence_MappedVector3D_t procedure , private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D_t procedure , private :: ApplyFlip => ApplyFlip_MappedVector3D_t procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector3D_t !procedure,public :: WriteTecplot => WriteTecplot_MappedVector3D_t endtype MappedVector3D_t","tags":"","loc":"type/mappedvector3d_t.html"},{"title":"Vector2D_t – SELF ","text":"type, public, extends( SELF_DataObj ) :: Vector2D_t Contents Variables M N avgBoundary boundary boundaryNormal eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Divergence Divergence_Vector2D_t Free Gradient Gradient_Vector2D_t GridInterp GridInterp_Vector2D_t Init SetDescription SetEquation SetEquation_Vector2D_t SetName SetUnits UpdateDevice UpdateHost WriteHDF5 WriteHDF5_MPI_Vector2D_t WriteHDF5_Vector2D_t Source Code Vector2D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundaryNormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Vector2D_t public subroutine AverageSides_Vector2D_t (this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D_t public subroutine BoundaryInterp_Vector2D_t (this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this generic, public :: Divergence => Divergence_Vector2D_t public subroutine Divergence_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, private :: Divergence_Vector2D_t public subroutine Divergence_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: Free => Free_Vector2D_t public subroutine Free_Vector2D_t (this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this generic, public :: Gradient => Gradient_Vector2D_t public subroutine Gradient_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2,1:2) procedure, private :: Gradient_Vector2D_t public subroutine Gradient_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2,1:2) generic, public :: GridInterp => GridInterp_Vector2D_t public subroutine GridInterp_Vector2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:2) procedure, private :: GridInterp_Vector2D_t public subroutine GridInterp_Vector2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:2) procedure, public :: Init => Init_Vector2D_t public subroutine Init_Vector2D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector2D_t public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector2D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, private :: SetEquation_Vector2D_t public subroutine SetEquation_Vector2D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Vector2D_t public subroutine UpdateDevice_Vector2D_t (this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Vector2D_t public subroutine UpdateHost_Vector2D_t (this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D_t , WriteHDF5_Vector2D_t public subroutine WriteHDF5_MPI_Vector2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group procedure, private :: WriteHDF5_MPI_Vector2D_t public subroutine WriteHDF5_MPI_Vector2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem procedure, private :: WriteHDF5_Vector2D_t public subroutine WriteHDF5_Vector2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( SELF_DataObj ), public :: Vector2D_t real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: interior real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: boundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: extBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: avgBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:) :: boundaryNormal contains procedure , public :: Init => Init_Vector2D_t procedure , public :: Free => Free_Vector2D_t procedure , public :: UpdateHost => UpdateHost_Vector2D_t procedure , public :: UpdateDevice => UpdateDevice_Vector2D_t procedure , public :: BoundaryInterp => BoundaryInterp_Vector2D_t procedure , public :: AverageSides => AverageSides_Vector2D_t generic , public :: GridInterp => GridInterp_Vector2D_t procedure , private :: GridInterp_Vector2D_t generic , public :: Gradient => Gradient_Vector2D_t procedure , private :: Gradient_Vector2D_t generic , public :: Divergence => Divergence_Vector2D_t procedure , private :: Divergence_Vector2D_t generic , public :: SetEquation => SetEquation_Vector2D_t procedure , private :: SetEquation_Vector2D_t generic , public :: WriteHDF5 => WriteHDF5_MPI_Vector2D_t , WriteHDF5_Vector2D_t procedure , private :: WriteHDF5_MPI_Vector2D_t procedure , private :: WriteHDF5_Vector2D_t endtype Vector2D_t","tags":"","loc":"type/vector2d_t.html"},{"title":"NullDGModel2D_t – SELF ","text":"type, public, extends( DGModel2D ) :: NullDGModel2D_t Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code NullDGModel2D_t Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D public subroutine BoundaryFlux_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D public subroutine CalculateEntropy_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D public subroutine CalculateSolutionGradient_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel2D public subroutine CalculateTendency_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel2D public subroutine fluxmethod_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel2D_t public subroutine Free_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel2D_t public subroutine Init_DGModel2D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), target :: mesh type( SEMQuad ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel2D_t public subroutine Read_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D public subroutine setboundarycondition_DGModel2D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D public subroutine setgradientboundarycondition_DGModel2D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel2D_t public subroutine SetMetadata_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t , SetSolutionFromEqn_DGModel2D_t public subroutine SetSolutionFromChar_DGModel2D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel2D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel2D public subroutine sourcemethod_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D public subroutine UpdateGRK2_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D public subroutine UpdateGRK3_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D public subroutine UpdateGRK4_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel2D public subroutine UpdateSolution_DGModel2D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel2D_t public subroutine Write_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t public subroutine WriteTecplot_DGModel2D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( dgmodel2d ) :: NullDGModel2D_t ! Add any additional attributes here that are specific to your model contains !   procedure :: hbc2d_Prescribed => hbc2d_Generic_Model !   procedure :: hbc2d_Radiation => hbc2d_Generic_Model !   procedure :: hbc2d_NoNormalFlow => hbc2d_Generic_Model !   procedure :: pbc2d_Prescribed => pbc2d_Generic_Model !   procedure :: pbc2d_Radiation => pbc2d_Generic_Model !   procedure :: pbc2d_NoNormalFlow => pbc2d_Generic_Model !   procedure :: SetMetadata => SetMetadata_NullDGModel2D_t !   procedure :: pretendency => pretendency_NullDGModel2D_t !   procedure :: entropy_func => entropy_func_NullDGModel2D_t !   procedure :: flux2d => flux2d_NullDGModel2D_t !   procedure :: riemannflux2d => riemannflux2d_NullDGModel2D_t !   procedure :: source2d => source2d_NullDGModel2D_t endtype NullDGModel2D_t","tags":"","loc":"type/nulldgmodel2d_t.html"},{"title":"Burgers1D_t – SELF ","text":"type, public, extends( DGModel1D ) :: Burgers1D_t Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nu nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1d flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code Burgers1D_t Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh real(kind=prec), public :: nu = 0.0_prec integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D public subroutine BoundaryFlux_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D public subroutine CalculateEntropy_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D public subroutine CalculateSolutionGradient_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel1D public subroutine CalculateTendency_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel1D public subroutine fluxmethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel1D_t public subroutine Free_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel1D_t public subroutine Init_DGModel1D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), target :: mesh type( Geometry1D ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel1D_t public subroutine Read_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D public subroutine setboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D public subroutine setgradientboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_Burgers1D_t public subroutine SetMetadata_Burgers1D_t (this) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t , SetSolutionFromEqn_DGModel1D_t public subroutine SetSolutionFromChar_DGModel1D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel1D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel1D public subroutine sourcemethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D public subroutine UpdateGRK2_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D public subroutine UpdateGRK3_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D public subroutine UpdateGRK4_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel1D public subroutine UpdateSolution_DGModel1D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel1D_t public subroutine Write_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t public subroutine WriteTecplot_DGModel1D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Burgers1D_t public pure function entropy_func_Burgers1D_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) procedure, public :: flux1d => flux1d_Burgers1D_t public pure function flux1d_Burgers1D_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) Return Value real(kind=prec)(1:this%solution%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Burgers1D_t public pure function riemannflux1d_Burgers1D_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%solution%nvar) real(kind=prec), intent(in) :: sR (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%solution%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( dgmodel1d ) :: Burgers1D_t ! Add any additional attributes here that are specific to your model real ( prec ) :: nu = 0.0_prec ! Diffusivity/viscosity contains procedure :: SetMetadata => SetMetadata_Burgers1D_t procedure :: entropy_func => entropy_func_Burgers1D_t procedure :: flux1d => flux1d_Burgers1D_t procedure :: riemannflux1d => riemannflux1d_Burgers1D_t endtype Burgers1D_t","tags":"","loc":"type/burgers1d_t.html"},{"title":"SEMMesh – SELF ","text":"type, public :: SEMMesh Contents Variables decomp nBCs nCornerNodes nElem nGeo nGlobalElem nNodes nSides nUniqueNodes nUniqueSides quadrature Source Code SEMMesh Components Type Visibility Attributes Name Initial type( DomainDecomposition ), public :: decomp integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides integer, public :: quadrature Source Code type :: SEMMesh integer :: nGeo integer :: nElem integer :: nGlobalElem integer :: nNodes integer :: nSides integer :: nCornerNodes integer :: nUniqueNodes integer :: nUniqueSides integer :: nBCs integer :: quadrature type ( DomainDecomposition ) :: decomp endtype SEMMesh","tags":"","loc":"type/semmesh.html"},{"title":"Lagrange_t – SELF ","text":"type, public :: Lagrange_t A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions.\nThe Lagrange data-structure stores the information necessary to interpolate between two\nsets of grid-points and to estimate the derivative of data at native grid points. Routines for\nmultidimensional interpolation are based on the tensor product of 1-D interpolants. It is\nassumed that the polynomial degree (and the interpolation nodes) are the same in each direction.\nThis assumption permits the storage of only one array of interpolation nodes and barycentric\nweights and is what allows this data structure to be flexible. Contents Variables M N bMatrix bWeights blas_handle controlNodeType controlPoints dMatrix dgMatrix iMatrix qWeights targetNodeType targetPoints Type-Bound Procedures CalculateBarycentricWeights CalculateDerivativeMatrix CalculateInterpolationMatrix CalculateLagrangePolynomials Free Init WriteHDF5 Source Code Lagrange_t Components Type Visibility Attributes Name Initial integer, public :: M The number of target points. integer, public :: N The number of control points. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: bMatrix The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. real(kind=prec), public, pointer, contiguous, dimension(:) :: bWeights The barycentric weights that are calculated from the controlPoints and used for interpolation. type(c_ptr), public :: blas_handle = c_null_ptr A handle for working with hipblas integer, public :: controlNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: controlPoints The set of nodes in one dimension where data is known.\nTo create higher dimension interpolation and differentiation operators, structured grids in two and three\ndimensions are created by tensor products of the controlPoints. This design decision implies that all\nspectral element methods supported by the Lagrange class have the same polynomial degree in each\ncomputational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto,\nLegendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over\nthe domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of\nthese quadrature types or uniform points on [-1,1]. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The\ndMatrix is based on a strong form of the derivative. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dgMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based\non a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: iMatrix The interpolation matrix (transpose) for mapping data from the control grid to the target grid. real(kind=prec), public, pointer, contiguous, dimension(:) :: qWeights The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints\nprovided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss,\nChebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant . integer, public :: targetNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: targetPoints The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation\nand differentiation operators, structured grids in two and three dimensions are created by tensor products of\nthe targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1]\n(computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. Type-Bound Procedures procedure, public :: CalculateBarycentricWeights public subroutine CalculateBarycentricWeights (this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this procedure, public :: CalculateDerivativeMatrix public subroutine CalculateDerivativeMatrix (this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this procedure, public :: CalculateInterpolationMatrix public subroutine CalculateInterpolationMatrix (this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this procedure, public :: CalculateLagrangePolynomials public function CalculateLagrangePolynomials (this, sE) result(lAtS) Arguments Type Intent Optional Attributes Name class( Lagrange_t ) :: this real(kind=prec) :: sE Return Value real(kind=prec)(0:this%N) procedure, public :: Free => Free_Lagrange_t public subroutine Free_Lagrange_t (this) Frees all memory (host and device) associated with an instance of the Lagrange_t class Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this Lagrange_t class instance procedure, public :: Init => Init_Lagrange_t public subroutine Init_Lagrange_t (this, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange_t class\nOn output, all of the attributes for the Lagrange_t class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange_t attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(out) :: this Lagrange_t class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) procedure, public :: WriteHDF5 => WriteHDF5_Lagrange_t public subroutine WriteHDF5_Lagrange_t (this, fileId) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId Source Code type , public :: Lagrange_t !! A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions. !! The Lagrange data-structure stores the information necessary to interpolate between two !! sets of grid-points and to estimate the derivative of data at native grid points. Routines for !! multidimensional interpolation are based on the tensor product of 1-D interpolants. It is !! assumed that the polynomial degree (and the interpolation nodes) are the same in each direction. !! This assumption permits the storage of only one array of interpolation nodes and barycentric !! weights and is what allows this data structure to be flexible. integer :: N !! The number of control points. integer :: controlNodeType integer :: M !! The number of target points. integer :: targetNodeType type ( c_ptr ) :: blas_handle = c_null_ptr !! A handle for working with hipblas real ( prec ), pointer , contiguous , dimension (:) :: controlPoints !! The set of nodes in one dimension where data is known. !! To create higher dimension interpolation and differentiation operators, structured grids in two and three !! dimensions are created by tensor products of the controlPoints. This design decision implies that all !! spectral element methods supported by the Lagrange class have the same polynomial degree in each !! computational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto, !! Legendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over !! the domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of !! these quadrature types or uniform points on [-1,1]. real ( prec ), pointer , contiguous , dimension (:) :: targetPoints !! The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation !! and differentiation operators, structured grids in two and three dimensions are created by tensor products of !! the targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1] !! (computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. real ( prec ), pointer , contiguous , dimension (:) :: bWeights !! The barycentric weights that are calculated from the controlPoints and used for interpolation. real ( prec ), pointer , contiguous , dimension (:) :: qWeights !! The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints !! provided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss, !! Chebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant !! dx = \\frac{2.0}{N+1}. real ( prec ), pointer , contiguous , dimension (:,:) :: iMatrix !! The interpolation matrix (transpose) for mapping data from the control grid to the target grid. real ( prec ), pointer , contiguous , dimension (:,:) :: dMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The !! dMatrix is based on a strong form of the derivative. real ( prec ), pointer , contiguous , dimension (:,:) :: dgMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based !! on a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. real ( prec ), pointer , contiguous , dimension (:,:) :: bMatrix !! The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. contains procedure , public :: Init => Init_Lagrange_t procedure , public :: Free => Free_Lagrange_t procedure , public :: WriteHDF5 => WriteHDF5_Lagrange_t procedure , public :: CalculateBarycentricWeights procedure , public :: CalculateInterpolationMatrix procedure , public :: CalculateDerivativeMatrix procedure , public :: CalculateLagrangePolynomials endtype Lagrange_t","tags":"","loc":"type/lagrange_t.html"},{"title":"MappedVector2D_t – SELF ","text":"type, public, extends( Vector2D ) :: MappedVector2D_t Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundaryNormal boundaryNormal_gpu boundary_gpu eqn extBoundary extBoundary_gpu geometry geometry_associated interior interior_gpu interp interpWork meta nElem nVar Type-Bound Procedures ApplyFlip AssociateGeometry AverageSides BoundaryInterp DissociateGeometry Divergence Free Gradient GridInterp Init MPIExchangeAsync MappedDGDivergence MappedDGDivergence_MappedVector2D_t MappedDivergence MappedDivergence_MappedVector2D_t SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedVector2D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMQuad ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedVector2D_t public subroutine ApplyFlip_MappedVector2D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( Mesh2D ), intent(in) :: mesh procedure, public :: AssociateGeometry => AssociateGeometry_MappedVector2D_t public subroutine AssociateGeometry_MappedVector2D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( SEMQuad ), intent(in), target :: geometry procedure, public :: AverageSides => AverageSides_Vector2D public subroutine AverageSides_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D public subroutine BoundaryInterp_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this procedure, public :: DissociateGeometry => DissociateGeometry_MappedVector2D_t public subroutine DissociateGeometry_MappedVector2D_t (this) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this generic, public :: Divergence => Divergence_Vector2D_t , Divergence_Vector2D public subroutine Divergence_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Divergence_Vector2D (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, public :: Free => Free_Vector2D public subroutine Free_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this generic, public :: Gradient => Gradient_Vector2D_t , Gradient_Vector2D public subroutine Gradient_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2,1:2) public subroutine Gradient_Vector2D (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Vector2D_t , GridInterp_Vector2D public subroutine GridInterp_Vector2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:2) public subroutine GridInterp_Vector2D (this, f) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Vector2D public subroutine Init_Vector2D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D_t public subroutine MPIExchangeAsync_MappedVector2D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh generic, public :: MappedDGDivergence => MappedDGDivergence_MappedVector2D_t public subroutine MappedDGDivergence_MappedVector2D_t (this, df) Computes the divergence of a 2-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(in) :: this real(kind=prec) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, private :: MappedDGDivergence_MappedVector2D_t public subroutine MappedDGDivergence_MappedVector2D_t (this, df) Computes the divergence of a 2-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(in) :: this real(kind=prec) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) generic, public :: MappedDivergence => MappedDivergence_MappedVector2D_t public subroutine MappedDivergence_MappedVector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, private :: MappedDivergence_MappedVector2D_t public subroutine MappedDivergence_MappedVector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector2D_t public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector2D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector2D_t public subroutine SetInteriorFromEquation_MappedVector2D_t (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedVector2D_t public subroutine SideExchange_MappedVector2D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh procedure, public :: UpdateDevice => UpdateDevice_Vector2D public subroutine UpdateDevice_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Vector2D public subroutine UpdateHost_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D_t , WriteHDF5_Vector2D_t public subroutine WriteHDF5_MPI_Vector2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Vector2D ), public :: MappedVector2D_t logical :: geometry_associated = . false . type ( SEMQuad ), pointer :: geometry => null () contains procedure , public :: AssociateGeometry => AssociateGeometry_MappedVector2D_t procedure , public :: DissociateGeometry => DissociateGeometry_MappedVector2D_t procedure , public :: SideExchange => SideExchange_MappedVector2D_t generic , public :: MappedDivergence => MappedDivergence_MappedVector2D_t procedure , private :: MappedDivergence_MappedVector2D_t generic , public :: MappedDGDivergence => MappedDGDivergence_MappedVector2D_t procedure , private :: MappedDGDivergence_MappedVector2D_t procedure , private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D_t procedure , private :: ApplyFlip => ApplyFlip_MappedVector2D_t procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector2D_t endtype MappedVector2D_t","tags":"","loc":"type/mappedvector2d_t.html"},{"title":"Vector3D_t – SELF ","text":"type, public, extends( SELF_DataObj ) :: Vector3D_t Contents Variables M N avgBoundary boundary boundaryNormal eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Curl Curl_Vector3D_t Divergence Divergence_Vector3D_t Free Gradient Gradient_Vector3D_t GridInterp GridInterp_Vector3D_t Init SetDescription SetEquation SetEquation_Vector3D_t SetName SetUnits UpdateDevice UpdateHost WriteHDF5 WriteHDF5_MPI_Vector3D_t WriteHDF5_Vector3D_t Source Code Vector3D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: avgBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundaryNormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Vector3D_t public subroutine AverageSides_Vector3D_t (this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D_t public subroutine BoundaryInterp_Vector3D_t (this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this generic, public :: Curl => Curl_Vector3D_t public subroutine Curl_Vector3D_t (this, curlf) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: curlf (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) procedure, private :: Curl_Vector3D_t public subroutine Curl_Vector3D_t (this, curlf) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: curlf (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) generic, public :: Divergence => Divergence_Vector3D_t public subroutine Divergence_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, private :: Divergence_Vector3D_t public subroutine Divergence_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: Free => Free_Vector3D_t public subroutine Free_Vector3D_t (this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this generic, public :: Gradient => Gradient_Vector3D_t public subroutine Gradient_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3,1:3) procedure, private :: Gradient_Vector3D_t public subroutine Gradient_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3,1:3) generic, public :: GridInterp => GridInterp_Vector3D_t public subroutine GridInterp_Vector3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:3) (Output) Array of function values, defined on the target grid procedure, private :: GridInterp_Vector3D_t public subroutine GridInterp_Vector3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:3) (Output) Array of function values, defined on the target grid procedure, public :: Init => Init_Vector3D_t public subroutine Init_Vector3D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector3D_t public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector3D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, private :: SetEquation_Vector3D_t public subroutine SetEquation_Vector3D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Vector3D_t public subroutine UpdateDevice_Vector3D_t (this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Vector3D_t public subroutine UpdateHost_Vector3D_t (this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D_t , WriteHDF5_Vector3D_t public subroutine WriteHDF5_MPI_Vector3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group procedure, private :: WriteHDF5_MPI_Vector3D_t public subroutine WriteHDF5_MPI_Vector3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem procedure, private :: WriteHDF5_Vector3D_t public subroutine WriteHDF5_Vector3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( SELF_DataObj ), public :: Vector3D_t real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:) :: interior real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:) :: boundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:) :: extBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:) :: avgBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: boundaryNormal contains procedure , public :: Init => Init_Vector3D_t procedure , public :: Free => Free_Vector3D_t procedure , public :: UpdateHost => UpdateHost_Vector3D_t procedure , public :: UpdateDevice => UpdateDevice_Vector3D_t procedure , public :: BoundaryInterp => BoundaryInterp_Vector3D_t procedure , public :: AverageSides => AverageSides_Vector3D_t generic , public :: GridInterp => GridInterp_Vector3D_t procedure , private :: GridInterp_Vector3D_t generic , public :: Gradient => Gradient_Vector3D_t procedure , private :: Gradient_Vector3D_t generic , public :: Curl => Curl_Vector3D_t procedure , private :: Curl_Vector3D_t generic , public :: Divergence => Divergence_Vector3D_t procedure , private :: Divergence_Vector3D_t generic , public :: SetEquation => SetEquation_Vector3D_t procedure , private :: SetEquation_Vector3D_t generic , public :: WriteHDF5 => WriteHDF5_MPI_Vector3D_t , WriteHDF5_Vector3D_t procedure , private :: WriteHDF5_MPI_Vector3D_t procedure , private :: WriteHDF5_Vector3D_t endtype Vector3D_t","tags":"","loc":"type/vector3d_t.html"},{"title":"Scalar3D_t – SELF ","text":"type, public, extends( SELF_DataObj ) :: Scalar3D_t Contents Variables M N avgBoundary boundary boundarynormal eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Free Gradient Gradient_Scalar3D_t GridInterp GridInterp_Scalar3D_t Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 WriteHDF5_MPI_Scalar3D_t WriteHDF5_Scalar3D_t Source Code Scalar3D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundarynormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar3D_t public subroutine AverageSides_Scalar3D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D_t public subroutine BoundaryInterp_Scalar3D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this procedure, public :: Free => Free_Scalar3D_t public subroutine Free_Scalar3D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this generic, public :: Gradient => Gradient_Scalar3D_t public subroutine Gradient_Scalar3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) procedure, private :: Gradient_Scalar3D_t public subroutine Gradient_Scalar3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) generic, public :: GridInterp => GridInterp_Scalar3D_t public subroutine GridInterp_Scalar3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) (Output) Array of function values, defined on the target grid procedure, private :: GridInterp_Scalar3D_t public subroutine GridInterp_Scalar3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) (Output) Array of function values, defined on the target grid procedure, public :: Init => Init_Scalar3D_t public subroutine Init_Scalar3D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Scalar3D_t public subroutine UpdateDevice_Scalar3D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar3D_t public subroutine UpdateHost_Scalar3D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D_t , WriteHDF5_Scalar3D_t public subroutine WriteHDF5_MPI_Scalar3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group procedure, private :: WriteHDF5_MPI_Scalar3D_t public subroutine WriteHDF5_MPI_Scalar3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem procedure, private :: WriteHDF5_Scalar3D_t public subroutine WriteHDF5_Scalar3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( SELF_DataObj ), public :: Scalar3D_t real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: interior real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: boundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: extBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: avgBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: boundarynormal contains procedure , public :: Init => Init_Scalar3D_t procedure , public :: Free => Free_Scalar3D_t procedure , public :: UpdateHost => UpdateHost_Scalar3D_t procedure , public :: UpdateDevice => UpdateDevice_Scalar3D_t procedure , public :: BoundaryInterp => BoundaryInterp_Scalar3D_t procedure , public :: AverageSides => AverageSides_Scalar3D_t generic , public :: GridInterp => GridInterp_Scalar3D_t procedure , private :: GridInterp_Scalar3D_t generic , public :: Gradient => Gradient_Scalar3D_t procedure , private :: Gradient_Scalar3D_t generic , public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D_t , WriteHDF5_Scalar3D_t procedure , private :: WriteHDF5_MPI_Scalar3D_t procedure , private :: WriteHDF5_Scalar3D_t endtype Scalar3D_t","tags":"","loc":"type/scalar3d_t.html"},{"title":"Tensor2D_t – SELF ","text":"type, public, extends( SELF_DataObj ) :: Tensor2D_t Contents Variables M N boundary eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures BoundaryInterp Determinant Determinant_Tensor2D_t Free Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost Source Code Tensor2D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor2D_t public subroutine BoundaryInterp_Tensor2D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this generic, public :: Determinant => Determinant_Tensor2D_t public subroutine Determinant_Tensor2D_t (this, det) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(in) :: this real(kind=prec), intent(out) :: det (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, private :: Determinant_Tensor2D_t public subroutine Determinant_Tensor2D_t (this, det) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(in) :: this real(kind=prec), intent(out) :: det (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: Free => Free_Tensor2D_t public subroutine Free_Tensor2D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this procedure, public :: Init => Init_Tensor2D_t public subroutine Init_Tensor2D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Tensor2D_t public subroutine UpdateDevice_Tensor2D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Tensor2D_t public subroutine UpdateHost_Tensor2D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this Source Code type , extends ( SELF_DataObj ), public :: Tensor2D_t real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:) :: interior real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:) :: boundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:) :: extBoundary contains procedure , public :: Init => Init_Tensor2D_t procedure , public :: Free => Free_Tensor2D_t procedure , public :: UpdateHost => UpdateHost_Tensor2D_t procedure , public :: UpdateDevice => UpdateDevice_Tensor2D_t procedure , public :: BoundaryInterp => BoundaryInterp_Tensor2D_t generic , public :: Determinant => Determinant_Tensor2D_t procedure , private :: Determinant_Tensor2D_t endtype Tensor2D_t","tags":"","loc":"type/tensor2d_t.html"},{"title":"SELF_DataObj – SELF ","text":"type, public :: SELF_DataObj The SELF_DataObj class is a base class for all data objects in SELF.\nA data object in SELF is a multidimensional array of data, represented\non both host and device, that is associated with an interpolant, metadata,\nand (optionally) an equation string.\nType extensions of the SELF_DataObj include scalars, vectors, and tensors\nin 1-D, 2-D, and 3-D using the storage patterns that are expected for\nderivative and interpolation operations defined in SELF_Lagrange.f90\nAdditionally, each extended type has the necessary attributes to store\ninformation on element interiors and element boundaries, both of which\nare commonly used for spectral element solvers. Contents Variables M N eqn interp meta nElem nVar Type-Bound Procedures SetDescription SetEquation SetEquation_DataObj SetName SetUnits Source Code SELF_DataObj Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(EquationParser), public, allocatable :: eqn (:) type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, private :: SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units Source Code type , public :: SELF_DataObj !! The SELF_DataObj class is a base class for all data objects in SELF. !! A data object in SELF is a multidimensional array of data, represented !! on both host and device, that is associated with an interpolant, metadata, !! and (optionally) an equation string. !! Type extensions of the SELF_DataObj include scalars, vectors, and tensors !! in 1-D, 2-D, and 3-D using the storage patterns that are expected for !! derivative and interpolation operations defined in SELF_Lagrange.f90 !! Additionally, each extended type has the necessary attributes to store !! information on element interiors and element boundaries, both of which !! are commonly used for spectral element solvers. integer :: nVar integer :: nElem integer :: N integer :: M type ( Lagrange ), pointer :: interp type ( Metadata ), allocatable :: meta (:) type ( EquationParser ), allocatable :: eqn (:) contains ! Procedures for setting metadata for procedure , public :: SetName => SetName_DataObj procedure , public :: SetDescription => SetDescription_DataObj procedure , public :: SetUnits => SetUnits_DataObj generic , public :: SetEquation => SetEquation_DataObj procedure , private :: SetEquation_DataObj endtype SELF_DataObj","tags":"","loc":"type/self_dataobj.html"},{"title":"Mesh1D – SELF ","text":"type, public, extends( SEMMesh ) :: Mesh1D Contents Variables BCNames BCType bcid decomp elemInfo globalNodeIDs nBCs nCornerNodes nElem nGeo nGlobalElem nNodes nSides nUniqueNodes nUniqueSides nodeCoords quadrature Type-Bound Procedures Free Init ResetBoundaryConditionType StructuredMesh UniformBlockMesh_Mesh1D Write_Mesh Source Code Mesh1D Components Type Visibility Attributes Name Initial character(len=255), public, allocatable :: BCNames (:) integer, public, pointer, dimension(:,:) :: BCType integer, public, dimension(2) :: bcid = 0 type( DomainDecomposition ), public :: decomp integer, public, pointer, dimension(:,:) :: elemInfo integer, public, pointer, dimension(:) :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides real(kind=prec), public, pointer, dimension(:) :: nodeCoords integer, public :: quadrature Type-Bound Procedures procedure, public :: Free => Free_Mesh1D public subroutine Free_Mesh1D (this) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: this procedure, public :: Init => Init_Mesh1D public subroutine Init_Mesh1D (this, nElem, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: this integer, intent(in) :: nElem integer, intent(in) :: nNodes integer, intent(in) :: nBCs procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh1D public subroutine ResetBoundaryConditionType_Mesh1D (this, leftbc, rightbc) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Read more… Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: this integer, intent(in) :: leftbc integer, intent(in) :: rightbc generic, public :: StructuredMesh => UniformBlockMesh_Mesh1D public subroutine UniformBlockMesh_Mesh1D (this, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: this integer, intent(in) :: nElem real(kind=prec), intent(in) :: x (1:2) procedure, private :: UniformBlockMesh_Mesh1D public subroutine UniformBlockMesh_Mesh1D (this, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: this integer, intent(in) :: nElem real(kind=prec), intent(in) :: x (1:2) procedure, public :: Write_Mesh => Write_Mesh1D public subroutine Write_Mesh1D (this, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: this character, intent(in) :: meshFile Source Code type , extends ( SEMMesh ) :: Mesh1D integer , pointer , dimension (:,:) :: elemInfo real ( prec ), pointer , dimension (:) :: nodeCoords integer , pointer , dimension (:) :: globalNodeIDs integer , pointer , dimension (:,:) :: BCType character ( LEN = 255 ), allocatable :: BCNames (:) integer , dimension ( 2 ) :: bcid = 0 ! Boundary conditions for the left and right endpoints contains procedure , public :: Init => Init_Mesh1D procedure , public :: Free => Free_Mesh1D generic , public :: StructuredMesh => UniformBlockMesh_Mesh1D procedure , private :: UniformBlockMesh_Mesh1D procedure , public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh1D procedure , public :: Write_Mesh => Write_Mesh1D endtype Mesh1D","tags":"","loc":"type/mesh1d.html"},{"title":"NullDGModel3D_t – SELF ","text":"type, public, extends( DGModel3D ) :: NullDGModel3D_t Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code NullDGModel3D_t Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D public subroutine BoundaryFlux_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D public subroutine CalculateEntropy_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D public subroutine CalculateSolutionGradient_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel3D public subroutine CalculateTendency_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel3D public subroutine fluxmethod_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel3D_t public subroutine Free_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel3D_t public subroutine Init_DGModel3D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh3D ), intent(in), target :: mesh type( SEMHex ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel3D_t public subroutine Read_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D public subroutine setboundarycondition_DGModel3D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D public subroutine setgradientboundarycondition_DGModel3D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel3D_t public subroutine SetMetadata_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t , SetSolutionFromEqn_DGModel3D_t public subroutine SetSolutionFromChar_DGModel3D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel3D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel3D public subroutine sourcemethod_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D public subroutine UpdateGRK2_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D public subroutine UpdateGRK3_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D public subroutine UpdateGRK4_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel3D public subroutine UpdateSolution_DGModel3D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel3D_t public subroutine Write_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t public subroutine WriteTecplot_DGModel3D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( dgmodel3d ) :: NullDGModel3D_t ! Add any additional attributes here that are specific to your model contains !   procedure :: hbc3d_Prescribed => hbc3d_Generic_Model !   procedure :: hbc3d_Radiation => hbc3d_Generic_Model !   procedure :: hbc3d_NoNormalFlow => hbc3d_Generic_Model !   procedure :: pbc3d_Prescribed => pbc3d_Generic_Model !   procedure :: pbc3d_Radiation => pbc3d_Generic_Model !   procedure :: pbc3d_NoNormalFlow => pbc3d_Generic_Model !   procedure :: SetMetadata => SetMetadata_NullDGModel3D_t !   procedure :: pretendency => pretendency_NullDGModel3D_t !   procedure :: entropy_func => entropy_func_NullDGModel3D_t !   procedure :: flux3d => flux3d_NullDGModel3D_t !   procedure :: riemannflux3d => riemannflux3d_NullDGModel3D_t !   procedure :: source3d => source3d_NullDGModel3D_t endtype NullDGModel3D_t","tags":"","loc":"type/nulldgmodel3d_t.html"},{"title":"SEMHex – SELF ","text":"type, public :: SEMHex Contents Variables J dsdx dxds nElem nHat nScale x Type-Bound Procedures CalculateContravariantBasis CalculateMetricTerms Free GenerateFromMesh Init Source Code SEMHex Components Type Visibility Attributes Name Initial type( Scalar3D ), public :: J type( Tensor3D ), public :: dsdx type( Tensor3D ), public :: dxds integer, public :: nElem type( Vector3D ), public :: nHat type( Scalar3D ), public :: nScale type( Vector3D ), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex public subroutine CalculateContravariantBasis_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMHex public subroutine CalculateMetricTerms_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom procedure, public :: Free => Free_SEMHex public subroutine Free_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMHex public subroutine GenerateFromMesh_SEMHex (myGeom, mesh) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom type( Mesh3D ), intent(in) :: mesh procedure, public :: Init => Init_SEMHex public subroutine Init_SEMHex (myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom type( Lagrange ), intent(in), pointer :: interp integer, intent(in) :: nElem Source Code type , public :: SEMHex type ( Vector3D ) :: x ! Physical positions type ( Tensor3D ) :: dxds ! Covariant basis vectors type ( Tensor3D ) :: dsdx ! Contavariant basis vectors type ( Vector3D ) :: nHat ! Normal Vectors pointing across coordinate lines type ( Scalar3D ) :: nScale ! Boundary scale type ( Scalar3D ) :: J ! Jacobian of the transformation integer :: nElem contains procedure , public :: Init => Init_SEMHex procedure , public :: Free => Free_SEMHex procedure , public :: GenerateFromMesh => GenerateFromMesh_SEMHex procedure , public :: CalculateMetricTerms => CalculateMetricTerms_SEMHex procedure , private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex endtype SEMHex","tags":"","loc":"type/semhex.html"},{"title":"Mesh3D_t – SELF ","text":"type, public, extends( SEMMesh ) :: Mesh3D_t Contents Variables BCNames BCType CGNSCornerMap CGNSSideMap decomp elemInfo globalNodeIDs nBCs nCornerNodes nElem nGeo nGlobalElem nNodes nSides nUniqueNodes nUniqueSides nodeCoords quadrature sideInfo sideMap Type-Bound Procedures Free Init Read_HOPr RecalculateFlip ResetBoundaryConditionType Write_Mesh Source Code Mesh3D_t Components Type Visibility Attributes Name Initial character(len=255), public, allocatable :: BCNames (:) integer, public, pointer, dimension(:,:) :: BCType integer, public, pointer, dimension(:,:) :: CGNSCornerMap integer, public, pointer, dimension(:,:) :: CGNSSideMap type( DomainDecomposition ), public :: decomp integer, public, pointer, dimension(:,:) :: elemInfo integer, public, pointer, dimension(:,:,:,:) :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides real(kind=prec), public, pointer, dimension(:,:,:,:,:) :: nodeCoords integer, public :: quadrature integer, public, pointer, dimension(:,:,:) :: sideInfo integer, public, pointer, dimension(:,:) :: sideMap Type-Bound Procedures procedure, public :: Free => Free_Mesh3D_t public subroutine Free_Mesh3D_t (this) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this procedure, public :: Init => Init_Mesh3D_t public subroutine Init_Mesh3D_t (this, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs procedure, public :: Read_HOPr => Read_HOPr_Mesh3D_t public subroutine Read_HOPr_Mesh3D_t (this, meshFile, enableDomainDecomposition) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(out) :: this character, intent(in) :: meshFile logical, intent(in), optional :: enableDomainDecomposition procedure, public :: RecalculateFlip => RecalculateFlip_Mesh3D_t public subroutine RecalculateFlip_Mesh3D_t (this) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh3D_t public subroutine ResetBoundaryConditionType_Mesh3D_t (this, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Read more… Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this integer, intent(in) :: bcid procedure, public :: Write_Mesh => Write_Mesh3D_t public subroutine Write_Mesh3D_t (this, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this character, intent(in) :: meshFile Source Code type , extends ( SEMMesh ) :: Mesh3D_t integer , pointer , dimension (:,:,:) :: sideInfo real ( prec ), pointer , dimension (:,:,:,:,:) :: nodeCoords integer , pointer , dimension (:,:) :: elemInfo integer , pointer , dimension (:,:,:,:) :: globalNodeIDs integer , pointer , dimension (:,:) :: CGNSCornerMap integer , pointer , dimension (:,:) :: sideMap integer , pointer , dimension (:,:) :: CGNSSideMap integer , pointer , dimension (:,:) :: BCType character ( LEN = 255 ), allocatable :: BCNames (:) contains procedure , public :: Init => Init_Mesh3D_t procedure , public :: Free => Free_Mesh3D_t procedure , public :: Read_HOPr => Read_HOPr_Mesh3D_t procedure , public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh3D_t procedure , public :: Write_Mesh => Write_Mesh3D_t procedure , public :: RecalculateFlip => RecalculateFlip_Mesh3D_t endtype Mesh3D_t","tags":"","loc":"type/mesh3d_t.html"},{"title":"DomainDecomposition_t – SELF ","text":"type, public :: DomainDecomposition_t Contents Variables elemToRank maxMsg mpiComm mpiEnabled mpiPrec msgCount nElem nRanks offSetElem rankId requests stats Type-Bound Procedures FinalizeMPIExchangeAsync Free GenerateDecomposition Init SetElemToRank Source Code DomainDecomposition_t Components Type Visibility Attributes Name Initial integer, public, pointer, dimension(:) :: elemToRank integer, public :: maxMsg integer, public :: mpiComm logical, public :: mpiEnabled integer, public :: mpiPrec integer, public :: msgCount integer, public :: nElem integer, public :: nRanks integer, public, pointer, dimension(:) :: offSetElem integer, public :: rankId integer, public, allocatable :: requests (:) integer, public, allocatable :: stats (:,:) Type-Bound Procedures procedure, public :: FinalizeMPIExchangeAsync public subroutine FinalizeMPIExchangeAsync (mpiHandler) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: mpiHandler procedure, public :: Free => Free_DomainDecomposition_t public subroutine Free_DomainDecomposition_t (this) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this procedure, public :: GenerateDecomposition => GenerateDecomposition_DomainDecomposition_t public subroutine GenerateDecomposition_DomainDecomposition_t (this, nGlobalElem, maxMsg) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this integer, intent(in) :: nGlobalElem integer, intent(in) :: maxMsg procedure, public :: Init => Init_DomainDecomposition_t public subroutine Init_DomainDecomposition_t (this, enableMPI) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this logical, intent(in) :: enableMPI procedure, public :: SetElemToRank => SetElemToRank_DomainDecomposition_t public subroutine SetElemToRank_DomainDecomposition_t (this, nElem) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this integer, intent(in) :: nElem Source Code type DomainDecomposition_t logical :: mpiEnabled integer :: mpiComm integer :: mpiPrec integer :: rankId integer :: nRanks integer :: nElem integer :: maxMsg integer :: msgCount integer , pointer , dimension (:) :: elemToRank integer , pointer , dimension (:) :: offSetElem integer , allocatable :: requests (:) integer , allocatable :: stats (:,:) contains procedure :: Init => Init_DomainDecomposition_t procedure :: Free => Free_DomainDecomposition_t procedure :: GenerateDecomposition => GenerateDecomposition_DomainDecomposition_t procedure :: SetElemToRank => SetElemToRank_DomainDecomposition_t procedure , public :: FinalizeMPIExchangeAsync endtype DomainDecomposition_t","tags":"","loc":"type/domaindecomposition_t.html"},{"title":"Tensor3D_t – SELF ","text":"type, public, extends( SELF_DataObj ) :: Tensor3D_t Contents Variables M N boundary eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures BoundaryInterp Determinant Determinant_Tensor3D_t Free Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost Source Code Tensor3D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: boundary type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor3D_t public subroutine BoundaryInterp_Tensor3D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this generic, public :: Determinant => Determinant_Tensor3D_t public subroutine Determinant_Tensor3D_t (this, det) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(in) :: this real(kind=prec), intent(out) :: det (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, private :: Determinant_Tensor3D_t public subroutine Determinant_Tensor3D_t (this, det) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(in) :: this real(kind=prec), intent(out) :: det (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: Free => Free_Tensor3D_t public subroutine Free_Tensor3D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this procedure, public :: Init => Init_Tensor3D_t public subroutine Init_Tensor3D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Tensor3D_t public subroutine UpdateDevice_Tensor3D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Tensor3D_t public subroutine UpdateHost_Tensor3D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this Source Code type , extends ( SELF_DataObj ), public :: Tensor3D_t real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:,:) :: interior real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:,:) :: boundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:,:) :: extBoundary contains procedure , public :: Init => Init_Tensor3D_t procedure , public :: Free => Free_Tensor3D_t procedure , public :: BoundaryInterp => BoundaryInterp_Tensor3D_t procedure , public :: UpdateHost => UpdateHost_Tensor3D_t procedure , public :: UpdateDevice => UpdateDevice_Tensor3D_t generic , public :: Determinant => Determinant_Tensor3D_t procedure , private :: Determinant_Tensor3D_t endtype Tensor3D_t","tags":"","loc":"type/tensor3d_t.html"},{"title":"advection_diffusion_1d_t – SELF ","text":"type, public, extends( DGModel1D ) :: advection_diffusion_1d_t Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nu nvar solution solutionGradient source t timeIntegrator u workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1d flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code advection_diffusion_1d_t Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D public subroutine BoundaryFlux_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D public subroutine CalculateEntropy_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D public subroutine CalculateSolutionGradient_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel1D public subroutine CalculateTendency_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel1D public subroutine fluxmethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel1D_t public subroutine Free_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel1D_t public subroutine Init_DGModel1D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), target :: mesh type( Geometry1D ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel1D_t public subroutine Read_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D public subroutine setboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D public subroutine setgradientboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel1D_t public subroutine SetMetadata_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t , SetSolutionFromEqn_DGModel1D_t public subroutine SetSolutionFromChar_DGModel1D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel1D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel1D public subroutine sourcemethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D public subroutine UpdateGRK2_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D public subroutine UpdateGRK3_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D public subroutine UpdateGRK4_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel1D public subroutine UpdateSolution_DGModel1D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel1D_t public subroutine Write_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t public subroutine WriteTecplot_DGModel1D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_advection_diffusion_1d_t public pure function entropy_func_advection_diffusion_1d_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) procedure, public :: flux1d => flux1d_advection_diffusion_1d_t public pure function flux1d_advection_diffusion_1d_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) Return Value real(kind=prec)(1:this%solution%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_advection_diffusion_1d_t public pure function riemannflux1d_advection_diffusion_1d_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%solution%nvar) real(kind=prec), intent(in) :: sR (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%solution%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( dgmodel1d ) :: advection_diffusion_1d_t real ( prec ) :: nu ! diffusion coefficient real ( prec ) :: u ! constant velocity contains procedure :: riemannflux1d => riemannflux1d_advection_diffusion_1d_t procedure :: flux1d => flux1d_advection_diffusion_1d_t procedure :: entropy_func => entropy_func_advection_diffusion_1d_t endtype advection_diffusion_1d_t","tags":"","loc":"type/advection_diffusion_1d_t.html"},{"title":"DGModel1D_t – SELF ","text":"type, public, extends( Model ) :: DGModel1D_t Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetSolutionFromChar_DGModel1D_t SetSolutionFromEqn_DGModel1D_t SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code DGModel1D_t Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D_t public subroutine BoundaryFlux_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D_t public subroutine CalculateEntropy_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D_t public subroutine CalculateSolutionGradient_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel1D_t public subroutine CalculateTendency_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel1D_t public subroutine fluxmethod_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel1D_t public subroutine Free_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel1D_t public subroutine Init_DGModel1D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), target :: mesh type( Geometry1D ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel1D_t public subroutine Read_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D_t public subroutine setboundarycondition_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D_t public subroutine setgradientboundarycondition_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel1D_t public subroutine SetMetadata_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t , SetSolutionFromEqn_DGModel1D_t public subroutine SetSolutionFromChar_DGModel1D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel1D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) procedure, private :: SetSolutionFromChar_DGModel1D_t public subroutine SetSolutionFromChar_DGModel1D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) procedure, private :: SetSolutionFromEqn_DGModel1D_t public subroutine SetSolutionFromEqn_DGModel1D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel1D_t public subroutine sourcemethod_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D_t public subroutine UpdateGRK2_DGModel1D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D_t public subroutine UpdateGRK3_DGModel1D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D_t public subroutine UpdateGRK4_DGModel1D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel1D_t public subroutine UpdateSolution_DGModel1D_t (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel1D_t public subroutine Write_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t public subroutine WriteTecplot_DGModel1D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( Model ) :: DGModel1D_t type ( MappedScalar1D ) :: solution type ( MappedScalar1D ) :: solutionGradient type ( MappedScalar1D ) :: flux type ( MappedScalar1D ) :: source type ( MappedScalar1D ) :: fluxDivergence type ( MappedScalar1D ) :: dSdt type ( MappedScalar1D ) :: workSol type ( Mesh1D ), pointer :: mesh type ( Geometry1D ), pointer :: geometry contains procedure :: Init => Init_DGModel1D_t procedure :: SetMetadata => SetMetadata_DGModel1D_t procedure :: Free => Free_DGModel1D_t procedure :: CalculateEntropy => CalculateEntropy_DGModel1D_t procedure :: BoundaryFlux => BoundaryFlux_DGModel1D_t procedure :: FluxMethod => fluxmethod_DGModel1D_t procedure :: SourceMethod => sourcemethod_DGModel1D_t procedure :: SetBoundaryCondition => setboundarycondition_DGModel1D_t procedure :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D_t procedure :: UpdateSolution => UpdateSolution_DGModel1D_t procedure :: UpdateGRK2 => UpdateGRK2_DGModel1D_t procedure :: UpdateGRK3 => UpdateGRK3_DGModel1D_t procedure :: UpdateGRK4 => UpdateGRK4_DGModel1D_t procedure :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D_t procedure :: CalculateTendency => CalculateTendency_DGModel1D_t generic :: SetSolution => SetSolutionFromChar_DGModel1D_t , & SetSolutionFromEqn_DGModel1D_t procedure , private :: SetSolutionFromChar_DGModel1D_t procedure , private :: SetSolutionFromEqn_DGModel1D_t procedure :: ReadModel => Read_DGModel1D_t procedure :: WriteModel => Write_DGModel1D_t procedure :: WriteTecplot => WriteTecplot_DGModel1D_t endtype DGModel1D_t","tags":"","loc":"type/dgmodel1d_t.html"},{"title":"advection_diffusion_3d_t – SELF ","text":"type, public, extends( DGModel3D ) :: advection_diffusion_3d_t Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nu nvar solution solutionGradient source t timeIntegrator u v w workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3d hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code advection_diffusion_3d_t Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v real(kind=prec), public :: w type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D public subroutine BoundaryFlux_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D public subroutine CalculateEntropy_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D public subroutine CalculateSolutionGradient_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel3D public subroutine CalculateTendency_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel3D public subroutine fluxmethod_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel3D_t public subroutine Free_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel3D_t public subroutine Init_DGModel3D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh3D ), intent(in), target :: mesh type( SEMHex ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel3D_t public subroutine Read_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D public subroutine setboundarycondition_DGModel3D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D public subroutine setgradientboundarycondition_DGModel3D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel3D_t public subroutine SetMetadata_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t , SetSolutionFromEqn_DGModel3D_t public subroutine SetSolutionFromChar_DGModel3D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel3D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel3D public subroutine sourcemethod_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D public subroutine UpdateGRK2_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D public subroutine UpdateGRK3_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D public subroutine UpdateGRK4_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel3D public subroutine UpdateSolution_DGModel3D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel3D_t public subroutine Write_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t public subroutine WriteTecplot_DGModel3D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_advection_diffusion_3d_t public pure function entropy_func_advection_diffusion_3d_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3d => flux3d_advection_diffusion_3d_t public pure function flux3d_advection_diffusion_3d_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar,1:3) Return Value real(kind=prec)(1:this%solution%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_advection_diffusion_3d_t public pure function riemannflux3d_advection_diffusion_3d_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( dgmodel3d ) :: advection_diffusion_3d_t real ( prec ) :: nu ! diffusion coefficient real ( prec ) :: u ! constant x-component of velocity real ( prec ) :: v ! constant y-component of velocity real ( prec ) :: w ! constant z-component of velocity contains procedure :: riemannflux3d => riemannflux3d_advection_diffusion_3d_t procedure :: flux3d => flux3d_advection_diffusion_3d_t procedure :: entropy_func => entropy_func_advection_diffusion_3d_t endtype advection_diffusion_3d_t","tags":"","loc":"type/advection_diffusion_3d_t.html"},{"title":"Scalar1D_t – SELF ","text":"type, public, extends( SELF_DataObj ) :: Scalar1D_t Contents Variables M N avgBoundary boundary boundarynormal eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Derivative Derivative_Scalar1D_t Free GridInterp GridInterp_Scalar1D_t Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 WriteHDF5_Scalar1D_t Source Code Scalar1D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: avgBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundarynormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar1D_t public subroutine AverageSides_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D_t public subroutine BoundaryInterp_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this generic, public :: Derivative => Derivative_Scalar1D_t public subroutine Derivative_Scalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%nelem,1:this%nvar) procedure, private :: Derivative_Scalar1D_t public subroutine Derivative_Scalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: Free => Free_Scalar1D_t public subroutine Free_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this generic, public :: GridInterp => GridInterp_Scalar1D_t public subroutine GridInterp_Scalar1D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%nelem,1:this%nvar) procedure, private :: GridInterp_Scalar1D_t public subroutine GridInterp_Scalar1D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%nelem,1:this%nvar) procedure, public :: Init => Init_Scalar1D_t public subroutine Init_Scalar1D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Scalar1D_t public subroutine UpdateDevice_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar1D_t public subroutine UpdateHost_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_Scalar1D_t public subroutine WriteHDF5_Scalar1D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group procedure, private :: WriteHDF5_Scalar1D_t public subroutine WriteHDF5_Scalar1D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( SELF_DataObj ), public :: Scalar1D_t real ( prec ), pointer , contiguous , dimension (:,:,:) :: interior real ( prec ), pointer , contiguous , dimension (:,:,:) :: boundary real ( prec ), pointer , contiguous , dimension (:,:,:) :: boundarynormal real ( prec ), pointer , contiguous , dimension (:,:,:) :: extBoundary real ( prec ), pointer , contiguous , dimension (:,:,:) :: avgBoundary contains procedure , public :: Init => Init_Scalar1D_t procedure , public :: Free => Free_Scalar1D_t procedure , public :: UpdateHost => UpdateHost_Scalar1D_t procedure , public :: UpdateDevice => UpdateDevice_Scalar1D_t procedure , public :: AverageSides => AverageSides_Scalar1D_t procedure , public :: BoundaryInterp => BoundaryInterp_Scalar1D_t generic , public :: GridInterp => GridInterp_Scalar1D_t procedure , private :: GridInterp_Scalar1D_t generic , public :: Derivative => Derivative_Scalar1D_t procedure , private :: Derivative_Scalar1D_t generic , public :: WriteHDF5 => WriteHDF5_Scalar1D_t procedure , private :: WriteHDF5_Scalar1D_t endtype Scalar1D_t","tags":"","loc":"type/scalar1d_t.html"},{"title":"MappedScalar2D_t – SELF ","text":"type, public, extends( Scalar2D ) :: MappedScalar2D_t Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundary_gpu boundarynormal boundarynormal_gpu eqn extBoundary extBoundary_gpu geometry geometry_associated interior interior_gpu interp interpWork meta nElem nVar Type-Bound Procedures ApplyFlip AssociateGeometry AverageSides BoundaryInterp DissociateGeometry Free Gradient GridInterp Init MPIExchangeAsync MappedDGGradient MappedDGGradient_MappedScalar2D_t MappedGradient MappedGradient_MappedScalar2D_t SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedScalar2D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMQuad ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedScalar2D_t public subroutine ApplyFlip_MappedScalar2D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( Mesh2D ), intent(in) :: mesh procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar2D_t public subroutine AssociateGeometry_MappedScalar2D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( SEMQuad ), intent(in), target :: geometry procedure, public :: AverageSides => AverageSides_Scalar2D public subroutine AverageSides_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D public subroutine BoundaryInterp_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar2D_t public subroutine DissociateGeometry_MappedScalar2D_t (this) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this procedure, public :: Free => Free_Scalar2D public subroutine Free_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this generic, public :: Gradient => Gradient_Scalar2D_t , Gradient_Scalar2D public subroutine Gradient_Scalar2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) public subroutine Gradient_Scalar2D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Scalar2D_t , GridInterp_Scalar2D public subroutine GridInterp_Scalar2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) public subroutine GridInterp_Scalar2D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Scalar2D public subroutine Init_Scalar2D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D_t public subroutine MPIExchangeAsync_MappedScalar2D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh generic, public :: MappedDGGradient => MappedDGGradient_MappedScalar2D_t public subroutine MappedDGGradient_MappedScalar2D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) procedure, private :: MappedDGGradient_MappedScalar2D_t public subroutine MappedDGGradient_MappedScalar2D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) generic, public :: MappedGradient => MappedGradient_MappedScalar2D_t public subroutine MappedGradient_MappedScalar2D_t (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) procedure, private :: MappedGradient_MappedScalar2D_t public subroutine MappedGradient_MappedScalar2D_t (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar2D_t public subroutine SetInteriorFromEquation_MappedScalar2D_t (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedScalar2D_t public subroutine SideExchange_MappedScalar2D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh procedure, public :: UpdateDevice => UpdateDevice_Scalar2D public subroutine UpdateDevice_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar2D public subroutine UpdateHost_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D_t , WriteHDF5_Scalar2D_t public subroutine WriteHDF5_MPI_Scalar2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Scalar2D ), public :: MappedScalar2D_t logical :: geometry_associated = . false . type ( SEMQuad ), pointer :: geometry => null () contains procedure , public :: AssociateGeometry => AssociateGeometry_MappedScalar2D_t procedure , public :: DissociateGeometry => DissociateGeometry_MappedScalar2D_t procedure , public :: SideExchange => SideExchange_MappedScalar2D_t generic , public :: MappedGradient => MappedGradient_MappedScalar2D_t procedure , private :: MappedGradient_MappedScalar2D_t generic , public :: MappedDGGradient => MappedDGGradient_MappedScalar2D_t procedure , private :: MappedDGGradient_MappedScalar2D_t procedure , private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D_t procedure , private :: ApplyFlip => ApplyFlip_MappedScalar2D_t procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar2D_t endtype MappedScalar2D_t","tags":"","loc":"type/mappedscalar2d_t.html"},{"title":"MappedScalar3D_t – SELF ","text":"type, public, extends( Scalar3D ) :: MappedScalar3D_t Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundary_gpu boundarynormal boundarynormal_gpu eqn extBoundary extBoundary_gpu geometry geometry_associated interior interior_gpu interp interpWork1 interpWork2 meta nElem nVar Type-Bound Procedures ApplyFlip AssociateGeometry AverageSides BoundaryInterp DissociateGeometry Free Gradient GridInterp Init MPIExchangeAsync MappedDGGradient MappedDGGradient_MappedScalar3D_t MappedGradient MappedGradient_MappedScalar3D_t SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedScalar3D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMHex ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedScalar3D_t public subroutine ApplyFlip_MappedScalar3D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar3D_t public subroutine AssociateGeometry_MappedScalar3D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( SEMHex ), intent(in), target :: geometry procedure, public :: AverageSides => AverageSides_Scalar3D public subroutine AverageSides_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D public subroutine BoundaryInterp_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar3D_t public subroutine DissociateGeometry_MappedScalar3D_t (this) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this procedure, public :: Free => Free_Scalar3D public subroutine Free_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this generic, public :: Gradient => Gradient_Scalar3D_t , Gradient_Scalar3D public subroutine Gradient_Scalar3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) public subroutine Gradient_Scalar3D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Scalar3D_t , GridInterp_Scalar3D public subroutine GridInterp_Scalar3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) (Output) Array of function values, defined on the target grid public subroutine GridInterp_Scalar3D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Scalar3D public subroutine Init_Scalar3D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D_t public subroutine MPIExchangeAsync_MappedScalar3D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh generic, public :: MappedDGGradient => MappedDGGradient_MappedScalar3D_t public subroutine MappedDGGradient_MappedScalar3D_t (this, df) Calculates the gradient of a function using the weak form of the gradient\nand the average boundary state.\nThis method will compute the average boundary state from the\nand  attributes of Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) procedure, private :: MappedDGGradient_MappedScalar3D_t public subroutine MappedDGGradient_MappedScalar3D_t (this, df) Calculates the gradient of a function using the weak form of the gradient\nand the average boundary state.\nThis method will compute the average boundary state from the\nand  attributes of Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) generic, public :: MappedGradient => MappedGradient_MappedScalar3D_t public subroutine MappedGradient_MappedScalar3D_t (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) procedure, private :: MappedGradient_MappedScalar3D_t public subroutine MappedGradient_MappedScalar3D_t (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar3D_t public subroutine SetInteriorFromEquation_MappedScalar3D_t (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedScalar3D_t public subroutine SideExchange_MappedScalar3D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh procedure, public :: UpdateDevice => UpdateDevice_Scalar3D public subroutine UpdateDevice_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar3D public subroutine UpdateHost_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D_t , WriteHDF5_Scalar3D_t public subroutine WriteHDF5_MPI_Scalar3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Scalar3D ), public :: MappedScalar3D_t logical :: geometry_associated = . false . type ( SEMHex ), pointer :: geometry => null () contains procedure , public :: AssociateGeometry => AssociateGeometry_MappedScalar3D_t procedure , public :: DissociateGeometry => DissociateGeometry_MappedScalar3D_t procedure , public :: SideExchange => SideExchange_MappedScalar3D_t generic , public :: MappedGradient => MappedGradient_MappedScalar3D_t procedure , private :: MappedGradient_MappedScalar3D_t generic , public :: MappedDGGradient => MappedDGGradient_MappedScalar3D_t procedure , private :: MappedDGGradient_MappedScalar3D_t procedure , private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D_t procedure , private :: ApplyFlip => ApplyFlip_MappedScalar3D_t procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar3D_t ! procedure,public :: WriteTecplot => WriteTecplot_MappedScalar3D_t endtype MappedScalar3D_t","tags":"","loc":"type/mappedscalar3d_t.html"},{"title":"NullDGModel3D – SELF ","text":"type, public, extends( NullDGModel3D_t ) :: NullDGModel3D Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code NullDGModel3D Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D public subroutine BoundaryFlux_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D public subroutine CalculateEntropy_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D public subroutine CalculateSolutionGradient_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel3D public subroutine CalculateTendency_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel3D public subroutine fluxmethod_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel3D_t public subroutine Free_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel3D_t public subroutine Init_DGModel3D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh3D ), intent(in), target :: mesh type( SEMHex ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel3D_t public subroutine Read_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D public subroutine setboundarycondition_DGModel3D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D public subroutine setgradientboundarycondition_DGModel3D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel3D_t public subroutine SetMetadata_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t , SetSolutionFromEqn_DGModel3D_t public subroutine SetSolutionFromChar_DGModel3D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel3D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel3D public subroutine sourcemethod_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D public subroutine UpdateGRK2_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D public subroutine UpdateGRK3_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D public subroutine UpdateGRK4_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel3D public subroutine UpdateSolution_DGModel3D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel3D_t public subroutine Write_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t public subroutine WriteTecplot_DGModel3D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( NullDGModel3D_t ) :: NullDGModel3D endtype NullDGModel3D","tags":"","loc":"type/nulldgmodel3d.html"},{"title":"MappedScalar3D – SELF ","text":"type, public, extends( MappedScalar3D_t ) :: MappedScalar3D Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundary_gpu boundarynormal boundarynormal_gpu eqn extBoundary extBoundary_gpu geometry geometry_associated interior interior_gpu interp interpWork1 interpWork2 jas_gpu meta nElem nVar Type-Bound Procedures AssociateGeometry AverageSides BoundaryInterp DissociateGeometry Free Gradient GridInterp Init MPIExchangeAsync MappedDGGradient MappedDGGradient_MappedScalar3D MappedGradient MappedGradient_MappedScalar3D SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedScalar3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMHex ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type(c_ptr), public :: jas_gpu type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar3D_t public subroutine AssociateGeometry_MappedScalar3D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( SEMHex ), intent(in), target :: geometry procedure, public :: AverageSides => AverageSides_Scalar3D public subroutine AverageSides_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D public subroutine BoundaryInterp_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar3D_t public subroutine DissociateGeometry_MappedScalar3D_t (this) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this procedure, public :: Free => Free_MappedScalar3D public subroutine Free_MappedScalar3D (this) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this generic, public :: Gradient => Gradient_Scalar3D_t , Gradient_Scalar3D public subroutine Gradient_Scalar3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) public subroutine Gradient_Scalar3D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Scalar3D_t , GridInterp_Scalar3D public subroutine GridInterp_Scalar3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) (Output) Array of function values, defined on the target grid public subroutine GridInterp_Scalar3D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_MappedScalar3D public subroutine Init_MappedScalar3D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D public subroutine MPIExchangeAsync_MappedScalar3D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh generic, public :: MappedDGGradient => MappedDGGradient_MappedScalar3D_t , MappedDGGradient_MappedScalar3D public subroutine MappedDGGradient_MappedScalar3D_t (this, df) Calculates the gradient of a function using the weak form of the gradient\nand the average boundary state.\nThis method will compute the average boundary state from the\nand  attributes of Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) public subroutine MappedDGGradient_MappedScalar3D (this, df) Calculates the gradient of a function using the weak form of the gradient\nand the average boundary state.\nThis method will compute the average boundary state from the\nand  attributes of Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, private :: MappedDGGradient_MappedScalar3D public subroutine MappedDGGradient_MappedScalar3D (this, df) Calculates the gradient of a function using the weak form of the gradient\nand the average boundary state.\nThis method will compute the average boundary state from the\nand  attributes of Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: MappedGradient => MappedGradient_MappedScalar3D_t , MappedGradient_MappedScalar3D public subroutine MappedGradient_MappedScalar3D_t (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) public subroutine MappedGradient_MappedScalar3D (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this type(c_ptr), intent(out) :: df procedure, private :: MappedGradient_MappedScalar3D public subroutine MappedGradient_MappedScalar3D (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this type(c_ptr), intent(out) :: df procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar3D public subroutine SetInteriorFromEquation_MappedScalar3D (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedScalar3D public subroutine SideExchange_MappedScalar3D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh procedure, public :: UpdateDevice => UpdateDevice_Scalar3D public subroutine UpdateDevice_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar3D public subroutine UpdateHost_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D_t , WriteHDF5_Scalar3D_t public subroutine WriteHDF5_MPI_Scalar3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( MappedScalar3D_t ), public :: MappedScalar3D type ( c_ptr ) :: jas_gpu ! jacobian weighted scalar for gradient calculation contains procedure , public :: Init => Init_MappedScalar3D procedure , public :: Free => Free_MappedScalar3D procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar3D procedure , public :: SideExchange => SideExchange_MappedScalar3D procedure , private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D generic , public :: MappedGradient => MappedGradient_MappedScalar3D procedure , private :: MappedGradient_MappedScalar3D generic , public :: MappedDGGradient => MappedDGGradient_MappedScalar3D procedure , private :: MappedDGGradient_MappedScalar3D endtype MappedScalar3D","tags":"","loc":"type/mappedscalar3d.html"},{"title":"Vector3D – SELF ","text":"type, public, extends( Vector3D_t ) :: Vector3D Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundaryNormal boundaryNormal_gpu boundary_gpu eqn extBoundary extBoundary_gpu interior interior_gpu interp interpWork1 interpWork2 meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Curl Divergence Divergence_Vector3D Free Gradient Gradient_Vector3D GridInterp GridInterp_Vector3D Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 Source Code Vector3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Vector3D public subroutine AverageSides_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D public subroutine BoundaryInterp_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this generic, public :: Curl => Curl_Vector3D_t public subroutine Curl_Vector3D_t (this, curlf) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: curlf (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) generic, public :: Divergence => Divergence_Vector3D_t , Divergence_Vector3D public subroutine Divergence_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Divergence_Vector3D (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, private :: Divergence_Vector3D public subroutine Divergence_Vector3D (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, public :: Free => Free_Vector3D public subroutine Free_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this generic, public :: Gradient => Gradient_Vector3D_t , Gradient_Vector3D public subroutine Gradient_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3,1:3) public subroutine Gradient_Vector3D (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, private :: Gradient_Vector3D public subroutine Gradient_Vector3D (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Vector3D_t , GridInterp_Vector3D public subroutine GridInterp_Vector3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:3) (Output) Array of function values, defined on the target grid public subroutine GridInterp_Vector3D (this, f) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, private :: GridInterp_Vector3D public subroutine GridInterp_Vector3D (this, f) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Vector3D public subroutine Init_Vector3D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector3D_t public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector3D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Vector3D public subroutine UpdateDevice_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Vector3D public subroutine UpdateHost_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D_t , WriteHDF5_Vector3D_t public subroutine WriteHDF5_MPI_Vector3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Vector3D_t ), public :: Vector3D character ( 3 ) :: backend = \"gpu\" type ( c_ptr ) :: blas_handle type ( c_ptr ) :: interior_gpu type ( c_ptr ) :: boundary_gpu type ( c_ptr ) :: extBoundary_gpu type ( c_ptr ) :: avgBoundary_gpu type ( c_ptr ) :: boundaryNormal_gpu type ( c_ptr ) :: interpWork1 type ( c_ptr ) :: interpWork2 contains procedure , public :: Init => Init_Vector3D procedure , public :: Free => Free_Vector3D procedure , public :: UpdateHost => UpdateHost_Vector3D procedure , public :: UpdateDevice => UpdateDevice_Vector3D procedure , public :: BoundaryInterp => BoundaryInterp_Vector3D procedure , public :: AverageSides => AverageSides_Vector3D generic , public :: GridInterp => GridInterp_Vector3D procedure , private :: GridInterp_Vector3D generic , public :: Gradient => Gradient_Vector3D procedure , private :: Gradient_Vector3D ! generic,public :: Curl => Curl_Vector3D ! procedure,private :: Curl_Vector3D generic , public :: Divergence => Divergence_Vector3D procedure , private :: Divergence_Vector3D endtype Vector3D","tags":"","loc":"type/vector3d.html"},{"title":"Burgers1D – SELF ","text":"type, public, extends( Burgers1D_t ) :: Burgers1D Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nu nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1d flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code Burgers1D Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh real(kind=prec), public :: nu = 0.0_prec integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D public subroutine BoundaryFlux_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D public subroutine CalculateEntropy_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D public subroutine CalculateSolutionGradient_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel1D public subroutine CalculateTendency_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel1D public subroutine fluxmethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel1D_t public subroutine Free_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel1D_t public subroutine Init_DGModel1D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), target :: mesh type( Geometry1D ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel1D_t public subroutine Read_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D public subroutine setboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D public subroutine setgradientboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_Burgers1D_t public subroutine SetMetadata_Burgers1D_t (this) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t , SetSolutionFromEqn_DGModel1D_t public subroutine SetSolutionFromChar_DGModel1D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel1D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel1D public subroutine sourcemethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D public subroutine UpdateGRK2_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D public subroutine UpdateGRK3_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D public subroutine UpdateGRK4_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel1D public subroutine UpdateSolution_DGModel1D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel1D_t public subroutine Write_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t public subroutine WriteTecplot_DGModel1D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Burgers1D_t public pure function entropy_func_Burgers1D_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) procedure, public :: flux1d => flux1d_Burgers1D_t public pure function flux1d_Burgers1D_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) Return Value real(kind=prec)(1:this%solution%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Burgers1D_t public pure function riemannflux1d_Burgers1D_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%solution%nvar) real(kind=prec), intent(in) :: sR (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%solution%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( Burgers1D_t ) :: Burgers1D endtype Burgers1D","tags":"","loc":"type/burgers1d.html"},{"title":"Lagrange – SELF ","text":"type, public, extends( Lagrange_t ) :: Lagrange Contents Variables M N bMatrix bMatrix_gpu bWeights backend blas_handle controlNodeType controlPoints dMatrix dMatrix_gpu dgMatrix dgMatrix_gpu iMatrix iMatrix_gpu qWeights qWeights_gpu targetNodeType targetPoints Type-Bound Procedures CalculateBarycentricWeights CalculateDerivativeMatrix CalculateInterpolationMatrix CalculateLagrangePolynomials Free Init WriteHDF5 Source Code Lagrange Components Type Visibility Attributes Name Initial integer, public :: M The number of target points. integer, public :: N The number of control points. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: bMatrix The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. type(c_ptr), public :: bMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:) :: bWeights The barycentric weights that are calculated from the controlPoints and used for interpolation. character(len=3), public :: backend = 'gpu' type(c_ptr), public :: blas_handle = c_null_ptr A handle for working with hipblas integer, public :: controlNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: controlPoints The set of nodes in one dimension where data is known.\nTo create higher dimension interpolation and differentiation operators, structured grids in two and three\ndimensions are created by tensor products of the controlPoints. This design decision implies that all\nspectral element methods supported by the Lagrange class have the same polynomial degree in each\ncomputational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto,\nLegendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over\nthe domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of\nthese quadrature types or uniform points on [-1,1]. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The\ndMatrix is based on a strong form of the derivative. type(c_ptr), public :: dMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dgMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based\non a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. type(c_ptr), public :: dgMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:) :: iMatrix The interpolation matrix (transpose) for mapping data from the control grid to the target grid. type(c_ptr), public :: iMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:) :: qWeights The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints\nprovided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss,\nChebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant . type(c_ptr), public :: qWeights_gpu integer, public :: targetNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: targetPoints The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation\nand differentiation operators, structured grids in two and three dimensions are created by tensor products of\nthe targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1]\n(computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. Type-Bound Procedures procedure, public :: CalculateBarycentricWeights public subroutine CalculateBarycentricWeights (this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this procedure, public :: CalculateDerivativeMatrix public subroutine CalculateDerivativeMatrix (this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this procedure, public :: CalculateInterpolationMatrix public subroutine CalculateInterpolationMatrix (this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this procedure, public :: CalculateLagrangePolynomials public function CalculateLagrangePolynomials (this, sE) result(lAtS) Arguments Type Intent Optional Attributes Name class( Lagrange_t ) :: this real(kind=prec) :: sE Return Value real(kind=prec)(0:this%N) procedure, public :: Free => Free_Lagrange public subroutine Free_Lagrange (this) Frees all memory (host and device) associated with an instance of the Lagrange class Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: this Lagrange class instance procedure, public :: Init => Init_Lagrange public subroutine Init_Lagrange (this, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange class\nOn output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(out) :: this Lagrange class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) procedure, public :: WriteHDF5 => WriteHDF5_Lagrange_t public subroutine WriteHDF5_Lagrange_t (this, fileId) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId Source Code type , extends ( Lagrange_t ), public :: Lagrange character ( 3 ) :: backend = 'gpu' type ( c_ptr ) :: qWeights_gpu type ( c_ptr ) :: iMatrix_gpu type ( c_ptr ) :: dMatrix_gpu type ( c_ptr ) :: dgMatrix_gpu type ( c_ptr ) :: bMatrix_gpu contains procedure , public :: Init => Init_Lagrange procedure , public :: Free => Free_Lagrange endtype Lagrange","tags":"","loc":"type/lagrange.html"},{"title":"DomainDecomposition – SELF ","text":"type, public, extends( DomainDecomposition_t ) :: DomainDecomposition Contents Variables elemToRank elemToRank_gpu maxMsg mpiComm mpiEnabled mpiPrec msgCount nElem nRanks offSetElem rankId requests stats Type-Bound Procedures FinalizeMPIExchangeAsync Free GenerateDecomposition Init SetElemToRank Source Code DomainDecomposition Components Type Visibility Attributes Name Initial integer, public, pointer, dimension(:) :: elemToRank type(c_ptr), public :: elemToRank_gpu integer, public :: maxMsg integer, public :: mpiComm logical, public :: mpiEnabled integer, public :: mpiPrec integer, public :: msgCount integer, public :: nElem integer, public :: nRanks integer, public, pointer, dimension(:) :: offSetElem integer, public :: rankId integer, public, allocatable :: requests (:) integer, public, allocatable :: stats (:,:) Type-Bound Procedures procedure, public :: FinalizeMPIExchangeAsync public subroutine FinalizeMPIExchangeAsync (mpiHandler) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: mpiHandler procedure, public :: Free => Free_DomainDecomposition public subroutine Free_DomainDecomposition (this) Arguments Type Intent Optional Attributes Name class( DomainDecomposition ), intent(inout) :: this procedure, public :: GenerateDecomposition => GenerateDecomposition_DomainDecomposition_t public subroutine GenerateDecomposition_DomainDecomposition_t (this, nGlobalElem, maxMsg) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this integer, intent(in) :: nGlobalElem integer, intent(in) :: maxMsg procedure, public :: Init => Init_DomainDecomposition_t public subroutine Init_DomainDecomposition_t (this, enableMPI) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this logical, intent(in) :: enableMPI procedure, public :: SetElemToRank => SetElemToRank_DomainDecomposition public subroutine SetElemToRank_DomainDecomposition (this, nElem) Arguments Type Intent Optional Attributes Name class( DomainDecomposition ), intent(inout) :: this integer, intent(in) :: nElem Source Code type , extends ( DomainDecomposition_t ) :: DomainDecomposition type ( c_ptr ) :: elemToRank_gpu contains procedure :: Free => Free_DomainDecomposition procedure :: SetElemToRank => SetElemToRank_DomainDecomposition endtype DomainDecomposition","tags":"","loc":"type/domaindecomposition.html"},{"title":"Mesh2D – SELF ","text":"type, public, extends( Mesh2D_t ) :: Mesh2D Contents Variables BCNames BCType CGNSCornerMap CGNSSideMap decomp elemInfo globalNodeIDs nBCs nCornerNodes nElem nGeo nGlobalElem nNodes nSides nUniqueNodes nUniqueSides nodeCoords quadrature sideInfo sideInfo_gpu Type-Bound Procedures Free Init Read_HOPr RecalculateFlip ResetBoundaryConditionType StructuredMesh Write_Mesh Source Code Mesh2D Components Type Visibility Attributes Name Initial character(len=255), public, allocatable :: BCNames (:) integer, public, pointer, dimension(:,:) :: BCType integer, public, pointer, dimension(:,:) :: CGNSCornerMap integer, public, pointer, dimension(:,:) :: CGNSSideMap type( DomainDecomposition ), public :: decomp integer, public, pointer, dimension(:,:) :: elemInfo integer, public, pointer, dimension(:,:,:) :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides real(kind=prec), public, pointer, dimension(:,:,:,:) :: nodeCoords integer, public :: quadrature integer, public, pointer, dimension(:,:,:) :: sideInfo type(c_ptr), public :: sideInfo_gpu Type-Bound Procedures procedure, public :: Free => Free_Mesh2D public subroutine Free_Mesh2D (this) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: this procedure, public :: Init => Init_Mesh2D public subroutine Init_Mesh2D (this, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: this integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs procedure, public :: Read_HOPr => Read_HOPr_Mesh2D public subroutine Read_HOPr_Mesh2D (this, meshFile, enableDomainDecomposition) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: this character, intent(in) :: meshFile logical, intent(in), optional :: enableDomainDecomposition procedure, public :: RecalculateFlip => RecalculateFlip_Mesh2D_t public subroutine RecalculateFlip_Mesh2D_t (this) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh2D_t public subroutine ResetBoundaryConditionType_Mesh2D_t (this, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Read more… Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this integer, intent(in) :: bcid generic, public :: StructuredMesh => UniformStructuredMesh_Mesh2D_t public subroutine UniformStructuredMesh_Mesh2D_t (this, nxPerTile, nyPerTile, nTileX, nTileY, dx, dy, bcids, enableDomainDecomposition) Create a structured mesh and store it in SELF's unstructured mesh format.\nThe mesh is created in tiles of size (tnx,tny). Tiling is used to determine\nthe element ordering. Read more… Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(out) :: this integer, intent(in) :: nxPerTile integer, intent(in) :: nyPerTile integer, intent(in) :: nTileX integer, intent(in) :: nTileY real(kind=prec), intent(in) :: dx real(kind=prec), intent(in) :: dy integer, intent(in) :: bcids (1:4) logical, intent(in), optional :: enableDomainDecomposition procedure, public :: Write_Mesh => Write_Mesh2D_t public subroutine Write_Mesh2D_t (this, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this character, intent(in) :: meshFile Source Code type , extends ( Mesh2D_t ) :: Mesh2D type ( c_ptr ) :: sideInfo_gpu contains procedure , public :: Init => Init_Mesh2D procedure , public :: Free => Free_Mesh2D procedure , public :: Read_HOPr => Read_HOPr_Mesh2D endtype Mesh2D","tags":"","loc":"type/mesh2d.html"},{"title":"Scalar1D – SELF ","text":"type, public, extends( Scalar1D_t ) :: Scalar1D Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundary_gpu boundarynormal boundarynormal_gpu eqn extBoundary extBoundary_gpu interior interior_gpu interp meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Derivative Derivative_Scalar1D Free GridInterp GridInterp_Scalar1D Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 Source Code Scalar1D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar1D public subroutine AverageSides_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D public subroutine BoundaryInterp_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this generic, public :: Derivative => Derivative_Scalar1D_t , Derivative_Scalar1D public subroutine Derivative_Scalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Derivative_Scalar1D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, private :: Derivative_Scalar1D public subroutine Derivative_Scalar1D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, public :: Free => Free_Scalar1D public subroutine Free_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this generic, public :: GridInterp => GridInterp_Scalar1D_t , GridInterp_Scalar1D public subroutine GridInterp_Scalar1D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%nelem,1:this%nvar) public subroutine GridInterp_Scalar1D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: f procedure, private :: GridInterp_Scalar1D public subroutine GridInterp_Scalar1D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Scalar1D public subroutine Init_Scalar1D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Scalar1D public subroutine UpdateDevice_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar1D public subroutine UpdateHost_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_Scalar1D_t public subroutine WriteHDF5_Scalar1D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Scalar1D_t ), public :: Scalar1D character ( 3 ) :: backend = \"gpu\" type ( c_ptr ) :: blas_handle type ( c_ptr ) :: interior_gpu type ( c_ptr ) :: boundary_gpu type ( c_ptr ) :: extBoundary_gpu type ( c_ptr ) :: avgBoundary_gpu type ( c_ptr ) :: boundarynormal_gpu contains procedure , public :: Init => Init_Scalar1D procedure , public :: Free => Free_Scalar1D procedure , public :: UpdateHost => UpdateHost_Scalar1D procedure , public :: UpdateDevice => UpdateDevice_Scalar1D procedure , public :: AverageSides => AverageSides_Scalar1D procedure , public :: BoundaryInterp => BoundaryInterp_Scalar1D generic , public :: GridInterp => GridInterp_Scalar1D procedure , private :: GridInterp_Scalar1D generic , public :: Derivative => Derivative_Scalar1D procedure , private :: Derivative_Scalar1D endtype Scalar1D","tags":"","loc":"type/scalar1d.html"},{"title":"advection_diffusion_2d – SELF ","text":"type, public, extends( advection_diffusion_2d_t ) :: advection_diffusion_2d Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nu nvar solution solutionGradient source t timeIntegrator u v workSol Type-Bound Procedures CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot boundaryflux entropy_func flux1D flux2d flux3D fluxmethod hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d setboundarycondition setgradientboundarycondition source1d source2d source3d Source Code advection_diffusion_2d Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: CalculateEntropy => CalculateEntropy_advection_diffusion_2d public subroutine CalculateEntropy_advection_diffusion_2d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D public subroutine CalculateSolutionGradient_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel2D public subroutine CalculateTendency_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel2D_t public subroutine Free_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel2D_t public subroutine Init_DGModel2D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), target :: mesh type( SEMQuad ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel2D_t public subroutine Read_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetMetadata => SetMetadata_DGModel2D_t public subroutine SetMetadata_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t , SetSolutionFromEqn_DGModel2D_t public subroutine SetSolutionFromChar_DGModel2D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel2D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel2D public subroutine sourcemethod_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D public subroutine UpdateGRK2_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D public subroutine UpdateGRK3_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D public subroutine UpdateGRK4_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel2D public subroutine UpdateSolution_DGModel2D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel2D_t public subroutine Write_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t public subroutine WriteTecplot_DGModel2D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: boundaryflux => boundaryflux_advection_diffusion_2d public subroutine boundaryflux_advection_diffusion_2d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this procedure, public :: entropy_func => entropy_func_advection_diffusion_2d_t public pure function entropy_func_advection_diffusion_2d_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2d => flux2d_advection_diffusion_2d_t public pure function flux2d_advection_diffusion_2d_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar,1:2) Return Value real(kind=prec)(1:this%solution%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: fluxmethod => fluxmethod_advection_diffusion_2d public subroutine fluxmethod_advection_diffusion_2d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_advection_diffusion_2d_t public pure function riemannflux2d_advection_diffusion_2d_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: setboundarycondition => setboundarycondition_advection_diffusion_2d public subroutine setboundarycondition_advection_diffusion_2d (this) Boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this procedure, public :: setgradientboundarycondition => setgradientboundarycondition_advection_diffusion_2d public subroutine setgradientboundarycondition_advection_diffusion_2d (this) Gradient boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( advection_diffusion_2d_t ) :: advection_diffusion_2d contains procedure :: setboundarycondition => setboundarycondition_advection_diffusion_2d procedure :: setgradientboundarycondition => setgradientboundarycondition_advection_diffusion_2d procedure :: boundaryflux => boundaryflux_advection_diffusion_2d procedure :: fluxmethod => fluxmethod_advection_diffusion_2d procedure :: CalculateEntropy => CalculateEntropy_advection_diffusion_2d endtype advection_diffusion_2d","tags":"","loc":"type/advection_diffusion_2d.html"},{"title":"DGModel2D – SELF ","text":"type, public, extends( DGModel2D_t ) :: DGModel2D Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code DGModel2D Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D public subroutine BoundaryFlux_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D public subroutine CalculateEntropy_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D public subroutine CalculateSolutionGradient_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel2D public subroutine CalculateTendency_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel2D public subroutine fluxmethod_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel2D_t public subroutine Free_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel2D_t public subroutine Init_DGModel2D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), target :: mesh type( SEMQuad ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel2D_t public subroutine Read_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D public subroutine setboundarycondition_DGModel2D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D public subroutine setgradientboundarycondition_DGModel2D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel2D_t public subroutine SetMetadata_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t , SetSolutionFromEqn_DGModel2D_t public subroutine SetSolutionFromChar_DGModel2D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel2D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel2D public subroutine sourcemethod_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D public subroutine UpdateGRK2_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D public subroutine UpdateGRK3_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D public subroutine UpdateGRK4_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel2D public subroutine UpdateSolution_DGModel2D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel2D_t public subroutine Write_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t public subroutine WriteTecplot_DGModel2D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( DGModel2D_t ) :: DGModel2D contains procedure :: UpdateSolution => UpdateSolution_DGModel2D procedure :: CalculateEntropy => CalculateEntropy_DGModel2D procedure :: BoundaryFlux => BoundaryFlux_DGModel2D procedure :: FluxMethod => fluxmethod_DGModel2D procedure :: SourceMethod => sourcemethod_DGModel2D procedure :: SetBoundaryCondition => setboundarycondition_DGModel2D procedure :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D procedure :: UpdateGRK2 => UpdateGRK2_DGModel2D procedure :: UpdateGRK3 => UpdateGRK3_DGModel2D procedure :: UpdateGRK4 => UpdateGRK4_DGModel2D procedure :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D procedure :: CalculateTendency => CalculateTendency_DGModel2D endtype DGModel2D","tags":"","loc":"type/dgmodel2d.html"},{"title":"advection_diffusion_1d – SELF ","text":"type, public, extends( advection_diffusion_1d_t ) :: advection_diffusion_1d Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nu nvar solution solutionGradient source t timeIntegrator u workSol Type-Bound Procedures CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot boundaryflux entropy_func flux1d flux2D flux3D fluxmethod hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d setboundarycondition setgradientboundarycondition source1d source2d source3d Source Code advection_diffusion_1d Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D public subroutine CalculateEntropy_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D public subroutine CalculateSolutionGradient_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel1D public subroutine CalculateTendency_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel1D_t public subroutine Free_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel1D_t public subroutine Init_DGModel1D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), target :: mesh type( Geometry1D ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel1D_t public subroutine Read_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetMetadata => SetMetadata_DGModel1D_t public subroutine SetMetadata_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t , SetSolutionFromEqn_DGModel1D_t public subroutine SetSolutionFromChar_DGModel1D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel1D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel1D public subroutine sourcemethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D public subroutine UpdateGRK2_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D public subroutine UpdateGRK3_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D public subroutine UpdateGRK4_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel1D public subroutine UpdateSolution_DGModel1D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel1D_t public subroutine Write_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t public subroutine WriteTecplot_DGModel1D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: boundaryflux => boundaryflux_advection_diffusion_1d public subroutine boundaryflux_advection_diffusion_1d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this procedure, public :: entropy_func => entropy_func_advection_diffusion_1d_t public pure function entropy_func_advection_diffusion_1d_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) procedure, public :: flux1d => flux1d_advection_diffusion_1d_t public pure function flux1d_advection_diffusion_1d_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) Return Value real(kind=prec)(1:this%solution%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: fluxmethod => fluxmethod_advection_diffusion_1d public subroutine fluxmethod_advection_diffusion_1d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_advection_diffusion_1d_t public pure function riemannflux1d_advection_diffusion_1d_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%solution%nvar) real(kind=prec), intent(in) :: sR (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%solution%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: setboundarycondition => setboundarycondition_advection_diffusion_1d public subroutine setboundarycondition_advection_diffusion_1d (this) Boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this procedure, public :: setgradientboundarycondition => setgradientboundarycondition_advection_diffusion_1d public subroutine setgradientboundarycondition_advection_diffusion_1d (this) Gradient boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( advection_diffusion_1d_t ) :: advection_diffusion_1d contains procedure :: setboundarycondition => setboundarycondition_advection_diffusion_1d procedure :: setgradientboundarycondition => setgradientboundarycondition_advection_diffusion_1d procedure :: boundaryflux => boundaryflux_advection_diffusion_1d procedure :: fluxmethod => fluxmethod_advection_diffusion_1d endtype advection_diffusion_1d","tags":"","loc":"type/advection_diffusion_1d.html"},{"title":"advection_diffusion_3d – SELF ","text":"type, public, extends( advection_diffusion_3d_t ) :: advection_diffusion_3d Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nu nvar solution solutionGradient source t timeIntegrator u v w workSol Type-Bound Procedures CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot boundaryflux entropy_func flux1D flux2D flux3d fluxmethod hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d setboundarycondition setgradientboundarycondition source1d source2d source3d Source Code advection_diffusion_3d Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v real(kind=prec), public :: w type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: CalculateEntropy => CalculateEntropy_advection_diffusion_3d public subroutine CalculateEntropy_advection_diffusion_3d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D public subroutine CalculateSolutionGradient_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel3D public subroutine CalculateTendency_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel3D_t public subroutine Free_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel3D_t public subroutine Init_DGModel3D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh3D ), intent(in), target :: mesh type( SEMHex ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel3D_t public subroutine Read_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetMetadata => SetMetadata_DGModel3D_t public subroutine SetMetadata_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t , SetSolutionFromEqn_DGModel3D_t public subroutine SetSolutionFromChar_DGModel3D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel3D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel3D public subroutine sourcemethod_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D public subroutine UpdateGRK2_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D public subroutine UpdateGRK3_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D public subroutine UpdateGRK4_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel3D public subroutine UpdateSolution_DGModel3D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel3D_t public subroutine Write_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t public subroutine WriteTecplot_DGModel3D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: boundaryflux => boundaryflux_advection_diffusion_3d public subroutine boundaryflux_advection_diffusion_3d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this procedure, public :: entropy_func => entropy_func_advection_diffusion_3d_t public pure function entropy_func_advection_diffusion_3d_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3d => flux3d_advection_diffusion_3d_t public pure function flux3d_advection_diffusion_3d_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar,1:3) Return Value real(kind=prec)(1:this%solution%nvar,1:3) procedure, public :: fluxmethod => fluxmethod_advection_diffusion_3d public subroutine fluxmethod_advection_diffusion_3d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_advection_diffusion_3d_t public pure function riemannflux3d_advection_diffusion_3d_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: setboundarycondition => setboundarycondition_advection_diffusion_3d public subroutine setboundarycondition_advection_diffusion_3d (this) Boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this procedure, public :: setgradientboundarycondition => setgradientboundarycondition_advection_diffusion_3d public subroutine setgradientboundarycondition_advection_diffusion_3d (this) Gradient boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( advection_diffusion_3d_t ) :: advection_diffusion_3d contains procedure :: setboundarycondition => setboundarycondition_advection_diffusion_3d procedure :: setgradientboundarycondition => setgradientboundarycondition_advection_diffusion_3d procedure :: boundaryflux => boundaryflux_advection_diffusion_3d procedure :: fluxmethod => fluxmethod_advection_diffusion_3d procedure :: CalculateEntropy => CalculateEntropy_advection_diffusion_3d endtype advection_diffusion_3d","tags":"","loc":"type/advection_diffusion_3d.html"},{"title":"NullDGModel1D – SELF ","text":"type, public, extends( NullDGModel1D_t ) :: NullDGModel1D Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code NullDGModel1D Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D public subroutine BoundaryFlux_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D public subroutine CalculateEntropy_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D public subroutine CalculateSolutionGradient_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel1D public subroutine CalculateTendency_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel1D public subroutine fluxmethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel1D_t public subroutine Free_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel1D_t public subroutine Init_DGModel1D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), target :: mesh type( Geometry1D ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel1D_t public subroutine Read_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D public subroutine setboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D public subroutine setgradientboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel1D_t public subroutine SetMetadata_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t , SetSolutionFromEqn_DGModel1D_t public subroutine SetSolutionFromChar_DGModel1D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel1D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel1D public subroutine sourcemethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D public subroutine UpdateGRK2_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D public subroutine UpdateGRK3_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D public subroutine UpdateGRK4_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel1D public subroutine UpdateSolution_DGModel1D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel1D_t public subroutine Write_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t public subroutine WriteTecplot_DGModel1D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( NullDGModel1D_t ) :: NullDGModel1D endtype NullDGModel1D","tags":"","loc":"type/nulldgmodel1d.html"},{"title":"DGModel1D – SELF ","text":"type, public, extends( DGModel1D_t ) :: DGModel1D Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code DGModel1D Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D public subroutine BoundaryFlux_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D public subroutine CalculateEntropy_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D public subroutine CalculateSolutionGradient_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel1D public subroutine CalculateTendency_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel1D public subroutine fluxmethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel1D_t public subroutine Free_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel1D_t public subroutine Init_DGModel1D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), target :: mesh type( Geometry1D ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel1D_t public subroutine Read_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D public subroutine setboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D public subroutine setgradientboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel1D_t public subroutine SetMetadata_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t , SetSolutionFromEqn_DGModel1D_t public subroutine SetSolutionFromChar_DGModel1D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel1D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel1D public subroutine sourcemethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D public subroutine UpdateGRK2_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D public subroutine UpdateGRK3_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D public subroutine UpdateGRK4_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel1D public subroutine UpdateSolution_DGModel1D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel1D_t public subroutine Write_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t public subroutine WriteTecplot_DGModel1D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( DGModel1D_t ) :: DGModel1D contains procedure :: UpdateSolution => UpdateSolution_DGModel1D procedure :: CalculateEntropy => CalculateEntropy_DGModel1D procedure :: BoundaryFlux => BoundaryFlux_DGModel1D procedure :: FluxMethod => fluxmethod_DGModel1D procedure :: SourceMethod => sourcemethod_DGModel1D procedure :: SetBoundaryCondition => setboundarycondition_DGModel1D procedure :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D procedure :: UpdateGRK2 => UpdateGRK2_DGModel1D procedure :: UpdateGRK3 => UpdateGRK3_DGModel1D procedure :: UpdateGRK4 => UpdateGRK4_DGModel1D procedure :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D procedure :: CalculateTendency => CalculateTendency_DGModel1D endtype DGModel1D","tags":"","loc":"type/dgmodel1d.html"},{"title":"MappedVector3D – SELF ","text":"type, public, extends( MappedVector3D_t ) :: MappedVector3D Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundaryNormal boundaryNormal_gpu boundary_gpu eqn extBoundary extBoundary_gpu geometry geometry_associated interior interior_gpu interp interpWork1 interpWork2 meta nElem nVar Type-Bound Procedures AssociateGeometry AverageSides BoundaryInterp Curl DissociateGeometry Divergence Free Gradient GridInterp Init MPIExchangeAsync MappedDGDivergence MappedDGDivergence_MappedVector3D MappedDivergence MappedDivergence_MappedVector3D SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedVector3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMHex ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedVector3D_t public subroutine AssociateGeometry_MappedVector3D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( SEMHex ), intent(in), target :: geometry procedure, public :: AverageSides => AverageSides_Vector3D public subroutine AverageSides_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D public subroutine BoundaryInterp_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this generic, public :: Curl => Curl_Vector3D_t public subroutine Curl_Vector3D_t (this, curlf) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: curlf (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) procedure, public :: DissociateGeometry => DissociateGeometry_MappedVector3D_t public subroutine DissociateGeometry_MappedVector3D_t (this) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this generic, public :: Divergence => Divergence_Vector3D_t , Divergence_Vector3D public subroutine Divergence_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Divergence_Vector3D (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, public :: Free => Free_Vector3D public subroutine Free_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this generic, public :: Gradient => Gradient_Vector3D_t , Gradient_Vector3D public subroutine Gradient_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3,1:3) public subroutine Gradient_Vector3D (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Vector3D_t , GridInterp_Vector3D public subroutine GridInterp_Vector3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:3) (Output) Array of function values, defined on the target grid public subroutine GridInterp_Vector3D (this, f) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Vector3D public subroutine Init_Vector3D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D public subroutine MPIExchangeAsync_MappedVector3D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh generic, public :: MappedDGDivergence => MappedDGDivergence_MappedVector3D_t , MappedDGDivergence_MappedVector3D public subroutine MappedDGDivergence_MappedVector3D_t (this, df) Computes the divergence of a 3-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine MappedDGDivergence_MappedVector3D (this, df) Computes the divergence of a 3-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, private :: MappedDGDivergence_MappedVector3D public subroutine MappedDGDivergence_MappedVector3D (this, df) Computes the divergence of a 3-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: MappedDivergence => MappedDivergence_MappedVector3D_t , MappedDivergence_MappedVector3D public subroutine MappedDivergence_MappedVector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine MappedDivergence_MappedVector3D (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, private :: MappedDivergence_MappedVector3D public subroutine MappedDivergence_MappedVector3D (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector3D_t public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector3D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector3D public subroutine SetInteriorFromEquation_MappedVector3D (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: this type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedVector3D public subroutine SideExchange_MappedVector3D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh procedure, public :: UpdateDevice => UpdateDevice_Vector3D public subroutine UpdateDevice_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Vector3D public subroutine UpdateHost_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D_t , WriteHDF5_Vector3D_t public subroutine WriteHDF5_MPI_Vector3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( MappedVector3D_t ), public :: MappedVector3D contains procedure , public :: SideExchange => SideExchange_MappedVector3D procedure , public :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D generic , public :: MappedDivergence => MappedDivergence_MappedVector3D procedure , private :: MappedDivergence_MappedVector3D generic , public :: MappedDGDivergence => MappedDGDivergence_MappedVector3D procedure , private :: MappedDGDivergence_MappedVector3D procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector3D endtype MappedVector3D","tags":"","loc":"type/mappedvector3d.html"},{"title":"Mesh3D – SELF ","text":"type, public, extends( Mesh3D_t ) :: Mesh3D Contents Variables BCNames BCType CGNSCornerMap CGNSSideMap decomp elemInfo globalNodeIDs nBCs nCornerNodes nElem nGeo nGlobalElem nNodes nSides nUniqueNodes nUniqueSides nodeCoords quadrature sideInfo sideInfo_gpu sideMap Type-Bound Procedures Free Init Read_HOPr RecalculateFlip ResetBoundaryConditionType Write_Mesh Source Code Mesh3D Components Type Visibility Attributes Name Initial character(len=255), public, allocatable :: BCNames (:) integer, public, pointer, dimension(:,:) :: BCType integer, public, pointer, dimension(:,:) :: CGNSCornerMap integer, public, pointer, dimension(:,:) :: CGNSSideMap type( DomainDecomposition ), public :: decomp integer, public, pointer, dimension(:,:) :: elemInfo integer, public, pointer, dimension(:,:,:,:) :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides real(kind=prec), public, pointer, dimension(:,:,:,:,:) :: nodeCoords integer, public :: quadrature integer, public, pointer, dimension(:,:,:) :: sideInfo type(c_ptr), public :: sideInfo_gpu integer, public, pointer, dimension(:,:) :: sideMap Type-Bound Procedures procedure, public :: Free => Free_Mesh3D public subroutine Free_Mesh3D (this) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: this procedure, public :: Init => Init_Mesh3D public subroutine Init_Mesh3D (this, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: this integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs procedure, public :: Read_HOPr => Read_HOPr_Mesh3D public subroutine Read_HOPr_Mesh3D (this, meshFile, enableDomainDecomposition) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: this character, intent(in) :: meshFile logical, intent(in), optional :: enableDomainDecomposition procedure, public :: RecalculateFlip => RecalculateFlip_Mesh3D_t public subroutine RecalculateFlip_Mesh3D_t (this) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh3D_t public subroutine ResetBoundaryConditionType_Mesh3D_t (this, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Read more… Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this integer, intent(in) :: bcid procedure, public :: Write_Mesh => Write_Mesh3D_t public subroutine Write_Mesh3D_t (this, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this character, intent(in) :: meshFile Source Code type , extends ( Mesh3D_t ) :: Mesh3D type ( c_ptr ) :: sideInfo_gpu contains procedure , public :: Init => Init_Mesh3D procedure , public :: Free => Free_Mesh3D procedure , public :: Read_HOPr => Read_HOPr_Mesh3D endtype Mesh3D","tags":"","loc":"type/mesh3d.html"},{"title":"MappedScalar1D – SELF ","text":"type, public, extends( MappedScalar1D_t ) :: MappedScalar1D Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundary_gpu boundarynormal boundarynormal_gpu eqn extBoundary extBoundary_gpu geometry geometry_associated interior interior_gpu interp meta nElem nVar Type-Bound Procedures AssociateGeometry AverageSides BoundaryInterp Derivative DissociateGeometry Free GridInterp Init MappedDGDerivative MappedDGDerivative_MappedScalar1D MappedDerivative MappedDerivative_MappedScalar1D SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedScalar1D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( Geometry1D ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar1D_t public subroutine AssociateGeometry_MappedScalar1D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this type( Geometry1D ), intent(in), target :: geometry procedure, public :: AverageSides => AverageSides_Scalar1D public subroutine AverageSides_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D public subroutine BoundaryInterp_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this generic, public :: Derivative => Derivative_Scalar1D_t , Derivative_Scalar1D public subroutine Derivative_Scalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Derivative_Scalar1D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar1D_t public subroutine DissociateGeometry_MappedScalar1D_t (this) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this procedure, public :: Free => Free_Scalar1D public subroutine Free_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this generic, public :: GridInterp => GridInterp_Scalar1D_t , GridInterp_Scalar1D public subroutine GridInterp_Scalar1D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%nelem,1:this%nvar) public subroutine GridInterp_Scalar1D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Scalar1D public subroutine Init_Scalar1D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: MappedDGDerivative => MappedDGDerivative_MappedScalar1D_t , MappedDGDerivative_MappedScalar1D public subroutine MappedDGDerivative_MappedScalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%nelem,1:this%nvar) public subroutine MappedDGDerivative_MappedScalar1D (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, private :: MappedDGDerivative_MappedScalar1D public subroutine MappedDGDerivative_MappedScalar1D (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: MappedDerivative => MappedDerivative_MappedScalar1D_t , MappedDerivative_MappedScalar1D public subroutine MappedDerivative_MappedScalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%nelem,1:this%nvar) public subroutine MappedDerivative_MappedScalar1D (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, private :: MappedDerivative_MappedScalar1D public subroutine MappedDerivative_MappedScalar1D (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar1D public subroutine SetInteriorFromEquation_MappedScalar1D (this, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: this real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedScalar1D public subroutine SideExchange_MappedScalar1D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: this type( Mesh1D ), intent(inout) :: mesh procedure, public :: UpdateDevice => UpdateDevice_Scalar1D public subroutine UpdateDevice_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar1D public subroutine UpdateHost_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_Scalar1D_t public subroutine WriteHDF5_Scalar1D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( MappedScalar1D_t ), public :: MappedScalar1D contains procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar1D procedure , public :: SideExchange => SideExchange_MappedScalar1D generic , public :: MappedDerivative => MappedDerivative_MappedScalar1D procedure , private :: MappedDerivative_MappedScalar1D generic , public :: MappedDGDerivative => MappedDGDerivative_MappedScalar1D procedure , private :: MappedDGDerivative_MappedScalar1D endtype MappedScalar1D","tags":"","loc":"type/mappedscalar1d.html"},{"title":"Tensor3D – SELF ","text":"type, public, extends( Tensor3D_t ) :: Tensor3D Contents Variables M N backend blas_handle boundary boundary_gpu eqn extBoundary extBoundary_gpu interior interior_gpu interp meta nElem nVar Type-Bound Procedures BoundaryInterp Determinant Free Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost Source Code Tensor3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor3D_t public subroutine BoundaryInterp_Tensor3D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this generic, public :: Determinant => Determinant_Tensor3D_t public subroutine Determinant_Tensor3D_t (this, det) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(in) :: this real(kind=prec), intent(out) :: det (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: Free => Free_Tensor3D public subroutine Free_Tensor3D (this) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: this procedure, public :: Init => Init_Tensor3D public subroutine Init_Tensor3D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Tensor3D public subroutine UpdateDevice_Tensor3D (this) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Tensor3D public subroutine UpdateHost_Tensor3D (this) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: this Source Code type , extends ( Tensor3D_t ), public :: Tensor3D character ( 3 ) :: backend = \"gpu\" type ( c_ptr ) :: blas_handle type ( c_ptr ) :: interior_gpu type ( c_ptr ) :: boundary_gpu type ( c_ptr ) :: extBoundary_gpu contains procedure , public :: Init => Init_Tensor3D procedure , public :: Free => Free_Tensor3D procedure , public :: UpdateHost => UpdateHost_Tensor3D procedure , public :: UpdateDevice => UpdateDevice_Tensor3D endtype Tensor3D","tags":"","loc":"type/tensor3d.html"},{"title":"NullDGModel2D – SELF ","text":"type, public, extends( NullDGModel2D_t ) :: NullDGModel2D Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code NullDGModel2D Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D public subroutine BoundaryFlux_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D public subroutine CalculateEntropy_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D public subroutine CalculateSolutionGradient_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel2D public subroutine CalculateTendency_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel2D public subroutine fluxmethod_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel2D_t public subroutine Free_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel2D_t public subroutine Init_DGModel2D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), target :: mesh type( SEMQuad ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel2D_t public subroutine Read_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D public subroutine setboundarycondition_DGModel2D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D public subroutine setgradientboundarycondition_DGModel2D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel2D_t public subroutine SetMetadata_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t , SetSolutionFromEqn_DGModel2D_t public subroutine SetSolutionFromChar_DGModel2D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel2D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel2D public subroutine sourcemethod_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D public subroutine UpdateGRK2_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D public subroutine UpdateGRK3_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D public subroutine UpdateGRK4_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel2D public subroutine UpdateSolution_DGModel2D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel2D_t public subroutine Write_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t public subroutine WriteTecplot_DGModel2D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( NullDGModel2D_t ) :: NullDGModel2D endtype NullDGModel2D","tags":"","loc":"type/nulldgmodel2d.html"},{"title":"Scalar3D – SELF ","text":"type, public, extends( Scalar3D_t ) :: Scalar3D Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundary_gpu boundarynormal boundarynormal_gpu eqn extBoundary extBoundary_gpu interior interior_gpu interp interpWork1 interpWork2 meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Free Gradient Gradient_Scalar3D GridInterp GridInterp_Scalar3D Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 Source Code Scalar3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar3D public subroutine AverageSides_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D public subroutine BoundaryInterp_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this procedure, public :: Free => Free_Scalar3D public subroutine Free_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this generic, public :: Gradient => Gradient_Scalar3D_t , Gradient_Scalar3D public subroutine Gradient_Scalar3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) public subroutine Gradient_Scalar3D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, private :: Gradient_Scalar3D public subroutine Gradient_Scalar3D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Scalar3D_t , GridInterp_Scalar3D public subroutine GridInterp_Scalar3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) (Output) Array of function values, defined on the target grid public subroutine GridInterp_Scalar3D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, private :: GridInterp_Scalar3D public subroutine GridInterp_Scalar3D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Scalar3D public subroutine Init_Scalar3D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Scalar3D public subroutine UpdateDevice_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar3D public subroutine UpdateHost_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D_t , WriteHDF5_Scalar3D_t public subroutine WriteHDF5_MPI_Scalar3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Scalar3D_t ), public :: Scalar3D character ( 3 ) :: backend = \"gpu\" type ( c_ptr ) :: blas_handle type ( c_ptr ) :: interior_gpu type ( c_ptr ) :: boundary_gpu type ( c_ptr ) :: boundarynormal_gpu type ( c_ptr ) :: extBoundary_gpu type ( c_ptr ) :: avgBoundary_gpu type ( c_ptr ) :: interpWork1 type ( c_ptr ) :: interpWork2 contains procedure , public :: Init => Init_Scalar3D procedure , public :: Free => Free_Scalar3D procedure , public :: UpdateHost => UpdateHost_Scalar3D procedure , public :: UpdateDevice => UpdateDevice_Scalar3D procedure , public :: BoundaryInterp => BoundaryInterp_Scalar3D procedure , public :: AverageSides => AverageSides_Scalar3D generic , public :: GridInterp => GridInterp_Scalar3D procedure , private :: GridInterp_Scalar3D generic , public :: Gradient => Gradient_Scalar3D procedure , private :: Gradient_Scalar3D endtype Scalar3D","tags":"","loc":"type/scalar3d.html"},{"title":"Scalar2D – SELF ","text":"type, public, extends( Scalar2D_t ) :: Scalar2D Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundary_gpu boundarynormal boundarynormal_gpu eqn extBoundary extBoundary_gpu interior interior_gpu interp interpWork meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Free Gradient Gradient_Scalar2D GridInterp GridInterp_Scalar2D Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 Source Code Scalar2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar2D public subroutine AverageSides_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D public subroutine BoundaryInterp_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this procedure, public :: Free => Free_Scalar2D public subroutine Free_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this generic, public :: Gradient => Gradient_Scalar2D_t , Gradient_Scalar2D public subroutine Gradient_Scalar2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) public subroutine Gradient_Scalar2D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, private :: Gradient_Scalar2D public subroutine Gradient_Scalar2D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Scalar2D_t , GridInterp_Scalar2D public subroutine GridInterp_Scalar2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) public subroutine GridInterp_Scalar2D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, private :: GridInterp_Scalar2D public subroutine GridInterp_Scalar2D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Scalar2D public subroutine Init_Scalar2D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Scalar2D public subroutine UpdateDevice_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar2D public subroutine UpdateHost_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D_t , WriteHDF5_Scalar2D_t public subroutine WriteHDF5_MPI_Scalar2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Scalar2D_t ), public :: Scalar2D character ( 3 ) :: backend = \"gpu\" type ( c_ptr ) :: blas_handle type ( c_ptr ) :: interior_gpu type ( c_ptr ) :: boundary_gpu type ( c_ptr ) :: boundarynormal_gpu type ( c_ptr ) :: extBoundary_gpu type ( c_ptr ) :: avgBoundary_gpu type ( c_ptr ) :: interpWork contains procedure , public :: Init => Init_Scalar2D procedure , public :: Free => Free_Scalar2D procedure , public :: UpdateHost => UpdateHost_Scalar2D procedure , public :: UpdateDevice => UpdateDevice_Scalar2D procedure , public :: BoundaryInterp => BoundaryInterp_Scalar2D procedure , public :: AverageSides => AverageSides_Scalar2D generic , public :: GridInterp => GridInterp_Scalar2D procedure , private :: GridInterp_Scalar2D generic , public :: Gradient => Gradient_Scalar2D procedure , private :: Gradient_Scalar2D endtype Scalar2D","tags":"","loc":"type/scalar2d.html"},{"title":"Vector2D – SELF ","text":"type, public, extends( Vector2D_t ) :: Vector2D Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundaryNormal boundaryNormal_gpu boundary_gpu eqn extBoundary extBoundary_gpu interior interior_gpu interp interpWork meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Divergence Divergence_Vector2D Free Gradient Gradient_Vector2D GridInterp GridInterp_Vector2D Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 Source Code Vector2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Vector2D public subroutine AverageSides_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D public subroutine BoundaryInterp_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this generic, public :: Divergence => Divergence_Vector2D_t , Divergence_Vector2D public subroutine Divergence_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Divergence_Vector2D (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, private :: Divergence_Vector2D public subroutine Divergence_Vector2D (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, public :: Free => Free_Vector2D public subroutine Free_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this generic, public :: Gradient => Gradient_Vector2D_t , Gradient_Vector2D public subroutine Gradient_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2,1:2) public subroutine Gradient_Vector2D (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, private :: Gradient_Vector2D public subroutine Gradient_Vector2D (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Vector2D_t , GridInterp_Vector2D public subroutine GridInterp_Vector2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:2) public subroutine GridInterp_Vector2D (this, f) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, private :: GridInterp_Vector2D public subroutine GridInterp_Vector2D (this, f) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Vector2D public subroutine Init_Vector2D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector2D_t public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector2D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Vector2D public subroutine UpdateDevice_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Vector2D public subroutine UpdateHost_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D_t , WriteHDF5_Vector2D_t public subroutine WriteHDF5_MPI_Vector2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Vector2D_t ), public :: Vector2D character ( 3 ) :: backend = \"gpu\" type ( c_ptr ) :: blas_handle type ( c_ptr ) :: interior_gpu type ( c_ptr ) :: boundary_gpu type ( c_ptr ) :: extBoundary_gpu type ( c_ptr ) :: avgBoundary_gpu type ( c_ptr ) :: boundaryNormal_gpu type ( c_ptr ) :: interpWork contains procedure , public :: Init => Init_Vector2D procedure , public :: Free => Free_Vector2D procedure , public :: UpdateHost => UpdateHost_Vector2D procedure , public :: UpdateDevice => UpdateDevice_Vector2D procedure , public :: BoundaryInterp => BoundaryInterp_Vector2D procedure , public :: AverageSides => AverageSides_Vector2D generic , public :: GridInterp => GridInterp_Vector2D procedure , private :: GridInterp_Vector2D generic , public :: Gradient => Gradient_Vector2D procedure , private :: Gradient_Vector2D generic , public :: Divergence => Divergence_Vector2D procedure , private :: Divergence_Vector2D endtype Vector2D","tags":"","loc":"type/vector2d.html"},{"title":"MappedScalar2D – SELF ","text":"type, public, extends( MappedScalar2D_t ) :: MappedScalar2D Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundary_gpu boundarynormal boundarynormal_gpu eqn extBoundary extBoundary_gpu geometry geometry_associated interior interior_gpu interp interpWork jas_gpu meta nElem nVar Type-Bound Procedures AssociateGeometry AverageSides BoundaryInterp DissociateGeometry Free Gradient GridInterp Init MPIExchangeAsync MappedDGGradient MappedDGGradient_MappedScalar2D MappedGradient MappedGradient_MappedScalar2D SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedScalar2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMQuad ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type(c_ptr), public :: jas_gpu type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar2D_t public subroutine AssociateGeometry_MappedScalar2D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( SEMQuad ), intent(in), target :: geometry procedure, public :: AverageSides => AverageSides_Scalar2D public subroutine AverageSides_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D public subroutine BoundaryInterp_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar2D_t public subroutine DissociateGeometry_MappedScalar2D_t (this) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this procedure, public :: Free => Free_MappedScalar2D public subroutine Free_MappedScalar2D (this) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this generic, public :: Gradient => Gradient_Scalar2D_t , Gradient_Scalar2D public subroutine Gradient_Scalar2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) public subroutine Gradient_Scalar2D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Scalar2D_t , GridInterp_Scalar2D public subroutine GridInterp_Scalar2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) public subroutine GridInterp_Scalar2D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_MappedScalar2D public subroutine Init_MappedScalar2D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D public subroutine MPIExchangeAsync_MappedScalar2D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh generic, public :: MappedDGGradient => MappedDGGradient_MappedScalar2D_t , MappedDGGradient_MappedScalar2D public subroutine MappedDGGradient_MappedScalar2D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) public subroutine MappedDGGradient_MappedScalar2D (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type(c_ptr), intent(inout) :: df procedure, private :: MappedDGGradient_MappedScalar2D public subroutine MappedDGGradient_MappedScalar2D (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type(c_ptr), intent(inout) :: df generic, public :: MappedGradient => MappedGradient_MappedScalar2D_t , MappedGradient_MappedScalar2D public subroutine MappedGradient_MappedScalar2D_t (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) public subroutine MappedGradient_MappedScalar2D (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type(c_ptr), intent(out) :: df procedure, private :: MappedGradient_MappedScalar2D public subroutine MappedGradient_MappedScalar2D (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type(c_ptr), intent(out) :: df procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar2D public subroutine SetInteriorFromEquation_MappedScalar2D (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedScalar2D public subroutine SideExchange_MappedScalar2D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh procedure, public :: UpdateDevice => UpdateDevice_Scalar2D public subroutine UpdateDevice_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar2D public subroutine UpdateHost_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D_t , WriteHDF5_Scalar2D_t public subroutine WriteHDF5_MPI_Scalar2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( MappedScalar2D_t ), public :: MappedScalar2D type ( c_ptr ) :: jas_gpu ! jacobian weighted scalar for gradient calculation contains procedure , public :: Init => Init_MappedScalar2D procedure , public :: Free => Free_MappedScalar2D procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar2D procedure , public :: SideExchange => SideExchange_MappedScalar2D procedure , private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D generic , public :: MappedGradient => MappedGradient_MappedScalar2D procedure , private :: MappedGradient_MappedScalar2D generic , public :: MappedDGGradient => MappedDGGradient_MappedScalar2D procedure , private :: MappedDGGradient_MappedScalar2D endtype MappedScalar2D","tags":"","loc":"type/mappedscalar2d.html"},{"title":"DGModel3D – SELF ","text":"type, public, extends( DGModel3D_t ) :: DGModel3D Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code DGModel3D Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D public subroutine BoundaryFlux_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D public subroutine CalculateEntropy_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D public subroutine CalculateSolutionGradient_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel3D public subroutine CalculateTendency_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel3D public subroutine fluxmethod_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel3D_t public subroutine Free_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel3D_t public subroutine Init_DGModel3D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh3D ), intent(in), target :: mesh type( SEMHex ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel3D_t public subroutine Read_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D public subroutine setboundarycondition_DGModel3D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D public subroutine setgradientboundarycondition_DGModel3D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel3D_t public subroutine SetMetadata_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t , SetSolutionFromEqn_DGModel3D_t public subroutine SetSolutionFromChar_DGModel3D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel3D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel3D public subroutine sourcemethod_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D public subroutine UpdateGRK2_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D public subroutine UpdateGRK3_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D public subroutine UpdateGRK4_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel3D public subroutine UpdateSolution_DGModel3D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel3D_t public subroutine Write_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t public subroutine WriteTecplot_DGModel3D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( DGModel3D_t ) :: DGModel3D contains procedure :: UpdateSolution => UpdateSolution_DGModel3D procedure :: CalculateEntropy => CalculateEntropy_DGModel3D procedure :: BoundaryFlux => BoundaryFlux_DGModel3D procedure :: FluxMethod => fluxmethod_DGModel3D procedure :: SourceMethod => sourcemethod_DGModel3D procedure :: SetBoundaryCondition => setboundarycondition_DGModel3D procedure :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D procedure :: UpdateGRK2 => UpdateGRK2_DGModel3D procedure :: UpdateGRK3 => UpdateGRK3_DGModel3D procedure :: UpdateGRK4 => UpdateGRK4_DGModel3D procedure :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D procedure :: CalculateTendency => CalculateTendency_DGModel3D endtype DGModel3D","tags":"","loc":"type/dgmodel3d.html"},{"title":"MappedVector2D – SELF ","text":"type, public, extends( MappedVector2D_t ) :: MappedVector2D Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundaryNormal boundaryNormal_gpu boundary_gpu eqn extBoundary extBoundary_gpu geometry geometry_associated interior interior_gpu interp interpWork meta nElem nVar Type-Bound Procedures AssociateGeometry AverageSides BoundaryInterp DissociateGeometry Divergence Free Gradient GridInterp Init MPIExchangeAsync MappedDGDivergence MappedDGDivergence_MappedVector2D MappedDivergence MappedDivergence_MappedVector2D SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedVector2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMQuad ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedVector2D_t public subroutine AssociateGeometry_MappedVector2D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( SEMQuad ), intent(in), target :: geometry procedure, public :: AverageSides => AverageSides_Vector2D public subroutine AverageSides_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D public subroutine BoundaryInterp_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this procedure, public :: DissociateGeometry => DissociateGeometry_MappedVector2D_t public subroutine DissociateGeometry_MappedVector2D_t (this) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this generic, public :: Divergence => Divergence_Vector2D_t , Divergence_Vector2D public subroutine Divergence_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Divergence_Vector2D (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, public :: Free => Free_Vector2D public subroutine Free_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this generic, public :: Gradient => Gradient_Vector2D_t , Gradient_Vector2D public subroutine Gradient_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2,1:2) public subroutine Gradient_Vector2D (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Vector2D_t , GridInterp_Vector2D public subroutine GridInterp_Vector2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:2) public subroutine GridInterp_Vector2D (this, f) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Vector2D public subroutine Init_Vector2D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D public subroutine MPIExchangeAsync_MappedVector2D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh generic, public :: MappedDGDivergence => MappedDGDivergence_MappedVector2D_t , MappedDGDivergence_MappedVector2D public subroutine MappedDGDivergence_MappedVector2D_t (this, df) Computes the divergence of a 2-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(in) :: this real(kind=prec) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine MappedDGDivergence_MappedVector2D (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type(c_ptr), intent(out) :: df procedure, private :: MappedDGDivergence_MappedVector2D public subroutine MappedDGDivergence_MappedVector2D (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type(c_ptr), intent(out) :: df generic, public :: MappedDivergence => MappedDivergence_MappedVector2D_t , MappedDivergence_MappedVector2D public subroutine MappedDivergence_MappedVector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine MappedDivergence_MappedVector2D (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type(c_ptr), intent(out) :: df procedure, private :: MappedDivergence_MappedVector2D public subroutine MappedDivergence_MappedVector2D (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type(c_ptr), intent(out) :: df procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector2D_t public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector2D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector2D public subroutine SetInteriorFromEquation_MappedVector2D (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedVector2D public subroutine SideExchange_MappedVector2D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh procedure, public :: UpdateDevice => UpdateDevice_Vector2D public subroutine UpdateDevice_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Vector2D public subroutine UpdateHost_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D_t , WriteHDF5_Vector2D_t public subroutine WriteHDF5_MPI_Vector2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( MappedVector2D_t ), public :: MappedVector2D contains procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector2D procedure , public :: SideExchange => SideExchange_MappedVector2D procedure , private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D generic , public :: MappedDivergence => MappedDivergence_MappedVector2D procedure , private :: MappedDivergence_MappedVector2D generic , public :: MappedDGDivergence => MappedDGDivergence_MappedVector2D procedure , private :: MappedDGDivergence_MappedVector2D endtype MappedVector2D","tags":"","loc":"type/mappedvector2d.html"},{"title":"Tensor2D – SELF ","text":"type, public, extends( Tensor2D_t ) :: Tensor2D Contents Variables M N backend blas_handle boundary boundary_gpu eqn extBoundary extBoundary_gpu interior interior_gpu interp meta nElem nVar Type-Bound Procedures BoundaryInterp Determinant Free Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost Source Code Tensor2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor2D_t public subroutine BoundaryInterp_Tensor2D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this generic, public :: Determinant => Determinant_Tensor2D_t public subroutine Determinant_Tensor2D_t (this, det) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(in) :: this real(kind=prec), intent(out) :: det (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: Free => Free_Tensor2D public subroutine Free_Tensor2D (this) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: this procedure, public :: Init => Init_Tensor2D public subroutine Init_Tensor2D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Tensor2D public subroutine UpdateDevice_Tensor2D (this) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Tensor2D public subroutine UpdateHost_Tensor2D (this) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: this Source Code type , extends ( Tensor2D_t ), public :: Tensor2D character ( 3 ) :: backend = \"gpu\" type ( c_ptr ) :: blas_handle type ( c_ptr ) :: interior_gpu type ( c_ptr ) :: boundary_gpu type ( c_ptr ) :: extBoundary_gpu contains procedure , public :: Init => Init_Tensor2D procedure , public :: Free => Free_Tensor2D procedure , public :: UpdateHost => UpdateHost_Tensor2D procedure , public :: UpdateDevice => UpdateDevice_Tensor2D endtype Tensor2D","tags":"","loc":"type/tensor2d.html"},{"title":"Lagrange – SELF ","text":"type, public, extends( Lagrange_t ) :: Lagrange Contents Variables M N bMatrix bMatrix_gpu bWeights backend blas_handle controlNodeType controlPoints dMatrix dMatrix_gpu dgMatrix dgMatrix_gpu iMatrix iMatrix_gpu qWeights qWeights_gpu targetNodeType targetPoints Type-Bound Procedures CalculateBarycentricWeights CalculateDerivativeMatrix CalculateInterpolationMatrix CalculateLagrangePolynomials Free Init WriteHDF5 Source Code Lagrange Components Type Visibility Attributes Name Initial integer, public :: M The number of target points. integer, public :: N The number of control points. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: bMatrix The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. type(c_ptr), public :: bMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:) :: bWeights The barycentric weights that are calculated from the controlPoints and used for interpolation. character(len=3), public :: backend = 'gpu' type(c_ptr), public :: blas_handle = c_null_ptr A handle for working with hipblas integer, public :: controlNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: controlPoints The set of nodes in one dimension where data is known.\nTo create higher dimension interpolation and differentiation operators, structured grids in two and three\ndimensions are created by tensor products of the controlPoints. This design decision implies that all\nspectral element methods supported by the Lagrange class have the same polynomial degree in each\ncomputational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto,\nLegendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over\nthe domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of\nthese quadrature types or uniform points on [-1,1]. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The\ndMatrix is based on a strong form of the derivative. type(c_ptr), public :: dMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dgMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based\non a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. type(c_ptr), public :: dgMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:) :: iMatrix The interpolation matrix (transpose) for mapping data from the control grid to the target grid. type(c_ptr), public :: iMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:) :: qWeights The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints\nprovided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss,\nChebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant . type(c_ptr), public :: qWeights_gpu integer, public :: targetNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: targetPoints The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation\nand differentiation operators, structured grids in two and three dimensions are created by tensor products of\nthe targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1]\n(computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. Type-Bound Procedures procedure, public :: CalculateBarycentricWeights public subroutine CalculateBarycentricWeights (this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this procedure, public :: CalculateDerivativeMatrix public subroutine CalculateDerivativeMatrix (this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this procedure, public :: CalculateInterpolationMatrix public subroutine CalculateInterpolationMatrix (this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this procedure, public :: CalculateLagrangePolynomials public function CalculateLagrangePolynomials (this, sE) result(lAtS) Arguments Type Intent Optional Attributes Name class( Lagrange_t ) :: this real(kind=prec) :: sE Return Value real(kind=prec)(0:this%N) procedure, public :: Free => Free_Lagrange public subroutine Free_Lagrange (this) Frees all memory (host and device) associated with an instance of the Lagrange class Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: this Lagrange class instance procedure, public :: Init => Init_Lagrange public subroutine Init_Lagrange (this, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange class\nOn output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(out) :: this Lagrange class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) procedure, public :: WriteHDF5 => WriteHDF5_Lagrange_t public subroutine WriteHDF5_Lagrange_t (this, fileId) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId Source Code type , extends ( Lagrange_t ), public :: Lagrange character ( 3 ) :: backend = 'gpu' type ( c_ptr ) :: qWeights_gpu type ( c_ptr ) :: iMatrix_gpu type ( c_ptr ) :: dMatrix_gpu type ( c_ptr ) :: dgMatrix_gpu type ( c_ptr ) :: bMatrix_gpu contains procedure , public :: Init => Init_Lagrange procedure , public :: Free => Free_Lagrange endtype Lagrange","tags":"","loc":"type/lagrange~2.html"},{"title":"Scalar1D – SELF ","text":"type, public, extends( Scalar1D_t ) :: Scalar1D Contents Variables M N avgBoundary backend blas_handle boundary boundarynormal eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Derivative Free GridInterp Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 Source Code Scalar1D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: avgBoundary character(len=3), public :: backend = \"apu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundarynormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar1D_t public subroutine AverageSides_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D public subroutine BoundaryInterp_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this generic, public :: Derivative => Derivative_Scalar1D_t public subroutine Derivative_Scalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: Free => Free_Scalar1D public subroutine Free_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this generic, public :: GridInterp => GridInterp_Scalar1D_t public subroutine GridInterp_Scalar1D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%nelem,1:this%nvar) procedure, public :: Init => Init_Scalar1D public subroutine Init_Scalar1D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Scalar1D_t public subroutine UpdateDevice_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar1D_t public subroutine UpdateHost_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_Scalar1D_t public subroutine WriteHDF5_Scalar1D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Scalar1D_t ), public :: Scalar1D character ( 3 ) :: backend = \"apu\" type ( c_ptr ) :: blas_handle contains procedure , public :: Init => Init_Scalar1D procedure , public :: Free => Free_Scalar1D procedure , public :: BoundaryInterp => BoundaryInterp_Scalar1D !procedure,public :: GridInterp => GridInterp_Scalar1D !procedure,public :: Derivative => Derivative_Scalar1D endtype Scalar1D","tags":"","loc":"type/scalar1d~2.html"},{"title":"NullDGModel3D – SELF ","text":"type, public, extends( NullDGModel3D_t ) :: NullDGModel3D Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code NullDGModel3D Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D public subroutine BoundaryFlux_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D public subroutine CalculateEntropy_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D public subroutine CalculateSolutionGradient_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel3D public subroutine CalculateTendency_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel3D public subroutine fluxmethod_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel3D_t public subroutine Free_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel3D_t public subroutine Init_DGModel3D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh3D ), intent(in), target :: mesh type( SEMHex ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel3D_t public subroutine Read_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D public subroutine setboundarycondition_DGModel3D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D public subroutine setgradientboundarycondition_DGModel3D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel3D_t public subroutine SetMetadata_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t , SetSolutionFromEqn_DGModel3D_t public subroutine SetSolutionFromChar_DGModel3D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel3D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel3D public subroutine sourcemethod_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D public subroutine UpdateGRK2_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D public subroutine UpdateGRK3_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D public subroutine UpdateGRK4_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel3D public subroutine UpdateSolution_DGModel3D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel3D_t public subroutine Write_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t public subroutine WriteTecplot_DGModel3D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( NullDGModel3D_t ) :: NullDGModel3D endtype NullDGModel3D","tags":"","loc":"type/nulldgmodel3d~2.html"},{"title":"MappedScalar3D – SELF ","text":"type, public, extends( MappedScalar3D_t ) :: MappedScalar3D Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundary_gpu boundarynormal boundarynormal_gpu eqn extBoundary extBoundary_gpu geometry geometry_associated interior interior_gpu interp interpWork1 interpWork2 meta nElem nVar Type-Bound Procedures AssociateGeometry AverageSides BoundaryInterp DissociateGeometry Free Gradient GridInterp Init MappedDGGradient MappedGradient SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedScalar3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMHex ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar3D_t public subroutine AssociateGeometry_MappedScalar3D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( SEMHex ), intent(in), target :: geometry procedure, public :: AverageSides => AverageSides_Scalar3D public subroutine AverageSides_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D public subroutine BoundaryInterp_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar3D_t public subroutine DissociateGeometry_MappedScalar3D_t (this) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this procedure, public :: Free => Free_Scalar3D public subroutine Free_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this generic, public :: Gradient => Gradient_Scalar3D_t , Gradient_Scalar3D public subroutine Gradient_Scalar3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) public subroutine Gradient_Scalar3D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Scalar3D_t , GridInterp_Scalar3D public subroutine GridInterp_Scalar3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) (Output) Array of function values, defined on the target grid public subroutine GridInterp_Scalar3D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Scalar3D public subroutine Init_Scalar3D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: MappedDGGradient => MappedDGGradient_MappedScalar3D_t public subroutine MappedDGGradient_MappedScalar3D_t (this, df) Calculates the gradient of a function using the weak form of the gradient\nand the average boundary state.\nThis method will compute the average boundary state from the\nand  attributes of Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) generic, public :: MappedGradient => MappedGradient_MappedScalar3D_t public subroutine MappedGradient_MappedScalar3D_t (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar3D_t public subroutine SetInteriorFromEquation_MappedScalar3D_t (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedScalar3D_t public subroutine SideExchange_MappedScalar3D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh procedure, public :: UpdateDevice => UpdateDevice_Scalar3D public subroutine UpdateDevice_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar3D public subroutine UpdateHost_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D_t , WriteHDF5_Scalar3D_t public subroutine WriteHDF5_MPI_Scalar3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( MappedScalar3D_t ), public :: MappedScalar3D endtype MappedScalar3D","tags":"","loc":"type/mappedscalar3d~2.html"},{"title":"Vector3D – SELF ","text":"type, public, extends( Vector3D_t ) :: Vector3D Contents Variables M N avgBoundary backend boundary boundaryNormal eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Curl Divergence Free Gradient GridInterp Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 Source Code Vector3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: avgBoundary character(len=3), public :: backend = \"cpu\" real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundaryNormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Vector3D_t public subroutine AverageSides_Vector3D_t (this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D_t public subroutine BoundaryInterp_Vector3D_t (this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this generic, public :: Curl => Curl_Vector3D_t public subroutine Curl_Vector3D_t (this, curlf) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: curlf (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) generic, public :: Divergence => Divergence_Vector3D_t public subroutine Divergence_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: Free => Free_Vector3D_t public subroutine Free_Vector3D_t (this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this generic, public :: Gradient => Gradient_Vector3D_t public subroutine Gradient_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3,1:3) generic, public :: GridInterp => GridInterp_Vector3D_t public subroutine GridInterp_Vector3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:3) (Output) Array of function values, defined on the target grid procedure, public :: Init => Init_Vector3D_t public subroutine Init_Vector3D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector3D_t public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector3D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Vector3D_t public subroutine UpdateDevice_Vector3D_t (this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Vector3D_t public subroutine UpdateHost_Vector3D_t (this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D_t , WriteHDF5_Vector3D_t public subroutine WriteHDF5_MPI_Vector3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Vector3D_t ), public :: Vector3D character ( 3 ) :: backend = \"cpu\" endtype Vector3D","tags":"","loc":"type/vector3d~2.html"},{"title":"Burgers1D – SELF ","text":"type, public, extends( Burgers1D_t ) :: Burgers1D Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nu nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1d flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code Burgers1D Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh real(kind=prec), public :: nu = 0.0_prec integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D public subroutine BoundaryFlux_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D public subroutine CalculateEntropy_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D public subroutine CalculateSolutionGradient_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel1D public subroutine CalculateTendency_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel1D public subroutine fluxmethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel1D_t public subroutine Free_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel1D_t public subroutine Init_DGModel1D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), target :: mesh type( Geometry1D ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel1D_t public subroutine Read_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D public subroutine setboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D public subroutine setgradientboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_Burgers1D_t public subroutine SetMetadata_Burgers1D_t (this) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t , SetSolutionFromEqn_DGModel1D_t public subroutine SetSolutionFromChar_DGModel1D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel1D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel1D public subroutine sourcemethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D public subroutine UpdateGRK2_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D public subroutine UpdateGRK3_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D public subroutine UpdateGRK4_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel1D public subroutine UpdateSolution_DGModel1D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel1D_t public subroutine Write_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t public subroutine WriteTecplot_DGModel1D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Burgers1D_t public pure function entropy_func_Burgers1D_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) procedure, public :: flux1d => flux1d_Burgers1D_t public pure function flux1d_Burgers1D_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) Return Value real(kind=prec)(1:this%solution%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Burgers1D_t public pure function riemannflux1d_Burgers1D_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%solution%nvar) real(kind=prec), intent(in) :: sR (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%solution%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( Burgers1D_t ) :: Burgers1D endtype Burgers1D","tags":"","loc":"type/burgers1d~2.html"},{"title":"Lagrange – SELF ","text":"type, public, extends( Lagrange_t ) :: Lagrange Contents Variables M N bMatrix bWeights backend blas_handle controlNodeType controlPoints dMatrix dgMatrix iMatrix qWeights targetNodeType targetPoints Type-Bound Procedures CalculateBarycentricWeights CalculateDerivativeMatrix CalculateInterpolationMatrix CalculateLagrangePolynomials Free Init WriteHDF5 Source Code Lagrange Components Type Visibility Attributes Name Initial integer, public :: M The number of target points. integer, public :: N The number of control points. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: bMatrix The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. real(kind=prec), public, pointer, contiguous, dimension(:) :: bWeights The barycentric weights that are calculated from the controlPoints and used for interpolation. character(len=3), public :: backend = 'cpu' type(c_ptr), public :: blas_handle = c_null_ptr A handle for working with hipblas integer, public :: controlNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: controlPoints The set of nodes in one dimension where data is known.\nTo create higher dimension interpolation and differentiation operators, structured grids in two and three\ndimensions are created by tensor products of the controlPoints. This design decision implies that all\nspectral element methods supported by the Lagrange class have the same polynomial degree in each\ncomputational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto,\nLegendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over\nthe domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of\nthese quadrature types or uniform points on [-1,1]. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The\ndMatrix is based on a strong form of the derivative. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dgMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based\non a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: iMatrix The interpolation matrix (transpose) for mapping data from the control grid to the target grid. real(kind=prec), public, pointer, contiguous, dimension(:) :: qWeights The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints\nprovided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss,\nChebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant . integer, public :: targetNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: targetPoints The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation\nand differentiation operators, structured grids in two and three dimensions are created by tensor products of\nthe targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1]\n(computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. Type-Bound Procedures procedure, public :: CalculateBarycentricWeights public subroutine CalculateBarycentricWeights (this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this procedure, public :: CalculateDerivativeMatrix public subroutine CalculateDerivativeMatrix (this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this procedure, public :: CalculateInterpolationMatrix public subroutine CalculateInterpolationMatrix (this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this procedure, public :: CalculateLagrangePolynomials public function CalculateLagrangePolynomials (this, sE) result(lAtS) Arguments Type Intent Optional Attributes Name class( Lagrange_t ) :: this real(kind=prec) :: sE Return Value real(kind=prec)(0:this%N) procedure, public :: Free => Free_Lagrange_t public subroutine Free_Lagrange_t (this) Frees all memory (host and device) associated with an instance of the Lagrange_t class Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this Lagrange_t class instance procedure, public :: Init => Init_Lagrange_t public subroutine Init_Lagrange_t (this, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange_t class\nOn output, all of the attributes for the Lagrange_t class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange_t attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(out) :: this Lagrange_t class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) procedure, public :: WriteHDF5 => WriteHDF5_Lagrange_t public subroutine WriteHDF5_Lagrange_t (this, fileId) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId Source Code type , extends ( Lagrange_t ), public :: Lagrange character ( 3 ) :: backend = 'cpu' endtype Lagrange","tags":"","loc":"type/lagrange~3.html"},{"title":"DomainDecomposition – SELF ","text":"type, public, extends( DomainDecomposition_t ) :: DomainDecomposition Contents Variables elemToRank maxMsg mpiComm mpiEnabled mpiPrec msgCount nElem nRanks offSetElem rankId requests stats Type-Bound Procedures FinalizeMPIExchangeAsync Free GenerateDecomposition Init SetElemToRank Source Code DomainDecomposition Components Type Visibility Attributes Name Initial integer, public, pointer, dimension(:) :: elemToRank integer, public :: maxMsg integer, public :: mpiComm logical, public :: mpiEnabled integer, public :: mpiPrec integer, public :: msgCount integer, public :: nElem integer, public :: nRanks integer, public, pointer, dimension(:) :: offSetElem integer, public :: rankId integer, public, allocatable :: requests (:) integer, public, allocatable :: stats (:,:) Type-Bound Procedures procedure, public :: FinalizeMPIExchangeAsync public subroutine FinalizeMPIExchangeAsync (mpiHandler) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: mpiHandler procedure, public :: Free => Free_DomainDecomposition_t public subroutine Free_DomainDecomposition_t (this) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this procedure, public :: GenerateDecomposition => GenerateDecomposition_DomainDecomposition_t public subroutine GenerateDecomposition_DomainDecomposition_t (this, nGlobalElem, maxMsg) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this integer, intent(in) :: nGlobalElem integer, intent(in) :: maxMsg procedure, public :: Init => Init_DomainDecomposition_t public subroutine Init_DomainDecomposition_t (this, enableMPI) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this logical, intent(in) :: enableMPI procedure, public :: SetElemToRank => SetElemToRank_DomainDecomposition_t public subroutine SetElemToRank_DomainDecomposition_t (this, nElem) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this integer, intent(in) :: nElem Source Code type , extends ( DomainDecomposition_t ) :: DomainDecomposition endtype DomainDecomposition","tags":"","loc":"type/domaindecomposition~2.html"},{"title":"Mesh2D – SELF ","text":"type, public, extends( Mesh2D_t ) :: Mesh2D Contents Variables BCNames BCType CGNSCornerMap CGNSSideMap decomp elemInfo globalNodeIDs nBCs nCornerNodes nElem nGeo nGlobalElem nNodes nSides nUniqueNodes nUniqueSides nodeCoords quadrature sideInfo Type-Bound Procedures Free Init Read_HOPr RecalculateFlip ResetBoundaryConditionType StructuredMesh Write_Mesh Source Code Mesh2D Components Type Visibility Attributes Name Initial character(len=255), public, allocatable :: BCNames (:) integer, public, pointer, dimension(:,:) :: BCType integer, public, pointer, dimension(:,:) :: CGNSCornerMap integer, public, pointer, dimension(:,:) :: CGNSSideMap type( DomainDecomposition ), public :: decomp integer, public, pointer, dimension(:,:) :: elemInfo integer, public, pointer, dimension(:,:,:) :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides real(kind=prec), public, pointer, dimension(:,:,:,:) :: nodeCoords integer, public :: quadrature integer, public, pointer, dimension(:,:,:) :: sideInfo Type-Bound Procedures procedure, public :: Free => Free_Mesh2D_t public subroutine Free_Mesh2D_t (this) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this procedure, public :: Init => Init_Mesh2D_t public subroutine Init_Mesh2D_t (this, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs procedure, public :: Read_HOPr => Read_HOPr_Mesh2D_t public subroutine Read_HOPr_Mesh2D_t (this, meshFile, enableDomainDecomposition) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(out) :: this character, intent(in) :: meshFile logical, intent(in), optional :: enableDomainDecomposition procedure, public :: RecalculateFlip => RecalculateFlip_Mesh2D_t public subroutine RecalculateFlip_Mesh2D_t (this) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh2D_t public subroutine ResetBoundaryConditionType_Mesh2D_t (this, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Read more… Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this integer, intent(in) :: bcid generic, public :: StructuredMesh => UniformStructuredMesh_Mesh2D_t public subroutine UniformStructuredMesh_Mesh2D_t (this, nxPerTile, nyPerTile, nTileX, nTileY, dx, dy, bcids, enableDomainDecomposition) Create a structured mesh and store it in SELF's unstructured mesh format.\nThe mesh is created in tiles of size (tnx,tny). Tiling is used to determine\nthe element ordering. Read more… Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(out) :: this integer, intent(in) :: nxPerTile integer, intent(in) :: nyPerTile integer, intent(in) :: nTileX integer, intent(in) :: nTileY real(kind=prec), intent(in) :: dx real(kind=prec), intent(in) :: dy integer, intent(in) :: bcids (1:4) logical, intent(in), optional :: enableDomainDecomposition procedure, public :: Write_Mesh => Write_Mesh2D_t public subroutine Write_Mesh2D_t (this, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this character, intent(in) :: meshFile Source Code type , extends ( Mesh2D_t ) :: Mesh2D endtype Mesh2D","tags":"","loc":"type/mesh2d~2.html"},{"title":"Scalar1D – SELF ","text":"type, public, extends( Scalar1D_t ) :: Scalar1D Contents Variables M N avgBoundary backend boundary boundarynormal eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Derivative Free GridInterp Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 Source Code Scalar1D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: avgBoundary character(len=3), public :: backend = \"cpu\" real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundarynormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar1D_t public subroutine AverageSides_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D_t public subroutine BoundaryInterp_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this generic, public :: Derivative => Derivative_Scalar1D_t public subroutine Derivative_Scalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: Free => Free_Scalar1D_t public subroutine Free_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this generic, public :: GridInterp => GridInterp_Scalar1D_t public subroutine GridInterp_Scalar1D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%nelem,1:this%nvar) procedure, public :: Init => Init_Scalar1D_t public subroutine Init_Scalar1D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Scalar1D_t public subroutine UpdateDevice_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar1D_t public subroutine UpdateHost_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_Scalar1D_t public subroutine WriteHDF5_Scalar1D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Scalar1D_t ), public :: Scalar1D character ( 3 ) :: backend = \"cpu\" endtype Scalar1D","tags":"","loc":"type/scalar1d~3.html"},{"title":"advection_diffusion_2d – SELF ","text":"type, public, extends( advection_diffusion_2d_t ) :: advection_diffusion_2d Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nu nvar solution solutionGradient source t timeIntegrator u v workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2d flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code advection_diffusion_2d Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D public subroutine BoundaryFlux_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D public subroutine CalculateEntropy_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D public subroutine CalculateSolutionGradient_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel2D public subroutine CalculateTendency_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel2D public subroutine fluxmethod_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel2D_t public subroutine Free_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel2D_t public subroutine Init_DGModel2D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), target :: mesh type( SEMQuad ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel2D_t public subroutine Read_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D public subroutine setboundarycondition_DGModel2D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D public subroutine setgradientboundarycondition_DGModel2D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel2D_t public subroutine SetMetadata_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t , SetSolutionFromEqn_DGModel2D_t public subroutine SetSolutionFromChar_DGModel2D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel2D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel2D public subroutine sourcemethod_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D public subroutine UpdateGRK2_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D public subroutine UpdateGRK3_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D public subroutine UpdateGRK4_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel2D public subroutine UpdateSolution_DGModel2D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel2D_t public subroutine Write_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t public subroutine WriteTecplot_DGModel2D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_advection_diffusion_2d_t public pure function entropy_func_advection_diffusion_2d_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2d => flux2d_advection_diffusion_2d_t public pure function flux2d_advection_diffusion_2d_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar,1:2) Return Value real(kind=prec)(1:this%solution%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_advection_diffusion_2d_t public pure function riemannflux2d_advection_diffusion_2d_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( advection_diffusion_2d_t ) :: advection_diffusion_2d endtype advection_diffusion_2d","tags":"","loc":"type/advection_diffusion_2d~2.html"},{"title":"DGModel2D – SELF ","text":"type, public, extends( DGModel2D_t ) :: DGModel2D Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code DGModel2D Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D_t public subroutine BoundaryFlux_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D_t public subroutine CalculateEntropy_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D_t public subroutine CalculateSolutionGradient_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel2D_t public subroutine CalculateTendency_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel2D_t public subroutine fluxmethod_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel2D_t public subroutine Free_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel2D_t public subroutine Init_DGModel2D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), target :: mesh type( SEMQuad ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel2D_t public subroutine Read_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D_t public subroutine setboundarycondition_DGModel2D_t (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D_t public subroutine setgradientboundarycondition_DGModel2D_t (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel2D_t public subroutine SetMetadata_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t , SetSolutionFromEqn_DGModel2D_t public subroutine SetSolutionFromChar_DGModel2D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel2D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel2D_t public subroutine sourcemethod_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D_t public subroutine UpdateGRK2_DGModel2D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D_t public subroutine UpdateGRK3_DGModel2D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D_t public subroutine UpdateGRK4_DGModel2D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel2D_t public subroutine UpdateSolution_DGModel2D_t (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel2D_t public subroutine Write_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t public subroutine WriteTecplot_DGModel2D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( DGModel2D_t ) :: DGModel2D endtype DGModel2D","tags":"","loc":"type/dgmodel2d~2.html"},{"title":"advection_diffusion_1d – SELF ","text":"type, public, extends( advection_diffusion_1d_t ) :: advection_diffusion_1d Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nu nvar solution solutionGradient source t timeIntegrator u workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1d flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code advection_diffusion_1d Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D public subroutine BoundaryFlux_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D public subroutine CalculateEntropy_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D public subroutine CalculateSolutionGradient_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel1D public subroutine CalculateTendency_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel1D public subroutine fluxmethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel1D_t public subroutine Free_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel1D_t public subroutine Init_DGModel1D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), target :: mesh type( Geometry1D ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel1D_t public subroutine Read_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D public subroutine setboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D public subroutine setgradientboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel1D_t public subroutine SetMetadata_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t , SetSolutionFromEqn_DGModel1D_t public subroutine SetSolutionFromChar_DGModel1D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel1D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel1D public subroutine sourcemethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D public subroutine UpdateGRK2_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D public subroutine UpdateGRK3_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D public subroutine UpdateGRK4_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel1D public subroutine UpdateSolution_DGModel1D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel1D_t public subroutine Write_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t public subroutine WriteTecplot_DGModel1D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_advection_diffusion_1d_t public pure function entropy_func_advection_diffusion_1d_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) procedure, public :: flux1d => flux1d_advection_diffusion_1d_t public pure function flux1d_advection_diffusion_1d_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) Return Value real(kind=prec)(1:this%solution%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_advection_diffusion_1d_t public pure function riemannflux1d_advection_diffusion_1d_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%solution%nvar) real(kind=prec), intent(in) :: sR (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%solution%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( advection_diffusion_1d_t ) :: advection_diffusion_1d endtype advection_diffusion_1d","tags":"","loc":"type/advection_diffusion_1d~2.html"},{"title":"advection_diffusion_3d – SELF ","text":"type, public, extends( advection_diffusion_3d_t ) :: advection_diffusion_3d Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nu nvar solution solutionGradient source t timeIntegrator u v w workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3d hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code advection_diffusion_3d Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v real(kind=prec), public :: w type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D public subroutine BoundaryFlux_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D public subroutine CalculateEntropy_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D public subroutine CalculateSolutionGradient_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel3D public subroutine CalculateTendency_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel3D public subroutine fluxmethod_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel3D_t public subroutine Free_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel3D_t public subroutine Init_DGModel3D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh3D ), intent(in), target :: mesh type( SEMHex ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel3D_t public subroutine Read_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D public subroutine setboundarycondition_DGModel3D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D public subroutine setgradientboundarycondition_DGModel3D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel3D_t public subroutine SetMetadata_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t , SetSolutionFromEqn_DGModel3D_t public subroutine SetSolutionFromChar_DGModel3D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel3D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel3D public subroutine sourcemethod_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D public subroutine UpdateGRK2_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D public subroutine UpdateGRK3_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D public subroutine UpdateGRK4_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel3D public subroutine UpdateSolution_DGModel3D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel3D_t public subroutine Write_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t public subroutine WriteTecplot_DGModel3D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_advection_diffusion_3d_t public pure function entropy_func_advection_diffusion_3d_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3d => flux3d_advection_diffusion_3d_t public pure function flux3d_advection_diffusion_3d_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar,1:3) Return Value real(kind=prec)(1:this%solution%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_advection_diffusion_3d_t public pure function riemannflux3d_advection_diffusion_3d_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( advection_diffusion_3d_t ) :: advection_diffusion_3d endtype advection_diffusion_3d","tags":"","loc":"type/advection_diffusion_3d~2.html"},{"title":"NullDGModel1D – SELF ","text":"type, public, extends( NullDGModel1D_t ) :: NullDGModel1D Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code NullDGModel1D Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D public subroutine BoundaryFlux_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D public subroutine CalculateEntropy_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D public subroutine CalculateSolutionGradient_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel1D public subroutine CalculateTendency_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel1D public subroutine fluxmethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel1D_t public subroutine Free_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel1D_t public subroutine Init_DGModel1D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), target :: mesh type( Geometry1D ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel1D_t public subroutine Read_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D public subroutine setboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D public subroutine setgradientboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel1D_t public subroutine SetMetadata_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t , SetSolutionFromEqn_DGModel1D_t public subroutine SetSolutionFromChar_DGModel1D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel1D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel1D public subroutine sourcemethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D public subroutine UpdateGRK2_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D public subroutine UpdateGRK3_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D public subroutine UpdateGRK4_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel1D public subroutine UpdateSolution_DGModel1D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel1D_t public subroutine Write_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t public subroutine WriteTecplot_DGModel1D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( NullDGModel1D_t ) :: NullDGModel1D endtype NullDGModel1D","tags":"","loc":"type/nulldgmodel1d~2.html"},{"title":"DGModel1D – SELF ","text":"type, public, extends( DGModel1D_t ) :: DGModel1D Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code DGModel1D Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D_t public subroutine BoundaryFlux_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D_t public subroutine CalculateEntropy_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D_t public subroutine CalculateSolutionGradient_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel1D_t public subroutine CalculateTendency_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel1D_t public subroutine fluxmethod_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel1D_t public subroutine Free_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel1D_t public subroutine Init_DGModel1D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), target :: mesh type( Geometry1D ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel1D_t public subroutine Read_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D_t public subroutine setboundarycondition_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D_t public subroutine setgradientboundarycondition_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel1D_t public subroutine SetMetadata_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t , SetSolutionFromEqn_DGModel1D_t public subroutine SetSolutionFromChar_DGModel1D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel1D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel1D_t public subroutine sourcemethod_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D_t public subroutine UpdateGRK2_DGModel1D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D_t public subroutine UpdateGRK3_DGModel1D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D_t public subroutine UpdateGRK4_DGModel1D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel1D_t public subroutine UpdateSolution_DGModel1D_t (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel1D_t public subroutine Write_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t public subroutine WriteTecplot_DGModel1D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( DGModel1D_t ) :: DGModel1D endtype DGModel1D","tags":"","loc":"type/dgmodel1d~2.html"},{"title":"MappedVector3D – SELF ","text":"type, public, extends( MappedVector3D_t ) :: MappedVector3D Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundaryNormal boundaryNormal_gpu boundary_gpu eqn extBoundary extBoundary_gpu geometry geometry_associated interior interior_gpu interp interpWork1 interpWork2 meta nElem nVar Type-Bound Procedures AssociateGeometry AverageSides BoundaryInterp Curl DissociateGeometry Divergence Free Gradient GridInterp Init MappedDGDivergence MappedDivergence SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedVector3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMHex ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedVector3D_t public subroutine AssociateGeometry_MappedVector3D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( SEMHex ), intent(in), target :: geometry procedure, public :: AverageSides => AverageSides_Vector3D public subroutine AverageSides_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D public subroutine BoundaryInterp_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this generic, public :: Curl => Curl_Vector3D_t public subroutine Curl_Vector3D_t (this, curlf) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: curlf (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) procedure, public :: DissociateGeometry => DissociateGeometry_MappedVector3D_t public subroutine DissociateGeometry_MappedVector3D_t (this) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this generic, public :: Divergence => Divergence_Vector3D_t , Divergence_Vector3D public subroutine Divergence_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Divergence_Vector3D (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, public :: Free => Free_Vector3D public subroutine Free_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this generic, public :: Gradient => Gradient_Vector3D_t , Gradient_Vector3D public subroutine Gradient_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3,1:3) public subroutine Gradient_Vector3D (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Vector3D_t , GridInterp_Vector3D public subroutine GridInterp_Vector3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:3) (Output) Array of function values, defined on the target grid public subroutine GridInterp_Vector3D (this, f) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Vector3D public subroutine Init_Vector3D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: MappedDGDivergence => MappedDGDivergence_MappedVector3D_t public subroutine MappedDGDivergence_MappedVector3D_t (this, df) Computes the divergence of a 3-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) generic, public :: MappedDivergence => MappedDivergence_MappedVector3D_t public subroutine MappedDivergence_MappedVector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector3D_t public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector3D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector3D_t public subroutine SetInteriorFromEquation_MappedVector3D_t (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedVector3D_t public subroutine SideExchange_MappedVector3D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh procedure, public :: UpdateDevice => UpdateDevice_Vector3D public subroutine UpdateDevice_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Vector3D public subroutine UpdateHost_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D_t , WriteHDF5_Vector3D_t public subroutine WriteHDF5_MPI_Vector3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( MappedVector3D_t ), public :: MappedVector3D endtype MappedVector3D","tags":"","loc":"type/mappedvector3d~2.html"},{"title":"Mesh3D – SELF ","text":"type, public, extends( Mesh3D_t ) :: Mesh3D Contents Variables BCNames BCType CGNSCornerMap CGNSSideMap decomp elemInfo globalNodeIDs nBCs nCornerNodes nElem nGeo nGlobalElem nNodes nSides nUniqueNodes nUniqueSides nodeCoords quadrature sideInfo sideMap Type-Bound Procedures Free Init Read_HOPr RecalculateFlip ResetBoundaryConditionType Write_Mesh Source Code Mesh3D Components Type Visibility Attributes Name Initial character(len=255), public, allocatable :: BCNames (:) integer, public, pointer, dimension(:,:) :: BCType integer, public, pointer, dimension(:,:) :: CGNSCornerMap integer, public, pointer, dimension(:,:) :: CGNSSideMap type( DomainDecomposition ), public :: decomp integer, public, pointer, dimension(:,:) :: elemInfo integer, public, pointer, dimension(:,:,:,:) :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides real(kind=prec), public, pointer, dimension(:,:,:,:,:) :: nodeCoords integer, public :: quadrature integer, public, pointer, dimension(:,:,:) :: sideInfo integer, public, pointer, dimension(:,:) :: sideMap Type-Bound Procedures procedure, public :: Free => Free_Mesh3D_t public subroutine Free_Mesh3D_t (this) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this procedure, public :: Init => Init_Mesh3D_t public subroutine Init_Mesh3D_t (this, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs procedure, public :: Read_HOPr => Read_HOPr_Mesh3D_t public subroutine Read_HOPr_Mesh3D_t (this, meshFile, enableDomainDecomposition) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(out) :: this character, intent(in) :: meshFile logical, intent(in), optional :: enableDomainDecomposition procedure, public :: RecalculateFlip => RecalculateFlip_Mesh3D_t public subroutine RecalculateFlip_Mesh3D_t (this) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh3D_t public subroutine ResetBoundaryConditionType_Mesh3D_t (this, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Read more… Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this integer, intent(in) :: bcid procedure, public :: Write_Mesh => Write_Mesh3D_t public subroutine Write_Mesh3D_t (this, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this character, intent(in) :: meshFile Source Code type , extends ( Mesh3D_t ) :: Mesh3D endtype Mesh3D","tags":"","loc":"type/mesh3d~2.html"},{"title":"MappedScalar1D – SELF ","text":"type, public, extends( MappedScalar1D_t ) :: MappedScalar1D Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundary_gpu boundarynormal boundarynormal_gpu eqn extBoundary extBoundary_gpu geometry geometry_associated interior interior_gpu interp meta nElem nVar Type-Bound Procedures AssociateGeometry AverageSides BoundaryInterp Derivative DissociateGeometry Free GridInterp Init MappedDGDerivative MappedDerivative SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedScalar1D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( Geometry1D ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar1D_t public subroutine AssociateGeometry_MappedScalar1D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this type( Geometry1D ), intent(in), target :: geometry procedure, public :: AverageSides => AverageSides_Scalar1D public subroutine AverageSides_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D public subroutine BoundaryInterp_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this generic, public :: Derivative => Derivative_Scalar1D_t , Derivative_Scalar1D public subroutine Derivative_Scalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Derivative_Scalar1D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar1D_t public subroutine DissociateGeometry_MappedScalar1D_t (this) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this procedure, public :: Free => Free_Scalar1D public subroutine Free_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this generic, public :: GridInterp => GridInterp_Scalar1D_t , GridInterp_Scalar1D public subroutine GridInterp_Scalar1D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%nelem,1:this%nvar) public subroutine GridInterp_Scalar1D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Scalar1D public subroutine Init_Scalar1D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: MappedDGDerivative => MappedDGDerivative_MappedScalar1D_t public subroutine MappedDGDerivative_MappedScalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%nelem,1:this%nvar) generic, public :: MappedDerivative => MappedDerivative_MappedScalar1D_t public subroutine MappedDerivative_MappedScalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar1D_t public subroutine SetInteriorFromEquation_MappedScalar1D_t (this, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedScalar1D_t public subroutine SideExchange_MappedScalar1D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this type( Mesh1D ), intent(inout) :: mesh procedure, public :: UpdateDevice => UpdateDevice_Scalar1D public subroutine UpdateDevice_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar1D public subroutine UpdateHost_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_Scalar1D_t public subroutine WriteHDF5_Scalar1D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( MappedScalar1D_t ), public :: MappedScalar1D endtype MappedScalar1D","tags":"","loc":"type/mappedscalar1d~2.html"},{"title":"Tensor3D – SELF ","text":"type, public, extends( Tensor3D_t ) :: Tensor3D Contents Variables M N backend boundary eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures BoundaryInterp Determinant Free Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost Source Code Tensor3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N character(len=3), public :: backend = \"cpu\" real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: boundary type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor3D_t public subroutine BoundaryInterp_Tensor3D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this generic, public :: Determinant => Determinant_Tensor3D_t public subroutine Determinant_Tensor3D_t (this, det) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(in) :: this real(kind=prec), intent(out) :: det (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: Free => Free_Tensor3D_t public subroutine Free_Tensor3D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this procedure, public :: Init => Init_Tensor3D_t public subroutine Init_Tensor3D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Tensor3D_t public subroutine UpdateDevice_Tensor3D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Tensor3D_t public subroutine UpdateHost_Tensor3D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this Source Code type , extends ( Tensor3D_t ), public :: Tensor3D character ( 3 ) :: backend = \"cpu\" endtype Tensor3D","tags":"","loc":"type/tensor3d~2.html"},{"title":"NullDGModel2D – SELF ","text":"type, public, extends( NullDGModel2D_t ) :: NullDGModel2D Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code NullDGModel2D Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D public subroutine BoundaryFlux_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D public subroutine CalculateEntropy_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D public subroutine CalculateSolutionGradient_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel2D public subroutine CalculateTendency_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel2D public subroutine fluxmethod_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel2D_t public subroutine Free_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel2D_t public subroutine Init_DGModel2D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), target :: mesh type( SEMQuad ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel2D_t public subroutine Read_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D public subroutine setboundarycondition_DGModel2D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D public subroutine setgradientboundarycondition_DGModel2D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel2D_t public subroutine SetMetadata_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t , SetSolutionFromEqn_DGModel2D_t public subroutine SetSolutionFromChar_DGModel2D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel2D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel2D public subroutine sourcemethod_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D public subroutine UpdateGRK2_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D public subroutine UpdateGRK3_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D public subroutine UpdateGRK4_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel2D public subroutine UpdateSolution_DGModel2D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel2D_t public subroutine Write_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t public subroutine WriteTecplot_DGModel2D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( NullDGModel2D_t ) :: NullDGModel2D endtype NullDGModel2D","tags":"","loc":"type/nulldgmodel2d~2.html"},{"title":"Scalar3D – SELF ","text":"type, public, extends( Scalar3D_t ) :: Scalar3D Contents Variables M N avgBoundary backend boundary boundarynormal eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Free Gradient GridInterp Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 Source Code Scalar3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary character(len=3), public :: backend = \"cpu\" real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundarynormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar3D_t public subroutine AverageSides_Scalar3D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D_t public subroutine BoundaryInterp_Scalar3D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this procedure, public :: Free => Free_Scalar3D_t public subroutine Free_Scalar3D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this generic, public :: Gradient => Gradient_Scalar3D_t public subroutine Gradient_Scalar3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) generic, public :: GridInterp => GridInterp_Scalar3D_t public subroutine GridInterp_Scalar3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) (Output) Array of function values, defined on the target grid procedure, public :: Init => Init_Scalar3D_t public subroutine Init_Scalar3D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Scalar3D_t public subroutine UpdateDevice_Scalar3D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar3D_t public subroutine UpdateHost_Scalar3D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D_t , WriteHDF5_Scalar3D_t public subroutine WriteHDF5_MPI_Scalar3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Scalar3D_t ), public :: Scalar3D character ( 3 ) :: backend = \"cpu\" endtype Scalar3D","tags":"","loc":"type/scalar3d~2.html"},{"title":"Scalar2D – SELF ","text":"type, public, extends( Scalar2D_t ) :: Scalar2D Contents Variables M N avgBoundary backend boundary boundarynormal eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Free Gradient GridInterp Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 Source Code Scalar2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: avgBoundary character(len=3), public :: backend = \"cpu\" real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundarynormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar2D_t public subroutine AverageSides_Scalar2D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D_t public subroutine BoundaryInterp_Scalar2D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this procedure, public :: Free => Free_Scalar2D_t public subroutine Free_Scalar2D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this generic, public :: Gradient => Gradient_Scalar2D_t public subroutine Gradient_Scalar2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) generic, public :: GridInterp => GridInterp_Scalar2D_t public subroutine GridInterp_Scalar2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) procedure, public :: Init => Init_Scalar2D_t public subroutine Init_Scalar2D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Scalar2D_t public subroutine UpdateDevice_Scalar2D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar2D_t public subroutine UpdateHost_Scalar2D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D_t , WriteHDF5_Scalar2D_t public subroutine WriteHDF5_MPI_Scalar2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Scalar2D_t ), public :: Scalar2D character ( 3 ) :: backend = \"cpu\" endtype Scalar2D","tags":"","loc":"type/scalar2d~2.html"},{"title":"Vector2D – SELF ","text":"type, public, extends( Vector2D_t ) :: Vector2D Contents Variables M N avgBoundary backend boundary boundaryNormal eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures AverageSides BoundaryInterp Divergence Free Gradient GridInterp Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost WriteHDF5 Source Code Vector2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary character(len=3), public :: backend = \"cpu\" real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundaryNormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Vector2D_t public subroutine AverageSides_Vector2D_t (this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D_t public subroutine BoundaryInterp_Vector2D_t (this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this generic, public :: Divergence => Divergence_Vector2D_t public subroutine Divergence_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: Free => Free_Vector2D_t public subroutine Free_Vector2D_t (this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this generic, public :: Gradient => Gradient_Vector2D_t public subroutine Gradient_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2,1:2) generic, public :: GridInterp => GridInterp_Vector2D_t public subroutine GridInterp_Vector2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:2) procedure, public :: Init => Init_Vector2D_t public subroutine Init_Vector2D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector2D_t public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector2D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Vector2D_t public subroutine UpdateDevice_Vector2D_t (this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Vector2D_t public subroutine UpdateHost_Vector2D_t (this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D_t , WriteHDF5_Vector2D_t public subroutine WriteHDF5_MPI_Vector2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( Vector2D_t ), public :: Vector2D character ( 3 ) :: backend = \"cpu\" endtype Vector2D","tags":"","loc":"type/vector2d~2.html"},{"title":"MappedScalar2D – SELF ","text":"type, public, extends( MappedScalar2D_t ) :: MappedScalar2D Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundary_gpu boundarynormal boundarynormal_gpu eqn extBoundary extBoundary_gpu geometry geometry_associated interior interior_gpu interp interpWork meta nElem nVar Type-Bound Procedures AssociateGeometry AverageSides BoundaryInterp DissociateGeometry Free Gradient GridInterp Init MappedDGGradient MappedGradient SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedScalar2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMQuad ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar2D_t public subroutine AssociateGeometry_MappedScalar2D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( SEMQuad ), intent(in), target :: geometry procedure, public :: AverageSides => AverageSides_Scalar2D public subroutine AverageSides_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D public subroutine BoundaryInterp_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar2D_t public subroutine DissociateGeometry_MappedScalar2D_t (this) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this procedure, public :: Free => Free_Scalar2D public subroutine Free_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this generic, public :: Gradient => Gradient_Scalar2D_t , Gradient_Scalar2D public subroutine Gradient_Scalar2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) public subroutine Gradient_Scalar2D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Scalar2D_t , GridInterp_Scalar2D public subroutine GridInterp_Scalar2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) public subroutine GridInterp_Scalar2D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Scalar2D public subroutine Init_Scalar2D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: MappedDGGradient => MappedDGGradient_MappedScalar2D_t public subroutine MappedDGGradient_MappedScalar2D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) generic, public :: MappedGradient => MappedGradient_MappedScalar2D_t public subroutine MappedGradient_MappedScalar2D_t (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar2D_t public subroutine SetInteriorFromEquation_MappedScalar2D_t (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedScalar2D_t public subroutine SideExchange_MappedScalar2D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh procedure, public :: UpdateDevice => UpdateDevice_Scalar2D public subroutine UpdateDevice_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Scalar2D public subroutine UpdateHost_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D_t , WriteHDF5_Scalar2D_t public subroutine WriteHDF5_MPI_Scalar2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( MappedScalar2D_t ), public :: MappedScalar2D endtype MappedScalar2D","tags":"","loc":"type/mappedscalar2d~2.html"},{"title":"DGModel3D – SELF ","text":"type, public, extends( DGModel3D_t ) :: DGModel3D Contents Variables dSdt dt entropy flux fluxDivergence geometry gradient_enabled ioIterate mesh nvar solution solutionGradient source t timeIntegrator workSol Type-Bound Procedures BoundaryFlux CalculateEntropy CalculateSolutionGradient CalculateTendency Euler_timeIntegrator FluxMethod ForwardStep Free GetSimulationTime IncrementIOCounter Init LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency PrintType ReadModel ReportEntropy SetBoundaryCondition SetGradientBoundaryCondition SetMetadata SetSimulationTime SetSolution SetTimeIntegrator SourceMethod UpdateGRK2 UpdateGRK3 UpdateGRK4 UpdateSolution WriteModel WriteTecplot entropy_func flux1D flux2D flux3D hbc1d_NoNormalFlow hbc1d_Prescribed hbc1d_Radiation hbc2d_NoNormalFlow hbc2d_Prescribed hbc2d_Radiation hbc3d_NoNormalFlow hbc3d_Prescribed hbc3d_Radiation pbc1d_NoNormalFlow pbc1d_Prescribed pbc1d_Radiation pbc2d_NoNormalFlow pbc2d_Prescribed pbc2d_Radiation pbc3d_NoNormalFlow pbc3d_Prescribed pbc3d_Radiation riemannflux1d riemannflux2d riemannflux3d source1d source2d source3d Source Code DGModel3D Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D_t public subroutine BoundaryFlux_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D_t public subroutine CalculateEntropy_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D_t public subroutine CalculateSolutionGradient_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: CalculateTendency => CalculateTendency_DGModel3D_t public subroutine CalculateTendency_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: Euler_timeIntegrator public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: FluxMethod => fluxmethod_DGModel3D_t public subroutine fluxmethod_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: ForwardStep => ForwardStep_Model public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval procedure, public :: Free => Free_DGModel3D_t public subroutine Free_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: GetSimulationTime public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t procedure, public :: IncrementIOCounter public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: Init => Init_DGModel3D_t public subroutine Init_DGModel3D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh3D ), intent(in), target :: mesh type( SEMHex ), intent(in), target :: geometry procedure, public :: LowStorageRK2_timeIntegrator public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK3_timeIntegrator public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: LowStorageRK4_timeIntegrator public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn procedure, public :: PreTendency => PreTendency_Model public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this procedure, public :: PrintType => PrintType_Model public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: ReadModel => Read_DGModel3D_t public subroutine Read_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: ReportEntropy => ReportEntropy_Model public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D_t public subroutine setboundarycondition_DGModel3D_t (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D_t public subroutine setgradientboundarycondition_DGModel3D_t (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: SetMetadata => SetMetadata_DGModel3D_t public subroutine SetMetadata_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: SetSimulationTime public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t , SetSolutionFromEqn_DGModel3D_t public subroutine SetSolutionFromChar_DGModel3D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel3D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator procedure, public :: SourceMethod => sourcemethod_DGModel3D_t public subroutine sourcemethod_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D_t public subroutine UpdateGRK2_DGModel3D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D_t public subroutine UpdateGRK3_DGModel3D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D_t public subroutine UpdateGRK4_DGModel3D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this integer, intent(in) :: m procedure, public :: UpdateSolution => UpdateSolution_DGModel3D_t public subroutine UpdateSolution_DGModel3D_t (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt procedure, public :: WriteModel => Write_DGModel3D_t public subroutine Write_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: fileName procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t public subroutine WriteTecplot_DGModel3D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: filename procedure, public :: entropy_func => entropy_func_Model public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) procedure, public :: flux1D => flux1d_Model public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: flux2D => flux2d_Model public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: flux3D => flux3d_Model public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) procedure, public :: riemannflux1d => riemannflux1d_Model public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux2d => riemannflux2d_Model public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: riemannflux3d => riemannflux3d_Model public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source1d => source1d_Model public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source2d => source2d_Model public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) procedure, public :: source3d => source3d_Model public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Source Code type , extends ( DGModel3D_t ) :: DGModel3D endtype DGModel3D","tags":"","loc":"type/dgmodel3d~2.html"},{"title":"MappedVector2D – SELF ","text":"type, public, extends( MappedVector2D_t ) :: MappedVector2D Contents Variables M N avgBoundary avgBoundary_gpu backend blas_handle boundary boundaryNormal boundaryNormal_gpu boundary_gpu eqn extBoundary extBoundary_gpu geometry geometry_associated interior interior_gpu interp interpWork meta nElem nVar Type-Bound Procedures AssociateGeometry AverageSides BoundaryInterp DissociateGeometry Divergence Free Gradient GridInterp Init MappedDGDivergence MappedDivergence SetDescription SetEquation SetInteriorFromEquation SetName SetUnits SideExchange UpdateDevice UpdateHost WriteHDF5 Source Code MappedVector2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMQuad ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedVector2D_t public subroutine AssociateGeometry_MappedVector2D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( SEMQuad ), intent(in), target :: geometry procedure, public :: AverageSides => AverageSides_Vector2D public subroutine AverageSides_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D public subroutine BoundaryInterp_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this procedure, public :: DissociateGeometry => DissociateGeometry_MappedVector2D_t public subroutine DissociateGeometry_MappedVector2D_t (this) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this generic, public :: Divergence => Divergence_Vector2D_t , Divergence_Vector2D public subroutine Divergence_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Divergence_Vector2D (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this type(c_ptr), intent(inout) :: df procedure, public :: Free => Free_Vector2D public subroutine Free_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this generic, public :: Gradient => Gradient_Vector2D_t , Gradient_Vector2D public subroutine Gradient_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2,1:2) public subroutine Gradient_Vector2D (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this type(c_ptr), intent(inout) :: df generic, public :: GridInterp => GridInterp_Vector2D_t , GridInterp_Vector2D public subroutine GridInterp_Vector2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:2) public subroutine GridInterp_Vector2D (this, f) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this type(c_ptr), intent(inout) :: f procedure, public :: Init => Init_Vector2D public subroutine Init_Vector2D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: MappedDGDivergence => MappedDGDivergence_MappedVector2D_t public subroutine MappedDGDivergence_MappedVector2D_t (this, df) Computes the divergence of a 2-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(in) :: this real(kind=prec) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) generic, public :: MappedDivergence => MappedDivergence_MappedVector2D_t public subroutine MappedDivergence_MappedVector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj , SetEquation_Vector2D_t public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetEquation_Vector2D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector2D_t public subroutine SetInteriorFromEquation_MappedVector2D_t (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: SideExchange => SideExchange_MappedVector2D_t public subroutine SideExchange_MappedVector2D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh procedure, public :: UpdateDevice => UpdateDevice_Vector2D public subroutine UpdateDevice_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Vector2D public subroutine UpdateHost_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D_t , WriteHDF5_Vector2D_t public subroutine WriteHDF5_MPI_Vector2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Source Code type , extends ( MappedVector2D_t ), public :: MappedVector2D endtype MappedVector2D","tags":"","loc":"type/mappedvector2d~2.html"},{"title":"Tensor2D – SELF ","text":"type, public, extends( Tensor2D_t ) :: Tensor2D Contents Variables M N backend boundary eqn extBoundary interior interp meta nElem nVar Type-Bound Procedures BoundaryInterp Determinant Free Init SetDescription SetEquation SetName SetUnits UpdateDevice UpdateHost Source Code Tensor2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N character(len=3), public :: backend = \"cpu\" real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor2D_t public subroutine BoundaryInterp_Tensor2D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this generic, public :: Determinant => Determinant_Tensor2D_t public subroutine Determinant_Tensor2D_t (this, det) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(in) :: this real(kind=prec), intent(out) :: det (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) procedure, public :: Free => Free_Tensor2D_t public subroutine Free_Tensor2D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this procedure, public :: Init => Init_Tensor2D_t public subroutine Init_Tensor2D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem procedure, public :: SetDescription => SetDescription_DataObj public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description generic, public :: SetEquation => SetEquation_DataObj public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar procedure, public :: SetName => SetName_DataObj public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name procedure, public :: SetUnits => SetUnits_DataObj public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units procedure, public :: UpdateDevice => UpdateDevice_Tensor2D_t public subroutine UpdateDevice_Tensor2D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_Tensor2D_t public subroutine UpdateHost_Tensor2D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this Source Code type , extends ( Tensor2D_t ), public :: Tensor2D character ( 3 ) :: backend = \"cpu\" endtype Tensor2D","tags":"","loc":"type/tensor2d~2.html"},{"title":"BoundaryFlux_DGModel3D_t – SELF","text":"public subroutine BoundaryFlux_DGModel3D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this Contents Source Code BoundaryFlux_DGModel3D_t Source Code subroutine BoundaryFlux_DGModel3D_t ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! Local integer :: i , j , k , iel real ( prec ) :: sL ( 1 : this % nvar ), sR ( 1 : this % nvar ) real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ) :: nhat ( 1 : 3 ), nmag do iEl = 1 , this % solution % nElem do k = 1 , 6 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 ! Get the boundary normals on cell edges from the mesh geometry nhat = this % geometry % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) sL = this % solution % boundary ( i , j , k , iel , 1 : this % nvar ) ! interior solution sR = this % solution % extboundary ( i , j , k , iel , 1 : this % nvar ) ! exterior solution dsdx = this % solutiongradient % avgboundary ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) nmag = this % geometry % nScale % boundary ( i , j , k , iEl , 1 ) this % flux % boundaryNormal ( i , j , k , iEl , 1 : this % nvar ) = this % riemannflux3d ( sL , sR , dsdx , nhat ) * nmag enddo enddo enddo enddo endsubroutine BoundaryFlux_DGModel3D_t","tags":"","loc":"proc/boundaryflux_dgmodel3d_t.html"},{"title":"CalculateEntropy_DGModel3D_t – SELF","text":"public subroutine CalculateEntropy_DGModel3D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this Contents Source Code CalculateEntropy_DGModel3D_t Source Code subroutine CalculateEntropy_DGModel3D_t ( this ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! Local integer :: iel , i , j , k , ierror real ( prec ) :: e , jac real ( prec ) :: s ( 1 : this % nvar ) e = 0.0_prec do iel = 1 , this % geometry % nelem do k = 1 , this % solution % interp % N + 1 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 jac = this % geometry % J % interior ( i , j , k , iel , 1 ) s = this % solution % interior ( i , j , k , iel , 1 : this % nvar ) e = e + this % entropy_func ( s ) * jac enddo enddo enddo enddo if ( this % mesh % decomp % mpiEnabled ) then call mpi_allreduce ( e , & this % entropy , & 1 , & this % mesh % decomp % mpiPrec , & MPI_SUM , & this % mesh % decomp % mpiComm , & iError ) else this % entropy = e endif endsubroutine CalculateEntropy_DGModel3D_t","tags":"","loc":"proc/calculateentropy_dgmodel3d_t.html"},{"title":"CalculateSolutionGradient_DGModel3D_t – SELF","text":"public subroutine CalculateSolutionGradient_DGModel3D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this Contents Source Code CalculateSolutionGradient_DGModel3D_t Source Code subroutine CalculateSolutionGradient_DGModel3D_t ( this ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this call this % solution % AverageSides () call this % solution % MappedDGGradient ( this % solutionGradient % interior ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp () ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh ) endsubroutine CalculateSolutionGradient_DGModel3D_t","tags":"","loc":"proc/calculatesolutiongradient_dgmodel3d_t.html"},{"title":"CalculateTendency_DGModel3D_t – SELF","text":"public subroutine CalculateTendency_DGModel3D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this Contents Source Code CalculateTendency_DGModel3D_t Source Code subroutine CalculateTendency_DGModel3D_t ( this ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! Local integer :: i , j , k , iVar , iEl call this % solution % BoundaryInterp () call this % solution % SideExchange ( this % mesh ) call this % PreTendency () ! User-supplied call this % SetBoundaryCondition () ! User-supplied if ( this % gradient_enabled ) then call this % solution % AverageSides () call this % CalculateSolutionGradient () call this % SetGradientBoundaryCondition () ! User-supplied call this % solutionGradient % AverageSides () endif call this % SourceMethod () ! User supplied call this % BoundaryFlux () ! User supplied call this % FluxMethod () ! User supplied call this % flux % MappedDGDivergence ( this % fluxDivergence % interior ) do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & k = 1 : this % solution % N + 1 , iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % dSdt % interior ( i , j , k , iEl , iVar ) = & this % source % interior ( i , j , k , iEl , iVar ) - & this % fluxDivergence % interior ( i , j , k , iEl , iVar ) enddo endsubroutine CalculateTendency_DGModel3D_t","tags":"","loc":"proc/calculatetendency_dgmodel3d_t.html"},{"title":"Free_DGModel3D_t – SELF","text":"public subroutine Free_DGModel3D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this Contents Source Code Free_DGModel3D_t Source Code subroutine Free_DGModel3D_t ( this ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this call this % solution % Free () call this % workSol % Free () call this % dSdt % Free () call this % solutionGradient % Free () call this % flux % Free () call this % source % Free () call this % fluxDivergence % Free () endsubroutine Free_DGModel3D_t","tags":"","loc":"proc/free_dgmodel3d_t.html"},{"title":"Init_DGModel3D_t – SELF","text":"public subroutine Init_DGModel3D_t(this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh3D ), intent(in), target :: mesh type( SEMHex ), intent(in), target :: geometry Contents Source Code Init_DGModel3D_t Source Code subroutine Init_DGModel3D_t ( this , nvar , mesh , geometry ) implicit none class ( DGModel3D_t ), intent ( out ) :: this integer , intent ( in ) :: nvar type ( Mesh3D ), intent ( in ), target :: mesh type ( SEMHex ), intent ( in ), target :: geometry ! Local integer :: ivar character ( LEN = 3 ) :: ivarChar character ( LEN = 25 ) :: varname this % mesh => mesh this % geometry => geometry this % nvar = nvar call this % solution % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % workSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % dSdt % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % solutionGradient % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % flux % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % source % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % fluxDivergence % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % solution % AssociateGeometry ( geometry ) call this % solutionGradient % AssociateGeometry ( geometry ) call this % flux % AssociateGeometry ( geometry ) call this % fluxDivergence % AssociateGeometry ( geometry ) call this % SetMetadata () endsubroutine Init_DGModel3D_t","tags":"","loc":"proc/init_dgmodel3d_t.html"},{"title":"Read_DGModel3D_t – SELF","text":"public subroutine Read_DGModel3D_t(this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: fileName Contents Source Code Read_DGModel3D_t Source Code subroutine Read_DGModel3D_t ( this , fileName ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: fileName ! Local integer ( HID_T ) :: fileId integer ( HID_T ) :: solOffset ( 1 : 4 ) integer :: firstElem , ivar if ( this % mesh % decomp % mpiEnabled ) then call Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % mesh % decomp % mpiComm ) else call Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) endif if ( this % mesh % decomp % mpiEnabled ) then firstElem = this % mesh % decomp % offsetElem ( this % mesh % decomp % rankId + 1 ) solOffset ( 1 : 4 ) = ( / 0 , 0 , 0 , firstElem / ) do ivar = 1 , this % solution % nvar call ReadArray_HDF5 ( fileId , & '/controlgrid/solution/' // trim ( this % solution % meta ( ivar )% name ), & this % solution % interior (:,:,:,:, ivar ), solOffset ) enddo else do ivar = 1 , this % solution % nvar call ReadArray_HDF5 ( fileId , & '/controlgrid/solution/' // trim ( this % solution % meta ( ivar )% name ), & this % solution % interior (:,:,:,:, ivar )) enddo endif call Close_HDF5 ( fileId ) endsubroutine Read_DGModel3D_t","tags":"","loc":"proc/read_dgmodel3d_t.html"},{"title":"SetMetadata_DGModel3D_t – SELF","text":"public subroutine SetMetadata_DGModel3D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this Contents Source Code SetMetadata_DGModel3D_t Source Code subroutine SetMetadata_DGModel3D_t ( this ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! Local integer :: ivar character ( LEN = 3 ) :: ivarChar character ( LEN = 25 ) :: varname do ivar = 1 , this % nvar write ( ivarChar , '(I3.3)' ) ivar varname = \"solution\" // trim ( ivarChar ) call this % solution % SetName ( ivar , varname ) call this % solution % SetUnits ( ivar , \"[null]\" ) enddo endsubroutine SetMetadata_DGModel3D_t","tags":"","loc":"proc/setmetadata_dgmodel3d_t.html"},{"title":"SetSolutionFromChar_DGModel3D_t – SELF","text":"public subroutine SetSolutionFromChar_DGModel3D_t(this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) Contents Source Code SetSolutionFromChar_DGModel3D_t Source Code subroutine SetSolutionFromChar_DGModel3D_t ( this , eqnChar ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: eqnChar ( 1 : this % solution % nVar ) ! Local integer :: iVar do iVar = 1 , this % solution % nVar call this % solution % SetEquation ( ivar , trim ( eqnChar ( iVar ))) enddo call this % solution % SetInteriorFromEquation ( this % geometry , this % t ) call this % solution % BoundaryInterp () endsubroutine SetSolutionFromChar_DGModel3D_t","tags":"","loc":"proc/setsolutionfromchar_dgmodel3d_t.html"},{"title":"SetSolutionFromEqn_DGModel3D_t – SELF","text":"public subroutine SetSolutionFromEqn_DGModel3D_t(this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) Contents Source Code SetSolutionFromEqn_DGModel3D_t Source Code subroutine SetSolutionFromEqn_DGModel3D_t ( this , eqn ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this type ( EquationParser ), intent ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local integer :: iVar ! Copy the equation parser do iVar = 1 , this % solution % nVar call this % solution % SetEquation ( ivar , eqn ( iVar )% equation ) enddo call this % solution % SetInteriorFromEquation ( this % geometry , this % t ) call this % solution % BoundaryInterp () endsubroutine SetSolutionFromEqn_DGModel3D_t","tags":"","loc":"proc/setsolutionfromeqn_dgmodel3d_t.html"},{"title":"UpdateGRK2_DGModel3D_t – SELF","text":"public subroutine UpdateGRK2_DGModel3D_t(this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK2_DGModel3D_t Source Code subroutine UpdateGRK2_DGModel3D_t ( this , m ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , j , k , iVar , iEl do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & k = 1 : this % solution % N + 1 , iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , j , k , iEl , iVar ) = rk2_a ( m ) * & this % workSol % interior ( i , j , k , iEl , iVar ) + & this % dSdt % interior ( i , j , k , iEl , iVar ) this % solution % interior ( i , j , k , iEl , iVar ) = & this % solution % interior ( i , j , k , iEl , iVar ) + & rk2_g ( m ) * this % dt * this % workSol % interior ( i , j , k , iEl , iVar ) enddo endsubroutine UpdateGRK2_DGModel3D_t","tags":"","loc":"proc/updategrk2_dgmodel3d_t.html"},{"title":"UpdateGRK3_DGModel3D_t – SELF","text":"public subroutine UpdateGRK3_DGModel3D_t(this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK3_DGModel3D_t Source Code subroutine UpdateGRK3_DGModel3D_t ( this , m ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , j , k , iVar , iEl do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & k = 1 : this % solution % N + 1 , iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , j , k , iEl , iVar ) = rk3_a ( m ) * & this % workSol % interior ( i , j , k , iEl , iVar ) + & this % dSdt % interior ( i , j , k , iEl , iVar ) this % solution % interior ( i , j , k , iEl , iVar ) = & this % solution % interior ( i , j , k , iEl , iVar ) + & rk3_g ( m ) * this % dt * this % workSol % interior ( i , j , k , iEl , iVar ) enddo endsubroutine UpdateGRK3_DGModel3D_t","tags":"","loc":"proc/updategrk3_dgmodel3d_t.html"},{"title":"UpdateGRK4_DGModel3D_t – SELF","text":"public subroutine UpdateGRK4_DGModel3D_t(this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK4_DGModel3D_t Source Code subroutine UpdateGRK4_DGModel3D_t ( this , m ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , j , k , iVar , iEl do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & k = 1 : this % solution % N + 1 , iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , j , k , iEl , iVar ) = rk4_a ( m ) * & this % workSol % interior ( i , j , k , iEl , iVar ) + & this % dSdt % interior ( i , j , k , iEl , iVar ) this % solution % interior ( i , j , k , iEl , iVar ) = & this % solution % interior ( i , j , k , iEl , iVar ) + & rk4_g ( m ) * this % dt * this % workSol % interior ( i , j , k , iEl , iVar ) enddo endsubroutine UpdateGRK4_DGModel3D_t","tags":"","loc":"proc/updategrk4_dgmodel3d_t.html"},{"title":"UpdateSolution_DGModel3D_t – SELF","text":"public subroutine UpdateSolution_DGModel3D_t(this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt Contents Source Code UpdateSolution_DGModel3D_t Source Code subroutine UpdateSolution_DGModel3D_t ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) implicit none class ( DGModel3D_t ), intent ( inout ) :: this real ( prec ), optional , intent ( in ) :: dt ! Local real ( prec ) :: dtLoc integer :: i , j , k , iVar , iEl if ( present ( dt )) then dtLoc = dt else dtLoc = this % dt endif do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & k = 1 : this % solution % N + 1 , iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % solution % interior ( i , j , k , iEl , iVar ) = & this % solution % interior ( i , j , k , iEl , iVar ) + & dtLoc * this % dSdt % interior ( i , j , k , iEl , iVar ) enddo endsubroutine UpdateSolution_DGModel3D_t","tags":"","loc":"proc/updatesolution_dgmodel3d_t.html"},{"title":"WriteTecplot_DGModel3D_t – SELF","text":"public subroutine WriteTecplot_DGModel3D_t(this, filename) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: filename Contents Source Code WriteTecplot_DGModel3D_t Source Code subroutine WriteTecplot_DGModel3D_t ( this , filename ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: filename ! Local character ( 8 ) :: zoneID integer :: fUnit integer :: iEl , i , j , k , iVar character ( LEN = self_FileNameLength ) :: tecFile character ( LEN = self_TecplotHeaderLength ) :: tecHeader character ( LEN = self_FormatLength ) :: fmat character ( 13 ) :: timeStampString character ( 5 ) :: rankString type ( Scalar3D ) :: solution type ( Vector3D ) :: solutionGradient type ( Vector3D ) :: x type ( Lagrange ), target :: interp if ( present ( filename )) then tecFile = filename else write ( timeStampString , '(I13.13)' ) this % ioIterate if ( this % mesh % decomp % mpiEnabled ) then write ( rankString , '(I5.5)' ) this % mesh % decomp % rankId tecFile = 'solution.' // rankString // '.' // timeStampString // '.tec' else tecFile = 'solution.' // timeStampString // '.tec' endif endif ! Create an interpolant for the uniform grid call interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) call solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) call solutionGradient % Init ( interp , & this % solution % nVar , this % solution % nElem ) call x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid call this % geometry % x % GridInterp ( x % interior ) call this % solution % UpdateHost () call this % solutionGradient % UpdateHost () ! Map the solution to the target grid call this % solution % GridInterp ( solution % interior ) ! Map the solution to the target grid call this % solutionGradient % GridInterp ( solutionGradient % interior ) open ( UNIT = NEWUNIT ( fUnit ), & FILE = trim ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) tecHeader = 'VARIABLES = \"X\", \"Y\", \"Z\"' do iVar = 1 , this % solution % nVar tecHeader = trim ( tecHeader ) // ', \"' // trim ( this % solution % meta ( iVar )% name ) // '\"' enddo do iVar = 1 , this % solution % nVar tecHeader = trim ( tecHeader ) // ', \"d/dx(' // trim ( this % solution % meta ( iVar )% name ) // ')\"' enddo do iVar = 1 , this % solution % nVar tecHeader = trim ( tecHeader ) // ', \"d/dy(' // trim ( this % solution % meta ( iVar )% name ) // ')\"' enddo write ( fUnit , * ) trim ( tecHeader ) ! Create format statement write ( fmat , * ) 3 * this % solution % nvar + 3 fmat = '(' // trim ( fmat ) // '(ES16.7E3,1x))' do iEl = 1 , this % solution % nElem ! TO DO :: Get the global element ID write ( zoneID , '(I8.8)' ) iEl write ( fUnit , * ) 'ZONE T=\"el' // trim ( zoneID ) // '\", I=' , this % solution % interp % M + 1 , & ', J=' , this % solution % interp % M + 1 do k = 1 , this % solution % interp % M + 1 do j = 1 , this % solution % interp % M + 1 do i = 1 , this % solution % interp % M + 1 write ( fUnit , fmat ) x % interior ( i , j , k , iEl , 1 , 1 ), & x % interior ( i , j , k , iEl , 1 , 2 ), & x % interior ( i , j , k , iEl , 1 , 3 ), & solution % interior ( i , j , k , iEl , 1 : this % solution % nvar ), & solutionGradient % interior ( i , j , k , iEl , 1 : this % solution % nvar , 1 ), & solutionGradient % interior ( i , j , k , iEl , 1 : this % solution % nvar , 2 ), & solutionGradient % interior ( i , j , k , iEl , 1 : this % solution % nvar , 3 ) enddo enddo enddo enddo close ( UNIT = fUnit ) call x % Free () call solution % Free () call interp % Free () endsubroutine WriteTecplot_DGModel3D_t","tags":"","loc":"proc/writetecplot_dgmodel3d_t.html"},{"title":"Write_DGModel3D_t – SELF","text":"public subroutine Write_DGModel3D_t(this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: fileName Contents Source Code Write_DGModel3D_t Source Code subroutine Write_DGModel3D_t ( this , fileName ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this character ( * ), optional , intent ( in ) :: fileName ! Local integer ( HID_T ) :: fileId character ( LEN = self_FileNameLength ) :: pickupFile character ( 13 ) :: timeStampString if ( present ( filename )) then pickupFile = filename else write ( timeStampString , '(I13.13)' ) this % ioIterate pickupFile = 'solution.' // timeStampString // '.h5' endif print * , __ FILE__ // \" : Writing pickup file : \" // trim ( pickupFile ) if ( this % mesh % decomp % mpiEnabled ) then call Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId , this % mesh % decomp % mpiComm ) ! Write the interpolant to the file print * , __ FILE__ // \" : Writing interpolant data to file\" call this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file print * , __ FILE__ // \" : Writing control grid solution to file\" call CreateGroup_HDF5 ( fileId , '/controlgrid' ) call this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' , & this % mesh % decomp % offsetElem ( this % mesh % decomp % rankId + 1 ), this % mesh % decomp % nElem ) ! Write the geometry to file print * , __ FILE__ // \" : Writing control grid geometry to file\" call this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry' , & this % mesh % decomp % offsetElem ( this % mesh % decomp % rankId + 1 ), this % mesh % decomp % nElem ) ! -- END : writing solution on control grid -- ! call Close_HDF5 ( fileId ) else call Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) ! Write the interpolant to the file print * , __ FILE__ // \" : Writing interpolant data to file\" call this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file print * , __ FILE__ // \" : Writing control grid solution to file\" call CreateGroup_HDF5 ( fileId , '/controlgrid' ) call this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' ) ! Write the geometry to file print * , __ FILE__ // \" : Writing control grid geometry to file\" call this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry' ) ! -- END : writing solution on control grid -- ! call Close_HDF5 ( fileId ) endif endsubroutine Write_DGModel3D_t","tags":"","loc":"proc/write_dgmodel3d_t.html"},{"title":"fluxmethod_DGModel3D_t – SELF","text":"public subroutine fluxmethod_DGModel3D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this Contents Source Code fluxmethod_DGModel3D_t Source Code subroutine fluxmethod_DGModel3D_t ( this ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: i , j , k real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 3 ) do iel = 1 , this % mesh % nelem do k = 1 , this % solution % interp % N + 1 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , k , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) this % flux % interior ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) = this % flux3d ( s , dsdx ) enddo enddo enddo enddo endsubroutine fluxmethod_DGModel3D_t","tags":"","loc":"proc/fluxmethod_dgmodel3d_t.html"},{"title":"setboundarycondition_DGModel3D_t – SELF","text":"public subroutine setboundarycondition_DGModel3D_t(this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this Contents Source Code setboundarycondition_DGModel3D_t Source Code subroutine setboundarycondition_DGModel3D_t ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! local integer :: i , iEl , j , k , e2 , bcid real ( prec ) :: nhat ( 1 : 3 ), x ( 1 : 3 ) do iEl = 1 , this % solution % nElem ! Loop over all elements do k = 1 , 6 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , k , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , k , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do j = 1 , this % solution % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points x = this % geometry % x % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solution % extBoundary ( i , j , k , iEl , 1 : this % nvar ) = & this % hbc3d_Prescribed ( x , this % t ) enddo enddo elseif ( bcid == SELF_BC_RADIATION ) then do j = 1 , this % solution % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solution % extBoundary ( i , j , k , iEl , 1 : this % nvar ) = & this % hbc3d_Radiation ( this % solution % boundary ( i , j , k , iEl , 1 : this % nvar ), nhat ) enddo enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do j = 1 , this % solution % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solution % extBoundary ( i , j , k , iEl , 1 : this % nvar ) = & this % hbc3d_NoNormalFlow ( this % solution % boundary ( i , j , k , iEl , 1 : this % nvar ), nhat ) enddo enddo endif endif enddo enddo endsubroutine setboundarycondition_DGModel3D_t","tags":"","loc":"proc/setboundarycondition_dgmodel3d_t.html"},{"title":"setgradientboundarycondition_DGModel3D_t – SELF","text":"public subroutine setgradientboundarycondition_DGModel3D_t(this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this Contents Source Code setgradientboundarycondition_DGModel3D_t Source Code subroutine setgradientboundarycondition_DGModel3D_t ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! local integer :: i , iEl , j , k , e2 , bcid real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ) :: nhat ( 1 : 3 ), x ( 1 : 3 ) do iEl = 1 , this % solution % nElem ! Loop over all elements do k = 1 , 6 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , k , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , k , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do j = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points x = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solutiongradient % extBoundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) = & this % pbc3d_Prescribed ( x , this % t ) enddo enddo elseif ( bcid == SELF_BC_RADIATION ) then do j = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) dsdx = this % solutiongradient % boundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) this % solutiongradient % extBoundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) = & this % pbc3d_Radiation ( dsdx , nhat ) enddo enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do j = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) dsdx = this % solutiongradient % boundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) this % solutiongradient % extBoundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) = & this % pbc3d_NoNormalFlow ( dsdx , nhat ) enddo enddo endif endif enddo enddo endsubroutine setgradientboundarycondition_DGModel3D_t","tags":"","loc":"proc/setgradientboundarycondition_dgmodel3d_t.html"},{"title":"sourcemethod_DGModel3D_t – SELF","text":"public subroutine sourcemethod_DGModel3D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this Contents Source Code sourcemethod_DGModel3D_t Source Code subroutine sourcemethod_DGModel3D_t ( this ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! Local integer :: i , j , k , iel real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 3 ) do iel = 1 , this % mesh % nelem do k = 1 , this % solution % interp % N + 1 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , k , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) this % source % interior ( i , j , k , iel , 1 : this % nvar ) = this % source3d ( s , dsdx ) enddo enddo enddo enddo endsubroutine sourcemethod_DGModel3D_t","tags":"","loc":"proc/sourcemethod_dgmodel3d_t.html"},{"title":"entropy_func_advection_diffusion_2d_t – SELF","text":"public pure function entropy_func_advection_diffusion_2d_t(this, s) result(e) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) Contents Source Code entropy_func_advection_diffusion_2d_t Source Code pure function entropy_func_advection_diffusion_2d_t ( this , s ) result ( e ) class ( advection_diffusion_2d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ) :: e ! Local integer :: ivar e = 0.0_prec do ivar = 1 , this % solution % nvar e = e + 0.5_prec * s ( ivar ) * s ( ivar ) enddo endfunction entropy_func_advection_diffusion_2d_t","tags":"","loc":"proc/entropy_func_advection_diffusion_2d_t.html"},{"title":"flux2d_advection_diffusion_2d_t – SELF","text":"public pure function flux2d_advection_diffusion_2d_t(this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar,1:2) Return Value real(kind=prec)(1:this%solution%nvar,1:2) Contents Source Code flux2d_advection_diffusion_2d_t Source Code pure function flux2d_advection_diffusion_2d_t ( this , s , dsdx ) result ( flux ) class ( advection_diffusion_2d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % solution % nvar , 1 : 2 ) real ( prec ) :: flux ( 1 : this % solution % nvar , 1 : 2 ) ! Local integer :: ivar do ivar = 1 , this % solution % nvar flux ( ivar , 1 ) = this % u * s ( ivar ) - this % nu * dsdx ( ivar , 1 ) ! advective flux + diffusive flux flux ( ivar , 2 ) = this % v * s ( ivar ) - this % nu * dsdx ( ivar , 2 ) ! advective flux + diffusive flux enddo endfunction flux2d_advection_diffusion_2d_t","tags":"","loc":"proc/flux2d_advection_diffusion_2d_t.html"},{"title":"riemannflux2d_advection_diffusion_2d_t – SELF","text":"public pure function riemannflux2d_advection_diffusion_2d_t(this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) Contents Source Code riemannflux2d_advection_diffusion_2d_t Source Code pure function riemannflux2d_advection_diffusion_2d_t ( this , sL , sR , dsdx , nhat ) result ( flux ) class ( advection_diffusion_2d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: sL ( 1 : this % nvar ) real ( prec ), intent ( in ) :: sR ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ), intent ( in ) :: nhat ( 1 : 2 ) real ( prec ) :: flux ( 1 : this % nvar ) ! Local integer :: ivar real ( prec ) :: un , dsdn un = this % u * nhat ( 1 ) + this % v * nhat ( 2 ) do ivar = 1 , this % nvar dsdn = dsdx ( ivar , 1 ) * nhat ( 1 ) + dsdx ( ivar , 2 ) * nhat ( 2 ) flux ( ivar ) = 0.5_prec * ( & ( sL ( ivar ) + sR ( ivar )) + abs ( un ) * ( sL ( ivar ) - sR ( ivar ))) - & ! advective flux this % nu * dsdn enddo endfunction riemannflux2d_advection_diffusion_2d_t","tags":"","loc":"proc/riemannflux2d_advection_diffusion_2d_t.html"},{"title":"AlmostEqual_r64 – SELF","text":"public function AlmostEqual_r64(a, b) result(AisB) \\addtogroup SELF_SupportRoutines\n @{\n \\fn AlmostEqual\n Compares two floating point numbers and determines if they are equal (to machine precision). This function is from Alg. 139 on pg. 359 of D.A. Kopriva, 2009, \"Implementing Spectral Element\n    Methods for Scientists and Engineers\" Usage : Logical :: AisB REAL (prec) :: a, b .... AisB = AlmostEqual( a, b ) Parameters : in a REAL(prec) scalar in b REAL(prec) scalar in AisB Logical .TRUE. IF a=b to machine precision .FALSE. otherwise @} Arguments Type Intent Optional Attributes Name real(kind=real64) :: a real(kind=real64) :: b Return Value logical Contents Source Code AlmostEqual_r64 Source Code function AlmostEqual_r64 ( a , b ) result ( AisB ) implicit none real ( real64 ) :: a , b logical :: AisB if ( a == 0.0_real64 . or . b == 0.0_real64 ) then if ( abs ( a - b ) <= epsilon ( 1.0_real64 )) then AisB = . true . else AisB = . false . endif else if (( abs ( a - b ) <= epsilon ( 1.0_real64 ) * abs ( a )) . or . ( abs ( a - b ) <= epsilon ( 1.0_real64 ) * abs ( b ))) then AisB = . true . else AisB = . false . endif endif endfunction AlmostEqual_r64","tags":"","loc":"proc/almostequal_r64.html"},{"title":"CompareArray – SELF","text":"public function CompareArray(arrayOne, arrayTwo, N) result(arraysMatch) \\addtogroup SELF_SupportRoutines\n @{\n \\fn CompareArray\n Compares to INTEGER arrays and determines if they are identical. A logical is returned that specifies whether or not two arrays are identical. To determine\n if the two arrays are identical, the sum of the difference between each element in the input\n array is calculated. If the arrays are identical, each contribution to the sum is zero and hence\n the sum is zero. If the sum is non-zero, the arrays are distinct. This routine is used in the \\ref HexMeshClass module. A face of an element in an unstructured\n mesh is identified by its four corner nodes. When identifying unique faces in an unstructured\n mesh, we need to determine if two elements share a face. This can be accomplished by comparing\n the four corner nodes (from each element) that define each face. Usage : INTEGER :: N INTEGER :: arrayOne(1:N) INTEGER :: arrayTwo(1:N) LOGICAL :: arraysMatch .... arraysMatch = CompareArray( arrayOne, arrayTwo, N ) Parameters : in arrayOne(1:N) INTEGER in arrayTwo(1:N) INTEGER in N INTEGER out arraysMatch INTEGER @} Arguments Type Intent Optional Attributes Name integer :: arrayOne (1:N) integer :: arrayTwo (1:N) integer :: N Return Value logical Contents Source Code CompareArray Source Code function CompareArray ( arrayOne , arrayTwo , N ) result ( arraysMatch ) implicit none integer :: N integer :: arrayOne ( 1 : N ), arrayTwo ( 1 : N ) logical :: arraysMatch ! LOCAL integer :: i , theSumOfDiffs theSumOfDiffs = 0 do i = 1 , N theSumOfDiffs = theSumOfDiffs + abs ( arrayOne ( i ) - arrayTwo ( i )) enddo if ( theSumOfDiffs == 0 ) then arraysMatch = . true . else arraysMatch = . false . endif endfunction CompareArray","tags":"","loc":"proc/comparearray.html"},{"title":"UniformPoints – SELF","text":"public function UniformPoints(a, b, firstInd, lastInd) result(xU) \\addtogroup SELF_SupportRoutines\n @{\n \\fn UniformPoints\n Generates a REAL(prec) array of N points evenly spaced between two points. Usage : REAL (prec) :: a REAL (prec) :: b REAL (prec) :: xU(0:N) INTEGER :: N .... xU = UniformPoints( a, b, N ) Parameters : in a REAL(prec) Starting point of the interval in b REAL(prec) Ending point of the interval in N INTEGER The number of points in the interval \\f$[a,b]\\f$ in xU(0:N) REAL(prec) Array of evenly spaced points in the interval \\f$[a,b]\\f$ @} Arguments Type Intent Optional Attributes Name real(kind=prec) :: a real(kind=prec) :: b integer :: firstInd integer :: lastInd Return Value real(kind=prec)(firstInd:lastInd) Contents Source Code UniformPoints Source Code function UniformPoints ( a , b , firstInd , lastInd ) result ( xU ) implicit none real ( prec ) :: a , b integer :: firstInd , lastInd real ( prec ) :: xU ( firstInd : lastInd ) ! LOCAL real ( prec ) :: dx integer :: i dx = ( b - a ) / real (( lastInd - firstInd ), prec ) do i = firstInd , lastInd xU ( i ) = a + dx * real ( i - firstInd , prec ) enddo endfunction UniformPoints","tags":"","loc":"proc/uniformpoints.html"},{"title":"UpperCase – SELF","text":"public function UpperCase(str) result(Upper) Arguments Type Intent Optional Attributes Name character, intent(in) :: str Return Value character Contents Source Code UpperCase Source Code function UpperCase ( str ) result ( upper ) implicit none character ( * ), intent ( In ) :: str character ( len ( str )) :: Upper integer :: ic , i character ( 27 ), parameter :: cap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ ' character ( 27 ), parameter :: low = 'abcdefghijklmnopqrstuvwxyz ' do i = 1 , len ( str ) ic = index ( low , str ( i : i )) if ( ic > 0 ) then Upper ( i : i ) = cap ( ic : ic ) else Upper ( i : i ) = str ( i : i ) endif enddo endfunction UpperCase","tags":"","loc":"proc/uppercase.html"},{"title":"newunit – SELF","text":"public function newunit(unit) Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: unit Return Value integer Contents Source Code newunit Source Code integer function newunit ( unit ) !  https://fortranwiki.org/fortran/show/newunit integer , intent ( out ), optional :: unit ! local integer , parameter :: LUN_MIN = 10 , LUN_MAX = 1000 logical :: opened integer :: lun ! begin newunit = - 1 do lun = LUN_MIN , LUN_MAX inquire ( unit = lun , opened = opened ) if (. not . opened ) then newunit = lun exit endif enddo if ( present ( unit )) unit = newunit endfunction newunit","tags":"","loc":"proc/newunit.html"},{"title":"ForwardShift – SELF","text":"public subroutine ForwardShift(myArray, N) \\addtogroup SELF_SupportRoutines\n @{\n \\fn ForwardShift\n Shift an array integers by one index forward, moving the last index to the first. Shifts the array entries as follows : myArray(1) <-- myArray(N) myArray(2) <-- myArray(1) myArray(3) <-- myArray(2) Usage : INTEGER :: N INTEGER :: myArray(1:N) .... CALL ForwardShift( myArray, N ) Parameters : in/out myArray(1:N) INTEGER On output , the input array with elements shifted forward by\n                         one index. in N INTEGER The number of elements in the array @} Arguments Type Intent Optional Attributes Name integer, intent(inout) :: myArray (1:N) integer, intent(in) :: N Contents Source Code ForwardShift Source Code subroutine ForwardShift ( myArray , N ) implicit none integer , intent ( in ) :: N integer , intent ( inout ) :: myArray ( 1 : N ) ! LOCAL integer :: temp ( 1 : N ) temp = myArray myArray ( 1 ) = temp ( N ) myArray ( 2 : N ) = temp ( 1 : N - 1 ) endsubroutine ForwardShift","tags":"","loc":"proc/forwardshift.html"},{"title":"AlmostEqual – SELF","text":"public interface AlmostEqual Contents Module Procedures AlmostEqual_r64 Module Procedures public function AlmostEqual_r64 (a, b) result(AisB) \\addtogroup SELF_SupportRoutines\n @{\n \\fn AlmostEqual\n Compares two floating point numbers and determines if they are equal (to machine precision). Read more… Arguments Type Intent Optional Attributes Name real(kind=real64) :: a real(kind=real64) :: b Return Value logical","tags":"","loc":"interface/almostequal.html"},{"title":"AverageSides_Scalar2D_t – SELF","text":"public subroutine AverageSides_Scalar2D_t(this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this Contents Source Code AverageSides_Scalar2D_t Source Code subroutine AverageSides_Scalar2D_t ( this ) implicit none class ( Scalar2D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: iside integer :: ivar integer :: i do concurrent ( i = 1 : this % interp % N + 1 , iside = 1 : 4 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) this % avgBoundary ( i , iside , iel , ivar ) = 0.5_prec * ( & this % boundary ( i , iside , iel , ivar ) + & this % extBoundary ( i , iside , iel , ivar )) enddo endsubroutine AverageSides_Scalar2D_t","tags":"","loc":"proc/averagesides_scalar2d_t.html"},{"title":"BoundaryInterp_Scalar2D_t – SELF","text":"public subroutine BoundaryInterp_Scalar2D_t(this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this Contents Source Code BoundaryInterp_Scalar2D_t Source Code subroutine BoundaryInterp_Scalar2D_t ( this ) implicit none class ( Scalar2D_t ), intent ( inout ) :: this ! Local integer :: i , ii , iel , ivar real ( prec ) :: fbs , fbe , fbn , fbw do concurrent ( i = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) fbs = 0.0_prec fbe = 0.0_prec fbn = 0.0_prec fbw = 0.0_prec do ii = 1 , this % N + 1 fbs = fbs + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , ii , iel , ivar ) ! South fbe = fbe + this % interp % bMatrix ( ii , 2 ) * this % interior ( ii , i , iel , ivar ) ! East fbn = fbn + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , ii , iel , ivar ) ! North fbw = fbw + this % interp % bMatrix ( ii , 1 ) * this % interior ( ii , i , iel , ivar ) ! West enddo this % boundary ( i , 1 , iel , ivar ) = fbs this % boundary ( i , 2 , iel , ivar ) = fbe this % boundary ( i , 3 , iel , ivar ) = fbn this % boundary ( i , 4 , iel , ivar ) = fbw enddo endsubroutine BoundaryInterp_Scalar2D_t","tags":"","loc":"proc/boundaryinterp_scalar2d_t.html"},{"title":"Free_Scalar2D_t – SELF","text":"public subroutine Free_Scalar2D_t(this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this Contents Source Code Free_Scalar2D_t Source Code subroutine Free_Scalar2D_t ( this ) implicit none class ( Scalar2D_t ), intent ( inout ) :: this this % nVar = 0 this % nElem = 0 this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % boundarynormal ) deallocate ( this % meta ) deallocate ( this % eqn ) endsubroutine Free_Scalar2D_t","tags":"","loc":"proc/free_scalar2d_t.html"},{"title":"Gradient_Scalar2D_t – SELF","text":"public subroutine Gradient_Scalar2D_t(this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) Contents Source Code Gradient_Scalar2D_t Source Code subroutine Gradient_Scalar2D_t ( this , df ) implicit none class ( Scalar2D_t ), intent ( in ) :: this real ( prec ), intent ( inout ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 2 ) ! Local integer :: i , j , ii , iel , ivar real ( prec ) :: df1 , df2 do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) df1 = 0.0_prec df2 = 0.0_prec do ii = 1 , this % N + 1 df1 = df1 + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , iel , ivar ) df2 = df2 + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , iel , ivar ) enddo df ( i , j , iel , ivar , 1 ) = df1 df ( i , j , iel , ivar , 2 ) = df2 enddo endsubroutine Gradient_Scalar2D_t","tags":"","loc":"proc/gradient_scalar2d_t.html"},{"title":"GridInterp_Scalar2D_t – SELF","text":"public subroutine GridInterp_Scalar2D_t(this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) Contents Source Code GridInterp_Scalar2D_t Source Code subroutine GridInterp_Scalar2D_t ( this , f ) implicit none class ( Scalar2D_t ), intent ( in ) :: this real ( prec ), intent ( inout ) :: f ( 1 : this % M + 1 , 1 : this % M + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: i , j , ii , jj , iel , ivar real ( prec ) :: fi , fij do concurrent ( i = 1 : this % M + 1 , j = 1 : this % M + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) fij = 0.0_prec do jj = 1 , this % N + 1 fi = 0.0_prec do ii = 1 , this % N + 1 fi = fi + this % interior ( ii , jj , iel , ivar ) * this % interp % iMatrix ( ii , i ) enddo fij = fij + fi * this % interp % iMatrix ( jj , j ) enddo f ( i , j , iel , ivar ) = fij enddo endsubroutine GridInterp_Scalar2D_t","tags":"","loc":"proc/gridinterp_scalar2d_t.html"},{"title":"Init_Scalar2D_t – SELF","text":"public subroutine Init_Scalar2D_t(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar2D_t Source Code subroutine Init_Scalar2D_t ( this , interp , nVar , nElem ) implicit none class ( Scalar2D_t ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , interp % N + 1 , nelem , nvar ), & this % boundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : 2 * nvar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec this % boundarynormal = 0.0_prec allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) endsubroutine Init_Scalar2D_t","tags":"","loc":"proc/init_scalar2d_t.html"},{"title":"UpdateDevice_Scalar2D_t – SELF","text":"public subroutine UpdateDevice_Scalar2D_t(this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this Contents Source Code UpdateDevice_Scalar2D_t Source Code subroutine UpdateDevice_Scalar2D_t ( this ) implicit none class ( Scalar2D_t ), intent ( inout ) :: this endsubroutine UpdateDevice_Scalar2D_t","tags":"","loc":"proc/updatedevice_scalar2d_t.html"},{"title":"UpdateHost_Scalar2D_t – SELF","text":"public subroutine UpdateHost_Scalar2D_t(this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this Contents Source Code UpdateHost_Scalar2D_t Source Code subroutine UpdateHost_Scalar2D_t ( this ) implicit none class ( Scalar2D_t ), intent ( inout ) :: this endsubroutine UpdateHost_Scalar2D_t","tags":"","loc":"proc/updatehost_scalar2d_t.html"},{"title":"WriteHDF5_MPI_Scalar2D_t – SELF","text":"public subroutine WriteHDF5_MPI_Scalar2D_t(this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem Contents Source Code WriteHDF5_MPI_Scalar2D_t Source Code subroutine WriteHDF5_MPI_Scalar2D_t ( this , fileId , group , elemoffset , nglobalelem ) implicit none class ( Scalar2D_t ), intent ( in ) :: this character ( * ), intent ( in ) :: group integer ( HID_T ), intent ( in ) :: fileId integer , intent ( in ) :: elemoffset integer , intent ( in ) :: nglobalelem ! Local integer ( HID_T ) :: offset ( 1 : 3 ) integer ( HID_T ) :: globalDims ( 1 : 3 ) integer :: ivar offset ( 1 : 3 ) = ( / 0 , 0 , elemoffset / ) globalDims ( 1 : 3 ) = ( / this % interp % N + 1 , & this % interp % N + 1 , & nglobalelem / ) call CreateGroup_HDF5 ( fileId , trim ( group )) do ivar = 1 , this % nVar !call this%meta(ivar)%WriteHDF5(group,ivar,fileId) call WriteArray_HDF5 ( fileId , & trim ( group ) // \"/\" // trim ( this % meta ( ivar )% name ), & this % interior (:,:,:, ivar ), offset , globalDims ) enddo endsubroutine WriteHDF5_MPI_Scalar2D_t","tags":"","loc":"proc/writehdf5_mpi_scalar2d_t.html"},{"title":"WriteHDF5_Scalar2D_t – SELF","text":"public subroutine WriteHDF5_Scalar2D_t(this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Contents Source Code WriteHDF5_Scalar2D_t Source Code subroutine WriteHDF5_Scalar2D_t ( this , fileId , group ) implicit none class ( Scalar2D_t ), intent ( in ) :: this integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: group ! Local integer :: ivar call CreateGroup_HDF5 ( fileId , trim ( group )) do ivar = 1 , this % nVar call this % meta ( ivar )% WriteHDF5 ( group , ivar , fileId ) call WriteArray_HDF5 ( fileId , & trim ( group ) // \"/\" // trim ( this % meta ( ivar )% name ), & this % interior (:,:,:, ivar )) enddo endsubroutine WriteHDF5_Scalar2D_t","tags":"","loc":"proc/writehdf5_scalar2d_t.html"},{"title":"BoundaryFlux_DGModel2D_t – SELF","text":"public subroutine BoundaryFlux_DGModel2D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this Contents Source Code BoundaryFlux_DGModel2D_t Source Code subroutine BoundaryFlux_DGModel2D_t ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: j integer :: i real ( prec ) :: sL ( 1 : this % nvar ), sR ( 1 : this % nvar ) real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ) :: nhat ( 1 : 2 ), nmag do iEl = 1 , this % solution % nElem do j = 1 , 4 do i = 1 , this % solution % interp % N + 1 ! Get the boundary normals on cell edges from the mesh geometry nhat = this % geometry % nHat % boundary ( i , j , iEl , 1 , 1 : 2 ) sL = this % solution % boundary ( i , j , iel , 1 : this % nvar ) ! interior solution sR = this % solution % extboundary ( i , j , iel , 1 : this % nvar ) ! exterior solution dsdx = this % solutiongradient % avgboundary ( i , j , iel , 1 : this % nvar , 1 : 2 ) nmag = this % geometry % nScale % boundary ( i , j , iEl , 1 ) this % flux % boundaryNormal ( i , j , iEl , 1 : this % nvar ) = this % riemannflux2d ( sL , sR , dsdx , nhat ) * nmag enddo enddo enddo endsubroutine BoundaryFlux_DGModel2D_t","tags":"","loc":"proc/boundaryflux_dgmodel2d_t.html"},{"title":"CalculateEntropy_DGModel2D_t – SELF","text":"public subroutine CalculateEntropy_DGModel2D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this Contents Source Code CalculateEntropy_DGModel2D_t Source Code subroutine CalculateEntropy_DGModel2D_t ( this ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! Local integer :: iel , i , j , ierror real ( prec ) :: e , jac real ( prec ) :: s ( 1 : this % nvar ) e = 0.0_prec do iel = 1 , this % geometry % nelem do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 jac = this % geometry % J % interior ( i , j , iel , 1 ) s = this % solution % interior ( i , j , iel , 1 : this % nvar ) e = e + this % entropy_func ( s ) * jac enddo enddo enddo if ( this % mesh % decomp % mpiEnabled ) then call mpi_allreduce ( e , & this % entropy , & 1 , & this % mesh % decomp % mpiPrec , & MPI_SUM , & this % mesh % decomp % mpiComm , & iError ) else this % entropy = e endif endsubroutine CalculateEntropy_DGModel2D_t","tags":"","loc":"proc/calculateentropy_dgmodel2d_t.html"},{"title":"CalculateSolutionGradient_DGModel2D_t – SELF","text":"public subroutine CalculateSolutionGradient_DGModel2D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this Contents Source Code CalculateSolutionGradient_DGModel2D_t Source Code subroutine CalculateSolutionGradient_DGModel2D_t ( this ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this call this % solution % AverageSides () call this % solution % MappedDGGradient ( this % solutionGradient % interior ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp () ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh ) endsubroutine CalculateSolutionGradient_DGModel2D_t","tags":"","loc":"proc/calculatesolutiongradient_dgmodel2d_t.html"},{"title":"CalculateTendency_DGModel2D_t – SELF","text":"public subroutine CalculateTendency_DGModel2D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this Contents Source Code CalculateTendency_DGModel2D_t Source Code subroutine CalculateTendency_DGModel2D_t ( this ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! Local integer :: i , j , iEl , iVar call this % solution % BoundaryInterp () call this % solution % SideExchange ( this % mesh ) call this % PreTendency () ! User-supplied call this % SetBoundaryCondition () ! User-supplied if ( this % gradient_enabled ) then call this % solution % AverageSides () call this % CalculateSolutionGradient () call this % SetGradientBoundaryCondition () ! User-supplied call this % solutionGradient % AverageSides () endif call this % SourceMethod () ! User supplied call this % BoundaryFlux () ! User supplied call this % FluxMethod () ! User supplied call this % flux % MappedDGDivergence ( this % fluxDivergence % interior ) do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % dSdt % interior ( i , j , iEl , iVar ) = & this % source % interior ( i , j , iEl , iVar ) - & this % fluxDivergence % interior ( i , j , iEl , iVar ) enddo endsubroutine CalculateTendency_DGModel2D_t","tags":"","loc":"proc/calculatetendency_dgmodel2d_t.html"},{"title":"Free_DGModel2D_t – SELF","text":"public subroutine Free_DGModel2D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this Contents Source Code Free_DGModel2D_t Source Code subroutine Free_DGModel2D_t ( this ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this call this % solution % Free () call this % workSol % Free () call this % dSdt % Free () call this % solutionGradient % Free () call this % flux % Free () call this % source % Free () call this % fluxDivergence % Free () endsubroutine Free_DGModel2D_t","tags":"","loc":"proc/free_dgmodel2d_t.html"},{"title":"Init_DGModel2D_t – SELF","text":"public subroutine Init_DGModel2D_t(this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), target :: mesh type( SEMQuad ), intent(in), target :: geometry Contents Source Code Init_DGModel2D_t Source Code subroutine Init_DGModel2D_t ( this , nvar , mesh , geometry ) implicit none class ( DGModel2D_t ), intent ( out ) :: this integer , intent ( in ) :: nvar type ( Mesh2D ), intent ( in ), target :: mesh type ( SEMQuad ), intent ( in ), target :: geometry ! Local integer :: ivar character ( LEN = 3 ) :: ivarChar character ( LEN = 25 ) :: varname this % mesh => mesh this % geometry => geometry this % nvar = nvar call this % solution % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % workSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % dSdt % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % solutionGradient % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % flux % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % source % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % fluxDivergence % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % solution % AssociateGeometry ( geometry ) call this % solutionGradient % AssociateGeometry ( geometry ) call this % flux % AssociateGeometry ( geometry ) call this % fluxDivergence % AssociateGeometry ( geometry ) call this % SetMetadata () endsubroutine Init_DGModel2D_t","tags":"","loc":"proc/init_dgmodel2d_t.html"},{"title":"Read_DGModel2D_t – SELF","text":"public subroutine Read_DGModel2D_t(this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: fileName Contents Source Code Read_DGModel2D_t Source Code subroutine Read_DGModel2D_t ( this , fileName ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: fileName ! Local integer ( HID_T ) :: fileId integer ( HID_T ) :: solOffset ( 1 : 3 ) integer :: firstElem integer :: N , ivar if ( this % mesh % decomp % mpiEnabled ) then call Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % mesh % decomp % mpiComm ) else call Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) endif if ( this % mesh % decomp % mpiEnabled ) then firstElem = this % mesh % decomp % offsetElem ( this % mesh % decomp % rankId + 1 ) solOffset ( 1 : 3 ) = ( / 0 , 0 , firstElem / ) do ivar = 1 , this % solution % nvar call ReadArray_HDF5 ( fileId , & '/controlgrid/solution/' // trim ( this % solution % meta ( ivar )% name ), & this % solution % interior (:,:,:, ivar ), solOffset ) enddo else do ivar = 1 , this % solution % nvar call ReadArray_HDF5 ( fileId , & '/controlgrid/solution/' // trim ( this % solution % meta ( ivar )% name ), & this % solution % interior (:,:,:, ivar )) enddo endif call Close_HDF5 ( fileId ) endsubroutine Read_DGModel2D_t","tags":"","loc":"proc/read_dgmodel2d_t.html"},{"title":"SetMetadata_DGModel2D_t – SELF","text":"public subroutine SetMetadata_DGModel2D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this Contents Source Code SetMetadata_DGModel2D_t Source Code subroutine SetMetadata_DGModel2D_t ( this ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! Local integer :: ivar character ( LEN = 3 ) :: ivarChar character ( LEN = 25 ) :: varname do ivar = 1 , this % nvar write ( ivarChar , '(I3.3)' ) ivar varname = \"solution\" // trim ( ivarChar ) call this % solution % SetName ( ivar , varname ) call this % solution % SetUnits ( ivar , \"[null]\" ) enddo endsubroutine SetMetadata_DGModel2D_t","tags":"","loc":"proc/setmetadata_dgmodel2d_t.html"},{"title":"SetSolutionFromChar_DGModel2D_t – SELF","text":"public subroutine SetSolutionFromChar_DGModel2D_t(this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) Contents Source Code SetSolutionFromChar_DGModel2D_t Source Code subroutine SetSolutionFromChar_DGModel2D_t ( this , eqnChar ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: eqnChar ( 1 : this % solution % nVar ) ! Local integer :: iVar do iVar = 1 , this % solution % nVar call this % solution % SetEquation ( ivar , trim ( eqnChar ( iVar ))) enddo call this % solution % SetInteriorFromEquation ( this % geometry , this % t ) call this % solution % BoundaryInterp () endsubroutine SetSolutionFromChar_DGModel2D_t","tags":"","loc":"proc/setsolutionfromchar_dgmodel2d_t.html"},{"title":"SetSolutionFromEqn_DGModel2D_t – SELF","text":"public subroutine SetSolutionFromEqn_DGModel2D_t(this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) Contents Source Code SetSolutionFromEqn_DGModel2D_t Source Code subroutine SetSolutionFromEqn_DGModel2D_t ( this , eqn ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this type ( EquationParser ), intent ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local integer :: iVar ! Copy the equation parser do iVar = 1 , this % solution % nVar call this % solution % SetEquation ( ivar , eqn ( iVar )% equation ) enddo call this % solution % SetInteriorFromEquation ( this % geometry , this % t ) call this % solution % BoundaryInterp () endsubroutine SetSolutionFromEqn_DGModel2D_t","tags":"","loc":"proc/setsolutionfromeqn_dgmodel2d_t.html"},{"title":"UpdateGRK2_DGModel2D_t – SELF","text":"public subroutine UpdateGRK2_DGModel2D_t(this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK2_DGModel2D_t Source Code subroutine UpdateGRK2_DGModel2D_t ( this , m ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , j , iEl , iVar do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , j , iEl , iVar ) = rk2_a ( m ) * & this % workSol % interior ( i , j , iEl , iVar ) + & this % dSdt % interior ( i , j , iEl , iVar ) this % solution % interior ( i , j , iEl , iVar ) = & this % solution % interior ( i , j , iEl , iVar ) + & rk2_g ( m ) * this % dt * this % workSol % interior ( i , j , iEl , iVar ) enddo endsubroutine UpdateGRK2_DGModel2D_t","tags":"","loc":"proc/updategrk2_dgmodel2d_t.html"},{"title":"UpdateGRK3_DGModel2D_t – SELF","text":"public subroutine UpdateGRK3_DGModel2D_t(this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK3_DGModel2D_t Source Code subroutine UpdateGRK3_DGModel2D_t ( this , m ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , j , iEl , iVar do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , j , iEl , iVar ) = rk3_a ( m ) * & this % workSol % interior ( i , j , iEl , iVar ) + & this % dSdt % interior ( i , j , iEl , iVar ) this % solution % interior ( i , j , iEl , iVar ) = & this % solution % interior ( i , j , iEl , iVar ) + & rk3_g ( m ) * this % dt * this % workSol % interior ( i , j , iEl , iVar ) enddo endsubroutine UpdateGRK3_DGModel2D_t","tags":"","loc":"proc/updategrk3_dgmodel2d_t.html"},{"title":"UpdateGRK4_DGModel2D_t – SELF","text":"public subroutine UpdateGRK4_DGModel2D_t(this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK4_DGModel2D_t Source Code subroutine UpdateGRK4_DGModel2D_t ( this , m ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , j , iEl , iVar do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , j , iEl , iVar ) = rk4_a ( m ) * & this % workSol % interior ( i , j , iEl , iVar ) + & this % dSdt % interior ( i , j , iEl , iVar ) this % solution % interior ( i , j , iEl , iVar ) = & this % solution % interior ( i , j , iEl , iVar ) + & rk4_g ( m ) * this % dt * this % workSol % interior ( i , j , iEl , iVar ) enddo endsubroutine UpdateGRK4_DGModel2D_t","tags":"","loc":"proc/updategrk4_dgmodel2d_t.html"},{"title":"UpdateSolution_DGModel2D_t – SELF","text":"public subroutine UpdateSolution_DGModel2D_t(this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt Contents Source Code UpdateSolution_DGModel2D_t Source Code subroutine UpdateSolution_DGModel2D_t ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) implicit none class ( DGModel2D_t ), intent ( inout ) :: this real ( prec ), optional , intent ( in ) :: dt ! Local real ( prec ) :: dtLoc integer :: i , j , iEl , iVar if ( present ( dt )) then dtLoc = dt else dtLoc = this % dt endif do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % solution % interior ( i , j , iEl , iVar ) = & this % solution % interior ( i , j , iEl , iVar ) + & dtLoc * this % dSdt % interior ( i , j , iEl , iVar ) enddo endsubroutine UpdateSolution_DGModel2D_t","tags":"","loc":"proc/updatesolution_dgmodel2d_t.html"},{"title":"WriteTecplot_DGModel2D_t – SELF","text":"public subroutine WriteTecplot_DGModel2D_t(this, filename) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: filename Contents Source Code WriteTecplot_DGModel2D_t Source Code subroutine WriteTecplot_DGModel2D_t ( this , filename ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: filename ! Local character ( 8 ) :: zoneID integer :: fUnit integer :: iEl , i , j , iVar character ( LEN = self_FileNameLength ) :: tecFile character ( LEN = self_TecplotHeaderLength ) :: tecHeader character ( LEN = self_FormatLength ) :: fmat character ( 13 ) :: timeStampString character ( 5 ) :: rankString type ( Scalar2D ) :: solution type ( Scalar2D ) :: dsdt type ( Vector2D ) :: solutionGradient type ( Vector2D ) :: x type ( Lagrange ), target :: interp if ( present ( filename )) then tecFile = filename else write ( timeStampString , '(I13.13)' ) this % ioIterate if ( this % mesh % decomp % mpiEnabled ) then write ( rankString , '(I5.5)' ) this % mesh % decomp % rankId tecFile = 'solution.' // rankString // '.' // timeStampString // '.tec' else tecFile = 'solution.' // timeStampString // '.tec' endif endif ! Create an interpolant for the uniform grid call interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) call solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) call dsdt % Init ( interp , & this % solution % nVar , this % solution % nElem ) call solutionGradient % Init ( interp , & this % solution % nVar , this % solution % nElem ) call x % Init ( interp , 1 , this % solution % nElem ) call this % solution % UpdateHost () call this % solutionGradient % UpdateHost () call this % dsdt % UpdateHost () ! Map the mesh positions to the target grid call this % geometry % x % GridInterp ( x % interior ) ! Map the solution to the target grid call this % solution % GridInterp ( solution % interior ) call this % dsdt % GridInterp ( dsdt % interior ) ! Map the solution to the target grid call this % solutionGradient % GridInterp ( solutionGradient % interior ) open ( UNIT = NEWUNIT ( fUnit ), & FILE = trim ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) tecHeader = 'VARIABLES = \"X\", \"Y\"' do iVar = 1 , this % solution % nVar tecHeader = trim ( tecHeader ) // ', \"' // trim ( this % solution % meta ( iVar )% name ) // '\"' enddo do iVar = 1 , this % solution % nVar tecHeader = trim ( tecHeader ) // ', \"d/dx(' // trim ( this % solution % meta ( iVar )% name ) // ')\"' enddo do iVar = 1 , this % solution % nVar tecHeader = trim ( tecHeader ) // ', \"d/dy(' // trim ( this % solution % meta ( iVar )% name ) // ')\"' enddo do iVar = 1 , this % solution % nVar tecHeader = trim ( tecHeader ) // ', \"d/dt(' // trim ( this % solution % meta ( iVar )% name ) // ')\"' enddo write ( fUnit , * ) trim ( tecHeader ) ! Create format statement write ( fmat , * ) 4 * this % solution % nvar + 2 fmat = '(' // trim ( fmat ) // '(ES16.7E3,1x))' do iEl = 1 , this % solution % nElem ! TO DO :: Get the global element ID write ( zoneID , '(I8.8)' ) iEl write ( fUnit , * ) 'ZONE T=\"el' // trim ( zoneID ) // '\", I=' , this % solution % interp % M + 1 , & ', J=' , this % solution % interp % M + 1 do j = 1 , this % solution % interp % M + 1 do i = 1 , this % solution % interp % M + 1 write ( fUnit , fmat ) x % interior ( i , j , iEl , 1 , 1 ), & x % interior ( i , j , iEl , 1 , 2 ), & solution % interior ( i , j , iEl , 1 : this % solution % nvar ), & solutionGradient % interior ( i , j , iEl , 1 : this % solution % nvar , 1 ), & solutionGradient % interior ( i , j , iEl , 1 : this % solution % nvar , 2 ), & dsdt % interior ( i , j , iEl , 1 : this % solution % nvar ) enddo enddo enddo close ( UNIT = fUnit ) call x % Free () call solution % Free () call dsdt % Free () call interp % Free () endsubroutine WriteTecplot_DGModel2D_t","tags":"","loc":"proc/writetecplot_dgmodel2d_t.html"},{"title":"Write_DGModel2D_t – SELF","text":"public subroutine Write_DGModel2D_t(this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: fileName Contents Source Code Write_DGModel2D_t Source Code subroutine Write_DGModel2D_t ( this , fileName ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this character ( * ), optional , intent ( in ) :: fileName ! Local integer ( HID_T ) :: fileId character ( LEN = self_FileNameLength ) :: pickupFile character ( 13 ) :: timeStampString if ( present ( filename )) then pickupFile = filename else write ( timeStampString , '(I13.13)' ) this % ioIterate pickupFile = 'solution.' // timeStampString // '.h5' endif print * , __ FILE__ // \" : Writing pickup file : \" // trim ( pickupFile ) call this % solution % UpdateHost () if ( this % mesh % decomp % mpiEnabled ) then call Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId , this % mesh % decomp % mpiComm ) ! Write the interpolant to the file print * , __ FILE__ // \" : Writing interpolant data to file\" call this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file print * , __ FILE__ // \" : Writing control grid solution to file\" call CreateGroup_HDF5 ( fileId , '/controlgrid' ) print * , \" offset, nglobal_elem : \" , this % mesh % decomp % offsetElem ( this % mesh % decomp % rankId + 1 ), this % mesh % decomp % nElem call this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' , & this % mesh % decomp % offsetElem ( this % mesh % decomp % rankId + 1 ), this % mesh % decomp % nElem ) ! Write the geometry to file print * , __ FILE__ // \" : Writing control grid geometry to file\" call this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry' , & this % mesh % decomp % offsetElem ( this % mesh % decomp % rankId + 1 ), this % mesh % decomp % nElem ) ! -- END : writing solution on control grid -- ! call Close_HDF5 ( fileId ) else call Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) ! Write the interpolant to the file print * , __ FILE__ // \" : Writing interpolant data to file\" call this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file print * , __ FILE__ // \" : Writing control grid solution to file\" call CreateGroup_HDF5 ( fileId , '/controlgrid' ) call this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' ) ! Write the geometry to file print * , __ FILE__ // \" : Writing control grid geometry to file\" call this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry' ) ! -- END : writing solution on control grid -- ! call Close_HDF5 ( fileId ) endif endsubroutine Write_DGModel2D_t","tags":"","loc":"proc/write_dgmodel2d_t.html"},{"title":"fluxmethod_DGModel2D_t – SELF","text":"public subroutine fluxmethod_DGModel2D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this Contents Source Code fluxmethod_DGModel2D_t Source Code subroutine fluxmethod_DGModel2D_t ( this ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: i integer :: j real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 2 ) do iel = 1 , this % mesh % nelem do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , iel , 1 : this % nvar , 1 : 2 ) this % flux % interior ( i , j , iel , 1 : this % nvar , 1 : 2 ) = this % flux2d ( s , dsdx ) enddo enddo enddo endsubroutine fluxmethod_DGModel2D_t","tags":"","loc":"proc/fluxmethod_dgmodel2d_t.html"},{"title":"setboundarycondition_DGModel2D_t – SELF","text":"public subroutine setboundarycondition_DGModel2D_t(this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this Contents Source Code setboundarycondition_DGModel2D_t Source Code subroutine setboundarycondition_DGModel2D_t ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! local integer :: i , iEl , j , e2 , bcid real ( prec ) :: nhat ( 1 : 2 ), x ( 1 : 2 ) do iEl = 1 , this % solution % nElem ! Loop over all elements do j = 1 , 4 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , j , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , j , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points x = this % geometry % x % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solution % extBoundary ( i , j , iEl , 1 : this % nvar ) = & this % hbc2d_Prescribed ( x , this % t ) enddo elseif ( bcid == SELF_BC_RADIATION ) then do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solution % extBoundary ( i , j , iEl , 1 : this % nvar ) = & this % hbc2d_Radiation ( this % solution % boundary ( i , j , iEl , 1 : this % nvar ), nhat ) enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solution % extBoundary ( i , j , iEl , 1 : this % nvar ) = & this % hbc2d_NoNormalFlow ( this % solution % boundary ( i , j , iEl , 1 : this % nvar ), nhat ) enddo endif endif enddo enddo endsubroutine setboundarycondition_DGModel2D_t","tags":"","loc":"proc/setboundarycondition_dgmodel2d_t.html"},{"title":"setgradientboundarycondition_DGModel2D_t – SELF","text":"public subroutine setgradientboundarycondition_DGModel2D_t(this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this Contents Source Code setgradientboundarycondition_DGModel2D_t Source Code subroutine setgradientboundarycondition_DGModel2D_t ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! local integer :: i , iEl , j , e2 , bcid real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ) :: nhat ( 1 : 2 ), x ( 1 : 2 ) do iEl = 1 , this % solution % nElem ! Loop over all elements do j = 1 , 4 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , j , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , j , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points x = this % geometry % x % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solutiongradient % extBoundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) = & this % pbc2d_Prescribed ( x , this % t ) enddo elseif ( bcid == SELF_BC_RADIATION ) then do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) dsdx = this % solutiongradient % boundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) this % solutiongradient % extBoundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) = & this % pbc2d_Radiation ( dsdx , nhat ) enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) dsdx = this % solutiongradient % boundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) this % solutiongradient % extBoundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) = & this % pbc2d_NoNormalFlow ( dsdx , nhat ) enddo endif endif enddo enddo endsubroutine setgradientboundarycondition_DGModel2D_t","tags":"","loc":"proc/setgradientboundarycondition_dgmodel2d_t.html"},{"title":"sourcemethod_DGModel2D_t – SELF","text":"public subroutine sourcemethod_DGModel2D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this Contents Source Code sourcemethod_DGModel2D_t Source Code subroutine sourcemethod_DGModel2D_t ( this ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: i integer :: j real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 2 ) do iel = 1 , this % mesh % nelem do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , iel , 1 : this % nvar , 1 : 2 ) this % source % interior ( i , j , iel , 1 : this % nvar ) = this % source2d ( s , dsdx ) enddo enddo enddo endsubroutine sourcemethod_DGModel2D_t","tags":"","loc":"proc/sourcemethod_dgmodel2d_t.html"},{"title":"AssociateGeometry_MappedScalar1D_t – SELF","text":"public subroutine AssociateGeometry_MappedScalar1D_t(this, geometry) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this type( Geometry1D ), intent(in), target :: geometry Contents Source Code AssociateGeometry_MappedScalar1D_t Source Code subroutine AssociateGeometry_MappedScalar1D_t ( this , geometry ) implicit none class ( MappedScalar1D_t ), intent ( inout ) :: this type ( Geometry1D ), target , intent ( in ) :: geometry if (. not . associated ( this % geometry )) then this % geometry => geometry this % geometry_associated = . true . endif endsubroutine AssociateGeometry_MappedScalar1D_t","tags":"","loc":"proc/associategeometry_mappedscalar1d_t.html"},{"title":"DissociateGeometry_MappedScalar1D_t – SELF","text":"public subroutine DissociateGeometry_MappedScalar1D_t(this) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this Contents Source Code DissociateGeometry_MappedScalar1D_t Source Code subroutine DissociateGeometry_MappedScalar1D_t ( this ) implicit none class ( MappedScalar1D_t ), intent ( inout ) :: this if ( associated ( this % geometry )) then this % geometry => null () this % geometry_associated = . false . endif endsubroutine DissociateGeometry_MappedScalar1D_t","tags":"","loc":"proc/dissociategeometry_mappedscalar1d_t.html"},{"title":"MappedDGDerivative_MappedScalar1D_t – SELF","text":"public subroutine MappedDGDerivative_MappedScalar1D_t(this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%nelem,1:this%nvar) Contents Source Code MappedDGDerivative_MappedScalar1D_t Source Code subroutine MappedDGDerivative_MappedScalar1D_t ( this , dF ) implicit none class ( MappedScalar1D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , ii real ( prec ) :: dfloc do concurrent ( i = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfloc = 0.0_prec do ii = 1 , this % N + 1 dfloc = dfloc + this % interp % dgMatrix ( ii , i ) * this % interior ( ii , iel , ivar ) enddo dfloc = dfloc + ( this % boundarynormal ( 2 , iel , ivar ) * this % interp % bMatrix ( i , 2 ) + & this % boundarynormal ( 1 , iel , ivar ) * this % interp % bMatrix ( i , 1 )) / & this % interp % qWeights ( i ) df ( i , iel , ivar ) = dfloc / this % geometry % dxds % interior ( i , iEl , 1 ) enddo endsubroutine MappedDGDerivative_MappedScalar1D_t","tags":"","loc":"proc/mappeddgderivative_mappedscalar1d_t.html"},{"title":"MappedDerivative_MappedScalar1D_t – SELF","text":"public subroutine MappedDerivative_MappedScalar1D_t(this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%nelem,1:this%nvar) Contents Source Code MappedDerivative_MappedScalar1D_t Source Code subroutine MappedDerivative_MappedScalar1D_t ( this , dF ) implicit none class ( MappedScalar1D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , ii real ( prec ) :: dfloc do concurrent ( i = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfloc = 0.0_prec do ii = 1 , this % N + 1 dfloc = dfloc + this % interp % dMatrix ( ii , i ) * this % interior ( ii , iel , ivar ) enddo df ( i , iel , ivar ) = dfloc / this % geometry % dxds % interior ( i , iEl , 1 ) enddo endsubroutine MappedDerivative_MappedScalar1D_t","tags":"","loc":"proc/mappedderivative_mappedscalar1d_t.html"},{"title":"SetInteriorFromEquation_MappedScalar1D_t – SELF","text":"public subroutine SetInteriorFromEquation_MappedScalar1D_t(this, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this real(kind=prec), intent(in) :: time Contents Source Code SetInteriorFromEquation_MappedScalar1D_t Source Code subroutine SetInteriorFromEquation_MappedScalar1D_t ( this , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedScalar1D_t ), intent ( inout ) :: this real ( prec ), intent ( in ) :: time ! Local integer :: iVar do ivar = 1 , this % nvar this % interior (:,:, ivar ) = this % eqn ( ivar )% evaluate ( this % geometry % x % interior ) enddo endsubroutine SetInteriorFromEquation_MappedScalar1D_t","tags":"","loc":"proc/setinteriorfromequation_mappedscalar1d_t.html"},{"title":"SideExchange_MappedScalar1D_t – SELF","text":"public subroutine SideExchange_MappedScalar1D_t(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this type( Mesh1D ), intent(inout) :: mesh Contents Source Code SideExchange_MappedScalar1D_t Source Code subroutine SideExchange_MappedScalar1D_t ( this , mesh ) implicit none class ( MappedScalar1D_t ), intent ( inout ) :: this type ( Mesh1D ), intent ( inout ) :: mesh ! Local integer :: e1 , e2 , s1 , s2 integer :: ivar do concurrent ( e1 = 1 : mesh % nElem , ivar = 1 : this % nvar ) if ( e1 == 1 ) then s1 = 2 e2 = e1 + 1 s2 = 1 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) elseif ( e1 == mesh % nElem ) then s1 = 1 e2 = e1 - 1 s2 = 2 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) else s1 = 1 e2 = e1 - 1 s2 = 2 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) s1 = 2 e2 = e1 + 1 s2 = 1 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) endif enddo endsubroutine SideExchange_MappedScalar1D_t","tags":"","loc":"proc/sideexchange_mappedscalar1d_t.html"},{"title":"CalculateMetricTerms_Geometry1D – SELF","text":"public subroutine CalculateMetricTerms_Geometry1D(myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Contents Source Code CalculateMetricTerms_Geometry1D Source Code subroutine CalculateMetricTerms_Geometry1D ( myGeom ) implicit none class ( Geometry1D ), intent ( inout ) :: myGeom call myGeom % x % Derivative ( myGeom % dxds % interior ) call myGeom % dxds % UpdateDevice () call myGeom % dxds % BoundaryInterp () endsubroutine CalculateMetricTerms_Geometry1D","tags":"","loc":"proc/calculatemetricterms_geometry1d.html"},{"title":"Free_Geometry1D – SELF","text":"public subroutine Free_Geometry1D(myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Contents Source Code Free_Geometry1D Source Code subroutine Free_Geometry1D ( myGeom ) implicit none class ( Geometry1D ), intent ( inout ) :: myGeom call myGeom % x % Free () call myGeom % dxds % Free () endsubroutine Free_Geometry1D","tags":"","loc":"proc/free_geometry1d.html"},{"title":"GenerateFromMesh_Geometry1D – SELF","text":"public subroutine GenerateFromMesh_Geometry1D(myGeom, mesh) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom type( Mesh1D ), intent(in) :: mesh Contents Source Code GenerateFromMesh_Geometry1D Source Code subroutine GenerateFromMesh_Geometry1D ( myGeom , mesh ) ! Generates the geometry for a 1-D mesh ( set of line segments ) ! Assumes that mesh is using Gauss-Lobatto quadrature and the degree is given by mesh % nGeo implicit none class ( Geometry1D ), intent ( inout ) :: myGeom type ( Mesh1D ), intent ( in ) :: mesh ! Local integer :: iel , i , nid type ( Lagrange ), target :: meshToModel type ( Scalar1D ) :: xMesh call meshToModel % Init ( mesh % nGeo , mesh % quadrature , & myGeom % x % interp % N , & myGeom % x % interp % controlNodeType ) call xMesh % Init ( meshToModel , & 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 do iel = 1 , mesh % nElem do i = 1 , mesh % nGeo + 1 xMesh % interior ( i , iel , 1 ) = mesh % nodeCoords ( nid ) nid = nid + 1 enddo enddo ! Interpolate from the mesh hopr_nodeCoords to the geometry (Possibly not gauss_lobatto quadrature) call xMesh % GridInterp ( myGeom % x % interior ) call myGeom % x % UpdateDevice () call myGeom % x % BoundaryInterp () call myGeom % CalculateMetricTerms () call xMesh % Free () call meshToModel % Free () endsubroutine GenerateFromMesh_Geometry1D","tags":"","loc":"proc/generatefrommesh_geometry1d.html"},{"title":"Init_Geometry1D – SELF","text":"public subroutine Init_Geometry1D(myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom type( Lagrange ), intent(in), pointer :: interp integer, intent(in) :: nElem Contents Source Code Init_Geometry1D Source Code subroutine Init_Geometry1D ( myGeom , interp , nElem ) implicit none class ( Geometry1D ), intent ( out ) :: myGeom type ( Lagrange ), pointer , intent ( in ) :: interp integer , intent ( in ) :: nElem myGeom % nElem = nElem call myGeom % x % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % dxds % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) endsubroutine Init_Geometry1D","tags":"","loc":"proc/init_geometry1d.html"},{"title":"Write_Geometry1D – SELF","text":"public subroutine Write_Geometry1D(myGeom, fileName) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(in) :: myGeom character, intent(in), optional :: fileName Contents Source Code Write_Geometry1D Source Code subroutine Write_Geometry1D ( myGeom , fileName ) implicit none class ( Geometry1D ), intent ( in ) :: myGeom character ( * ), optional , intent ( in ) :: fileName ! Local integer ( HID_T ) :: fileId ! Local character ( LEN = self_FileNameLength ) :: pickupFile if ( present ( filename )) then pickupFile = filename else pickupFile = 'mesh.h5' endif call Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) call CreateGroup_HDF5 ( fileId , '/quadrature' ) call WriteArray_HDF5 ( fileId , '/quadrature/xi' , & myGeom % x % interp % controlPoints ) call WriteArray_HDF5 ( fileId , '/quadrature/weights' , & myGeom % x % interp % qWeights ) call WriteArray_HDF5 ( fileId , '/quadrature/dgmatrix' , & myGeom % x % interp % dgMatrix ) call WriteArray_HDF5 ( fileId , '/quadrature/dmatrix' , & myGeom % x % interp % dMatrix ) call CreateGroup_HDF5 ( fileId , '/mesh' ) call CreateGroup_HDF5 ( fileId , '/mesh/interior' ) call CreateGroup_HDF5 ( fileId , '/mesh/boundary' ) call WriteArray_HDF5 ( fileId , '/mesh/interior/x' , myGeom % x % interior ) call WriteArray_HDF5 ( fileId , '/mesh/interior/dxds' , myGeom % dxds % interior ) call WriteArray_HDF5 ( fileId , '/mesh/boundary/x' , myGeom % x % boundary ) call WriteArray_HDF5 ( fileId , '/mesh/boundary/dxds' , myGeom % dxds % boundary ) call Close_HDF5 ( fileId ) endsubroutine Write_Geometry1D","tags":"","loc":"proc/write_geometry1d.html"},{"title":"entropy_func_Model – SELF","text":"public pure function entropy_func_Model(this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) Contents Source Code entropy_func_Model Source Code pure function entropy_func_Model ( this , s ) result ( e ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ) :: e e = 0.0_prec endfunction entropy_func_Model","tags":"","loc":"proc/entropy_func_model.html"},{"title":"flux1d_Model – SELF","text":"public pure function flux1d_Model(this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) Contents Source Code flux1d_Model Source Code pure function flux1d_Model ( this , s , dsdx ) result ( flux ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar ) real ( prec ) :: flux ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar flux ( ivar ) = 0.0_prec enddo endfunction flux1d_Model","tags":"","loc":"proc/flux1d_model.html"},{"title":"flux2d_Model – SELF","text":"public pure function flux2d_Model(this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) Contents Source Code flux2d_Model Source Code pure function flux2d_Model ( this , s , dsdx ) result ( flux ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ) :: flux ( 1 : this % nvar , 1 : 2 ) ! Local integer :: ivar do ivar = 1 , this % nvar flux ( ivar , 1 : 2 ) = 0.0_prec enddo endfunction flux2d_Model","tags":"","loc":"proc/flux2d_model.html"},{"title":"flux3d_Model – SELF","text":"public pure function flux3d_Model(this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) Contents Source Code flux3d_Model Source Code pure function flux3d_Model ( this , s , dsdx ) result ( flux ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ) :: flux ( 1 : this % nvar , 1 : 3 ) ! Local integer :: ivar do ivar = 1 , this % nvar flux ( ivar , 1 : 3 ) = 0.0_prec enddo endfunction flux3d_Model","tags":"","loc":"proc/flux3d_model.html"},{"title":"hbc1d_Generic_Model – SELF","text":"public pure function hbc1d_Generic_Model(this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) Contents Source Code hbc1d_Generic_Model Source Code pure function hbc1d_Generic_Model ( this , s , nhat ) result ( exts ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: nhat real ( prec ) :: exts ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar exts ( ivar ) = 0.0_prec enddo endfunction hbc1d_Generic_Model","tags":"","loc":"proc/hbc1d_generic_model.html"},{"title":"hbc1d_Prescribed_Model – SELF","text":"public pure function hbc1d_Prescribed_Model(this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) Contents Source Code hbc1d_Prescribed_Model Source Code pure function hbc1d_Prescribed_Model ( this , x , t ) result ( exts ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: x real ( prec ), intent ( in ) :: t real ( prec ) :: exts ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar exts ( ivar ) = 0.0_prec enddo endfunction hbc1d_Prescribed_Model","tags":"","loc":"proc/hbc1d_prescribed_model.html"},{"title":"hbc2d_Generic_Model – SELF","text":"public pure function hbc2d_Generic_Model(this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) Contents Source Code hbc2d_Generic_Model Source Code pure function hbc2d_Generic_Model ( this , s , nhat ) result ( exts ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: nhat ( 1 : 2 ) real ( prec ) :: exts ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar exts ( ivar ) = 0.0_prec enddo endfunction hbc2d_Generic_Model","tags":"","loc":"proc/hbc2d_generic_model.html"},{"title":"hbc2d_Prescribed_Model – SELF","text":"public pure function hbc2d_Prescribed_Model(this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) Contents Source Code hbc2d_Prescribed_Model Source Code pure function hbc2d_Prescribed_Model ( this , x , t ) result ( exts ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: x ( 1 : 2 ) real ( prec ), intent ( in ) :: t real ( prec ) :: exts ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar exts ( ivar ) = 0.0_prec enddo endfunction hbc2d_Prescribed_Model","tags":"","loc":"proc/hbc2d_prescribed_model.html"},{"title":"hbc3d_Generic_Model – SELF","text":"public pure function hbc3d_Generic_Model(this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) Contents Source Code hbc3d_Generic_Model Source Code pure function hbc3d_Generic_Model ( this , s , nhat ) result ( exts ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: nhat ( 1 : 3 ) real ( prec ) :: exts ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar exts ( ivar ) = 0.0_prec enddo endfunction hbc3d_Generic_Model","tags":"","loc":"proc/hbc3d_generic_model.html"},{"title":"hbc3d_Prescribed_Model – SELF","text":"public pure function hbc3d_Prescribed_Model(this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) Contents Source Code hbc3d_Prescribed_Model Source Code pure function hbc3d_Prescribed_Model ( this , x , t ) result ( exts ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: x ( 1 : 3 ) real ( prec ), intent ( in ) :: t real ( prec ) :: exts ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar exts ( ivar ) = 0.0_prec enddo endfunction hbc3d_Prescribed_Model","tags":"","loc":"proc/hbc3d_prescribed_model.html"},{"title":"pbc1d_Generic_Model – SELF","text":"public pure function pbc1d_Generic_Model(this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) Contents Source Code pbc1d_Generic_Model Source Code pure function pbc1d_Generic_Model ( this , dsdx , nhat ) result ( extDsdx ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar ) real ( prec ), intent ( in ) :: nhat real ( prec ) :: extDsdx ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar extDsdx ( ivar ) = dsdx ( ivar ) enddo endfunction pbc1d_Generic_Model","tags":"","loc":"proc/pbc1d_generic_model.html"},{"title":"pbc1d_Prescribed_Model – SELF","text":"public pure function pbc1d_Prescribed_Model(this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) Contents Source Code pbc1d_Prescribed_Model Source Code pure function pbc1d_Prescribed_Model ( this , x , t ) result ( extDsdx ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: x real ( prec ), intent ( in ) :: t real ( prec ) :: extDsdx ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar extDsdx ( ivar ) = 0.0_prec enddo endfunction pbc1d_Prescribed_Model","tags":"","loc":"proc/pbc1d_prescribed_model.html"},{"title":"pbc2d_Generic_Model – SELF","text":"public pure function pbc2d_Generic_Model(this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) Contents Source Code pbc2d_Generic_Model Source Code pure function pbc2d_Generic_Model ( this , dsdx , nhat ) result ( extDsdx ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ), intent ( in ) :: nhat ( 1 : 2 ) real ( prec ) :: extDsdx ( 1 : this % nvar , 1 : 2 ) ! Local integer :: ivar do ivar = 1 , this % nvar extDsdx ( ivar , 1 : 2 ) = dsdx ( ivar , 1 : 2 ) enddo endfunction pbc2d_Generic_Model","tags":"","loc":"proc/pbc2d_generic_model.html"},{"title":"pbc2d_Prescribed_Model – SELF","text":"public pure function pbc2d_Prescribed_Model(this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) Contents Source Code pbc2d_Prescribed_Model Source Code pure function pbc2d_Prescribed_Model ( this , x , t ) result ( extDsdx ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: x ( 1 : 2 ) real ( prec ), intent ( in ) :: t real ( prec ) :: extDsdx ( 1 : this % nvar , 1 : 2 ) ! Local integer :: ivar do ivar = 1 , this % nvar extDsdx ( ivar , 1 : 2 ) = 0.0_prec enddo endfunction pbc2d_Prescribed_Model","tags":"","loc":"proc/pbc2d_prescribed_model.html"},{"title":"pbc3d_Generic_Model – SELF","text":"public pure function pbc3d_Generic_Model(this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) Contents Source Code pbc3d_Generic_Model Source Code pure function pbc3d_Generic_Model ( this , dsdx , nhat ) result ( extDsdx ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ), intent ( in ) :: nhat ( 1 : 3 ) real ( prec ) :: extDsdx ( 1 : this % nvar , 1 : 3 ) ! Local integer :: ivar do ivar = 1 , this % nvar extDsdx ( ivar , 1 : 3 ) = dsdx ( ivar , 1 : 3 ) enddo endfunction pbc3d_Generic_Model","tags":"","loc":"proc/pbc3d_generic_model.html"},{"title":"pbc3d_Prescribed_Model – SELF","text":"public pure function pbc3d_Prescribed_Model(this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) Contents Source Code pbc3d_Prescribed_Model Source Code pure function pbc3d_Prescribed_Model ( this , x , t ) result ( extDsdx ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: x ( 1 : 3 ) real ( prec ), intent ( in ) :: t real ( prec ) :: extDsdx ( 1 : this % nvar , 1 : 3 ) ! Local integer :: ivar do ivar = 1 , this % nvar extDsdx ( ivar , 1 : 3 ) = 0.0_prec enddo endfunction pbc3d_Prescribed_Model","tags":"","loc":"proc/pbc3d_prescribed_model.html"},{"title":"riemannflux1d_Model – SELF","text":"public pure function riemannflux1d_Model(this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) Contents Source Code riemannflux1d_Model Source Code pure function riemannflux1d_Model ( this , sL , sR , dsdx , nhat ) result ( flux ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: sL ( 1 : this % nvar ) real ( prec ), intent ( in ) :: sR ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar ) real ( prec ), intent ( in ) :: nhat real ( prec ) :: flux ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar flux ( ivar ) = 0.0_prec enddo endfunction riemannflux1d_Model","tags":"","loc":"proc/riemannflux1d_model.html"},{"title":"riemannflux2d_Model – SELF","text":"public pure function riemannflux2d_Model(this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) Contents Source Code riemannflux2d_Model Source Code pure function riemannflux2d_Model ( this , sL , sR , dsdx , nhat ) result ( flux ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: sL ( 1 : this % nvar ) real ( prec ), intent ( in ) :: sR ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ), intent ( in ) :: nhat ( 1 : 2 ) real ( prec ) :: flux ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar flux ( ivar ) = 0.0_prec enddo endfunction riemannflux2d_Model","tags":"","loc":"proc/riemannflux2d_model.html"},{"title":"riemannflux3d_Model – SELF","text":"public pure function riemannflux3d_Model(this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) Contents Source Code riemannflux3d_Model Source Code pure function riemannflux3d_Model ( this , sL , sR , dsdx , nhat ) result ( flux ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: sL ( 1 : this % nvar ) real ( prec ), intent ( in ) :: sR ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ), intent ( in ) :: nhat ( 1 : 3 ) real ( prec ) :: flux ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar flux ( ivar ) = 0.0_prec enddo endfunction riemannflux3d_Model","tags":"","loc":"proc/riemannflux3d_model.html"},{"title":"source1d_Model – SELF","text":"public pure function source1d_Model(this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) Contents Source Code source1d_Model Source Code pure function source1d_Model ( this , s , dsdx ) result ( source ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar ) real ( prec ) :: source ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar source ( ivar ) = 0.0_prec enddo endfunction source1d_Model","tags":"","loc":"proc/source1d_model.html"},{"title":"source2d_Model – SELF","text":"public pure function source2d_Model(this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) Contents Source Code source2d_Model Source Code pure function source2d_Model ( this , s , dsdx ) result ( source ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ) :: source ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar source ( ivar ) = 0.0_prec enddo endfunction source2d_Model","tags":"","loc":"proc/source2d_model.html"},{"title":"source3d_Model – SELF","text":"public pure function source3d_Model(this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Contents Source Code source3d_Model Source Code pure function source3d_Model ( this , s , dsdx ) result ( source ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ) :: source ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar source ( ivar ) = 0.0_prec enddo endfunction source3d_Model","tags":"","loc":"proc/source3d_model.html"},{"title":"CalculateEntropy_Model – SELF","text":"public subroutine CalculateEntropy_Model(this) Base method for calculating entropy of a model\nWhen this method is not overridden, the entropy\nis simply set to 0.0. When you develop a model\nbuilt on top of this abstract class or one of its\nchildren, it is recommended that you define a\nconvex mathematical entropy function that is used\nas a measure of the model stability. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this Contents Source Code CalculateEntropy_Model Source Code subroutine CalculateEntropy_Model ( this ) !! Base method for calculating entropy of a model !! When this method is not overridden, the entropy !! is simply set to 0.0. When you develop a model !! built on top of this abstract class or one of its !! children, it is recommended that you define a !! convex mathematical entropy function that is used !! as a measure of the model stability. implicit none class ( Model ), intent ( inout ) :: this this % entropy = 0.0_prec endsubroutine CalculateEntropy_Model","tags":"","loc":"proc/calculateentropy_model.html"},{"title":"Euler_timeIntegrator – SELF","text":"public subroutine Euler_timeIntegrator(this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn Contents Source Code Euler_timeIntegrator Source Code subroutine Euler_timeIntegrator ( this , tn ) implicit none class ( Model ), intent ( inout ) :: this real ( prec ), intent ( in ) :: tn ! Local real ( prec ) :: tRemain real ( prec ) :: dtLim dtLim = this % dt ! Get the max time step size from the dt attribute do while ( this % t < tn ) tRemain = tn - this % t this % dt = min ( dtLim , tRemain ) call this % CalculateTendency () call this % UpdateSolution () this % t = this % t + this % dt enddo this % dt = dtLim endsubroutine Euler_timeIntegrator","tags":"","loc":"proc/euler_timeintegrator.html"},{"title":"ForwardStep_Model – SELF","text":"public subroutine ForwardStep_Model(this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator If the final time  is provided, the model is forward stepped to that final time,\n otherwise, the model is forward stepped only a single time step If a time step is provided through the interface, the model time step size is updated\n and that time step is used to update the model If ioInterval is provided, file IO will be conducted every ioInterval seconds until tn\nis reached Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval Contents Source Code ForwardStep_Model Source Code subroutine ForwardStep_Model ( this , tn , dt , ioInterval ) !!  Forward steps the model using the associated tendency procedure and time integrator !! !!  If the final time  is provided, the model is forward stepped to that final time, !!  otherwise, the model is forward stepped only a single time step !! !!  If a time step is provided through the interface, the model time step size is updated !!  and that time step is used to update the model !! !! If ioInterval is provided, file IO will be conducted every ioInterval seconds until tn !! is reached implicit none class ( Model ), intent ( inout ) :: this real ( prec ), intent ( in ) :: tn real ( prec ), intent ( in ) :: dt real ( prec ), intent ( in ) :: ioInterval ! Local real ( prec ) :: targetTime , tNext integer :: i , nIO this % dt = dt targetTime = tn nIO = int (( targetTime - this % t ) / ioInterval ) do i = 1 , nIO tNext = this % t + ioInterval call this % timeIntegrator ( tNext ) this % t = tNext call this % WriteModel () call this % WriteTecplot () call this % IncrementIOCounter () call this % CalculateEntropy () call this % ReportEntropy () enddo endsubroutine ForwardStep_Model","tags":"","loc":"proc/forwardstep_model.html"},{"title":"GetSimulationTime – SELF","text":"public subroutine GetSimulationTime(this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t Contents Source Code GetSimulationTime Source Code subroutine GetSimulationTime ( this , t ) !! Returns the current simulation time stored in the model % t attribute implicit none class ( Model ), intent ( in ) :: this real ( prec ), intent ( out ) :: t t = this % t endsubroutine GetSimulationTime","tags":"","loc":"proc/getsimulationtime.html"},{"title":"IncrementIOCounter – SELF","text":"public subroutine IncrementIOCounter(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this Contents Source Code IncrementIOCounter Source Code subroutine IncrementIOCounter ( this ) implicit none class ( Model ), intent ( inout ) :: this ! Increment the ioIterate this % ioIterate = this % ioIterate + 1 endsubroutine IncrementIOCounter","tags":"","loc":"proc/incrementiocounter.html"},{"title":"LowStorageRK2_timeIntegrator – SELF","text":"public subroutine LowStorageRK2_timeIntegrator(this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn Contents Source Code LowStorageRK2_timeIntegrator Source Code subroutine LowStorageRK2_timeIntegrator ( this , tn ) implicit none class ( Model ), intent ( inout ) :: this real ( prec ), intent ( in ) :: tn ! Local integer :: m real ( prec ) :: tRemain real ( prec ) :: dtLim real ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute do while ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = min ( dtLim , tRemain ) do m = 1 , 2 call this % CalculateTendency () call this % UpdateGRK2 ( m ) this % t = t0 + rk2_b ( m ) * this % dt enddo this % t = t0 + this % dt enddo this % dt = dtLim endsubroutine LowStorageRK2_timeIntegrator","tags":"","loc":"proc/lowstoragerk2_timeintegrator.html"},{"title":"LowStorageRK3_timeIntegrator – SELF","text":"public subroutine LowStorageRK3_timeIntegrator(this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn Contents Source Code LowStorageRK3_timeIntegrator Source Code subroutine LowStorageRK3_timeIntegrator ( this , tn ) implicit none class ( Model ), intent ( inout ) :: this real ( prec ), intent ( in ) :: tn ! Local integer :: m real ( prec ) :: tRemain real ( prec ) :: dtLim real ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute do while ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = min ( dtLim , tRemain ) do m = 1 , 3 call this % CalculateTendency () call this % UpdateGRK3 ( m ) this % t = t0 + rk3_b ( m ) * this % dt enddo this % t = t0 + this % dt enddo this % dt = dtLim endsubroutine LowStorageRK3_timeIntegrator","tags":"","loc":"proc/lowstoragerk3_timeintegrator.html"},{"title":"LowStorageRK4_timeIntegrator – SELF","text":"public subroutine LowStorageRK4_timeIntegrator(this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn Contents Source Code LowStorageRK4_timeIntegrator Source Code subroutine LowStorageRK4_timeIntegrator ( this , tn ) implicit none class ( Model ), intent ( inout ) :: this real ( prec ), intent ( in ) :: tn ! Local integer :: m real ( prec ) :: tRemain real ( prec ) :: dtLim real ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute do while ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = min ( dtLim , tRemain ) do m = 1 , 5 call this % CalculateTendency () call this % UpdateGRK4 ( m ) this % t = t0 + rk4_b ( m ) * this % dt enddo this % t = t0 + this % dt enddo this % dt = dtLim endsubroutine LowStorageRK4_timeIntegrator","tags":"","loc":"proc/lowstoragerk4_timeintegrator.html"},{"title":"PreTendency_Model – SELF","text":"public subroutine PreTendency_Model(this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions The intention is to provide a method that can be overridden through type-extension, to handle\nany steps that need to be executed before proceeding with the usual tendency calculation methods. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this Contents Source Code PreTendency_Model Source Code subroutine PreTendency_Model ( this ) !! PreTendency is a template routine that is used to house any additional calculations !! that you want to execute at the beginning of the tendency calculation routine. !! This default PreTendency simply returns back to the caller without executing any instructions !! !! The intention is to provide a method that can be overridden through type-extension, to handle !! any steps that need to be executed before proceeding with the usual tendency calculation methods. !! implicit none class ( Model ), intent ( inout ) :: this return endsubroutine PreTendency_Model","tags":"","loc":"proc/pretendency_model.html"},{"title":"PrintType_Model – SELF","text":"public subroutine PrintType_Model(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this Contents Source Code PrintType_Model Source Code subroutine PrintType_Model ( this ) implicit none class ( Model ), intent ( in ) :: this print * , __ FILE__ // \" : Model : No model type\" endsubroutine PrintType_Model","tags":"","loc":"proc/printtype_model.html"},{"title":"ReportEntropy_Model – SELF","text":"public subroutine ReportEntropy_Model(this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this Contents Source Code ReportEntropy_Model Source Code subroutine ReportEntropy_Model ( this ) !! Base method for reporting the entropy of a model !! to stdout. Only override this procedure if additional !! reporting is needed. Alternatively, if you think !! additional reporting would be valuable for all models, !! open a pull request with modifications to this base !! method. implicit none class ( Model ), intent ( in ) :: this ! Local character ( len = 20 ) :: modelTime character ( len = 20 ) :: entropy character ( len = :), allocatable :: str ! Copy the time and entropy to a string write ( modelTime , \"(ES16.7E3)\" ) this % t write ( entropy , \"(ES16.7E3)\" ) this % entropy ! Write the output to STDOUT open ( output_unit , ENCODING = 'utf-8' ) write ( output_unit , '(A,\" : \")' , ADVANCE = 'no' ) __ FILE__ str = 'tᵢ =' // trim ( modelTime ) write ( output_unit , '(A)' , ADVANCE = 'no' ) str str = '  |  eᵢ =' // trim ( entropy ) write ( output_unit , '(A)' , ADVANCE = 'yes' ) str endsubroutine ReportEntropy_Model","tags":"","loc":"proc/reportentropy_model.html"},{"title":"SetSimulationTime – SELF","text":"public subroutine SetSimulationTime(this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t Contents Source Code SetSimulationTime Source Code subroutine SetSimulationTime ( this , t ) !! Sets the model % t attribute with the provided simulation time implicit none class ( Model ), intent ( inout ) :: this real ( prec ), intent ( in ) :: t this % t = t endsubroutine SetSimulationTime","tags":"","loc":"proc/setsimulationtime.html"},{"title":"SetTimeIntegrator_withChar – SELF","text":"public subroutine SetTimeIntegrator_withChar(this, integrator) Sets the time integrator method, using a character input Valid options for integrator are \"euler\"\n  \"rk2\"\n  \"rk3\"\n  \"rk4\" Note that the character provided is not case-sensitive Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator Contents Source Code SetTimeIntegrator_withChar Source Code subroutine SetTimeIntegrator_withChar ( this , integrator ) !! Sets the time integrator method, using a character input !! !! Valid options for integrator are !! !!   \"euler\" !!   \"rk2\" !!   \"rk3\" !!   \"rk4\" !! !! Note that the character provided is not case-sensitive !! implicit none class ( Model ), intent ( inout ) :: this character ( * ), intent ( in ) :: integrator ! Local character ( SELF_INTEGRATOR_LENGTH ) :: upperCaseInt upperCaseInt = UpperCase ( trim ( integrator )) select case ( trim ( upperCaseInt )) case ( \"EULER\" ) this % timeIntegrator => Euler_timeIntegrator case ( \"RK2\" ) this % timeIntegrator => LowStorageRK2_timeIntegrator case ( \"RK3\" ) this % timeIntegrator => LowStorageRK3_timeIntegrator case ( \"RK4\" ) this % timeIntegrator => LowStorageRK4_timeIntegrator case DEFAULT this % timeIntegrator => LowStorageRK3_timeIntegrator endselect endsubroutine SetTimeIntegrator_withChar","tags":"","loc":"proc/settimeintegrator_withchar.html"},{"title":"CalculateTendency – SELF","text":"interface public subroutine CalculateTendency(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this","tags":"","loc":"interface/calculatetendency.html"},{"title":"ReadModel – SELF","text":"interface public subroutine ReadModel(this, filename) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: filename","tags":"","loc":"interface/readmodel.html"},{"title":"SELF_timeIntegrator – SELF","text":"interface public subroutine SELF_timeIntegrator(this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn","tags":"","loc":"interface/self_timeintegrator.html"},{"title":"UpdateGRK – SELF","text":"interface public subroutine UpdateGRK(this, m) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m","tags":"","loc":"interface/updategrk.html"},{"title":"UpdateSolution – SELF","text":"interface public subroutine UpdateSolution(this, dt) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt","tags":"","loc":"interface/updatesolution.html"},{"title":"WriteModel – SELF","text":"interface public subroutine WriteModel(this, filename) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in), optional :: filename","tags":"","loc":"interface/writemodel.html"},{"title":"WriteTecplot – SELF","text":"interface public subroutine WriteTecplot(this, filename) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in), optional :: filename","tags":"","loc":"interface/writetecplot.html"},{"title":"Free_Mesh2D_t – SELF","text":"public subroutine Free_Mesh2D_t(this) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this Contents Source Code Free_Mesh2D_t Source Code subroutine Free_Mesh2D_t ( this ) implicit none class ( Mesh2D_t ), intent ( inout ) :: this this % nElem = 0 this % nNodes = 0 this % nSides = 0 this % nCornerNodes = 0 this % nUniqueSides = 0 this % nUniqueNodes = 0 this % nBCs = 0 deallocate ( this % elemInfo ) deallocate ( this % sideInfo ) deallocate ( this % nodeCoords ) deallocate ( this % globalNodeIDs ) deallocate ( this % CGNSCornerMap ) deallocate ( this % CGNSSideMap ) deallocate ( this % BCType ) deallocate ( this % BCNames ) call this % decomp % Free () endsubroutine Free_Mesh2D_t","tags":"","loc":"proc/free_mesh2d_t.html"},{"title":"Init_Mesh2D_t – SELF","text":"public subroutine Init_Mesh2D_t(this, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs Contents Source Code Init_Mesh2D_t Source Code subroutine Init_Mesh2D_t ( this , nGeo , nElem , nSides , nNodes , nBCs ) implicit none class ( Mesh2D_t ), intent ( inout ) :: this integer , intent ( in ) :: nGeo integer , intent ( in ) :: nElem integer , intent ( in ) :: nSides integer , intent ( in ) :: nNodes integer , intent ( in ) :: nBCs ! Local integer :: i , j , l this % nGeo = nGeo this % nElem = nElem this % nGlobalElem = nElem this % nNodes = nNodes this % nSides = nSides this % nCornerNodes = 0 this % nUniqueNodes = 0 this % nUniqueSides = 0 this % nBCs = nBCs allocate ( this % elemInfo ( 1 : 6 , 1 : nElem )) allocate ( this % sideInfo ( 1 : 5 , 1 : 4 , 1 : nElem )) allocate ( this % nodeCoords ( 1 : 2 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % globalNodeIDs ( 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % CGNSCornerMap ( 1 : 2 , 1 : 4 )) allocate ( this % CGNSSideMap ( 1 : 2 , 1 : 4 )) allocate ( this % BCType ( 1 : 4 , 1 : nBCs )) allocate ( this % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation this % CGNSCornerMap ( 1 : 2 , 1 ) = ( / 1 , 1 / ) this % CGNSCornerMap ( 1 : 2 , 2 ) = ( / nGeo + 1 , 1 / ) this % CGNSCornerMap ( 1 : 2 , 3 ) = ( / nGeo + 1 , nGeo + 1 / ) this % CGNSCornerMap ( 1 : 2 , 4 ) = ( / 1 , nGeo + 1 / ) ! Maps from local corner node id to CGNS side this % CGNSSideMap ( 1 : 2 , 1 ) = ( / 1 , 2 / ) this % CGNSSideMap ( 1 : 2 , 2 ) = ( / 2 , 3 / ) this % CGNSSideMap ( 1 : 2 , 3 ) = ( / 4 , 3 / ) this % CGNSSideMap ( 1 : 2 , 4 ) = ( / 1 , 4 / ) endsubroutine Init_Mesh2D_t","tags":"","loc":"proc/init_mesh2d_t.html"},{"title":"Read_HOPr_Mesh2D_t – SELF","text":"public subroutine Read_HOPr_Mesh2D_t(this, meshFile, enableDomainDecomposition) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(out) :: this character, intent(in) :: meshFile logical, intent(in), optional :: enableDomainDecomposition Contents Source Code Read_HOPr_Mesh2D_t Source Code subroutine Read_HOPr_Mesh2D_t ( this , meshFile , enableDomainDecomposition ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 ! Adapted for 2D Mesh : Note that HOPR does not have 2D mesh output. implicit none class ( Mesh2D_t ), intent ( out ) :: this character ( * ), intent ( in ) :: meshFile logical , intent ( in ), optional :: enableDomainDecomposition ! Local integer ( HID_T ) :: fileId integer ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) integer :: nGlobalElem integer :: firstElem integer :: firstNode integer :: firstSide integer :: nLocalElems integer :: nLocalNodes3D integer :: nLocalSides3D integer :: nUniqueSides3D integer :: nLocalNodes2D integer :: nLocalSides2D integer :: nUniqueSides2D integer :: nGeo , nBCs integer :: eid , lsid , iSide integer :: i , j , nid integer , dimension (:,:), allocatable :: hopr_elemInfo integer , dimension (:,:), allocatable :: hopr_sideInfo real ( prec ), dimension (:,:), allocatable :: hopr_nodeCoords integer , dimension (:), allocatable :: hopr_globalNodeIDs integer , dimension (:,:), allocatable :: bcType if ( present ( enableDomainDecomposition )) then call this % decomp % init ( enableDomainDecomposition ) else call this % decomp % init (. false .) endif print * , __ FILE__ // ' : Reading HOPr mesh from' // trim ( meshfile ) if ( this % decomp % mpiEnabled ) then call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId , this % decomp % mpiComm ) else call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId ) endif print * , __ FILE__ // ' : Loading mesh attributes' call ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) call ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) call ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) call ReadAttribute_HDF5 ( fileId , 'nUniqueSides' , nUniqueSides3D ) print * , __ FILE__ // ' : N Global Elements = ' , nGlobalElem print * , __ FILE__ // ' : Mesh geometry degree = ' , nGeo print * , __ FILE__ // ' : N Boundary conditions = ' , nBCs print * , __ FILE__ // ' : N Unique Sides (3D) = ' , nUniqueSides3D ! Read BCType allocate ( bcType ( 1 : 4 , 1 : nBCS )) if ( this % decomp % mpiEnabled ) then offset (:) = 0 call ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) else call ReadArray_HDF5 ( fileId , 'BCType' , bcType ) endif ! Read local subarray of ElemInfo print * , __ FILE__ // ' : Generating Domain Decomposition' call this % decomp % GenerateDecomposition ( nGlobalElem , nUniqueSides3D ) firstElem = this % decomp % offsetElem ( this % decomp % rankId + 1 ) + 1 nLocalElems = this % decomp % offsetElem ( this % decomp % rankId + 2 ) - & this % decomp % offsetElem ( this % decomp % rankId + 1 ) print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : element offset = ' , firstElem print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : n_elements = ' , nLocalElems ! Allocate Space for hopr_elemInfo! allocate ( hopr_elemInfo ( 1 : 6 , 1 : nLocalElems )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstElem - 1 / ) call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) else call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) endif ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo ( 5 , 1 ) + 1 nLocalNodes3D = hopr_elemInfo ( 6 , nLocalElems ) - hopr_elemInfo ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! allocate ( hopr_nodeCoords ( 1 : 3 , nLocalNodes3D ), hopr_globalNodeIDs ( 1 : nLocalNodes3D )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) else call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) endif ! Read local subarray of SideInfo firstSide = hopr_elemInfo ( 3 , 1 ) + 1 nLocalSides3D = hopr_elemInfo ( 4 , nLocalElems ) - hopr_elemInfo ( 3 , 1 ) ! Allocate space for hopr_sideInfo allocate ( hopr_sideInfo ( 1 : 5 , 1 : nLocalSides3D )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstSide - 1 / ) print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' Reading side information' call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) else call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) endif call Close_HDF5 ( fileID ) ! ---- Done reading 3-D Mesh information ---- ! ! Now we need to convert from 3-D to 2-D ! nLocalSides2D = nLocalSides3D - 2 * nLocalElems nUniqueSides2D = nUniqueSides3D - 2 * nGlobalElem ! Remove the \"top\" and \"bottom\" faces nLocalNodes2D = nLocalNodes2D - nLocalElems * nGeo * ( nGeo + 1 ) ** 2 ! Remove the third dimension print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' Allocating memory for mesh' print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' n local sides  : ' , nLocalSides2D call this % Init ( nGeo , nLocalElems , nLocalSides2D , nLocalNodes2D , nBCs ) this % nUniqueSides = nUniqueSides2D ! Store the number of sides in the global mesh ! Copy data from local arrays into this !  elemInfo(1:6,iEl) !    1 - Element Type !    2 - Zone !    3 - offset index for side array (not needed when all quads are assumed) !    4 - last index for side array (not needed when all quads are assumed) !    5 - offset index for node array (not needed when all quads are assumed) !    6 - last index for node array (not needed when all quads are assumed) this % elemInfo = hopr_elemInfo this % quadrature = UNIFORM ! HOPr uses uniformly spaced points ! Grab the node coordinates (x and y only) from the \"bottom\" layer of the extruded mesh do eid = 1 , this % nElem do j = 1 , nGeo + 1 do i = 1 , nGeo + 1 nid = i + ( nGeo + 1 ) * ( j - 1 + ( nGeo + 1 ) * (( nGeo + 1 ) * ( eid - 1 ))) this % nodeCoords ( 1 : 2 , i , j , eid ) = hopr_nodeCoords ( 1 : 2 , nid ) this % globalNodeIDs ( i , j , eid ) = hopr_globalNodeIDs ( nid ) enddo enddo enddo ! Grab the south, west, north, and south sides of the elements !  sideInfo(1:5,iSide,iEl) ! !    1 - Side Type (currently unused in SELF) !    2 - Global Side ID (Used for message passing. Don't need to change) !    3 - Neighbor Element ID (Can stay the same) !    4 - 10*( neighbor local side )  + flip (Need to recalculate flip) !    5 - Boundary Condition ID (Can stay the same) do eid = 1 , this % nElem do lsid = 1 , 4 ! Calculate the 3-D side ID from the 2-D local side id and element ID iSide = lsid + 1 + 6 * ( eid - 1 ) this % sideInfo ( 1 : 5 , lsid , eid ) = hopr_sideInfo ( 1 : 5 , iSide ) ! Adjust the secondary side index for 2-D this % sideInfo ( 4 , lsid , eid ) = this % sideInfo ( 4 , lsid , eid ) - 10 enddo enddo call this % RecalculateFlip () deallocate ( hopr_elemInfo , hopr_nodeCoords , hopr_globalNodeIDs , hopr_sideInfo ) endsubroutine Read_HOPr_Mesh2D_t","tags":"","loc":"proc/read_hopr_mesh2d_t.html"},{"title":"RecalculateFlip_Mesh2D_t – SELF","text":"public subroutine RecalculateFlip_Mesh2D_t(this) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this Contents Source Code RecalculateFlip_Mesh2D_t Source Code subroutine RecalculateFlip_Mesh2D_t ( this ) implicit none class ( Mesh2D_t ), intent ( inout ) :: this ! Local integer :: e1 integer :: s1 integer :: e2 integer :: e2Global integer :: s2 integer :: flip integer :: bcid integer :: lnid1 ( 1 : 2 ) integer :: lnid2 ( 1 : 2 ) integer :: nid1 ( 1 : 2 , 1 : 4 , 1 : this % nElem ) integer :: nid2 ( 1 : 2 , 1 : 4 , 1 : this % nElem ) integer :: nloc1 ( 1 : 2 ) integer :: nloc2 ( 1 : 2 ) integer :: n1 integer :: n1Global integer :: n2 integer :: n2Global integer :: c1 integer :: c2 integer :: i , j integer :: l integer :: nShifts integer :: neighborRank integer :: rankId integer :: offset integer :: msgCount integer :: globalSideId integer , allocatable :: requests (:) integer , allocatable :: stats (:,:) integer :: iError integer :: tag logical :: theyMatch allocate ( requests ( 1 : this % nSides * 2 )) allocate ( stats ( MPI_STATUS_SIZE , 1 : this % nSides * 2 )) if ( this % decomp % mpiEnabled ) then rankId = this % decomp % rankId offset = this % decomp % offsetElem ( rankId + 1 ) else rankId = 0 offset = 0 endif msgCount = 0 do e1 = 1 , this % nElem do s1 = 1 , 4 e2Global = this % sideInfo ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = this % sideInfo ( 4 , s1 , e1 ) / 10 flip = this % sideInfo ( 4 , s1 , e1 ) - s2 * 10 bcid = this % sideInfo ( 5 , s1 , e1 ) if ( e2Global > 0 ) then if ( this % decomp % mpiEnabled ) then neighborRank = this % decomp % elemToRank ( e2Global ) else neighborRank = 0 endif if ( neighborRank == rankId ) then lnid1 = this % CGNSSideMap ( 1 : 2 , s1 ) ! local CGNS corner node ids for element 1 side lnid2 = this % CGNSSideMap ( 1 : 2 , s2 ) ! local CGNS corner node ids for element 2 side do l = 1 , 2 i = this % CGNSCornerMap ( 1 , lnid1 ( l )) j = this % CGNSCornerMap ( 2 , lnid1 ( l )) nid1 ( l , s1 , e1 ) = this % globalNodeIDs ( i , j , e1 ) i = this % CGNSCornerMap ( 1 , lnid2 ( l )) j = this % CGNSCornerMap ( 2 , lnid2 ( l )) nid2 ( l , s1 , e1 ) = this % globalNodeIDs ( i , j , e2 ) enddo else ! In this case, we need to exchange globalSideId = abs ( this % sideInfo ( 2 , s1 , e1 )) lnid1 = this % CGNSSideMap ( 1 : 2 , s1 ) ! local CGNS corner node ids for element 1 side do l = 1 , 2 i = this % CGNSCornerMap ( 1 , lnid1 ( l )) j = this % CGNSCornerMap ( 2 , lnid1 ( l )) nid1 ( l , s1 , e1 ) = this % globalNodeIDs ( i , j , e1 ) tag = l + 2 * globalSideId msgCount = msgCount + 1 call MPI_IRECV ( nid2 ( l , s1 , e1 ), & 1 , & MPI_INTEGER , & neighborRank , tag , & this % decomp % mpiComm , & requests ( msgCount ), iError ) ! Send nid1(l) from this rank to nid2(l) on the other rank msgCount = msgCount + 1 call MPI_ISEND ( nid1 ( l , s1 , e1 ), & 1 , & MPI_INTEGER , & neighborRank , tag , & this % decomp % mpiComm , & requests ( msgCount ), iError ) enddo endif ! MPI or not endif ! If not physical boundary enddo enddo if ( this % decomp % mpiEnabled . and . msgCount > 0 ) then call MPI_WaitAll ( msgCount , & requests ( 1 : msgCount ), & stats ( 1 : MPI_STATUS_SIZE , 1 : msgCount ), & iError ) endif do e1 = 1 , this % nElem do s1 = 1 , 4 e2Global = this % sideInfo ( 3 , s1 , e1 ) s2 = this % sideInfo ( 4 , s1 , e1 ) / 10 nloc1 ( 1 : 2 ) = nid1 ( 1 : 2 , s1 , e1 ) nloc2 ( 1 : 2 ) = nid2 ( 1 : 2 , s1 , e1 ) if ( e2Global > 0 ) then theyMatch = CompareArray ( nloc1 , nloc2 , 2 ) if ( theyMatch ) then this % sideInfo ( 4 , s1 , e1 ) = 10 * s2 else this % sideInfo ( 4 , s1 , e1 ) = 10 * s2 + 1 endif endif enddo enddo deallocate ( requests ) deallocate ( stats ) endsubroutine RecalculateFlip_Mesh2D_t","tags":"","loc":"proc/recalculateflip_mesh2d_t.html"},{"title":"ResetBoundaryConditionType_Mesh2D_t – SELF","text":"public subroutine ResetBoundaryConditionType_Mesh2D_t(this, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Note that ALL physical boundaries will be set to have this boundary\ncondition Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this integer, intent(in) :: bcid Contents Source Code ResetBoundaryConditionType_Mesh2D_t Source Code subroutine ResetBoundaryConditionType_Mesh2D_t ( this , bcid ) !! This method can be used to reset all of the boundary elements !! boundary condition type to the desired value. !! !! Note that ALL physical boundaries will be set to have this boundary !! condition implicit none class ( Mesh2D_t ), intent ( inout ) :: this integer , intent ( in ) :: bcid ! Local integer :: iSide , iEl , e2 do iEl = 1 , this % nElem do iSide = 1 , 4 e2 = this % sideInfo ( 3 , iSide , iEl ) if ( e2 == 0 ) then this % sideInfo ( 5 , iSide , iEl ) = bcid endif enddo enddo endsubroutine ResetBoundaryConditionType_Mesh2D_t","tags":"","loc":"proc/resetboundaryconditiontype_mesh2d_t.html"},{"title":"UniformStructuredMesh_Mesh2D_t – SELF","text":"public subroutine UniformStructuredMesh_Mesh2D_t(this, nxPerTile, nyPerTile, nTileX, nTileY, dx, dy, bcids, enableDomainDecomposition) Create a structured mesh and store it in SELF's unstructured mesh format.\nThe mesh is created in tiles of size (tnx,tny). Tiling is used to determine\nthe element ordering. Input\n   - this : Fresh/empty mesh2d_t object\n   - nxPerTile : The number of elements in the x direction within a tile\n   - nyPerTile : The number of elements in the y direction within a tile\n   - nTileX : The number of tiles in the x direction\n   - nTileY : The number of tiles in the y direction\n   - dx : Element width in the x-direction\n   - dy : Element width in the y-direction\n   - bcids(1:4) : Boundary condition flags for the south, east, north, and west sides of the domain\n   - enableDomainDecomposition : Boolean to determine if domain decomposition is used. Output\n   - this : mesh2d_t object with vertices, edges, and element information Total number of elements in the x-direction is nX = nxPerTile nTileX\nTotal number of elements in the y-direction is nY = nyPerTile nTileY Length of the domain in the x-direction is Lx = dx nX\nLength of the domain in the y-direction is Ly = dy nY Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(out) :: this integer, intent(in) :: nxPerTile integer, intent(in) :: nyPerTile integer, intent(in) :: nTileX integer, intent(in) :: nTileY real(kind=prec), intent(in) :: dx real(kind=prec), intent(in) :: dy integer, intent(in) :: bcids (1:4) logical, intent(in), optional :: enableDomainDecomposition Contents Source Code UniformStructuredMesh_Mesh2D_t Source Code subroutine UniformStructuredMesh_Mesh2D_t ( this , nxPerTile , nyPerTile , nTileX , nTileY , dx , dy , bcids , enableDomainDecomposition ) !! !! Create a structured mesh and store it in SELF's unstructured mesh format. !! The mesh is created in tiles of size (tnx,tny). Tiling is used to determine !! the element ordering. !! !! !!  Input !!    - this : Fresh/empty mesh2d_t object !!    - nxPerTile : The number of elements in the x direction within a tile !!    - nyPerTile : The number of elements in the y direction within a tile !!    - nTileX : The number of tiles in the x direction !!    - nTileY : The number of tiles in the y direction !!    - dx : Element width in the x-direction !!    - dy : Element width in the y-direction !!    - bcids(1:4) : Boundary condition flags for the south, east, north, and west sides of the domain !!    - enableDomainDecomposition : Boolean to determine if domain decomposition is used. !! !!  Output !!    - this : mesh2d_t object with vertices, edges, and element information !! !! Total number of elements in the x-direction is nX = nxPerTile*nTileX !! Total number of elements in the y-direction is nY = nyPerTile*nTileY !! !! Length of the domain in the x-direction is Lx = dx*nX !! Length of the domain in the y-direction is Ly = dy*nY !! implicit none class ( Mesh2D_t ), intent ( out ) :: this integer , intent ( in ) :: nxPerTile integer , intent ( in ) :: nyPerTile integer , intent ( in ) :: nTileX integer , intent ( in ) :: nTileY real ( prec ), intent ( in ) :: dx real ( prec ), intent ( in ) :: dy integer , intent ( in ) :: bcids ( 1 : 4 ) logical , optional , intent ( in ) :: enableDomainDecomposition ! Local integer :: nX , nY , nGeo , nBCs integer :: nGlobalElem integer :: nUniqueSides integer :: nUniqueNodes integer :: nLocalElems integer :: nLocalSides integer :: nLocalNodes real ( prec ), allocatable :: nodeCoords (:,:,:,:) integer , allocatable :: globalNodeIDs (:,:,:) integer , allocatable :: sideInfo (:,:,:) integer :: i , j , ti , tj integer :: ix , iy , iel integer :: ni , nj integer :: e1 , e2 integer :: nedges if ( present ( enableDomainDecomposition )) then call this % decomp % init ( enableDomainDecomposition ) else call this % decomp % init (. false .) endif nX = nTileX * nxPerTile nY = nTileY * nyPerTile nGeo = 1 ! Force the geometry to be linear nBCs = 4 ! Force the number of boundary conditions to 4 nGlobalElem = nX * nY nUniqueSides = ( nX + 1 ) * nY + ( nY + 1 ) * nX nUniqueNodes = ( nX + 1 ) * ( nY + 1 ) allocate ( nodeCoords ( 1 : 2 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nGlobalElem )) allocate ( globalNodeIDs ( 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nGlobalElem )) allocate ( sideInfo ( 1 : 5 , 1 : 4 , 1 : nGlobalElem )) do tj = 1 , nTileY do ti = 1 , nTileX do j = 1 , nyPerTile iy = j + nyPerTile * ( tj - 1 ) do i = 1 , nxPerTile iel = i + nxPerTile * ( j - 1 + nyPerTile * ( ti - 1 + nTilex * ( tj - 1 ))) ix = i + nxPerTile * ( ti - 1 ) ! nxpertile + nxpertile*(nTileX-1) = nxperTile*nTilex = 1 do nj = 1 , nGeo + 1 do ni = 1 , nGeo + 1 nodeCoords ( 1 , ni , nj , iel ) = real ( ni - 1 + ix - 1 , prec ) * dx nodeCoords ( 2 , ni , nj , iel ) = real ( nj - 1 + iy - 1 , prec ) * dy globalNodeIDs ( ni , nj , iel ) = ni - 1 + i + ( nxPerTile + 1 ) * ( nj - 1 + j - 1 + ( nyPerTile + 1 ) * ( ti - 1 + nTileX * ( tj - 1 )) ) enddo enddo enddo enddo enddo enddo ! Fill in edge information !  sideInfo(1:5,iSide,iEl) !    1 - Side Type (currently unused in SELF) !    2 - Global Side ID (Used for message passing. Don't need to change) !    3 - Neighbor Element ID (Can stay the same) !    4 - 10*( neighbor local side )  + flip (Need to recalculate flip) !    5 - Boundary Condition ID (Can stay the same) nedges = 0 do tj = 1 , nTileY do ti = 1 , nTileX do j = 1 , nyPerTile do i = 1 , nxPerTile iel = i + nxPerTile * ( j - 1 + nyPerTile * ( ti - 1 + nTilex * ( tj - 1 ))) ! south, iside=1 ! Get the corner node ids for this edge ! sideInfo(2,1,iel) = (nc1+nc2)*(nc1+nc2+1)/2 + nc2 if ( j == 1 ) then ! southern most part of the tile if ( tj == 1 ) then ! southern most tile nedges = nedges + 1 sideinfo ( 2 , 1 , iel ) = nedges sideinfo ( 3 , 1 , iel ) = 0 ! Neigbor element (null, boundary condition) sideinfo ( 4 , 1 , iel ) = 0 ! Neighbor side id (null, boundary condition) sideinfo ( 5 , 1 , iel ) = bcids ( 1 ) ! Boundary condition id; set from the user input else ! interior tile, but souther most edge of the tile e2 = i + nxPerTile * ( nyPerTile - 1 + nyPerTile * ( ti - 1 + nTilex * ( tj - 2 ))) ! Neigbor element, northernmost element, in tile to the south sideinfo ( 2 , 1 , iel ) = sideInfo ( 2 , 3 , e2 ) ! Copy the edge id from neighbor's north edge sideinfo ( 3 , 1 , iel ) = e2 sideinfo ( 4 , 1 , iel ) = 10 * 3 ! Neighbor side id - neighbor to the south, north side (3) sideinfo ( 5 , 1 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif else ! interior to the tile e2 = i + nxPerTile * ( j - 2 + nyPerTile * ( ti - 1 + nTilex * ( tj - 1 ))) ! Neigbor element, inside same tile, to the south sideinfo ( 2 , 1 , iel ) = sideInfo ( 2 , 3 , e2 ) ! Copy the edge id from neighbor's north edge sideinfo ( 3 , 1 , iel ) = e2 sideinfo ( 4 , 1 , iel ) = 10 * 3 ! Neighbor side id - neighbor to the south, north side (3) sideinfo ( 5 , 1 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif ! east, iside=2 ! Get the corner node ids for this edge ! East edges are always new edges, due to the way we are traversing the grid nedges = nedges + 1 sideinfo ( 2 , 2 , iel ) = nedges if ( i == nxPerTile ) then ! eastern most part of the tile if ( ti == nTileX ) then ! eastern most tile sideinfo ( 3 , 2 , iel ) = 0 ! Neigbor element (null, boundary condition) sideinfo ( 4 , 2 , iel ) = 0 ! Neighbor side id (null, boundary condition) sideinfo ( 5 , 2 , iel ) = bcids ( 2 ) ! Boundary condition id; eastern boundary set from the user input else ! interior tile, but eastern most edge of the tile sideinfo ( 3 , 2 , iel ) = 1 + nxPerTile * ( j - 1 + nyPerTile * ( ti + nTilex * ( tj - 1 ))) ! Neigbor element, westernnmost element, in tile to the east sideinfo ( 4 , 2 , iel ) = 10 * 4 ! Neighbor side id - neighbor to the east, west side (4) sideinfo ( 5 , 2 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif else ! interior to the tile sideinfo ( 3 , 2 , iel ) = i + 1 + nxPerTile * ( j - 1 + nyPerTile * ( ti - 1 + nTilex * ( tj - 1 ))) ! Neigbor element, inside same tile, to the east sideinfo ( 4 , 2 , iel ) = 10 * 4 ! Neighbor side id - neighbor to the east, west side (4) sideinfo ( 5 , 2 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif ! north, iside=3 ! Get the corner node ids for this edge ! East edges are always new edges, due to the way we are traversing the grid nedges = nedges + 1 sideinfo ( 2 , 3 , iel ) = nedges if ( j == nyPerTile ) then ! northern most part of the tile if ( tj == nTileY ) then ! northern most tile sideinfo ( 3 , 3 , iel ) = 0 ! Neigbor element (null, boundary condition) sideinfo ( 4 , 3 , iel ) = 0 ! Neighbor side id (null, boundary condition) sideinfo ( 5 , 3 , iel ) = bcids ( 3 ) ! Boundary condition id; set from the user input else ! interior tile, but northern most edge of the tile sideinfo ( 3 , 3 , iel ) = i + nxPerTile * ( nyPerTile * ( ti - 1 + nTilex * ( tj ))) ! Neigbor element, southernmost element in tile to the north sideinfo ( 4 , 3 , iel ) = 10 * 1 ! Neighbor side id - neighbor to the north, south side (1) sideinfo ( 5 , 3 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif else ! interior to the tile sideinfo ( 3 , 3 , iel ) = i + nxPerTile * ( j + nyPerTile * ( ti - 1 + nTilex * ( tj - 1 ))) ! Neigbor element, inside same tile, to the north sideinfo ( 4 , 3 , iel ) = 10 * 1 ! Neighbor side id - neighbor to the north, south side (1) sideinfo ( 5 , 3 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif ! west, iside=4 ! Get the corner node ids for this edge ! n1 = globalNodeIds(this%CGNSCornerMap(1,1),this%CGNSCornerMap(2,1),iel) ! n2 = globalNodeIds(this%CGNSCornerMap(1,4),this%CGNSCornerMap(2,4),iel) ! nc1 = min(n1,n2) ! nc2 = max(n1,n2) ! sideInfo(2,1,iel) = (nc1+nc2)*(nc1+nc2+1)/2 + nc2 if ( i == 1 ) then ! western most part of the tile if ( ti == 1 ) then ! western most tile nedges = nedges + 1 sideinfo ( 2 , 4 , iel ) = nedges sideinfo ( 3 , 4 , iel ) = 0 ! Neigbor element (null, boundary condition) sideinfo ( 4 , 4 , iel ) = 0 ! Neighbor side id (null, boundary condition) sideinfo ( 5 , 4 , iel ) = bcids ( 4 ) ! Boundary condition id; eastern boundary set from the user input else ! interior tile, but western most edge of the tile e2 = nxPerTile + nxPerTile * ( j - 1 + nyPerTile * ( ti - 2 + nTilex * ( tj - 1 ))) ! Neigbor element, easternnmost element in tile to the west sideinfo ( 3 , 4 , iel ) = sideInfo ( 2 , 2 , e2 ) ! Copy the edge id from neighbor's east edge sideinfo ( 3 , 4 , iel ) = e2 sideinfo ( 4 , 4 , iel ) = 10 * 2 ! Neighbor side id - neighbor to the west, east side (2) sideinfo ( 5 , 4 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif else ! interior to the tile e2 = i - 1 + nxPerTile * ( j - 1 + nyPerTile * ( ti - 1 + nTilex * ( tj - 1 ))) ! Neigbor element, inside same tile, to the west sideinfo ( 3 , 4 , iel ) = sideInfo ( 2 , 2 , e2 ) ! Copy the edge id from neighbor's east edge sideinfo ( 3 , 4 , iel ) = e2 sideinfo ( 4 , 4 , iel ) = 10 * 2 ! Neighbor side id - neighbor to the west, east side (2) sideinfo ( 5 , 4 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif enddo enddo enddo enddo if ( nedges /= nUniqueSides ) then print * , \"nedges not equal to nuniquesides, wtf : \" , nedges , nUniqueSides endif call this % decomp % GenerateDecomposition ( nGlobalElem , nUniqueSides ) e1 = this % decomp % offsetElem ( this % decomp % rankId + 1 ) + 1 e2 = this % decomp % offsetElem ( this % decomp % rankId + 2 ) nLocalElems = e2 - e1 + 1 nLocalSides = nLocalElems * 4 nLocalNodes = nLocalElems * 4 call this % Init ( nGeo , nLocalElems , nLocalSides , nLocalNodes , nBCs ) this % nUniqueSides = nUniqueSides this % quadrature = UNIFORM this % nodeCoords ( 1 : 2 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nLocalElems ) = nodeCoords ( 1 : 2 , 1 : nGeo + 1 , 1 : nGeo + 1 , e1 : e2 ) this % globalNodeIDs ( 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nLocalElems ) = globalNodeIDs ( 1 : nGeo + 1 , 1 : nGeo + 1 , e1 : e2 ) this % sideInfo ( 1 : 5 , 1 : 4 , 1 : nLocalElems ) = sideInfo ( 1 : 5 , 1 : 4 , e1 : e2 ) deallocate ( nodeCoords ) deallocate ( globalNodeIDs ) deallocate ( sideInfo ) endsubroutine UniformStructuredMesh_Mesh2D_t","tags":"","loc":"proc/uniformstructuredmesh_mesh2d_t.html"},{"title":"Write_Mesh2D_t – SELF","text":"public subroutine Write_Mesh2D_t(this, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this character, intent(in) :: meshFile Contents Source Code Write_Mesh2D_t Source Code subroutine Write_Mesh2D_t ( this , meshFile ) ! Writes mesh output in HOPR format (serial only) implicit none class ( Mesh2D_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: meshFile ! Local integer ( HID_T ) :: fileId call Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) call WriteAttribute_HDF5 ( fileId , 'nElems' , this % nElem ) call WriteAttribute_HDF5 ( fileId , 'Ngeo' , this % nGeo ) call WriteAttribute_HDF5 ( fileId , 'nBCs' , this % nBCs ) call WriteArray_HDF5 ( fileId , 'BCType' , this % bcType ) ! Write local subarray of ElemInfo call WriteArray_HDF5 ( fileId , 'ElemInfo' , this % elemInfo ) ! Write local subarray of NodeCoords and GlobalNodeIDs call WriteArray_HDF5 ( fileId , 'NodeCoords' , this % nodeCoords ) call WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , this % globalNodeIDs ) ! Write local subarray of SideInfo call WriteArray_HDF5 ( fileId , 'SideInfo' , this % sideInfo ) call Close_HDF5 ( fileID ) endsubroutine Write_Mesh2D_t","tags":"","loc":"proc/write_mesh2d_t.html"},{"title":"CalculateContravariantBasis_SEMQuad – SELF","text":"public subroutine CalculateContravariantBasis_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code CalculateContravariantBasis_SEMQuad Source Code subroutine CalculateContravariantBasis_SEMQuad ( myGeom ) implicit none class ( SEMQuad ), intent ( inout ) :: myGeom ! Local integer :: iEl , i , j , k real ( prec ) :: fac real ( prec ) :: mag ! Now calculate the contravariant basis vectors ! In this convention, dsdx(j,i) is contravariant vector i, component j ! To project onto contravariant vector i, dot vector along the first dimension do iEl = 1 , myGeom % nElem do j = 1 , myGeom % dxds % interp % N + 1 do i = 1 , myGeom % dxds % interp % N + 1 myGeom % dsdx % interior ( i , j , iel , 1 , 1 , 1 ) = myGeom % dxds % interior ( i , j , iel , 1 , 2 , 2 ) myGeom % dsdx % interior ( i , j , iel , 1 , 2 , 1 ) = - myGeom % dxds % interior ( i , j , iel , 1 , 1 , 2 ) myGeom % dsdx % interior ( i , j , iel , 1 , 1 , 2 ) = - myGeom % dxds % interior ( i , j , iel , 1 , 2 , 1 ) myGeom % dsdx % interior ( i , j , iel , 1 , 2 , 2 ) = myGeom % dxds % interior ( i , j , iel , 1 , 1 , 1 ) enddo enddo enddo ! Interpolate the contravariant tensor to the boundaries call myGeom % dsdx % BoundaryInterp () ! Tensor boundary interp is not offloaded ! Now, modify the sign of dsdx so that ! myGeom % dsdx % boundary is equal to the outward pointing normal vector do iEl = 1 , myGeom % nElem do k = 1 , 4 do i = 1 , myGeom % J % interp % N + 1 if ( k == selfSide2D_East . or . k == selfSide2D_North ) then fac = sign ( 1.0_prec , myGeom % J % boundary ( i , k , iEl , 1 )) else fac = - sign ( 1.0_prec , myGeom % J % boundary ( i , k , iEl , 1 )) endif if ( k == 1 ) then ! South mag = sqrt ( myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 , 2 ) ** 2 + & myGeom % dsdx % boundary ( i , k , iEl , 1 , 2 , 2 ) ** 2 ) myGeom % nScale % boundary ( i , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , k , iEl , 1 , 1 : 2 ) = & fac * myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 : 2 , 2 ) / mag elseif ( k == 2 ) then ! East mag = sqrt ( myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 , 1 ) ** 2 + & myGeom % dsdx % boundary ( i , k , iEl , 1 , 2 , 1 ) ** 2 ) myGeom % nScale % boundary ( i , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , k , iEl , 1 , 1 : 2 ) = & fac * myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 : 2 , 1 ) / mag elseif ( k == 3 ) then ! North mag = sqrt ( myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 , 2 ) ** 2 + & myGeom % dsdx % boundary ( i , k , iEl , 1 , 2 , 2 ) ** 2 ) myGeom % nScale % boundary ( i , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , k , iEl , 1 , 1 : 2 ) = & fac * myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 : 2 , 2 ) / mag elseif ( k == 4 ) then ! West mag = sqrt ( myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 , 1 ) ** 2 + & myGeom % dsdx % boundary ( i , k , iEl , 1 , 2 , 1 ) ** 2 ) myGeom % nScale % boundary ( i , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , k , iEl , 1 , 1 : 2 ) = & fac * myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 : 2 , 1 ) / mag endif ! Set the directionality for dsdx on the boundaries myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 : 2 , 1 : 2 ) = & myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 : 2 , 1 : 2 ) * fac enddo enddo enddo call myGeom % dsdx % UpdateDevice () call myGeom % nHat % UpdateDevice () call myGeom % nScale % UpdateDevice () endsubroutine CalculateContravariantBasis_SEMQuad","tags":"","loc":"proc/calculatecontravariantbasis_semquad.html"},{"title":"CalculateMetricTerms_SEMQuad – SELF","text":"public subroutine CalculateMetricTerms_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code CalculateMetricTerms_SEMQuad Source Code subroutine CalculateMetricTerms_SEMQuad ( myGeom ) implicit none class ( SEMQuad ), intent ( inout ) :: myGeom call myGeom % x % Gradient ( myGeom % dxds % interior ) call myGeom % dxds % BoundaryInterp () ! Tensor boundary interp is not offloaded to GPU call myGeom % dxds % UpdateDevice () call myGeom % dxds % Determinant ( myGeom % J % interior ) call myGeom % J % UpdateDevice () call myGeom % J % BoundaryInterp () call myGeom % J % UpdateHost () call myGeom % CalculateContravariantBasis () endsubroutine CalculateMetricTerms_SEMQuad","tags":"","loc":"proc/calculatemetricterms_semquad.html"},{"title":"Free_SEMQuad – SELF","text":"public subroutine Free_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code Free_SEMQuad Source Code subroutine Free_SEMQuad ( myGeom ) implicit none class ( SEMQuad ), intent ( inout ) :: myGeom call myGeom % x % Free () call myGeom % dxds % Free () call myGeom % dsdx % Free () call myGeom % nHat % Free () call myGeom % nScale % Free () call myGeom % J % Free () endsubroutine Free_SEMQuad","tags":"","loc":"proc/free_semquad.html"},{"title":"GenerateFromMesh_SEMQuad – SELF","text":"public subroutine GenerateFromMesh_SEMQuad(myGeom, mesh) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom type( Mesh2D ), intent(in) :: mesh Contents Source Code GenerateFromMesh_SEMQuad Source Code subroutine GenerateFromMesh_SEMQuad ( myGeom , mesh ) implicit none class ( SEMQuad ), intent ( inout ) :: myGeom type ( Mesh2D ), intent ( in ) :: mesh ! Local integer :: iel integer :: i , j type ( Lagrange ), target :: meshToModel type ( Vector2D ) :: xMesh call meshToModel % Init ( mesh % nGeo , & mesh % quadrature , & myGeom % x % interp % N , & myGeom % x % interp % controlNodeType ) call xMesh % Init ( meshToModel , 1 , mesh % nElem ) ! Set the element internal mesh locations do iel = 1 , mesh % nElem do j = 1 , mesh % nGeo + 1 do i = 1 , mesh % nGeo + 1 xMesh % interior ( i , j , iel , 1 , 1 : 2 ) = mesh % nodeCoords ( 1 : 2 , i , j , iel ) enddo enddo enddo call xMesh % GridInterp ( myGeom % x % interior ) call myGeom % x % UpdateDevice () call myGeom % x % BoundaryInterp () ! Boundary interp will run on GPU if enabled, hence why we close in update host/device call myGeom % x % UpdateHost () call myGeom % CalculateMetricTerms () call xMesh % Free () call meshToModel % Free () endsubroutine GenerateFromMesh_SEMQuad","tags":"","loc":"proc/generatefrommesh_semquad.html"},{"title":"Init_SEMQuad – SELF","text":"public subroutine Init_SEMQuad(myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom type( Lagrange ), intent(in), pointer :: interp integer, intent(in) :: nElem Contents Source Code Init_SEMQuad Source Code subroutine Init_SEMQuad ( myGeom , interp , nElem ) implicit none class ( SEMQuad ), intent ( out ) :: myGeom type ( Lagrange ), pointer , intent ( in ) :: interp integer , intent ( in ) :: nElem myGeom % nElem = nElem call myGeom % x % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % x % meta ( 1 )% SetName ( \"x\" ) call myGeom % dxds % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % dsdx % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % nHat % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % nScale % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % J % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) endsubroutine Init_SEMQuad","tags":"","loc":"proc/init_semquad.html"},{"title":"WriteTecplot_SEMQuad – SELF","text":"public subroutine WriteTecplot_SEMQuad(this, filename) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: this character, intent(in) :: filename Contents Source Code WriteTecplot_SEMQuad Source Code subroutine WriteTecplot_SEMQuad ( this , filename ) implicit none class ( SEMQuad ), intent ( inout ) :: this character ( * ), intent ( in ) :: filename ! Local character ( 8 ) :: zoneID integer :: fUnit integer :: iEl , i , j , iVar character ( LEN = self_TecplotHeaderLength ) :: tecHeader character ( LEN = self_FormatLength ) :: fmat open ( UNIT = NEWUNIT ( fUnit ), & FILE = trim ( filename ), & FORM = 'formatted' , & STATUS = 'replace' ) tecHeader = 'VARIABLES = \"X\", \"Y\", \"eID\"' write ( fUnit , * ) trim ( tecHeader ) ! Create format statement write ( fmat , * ) 3 fmat = '(' // trim ( fmat ) // '(ES16.7E3,1x))' do iEl = 1 , this % x % nElem ! TO DO :: Get the global element ID write ( zoneID , '(I8.8)' ) iEl write ( fUnit , * ) 'ZONE T=\"el' // trim ( zoneID ) // '\", I=' , this % x % interp % N + 1 , & ', J=' , this % x % interp % N + 1 do j = 1 , this % x % interp % N + 1 do i = 1 , this % x % interp % N + 1 write ( fUnit , fmat ) this % x % interior ( i , j , iEl , 1 , 1 ), & this % x % interior ( i , j , iEl , 1 , 2 ), real ( iEl , prec ) enddo enddo enddo close ( UNIT = fUnit ) endsubroutine WriteTecplot_SEMQuad","tags":"","loc":"proc/writetecplot_semquad.html"},{"title":"SetDescription_Metadata – SELF","text":"public subroutine SetDescription_Metadata(mtd, description) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: description Contents Source Code SetDescription_Metadata Source Code subroutine SetDescription_Metadata ( mtd , description ) implicit none class ( Metadata ), intent ( inout ) :: mtd character ( * ), intent ( in ) :: description mtd % description = description endsubroutine SetDescription_Metadata","tags":"","loc":"proc/setdescription_metadata.html"},{"title":"SetName_Metadata – SELF","text":"public subroutine SetName_Metadata(mtd, name) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: name Contents Source Code SetName_Metadata Source Code subroutine SetName_Metadata ( mtd , name ) implicit none class ( Metadata ), intent ( inout ) :: mtd character ( * ), intent ( in ) :: name mtd % name = name endsubroutine SetName_Metadata","tags":"","loc":"proc/setname_metadata.html"},{"title":"SetUnits_Metadata – SELF","text":"public subroutine SetUnits_Metadata(mtd, units) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: units Contents Source Code SetUnits_Metadata Source Code subroutine SetUnits_Metadata ( mtd , units ) implicit none class ( Metadata ), intent ( inout ) :: mtd character ( * ), intent ( in ) :: units mtd % units = units endsubroutine SetUnits_Metadata","tags":"","loc":"proc/setunits_metadata.html"},{"title":"WriteHDF5_Metadata – SELF","text":"public subroutine WriteHDF5_Metadata(mtd, group, varid, fileId) Writes the metadata to a HDF5 file using the\nfields :\n * /metadata/{group}/name/{varid} * /metadata/{group}/description/{varid} * /metadata/{group}/units/{varid} This method assumes that an HDF5 file is already\nopen for writing and is associated with the fileId input. Arguments Type Intent Optional Attributes Name class( Metadata ), intent(in) :: mtd character, intent(in) :: group integer, intent(in) :: varid integer(kind=HID_T), intent(in) :: fileId Contents Source Code WriteHDF5_Metadata Source Code subroutine WriteHDF5_Metadata ( mtd , group , varid , fileId ) !! Writes the metadata to a HDF5 file using the !! fields : !!  * `/metadata/{group}/name/{varid}` !!  * `/metadata/{group}/description/{varid}` !!  * `/metadata/{group}/units/{varid}` !! !! This method assumes that an HDF5 file is already !! open for writing and is associated with the `fileId` !! input. class ( Metadata ), intent ( in ) :: mtd character ( * ), intent ( in ) :: group integer , intent ( in ) :: varid integer ( HID_T ), intent ( in ) :: fileId ! Local character ( 4 ) :: varNumber ! Add variable names to the file call CreateGroup_HDF5 ( fileId , trim ( group ) // \"/metadata\" ) call CreateGroup_HDF5 ( fileId , trim ( group ) // \"/metadata/name\" ) call CreateGroup_HDF5 ( fileId , trim ( group ) // \"/metadata/description\" ) call CreateGroup_HDF5 ( fileId , trim ( group ) // \"/metadata/units\" ) write ( varNumber , \"(I0)\" ) varid call WriteCharacter_HDF5 ( fileId , trim ( group ) // \"/metadata/name/\" // trim ( varnumber ), & trim ( mtd % name )) call WriteCharacter_HDF5 ( fileId , trim ( group ) // \"/metadata/description/\" // trim ( varnumber ), & trim ( mtd % description )) call WriteCharacter_HDF5 ( fileId , trim ( group ) // \"/metadata/units/\" // trim ( varnumber ), & trim ( mtd % units )) endsubroutine WriteHDF5_Metadata","tags":"","loc":"proc/writehdf5_metadata.html"},{"title":"ApplyFlip_MappedVector3D_t – SELF","text":"public subroutine ApplyFlip_MappedVector3D_t(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh Contents Source Code ApplyFlip_MappedVector3D_t Source Code subroutine ApplyFlip_MappedVector3D_t ( this , mesh ) ! Apply side flips to sides where MPI exchanges took place. implicit none class ( MappedVector3D_t ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , idir integer :: i , i2 , j , j2 integer :: r2 , flip , ivar integer :: bcid real ( prec ) :: extBuff ( 1 : this % interp % N + 1 , 1 : this % interp % N + 1 ) do idir = 1 , 3 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 6 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 bcid = mesh % sideInfo ( 5 , s1 , e1 ) if ( e2 > 0 ) then ! Interior Element r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 ! Need to update extBoundary with flip applied if ( flip == 0 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 extBuff ( i , j ) = this % extBoundary ( i , j , s1 , e1 , ivar , idir ) enddo enddo else if ( flip == 1 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = j extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar , idir ) enddo enddo else if ( flip == 2 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = this % interp % N + 2 - j extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar , idir ) enddo enddo else if ( flip == 3 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = i j2 = this % interp % N + 2 - j extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar , idir ) enddo enddo else if ( flip == 4 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 extBuff ( i , j ) = this % extBoundary ( j , i , s1 , e1 , ivar , idir ) enddo enddo else if ( flip == 5 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = i extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar , idir ) enddo enddo else if ( flip == 6 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = this % interp % N + 2 - i extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar , idir ) enddo enddo else if ( flip == 7 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = j j2 = this % interp % N + 2 - i extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar , idir ) enddo enddo endif do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = extBuff ( i , j ) enddo enddo endif endif enddo enddo enddo enddo endsubroutine ApplyFlip_MappedVector3D_t","tags":"","loc":"proc/applyflip_mappedvector3d_t.html"},{"title":"AssociateGeometry_MappedVector3D_t – SELF","text":"public subroutine AssociateGeometry_MappedVector3D_t(this, geometry) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( SEMHex ), intent(in), target :: geometry Contents Source Code AssociateGeometry_MappedVector3D_t Source Code subroutine AssociateGeometry_MappedVector3D_t ( this , geometry ) implicit none class ( MappedVector3D_t ), intent ( inout ) :: this type ( SEMHex ), target , intent ( in ) :: geometry if (. not . associated ( this % geometry )) then this % geometry => geometry this % geometry_associated = . true . endif endsubroutine AssociateGeometry_MappedVector3D_t","tags":"","loc":"proc/associategeometry_mappedvector3d_t.html"},{"title":"DissociateGeometry_MappedVector3D_t – SELF","text":"public subroutine DissociateGeometry_MappedVector3D_t(this) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this Contents Source Code DissociateGeometry_MappedVector3D_t Source Code subroutine DissociateGeometry_MappedVector3D_t ( this ) implicit none class ( MappedVector3D_t ), intent ( inout ) :: this if ( associated ( this % geometry )) then this % geometry => null () this % geometry_associated = . false . endif endsubroutine DissociateGeometry_MappedVector3D_t","tags":"","loc":"proc/dissociategeometry_mappedvector3d_t.html"},{"title":"MPIExchangeAsync_MappedVector3D_t – SELF","text":"public subroutine MPIExchangeAsync_MappedVector3D_t(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh Contents Source Code MPIExchangeAsync_MappedVector3D_t Source Code subroutine MPIExchangeAsync_MappedVector3D_t ( this , mesh ) implicit none class ( MappedVector3D_t ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar , idir integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount msgCount = 0 do idir = 1 , 3 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 6 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 + this % nvar * ( idir - 1 )) msgCount = msgCount + 1 call MPI_IRECV ( this % extBoundary (:,:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , globalSideId , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( this % boundary (:,:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , globalSideId , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedVector3D_t","tags":"","loc":"proc/mpiexchangeasync_mappedvector3d_t.html"},{"title":"MappedDGDivergence_MappedVector3D_t – SELF","text":"public subroutine MappedDGDivergence_MappedVector3D_t(this, df) Computes the divergence of a 3-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) Contents Source Code MappedDGDivergence_MappedVector3D_t Source Code subroutine MappedDGDivergence_MappedVector3D_t ( this , df ) !! Computes the divergence of a 3-D vector using the weak form !! On input, the  attribute of the vector !! is assigned and the  attribute is set to the physical !! directions of the vector. This method will project the vector !! onto the contravariant basis vectors. implicit none class ( MappedVector3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , j , k , ii real ( prec ) :: dfLoc , Fx , Fy , Fz , Fc do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( ii , j , k , iEl , iVar , 1 ) Fy = this % interior ( ii , j , k , iEl , iVar , 2 ) Fz = this % interior ( ii , j , k , iEl , iVar , 3 ) Fc = this % geometry % dsdx % interior ( ii , j , k , iEl , 1 , 1 , 1 ) * Fx + & this % geometry % dsdx % interior ( ii , j , k , iEl , 1 , 2 , 1 ) * Fy + & this % geometry % dsdx % interior ( ii , j , k , iEl , 1 , 3 , 1 ) * Fz dfLoc = dfLoc + this % interp % dgMatrix ( ii , i ) * Fc enddo dfLoc = dfLoc + & ( this % interp % bMatrix ( i , 2 ) * this % boundaryNormal ( j , k , 3 , iel , ivar ) + & ! east this % interp % bMatrix ( i , 1 ) * this % boundaryNormal ( j , k , 5 , iel , ivar )) / & ! west this % interp % qweights ( i ) dF ( i , j , k , iel , ivar ) = dfLoc enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( i , ii , k , iEl , iVar , 1 ) Fy = this % interior ( i , ii , k , iEl , iVar , 2 ) Fz = this % interior ( i , ii , k , iEl , iVar , 3 ) Fc = this % geometry % dsdx % interior ( i , ii , k , iEl , 1 , 1 , 2 ) * Fx + & this % geometry % dsdx % interior ( i , ii , k , iEl , 1 , 2 , 2 ) * Fy + & this % geometry % dsdx % interior ( i , ii , k , iEl , 1 , 3 , 2 ) * Fz dfLoc = dfLoc + this % interp % dgMatrix ( ii , j ) * Fc enddo dfLoc = + dfLoc + & ( this % interp % bMatrix ( j , 2 ) * this % boundaryNormal ( i , k , 4 , iel , ivar ) + & ! north this % interp % bMatrix ( j , 1 ) * this % boundaryNormal ( i , k , 2 , iel , ivar )) / & ! south this % interp % qweights ( j ) dF ( i , j , k , iel , ivar ) = ( dF ( i , j , k , iel , ivar ) + dfLoc ) enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( i , j , ii , iEl , iVar , 1 ) Fy = this % interior ( i , j , ii , iEl , iVar , 2 ) Fz = this % interior ( i , j , ii , iEl , iVar , 3 ) Fc = this % geometry % dsdx % interior ( i , j , ii , iEl , 1 , 1 , 3 ) * Fx + & this % geometry % dsdx % interior ( i , j , ii , iEl , 1 , 2 , 3 ) * Fy + & this % geometry % dsdx % interior ( i , j , ii , iEl , 1 , 3 , 3 ) * Fz dfLoc = dfLoc + this % interp % dgMatrix ( ii , k ) * Fc enddo dfLoc = dfLoc + & ( this % interp % bMatrix ( k , 2 ) * this % boundaryNormal ( i , j , 6 , iel , ivar ) + & ! top this % interp % bMatrix ( k , 1 ) * this % boundaryNormal ( i , j , 1 , iel , ivar )) / & ! bottom this % interp % qweights ( k ) dF ( i , j , k , iel , ivar ) = ( dF ( i , j , k , iel , ivar ) + dfLoc ) / this % geometry % J % interior ( i , j , k , iEl , 1 ) enddo endsubroutine MappedDGDivergence_MappedVector3D_t","tags":"","loc":"proc/mappeddgdivergence_mappedvector3d_t.html"},{"title":"MappedDivergence_MappedVector3D_t – SELF","text":"public subroutine MappedDivergence_MappedVector3D_t(this, df) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) Contents Source Code MappedDivergence_MappedVector3D_t Source Code subroutine MappedDivergence_MappedVector3D_t ( this , df ) ! Strong Form Operator !    ! implicit none class ( MappedVector3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , j , k , ii real ( prec ) :: dfLoc , Fx , Fy , Fz , Fc do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( ii , j , k , iEl , iVar , 1 ) Fy = this % interior ( ii , j , k , iEl , iVar , 2 ) Fz = this % interior ( ii , j , k , iEl , iVar , 3 ) Fc = this % geometry % dsdx % interior ( ii , j , k , iEl , 1 , 1 , 1 ) * Fx + & this % geometry % dsdx % interior ( ii , j , k , iEl , 1 , 2 , 1 ) * Fy + & this % geometry % dsdx % interior ( ii , j , k , iEl , 1 , 3 , 1 ) * Fz dfLoc = dfLoc + this % interp % dMatrix ( ii , i ) * Fc enddo dF ( i , j , k , iel , ivar ) = dfLoc enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( i , ii , k , iEl , iVar , 1 ) Fy = this % interior ( i , ii , k , iEl , iVar , 2 ) Fz = this % interior ( i , ii , k , iEl , iVar , 3 ) Fc = this % geometry % dsdx % interior ( i , ii , k , iEl , 1 , 1 , 2 ) * Fx + & this % geometry % dsdx % interior ( i , ii , k , iEl , 1 , 2 , 2 ) * Fy + & this % geometry % dsdx % interior ( i , ii , k , iEl , 1 , 3 , 2 ) * Fz dfLoc = dfLoc + this % interp % dMatrix ( ii , j ) * Fc enddo dF ( i , j , k , iel , ivar ) = ( dF ( i , j , k , iel , ivar ) + dfLoc ) enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( i , j , ii , iEl , iVar , 1 ) Fy = this % interior ( i , j , ii , iEl , iVar , 2 ) Fz = this % interior ( i , j , ii , iEl , iVar , 3 ) Fc = this % geometry % dsdx % interior ( i , j , ii , iEl , 1 , 1 , 3 ) * Fx + & this % geometry % dsdx % interior ( i , j , ii , iEl , 1 , 2 , 3 ) * Fy + & this % geometry % dsdx % interior ( i , j , ii , iEl , 1 , 3 , 3 ) * Fz dfLoc = dfLoc + this % interp % dMatrix ( ii , k ) * Fc enddo dF ( i , j , k , iel , ivar ) = ( dF ( i , j , k , iel , ivar ) + dfLoc ) / this % geometry % J % interior ( i , j , k , iEl , 1 ) enddo endsubroutine MappedDivergence_MappedVector3D_t","tags":"","loc":"proc/mappeddivergence_mappedvector3d_t.html"},{"title":"SetInteriorFromEquation_MappedVector3D_t – SELF","text":"public subroutine SetInteriorFromEquation_MappedVector3D_t(this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time Contents Source Code SetInteriorFromEquation_MappedVector3D_t Source Code subroutine SetInteriorFromEquation_MappedVector3D_t ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedVector3D_t ), intent ( inout ) :: this type ( SEMHex ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , k , iEl , iVar real ( prec ) :: x real ( prec ) :: y real ( prec ) :: z do iVar = 1 , this % nVar do iEl = 1 , this % nElem do k = 1 , this % interp % N + 1 do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , k , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , k , iEl , 1 , 2 ) z = geometry % x % interior ( i , j , k , iEl , 1 , 3 ) this % interior ( i , j , k , iEl , iVar , 1 ) = & this % eqn ( 1 + 3 * ( iVar - 1 ))% Evaluate (( / x , y , z , time / )) this % interior ( i , j , k , iEl , iVar , 2 ) = & this % eqn ( 2 + 3 * ( iVar - 1 ))% Evaluate (( / x , y , z , time / )) this % interior ( i , j , k , iEl , iVar , 3 ) = & this % eqn ( 3 + 3 * ( iVar - 1 ))% Evaluate (( / x , y , z , time / )) enddo enddo enddo enddo enddo endsubroutine SetInteriorFromEquation_MappedVector3D_t","tags":"","loc":"proc/setinteriorfromequation_mappedvector3d_t.html"},{"title":"SideExchange_MappedVector3D_t – SELF","text":"public subroutine SideExchange_MappedVector3D_t(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh Contents Source Code SideExchange_MappedVector3D_t Source Code subroutine SideExchange_MappedVector3D_t ( this , mesh ) implicit none class ( MappedVector3D_t ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , e2 , s1 , s2 , e2Global integer :: flip integer :: i , i2 , j , j2 , ivar integer :: r2 integer :: rankId , offset integer :: idir integer , pointer :: elemtorank (:) elemtorank => mesh % decomp % elemToRank (:) rankId = mesh % decomp % rankId offset = mesh % decomp % offsetElem ( rankId + 1 ) if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif do concurrent ( s1 = 1 : 6 , e1 = 1 : mesh % nElem , ivar = 1 : this % nvar , idir = 1 : 3 ) e2Global = mesh % sideInfo ( 3 , s1 , e1 ) s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 if ( e2Global > 0 ) then r2 = elemToRank ( e2Global ) if ( r2 == rankId ) then e2 = e2Global - offset if ( flip == 0 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = & this % boundary ( i , j , s2 , e2 , ivar , idir ) enddo enddo else if ( flip == 1 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = j this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = & this % boundary ( i2 , j2 , s2 , e2 , ivar , idir ) enddo enddo else if ( flip == 2 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = this % interp % N + 2 - j this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = & this % boundary ( i2 , j2 , s2 , e2 , ivar , idir ) enddo enddo else if ( flip == 3 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = i j2 = this % interp % N + 2 - j this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = & this % boundary ( i2 , j2 , s2 , e2 , ivar , idir ) enddo enddo else if ( flip == 4 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = & this % boundary ( j , i , s2 , e2 , ivar , idir ) enddo enddo else if ( flip == 5 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = i this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = this % boundary ( i2 , j2 , s2 , e2 , ivar , idir ) enddo enddo else if ( flip == 6 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = this % interp % N + 2 - i this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = this % boundary ( i2 , j2 , s2 , e2 , ivar , idir ) enddo enddo else if ( flip == 7 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = j j2 = this % interp % N + 2 - i this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = this % boundary ( i2 , j2 , s2 , e2 , ivar , idir ) enddo enddo endif endif endif enddo if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call this % ApplyFlip ( mesh ) endif endsubroutine SideExchange_MappedVector3D_t","tags":"","loc":"proc/sideexchange_mappedvector3d_t.html"},{"title":"Close_HDF5 – SELF","text":"public subroutine Close_HDF5(fileId) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId Contents Source Code Close_HDF5 Source Code subroutine Close_HDF5 ( fileId ) implicit none integer ( HID_T ), intent ( in ) :: fileId ! Local integer :: error call h5fclose_f ( fileId , error ) call h5close_f ( error ) endsubroutine Close_HDF5","tags":"","loc":"proc/close_hdf5.html"},{"title":"CreateGroup_HDF5 – SELF","text":"public subroutine CreateGroup_HDF5(fileId, groupName) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: groupName Contents Source Code CreateGroup_HDF5 Source Code subroutine CreateGroup_HDF5 ( fileId , groupName ) #undef __FUNC__ #define __FUNC__ \"CreateGroup_HDF5\" implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: groupName ! Local integer ( HID_T ) :: groupId logical :: groupExists integer :: error call h5lexists_f ( fileId , trim ( groupName ), groupExists , error ) if ( error /= 0 ) then print * , __ FILE__ , \" : Link check failure for \" // trim ( groupName ) else if (. not . groupExists ) then ! Create groups call h5gcreate_f ( fileId , trim ( groupName ), groupId , error ) if ( error /= 0 ) then print * , __ FILE__ , \" :Failed to create group \" // trim ( groupName ) endif call h5gclose_f ( groupId , error ) if ( error /= 0 ) then print * , __ FILE__ , \" :Failed to close group \" // trim ( groupName ) endif endif endif endsubroutine CreateGroup_HDF5","tags":"","loc":"proc/creategroup_hdf5.html"},{"title":"Open_HDF5_parallel – SELF","text":"private subroutine Open_HDF5_parallel(fileName, accessFlag, fileId, mpiComm) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId integer, intent(in) :: mpiComm Contents Source Code Open_HDF5_parallel Source Code subroutine Open_HDF5_parallel ( fileName , accessFlag , fileId , mpiComm ) implicit none character ( * ), intent ( in ) :: fileName integer , intent ( in ) :: accessFlag integer ( HID_T ), intent ( inout ) :: fileId integer , intent ( in ) :: mpiComm ! Local integer ( HID_T ) :: plistId integer :: error call h5open_f ( error ) call h5pcreate_f ( H5P_FILE_ACCESS_F , plistId , error ) call h5pset_fapl_mpio_f ( plistId , mpiComm , MPI_INFO_NULL , error ) if ( accessFlag == H5F_ACC_TRUNC_F ) then call h5fcreate_f ( trim ( fileName ), accessFlag , fileId , error , access_prp = plistId ) else call h5fopen_f ( trim ( fileName ), accessFlag , fileId , error , access_prp = plistId ) endif call h5pclose_f ( plistId , error ) if ( error == - 1 ) then print * , 'Failed to open ' // trim ( fileName ) // '.' stop 1 endif endsubroutine Open_HDF5_parallel","tags":"","loc":"proc/open_hdf5_parallel.html"},{"title":"Open_HDF5_serial – SELF","text":"private subroutine Open_HDF5_serial(fileName, accessFlag, fileId) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId Contents Source Code Open_HDF5_serial Source Code subroutine Open_HDF5_serial ( fileName , accessFlag , fileId ) implicit none character ( * ), intent ( in ) :: fileName integer , intent ( in ) :: accessFlag integer ( HID_T ), intent ( inout ) :: fileId ! Local integer :: error call h5open_f ( error ) if ( accessFlag == H5F_ACC_TRUNC_F ) then call h5fcreate_f ( trim ( fileName ), accessFlag , fileId , error ) else call h5fopen_f ( trim ( fileName ), accessFlag , fileId , error ) endif if ( error == - 1 ) then print * , 'Failed to open ' // trim ( fileName ) // '.' stop 1 endif endsubroutine Open_HDF5_serial","tags":"","loc":"proc/open_hdf5_serial.html"},{"title":"ReadArray_HDF5_int32_r1_parallel – SELF","text":"private subroutine ReadArray_HDF5_int32_r1_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) Contents Source Code ReadArray_HDF5_int32_r1_parallel Source Code subroutine ReadArray_HDF5_int32_r1_parallel ( fileId , arrayName , hfArray , offset ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 ) integer ( int32 ), dimension (:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: dtypeId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HID_T ) :: dims ( 1 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 1 , dims , memspace , error ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dget_space_f ( dsetId , filespace , error ) call h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dget_type_f ( dsetId , dtypeId , error ) call h5dread_f ( dsetId , dtypeId , hfArray , dims , & error , memspace , filespace , plistId ) call h5tclose_f ( dtypeId , error ) call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dsetId , error ) call h5sclose_f ( memspace , error ) endsubroutine ReadArray_HDF5_int32_r1_parallel","tags":"","loc":"proc/readarray_hdf5_int32_r1_parallel.html"},{"title":"ReadArray_HDF5_int32_r1_serial – SELF","text":"private subroutine ReadArray_HDF5_int32_r1_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:) :: hfArray Contents Source Code ReadArray_HDF5_int32_r1_serial Source Code subroutine ReadArray_HDF5_int32_r1_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( int32 ), dimension (:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: dims ( 1 ) integer :: error dims = shape ( hfArray ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dread_f ( dsetId , h5kind_to_type ( int32 , H5_INTEGER_KIND ), hfArray , dims , error ) call h5dclose_f ( dsetId , error ) endsubroutine ReadArray_HDF5_int32_r1_serial","tags":"","loc":"proc/readarray_hdf5_int32_r1_serial.html"},{"title":"ReadArray_HDF5_int32_r2_parallel – SELF","text":"private subroutine ReadArray_HDF5_int32_r2_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) Contents Source Code ReadArray_HDF5_int32_r2_parallel Source Code subroutine ReadArray_HDF5_int32_r2_parallel ( fileId , arrayName , hfArray , offset ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 : 2 ) integer ( int32 ), dimension (:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: dtypeId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HID_T ) :: dims ( 1 : 2 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 2 , dims , memspace , error ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dget_space_f ( dsetId , filespace , error ) call h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dget_type_f ( dsetId , dtypeId , error ) call h5dread_f ( dsetId , dtypeId , hfArray , dims , & error , memspace , filespace , plistId ) call h5tclose_f ( dtypeId , error ) call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dsetId , error ) call h5sclose_f ( memspace , error ) endsubroutine ReadArray_HDF5_int32_r2_parallel","tags":"","loc":"proc/readarray_hdf5_int32_r2_parallel.html"},{"title":"ReadArray_HDF5_int32_r2_serial – SELF","text":"private subroutine ReadArray_HDF5_int32_r2_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:,:) :: hfArray Contents Source Code ReadArray_HDF5_int32_r2_serial Source Code subroutine ReadArray_HDF5_int32_r2_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( int32 ), dimension (:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: dims ( 1 : 2 ) integer :: error dims = shape ( hfArray ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dread_f ( dsetId , h5kind_to_type ( int32 , H5_INTEGER_KIND ), hfArray , dims , error ) call h5dclose_f ( dsetId , error ) endsubroutine ReadArray_HDF5_int32_r2_serial","tags":"","loc":"proc/readarray_hdf5_int32_r2_serial.html"},{"title":"ReadArray_HDF5_real_r1_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r1_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) Contents Source Code ReadArray_HDF5_real_r1_parallel Source Code subroutine ReadArray_HDF5_real_r1_parallel ( fileId , arrayName , hfArray , offset ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 ) real ( prec ), dimension (:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: dtypeId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HID_T ) :: dims ( 1 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 1 , dims , memspace , error ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dget_space_f ( dsetId , filespace , error ) call h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dget_type_f ( dsetId , dtypeId , error ) call h5dread_f ( dsetId , dtypeId , hfArray , dims , & error , memspace , filespace , plistId ) call h5tclose_f ( dtypeId , error ) call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dsetId , error ) call h5sclose_f ( memspace , error ) endsubroutine ReadArray_HDF5_real_r1_parallel","tags":"","loc":"proc/readarray_hdf5_real_r1_parallel.html"},{"title":"ReadArray_HDF5_real_r1_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r1_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:) :: hfArray Contents Source Code ReadArray_HDF5_real_r1_serial Source Code subroutine ReadArray_HDF5_real_r1_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: dims ( 1 ) integer :: error dims = shape ( hfArray ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray , dims , error ) call h5dclose_f ( dsetId , error ) endsubroutine ReadArray_HDF5_real_r1_serial","tags":"","loc":"proc/readarray_hdf5_real_r1_serial.html"},{"title":"ReadArray_HDF5_real_r2_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r2_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) Contents Source Code ReadArray_HDF5_real_r2_parallel Source Code subroutine ReadArray_HDF5_real_r2_parallel ( fileId , arrayName , hfArray , offset ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 : 2 ) real ( prec ), dimension (:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: dtypeId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HID_T ) :: dims ( 1 : 2 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 2 , dims , memspace , error ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dget_space_f ( dsetId , filespace , error ) call h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dget_type_f ( dsetId , dtypeId , error ) call h5dread_f ( dsetId , dtypeId , hfArray , dims , & error , memspace , filespace , plistId ) call h5tclose_f ( dtypeId , error ) call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dsetId , error ) call h5sclose_f ( memspace , error ) endsubroutine ReadArray_HDF5_real_r2_parallel","tags":"","loc":"proc/readarray_hdf5_real_r2_parallel.html"},{"title":"ReadArray_HDF5_real_r2_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r2_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:) :: hfArray Contents Source Code ReadArray_HDF5_real_r2_serial Source Code subroutine ReadArray_HDF5_real_r2_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: dims ( 1 : 2 ) integer :: error dims = shape ( hfArray ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray , dims , error ) call h5dclose_f ( dsetId , error ) endsubroutine ReadArray_HDF5_real_r2_serial","tags":"","loc":"proc/readarray_hdf5_real_r2_serial.html"},{"title":"ReadArray_HDF5_real_r3_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r3_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) Contents Source Code ReadArray_HDF5_real_r3_parallel Source Code subroutine ReadArray_HDF5_real_r3_parallel ( fileId , arrayName , hfArray , offset ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 : 3 ) real ( prec ), dimension (:,:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: dtypeId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HID_T ) :: dims ( 1 : 3 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 3 , dims , memspace , error ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dget_space_f ( dsetId , filespace , error ) call h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dget_type_f ( dsetId , dtypeId , error ) call h5dread_f ( dsetId , dtypeId , hfArray , dims , & error , memspace , filespace , plistId ) call h5tclose_f ( dtypeId , error ) call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dsetId , error ) call h5sclose_f ( memspace , error ) endsubroutine ReadArray_HDF5_real_r3_parallel","tags":"","loc":"proc/readarray_hdf5_real_r3_parallel.html"},{"title":"ReadArray_HDF5_real_r3_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r3_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:) :: hfArray Contents Source Code ReadArray_HDF5_real_r3_serial Source Code subroutine ReadArray_HDF5_real_r3_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: dims ( 1 : 3 ) integer :: error dims = shape ( hfArray ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray , dims , error ) call h5dclose_f ( dsetId , error ) endsubroutine ReadArray_HDF5_real_r3_serial","tags":"","loc":"proc/readarray_hdf5_real_r3_serial.html"},{"title":"ReadArray_HDF5_real_r4_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r4_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) Contents Source Code ReadArray_HDF5_real_r4_parallel Source Code subroutine ReadArray_HDF5_real_r4_parallel ( fileId , arrayName , hfArray , offset ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 : 4 ) real ( prec ), dimension (:,:,:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: dtypeId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HID_T ) :: dims ( 1 : 4 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 4 , dims , memspace , error ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dget_space_f ( dsetId , filespace , error ) call h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dget_type_f ( dsetId , dtypeId , error ) call h5dread_f ( dsetId , dtypeId , hfArray , dims , & error , memspace , filespace , plistId ) call h5tclose_f ( dtypeId , error ) call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dsetId , error ) call h5sclose_f ( memspace , error ) endsubroutine ReadArray_HDF5_real_r4_parallel","tags":"","loc":"proc/readarray_hdf5_real_r4_parallel.html"},{"title":"ReadArray_HDF5_real_r4_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r4_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:,:) :: hfArray Contents Source Code ReadArray_HDF5_real_r4_serial Source Code subroutine ReadArray_HDF5_real_r4_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:,:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: dims ( 1 : 4 ) integer :: error dims = shape ( hfArray ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray , dims , error ) call h5dclose_f ( dsetId , error ) endsubroutine ReadArray_HDF5_real_r4_serial","tags":"","loc":"proc/readarray_hdf5_real_r4_serial.html"},{"title":"ReadArray_HDF5_real_r5_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r5_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:,:,:) :: hfArray Contents Source Code ReadArray_HDF5_real_r5_serial Source Code subroutine ReadArray_HDF5_real_r5_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:,:,:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: dims ( 1 : 5 ) integer :: error dims = shape ( hfArray ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray , dims , error ) call h5dclose_f ( dsetId , error ) endsubroutine ReadArray_HDF5_real_r5_serial","tags":"","loc":"proc/readarray_hdf5_real_r5_serial.html"},{"title":"ReadAttribute_HDF5_character – SELF","text":"private subroutine ReadAttribute_HDF5_character(fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(out) :: attribute Contents Source Code ReadAttribute_HDF5_character Source Code subroutine ReadAttribute_HDF5_character ( fileId , attributeName , attribute ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: attributeName character ( * ), intent ( out ) :: attribute ! Local integer ( HID_T ) :: attrId integer ( HID_T ) :: typeId integer ( HSIZE_T ) :: dims ( 1 : 1 ) integer :: error dims ( 1 ) = 1 call h5aopen_f ( fileId , trim ( attributeName ), attrId , error ) call h5aget_type_f ( attrId , typeId , error ) call h5aread_f ( attrId , typeId , attribute , dims , error ) call h5tclose_f ( typeId , error ) call h5aclose_f ( attrId , error ) endsubroutine ReadAttribute_HDF5_character","tags":"","loc":"proc/readattribute_hdf5_character.html"},{"title":"ReadAttribute_HDF5_int32 – SELF","text":"private subroutine ReadAttribute_HDF5_int32(fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(out) :: attribute Contents Source Code ReadAttribute_HDF5_int32 Source Code subroutine ReadAttribute_HDF5_int32 ( fileId , attributeName , attribute ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: attributeName integer , intent ( out ) :: attribute ! Local integer ( HID_T ) :: attrId integer ( HID_T ) :: typeId integer ( HSIZE_T ) :: dims ( 1 : 1 ) integer :: error dims ( 1 ) = 1 call h5aopen_f ( fileId , trim ( attributeName ), attrId , error ) call h5aget_type_f ( attrId , typeId , error ) call h5aread_f ( attrId , typeId , attribute , dims , error ) call h5tclose_f ( typeId , error ) call h5aclose_f ( attrId , error ) endsubroutine ReadAttribute_HDF5_int32","tags":"","loc":"proc/readattribute_hdf5_int32.html"},{"title":"ReadAttribute_HDF5_real – SELF","text":"private subroutine ReadAttribute_HDF5_real(fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(out) :: attribute Contents Source Code ReadAttribute_HDF5_real Source Code subroutine ReadAttribute_HDF5_real ( fileId , attributeName , attribute ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: attributeName real ( prec ), intent ( out ) :: attribute ! Local integer ( HID_T ) :: attrId integer ( HID_T ) :: typeId integer ( HSIZE_T ) :: dims ( 1 : 1 ) integer :: error dims ( 1 ) = 1 call h5aopen_f ( fileId , trim ( attributeName ), attrId , error ) call h5aget_type_f ( attrId , typeId , error ) call h5aread_f ( attrId , typeId , attribute , dims , error ) call h5tclose_f ( typeId , error ) call h5aclose_f ( attrId , error ) endsubroutine ReadAttribute_HDF5_real","tags":"","loc":"proc/readattribute_hdf5_real.html"},{"title":"WriteArray_HDF5_int32_r1_serial – SELF","text":"private subroutine WriteArray_HDF5_int32_r1_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:) :: hfArray Contents Source Code WriteArray_HDF5_int32_r1_serial Source Code subroutine WriteArray_HDF5_int32_r1_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( int32 ), dimension (:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 1 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_int32_r1_serial","tags":"","loc":"proc/writearray_hdf5_int32_r1_serial.html"},{"title":"WriteArray_HDF5_int32_r2_serial – SELF","text":"private subroutine WriteArray_HDF5_int32_r2_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:,:) :: hfArray Contents Source Code WriteArray_HDF5_int32_r2_serial Source Code subroutine WriteArray_HDF5_int32_r2_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( int32 ), dimension (:,:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 2 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 2 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_int32_r2_serial","tags":"","loc":"proc/writearray_hdf5_int32_r2_serial.html"},{"title":"WriteArray_HDF5_int32_r3_serial – SELF","text":"private subroutine WriteArray_HDF5_int32_r3_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:,:,:) :: hfArray Contents Source Code WriteArray_HDF5_int32_r3_serial Source Code subroutine WriteArray_HDF5_int32_r3_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( int32 ), dimension (:,:,:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 3 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 3 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_int32_r3_serial","tags":"","loc":"proc/writearray_hdf5_int32_r3_serial.html"},{"title":"WriteArray_HDF5_int32_r4_serial – SELF","text":"private subroutine WriteArray_HDF5_int32_r4_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:,:,:,:) :: hfArray Contents Source Code WriteArray_HDF5_int32_r4_serial Source Code subroutine WriteArray_HDF5_int32_r4_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( int32 ), dimension (:,:,:,:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 4 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 4 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_int32_r4_serial","tags":"","loc":"proc/writearray_hdf5_int32_r4_serial.html"},{"title":"WriteArray_HDF5_real_r1_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r1_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:) :: hfArray Contents Source Code WriteArray_HDF5_real_r1_serial Source Code subroutine WriteArray_HDF5_real_r1_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 1 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_real_r1_serial","tags":"","loc":"proc/writearray_hdf5_real_r1_serial.html"},{"title":"WriteArray_HDF5_real_r2_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r2_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:) :: hfArray Contents Source Code WriteArray_HDF5_real_r2_serial Source Code subroutine WriteArray_HDF5_real_r2_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 2 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 2 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_real_r2_serial","tags":"","loc":"proc/writearray_hdf5_real_r2_serial.html"},{"title":"WriteArray_HDF5_real_r3_parallel – SELF","text":"private subroutine WriteArray_HDF5_real_r3_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) Contents Source Code WriteArray_HDF5_real_r3_parallel Source Code subroutine WriteArray_HDF5_real_r3_parallel ( fileId , arrayName , hfArray , offset , globalDims ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 : 3 ) real ( prec ), dimension (:,:,:), intent ( in ) :: hfArray integer ( HID_T ), intent ( in ) :: globalDims ( 1 : 3 ) ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 3 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 3 , globalDims , filespace , error ) call h5screate_simple_f ( 3 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) call h5sselect_hyperslab_f ( filespace , & H5S_SELECT_SET_F , & offset , & dims , & error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray , dims , error , & mem_space_id = memspace , file_space_id = filespace , xfer_prp = plistId ) if ( error /= 0 ) then print * , 'Failure to write dataset' stop 1 endif call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_real_r3_parallel","tags":"","loc":"proc/writearray_hdf5_real_r3_parallel.html"},{"title":"WriteArray_HDF5_real_r3_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r3_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:) :: hfArray Contents Source Code WriteArray_HDF5_real_r3_serial Source Code subroutine WriteArray_HDF5_real_r3_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:,:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 3 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 3 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_real_r3_serial","tags":"","loc":"proc/writearray_hdf5_real_r3_serial.html"},{"title":"WriteArray_HDF5_real_r4_parallel – SELF","text":"private subroutine WriteArray_HDF5_real_r4_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) Contents Source Code WriteArray_HDF5_real_r4_parallel Source Code subroutine WriteArray_HDF5_real_r4_parallel ( fileId , arrayName , hfArray , offset , globalDims ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 : 4 ) real ( prec ), dimension (:,:,:,:), intent ( in ) :: hfArray integer ( HID_T ), intent ( in ) :: globalDims ( 1 : 4 ) ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 4 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 4 , globalDims , filespace , error ) call h5screate_simple_f ( 4 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) call h5sselect_hyperslab_f ( filespace , & H5S_SELECT_SET_F , & offset , & dims , & error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray , dims , error , & mem_space_id = memspace , file_space_id = filespace , xfer_prp = plistId ) if ( error /= 0 ) then print * , 'Failure to write dataset' stop 1 endif call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_real_r4_parallel","tags":"","loc":"proc/writearray_hdf5_real_r4_parallel.html"},{"title":"WriteArray_HDF5_real_r4_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r4_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:,:) :: hfArray Contents Source Code WriteArray_HDF5_real_r4_serial Source Code subroutine WriteArray_HDF5_real_r4_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:,:,:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 4 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 4 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_real_r4_serial","tags":"","loc":"proc/writearray_hdf5_real_r4_serial.html"},{"title":"WriteArray_HDF5_real_r5_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r5_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:,:,:) :: hfArray Contents Source Code WriteArray_HDF5_real_r5_serial Source Code subroutine WriteArray_HDF5_real_r5_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:,:,:,:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 5 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 5 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), HDF5_IO_PREC , memspace , dsetId , error ) call h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_real_r5_serial","tags":"","loc":"proc/writearray_hdf5_real_r5_serial.html"},{"title":"WriteAttribute_HDF5_int32 – SELF","text":"private subroutine WriteAttribute_HDF5_int32(fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(in) :: attribute Contents Source Code WriteAttribute_HDF5_int32 Source Code subroutine WriteAttribute_HDF5_int32 ( fileId , attributeName , attribute ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: attributeName integer , intent ( in ) :: attribute ! Local integer ( HID_T ) :: aspaceId integer ( HID_T ) :: attrId integer ( HSIZE_T ) :: dims ( 1 : 1 ) integer :: error dims ( 1 ) = 1 call h5screate_f ( H5S_SCALAR_F , aspaceId , error ) call h5acreate_f ( fileId , trim ( attributeName ), H5T_STD_I32LE , & aspaceId , attrId , error ) call h5awrite_f ( attrId , H5T_STD_I32LE , attribute , dims , error ) call h5sclose_f ( aspaceId , error ) call h5aclose_f ( attrId , error ) endsubroutine WriteAttribute_HDF5_int32","tags":"","loc":"proc/writeattribute_hdf5_int32.html"},{"title":"WriteCharacter_HDF5_serial – SELF","text":"private subroutine WriteCharacter_HDF5_serial(fileId, name, hfField) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character(len=*), intent(in) :: name character(len=*), intent(in) :: hfField Contents Source Code WriteCharacter_HDF5_serial Source Code subroutine WriteCharacter_HDF5_serial ( fileid , name , hfField ) ! adapted from https://forum.hdfgroup.org/t/writing-a-string-array-as-attribute-in-fortran/8503/6 implicit none integer ( HID_T ), intent ( in ) :: fileId character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: hfField ! Local integer ( HID_T ) :: h5_strtype , h5_dspace , h5_dset integer ( HSIZE_T ), dimension ( 2 ) :: size character ( len = len ( hfField ) + 1 ), dimension ( 1 ) :: str_data integer ( SIZE_T ), dimension ( 1 ) :: str_len integer :: error ! string output requires to open a file local = non-parallel str_len ( 1 ) = len_trim ( hfField ) size ( 1 ) = str_len ( 1 ) size ( 2 ) = 1 str_data ( 1 ) = hfField // char ( 0 ) ! create data space call H5Tcopy_f ( H5T_STRING , h5_strtype , error ) call H5Tset_strpad_f ( h5_strtype , H5T_STR_NULLPAD_F , error ) call h5screate_simple_f ( 1 , size ( 2 ), h5_dspace , error ) call h5dcreate_f ( fileid , trim ( name ), h5_strtype , h5_dspace , h5_dset , error ) call h5dwrite_vl_f ( h5_dset , h5_strtype , str_data , size , str_len , error , h5_dspace ) call h5dclose_f ( h5_dset , error ) call h5sclose_f ( h5_dspace , error ) endsubroutine WriteCharacter_HDF5_serial","tags":"","loc":"proc/writecharacter_hdf5_serial.html"},{"title":"Open_HDF5 – SELF","text":"public interface Open_HDF5 Contents Module Procedures Open_HDF5_serial Open_HDF5_parallel Module Procedures private subroutine Open_HDF5_serial (fileName, accessFlag, fileId) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId private subroutine Open_HDF5_parallel (fileName, accessFlag, fileId, mpiComm) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId integer, intent(in) :: mpiComm","tags":"","loc":"interface/open_hdf5.html"},{"title":"ReadArray_HDF5 – SELF","text":"public interface ReadArray_HDF5 Contents Module Procedures ReadArray_HDF5_real_r1_serial ReadArray_HDF5_real_r2_serial ReadArray_HDF5_real_r3_serial ReadArray_HDF5_real_r4_serial ReadArray_HDF5_real_r5_serial ReadArray_HDF5_int32_r1_serial ReadArray_HDF5_int32_r2_serial ReadArray_HDF5_real_r1_parallel ReadArray_HDF5_real_r2_parallel ReadArray_HDF5_real_r3_parallel ReadArray_HDF5_real_r4_parallel ReadArray_HDF5_int32_r1_parallel ReadArray_HDF5_int32_r2_parallel Module Procedures private subroutine ReadArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:) :: hfArray private subroutine ReadArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:) :: hfArray private subroutine ReadArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:) :: hfArray private subroutine ReadArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:,:) :: hfArray private subroutine ReadArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:,:,:) :: hfArray private subroutine ReadArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:) :: hfArray private subroutine ReadArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:,:) :: hfArray private subroutine ReadArray_HDF5_real_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_real_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) private subroutine ReadArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) private subroutine ReadArray_HDF5_int32_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_int32_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2)","tags":"","loc":"interface/readarray_hdf5.html"},{"title":"ReadAttribute_HDF5 – SELF","text":"public interface ReadAttribute_HDF5 Contents Module Procedures ReadAttribute_HDF5_int32 ReadAttribute_HDF5_real ReadAttribute_HDF5_character Module Procedures private subroutine ReadAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(out) :: attribute private subroutine ReadAttribute_HDF5_real (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(out) :: attribute private subroutine ReadAttribute_HDF5_character (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(out) :: attribute","tags":"","loc":"interface/readattribute_hdf5.html"},{"title":"WriteArray_HDF5 – SELF","text":"public interface WriteArray_HDF5 Contents Module Procedures WriteArray_HDF5_real_r1_serial WriteArray_HDF5_real_r2_serial WriteArray_HDF5_real_r3_serial WriteArray_HDF5_real_r4_serial WriteArray_HDF5_real_r5_serial WriteArray_HDF5_int32_r1_serial WriteArray_HDF5_int32_r2_serial WriteArray_HDF5_int32_r3_serial WriteArray_HDF5_int32_r4_serial WriteArray_HDF5_real_r3_parallel WriteArray_HDF5_real_r4_parallel Module Procedures private subroutine WriteArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:) :: hfArray private subroutine WriteArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:) :: hfArray private subroutine WriteArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:) :: hfArray private subroutine WriteArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:,:) :: hfArray private subroutine WriteArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:,:,:) :: hfArray private subroutine WriteArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:) :: hfArray private subroutine WriteArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:,:) :: hfArray private subroutine WriteArray_HDF5_int32_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:,:,:) :: hfArray private subroutine WriteArray_HDF5_int32_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:,:,:,:) :: hfArray private subroutine WriteArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4)","tags":"","loc":"interface/writearray_hdf5.html"},{"title":"WriteAttribute_HDF5 – SELF","text":"public interface WriteAttribute_HDF5 Contents Module Procedures WriteAttribute_HDF5_int32 Module Procedures private subroutine WriteAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(in) :: attribute","tags":"","loc":"interface/writeattribute_hdf5.html"},{"title":"WriteCharacter_HDF5 – SELF","text":"public interface WriteCharacter_HDF5 Contents Module Procedures WriteCharacter_HDF5_serial Module Procedures private subroutine WriteCharacter_HDF5_serial (fileId, name, hfField) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character(len=*), intent(in) :: name character(len=*), intent(in) :: hfField","tags":"","loc":"interface/writecharacter_hdf5.html"},{"title":"AverageSides_Vector2D_t – SELF","text":"public subroutine AverageSides_Vector2D_t(this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this Contents Source Code AverageSides_Vector2D_t Source Code subroutine AverageSides_Vector2D_t ( this ) implicit none class ( Vector2D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: iside integer :: ivar integer :: i integer :: idir do concurrent ( i = 1 : this % interp % N + 1 , iside = 1 : 4 , iel = 1 : this % nElem , & ivar = 1 : this % nVar , idir = 1 : 2 ) this % avgboundary ( i , iside , iel , ivar , idir ) = 0.5_prec * ( & this % boundary ( i , iside , iel , ivar , idir ) + & this % extBoundary ( i , iside , iel , ivar , idir )) enddo endsubroutine AverageSides_Vector2D_t","tags":"","loc":"proc/averagesides_vector2d_t.html"},{"title":"BoundaryInterp_Vector2D_t – SELF","text":"public subroutine BoundaryInterp_Vector2D_t(this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this Contents Source Code BoundaryInterp_Vector2D_t Source Code subroutine BoundaryInterp_Vector2D_t ( this ) implicit none class ( Vector2D_t ), intent ( inout ) :: this ! Local integer :: i , ii , idir , iel , ivar real ( prec ) :: fbs , fbe , fbn , fbw do concurrent ( i = 1 : this % N + 1 , iel = 1 : this % nelem , & ivar = 1 : this % nvar , idir = 1 : 2 ) fbs = 0.0_prec fbe = 0.0_prec fbn = 0.0_prec fbw = 0.0_prec do ii = 1 , this % N + 1 fbs = fbs + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , ii , iel , ivar , idir ) ! South fbe = fbe + this % interp % bMatrix ( ii , 2 ) * this % interior ( ii , i , iel , ivar , idir ) ! East fbn = fbn + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , ii , iel , ivar , idir ) ! North fbw = fbw + this % interp % bMatrix ( ii , 1 ) * this % interior ( ii , i , iel , ivar , idir ) ! West enddo this % boundary ( i , 1 , iel , ivar , idir ) = fbs this % boundary ( i , 2 , iel , ivar , idir ) = fbe this % boundary ( i , 3 , iel , ivar , idir ) = fbn this % boundary ( i , 4 , iel , ivar , idir ) = fbw enddo endsubroutine BoundaryInterp_Vector2D_t","tags":"","loc":"proc/boundaryinterp_vector2d_t.html"},{"title":"Divergence_Vector2D_t – SELF","text":"public subroutine Divergence_Vector2D_t(this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) Contents Source Code Divergence_Vector2D_t Source Code subroutine Divergence_Vector2D_t ( this , df ) implicit none class ( Vector2D_t ), intent ( in ) :: this real ( prec ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: i , j , ii , iel , ivar real ( prec ) :: dfLoc do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 dfLoc = dfLoc + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , iel , ivar , 1 ) enddo dF ( i , j , iel , ivar ) = dfLoc enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 dfLoc = dfLoc + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , iel , ivar , 2 ) enddo dF ( i , j , iel , ivar ) = dF ( i , j , iel , ivar ) + dfLoc enddo endsubroutine Divergence_Vector2D_t","tags":"","loc":"proc/divergence_vector2d_t.html"},{"title":"Free_Vector2D_t – SELF","text":"public subroutine Free_Vector2D_t(this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this Contents Source Code Free_Vector2D_t Source Code subroutine Free_Vector2D_t ( this ) implicit none class ( Vector2D_t ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % boundaryNormal ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) endsubroutine Free_Vector2D_t","tags":"","loc":"proc/free_vector2d_t.html"},{"title":"Gradient_Vector2D_t – SELF","text":"public subroutine Gradient_Vector2D_t(this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2,1:2) Contents Source Code Gradient_Vector2D_t Source Code subroutine Gradient_Vector2D_t ( this , df ) implicit none class ( Vector2D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 2 , 1 : 2 ) ! Local integer :: i , j , ii , iEl , iVar , idir real ( prec ) :: dfds1 , dfds2 do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , & ivar = 1 : this % nVar , idir = 1 : 2 ) dfds1 = 0.0_prec dfds2 = 0.0_prec do ii = 1 , this % N + 1 dfds1 = dfds1 + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , iel , ivar , idir ) dfds2 = dfds2 + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , iel , ivar , idir ) enddo df ( i , j , iel , ivar , idir , 1 ) = dfds1 df ( i , j , iel , ivar , idir , 2 ) = dfds2 enddo endsubroutine Gradient_Vector2D_t","tags":"","loc":"proc/gradient_vector2d_t.html"},{"title":"GridInterp_Vector2D_t – SELF","text":"public subroutine GridInterp_Vector2D_t(this, f) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:2) Contents Source Code GridInterp_Vector2D_t Source Code subroutine GridInterp_Vector2D_t ( this , f ) implicit none class ( Vector2D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: f ( 1 : this % M + 1 , 1 : this % M + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 2 ) ! Local integer :: i , j , ii , jj , iel , ivar , idir real ( prec ) :: fi , fij do concurrent ( i = 1 : this % M + 1 , j = 1 : this % M + 1 , iel = 1 : this % nElem , & ivar = 1 : this % nVar , idir = 1 : 2 ) fij = 0.0_prec do jj = 1 , this % N + 1 fi = 0.0_prec do ii = 1 , this % N + 1 fi = fi + this % interior ( ii , jj , iel , ivar , idir ) * this % interp % iMatrix ( ii , i ) enddo fij = fij + fi * this % interp % iMatrix ( jj , j ) enddo f ( i , j , iel , ivar , idir ) = fij enddo endsubroutine GridInterp_Vector2D_t","tags":"","loc":"proc/gridinterp_vector2d_t.html"},{"title":"Init_Vector2D_t – SELF","text":"public subroutine Init_Vector2D_t(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Vector2D_t Source Code subroutine Init_Vector2D_t ( this , interp , nVar , nElem ) implicit none class ( Vector2D_t ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % boundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % boundaryNormal ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 2 * nVar )) ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 2 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo this % interior = 0.0_prec this % boundary = 0.0_prec this % boundarynormal = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec endsubroutine Init_Vector2D_t","tags":"","loc":"proc/init_vector2d_t.html"},{"title":"SetEquation_Vector2D_t – SELF","text":"public subroutine SetEquation_Vector2D_t(this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar Contents Source Code SetEquation_Vector2D_t Source Code subroutine SetEquation_Vector2D_t ( this , idir , ivar , eqnChar ) !! Sets the equation parser for the `idir` direction and `ivar-th` variable implicit none class ( Vector2D_t ), intent ( inout ) :: this integer , intent ( in ) :: idir , ivar character ( * ), intent ( in ) :: eqnChar this % eqn ( idir + 2 * ( ivar - 1 )) = EquationParser ( trim ( eqnChar ), & ( / 'x' , 'y' , 'z' , 't' / )) endsubroutine SetEquation_Vector2D_t","tags":"","loc":"proc/setequation_vector2d_t.html"},{"title":"UpdateDevice_Vector2D_t – SELF","text":"public subroutine UpdateDevice_Vector2D_t(this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this Contents Source Code UpdateDevice_Vector2D_t Source Code subroutine UpdateDevice_Vector2D_t ( this ) implicit none class ( Vector2D_t ), intent ( inout ) :: this endsubroutine UpdateDevice_Vector2D_t","tags":"","loc":"proc/updatedevice_vector2d_t.html"},{"title":"UpdateHost_Vector2D_t – SELF","text":"public subroutine UpdateHost_Vector2D_t(this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this Contents Source Code UpdateHost_Vector2D_t Source Code subroutine UpdateHost_Vector2D_t ( this ) implicit none class ( Vector2D_t ), intent ( inout ) :: this endsubroutine UpdateHost_Vector2D_t","tags":"","loc":"proc/updatehost_vector2d_t.html"},{"title":"WriteHDF5_MPI_Vector2D_t – SELF","text":"public subroutine WriteHDF5_MPI_Vector2D_t(this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem Contents Source Code WriteHDF5_MPI_Vector2D_t Source Code subroutine WriteHDF5_MPI_Vector2D_t ( this , fileId , group , elemoffset , nglobalelem ) implicit none class ( Vector2D_t ), intent ( in ) :: this character ( * ), intent ( in ) :: group integer ( HID_T ), intent ( in ) :: fileId integer , intent ( in ) :: elemoffset integer , intent ( in ) :: nglobalelem ! Local integer ( HID_T ) :: offset ( 1 : 3 ) integer ( HID_T ) :: globalDims ( 1 : 3 ) integer :: ivar , idir character ( 4 ) :: dimvar offset ( 1 : 3 ) = ( / 0 , 0 , elemoffset / ) globalDims ( 1 : 3 ) = ( / this % interp % N + 1 , & this % interp % N + 1 , & nglobalelem / ) call CreateGroup_HDF5 ( fileId , trim ( group )) do idir = 1 , 2 write ( dimvar , '(I1)' ) idir dimvar = \"dim\" // trim ( dimvar ) do ivar = 1 , this % nVar !call this%meta(ivar)%WriteHDF5(group,ivar,fileId) call WriteArray_HDF5 ( fileId , & trim ( group ) // \"/\" // trim ( this % meta ( ivar )% name ) // \"_\" // dimvar , & this % interior (:,:,:, ivar , idir ), offset , globalDims ) enddo enddo endsubroutine WriteHDF5_MPI_Vector2D_t","tags":"","loc":"proc/writehdf5_mpi_vector2d_t.html"},{"title":"WriteHDF5_Vector2D_t – SELF","text":"public subroutine WriteHDF5_Vector2D_t(this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Contents Source Code WriteHDF5_Vector2D_t Source Code subroutine WriteHDF5_Vector2D_t ( this , fileId , group ) implicit none class ( Vector2D_t ), intent ( in ) :: this integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: group ! Local integer :: ivar , idir character ( 4 ) :: dimvar call CreateGroup_HDF5 ( fileId , trim ( group )) do ivar = 1 , this % nVar call this % meta ( ivar )% WriteHDF5 ( group , ivar , fileId ) enddo do idir = 1 , 2 write ( dimvar , '(I1)' ) idir dimvar = \"dim\" // trim ( dimvar ) do ivar = 1 , this % nVar call WriteArray_HDF5 ( fileId , & trim ( group ) // \"/\" // trim ( this % meta ( ivar )% name ) // \"_\" // dimvar , & this % interior (:,:,:, ivar , idir )) enddo enddo endsubroutine WriteHDF5_Vector2D_t","tags":"","loc":"proc/writehdf5_vector2d_t.html"},{"title":"entropy_func_Burgers1D_t – SELF","text":"public pure function entropy_func_Burgers1D_t(this, s) result(e) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) Contents Source Code entropy_func_Burgers1D_t Source Code pure function entropy_func_Burgers1D_t ( this , s ) result ( e ) class ( Burgers1D_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ) :: e e = 0.5_prec * s ( 1 ) * s ( 1 ) endfunction entropy_func_Burgers1D_t","tags":"","loc":"proc/entropy_func_burgers1d_t.html"},{"title":"flux1d_Burgers1D_t – SELF","text":"public pure function flux1d_Burgers1D_t(this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) Return Value real(kind=prec)(1:this%solution%nvar) Contents Source Code flux1d_Burgers1D_t Source Code pure function flux1d_Burgers1D_t ( this , s , dsdx ) result ( flux ) class ( Burgers1D_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % solution % nvar ) real ( prec ) :: flux ( 1 : this % solution % nvar ) flux ( 1 ) = 0.5_prec * s ( 1 ) * s ( 1 ) - this % nu * dsdx ( 1 ) endfunction flux1d_Burgers1D_t","tags":"","loc":"proc/flux1d_burgers1d_t.html"},{"title":"riemannflux1d_Burgers1D_t – SELF","text":"public pure function riemannflux1d_Burgers1D_t(this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%solution%nvar) real(kind=prec), intent(in) :: sR (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%solution%nvar) Contents Source Code riemannflux1d_Burgers1D_t Source Code pure function riemannflux1d_Burgers1D_t ( this , sL , sR , dsdx , nhat ) result ( flux ) class ( Burgers1D_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: sL ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: sR ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: nhat real ( prec ) :: flux ( 1 : this % solution % nvar ) ! Local real ( prec ) :: fL , fR , cmax ! Local Lax-Friedrich's flux fL = 0.5_prec * sL ( 1 ) * sL ( 1 ) * nhat fR = 0.5_prec * sR ( 1 ) * sR ( 1 ) * nhat cmax = max ( abs ( sL ( 1 ) * nhat ), abs ( sR ( 1 ) * nhat )) ! maximum wave speed flux ( 1 ) = 0.5_prec * ( fL + fR ) + cmax * ( sL ( 1 ) - sR ( 1 )) & ! advective flux - this % nu * dsdx ( 1 ) * nhat endfunction riemannflux1d_Burgers1D_t","tags":"","loc":"proc/riemannflux1d_burgers1d_t.html"},{"title":"SetMetadata_Burgers1D_t – SELF","text":"public subroutine SetMetadata_Burgers1D_t(this) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(inout) :: this Contents Source Code SetMetadata_Burgers1D_t Source Code subroutine SetMetadata_Burgers1D_t ( this ) implicit none class ( Burgers1D_t ), intent ( inout ) :: this call this % solution % SetName ( 1 , \"s\" ) call this % solution % SetUnits ( 1 , \"[null]\" ) endsubroutine SetMetadata_Burgers1D_t","tags":"","loc":"proc/setmetadata_burgers1d_t.html"},{"title":"CalculateLagrangePolynomials – SELF","text":"public function CalculateLagrangePolynomials(this, sE) result(lAtS) Arguments Type Intent Optional Attributes Name class( Lagrange_t ) :: this real(kind=prec) :: sE Return Value real(kind=prec)(0:this%N) Contents Source Code CalculateLagrangePolynomials Source Code function CalculateLagrangePolynomials ( this , sE ) result ( lAtS ) implicit none class ( Lagrange_t ) :: this real ( prec ) :: sE real ( prec ) :: lAtS ( 0 : this % N ) ! Local integer :: j logical :: xMatchesNode real ( real64 ) :: temp1 , temp2 real ( real64 ) :: sELocal real ( real64 ) :: controlPoints ( 0 : this % N ) real ( real64 ) :: bWeights ( 0 : this % N ) real ( real64 ) :: lS ( 0 : this % N ) sELocal = real ( sE , real64 ) do j = 0 , this % N controlPoints ( j ) = real ( this % controlPoints ( j + 1 ), real64 ) bWeights ( j ) = real ( this % bWeights ( j + 1 ), real64 ) enddo xMatchesNode = . false . do j = 0 , this % N lS ( j ) = 0.0_real64 if ( AlmostEqual ( sELocal , controlPoints ( j ))) then lS ( j ) = 1.0_real64 xMatchesNode = . true . endif enddo if ( xMatchesNode ) then do j = 0 , this % N lAtS ( j ) = real ( lS ( j ), prec ) enddo return endif temp1 = 0.0_real64 do j = 0 , this % N temp2 = bWeights ( j ) / ( sE - controlPoints ( j )) lS ( j ) = temp2 temp1 = temp1 + temp2 enddo lS = lS / temp1 do j = 0 , this % N lAtS ( j ) = real ( lS ( j ), prec ) enddo endfunction CalculateLagrangePolynomials","tags":"","loc":"proc/calculatelagrangepolynomials.html"},{"title":"CalculateBarycentricWeights – SELF","text":"public subroutine CalculateBarycentricWeights(this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this Contents Source Code CalculateBarycentricWeights Source Code subroutine CalculateBarycentricWeights ( this ) implicit none class ( Lagrange_t ), intent ( inout ) :: this ! Local integer :: i , j real ( real64 ) :: bWeights ( 0 : this % N ) real ( real64 ) :: controlPoints ( 0 : this % N ) do i = 0 , this % N bWeights ( i ) = 1.0_real64 controlPoints ( i ) = real ( this % controlPoints ( i + 1 ), real64 ) enddo ! Computes the product w_k = w_k*(s_k - s_j), k /= j do j = 1 , this % N do i = 0 , j - 1 bWeights ( i ) = bWeights ( i ) * ( controlPoints ( i ) - controlPoints ( j )) bWeights ( j ) = bWeights ( j ) * ( controlPoints ( j ) - controlPoints ( i )) enddo enddo do j = 0 , this % N bWeights ( j ) = 1.0_prec / bWeights ( j ) this % bWeights ( j + 1 ) = real ( bWeights ( j ), prec ) enddo endsubroutine CalculateBarycentricWeights","tags":"","loc":"proc/calculatebarycentricweights.html"},{"title":"CalculateDerivativeMatrix – SELF","text":"public subroutine CalculateDerivativeMatrix(this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this Contents Source Code CalculateDerivativeMatrix Source Code subroutine CalculateDerivativeMatrix ( this ) implicit none class ( Lagrange_t ), intent ( inout ) :: this ! Local integer :: row , col real ( real64 ) :: dmat ( 0 : this % N , 0 : this % N ) real ( real64 ) :: dgmat ( 0 : this % N , 0 : this % N ) real ( real64 ) :: bWeights ( 0 : this % N ) real ( real64 ) :: qWeights ( 0 : this % N ) real ( real64 ) :: controlPoints ( 0 : this % N ) do row = 0 , this % N bWeights ( row ) = real ( this % bWeights ( row + 1 ), real64 ) qWeights ( row ) = real ( this % qWeights ( row + 1 ), real64 ) controlPoints ( row ) = real ( this % controlPoints ( row + 1 ), real64 ) enddo do row = 0 , this % N dmat ( row , row ) = 0.0_prec do col = 0 , this % N if (. not .( col == row )) then dmat ( row , col ) = bWeights ( col ) / & ( bWeights ( row ) * & ( controlPoints ( row ) - & controlPoints ( col ))) dmat ( row , row ) = dmat ( row , row ) - dmat ( row , col ) endif enddo enddo do row = 0 , this % N do col = 0 , this % N dgmat ( row , col ) = - dmat ( col , row ) * & qWeights ( col ) / & qWeights ( row ) enddo enddo do row = 0 , this % N do col = 0 , this % N this % dMatrix ( row + 1 , col + 1 ) = real ( dmat ( col , row ), prec ) this % dgMatrix ( row + 1 , col + 1 ) = real ( dgmat ( col , row ), prec ) enddo enddo endsubroutine CalculateDerivativeMatrix","tags":"","loc":"proc/calculatederivativematrix.html"},{"title":"CalculateInterpolationMatrix – SELF","text":"public subroutine CalculateInterpolationMatrix(this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this Contents Source Code CalculateInterpolationMatrix Source Code subroutine CalculateInterpolationMatrix ( this ) implicit none class ( Lagrange_t ), intent ( inout ) :: this ! Local integer :: row , col logical :: rowHasMatch real ( real64 ) :: temp1 , temp2 real ( real64 ) :: iMatrix ( 0 : this % M , 0 : this % N ) real ( real64 ) :: bWeights ( 0 : this % N ) real ( real64 ) :: controlPoints ( 0 : this % N ) real ( real64 ) :: targetPoints ( 0 : this % M ) do col = 0 , this % N controlPoints ( col ) = real ( this % controlPoints ( col + 1 ), real64 ) bWeights ( col ) = real ( this % bWeights ( col + 1 ), real64 ) enddo do row = 0 , this % M targetPoints ( row ) = real ( this % targetPoints ( row + 1 ), real64 ) enddo do row = 0 , this % M rowHasMatch = . false . do col = 0 , this % N iMatrix ( row , col ) = 0.0_real64 if ( AlmostEqual ( targetPoints ( row ), controlPoints ( col ))) then rowHasMatch = . true . iMatrix ( row , col ) = 1.0_real64 endif enddo if (. not .( rowHasMatch )) then temp1 = 0.0_real64 do col = 0 , this % N temp2 = bWeights ( col ) / & ( targetPoints ( row ) - & controlPoints ( col )) iMatrix ( row , col ) = temp2 temp1 = temp1 + temp2 enddo do col = 0 , this % N iMatrix ( row , col ) = iMatrix ( row , col ) / temp1 enddo endif enddo do row = 0 , this % M do col = 0 , this % N this % iMatrix ( col + 1 , row + 1 ) = real ( iMatrix ( row , col ), prec ) enddo enddo endsubroutine CalculateInterpolationMatrix","tags":"","loc":"proc/calculateinterpolationmatrix.html"},{"title":"Free_Lagrange_t – SELF","text":"public subroutine Free_Lagrange_t(this) Frees all memory (host and device) associated with an instance of the Lagrange_t class Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this Lagrange_t class instance Contents Source Code Free_Lagrange_t Source Code subroutine Free_Lagrange_t ( this ) !! Frees all memory (host and device) associated with an instance of the Lagrange_t class implicit none class ( Lagrange_t ), intent ( inout ) :: this !! Lagrange_t class instance deallocate ( this % controlPoints ) deallocate ( this % targetPoints ) deallocate ( this % bWeights ) deallocate ( this % qWeights ) deallocate ( this % iMatrix ) deallocate ( this % dMatrix ) deallocate ( this % dgMatrix ) deallocate ( this % bMatrix ) endsubroutine Free_Lagrange_t","tags":"","loc":"proc/free_lagrange_t.html"},{"title":"Init_Lagrange_t – SELF","text":"public subroutine Init_Lagrange_t(this, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange_t class\nOn output, all of the attributes for the Lagrange_t class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange_t attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(out) :: this Lagrange_t class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) Contents Source Code Init_Lagrange_t Source Code subroutine Init_Lagrange_t ( this , N , controlNodeType , M , targetNodeType ) !! Initialize an instance of the Lagrange_t class !! On output, all of the attributes for the Lagrange_t class are allocated and values are initialized according to the number of !! control points, number of target points, and the types for the control and target nodes. !! If a GPU is available, device pointers for the Lagrange_t attributes are allocated and initialized. implicit none class ( Lagrange_t ), intent ( out ) :: this !! Lagrange_t class instance integer , intent ( in ) :: N !! The number of control points for interpolant integer , intent ( in ) :: M !! The number of target points for the interpolant integer , intent ( in ) :: controlNodeType !! The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) integer , intent ( in ) :: targetNodeType !! The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) ! -------! ! Local real ( prec ) :: q ( 0 : M ) this % N = N this % M = M this % controlNodeType = controlNodeType this % targetNodeType = targetNodeType allocate ( this % controlPoints ( 1 : N + 1 ), & this % targetPoints ( 1 : M + 1 ), & this % bWeights ( 1 : N + 1 ), & this % qWeights ( 1 : N + 1 ), & this % iMatrix ( 1 : N + 1 , 1 : M + 1 ), & this % dMatrix ( 1 : N + 1 , 1 : N + 1 ), & this % dgMatrix ( 1 : N + 1 , 1 : N + 1 ), & this % bMatrix ( 1 : N + 1 , 1 : 2 )) if ( controlNodeType == GAUSS . or . controlNodeType == GAUSS_LOBATTO ) then call LegendreQuadrature ( N , & this % controlPoints , & this % qWeights , & controlNodeType ) elseif ( controlNodeType == CHEBYSHEV_GAUSS . or . controlNodeType == CHEBYSHEV_GAUSS_LOBATTO ) then call ChebyshevQuadrature ( N , & this % controlPoints , & this % qWeights , & controlNodeType ) elseif ( controlNodeType == UNIFORM ) then this % controlPoints = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , N ) this % qWeights = 2.0_prec / real ( N , prec ) endif ! Target Points if ( targetNodeType == GAUSS . or . targetNodeType == GAUSS_LOBATTO ) then call LegendreQuadrature ( M , & this % targetPoints , & q , & targetNodeType ) elseif ( targetNodeType == UNIFORM ) then this % targetPoints = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , M ) endif call this % CalculateBarycentricWeights () call this % CalculateInterpolationMatrix () call this % CalculateDerivativeMatrix () this % bMatrix ( 1 : N + 1 , 1 ) = this % CalculateLagrangePolynomials ( - 1.0_prec ) this % bMatrix ( 1 : N + 1 , 2 ) = this % CalculateLagrangePolynomials ( 1.0_prec ) endsubroutine Init_Lagrange_t","tags":"","loc":"proc/init_lagrange_t.html"},{"title":"WriteHDF5_Lagrange_t – SELF","text":"public subroutine WriteHDF5_Lagrange_t(this, fileId) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId Contents Source Code WriteHDF5_Lagrange_t Source Code subroutine WriteHDF5_Lagrange_t ( this , fileId ) implicit none class ( Lagrange_t ), intent ( in ) :: this integer ( HID_T ), intent ( in ) :: fileId call CreateGroup_HDF5 ( fileId , '/interp' ) call WriteArray_HDF5 ( fileId , '/interp/controlpoints' , & this % controlPoints ) call WriteArray_HDF5 ( fileId , '/interp/qweights' , & this % qWeights ) call WriteArray_HDF5 ( fileId , '/interp/dgmatrix' , & this % dgMatrix ) call WriteArray_HDF5 ( fileId , '/interp/dmatrix' , & this % dMatrix ) call WriteArray_HDF5 ( fileId , '/interp/bmatrix' , & this % bMatrix ) call WriteArray_HDF5 ( fileId , '/interp/imatrix' , & this % iMatrix ) endsubroutine WriteHDF5_Lagrange_t","tags":"","loc":"proc/writehdf5_lagrange_t.html"},{"title":"ApplyFlip_MappedVector2D_t – SELF","text":"public subroutine ApplyFlip_MappedVector2D_t(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( Mesh2D ), intent(in) :: mesh Contents Source Code ApplyFlip_MappedVector2D_t Source Code subroutine ApplyFlip_MappedVector2D_t ( this , mesh ) ! Apply side flips to sides where MPI exchanges took place. implicit none class ( MappedVector2D_t ), intent ( inout ) :: this type ( Mesh2D ), intent ( in ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 integer :: i , i2 integer :: r2 , flip , ivar , idir real ( prec ) :: extBuff ( 1 : this % interp % N + 1 ) do idir = 1 , 2 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 4 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element (global id) if ( e2 > 0 ) then ! Interior Element r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 ! Need to update extBoundary with flip applied if ( flip == 1 ) then do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i extBuff ( i ) = this % extBoundary ( i2 , s1 , e1 , ivar , idir ) enddo do i = 1 , this % interp % N + 1 this % extBoundary ( i , s1 , e1 , ivar , idir ) = extBuff ( i ) enddo endif endif endif enddo enddo enddo enddo endsubroutine ApplyFlip_MappedVector2D_t","tags":"","loc":"proc/applyflip_mappedvector2d_t.html"},{"title":"AssociateGeometry_MappedVector2D_t – SELF","text":"public subroutine AssociateGeometry_MappedVector2D_t(this, geometry) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( SEMQuad ), intent(in), target :: geometry Contents Source Code AssociateGeometry_MappedVector2D_t Source Code subroutine AssociateGeometry_MappedVector2D_t ( this , geometry ) implicit none class ( MappedVector2D_t ), intent ( inout ) :: this type ( SEMQuad ), target , intent ( in ) :: geometry if (. not . associated ( this % geometry )) then this % geometry => geometry this % geometry_associated = . true . endif endsubroutine AssociateGeometry_MappedVector2D_t","tags":"","loc":"proc/associategeometry_mappedvector2d_t.html"},{"title":"DissociateGeometry_MappedVector2D_t – SELF","text":"public subroutine DissociateGeometry_MappedVector2D_t(this) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this Contents Source Code DissociateGeometry_MappedVector2D_t Source Code subroutine DissociateGeometry_MappedVector2D_t ( this ) implicit none class ( MappedVector2D_t ), intent ( inout ) :: this if ( associated ( this % geometry )) then this % geometry => null () this % geometry_associated = . false . endif endsubroutine DissociateGeometry_MappedVector2D_t","tags":"","loc":"proc/dissociategeometry_mappedvector2d_t.html"},{"title":"MPIExchangeAsync_MappedVector2D_t – SELF","text":"public subroutine MPIExchangeAsync_MappedVector2D_t(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh Contents Source Code MPIExchangeAsync_MappedVector2D_t Source Code subroutine MPIExchangeAsync_MappedVector2D_t ( this , mesh ) implicit none class ( MappedVector2D_t ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar , idir integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount msgCount = 0 do idir = 1 , 2 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 4 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) ! create unique tag for each side and each variable tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 + this % nvar * ( idir - 1 )) msgCount = msgCount + 1 call MPI_IRECV ( this % extBoundary (:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( this % boundary (:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedVector2D_t","tags":"","loc":"proc/mpiexchangeasync_mappedvector2d_t.html"},{"title":"MappedDGDivergence_MappedVector2D_t – SELF","text":"public subroutine MappedDGDivergence_MappedVector2D_t(this, df) Computes the divergence of a 2-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(in) :: this real(kind=prec) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) Contents Source Code MappedDGDivergence_MappedVector2D_t Source Code subroutine MappedDGDivergence_MappedVector2D_t ( this , df ) !! Computes the divergence of a 2-D vector using the weak form !! On input, the  attribute of the vector !! is assigned and the  attribute is set to the physical !! directions of the vector. This method will project the vector !! onto the contravariant basis vectors. implicit none class ( MappedVector2D_t ), intent ( in ) :: this real ( prec ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , j , ii real ( prec ) :: dfLoc , Fx , Fy , Fc do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( ii , j , iEl , iVar , 1 ) Fy = this % interior ( ii , j , iEl , iVar , 2 ) Fc = this % geometry % dsdx % interior ( ii , j , iEl , 1 , 1 , 1 ) * Fx + & this % geometry % dsdx % interior ( ii , j , iEl , 1 , 2 , 1 ) * Fy dfLoc = dfLoc + this % interp % dgMatrix ( ii , i ) * Fc enddo dF ( i , j , iel , ivar ) = dfLoc + & ( this % interp % bMatrix ( i , 2 ) * this % boundaryNormal ( j , 2 , iel , ivar ) + & this % interp % bMatrix ( i , 1 ) * this % boundaryNormal ( j , 4 , iel , ivar )) / & this % interp % qweights ( i ) enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( i , ii , iEl , iVar , 1 ) Fy = this % interior ( i , ii , iEl , iVar , 2 ) Fc = this % geometry % dsdx % interior ( i , ii , iEl , 1 , 1 , 2 ) * Fx + & this % geometry % dsdx % interior ( i , ii , iEl , 1 , 2 , 2 ) * Fy dfLoc = dfLoc + this % interp % dgMatrix ( ii , j ) * Fc enddo dfLoc = dfLoc + & ( this % interp % bMatrix ( j , 2 ) * this % boundaryNormal ( i , 3 , iel , ivar ) + & this % interp % bMatrix ( j , 1 ) * this % boundaryNormal ( i , 1 , iel , ivar )) / & this % interp % qweights ( j ) dF ( i , j , iel , ivar ) = ( dF ( i , j , iel , ivar ) + dfLoc ) / this % geometry % J % interior ( i , j , iEl , 1 ) enddo endsubroutine MappedDGDivergence_MappedVector2D_t","tags":"","loc":"proc/mappeddgdivergence_mappedvector2d_t.html"},{"title":"MappedDivergence_MappedVector2D_t – SELF","text":"public subroutine MappedDivergence_MappedVector2D_t(this, df) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) Contents Source Code MappedDivergence_MappedVector2D_t Source Code subroutine MappedDivergence_MappedVector2D_t ( this , df ) ! Strong Form Operator !    ! implicit none class ( MappedVector2D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , j , ii real ( prec ) :: dfLoc , Fx , Fy , Fc do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( ii , j , iEl , iVar , 1 ) Fy = this % interior ( ii , j , iEl , iVar , 2 ) Fc = this % geometry % dsdx % interior ( ii , j , iEl , 1 , 1 , 1 ) * Fx + & this % geometry % dsdx % interior ( ii , j , iEl , 1 , 2 , 1 ) * Fy dfLoc = dfLoc + this % interp % dMatrix ( ii , i ) * Fc enddo dF ( i , j , iel , ivar ) = dfLoc enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( i , ii , iEl , iVar , 1 ) Fy = this % interior ( i , ii , iEl , iVar , 2 ) Fc = this % geometry % dsdx % interior ( i , ii , iEl , 1 , 1 , 2 ) * Fx + & this % geometry % dsdx % interior ( i , ii , iEl , 1 , 2 , 2 ) * Fy dfLoc = dfLoc + this % interp % dMatrix ( ii , j ) * Fc enddo dF ( i , j , iel , ivar ) = ( dF ( i , j , iel , ivar ) + dfLoc ) / this % geometry % J % interior ( i , j , iEl , 1 ) enddo endsubroutine MappedDivergence_MappedVector2D_t","tags":"","loc":"proc/mappeddivergence_mappedvector2d_t.html"},{"title":"SetInteriorFromEquation_MappedVector2D_t – SELF","text":"public subroutine SetInteriorFromEquation_MappedVector2D_t(this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time Contents Source Code SetInteriorFromEquation_MappedVector2D_t Source Code subroutine SetInteriorFromEquation_MappedVector2D_t ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedVector2D_t ), intent ( inout ) :: this type ( SEMQuad ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , iEl , iVar real ( prec ) :: x real ( prec ) :: y do iVar = 1 , this % nVar do iEl = 1 , this % nElem do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , iEl , 1 , 2 ) this % interior ( i , j , iEl , iVar , 1 ) = & this % eqn ( 1 + 2 * ( iVar - 1 ))% Evaluate (( / x , y , 0.0_prec , time / )) this % interior ( i , j , iEl , iVar , 2 ) = & this % eqn ( 2 + 2 * ( iVar - 1 ))% Evaluate (( / x , y , 0.0_prec , time / )) enddo enddo enddo enddo endsubroutine SetInteriorFromEquation_MappedVector2D_t","tags":"","loc":"proc/setinteriorfromequation_mappedvector2d_t.html"},{"title":"SideExchange_MappedVector2D_t – SELF","text":"public subroutine SideExchange_MappedVector2D_t(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh Contents Source Code SideExchange_MappedVector2D_t Source Code subroutine SideExchange_MappedVector2D_t ( this , mesh ) implicit none class ( MappedVector2D_t ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: e1 , e2 , s1 , s2 , e2Global integer :: flip , bcid integer :: i1 , i2 , ivar , idir integer :: r2 integer :: rankId , offset integer , pointer :: elemtorank (:) ! This mapping is needed to resolve a build error with ! amdflang that appears to be caused by referencing ! the elemToRank attribute within the do concurrent ! https://github.com/FluidNumerics/SELF/issues/54 elemtorank => mesh % decomp % elemToRank (:) rankId = mesh % decomp % rankId offset = mesh % decomp % offsetElem ( rankId + 1 ) if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif do concurrent ( s1 = 1 : 4 , e1 = 1 : mesh % nElem , ivar = 1 : this % nvar , idir = 1 : 2 ) e2Global = mesh % sideInfo ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % sideInfo ( 5 , s1 , e1 ) if ( e2Global > 0 ) then r2 = elemToRank ( e2Global ) ! Neighbor rank if ( r2 == mesh % decomp % rankId ) then if ( flip == 0 ) then do i1 = 1 , this % interp % N + 1 this % extBoundary ( i1 , s1 , e1 , ivar , idir ) = & this % boundary ( i1 , s2 , e2 , ivar , idir ) enddo elseif ( flip == 1 ) then do i1 = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i1 this % extBoundary ( i1 , s1 , e1 , ivar , idir ) = & this % boundary ( i2 , s2 , e2 , ivar , idir ) enddo endif endif endif enddo if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call this % ApplyFlip ( mesh ) endif endsubroutine SideExchange_MappedVector2D_t","tags":"","loc":"proc/sideexchange_mappedvector2d_t.html"},{"title":"AverageSides_Vector3D_t – SELF","text":"public subroutine AverageSides_Vector3D_t(this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this Contents Source Code AverageSides_Vector3D_t Source Code subroutine AverageSides_Vector3D_t ( this ) implicit none class ( Vector3D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: iside integer :: ivar integer :: i , j integer :: idir do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & iside = 1 : 6 , iel = 1 : this % nelem , ivar = 1 : this % nvar , & idir = 1 : 3 ) this % boundary ( i , j , iside , iel , ivar , idir ) = 0.5_prec * ( & this % boundary ( i , j , iside , iel , ivar , idir ) + & this % extBoundary ( i , j , iside , iel , ivar , idir )) enddo endsubroutine AverageSides_Vector3D_t","tags":"","loc":"proc/averagesides_vector3d_t.html"},{"title":"BoundaryInterp_Vector3D_t – SELF","text":"public subroutine BoundaryInterp_Vector3D_t(this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this Contents Source Code BoundaryInterp_Vector3D_t Source Code subroutine BoundaryInterp_Vector3D_t ( this ) implicit none class ( Vector3D_t ), intent ( inout ) :: this ! Local integer :: i , j , ii , idir , iel , ivar real ( prec ) :: fbb , fbs , fbe , fbn , fbw , fbt do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) fbb = 0.0_prec fbs = 0.0_prec fbe = 0.0_prec fbn = 0.0_prec fbw = 0.0_prec fbt = 0.0_prec do ii = 1 , this % N + 1 fbb = fbb + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , j , ii , iel , ivar , idir ) ! Bottom fbs = fbs + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , ii , j , iel , ivar , idir ) ! South fbe = fbe + this % interp % bMatrix ( ii , 2 ) * this % interior ( ii , i , j , iel , ivar , idir ) ! East fbn = fbn + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , ii , j , iel , ivar , idir ) ! North fbw = fbw + this % interp % bMatrix ( ii , 1 ) * this % interior ( ii , i , j , iel , ivar , idir ) ! West fbt = fbt + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , j , ii , iel , ivar , idir ) ! Top enddo this % boundary ( i , j , 1 , iel , ivar , idir ) = fbb this % boundary ( i , j , 2 , iel , ivar , idir ) = fbs this % boundary ( i , j , 3 , iel , ivar , idir ) = fbe this % boundary ( i , j , 4 , iel , ivar , idir ) = fbn this % boundary ( i , j , 5 , iel , ivar , idir ) = fbw this % boundary ( i , j , 6 , iel , ivar , idir ) = fbt enddo endsubroutine BoundaryInterp_Vector3D_t","tags":"","loc":"proc/boundaryinterp_vector3d_t.html"},{"title":"Curl_Vector3D_t – SELF","text":"public subroutine Curl_Vector3D_t(this, curlf) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: curlf (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) Contents Source Code Curl_Vector3D_t Source Code subroutine Curl_Vector3D_t ( this , curlf ) implicit none class ( Vector3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: curlf ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 3 ) ! Local integer :: i , j , k , ii , idir , iel , ivar real ( prec ) :: dfds1 , dfds2 , dfds3 real ( prec ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 3 , 1 : 3 ) do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , & idir = 1 : 3 ) dfds1 = 0.0_prec dfds2 = 0.0_prec dfds3 = 0.0_prec do ii = 1 , this % N + 1 dfds1 = dfds1 + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , k , iel , ivar , idir ) dfds2 = dfds2 + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , k , iel , ivar , idir ) dfds3 = dfds3 + this % interp % dMatrix ( ii , k ) * this % interior ( i , j , ii , iel , ivar , idir ) enddo df ( i , j , k , iel , ivar , idir , 1 ) = dfds1 df ( i , j , k , iel , ivar , idir , 2 ) = dfds2 df ( i , j , k , iel , ivar , idir , 3 ) = dfds3 enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) curlf ( i , j , k , iel , ivar , 1 ) = ( df ( i , j , k , iel , ivar , 3 , 2 ) - df ( i , j , k , iel , ivar , 2 , 3 )) curlf ( i , j , k , iel , ivar , 2 ) = ( df ( i , j , k , iel , ivar , 1 , 3 ) - df ( i , j , k , iel , ivar , 3 , 1 )) curlf ( i , j , k , iel , ivar , 3 ) = ( df ( i , j , k , iel , ivar , 2 , 1 ) - df ( i , j , k , iel , ivar , 1 , 2 )) enddo endsubroutine Curl_Vector3D_t","tags":"","loc":"proc/curl_vector3d_t.html"},{"title":"Divergence_Vector3D_t – SELF","text":"public subroutine Divergence_Vector3D_t(this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) Contents Source Code Divergence_Vector3D_t Source Code subroutine Divergence_Vector3D_t ( this , df ) implicit none class ( Vector3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: i , j , k , ii , iel , ivar real ( prec ) :: dfLoc do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 dfLoc = dfLoc + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , k , iel , ivar , 1 ) enddo dF ( i , j , k , iel , ivar ) = dfLoc enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 dfLoc = dfLoc + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , k , iel , ivar , 2 ) enddo dF ( i , j , k , iel , ivar ) = dF ( i , j , k , iel , ivar ) + dfLoc enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 dfLoc = dfLoc + this % interp % dMatrix ( ii , k ) * this % interior ( i , j , ii , iel , ivar , 3 ) enddo dF ( i , j , k , iel , ivar ) = dF ( i , j , k , iel , ivar ) + dfLoc enddo endsubroutine Divergence_Vector3D_t","tags":"","loc":"proc/divergence_vector3d_t.html"},{"title":"Free_Vector3D_t – SELF","text":"public subroutine Free_Vector3D_t(this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this Contents Source Code Free_Vector3D_t Source Code subroutine Free_Vector3D_t ( this ) implicit none class ( Vector3D_t ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % boundaryNormal ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) endsubroutine Free_Vector3D_t","tags":"","loc":"proc/free_vector3d_t.html"},{"title":"Gradient_Vector3D_t – SELF","text":"public subroutine Gradient_Vector3D_t(this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3,1:3) Contents Source Code Gradient_Vector3D_t Source Code subroutine Gradient_Vector3D_t ( this , df ) implicit none class ( Vector3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 3 , 1 : 3 ) ! Local integer :: i , j , k , ii , idir , iel , ivar real ( prec ) :: dfds1 , dfds2 , dfds3 do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , & idir = 1 : 3 ) dfds1 = 0.0_prec dfds2 = 0.0_prec dfds3 = 0.0_prec do ii = 1 , this % N + 1 dfds1 = dfds1 + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , k , iel , ivar , idir ) dfds2 = dfds2 + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , k , iel , ivar , idir ) dfds3 = dfds3 + this % interp % dMatrix ( ii , k ) * this % interior ( i , j , ii , iel , ivar , idir ) enddo df ( i , j , k , iel , ivar , idir , 1 ) = dfds1 df ( i , j , k , iel , ivar , idir , 2 ) = dfds2 df ( i , j , k , iel , ivar , idir , 3 ) = dfds3 enddo endsubroutine Gradient_Vector3D_t","tags":"","loc":"proc/gradient_vector3d_t.html"},{"title":"GridInterp_Vector3D_t – SELF","text":"public subroutine GridInterp_Vector3D_t(this, f) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:3) (Output) Array of function values, defined on the target grid Contents Source Code GridInterp_Vector3D_t Source Code subroutine GridInterp_Vector3D_t ( this , f ) implicit none class ( Vector3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: f ( 1 : this % M + 1 , 1 : this % M + 1 , 1 : this % M + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 3 ) !! (Output) Array of function values, defined on the target grid ! Local integer :: i , j , k , ii , jj , kk , iel , ivar , idir real ( prec ) :: fi , fij , fijk do concurrent ( i = 1 : this % M + 1 , j = 1 : this % M + 1 , & k = 1 : this % M + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) fijk = 0.0_prec do kk = 1 , this % N + 1 fij = 0.0_prec do jj = 1 , this % N + 1 fi = 0.0_prec do ii = 1 , this % N + 1 fi = fi + this % interior ( ii , jj , kk , iel , ivar , idir ) * this % interp % iMatrix ( ii , i ) enddo fij = fij + fi * this % interp % iMatrix ( jj , j ) enddo fijk = fijk + fij * this % interp % iMatrix ( kk , k ) enddo f ( i , j , k , iel , ivar , idir ) = fijk enddo endsubroutine GridInterp_Vector3D_t","tags":"","loc":"proc/gridinterp_vector3d_t.html"},{"title":"Init_Vector3D_t – SELF","text":"public subroutine Init_Vector3D_t(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Vector3D_t Source Code subroutine Init_Vector3D_t ( this , interp , nVar , nElem ) implicit none class ( Vector3D_t ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % boundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % boundaryNormal ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 3 * nVar )) ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 3 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo this % interior = 0.0_prec this % boundary = 0.0_prec this % boundarynormal = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec endsubroutine Init_Vector3D_t","tags":"","loc":"proc/init_vector3d_t.html"},{"title":"SetEquation_Vector3D_t – SELF","text":"public subroutine SetEquation_Vector3D_t(this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar Contents Source Code SetEquation_Vector3D_t Source Code subroutine SetEquation_Vector3D_t ( this , idir , ivar , eqnChar ) !! Sets the equation parser for the `idir` direction and `ivar-th` variable implicit none class ( Vector3D_t ), intent ( inout ) :: this integer , intent ( in ) :: idir , ivar character ( * ), intent ( in ) :: eqnChar this % eqn ( idir + 3 * ( ivar - 1 )) = EquationParser ( trim ( eqnChar ), & ( / 'x' , 'y' , 'z' , 't' / )) endsubroutine SetEquation_Vector3D_t","tags":"","loc":"proc/setequation_vector3d_t.html"},{"title":"UpdateDevice_Vector3D_t – SELF","text":"public subroutine UpdateDevice_Vector3D_t(this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this Contents Source Code UpdateDevice_Vector3D_t Source Code subroutine UpdateDevice_Vector3D_t ( this ) implicit none class ( Vector3D_t ), intent ( inout ) :: this endsubroutine UpdateDevice_Vector3D_t","tags":"","loc":"proc/updatedevice_vector3d_t.html"},{"title":"UpdateHost_Vector3D_t – SELF","text":"public subroutine UpdateHost_Vector3D_t(this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this Contents Source Code UpdateHost_Vector3D_t Source Code subroutine UpdateHost_Vector3D_t ( this ) implicit none class ( Vector3D_t ), intent ( inout ) :: this endsubroutine UpdateHost_Vector3D_t","tags":"","loc":"proc/updatehost_vector3d_t.html"},{"title":"WriteHDF5_MPI_Vector3D_t – SELF","text":"public subroutine WriteHDF5_MPI_Vector3D_t(this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem Contents Source Code WriteHDF5_MPI_Vector3D_t Source Code subroutine WriteHDF5_MPI_Vector3D_t ( this , fileId , group , elemoffset , nglobalelem ) implicit none class ( Vector3D_t ), intent ( in ) :: this character ( * ), intent ( in ) :: group integer ( HID_T ), intent ( in ) :: fileId integer , intent ( in ) :: elemoffset integer , intent ( in ) :: nglobalelem ! Local integer ( HID_T ) :: offset ( 1 : 4 ) integer ( HID_T ) :: globalDims ( 1 : 4 ) integer :: ivar , idir character ( 4 ) :: dimvar offset ( 1 : 4 ) = ( / 0 , 0 , 0 , elemoffset / ) globalDims ( 1 : 4 ) = ( / this % interp % N + 1 , & this % interp % N + 1 , & this % interp % N + 1 , & nglobalelem / ) call CreateGroup_HDF5 ( fileId , trim ( group )) do idir = 1 , 3 write ( dimvar , '(I1)' ) idir dimvar = \"dim\" // trim ( dimvar ) do ivar = 1 , this % nVar call WriteArray_HDF5 ( fileId , & trim ( group ) // \"/\" // trim ( this % meta ( ivar )% name ) // \"_\" // dimvar , & this % interior (:,:,:,:, ivar , idir ), offset , globalDims ) enddo enddo endsubroutine WriteHDF5_MPI_Vector3D_t","tags":"","loc":"proc/writehdf5_mpi_vector3d_t.html"},{"title":"WriteHDF5_Vector3D_t – SELF","text":"public subroutine WriteHDF5_Vector3D_t(this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Contents Source Code WriteHDF5_Vector3D_t Source Code subroutine WriteHDF5_Vector3D_t ( this , fileId , group ) implicit none class ( Vector3D_t ), intent ( in ) :: this integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: group ! Local integer :: ivar , idir character ( 4 ) :: dimvar call CreateGroup_HDF5 ( fileId , trim ( group )) do ivar = 1 , this % nVar call this % meta ( ivar )% WriteHDF5 ( group , ivar , fileId ) enddo do idir = 1 , 3 write ( dimvar , '(I1)' ) idir dimvar = \"dim\" // trim ( dimvar ) do ivar = 1 , this % nVar call WriteArray_HDF5 ( fileId , & trim ( group ) // \"/\" // trim ( this % meta ( ivar )% name ) // \"_\" // dimvar , & this % interior (:,:,:,:, ivar , idir )) enddo enddo endsubroutine WriteHDF5_Vector3D_t","tags":"","loc":"proc/writehdf5_vector3d_t.html"},{"title":"AverageSides_Scalar3D_t – SELF","text":"public subroutine AverageSides_Scalar3D_t(this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this Contents Source Code AverageSides_Scalar3D_t Source Code subroutine AverageSides_Scalar3D_t ( this ) implicit none class ( Scalar3D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: iside integer :: ivar integer :: i , j do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & iside = 1 : 6 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) this % avgboundary ( i , j , iside , iel , ivar ) = 0.5_prec * ( & this % boundary ( i , j , iside , iel , ivar ) + & this % extBoundary ( i , j , iside , iel , ivar )) enddo endsubroutine AverageSides_Scalar3D_t","tags":"","loc":"proc/averagesides_scalar3d_t.html"},{"title":"BoundaryInterp_Scalar3D_t – SELF","text":"public subroutine BoundaryInterp_Scalar3D_t(this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this Contents Source Code BoundaryInterp_Scalar3D_t Source Code subroutine BoundaryInterp_Scalar3D_t ( this ) implicit none class ( Scalar3D_t ), intent ( inout ) :: this ! Local integer :: i , j , ii , iel , ivar real ( prec ) :: fbb , fbs , fbe , fbn , fbw , fbt do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & iel = 1 : this % nelem , ivar = 1 : this % nvar ) fbb = 0.0_prec fbs = 0.0_prec fbe = 0.0_prec fbn = 0.0_prec fbw = 0.0_prec fbt = 0.0_prec do ii = 1 , this % N + 1 fbb = fbb + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , j , ii , iel , ivar ) ! Bottom fbs = fbs + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , ii , j , iel , ivar ) ! South fbe = fbe + this % interp % bMatrix ( ii , 2 ) * this % interior ( ii , i , j , iel , ivar ) ! East fbn = fbn + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , ii , j , iel , ivar ) ! North fbw = fbw + this % interp % bMatrix ( ii , 1 ) * this % interior ( ii , i , j , iel , ivar ) ! West fbt = fbt + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , j , ii , iel , ivar ) ! Top enddo this % boundary ( i , j , 1 , iel , ivar ) = fbb this % boundary ( i , j , 2 , iel , ivar ) = fbs this % boundary ( i , j , 3 , iel , ivar ) = fbe this % boundary ( i , j , 4 , iel , ivar ) = fbn this % boundary ( i , j , 5 , iel , ivar ) = fbw this % boundary ( i , j , 6 , iel , ivar ) = fbt enddo endsubroutine BoundaryInterp_Scalar3D_t","tags":"","loc":"proc/boundaryinterp_scalar3d_t.html"},{"title":"Free_Scalar3D_t – SELF","text":"public subroutine Free_Scalar3D_t(this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this Contents Source Code Free_Scalar3D_t Source Code subroutine Free_Scalar3D_t ( this ) implicit none class ( Scalar3D_t ), intent ( inout ) :: this this % nVar = 0 this % nElem = 0 this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % boundarynormal ) deallocate ( this % meta ) deallocate ( this % eqn ) endsubroutine Free_Scalar3D_t","tags":"","loc":"proc/free_scalar3d_t.html"},{"title":"Gradient_Scalar3D_t – SELF","text":"public subroutine Gradient_Scalar3D_t(this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) Contents Source Code Gradient_Scalar3D_t Source Code subroutine Gradient_Scalar3D_t ( this , df ) implicit none class ( Scalar3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 3 ) ! Local integer :: i , j , k , ii , iel , ivar real ( prec ) :: df1 , df2 , df3 do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) df1 = 0.0_prec df2 = 0.0_prec df3 = 0.0_prec do ii = 1 , this % N + 1 df1 = df1 + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , k , iel , ivar ) df2 = df2 + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , k , iel , ivar ) df3 = df3 + this % interp % dMatrix ( ii , k ) * this % interior ( i , j , ii , iel , ivar ) enddo df ( i , j , k , iel , ivar , 1 ) = df1 df ( i , j , k , iel , ivar , 2 ) = df2 df ( i , j , k , iel , ivar , 3 ) = df3 enddo endsubroutine Gradient_Scalar3D_t","tags":"","loc":"proc/gradient_scalar3d_t.html"},{"title":"GridInterp_Scalar3D_t – SELF","text":"public subroutine GridInterp_Scalar3D_t(this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) (Output) Array of function values, defined on the target grid Contents Source Code GridInterp_Scalar3D_t Source Code subroutine GridInterp_Scalar3D_t ( this , f ) implicit none class ( Scalar3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: f ( 1 : this % M + 1 , 1 : this % M + 1 , 1 : this % M + 1 , 1 : this % nelem , 1 : this % nvar ) !! (Output) Array of function values, defined on the target grid ! Local integer :: i , j , k , ii , jj , kk , iel , ivar real ( prec ) :: fi , fij , fijk do concurrent ( i = 1 : this % M + 1 , j = 1 : this % M + 1 , & k = 1 : this % M + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) fijk = 0.0_prec do kk = 1 , this % N + 1 fij = 0.0_prec do jj = 1 , this % N + 1 fi = 0.0_prec do ii = 1 , this % N + 1 fi = fi + this % interior ( ii , jj , kk , iel , ivar ) * this % interp % iMatrix ( ii , i ) enddo fij = fij + fi * this % interp % iMatrix ( jj , j ) enddo fijk = fijk + fij * this % interp % iMatrix ( kk , k ) enddo f ( i , j , k , iel , ivar ) = fijk enddo endsubroutine GridInterp_Scalar3D_t","tags":"","loc":"proc/gridinterp_scalar3d_t.html"},{"title":"Init_Scalar3D_t – SELF","text":"public subroutine Init_Scalar3D_t(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar3D_t Source Code subroutine Init_Scalar3D_t ( this , interp , nVar , nElem ) implicit none class ( Scalar3D_t ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar ), & this % boundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : 3 * nvar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec this % boundarynormal = 0.0_prec allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) endsubroutine Init_Scalar3D_t","tags":"","loc":"proc/init_scalar3d_t.html"},{"title":"UpdateDevice_Scalar3D_t – SELF","text":"public subroutine UpdateDevice_Scalar3D_t(this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this Contents Source Code UpdateDevice_Scalar3D_t Source Code subroutine UpdateDevice_Scalar3D_t ( this ) implicit none class ( Scalar3D_t ), intent ( inout ) :: this endsubroutine UpdateDevice_Scalar3D_t","tags":"","loc":"proc/updatedevice_scalar3d_t.html"},{"title":"UpdateHost_Scalar3D_t – SELF","text":"public subroutine UpdateHost_Scalar3D_t(this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this Contents Source Code UpdateHost_Scalar3D_t Source Code subroutine UpdateHost_Scalar3D_t ( this ) implicit none class ( Scalar3D_t ), intent ( inout ) :: this endsubroutine UpdateHost_Scalar3D_t","tags":"","loc":"proc/updatehost_scalar3d_t.html"},{"title":"WriteHDF5_MPI_Scalar3D_t – SELF","text":"public subroutine WriteHDF5_MPI_Scalar3D_t(this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem Contents Source Code WriteHDF5_MPI_Scalar3D_t Source Code subroutine WriteHDF5_MPI_Scalar3D_t ( this , fileId , group , elemoffset , nglobalelem ) implicit none class ( Scalar3D_t ), intent ( in ) :: this character ( * ), intent ( in ) :: group integer ( HID_T ), intent ( in ) :: fileId integer , intent ( in ) :: elemoffset integer , intent ( in ) :: nglobalelem ! Local integer ( HID_T ) :: offset ( 1 : 4 ) integer ( HID_T ) :: globalDims ( 1 : 4 ) integer :: ivar offset ( 1 : 4 ) = ( / 0 , 0 , 0 , elemoffset / ) globalDims ( 1 : 4 ) = ( / this % interp % N + 1 , & this % interp % N + 1 , & this % interp % N + 1 , & nglobalelem / ) call CreateGroup_HDF5 ( fileId , trim ( group )) do ivar = 1 , this % nVar !call this%meta(ivar)%WriteHDF5(group,ivar,fileId) call WriteArray_HDF5 ( fileId , & trim ( group ) // \"/\" // trim ( this % meta ( ivar )% name ), & this % interior (:,:,:,:, ivar ), offset , globalDims ) enddo endsubroutine WriteHDF5_MPI_Scalar3D_t","tags":"","loc":"proc/writehdf5_mpi_scalar3d_t.html"},{"title":"WriteHDF5_Scalar3D_t – SELF","text":"public subroutine WriteHDF5_Scalar3D_t(this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Contents Source Code WriteHDF5_Scalar3D_t Source Code subroutine WriteHDF5_Scalar3D_t ( this , fileId , group ) implicit none class ( Scalar3D_t ), intent ( in ) :: this integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: group ! Local integer :: ivar call CreateGroup_HDF5 ( fileId , trim ( group )) do ivar = 1 , this % nVar call this % meta ( ivar )% WriteHDF5 ( group , ivar , fileId ) call WriteArray_HDF5 ( fileId , & trim ( group ) // trim ( this % meta ( ivar )% name ), & this % interior (:,:,:,:, ivar )) enddo endsubroutine WriteHDF5_Scalar3D_t","tags":"","loc":"proc/writehdf5_scalar3d_t.html"},{"title":"BoundaryInterp_Tensor2D_t – SELF","text":"public subroutine BoundaryInterp_Tensor2D_t(this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this Contents Source Code BoundaryInterp_Tensor2D_t Source Code subroutine BoundaryInterp_Tensor2D_t ( this ) implicit none class ( Tensor2D_t ), intent ( inout ) :: this ! Local integer :: i , ii , idir , jdir , iel , ivar real ( prec ) :: fbs , fbe , fbn , fbw do concurrent ( i = 1 : this % N + 1 , & iel = 1 : this % nelem , ivar = 1 : this % nvar , & idir = 1 : 2 , jdir = 1 : 2 ) fbs = 0.0_prec fbe = 0.0_prec fbn = 0.0_prec fbw = 0.0_prec do ii = 1 , this % N + 1 fbs = fbs + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , ii , iel , ivar , idir , jdir ) ! South fbe = fbe + this % interp % bMatrix ( ii , 2 ) * this % interior ( ii , i , iel , ivar , idir , jdir ) ! East fbn = fbn + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , ii , iel , ivar , idir , jdir ) ! North fbw = fbw + this % interp % bMatrix ( ii , 1 ) * this % interior ( ii , i , iel , ivar , idir , jdir ) ! West enddo this % boundary ( i , 1 , iel , ivar , idir , jdir ) = fbs this % boundary ( i , 2 , iel , ivar , idir , jdir ) = fbe this % boundary ( i , 3 , iel , ivar , idir , jdir ) = fbn this % boundary ( i , 4 , iel , ivar , idir , jdir ) = fbw enddo endsubroutine BoundaryInterp_Tensor2D_t","tags":"","loc":"proc/boundaryinterp_tensor2d_t.html"},{"title":"Determinant_Tensor2D_t – SELF","text":"public subroutine Determinant_Tensor2D_t(this, det) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(in) :: this real(kind=prec), intent(out) :: det (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) Contents Source Code Determinant_Tensor2D_t Source Code subroutine Determinant_Tensor2D_t ( this , det ) implicit none class ( Tensor2D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: det ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , j do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & iel = 1 : this % nelem , ivar = 1 : this % nvar ) det ( i , j , iEl , iVar ) = this % interior ( i , j , iEl , iVar , 1 , 1 ) * & this % interior ( i , j , iEl , iVar , 2 , 2 ) - & this % interior ( i , j , iEl , iVar , 1 , 2 ) * & this % interior ( i , j , iEl , iVar , 2 , 1 ) enddo endsubroutine Determinant_Tensor2D_t","tags":"","loc":"proc/determinant_tensor2d_t.html"},{"title":"Free_Tensor2D_t – SELF","text":"public subroutine Free_Tensor2D_t(this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this Contents Source Code Free_Tensor2D_t Source Code subroutine Free_Tensor2D_t ( this ) implicit none class ( Tensor2D_t ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) endsubroutine Free_Tensor2D_t","tags":"","loc":"proc/free_tensor2d_t.html"},{"title":"Init_Tensor2D_t – SELF","text":"public subroutine Init_Tensor2D_t(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Tensor2D_t Source Code subroutine Init_Tensor2D_t ( this , interp , nVar , nElem ) implicit none class ( Tensor2D_t ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 2 , 1 : 2 ), & this % boundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 , 1 : 2 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 , 1 : 2 )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 4 * nVar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 4 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo endsubroutine Init_Tensor2D_t","tags":"","loc":"proc/init_tensor2d_t.html"},{"title":"UpdateDevice_Tensor2D_t – SELF","text":"public subroutine UpdateDevice_Tensor2D_t(this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this Contents Source Code UpdateDevice_Tensor2D_t Source Code subroutine UpdateDevice_Tensor2D_t ( this ) implicit none class ( Tensor2D_t ), intent ( inout ) :: this endsubroutine UpdateDevice_Tensor2D_t","tags":"","loc":"proc/updatedevice_tensor2d_t.html"},{"title":"UpdateHost_Tensor2D_t – SELF","text":"public subroutine UpdateHost_Tensor2D_t(this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this Contents Source Code UpdateHost_Tensor2D_t Source Code subroutine UpdateHost_Tensor2D_t ( this ) implicit none class ( Tensor2D_t ), intent ( inout ) :: this endsubroutine UpdateHost_Tensor2D_t","tags":"","loc":"proc/updatehost_tensor2d_t.html"},{"title":"ChebyshevGauss – SELF","text":"private subroutine ChebyshevGauss(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Contents Source Code ChebyshevGauss Source Code subroutine ChebyshevGauss ( N , nodes , weights ) implicit none integer :: N real ( real64 ) :: nodes ( 0 : N ) real ( real64 ) :: weights ( 0 : N ) ! Local integer :: j do j = 0 , N weights ( j ) = pi / ( real ( N , real64 ) + 1.0_real64 ) nodes ( j ) = - cos ( pi * ( 2.0_real64 * real ( j , real64 ) + 1.0_real64 ) / ( 2.0_real64 * real ( N , real64 ) + 2.0_real64 )) enddo endsubroutine ChebyshevGauss","tags":"","loc":"proc/chebyshevgauss.html"},{"title":"ChebyshevGaussLobatto – SELF","text":"private subroutine ChebyshevGaussLobatto(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Contents Source Code ChebyshevGaussLobatto Source Code subroutine ChebyshevGaussLobatto ( N , nodes , weights ) implicit none integer :: N real ( real64 ) :: nodes ( 0 : N ) real ( real64 ) :: weights ( 0 : N ) ! LOCAL integer :: j do j = 0 , N weights ( j ) = pi / real ( N , real64 ) nodes ( j ) = - cos ( pi * real ( j , real64 ) / real ( N , real64 )) enddo weights ( 0 ) = weights ( 0 ) * 0.5_real64 weights ( N ) = weights ( N ) * 0.5_real64 endsubroutine ChebyshevGaussLobatto","tags":"","loc":"proc/chebyshevgausslobatto.html"},{"title":"ChebyshevQuadrature – SELF","text":"public subroutine ChebyshevQuadrature(N, nodes, weights, QuadType) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=prec), intent(out) :: nodes (0:N) real(kind=prec), intent(out) :: weights (0:N) integer, intent(in) :: QuadType Contents Source Code ChebyshevQuadrature Source Code subroutine ChebyshevQuadrature ( N , nodes , weights , quadType ) implicit none integer , intent ( in ) :: N real ( prec ), intent ( out ) :: nodes ( 0 : N ) real ( prec ), intent ( out ) :: weights ( 0 : N ) integer , intent ( in ) :: QuadType ! Local real ( real64 ) :: nodesLocal ( 0 : N ) real ( real64 ) :: weightsLocal ( 0 : N ) integer :: i if ( QuadType == CHEBYSHEV_GAUSS_LOBATTO ) then call ChebyshevGaussLobatto ( N , nodesLocal , weightsLocal ) elseif ( QuadType == CHEBYSHEV_GAUSS ) then call ChebyshevGauss ( N , nodesLocal , weightsLocal ) endif do i = 0 , N nodes ( i ) = real ( nodesLocal ( i ), prec ) weights ( i ) = real ( weightsLocal ( i ), prec ) enddo endsubroutine ChebyshevQuadrature","tags":"","loc":"proc/chebyshevquadrature.html"},{"title":"LegendreGauss – SELF","text":"private subroutine LegendreGauss(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Contents Source Code LegendreGauss Source Code subroutine LegendreGauss ( N , nodes , weights ) implicit none integer :: N real ( real64 ) :: nodes ( 0 : N ) real ( real64 ) :: weights ( 0 : N ) ! Local real ( real64 ) :: nodes_local ( 0 : N ) real ( real64 ) :: weights_local ( 0 : N ) real ( real64 ) :: lN1 , dlN1 real ( real64 ) :: delta integer :: j , kIt if ( N == 0 ) then nodes_local ( 0 ) = 0.0_real64 weights_local ( 0 ) = 2.0_real64 elseif ( N == 1 ) then nodes_local ( 0 ) = - sqrt ( 1.0_real64 / 3.0_real64 ) weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = - nodes ( 0 ) weights_local ( 1 ) = weights ( 0 ) else do j = 0 ,(( N + 1 ) / 2 ) nodes_local ( j ) = - cos (( 2.0_real64 * real ( j , real64 ) + 1.0_real64 ) * pi / ( 2.0_real64 * real ( N , real64 ) + 1.0_real64 )) do kIt = 1 , newtonMax call LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) delta = - lN1 / dlN1 nodes_local ( j ) = nodes_local ( j ) + delta if ( abs ( delta ) <= TOL * nodes_local ( j )) exit enddo call LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) weights_local ( j ) = 2.0_real64 / (( 1.0_real64 - nodes_local ( j ) * nodes_local ( j )) * dlN1 * dlN1 ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) enddo endif if ( mod ( real ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) then call LegendrePolynomial ( N + 1 , 0.0_real64 , lN1 , dlN1 ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0 / ( dlN1 * dlN1 ) endif do j = 0 , N nodes ( j ) = real ( nodes_local ( j ), real64 ) weights ( j ) = real ( weights_local ( j ), real64 ) enddo endsubroutine LegendreGauss","tags":"","loc":"proc/legendregauss.html"},{"title":"LegendreGaussLobatto – SELF","text":"private subroutine LegendreGaussLobatto(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Contents Source Code LegendreGaussLobatto Source Code subroutine LegendreGaussLobatto ( N , nodes , weights ) implicit none integer :: N real ( real64 ) :: nodes ( 0 : N ) real ( real64 ) :: weights ( 0 : N ) ! Local real ( real64 ) :: nodes_local ( 0 : N ) real ( real64 ) :: weights_local ( 0 : N ) real ( real64 ) :: delta , q , qprime , lN integer :: j , kIt if ( N == 1 ) then nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = 1.0_real64 weights_local ( 1 ) = 1.0_real64 else nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 2.0_real64 / ( real ( N , real64 ) * ( real ( N , real64 ) + 1.0_real64 )) nodes_local ( N ) = 1.0_real64 weights_local ( N ) = weights_local ( 0 ) do j = 1 ,(( N + 1 ) / 2 - 1 ) nodes_local ( j ) = - cos (( real ( j , real64 ) + 0.25_real64 ) * pi / real ( N , real64 ) - & 3.0_real64 / ( 8.0_real64 * real ( N , real64 ) * pi * ( real ( j , real64 ) + 0.25_real64 ))) do kIt = 1 , newtonMax call LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) delta = - q / qprime nodes_local ( j ) = nodes_local ( j ) + delta if ( abs ( delta ) <= TOL * nodes_local ( j )) exit enddo call LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) weights_local ( j ) = 2.0_real64 / ( real ( N , real64 ) * ( real ( N , real64 ) + 1.0_real64 ) * lN * lN ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) enddo endif if ( mod ( real ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) then call LegendreQandL ( N , 0.0_real64 , q , qprime , lN ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0_real64 / ( real ( N , real64 ) * ( real ( N , real64 ) + 1.0_real64 ) * lN * lN ) endif do j = 0 , N nodes ( j ) = real ( nodes_local ( j ), real64 ) weights ( j ) = real ( weights_local ( j ), real64 ) enddo endsubroutine LegendreGaussLobatto","tags":"","loc":"proc/legendregausslobatto.html"},{"title":"LegendrePolynomial – SELF","text":"public subroutine LegendrePolynomial(N, x, lAtX, dLdxAtX) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: lAtX real(kind=real64) :: dLdxAtX Contents Source Code LegendrePolynomial Source Code subroutine LegendrePolynomial ( N , x , lAtX , dLdxAtX ) implicit none integer :: N real ( real64 ) :: x real ( real64 ) :: lAtX , dLdxAtX ! Local real ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 integer :: i if ( N == 0 ) then lAtX = 1.0_real64 dLdxAtX = 0.0_real64 elseif ( N == 1 ) then lAtX = x dLdxAtX = 1.0_real64 else lnM2 = 1.0_real64 lnM1 = x dlnM2 = 0.0_real64 dlnM1 = 1.0_real64 do i = 2 , N lAtX = (( 2.0_real64 * real ( i , real64 ) - 1.0_real64 ) * x * lnM1 - & ( real ( i , real64 ) - 1.0_real64 ) * lnM2 ) / ( real ( i , real64 )) dldxAtX = dlnM2 + ( 2.0_real64 * real ( i , real64 ) - 1.0_real64 ) * lnM1 lnM2 = lnM1 lnM1 = lAtX dlnM2 = dlnM1 dlnM1 = dldxAtX enddo endif endsubroutine LegendrePolynomial","tags":"","loc":"proc/legendrepolynomial.html"},{"title":"LegendreQandL – SELF","text":"private subroutine LegendreQandL(N, x, q, qprime, lN) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: q real(kind=real64) :: qprime real(kind=real64) :: lN Contents Source Code LegendreQandL Source Code subroutine LegendreQandL ( N , x , q , qprime , lN ) implicit none integer :: N real ( real64 ) :: x real ( real64 ) :: lN , q , qprime ! Local real ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 , dlN , lN1 , dlN1 integer :: i lNm2 = 1.0_real64 lNm1 = x dlNm2 = 0.0_real64 dlNm1 = 1.0_real64 do i = 2 , N lN = ( 2.0_real64 * i - 1.0_real64 ) / ( real ( i , real64 )) * x * lNm1 - ( real ( i , real64 ) - 1.0_real64 ) / ( real ( i , real64 )) * lNm2 dlN = dlNm2 + ( 2.0_real64 * real ( i , real64 ) - 1.0_real64 ) * lNm1 lNm2 = lNm1 lNm1 = lN dlNm2 = dlNm1 dlNm1 = dlN enddo i = N + 1 lN1 = ( 2.0_real64 * i - 1.0_real64 ) / ( real ( i , real64 )) * x * lN - ( real ( i , real64 ) - 1.0_real64 ) / ( real ( i , real64 )) * lNm2 dlN1 = dlNm2 + ( 2.0_real64 * real ( i , real64 ) - 1.0_real64 ) * lNm1 q = lN1 - lNm2 qprime = dlN1 - dlNm2 endsubroutine LegendreQandL","tags":"","loc":"proc/legendreqandl.html"},{"title":"LegendreQuadrature – SELF","text":"public subroutine LegendreQuadrature(N, nodes, weights, QuadType) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=prec), intent(out) :: nodes (0:N) real(kind=prec), intent(out) :: weights (0:N) integer, intent(in) :: QuadType Contents Source Code LegendreQuadrature Source Code subroutine LegendreQuadrature ( N , nodes , weights , QuadType ) implicit none integer , intent ( in ) :: N real ( prec ), intent ( out ) :: nodes ( 0 : N ) real ( prec ), intent ( out ) :: weights ( 0 : N ) integer , intent ( in ) :: QuadType ! Local real ( real64 ) :: nodesLocal ( 0 : N ) real ( real64 ) :: weightsLocal ( 0 : N ) integer :: i if ( QuadType == GAUSS_LOBATTO ) then call LegendreGaussLobatto ( N , nodesLocal , weightsLocal ) elseif ( QuadType == GAUSS ) then call LegendreGauss ( N , nodesLocal , weightsLocal ) endif do i = 0 , N nodes ( i ) = real ( nodesLocal ( i ), prec ) weights ( i ) = real ( weightsLocal ( i ), prec ) enddo endsubroutine LegendreQuadrature","tags":"","loc":"proc/legendrequadrature.html"},{"title":"SetDescription_DataObj – SELF","text":"public subroutine SetDescription_DataObj(this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description Contents Source Code SetDescription_DataObj Source Code subroutine SetDescription_DataObj ( this , ivar , description ) !! Set the description of the `ivar-th` variable implicit none class ( SELF_DataObj ), intent ( inout ) :: this integer , intent ( in ) :: ivar character ( * ), intent ( in ) :: description call this % meta ( ivar )% SetDescription ( description ) endsubroutine SetDescription_DataObj","tags":"","loc":"proc/setdescription_dataobj.html"},{"title":"SetEquation_DataObj – SELF","text":"public subroutine SetEquation_DataObj(this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar Contents Source Code SetEquation_DataObj Source Code subroutine SetEquation_DataObj ( this , ivar , eqnChar ) !! Sets the equation parser for the `ivar-th` variable implicit none class ( SELF_DataObj ), intent ( inout ) :: this integer , intent ( in ) :: ivar character ( * ), intent ( in ) :: eqnChar this % eqn ( ivar ) = EquationParser ( trim ( eqnChar ), & ( / 'x' , 'y' , 'z' , 't' / )) endsubroutine SetEquation_DataObj","tags":"","loc":"proc/setequation_dataobj.html"},{"title":"SetName_DataObj – SELF","text":"public subroutine SetName_DataObj(this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name Contents Source Code SetName_DataObj Source Code subroutine SetName_DataObj ( this , ivar , name ) !! Set the name of the `ivar-th` variable implicit none class ( SELF_DataObj ), intent ( inout ) :: this integer , intent ( in ) :: ivar character ( * ), intent ( in ) :: name call this % meta ( ivar )% SetName ( name ) endsubroutine SetName_DataObj","tags":"","loc":"proc/setname_dataobj.html"},{"title":"SetUnits_DataObj – SELF","text":"public subroutine SetUnits_DataObj(this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units Contents Source Code SetUnits_DataObj Source Code subroutine SetUnits_DataObj ( this , ivar , units ) !! Set the units of the `ivar-th` variable implicit none class ( SELF_DataObj ), intent ( inout ) :: this integer , intent ( in ) :: ivar character ( * ), intent ( in ) :: units call this % meta ( ivar )% SetUnits ( units ) endsubroutine SetUnits_DataObj","tags":"","loc":"proc/setunits_dataobj.html"},{"title":"Free_Mesh1D – SELF","text":"public subroutine Free_Mesh1D(this) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: this Contents Source Code Free_Mesh1D Source Code subroutine Free_Mesh1D ( this ) implicit none class ( Mesh1D ), intent ( inout ) :: this this % nElem = 0 this % nNodes = 0 this % nCornerNodes = 0 this % nUniqueNodes = 0 this % nBCs = 0 deallocate ( this % elemInfo ) deallocate ( this % nodeCoords ) deallocate ( this % globalNodeIDs ) deallocate ( this % BCType ) deallocate ( this % BCNames ) call this % decomp % Free () endsubroutine Free_Mesh1D","tags":"","loc":"proc/free_mesh1d.html"},{"title":"Init_Mesh1D – SELF","text":"public subroutine Init_Mesh1D(this, nElem, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: this integer, intent(in) :: nElem integer, intent(in) :: nNodes integer, intent(in) :: nBCs Contents Source Code Init_Mesh1D Source Code subroutine Init_Mesh1D ( this , nElem , nNodes , nBCs ) implicit none class ( Mesh1D ), intent ( out ) :: this integer , intent ( in ) :: nElem integer , intent ( in ) :: nNodes integer , intent ( in ) :: nBCs this % nGeo = 1 this % nElem = nElem this % nGlobalElem = nElem this % nNodes = nNodes this % nCornerNodes = nElem * 2 this % nUniqueNodes = 0 this % nBCs = nBCs this % bcid = 0 allocate ( this % elemInfo ( 1 : 4 , 1 : nElem )) allocate ( this % nodeCoords ( 1 : nNodes )) allocate ( this % globalNodeIDs ( 1 : nNodes )) allocate ( this % BCType ( 1 : 4 , 1 : nBCs )) allocate ( this % BCNames ( 1 : nBCs )) call this % decomp % Init (. false .) endsubroutine Init_Mesh1D","tags":"","loc":"proc/init_mesh1d.html"},{"title":"ResetBoundaryConditionType_Mesh1D – SELF","text":"public subroutine ResetBoundaryConditionType_Mesh1D(this, leftbc, rightbc) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Note that ALL physical boundaries will be set to have this boundary\ncondition Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: this integer, intent(in) :: leftbc integer, intent(in) :: rightbc Contents Source Code ResetBoundaryConditionType_Mesh1D Source Code subroutine ResetBoundaryConditionType_Mesh1D ( this , leftbc , rightbc ) !! This method can be used to reset all of the boundary elements !! boundary condition type to the desired value. !! !! Note that ALL physical boundaries will be set to have this boundary !! condition implicit none class ( Mesh1D ), intent ( inout ) :: this integer , intent ( in ) :: leftbc , rightbc this % bcid ( 1 ) = leftbc this % bcid ( 2 ) = rightbc endsubroutine ResetBoundaryConditionType_Mesh1D","tags":"","loc":"proc/resetboundaryconditiontype_mesh1d.html"},{"title":"UniformBlockMesh_Mesh1D – SELF","text":"public subroutine UniformBlockMesh_Mesh1D(this, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: this integer, intent(in) :: nElem real(kind=prec), intent(in) :: x (1:2) Contents Source Code UniformBlockMesh_Mesh1D Source Code subroutine UniformBlockMesh_Mesh1D ( this , nElem , x ) implicit none class ( Mesh1D ), intent ( out ) :: this integer , intent ( in ) :: nElem real ( prec ), intent ( in ) :: x ( 1 : 2 ) ! Local integer :: iel , ngeo integer :: nid , nNodes integer :: i real ( prec ) :: xU ( 1 : nElem + 1 ) type ( Lagrange ), target :: linearInterp type ( Lagrange ), target :: nGeoInterp type ( Scalar1D ) :: xLinear type ( Scalar1D ) :: xGeo ngeo = 1 nNodes = nElem * ( nGeo + 1 ) call this % Init ( nElem , nNodes , 2 ) this % quadrature = GAUSS_LOBATTO ! Set the hopr_nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem + 1 ) call linearInterp % Init ( 1 , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO ) call nGeoInterp % Init ( nGeo , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO ) ! Create a linear interpolant to interpolate to nGeo grid call xLinear % Init ( linearInterp , 1 , nElem ) call xGeo % Init ( nGeoInterp , 1 , nElem ) do iel = 1 , nElem xLinear % interior ( 1 : 2 , iel , 1 ) = xU ( iel : iel + 1 ) enddo call xLinear % GridInterp ( xGeo % interior ) ! Set the element information nid = 1 do iel = 1 , nElem this % elemInfo ( 1 , iel ) = selfLineLinear ! Element Type this % elemInfo ( 2 , iel ) = 1 ! Element Zone this % elemInfo ( 3 , iel ) = nid ! Node Index Start do i = 1 , nGeo + 1 this % nodeCoords ( nid ) = xGeo % interior ( i , iel , 1 ) nid = nid + 1 enddo this % elemInfo ( 4 , iel ) = nid - 1 ! Node Index End enddo call xLinear % Free () call xGeo % Free () call linearInterp % Free () call nGeoInterp % Free () endsubroutine UniformBlockMesh_Mesh1D","tags":"","loc":"proc/uniformblockmesh_mesh1d.html"},{"title":"Write_Mesh1D – SELF","text":"public subroutine Write_Mesh1D(this, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: this character, intent(in) :: meshFile Contents Source Code Write_Mesh1D Source Code subroutine Write_Mesh1D ( this , meshFile ) ! Writes mesh output in HOPR format (serial IO only) implicit none class ( Mesh1D ), intent ( inout ) :: this character ( * ), intent ( in ) :: meshFile ! Local integer ( HID_T ) :: fileId call Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) call WriteAttribute_HDF5 ( fileId , 'nElems' , this % nElem ) call WriteAttribute_HDF5 ( fileId , 'Ngeo' , this % nGeo ) call WriteAttribute_HDF5 ( fileId , 'nBCs' , this % nBCs ) call WriteArray_HDF5 ( fileId , 'BCType' , this % bcType ) ! Read local subarray of ElemInfo call WriteArray_HDF5 ( fileId , 'ElemInfo' , this % elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs call WriteArray_HDF5 ( fileId , 'NodeCoords' , this % nodeCoords ) call WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , this % globalNodeIDs ) call Close_HDF5 ( fileID ) endsubroutine Write_Mesh1D","tags":"","loc":"proc/write_mesh1d.html"},{"title":"CalculateContravariantBasis_SEMHex – SELF","text":"public subroutine CalculateContravariantBasis_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code CalculateContravariantBasis_SEMHex Source Code subroutine CalculateContravariantBasis_SEMHex ( myGeom ) implicit none class ( SEMHex ), intent ( inout ) :: myGeom ! Local integer :: iEl , i , j , k real ( prec ) :: fac real ( prec ) :: mag type ( Vector3D ) :: xlgradxm , xmgradxl type ( Vector3D ) :: curl_xlgradxm , curl_xmgradxl ! Here we use the curl invariant form from Kopriva (2006) ! to calculate the contravariant basis vectors call xlgradxm % Init ( myGeom % x % interp , 1 , myGeom % x % nElem ) call xmgradxl % Init ( myGeom % x % interp , 1 , myGeom % x % nElem ) call curl_xlgradxm % Init ( myGeom % x % interp , 1 , myGeom % x % nElem ) call curl_xmgradxl % Init ( myGeom % x % interp , 1 , myGeom % x % nElem ) ! Ja&#94;{1:3}_1 (n=1, m=2, l=3) First component of the contravariant basis vectors do iEl = 1 , myGeom % nElem do k = 1 , myGeom % dxds % interp % N + 1 do j = 1 , myGeom % dxds % interp % N + 1 do i = 1 , myGeom % dxds % interp % N + 1 xlgradxm % interior ( i , j , k , iel , 1 , 1 : 3 ) = myGeom % x % interior ( i , j , k , iel , 1 , 3 ) * myGeom % dxds % interior ( i , j , k , iel , 1 , 2 , 1 : 3 ) ! x(...,l)*dxds(...,m,1:3) ; l=3,m=2 xmgradxl % interior ( i , j , k , iel , 1 , 1 : 3 ) = myGeom % x % interior ( i , j , k , iel , 1 , 2 ) * myGeom % dxds % interior ( i , j , k , iel , 1 , 3 , 1 : 3 ) ! x(...,m)*dxds(...,l,1:3) ; l=3,m=2 enddo enddo enddo enddo call xlgradxm % Curl ( curl_xlgradxm % interior ) call xmgradxl % Curl ( curl_xmgradxl % interior ) do iEl = 1 , myGeom % nElem do k = 1 , myGeom % dxds % interp % N + 1 do j = 1 , myGeom % dxds % interp % N + 1 do i = 1 , myGeom % dxds % interp % N + 1 ! In our convention, dsdx(i,j) is contravariant vector j, component i ! dsdx(...,n,i) = Ja&#94;{i}_{n} = contravariant vector i, component n; ! Here, i = 1:3, and n=1 myGeom % dsdx % interior ( i , j , k , iel , 1 , 1 , 1 : 3 ) = 0.5_prec * ( & curl_xmgradxl % interior ( i , j , k , iel , 1 , 1 : 3 ) - & curl_xlgradxm % interior ( i , j , k , iel , 1 , 1 : 3 )) enddo enddo enddo enddo ! Ja&#94;{1:3}_2 (n=2, m=3, l=1) Second component of the contravariant basis vectors do iEl = 1 , myGeom % nElem do k = 1 , myGeom % dxds % interp % N + 1 do j = 1 , myGeom % dxds % interp % N + 1 do i = 1 , myGeom % dxds % interp % N + 1 xlgradxm % interior ( i , j , k , iel , 1 , 1 : 3 ) = myGeom % x % interior ( i , j , k , iel , 1 , 1 ) * myGeom % dxds % interior ( i , j , k , iel , 1 , 3 , 1 : 3 ) ! x(...,l)*dxds(...,m,1:3) ; l=1,m=3 xmgradxl % interior ( i , j , k , iel , 1 , 1 : 3 ) = myGeom % x % interior ( i , j , k , iel , 1 , 3 ) * myGeom % dxds % interior ( i , j , k , iel , 1 , 1 , 1 : 3 ) ! x(...,m)*dxds(...,l,1:3) ; l=1,m=3 enddo enddo enddo enddo call xlgradxm % Curl ( curl_xlgradxm % interior ) call xmgradxl % Curl ( curl_xmgradxl % interior ) do iEl = 1 , myGeom % nElem do k = 1 , myGeom % dxds % interp % N + 1 do j = 1 , myGeom % dxds % interp % N + 1 do i = 1 , myGeom % dxds % interp % N + 1 ! In our convention, dsdx(i,j) is contravariant vector j, component i ! dsdx(...,n,i) = Ja&#94;{i}_{n} = contravariant vector i, component n; ! Here, i = 1:3, and n=2 myGeom % dsdx % interior ( i , j , k , iel , 1 , 2 , 1 : 3 ) = 0.5_prec * ( & curl_xmgradxl % interior ( i , j , k , iel , 1 , 1 : 3 ) - & curl_xlgradxm % interior ( i , j , k , iel , 1 , 1 : 3 )) enddo enddo enddo enddo ! Ja&#94;{1:3}_3 (n=3, m=1, l=2) Third component of the contravariant basis vectors do iEl = 1 , myGeom % nElem do k = 1 , myGeom % dxds % interp % N + 1 do j = 1 , myGeom % dxds % interp % N + 1 do i = 1 , myGeom % dxds % interp % N + 1 xlgradxm % interior ( i , j , k , iel , 1 , 1 : 3 ) = myGeom % x % interior ( i , j , k , iel , 1 , 2 ) * myGeom % dxds % interior ( i , j , k , iel , 1 , 1 , 1 : 3 ) ! x(...,l)*dxds(...,m,1:3) ; l=2,m=1 xmgradxl % interior ( i , j , k , iel , 1 , 1 : 3 ) = myGeom % x % interior ( i , j , k , iel , 1 , 1 ) * myGeom % dxds % interior ( i , j , k , iel , 1 , 2 , 1 : 3 ) ! x(...,m)*dxds(...,l,1:3) ; l=2,m=1 enddo enddo enddo enddo call xlgradxm % Curl ( curl_xlgradxm % interior ) call xmgradxl % Curl ( curl_xmgradxl % interior ) do iEl = 1 , myGeom % nElem do k = 1 , myGeom % dxds % interp % N + 1 do j = 1 , myGeom % dxds % interp % N + 1 do i = 1 , myGeom % dxds % interp % N + 1 ! In our convention, dsdx(i,j) is contravariant vector j, component i ! dsdx(...,n,i) = Ja&#94;{i}_{n} = contravariant vector i, component n; ! Here, i = 1:3, and n=3 myGeom % dsdx % interior ( i , j , k , iel , 1 , 3 , 1 : 3 ) = 0.5_prec * ( & curl_xmgradxl % interior ( i , j , k , iel , 1 , 1 : 3 ) - & curl_xlgradxm % interior ( i , j , k , iel , 1 , 1 : 3 )) enddo enddo enddo enddo call xlgradxm % Free () call xmgradxl % Free () call curl_xlgradxm % Free () call curl_xmgradxl % Free () ! Interpolate the contravariant tensor to the boundaries call myGeom % dsdx % BoundaryInterp () ! Tensor boundary interp is not offloaded ! Now, calculate nHat (outward pointing normal) do iEl = 1 , myGeom % nElem do k = 1 , 6 do j = 1 , myGeom % J % interp % N + 1 do i = 1 , myGeom % J % interp % N + 1 if ( k == selfSide3D_Top . or . k == selfSide3D_East . or . k == selfSide3D_North ) then fac = sign ( 1.0_prec , myGeom % J % boundary ( i , j , k , iEl , 1 )) else fac = - sign ( 1.0_prec , myGeom % J % boundary ( i , j , k , iEl , 1 )) endif if ( k == 1 ) then ! Bottom mag = sqrt ( myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 , 3 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 2 , 3 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 3 , 3 ) ** 2 ) myGeom % nScale % boundary ( i , j , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) = & fac * myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 3 ) / mag ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 3 ) = & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 3 ) * fac elseif ( k == 2 ) then ! South mag = sqrt ( myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 , 2 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 2 , 2 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 3 , 2 ) ** 2 ) myGeom % nScale % boundary ( i , j , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) = & fac * myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 2 ) / mag ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 2 ) = & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 2 ) * fac elseif ( k == 3 ) then ! East mag = sqrt ( myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 , 1 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 2 , 1 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 3 , 1 ) ** 2 ) myGeom % nScale % boundary ( i , j , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) = & fac * myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 1 ) / mag ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 1 ) = & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 1 ) * fac elseif ( k == 4 ) then ! North mag = sqrt ( myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 , 2 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 2 , 2 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 3 , 2 ) ** 2 ) myGeom % nScale % boundary ( i , j , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) = & fac * myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 2 ) / mag ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 2 ) = & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 2 ) * fac elseif ( k == 5 ) then ! West mag = sqrt ( myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 , 1 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 2 , 1 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 3 , 1 ) ** 2 ) myGeom % nScale % boundary ( i , j , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) = & fac * myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 1 ) / mag ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 1 ) = & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 1 ) * fac elseif ( k == 6 ) then ! Top mag = sqrt ( myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 , 3 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 2 , 3 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 3 , 3 ) ** 2 ) myGeom % nScale % boundary ( i , j , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) = & fac * myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 3 ) / mag ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 3 ) = & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 3 ) * fac endif enddo enddo enddo enddo call myGeom % dsdx % UpdateDevice () call myGeom % nHat % UpdateDevice () call myGeom % nScale % UpdateDevice () endsubroutine CalculateContravariantBasis_SEMHex","tags":"","loc":"proc/calculatecontravariantbasis_semhex.html"},{"title":"CalculateMetricTerms_SEMHex – SELF","text":"public subroutine CalculateMetricTerms_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code CalculateMetricTerms_SEMHex Source Code subroutine CalculateMetricTerms_SEMHex ( myGeom ) implicit none class ( SEMHex ), intent ( inout ) :: myGeom call myGeom % x % Gradient ( myGeom % dxds % interior ) call myGeom % dxds % BoundaryInterp () ! Tensor boundary interp is not offloaded to GPU call myGeom % dxds % UpdateDevice () call myGeom % dxds % Determinant ( myGeom % J % interior ) call myGeom % J % UpdateDevice () call myGeom % J % BoundaryInterp () call myGeom % J % UpdateHost () call myGeom % CalculateContravariantBasis () endsubroutine CalculateMetricTerms_SEMHex","tags":"","loc":"proc/calculatemetricterms_semhex.html"},{"title":"Free_SEMHex – SELF","text":"public subroutine Free_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code Free_SEMHex Source Code subroutine Free_SEMHex ( myGeom ) implicit none class ( SEMHex ), intent ( inout ) :: myGeom call myGeom % x % Free () call myGeom % dxds % Free () call myGeom % dsdx % Free () call myGeom % nHat % Free () call myGeom % nScale % Free () call myGeom % J % Free () endsubroutine Free_SEMHex","tags":"","loc":"proc/free_semhex.html"},{"title":"GenerateFromMesh_SEMHex – SELF","text":"public subroutine GenerateFromMesh_SEMHex(myGeom, mesh) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom type( Mesh3D ), intent(in) :: mesh Contents Source Code GenerateFromMesh_SEMHex Source Code subroutine GenerateFromMesh_SEMHex ( myGeom , mesh ) implicit none class ( SEMHex ), intent ( inout ) :: myGeom type ( Mesh3D ), intent ( in ) :: mesh ! Local integer :: iel integer :: i , j , k type ( Lagrange ), target :: meshToModel type ( Vector3D ) :: xMesh call meshToModel % Init ( mesh % nGeo , mesh % quadrature , & myGeom % x % interp % N , & myGeom % x % interp % controlNodeType ) call xMesh % Init ( meshToModel , & 1 , mesh % nElem ) ! Set the element internal mesh locations do iel = 1 , mesh % nElem do k = 1 , mesh % nGeo + 1 do j = 1 , mesh % nGeo + 1 do i = 1 , mesh % nGeo + 1 xMesh % interior ( i , j , k , iel , 1 , 1 : 3 ) = mesh % nodeCoords ( 1 : 3 , i , j , k , iel ) enddo enddo enddo enddo call xMesh % GridInterp ( myGeom % x % interior ) call myGeom % x % UpdateDevice () call myGeom % x % BoundaryInterp () call myGeom % x % UpdateHost () call myGeom % CalculateMetricTerms () call xMesh % Free () call meshToModel % Free () endsubroutine GenerateFromMesh_SEMHex","tags":"","loc":"proc/generatefrommesh_semhex.html"},{"title":"Init_SEMHex – SELF","text":"public subroutine Init_SEMHex(myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom type( Lagrange ), intent(in), pointer :: interp integer, intent(in) :: nElem Contents Source Code Init_SEMHex Source Code subroutine Init_SEMHex ( myGeom , interp , nElem ) implicit none class ( SEMHex ), intent ( out ) :: myGeom type ( Lagrange ), pointer , intent ( in ) :: interp integer , intent ( in ) :: nElem myGeom % nElem = nElem call myGeom % x % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % x % meta ( 1 )% SetName ( \"x\" ) call myGeom % dxds % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % dsdx % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % nHat % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % nScale % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % J % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) endsubroutine Init_SEMHex","tags":"","loc":"proc/init_semhex.html"},{"title":"Free_Mesh3D_t – SELF","text":"public subroutine Free_Mesh3D_t(this) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this Contents Source Code Free_Mesh3D_t Source Code subroutine Free_Mesh3D_t ( this ) implicit none class ( Mesh3D_t ), intent ( inout ) :: this this % nElem = 0 this % nSides = 0 this % nNodes = 0 this % nCornerNodes = 0 this % nUniqueSides = 0 this % nUniqueNodes = 0 this % nBCs = 0 deallocate ( this % elemInfo ) deallocate ( this % sideInfo ) deallocate ( this % nodeCoords ) deallocate ( this % globalNodeIDs ) deallocate ( this % CGNSCornerMap ) deallocate ( this % sideMap ) deallocate ( this % CGNSSideMap ) deallocate ( this % BCType ) deallocate ( this % BCNames ) call this % decomp % Free () endsubroutine Free_Mesh3D_t","tags":"","loc":"proc/free_mesh3d_t.html"},{"title":"Init_Mesh3D_t – SELF","text":"public subroutine Init_Mesh3D_t(this, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs Contents Source Code Init_Mesh3D_t Source Code subroutine Init_Mesh3D_t ( this , nGeo , nElem , nSides , nNodes , nBCs ) implicit none class ( Mesh3D_t ), intent ( inout ) :: this integer , intent ( in ) :: nGeo integer , intent ( in ) :: nElem integer , intent ( in ) :: nSides integer , intent ( in ) :: nNodes integer , intent ( in ) :: nBCs ! Local integer :: i , j , k , l this % nElem = nElem this % nGlobalElem = nElem this % nGeo = nGeo this % nSides = nSides this % nNodes = nNodes this % nCornerNodes = 0 this % nUniqueSides = 0 this % nUniqueNodes = 0 this % nBCs = nBCs allocate ( this % elemInfo ( 1 : 6 , 1 : nElem )) allocate ( this % sideInfo ( 1 : 5 , 1 : 6 , 1 : nElem )) allocate ( this % nodeCoords ( 1 : 3 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % globalNodeIDs ( 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % CGNSCornerMap ( 1 : 3 , 1 : 8 )) allocate ( this % CGNSSideMap ( 1 : 4 , 1 : 6 )) allocate ( this % sideMap ( 1 : 4 , 1 : 6 )) allocate ( this % BCType ( 1 : 4 , 1 : nBCs )) allocate ( this % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation this % CGNSCornerMap ( 1 : 3 , 1 ) = ( / 1 , 1 , 1 / ) ! Bottom-South-West this % CGNSCornerMap ( 1 : 3 , 2 ) = ( / nGeo + 1 , 1 , 1 / ) ! Bottom-South-East this % CGNSCornerMap ( 1 : 3 , 3 ) = ( / nGeo + 1 , nGeo + 1 , 1 / ) ! Bottom-North-East this % CGNSCornerMap ( 1 : 3 , 4 ) = ( / 1 , nGeo + 1 , 1 / ) ! Bottom-North-West this % CGNSCornerMap ( 1 : 3 , 5 ) = ( / 1 , 1 , nGeo + 1 / ) ! Top-South-West this % CGNSCornerMap ( 1 : 3 , 6 ) = ( / nGeo + 1 , 1 , nGeo + 1 / ) ! Top-South-East this % CGNSCornerMap ( 1 : 3 , 7 ) = ( / nGeo + 1 , nGeo + 1 , nGeo + 1 / ) ! Top-North-East this % CGNSCornerMap ( 1 : 3 , 8 ) = ( / 1 , nGeo + 1 , nGeo + 1 / ) ! Top-North-West ! Maps from local corner node id to CGNS side this % CGNSSideMap ( 1 : 4 , 1 ) = ( / 1 , 4 , 3 , 2 / ) this % CGNSSideMap ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) this % CGNSSideMap ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) this % CGNSSideMap ( 1 : 4 , 4 ) = ( / 3 , 4 , 8 , 7 / ) this % CGNSSideMap ( 1 : 4 , 5 ) = ( / 1 , 5 , 8 , 4 / ) this % CGNSSideMap ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) ! Sidemap traverses each face so that the normal ! formed by the right hand rule is the coordinate ! positive pointing normal. For east,north,and top ! this is an outward facing normal. ! For bottom, south, and west, the normal is inward ! facing. this % sideMap ( 1 : 4 , 1 ) = ( / 1 , 2 , 3 , 4 / ) ! Bottom this % sideMap ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) ! South this % sideMap ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) ! East this % sideMap ( 1 : 4 , 4 ) = ( / 4 , 3 , 7 , 8 / ) ! North this % sideMap ( 1 : 4 , 5 ) = ( / 1 , 4 , 8 , 5 / ) ! West this % sideMap ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) ! Top endsubroutine Init_Mesh3D_t","tags":"","loc":"proc/init_mesh3d_t.html"},{"title":"Read_HOPr_Mesh3D_t – SELF","text":"public subroutine Read_HOPr_Mesh3D_t(this, meshFile, enableDomainDecomposition) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(out) :: this character, intent(in) :: meshFile logical, intent(in), optional :: enableDomainDecomposition Contents Source Code Read_HOPr_Mesh3D_t Source Code subroutine Read_HOPr_Mesh3D_t ( this , meshFile , enableDomainDecomposition ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 implicit none class ( Mesh3D_t ), intent ( out ) :: this character ( * ), intent ( in ) :: meshFile logical , intent ( in ), optional :: enableDomainDecomposition ! Local integer ( HID_T ) :: fileId integer ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) integer :: nGlobalElem integer :: firstElem integer :: firstNode integer :: firstSide integer :: nLocalElems integer :: nLocalNodes integer :: nLocalSides integer :: nUniqueSides integer :: nGeo , nBCs integer :: eid , lsid , iSide integer :: i , j , k , nid integer , dimension (:,:), allocatable :: hopr_elemInfo integer , dimension (:,:), allocatable :: hopr_sideInfo real ( prec ), dimension (:,:), allocatable :: hopr_nodeCoords integer , dimension (:), allocatable :: hopr_globalNodeIDs integer , dimension (:,:), allocatable :: bcType if ( present ( enableDomainDecomposition )) then call this % decomp % init ( enableDomainDecomposition ) else call this % decomp % init (. false .) endif if ( this % decomp % mpiEnabled ) then call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId , this % decomp % mpiComm ) else call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId ) endif call ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) call ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) call ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) call ReadAttribute_HDF5 ( fileId , 'nUniqueSides' , nUniqueSides ) ! Read BCType allocate ( bcType ( 1 : 4 , 1 : nBCs )) if ( this % decomp % mpiEnabled ) then offset (:) = 0 call ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) else call ReadArray_HDF5 ( fileId , 'BCType' , bcType ) endif ! Read local subarray of ElemInfo call this % decomp % GenerateDecomposition ( nGlobalElem , nUniqueSides ) firstElem = this % decomp % offsetElem ( this % decomp % rankId + 1 ) + 1 nLocalElems = this % decomp % offsetElem ( this % decomp % rankId + 2 ) - & this % decomp % offsetElem ( this % decomp % rankId + 1 ) ! Allocate Space for hopr_elemInfo! allocate ( hopr_elemInfo ( 1 : 6 , 1 : nLocalElems )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstElem - 1 / ) call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) else call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) endif ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo ( 5 , 1 ) + 1 nLocalNodes = hopr_elemInfo ( 6 , nLocalElems ) - hopr_elemInfo ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! allocate ( hopr_nodeCoords ( 1 : 3 , 1 : nLocalNodes ), hopr_globalNodeIDs ( 1 : nLocalNodes )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) else call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) endif ! Read local subarray of SideInfo firstSide = hopr_elemInfo ( 3 , 1 ) + 1 nLocalSides = hopr_elemInfo ( 4 , nLocalElems ) - hopr_elemInfo ( 3 , 1 ) ! Allocate space for hopr_sideInfo allocate ( hopr_sideInfo ( 1 : 5 , 1 : nLocalSides )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstSide - 1 / ) call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) else call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) endif call Close_HDF5 ( fileID ) ! ---- Done reading 3-D Mesh information ---- ! ! Load hopr data into mesh data structure call this % Init ( nGeo , nLocalElems , nLocalSides , nLocalNodes , nBCs ) ! Copy data from local arrays into this this % elemInfo = hopr_elemInfo this % nUniqueSides = nUniqueSides this % quadrature = UNIFORM ! Grab the node coordinates do eid = 1 , this % nElem do k = 1 , nGeo + 1 do j = 1 , nGeo + 1 do i = 1 , nGeo + 1 nid = i + ( nGeo + 1 ) * ( j - 1 + ( nGeo + 1 ) * ( k - 1 + ( nGeo + 1 ) * ( eid - 1 ))) this % nodeCoords ( 1 : 3 , i , j , k , eid ) = hopr_nodeCoords ( 1 : 3 , nid ) this % globalNodeIDs ( i , j , k , eid ) = hopr_globalNodeIDs ( nid ) enddo enddo enddo enddo iSide = 0 do eid = 1 , this % nElem do lsid = 1 , 6 iSide = iSide + 1 this % sideInfo ( 1 : 5 , lsid , eid ) = hopr_sideInfo ( 1 : 5 , iSide ) enddo enddo call this % RecalculateFlip () deallocate ( hopr_elemInfo , hopr_nodeCoords , hopr_globalNodeIDs , hopr_sideInfo ) endsubroutine Read_HOPr_Mesh3D_t","tags":"","loc":"proc/read_hopr_mesh3d_t.html"},{"title":"RecalculateFlip_Mesh3D_t – SELF","text":"public subroutine RecalculateFlip_Mesh3D_t(this) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this Contents Source Code RecalculateFlip_Mesh3D_t Source Code subroutine RecalculateFlip_Mesh3D_t ( this ) implicit none class ( Mesh3D_t ), intent ( inout ) :: this ! Local integer :: e1 integer :: s1 integer :: e2 integer :: s2 integer :: cgnsFlip , selfFlip do e1 = 1 , this % nElem do s1 = 1 , 6 e2 = this % sideInfo ( 3 , s1 , e1 ) s2 = this % sideInfo ( 4 , s1 , e1 ) / 10 cgnsFlip = this % sideInfo ( 4 , s1 , e1 ) - s2 * 10 if ( e2 /= 0 ) then selfFlip = CGNStoSELFflip ( s2 , s1 , cgnsFlip ) this % sideInfo ( 4 , s1 , e1 ) = 10 * s2 + selfFlip endif enddo enddo endsubroutine RecalculateFlip_Mesh3D_t","tags":"","loc":"proc/recalculateflip_mesh3d_t.html"},{"title":"ResetBoundaryConditionType_Mesh3D_t – SELF","text":"public subroutine ResetBoundaryConditionType_Mesh3D_t(this, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Note that ALL physical boundaries will be set to have this boundary\ncondition Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this integer, intent(in) :: bcid Contents Source Code ResetBoundaryConditionType_Mesh3D_t Source Code subroutine ResetBoundaryConditionType_Mesh3D_t ( this , bcid ) !! This method can be used to reset all of the boundary elements !! boundary condition type to the desired value. !! !! Note that ALL physical boundaries will be set to have this boundary !! condition implicit none class ( Mesh3D_t ), intent ( inout ) :: this integer , intent ( in ) :: bcid ! Local integer :: iSide , iEl , e2 do iEl = 1 , this % nElem do iSide = 1 , 6 e2 = this % sideInfo ( 3 , iSide , iEl ) if ( e2 == 0 ) then this % sideInfo ( 5 , iSide , iEl ) = bcid endif enddo enddo endsubroutine ResetBoundaryConditionType_Mesh3D_t","tags":"","loc":"proc/resetboundaryconditiontype_mesh3d_t.html"},{"title":"Write_Mesh3D_t – SELF","text":"public subroutine Write_Mesh3D_t(this, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this character, intent(in) :: meshFile Contents Source Code Write_Mesh3D_t Source Code subroutine Write_Mesh3D_t ( this , meshFile ) ! Writes mesh output in HOPR format (serial only) implicit none class ( Mesh3D_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: meshFile ! Local integer ( HID_T ) :: fileId call Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) call WriteAttribute_HDF5 ( fileId , 'nElems' , this % nElem ) call WriteAttribute_HDF5 ( fileId , 'Ngeo' , this % nGeo ) call WriteAttribute_HDF5 ( fileId , 'nBCs' , this % nBCs ) call WriteArray_HDF5 ( fileId , 'BCType' , this % bcType ) call WriteArray_HDF5 ( fileId , 'ElemInfo' , this % elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs call WriteArray_HDF5 ( fileId , 'NodeCoords' , this % nodeCoords ) call WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , this % globalNodeIDs ) ! Read local subarray of SideInfo call WriteArray_HDF5 ( fileId , 'SideInfo' , this % sideInfo ) call Close_HDF5 ( fileID ) endsubroutine Write_Mesh3D_t","tags":"","loc":"proc/write_mesh3d_t.html"},{"title":"DomainDecomp – SELF","text":"public subroutine DomainDecomp(nElems, nDomains, offsetElem) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nElems integer, intent(in) :: nDomains integer, intent(out) :: offsetElem (0:nDomains) Contents Source Code DomainDecomp Source Code subroutine DomainDecomp ( nElems , nDomains , offSetElem ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 4 implicit none integer , intent ( in ) :: nElems integer , intent ( in ) :: nDomains integer , intent ( out ) :: offsetElem ( 0 : nDomains ) ! Local integer :: nLocalElems integer :: remainElems integer :: iDom nLocalElems = nElems / nDomains remainElems = nElems - nLocalElems * nDomains do iDom = 0 , nDomains - 1 offSetElem ( iDom ) = iDom * nLocalElems + min ( iDom , remainElems ) enddo offSetElem ( nDomains ) = nElems endsubroutine DomainDecomp","tags":"","loc":"proc/domaindecomp.html"},{"title":"ElemToRank – SELF","text":"public subroutine ElemToRank(nDomains, offsetElem, elemID, domain) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDomains integer, intent(in) :: offsetElem (0:nDomains) integer, intent(in) :: elemID integer, intent(out) :: domain Contents Source Code ElemToRank Source Code subroutine ElemToRank ( nDomains , offsetElem , elemID , domain ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 7 !   \"Find domain containing element index\" ! implicit none integer , intent ( in ) :: nDomains integer , intent ( in ) :: offsetElem ( 0 : nDomains ) integer , intent ( in ) :: elemID integer , intent ( out ) :: domain ! Local integer :: maxSteps integer :: low , up , mid integer :: i domain = 0 maxSteps = int ( log10 ( real ( nDomains )) / log10 ( 2.0 )) + 1 low = 0 up = nDomains - 1 if ( offsetElem ( low ) < elemID . and . elemID <= offsetElem ( low + 1 )) then domain = low elseif ( offsetElem ( up ) < elemID . and . elemID <= offsetElem ( up + 1 )) then domain = up else do i = 1 , maxSteps mid = ( up - low ) / 2 + low if ( offsetElem ( mid ) < elemID . and . elemID <= offsetElem ( mid + 1 )) then domain = mid return elseif ( elemID > offsetElem ( mid + 1 )) then low = mid + 1 else up = mid endif enddo endif endsubroutine ElemToRank","tags":"","loc":"proc/elemtorank.html"},{"title":"FinalizeMPIExchangeAsync – SELF","text":"public subroutine FinalizeMPIExchangeAsync(mpiHandler) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: mpiHandler Contents Source Code FinalizeMPIExchangeAsync Source Code subroutine FinalizeMPIExchangeAsync ( mpiHandler ) class ( DomainDecomposition_t ), intent ( inout ) :: mpiHandler ! Local integer :: ierror integer :: msgCount if ( mpiHandler % mpiEnabled ) then msgCount = mpiHandler % msgCount call MPI_WaitAll ( msgCount , & mpiHandler % requests ( 1 : msgCount ), & mpiHandler % stats ( 1 : MPI_STATUS_SIZE , 1 : msgCount ), & iError ) endif endsubroutine FinalizeMPIExchangeAsync","tags":"","loc":"proc/finalizempiexchangeasync.html"},{"title":"Free_DomainDecomposition_t – SELF","text":"public subroutine Free_DomainDecomposition_t(this) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this Contents Source Code Free_DomainDecomposition_t Source Code subroutine Free_DomainDecomposition_t ( this ) implicit none class ( DomainDecomposition_t ), intent ( inout ) :: this ! Local integer :: ierror if ( associated ( this % offSetElem )) then deallocate ( this % offSetElem ) endif if ( associated ( this % elemToRank )) then deallocate ( this % elemToRank ) endif if ( allocated ( this % requests )) deallocate ( this % requests ) if ( allocated ( this % stats )) deallocate ( this % stats ) if ( this % mpiEnabled ) then print * , __ FILE__ , \" : Rank \" , this % rankId + 1 , \"/\" , this % nRanks , \" checking out.\" call MPI_FINALIZE ( ierror ) endif endsubroutine Free_DomainDecomposition_t","tags":"","loc":"proc/free_domaindecomposition_t.html"},{"title":"GenerateDecomposition_DomainDecomposition_t – SELF","text":"public subroutine GenerateDecomposition_DomainDecomposition_t(this, nGlobalElem, maxMsg) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this integer, intent(in) :: nGlobalElem integer, intent(in) :: maxMsg Contents Source Code GenerateDecomposition_DomainDecomposition_t Source Code subroutine GenerateDecomposition_DomainDecomposition_t ( this , nGlobalElem , maxMsg ) implicit none class ( DomainDecomposition_t ), intent ( inout ) :: this integer , intent ( in ) :: nGlobalElem integer , intent ( in ) :: maxMsg call this % setElemToRank ( nGlobalElem ) if ( allocated ( this % requests )) deallocate ( this % requests ) if ( allocated ( this % stats )) deallocate ( this % stats ) allocate ( this % requests ( 1 : maxMsg )) allocate ( this % stats ( MPI_STATUS_SIZE , 1 : maxMsg )) this % maxMsg = maxMsg print * , __ FILE__ // \" : Rank \" , this % rankId + 1 , \" : n_elements = \" , & this % offSetElem ( this % rankId + 2 ) - this % offSetElem ( this % rankId + 1 ) endsubroutine GenerateDecomposition_DomainDecomposition_t","tags":"","loc":"proc/generatedecomposition_domaindecomposition_t.html"},{"title":"Init_DomainDecomposition_t – SELF","text":"public subroutine Init_DomainDecomposition_t(this, enableMPI) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this logical, intent(in) :: enableMPI Contents Source Code Init_DomainDecomposition_t Source Code subroutine Init_DomainDecomposition_t ( this , enableMPI ) #undef __FUNC__ #define __FUNC__ \"Init_DomainDecomposition_t\" implicit none class ( DomainDecomposition_t ), intent ( inout ) :: this logical , intent ( in ) :: enableMPI ! Local integer :: ierror this % mpiComm = 0 this % mpiPrec = prec this % rankId = 0 this % nRanks = 1 this % nElem = 0 this % mpiEnabled = enableMPI if ( enableMPI ) then this % mpiComm = MPI_COMM_WORLD print * , __ FILE__ , \" : Initializing MPI\" call mpi_init ( ierror ) call mpi_comm_rank ( this % mpiComm , this % rankId , ierror ) call mpi_comm_size ( this % mpiComm , this % nRanks , ierror ) print * , __ FILE__ , \" : Rank \" , this % rankId + 1 , \"/\" , this % nRanks , \" checking in.\" else print * , __ FILE__ , \" : MPI not initialized. No domain decomposition used.\" endif if ( prec == real32 ) then this % mpiPrec = MPI_FLOAT else this % mpiPrec = MPI_DOUBLE endif allocate ( this % offsetElem ( 1 : this % nRanks + 1 )) endsubroutine Init_DomainDecomposition_t","tags":"","loc":"proc/init_domaindecomposition_t.html"},{"title":"SetElemToRank_DomainDecomposition_t – SELF","text":"public subroutine SetElemToRank_DomainDecomposition_t(this, nElem) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this integer, intent(in) :: nElem Contents Source Code SetElemToRank_DomainDecomposition_t Source Code subroutine SetElemToRank_DomainDecomposition_t ( this , nElem ) implicit none class ( DomainDecomposition_t ), intent ( inout ) :: this integer , intent ( in ) :: nElem ! Local integer :: iel this % nElem = nElem allocate ( this % elemToRank ( 1 : nelem )) call DomainDecomp ( nElem , & this % nRanks , & this % offSetElem ) do iel = 1 , nElem call ElemToRank ( this % nRanks , & this % offSetElem , & iel , & this % elemToRank ( iel )) enddo endsubroutine SetElemToRank_DomainDecomposition_t","tags":"","loc":"proc/setelemtorank_domaindecomposition_t.html"},{"title":"BoundaryInterp_Tensor3D_t – SELF","text":"public subroutine BoundaryInterp_Tensor3D_t(this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this Contents Source Code BoundaryInterp_Tensor3D_t Source Code subroutine BoundaryInterp_Tensor3D_t ( this ) implicit none class ( Tensor3D_t ), intent ( inout ) :: this ! Local integer :: i , j , ii , idir , jdir , iel , ivar real ( prec ) :: fbb , fbs , fbe , fbn , fbw , fbt do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & iel = 1 : this % nelem , ivar = 1 : this % nvar , & idir = 1 : 3 , jdir = 1 : 3 ) fbb = 0.0_prec fbs = 0.0_prec fbe = 0.0_prec fbn = 0.0_prec fbw = 0.0_prec fbt = 0.0_prec do ii = 1 , this % N + 1 fbb = fbb + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , j , ii , iel , ivar , idir , jdir ) ! Bottom fbs = fbs + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , ii , j , iel , ivar , idir , jdir ) ! South fbe = fbe + this % interp % bMatrix ( ii , 2 ) * this % interior ( ii , i , j , iel , ivar , idir , jdir ) ! East fbn = fbn + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , ii , j , iel , ivar , idir , jdir ) ! North fbw = fbw + this % interp % bMatrix ( ii , 1 ) * this % interior ( ii , i , j , iel , ivar , idir , jdir ) ! West fbt = fbt + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , j , ii , iel , ivar , idir , jdir ) ! Top enddo this % boundary ( i , j , 1 , iel , ivar , idir , jdir ) = fbb this % boundary ( i , j , 2 , iel , ivar , idir , jdir ) = fbs this % boundary ( i , j , 3 , iel , ivar , idir , jdir ) = fbe this % boundary ( i , j , 4 , iel , ivar , idir , jdir ) = fbn this % boundary ( i , j , 5 , iel , ivar , idir , jdir ) = fbw this % boundary ( i , j , 6 , iel , ivar , idir , jdir ) = fbt enddo endsubroutine BoundaryInterp_Tensor3D_t","tags":"","loc":"proc/boundaryinterp_tensor3d_t.html"},{"title":"Determinant_Tensor3D_t – SELF","text":"public subroutine Determinant_Tensor3D_t(this, det) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(in) :: this real(kind=prec), intent(out) :: det (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) Contents Source Code Determinant_Tensor3D_t Source Code subroutine Determinant_Tensor3D_t ( this , det ) implicit none class ( Tensor3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: det ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , j , k do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) det ( i , j , k , iEl , iVar ) = & this % interior ( i , j , k , iEl , iVar , 1 , 1 ) * & ( this % interior ( i , j , k , iEl , iVar , 2 , 2 ) * & this % interior ( i , j , k , iEl , iVar , 3 , 3 ) - & this % interior ( i , j , k , iEl , iVar , 2 , 3 ) * & this % interior ( i , j , k , iEl , iVar , 3 , 2 )) - & this % interior ( i , j , k , iEl , iVar , 2 , 1 ) * & ( this % interior ( i , j , k , iEl , iVar , 1 , 2 ) * & this % interior ( i , j , k , iEl , iVar , 3 , 3 ) - & this % interior ( i , j , k , iEl , iVar , 1 , 3 ) * & this % interior ( i , j , k , iEl , iVar , 3 , 2 )) + & this % interior ( i , j , k , iEl , iVar , 3 , 1 ) * & ( this % interior ( i , j , k , iEl , iVar , 1 , 2 ) * & this % interior ( i , j , k , iEl , iVar , 2 , 3 ) - & this % interior ( i , j , k , iEl , iVar , 1 , 3 ) * & this % interior ( i , j , k , iEl , iVar , 2 , 2 )) enddo endsubroutine Determinant_Tensor3D_t","tags":"","loc":"proc/determinant_tensor3d_t.html"},{"title":"Free_Tensor3D_t – SELF","text":"public subroutine Free_Tensor3D_t(this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this Contents Source Code Free_Tensor3D_t Source Code subroutine Free_Tensor3D_t ( this ) implicit none class ( Tensor3D_t ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) endsubroutine Free_Tensor3D_t","tags":"","loc":"proc/free_tensor3d_t.html"},{"title":"Init_Tensor3D_t – SELF","text":"public subroutine Init_Tensor3D_t(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Tensor3D_t Source Code subroutine Init_Tensor3D_t ( this , interp , nVar , nElem ) implicit none class ( Tensor3D_t ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 3 , 1 : 3 ), & this % boundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 , 1 : 3 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 , 1 : 3 )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 9 * nVar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 9 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo endsubroutine Init_Tensor3D_t","tags":"","loc":"proc/init_tensor3d_t.html"},{"title":"UpdateDevice_Tensor3D_t – SELF","text":"public subroutine UpdateDevice_Tensor3D_t(this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this Contents Source Code UpdateDevice_Tensor3D_t Source Code subroutine UpdateDevice_Tensor3D_t ( this ) implicit none class ( Tensor3D_t ), intent ( inout ) :: this endsubroutine UpdateDevice_Tensor3D_t","tags":"","loc":"proc/updatedevice_tensor3d_t.html"},{"title":"UpdateHost_Tensor3D_t – SELF","text":"public subroutine UpdateHost_Tensor3D_t(this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this Contents Source Code UpdateHost_Tensor3D_t Source Code subroutine UpdateHost_Tensor3D_t ( this ) implicit none class ( Tensor3D_t ), intent ( inout ) :: this endsubroutine UpdateHost_Tensor3D_t","tags":"","loc":"proc/updatehost_tensor3d_t.html"},{"title":"entropy_func_advection_diffusion_1d_t – SELF","text":"public pure function entropy_func_advection_diffusion_1d_t(this, s) result(e) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) Contents Source Code entropy_func_advection_diffusion_1d_t Source Code pure function entropy_func_advection_diffusion_1d_t ( this , s ) result ( e ) class ( advection_diffusion_1d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ) :: e ! Local integer :: ivar e = 0.0_prec do ivar = 1 , this % solution % nvar e = e + 0.5_prec * s ( ivar ) * s ( ivar ) enddo endfunction entropy_func_advection_diffusion_1d_t","tags":"","loc":"proc/entropy_func_advection_diffusion_1d_t.html"},{"title":"flux1d_advection_diffusion_1d_t – SELF","text":"public pure function flux1d_advection_diffusion_1d_t(this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) Return Value real(kind=prec)(1:this%solution%nvar) Contents Source Code flux1d_advection_diffusion_1d_t Source Code pure function flux1d_advection_diffusion_1d_t ( this , s , dsdx ) result ( flux ) class ( advection_diffusion_1d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % solution % nvar ) real ( prec ) :: flux ( 1 : this % solution % nvar ) ! Local integer :: ivar do ivar = 1 , this % solution % nvar flux ( ivar ) = this % u * s ( ivar ) - this % nu * dsdx ( ivar ) ! advective flux + diffusive flux enddo endfunction flux1d_advection_diffusion_1d_t","tags":"","loc":"proc/flux1d_advection_diffusion_1d_t.html"},{"title":"riemannflux1d_advection_diffusion_1d_t – SELF","text":"public pure function riemannflux1d_advection_diffusion_1d_t(this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%solution%nvar) real(kind=prec), intent(in) :: sR (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%solution%nvar) Contents Source Code riemannflux1d_advection_diffusion_1d_t Source Code pure function riemannflux1d_advection_diffusion_1d_t ( this , sL , sR , dsdx , nhat ) result ( flux ) class ( advection_diffusion_1d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: sL ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: sR ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: nhat real ( prec ) :: flux ( 1 : this % solution % nvar ) ! Local integer :: ivar do ivar = 1 , this % solution % nvar flux ( ivar ) = 0.5_prec * ( this % u * nhat * ( sL ( ivar ) + sR ( ivar )) + & abs ( this % u * nhat ) * ( sL ( ivar ) - sR ( ivar ))) - & ! advective flux this % nu * dsdx ( ivar ) * nhat ! diffusive flux enddo endfunction riemannflux1d_advection_diffusion_1d_t","tags":"","loc":"proc/riemannflux1d_advection_diffusion_1d_t.html"},{"title":"BoundaryFlux_DGModel1D_t – SELF","text":"public subroutine BoundaryFlux_DGModel1D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this Contents Source Code BoundaryFlux_DGModel1D_t Source Code subroutine BoundaryFlux_DGModel1D_t ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: iside real ( prec ) :: fin ( 1 : this % solution % nvar ) real ( prec ) :: fout ( 1 : this % solution % nvar ) real ( prec ) :: dfdx ( 1 : this % solution % nvar ), nhat do iel = 1 , this % mesh % nelem do iside = 1 , 2 ! set the normal velocity if ( iside == 1 ) then nhat = - 1.0_prec else nhat = 1.0_prec endif fin = this % solution % boundary ( iside , iel , 1 : this % solution % nvar ) ! interior solution fout = this % solution % extboundary ( iside , iel , 1 : this % solution % nvar ) ! exterior solution dfdx = this % solutionGradient % avgboundary ( iside , iel , 1 : this % solution % nvar ) ! average solution gradient (with direction taken into account) this % flux % boundarynormal ( iside , iel , 1 : this % solution % nvar ) = & this % riemannflux1d ( fin , fout , dfdx , nhat ) enddo enddo endsubroutine BoundaryFlux_DGModel1D_t","tags":"","loc":"proc/boundaryflux_dgmodel1d_t.html"},{"title":"CalculateEntropy_DGModel1D_t – SELF","text":"public subroutine CalculateEntropy_DGModel1D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this Contents Source Code CalculateEntropy_DGModel1D_t Source Code subroutine CalculateEntropy_DGModel1D_t ( this ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! Local integer :: iel , i , ivar real ( prec ) :: e , s ( 1 : this % solution % nvar ), J e = 0.0_prec do iel = 1 , this % geometry % nelem do i = 1 , this % solution % interp % N + 1 J = this % geometry % dxds % interior ( i , iel , 1 ) s ( 1 : this % solution % nvar ) = this % solution % interior ( i , iel , 1 : this % solution % nvar ) e = e + this % entropy_func ( s ) * J enddo enddo this % entropy = e endsubroutine CalculateEntropy_DGModel1D_t","tags":"","loc":"proc/calculateentropy_dgmodel1d_t.html"},{"title":"CalculateSolutionGradient_DGModel1D_t – SELF","text":"public subroutine CalculateSolutionGradient_DGModel1D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this Contents Source Code CalculateSolutionGradient_DGModel1D_t Source Code subroutine CalculateSolutionGradient_DGModel1D_t ( this ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this call this % solution % AverageSides () this % solution % boundarynormal ( 1 ,:,:) = - this % solution % avgBoundary ( 1 ,:,:) ! Account for left facing normal this % solution % boundarynormal ( 2 ,:,:) = this % solution % avgBoundary ( 2 ,:,:) ! Account for right facing normal call this % solution % MappedDGDerivative ( this % solutionGradient % interior ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp () ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh ) endsubroutine CalculateSolutionGradient_DGModel1D_t","tags":"","loc":"proc/calculatesolutiongradient_dgmodel1d_t.html"},{"title":"CalculateTendency_DGModel1D_t – SELF","text":"public subroutine CalculateTendency_DGModel1D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this Contents Source Code CalculateTendency_DGModel1D_t Source Code subroutine CalculateTendency_DGModel1D_t ( this ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! Local integer :: i , iEl , iVar call this % solution % BoundaryInterp () call this % solution % SideExchange ( this % mesh ) call this % PreTendency () ! User-supplied call this % SetBoundaryCondition () ! User-supplied if ( this % gradient_enabled ) then call this % CalculateSolutionGradient () call this % SetGradientBoundaryCondition () ! User-supplied call this % solutionGradient % AverageSides () endif call this % SourceMethod () ! User supplied call this % BoundaryFlux () ! User supplied call this % FluxMethod () ! User supplied call this % flux % MappedDGDerivative ( this % fluxDivergence % interior ) do concurrent ( i = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % dSdt % interior ( i , iEl , iVar ) = & this % source % interior ( i , iEl , iVar ) - & this % fluxDivergence % interior ( i , iEl , iVar ) enddo endsubroutine CalculateTendency_DGModel1D_t","tags":"","loc":"proc/calculatetendency_dgmodel1d_t.html"},{"title":"Free_DGModel1D_t – SELF","text":"public subroutine Free_DGModel1D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this Contents Source Code Free_DGModel1D_t Source Code subroutine Free_DGModel1D_t ( this ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this call this % solution % DissociateGeometry () call this % solutionGradient % DissociateGeometry () call this % flux % DissociateGeometry () call this % fluxDivergence % DissociateGeometry () call this % solution % Free () call this % workSol % Free () call this % dSdt % Free () call this % solutionGradient % Free () call this % flux % Free () call this % source % Free () call this % fluxDivergence % Free () endsubroutine Free_DGModel1D_t","tags":"","loc":"proc/free_dgmodel1d_t.html"},{"title":"Init_DGModel1D_t – SELF","text":"public subroutine Init_DGModel1D_t(this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), target :: mesh type( Geometry1D ), intent(in), target :: geometry Contents Source Code Init_DGModel1D_t Source Code subroutine Init_DGModel1D_t ( this , nvar , mesh , geometry ) implicit none class ( DGModel1D_t ), intent ( out ) :: this integer , intent ( in ) :: nvar type ( Mesh1D ), intent ( in ), target :: mesh type ( Geometry1D ), intent ( in ), target :: geometry this % mesh => mesh this % geometry => geometry this % nvar = nvar call this % solution % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % workSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % dSdt % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % solutionGradient % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % flux % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % source % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % fluxDivergence % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % solution % AssociateGeometry ( geometry ) call this % solutionGradient % AssociateGeometry ( geometry ) call this % flux % AssociateGeometry ( geometry ) call this % fluxDivergence % AssociateGeometry ( geometry ) call this % SetMetadata () endsubroutine Init_DGModel1D_t","tags":"","loc":"proc/init_dgmodel1d_t.html"},{"title":"Read_DGModel1D_t – SELF","text":"public subroutine Read_DGModel1D_t(this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in) :: fileName Contents Source Code Read_DGModel1D_t Source Code subroutine Read_DGModel1D_t ( this , fileName ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: fileName ! Local integer ( HID_T ) :: fileId integer ( HID_T ) :: solOffset ( 1 : 3 ) integer :: firstElem integer :: N call Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) call ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , this % solution % interior ) call Close_HDF5 ( fileId ) call this % solution % UpdateDevice () endsubroutine Read_DGModel1D_t","tags":"","loc":"proc/read_dgmodel1d_t.html"},{"title":"SetMetadata_DGModel1D_t – SELF","text":"public subroutine SetMetadata_DGModel1D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this Contents Source Code SetMetadata_DGModel1D_t Source Code subroutine SetMetadata_DGModel1D_t ( this ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! Local integer :: ivar character ( LEN = 3 ) :: ivarChar character ( LEN = 25 ) :: varname do ivar = 1 , this % nvar write ( ivarChar , '(I3.3)' ) ivar varname = \"solution\" // trim ( ivarChar ) call this % solution % SetName ( ivar , varname ) call this % solution % SetUnits ( ivar , \"[null]\" ) enddo endsubroutine SetMetadata_DGModel1D_t","tags":"","loc":"proc/setmetadata_dgmodel1d_t.html"},{"title":"SetSolutionFromChar_DGModel1D_t – SELF","text":"public subroutine SetSolutionFromChar_DGModel1D_t(this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) Contents Source Code SetSolutionFromChar_DGModel1D_t Source Code subroutine SetSolutionFromChar_DGModel1D_t ( this , eqnChar ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this character ( LEN = SELF_EQUATION_LENGTH ), intent ( in ) :: eqnChar ( 1 : this % solution % nVar ) ! Local integer :: iVar do iVar = 1 , this % solution % nVar print * , iVar , eqnChar ( iVar ) call this % solution % SetEquation ( ivar , eqnChar ( iVar )) enddo call this % solution % SetInteriorFromEquation ( this % t ) call this % solution % BoundaryInterp () endsubroutine SetSolutionFromChar_DGModel1D_t","tags":"","loc":"proc/setsolutionfromchar_dgmodel1d_t.html"},{"title":"SetSolutionFromEqn_DGModel1D_t – SELF","text":"public subroutine SetSolutionFromEqn_DGModel1D_t(this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) Contents Source Code SetSolutionFromEqn_DGModel1D_t Source Code subroutine SetSolutionFromEqn_DGModel1D_t ( this , eqn ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this type ( EquationParser ), intent ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local integer :: iVar ! Copy the equation parser do iVar = 1 , this % solution % nVar call this % solution % SetEquation ( ivar , eqn ( iVar )% equation ) enddo call this % solution % SetInteriorFromEquation ( this % t ) call this % solution % BoundaryInterp () endsubroutine SetSolutionFromEqn_DGModel1D_t","tags":"","loc":"proc/setsolutionfromeqn_dgmodel1d_t.html"},{"title":"UpdateGRK2_DGModel1D_t – SELF","text":"public subroutine UpdateGRK2_DGModel1D_t(this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK2_DGModel1D_t Source Code subroutine UpdateGRK2_DGModel1D_t ( this , m ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , iEl , iVar do concurrent ( i = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , iEl , iVar ) = rk2_a ( m ) * & this % workSol % interior ( i , iEl , iVar ) + & this % dSdt % interior ( i , iEl , iVar ) this % solution % interior ( i , iEl , iVar ) = & this % solution % interior ( i , iEl , iVar ) + & rk2_g ( m ) * this % dt * this % workSol % interior ( i , iEl , iVar ) enddo endsubroutine UpdateGRK2_DGModel1D_t","tags":"","loc":"proc/updategrk2_dgmodel1d_t.html"},{"title":"UpdateGRK3_DGModel1D_t – SELF","text":"public subroutine UpdateGRK3_DGModel1D_t(this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK3_DGModel1D_t Source Code subroutine UpdateGRK3_DGModel1D_t ( this , m ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , iEl , iVar do concurrent ( i = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , iEl , iVar ) = rk3_a ( m ) * & this % workSol % interior ( i , iEl , iVar ) + & this % dSdt % interior ( i , iEl , iVar ) this % solution % interior ( i , iEl , iVar ) = & this % solution % interior ( i , iEl , iVar ) + & rk3_g ( m ) * this % dt * this % workSol % interior ( i , iEl , iVar ) enddo endsubroutine UpdateGRK3_DGModel1D_t","tags":"","loc":"proc/updategrk3_dgmodel1d_t.html"},{"title":"UpdateGRK4_DGModel1D_t – SELF","text":"public subroutine UpdateGRK4_DGModel1D_t(this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK4_DGModel1D_t Source Code subroutine UpdateGRK4_DGModel1D_t ( this , m ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , iEl , iVar do concurrent ( i = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , iEl , iVar ) = rk4_a ( m ) * & this % workSol % interior ( i , iEl , iVar ) + & this % dSdt % interior ( i , iEl , iVar ) this % solution % interior ( i , iEl , iVar ) = & this % solution % interior ( i , iEl , iVar ) + & rk4_g ( m ) * this % dt * this % workSol % interior ( i , iEl , iVar ) enddo endsubroutine UpdateGRK4_DGModel1D_t","tags":"","loc":"proc/updategrk4_dgmodel1d_t.html"},{"title":"UpdateSolution_DGModel1D_t – SELF","text":"public subroutine UpdateSolution_DGModel1D_t(this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt Contents Source Code UpdateSolution_DGModel1D_t Source Code subroutine UpdateSolution_DGModel1D_t ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) implicit none class ( DGModel1D_t ), intent ( inout ) :: this real ( prec ), optional , intent ( in ) :: dt ! Local real ( prec ) :: dtLoc integer :: i , iEl , iVar if ( present ( dt )) then dtLoc = dt else dtLoc = this % dt endif do concurrent ( i = 1 : this % solution % N + 1 , iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % solution % interior ( i , iEl , iVar ) = & this % solution % interior ( i , iEl , iVar ) + & dtLoc * this % dSdt % interior ( i , iEl , iVar ) enddo endsubroutine UpdateSolution_DGModel1D_t","tags":"","loc":"proc/updatesolution_dgmodel1d_t.html"},{"title":"WriteTecplot_DGModel1D_t – SELF","text":"public subroutine WriteTecplot_DGModel1D_t(this, filename) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: filename Contents Source Code WriteTecplot_DGModel1D_t Source Code subroutine WriteTecplot_DGModel1D_t ( this , filename ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: filename ! Local character ( 8 ) :: zoneID integer :: fUnit integer :: iEl , i , iVar character ( LEN = self_FileNameLength ) :: tecFile character ( LEN = self_TecplotHeaderLength ) :: tecHeader character ( LEN = self_FormatLength ) :: fmat character ( 13 ) :: timeStampString character ( 5 ) :: rankString type ( Scalar1D ) :: solution type ( Scalar1D ) :: x type ( Lagrange ), target :: interp if ( present ( filename )) then tecFile = filename else ! Create a 0-padded integer for the output iterate write ( timeStampString , '(I13.13)' ) this % ioIterate ! Increment the ioIterate this % ioIterate = this % ioIterate + 1 tecFile = 'solution.' // timeStampString // '.curve' endif call this % solution % UpdateHost () ! Create an interpolant for the uniform grid call interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) call solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) call x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid call this % geometry % x % GridInterp ( x % Interior ) ! Map the solution to the target grid call this % solution % GridInterp ( solution % interior ) fmat = '(2(ES16.7E3,1x))' ! Let's write some tecplot!! open ( UNIT = NEWUNIT ( fUnit ), & FILE = trim ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) do iVar = 1 , this % solution % nVar write ( tecHeader , '(E15.6)' ) this % t tecHeader = \"#TIME \" // trim ( tecHeader ) write ( fUnit , * ) trim ( tecHeader ) tecHeader = \"#\" // trim ( this % solution % meta ( iVar )% name ) // \" vs position\" write ( fUnit , * ) trim ( tecHeader ) do iEl = 1 , this % solution % nElem do i = 1 , this % solution % interp % M + 1 write ( fUnit , fmat ) x % interior ( i , iEl , 1 ), & solution % interior ( i , iEl , iVar ) enddo enddo enddo close ( UNIT = fUnit ) call x % Free () call solution % Free () call interp % Free () endsubroutine WriteTecplot_DGModel1D_t","tags":"","loc":"proc/writetecplot_dgmodel1d_t.html"},{"title":"Write_DGModel1D_t – SELF","text":"public subroutine Write_DGModel1D_t(this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: fileName Contents Source Code Write_DGModel1D_t Source Code subroutine Write_DGModel1D_t ( this , fileName ) #undef __FUNC__ #define __FUNC__ \"Write_DGModel1D_t\" implicit none class ( DGModel1D_t ), intent ( inout ) :: this character ( * ), optional , intent ( in ) :: fileName ! Local integer ( HID_T ) :: fileId type ( Scalar1D ) :: solution type ( Scalar1D ) :: x type ( Lagrange ), target :: interp character ( LEN = self_FileNameLength ) :: pickupFile character ( 13 ) :: timeStampString write ( timeStampString , '(I13.13)' ) this % ioIterate if ( present ( filename )) then pickupFile = trim ( filename ) else pickupFile = 'solution.' // timeStampString // '.h5' endif INFO ( \"Writing pickup file : \" // trim ( pickupFile )) call this % solution % UpdateHost () call Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) call this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) call CreateGroup_HDF5 ( fileId , '/controlgrid' ) call this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' ) ! Write the geometry to file INFO ( \"Writing control grid  geometry to file\" ) call CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) call this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid call interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) call solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) call x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid call this % geometry % x % GridInterp ( x % interior ) ! Map the solution to the target grid call this % solution % GridInterp ( solution % interior ) ! Write the model state to file INFO ( \"Writing target grid solution to file\" ) call CreateGroup_HDF5 ( fileId , '/targetgrid' ) call solution % WriteHDF5 ( fileId , '/targetgrid/solution' ) ! Write the geometry to file INFO ( \"Writing target grid geometry to file\" ) call CreateGroup_HDF5 ( fileId , '/targetgrid/geometry' ) call x % WriteHDF5 ( fileId , '/targetgrid/geometry/x' ) call Close_HDF5 ( fileId ) call x % Free () call solution % Free () call interp % Free () endsubroutine Write_DGModel1D_t","tags":"","loc":"proc/write_dgmodel1d_t.html"},{"title":"fluxmethod_DGModel1D_t – SELF","text":"public subroutine fluxmethod_DGModel1D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this Contents Source Code fluxmethod_DGModel1D_t Source Code subroutine fluxmethod_DGModel1D_t ( this ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: i real ( prec ) :: f ( 1 : this % solution % nvar ), dfdx ( 1 : this % solution % nvar ) do iel = 1 , this % mesh % nelem do i = 1 , this % solution % interp % N + 1 f = this % solution % interior ( i , iel , 1 : this % solution % nvar ) dfdx = this % solutionGradient % interior ( i , iel , 1 : this % solution % nvar ) this % flux % interior ( i , iel , 1 : this % solution % nvar ) = & this % flux1d ( f , dfdx ) enddo enddo endsubroutine fluxmethod_DGModel1D_t","tags":"","loc":"proc/fluxmethod_dgmodel1d_t.html"},{"title":"setboundarycondition_DGModel1D_t – SELF","text":"public subroutine setboundarycondition_DGModel1D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this Contents Source Code setboundarycondition_DGModel1D_t Source Code subroutine setboundarycondition_DGModel1D_t ( this ) ! Here, we use the pre-tendency method to calculate the ! derivative of the solution using a bassi-rebay method ! We then do a boundary interpolation and side exchange ! on the gradient field implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! local integer :: ivar integer :: N , nelem real ( prec ) :: x nelem = this % geometry % nelem ! number of elements in the mesh N = this % solution % interp % N ! polynomial degree ! left-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 1 , 1 , 1 ) this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % hbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % hbc1d_Radiation ( this % solution % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % hbc1d_NoNormalFlow ( this % solution % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = this % solution % boundary ( 2 , nelem , 1 : this % nvar ) endif ! right-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 2 , nelem , 1 ) this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % hbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % hbc1d_Radiation ( this % solution % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % hbc1d_NoNormalFlow ( this % solution % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = this % solution % boundary ( 1 , 1 , 1 : this % nvar ) endif endsubroutine setboundarycondition_DGModel1D_t","tags":"","loc":"proc/setboundarycondition_dgmodel1d_t.html"},{"title":"setgradientboundarycondition_DGModel1D_t – SELF","text":"public subroutine setgradientboundarycondition_DGModel1D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this Contents Source Code setgradientboundarycondition_DGModel1D_t Source Code subroutine setgradientboundarycondition_DGModel1D_t ( this ) ! Here, we set the boundary conditions for the ! solution and the solution gradient at the left ! and right most boundaries. ! ! Here, we use periodic boundary conditions implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! local real ( prec ) :: x integer :: nelem nelem = this % geometry % nelem ! number of elements in the mesh ! left-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 1 , 1 , 1 ) this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % pbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % pbc1d_Radiation ( this % solutionGradient % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % pbc1d_NoNormalFlow ( this % solutionGradient % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = this % solutionGradient % boundary ( 2 , nelem , 1 : this % nvar ) endif ! right-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 2 , nelem , 1 ) this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % pbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % pbc1d_Radiation ( this % solutionGradient % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % pbc1d_NoNormalFlow ( this % solutionGradient % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = this % solutionGradient % boundary ( 1 , 1 , 1 : this % nvar ) endif endsubroutine setgradientboundarycondition_DGModel1D_t","tags":"","loc":"proc/setgradientboundarycondition_dgmodel1d_t.html"},{"title":"sourcemethod_DGModel1D_t – SELF","text":"public subroutine sourcemethod_DGModel1D_t(this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this Contents Source Code sourcemethod_DGModel1D_t Source Code subroutine sourcemethod_DGModel1D_t ( this ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: i real ( prec ) :: f ( 1 : this % solution % nvar ), dfdx ( 1 : this % solution % nvar ) do iel = 1 , this % mesh % nelem do i = 1 , this % solution % interp % N + 1 f = this % solution % interior ( i , iel , 1 : this % solution % nvar ) dfdx = this % solutionGradient % interior ( i , iel , 1 : this % solution % nvar ) this % source % interior ( i , iel , 1 : this % solution % nvar ) = & this % source1d ( f , dfdx ) enddo enddo endsubroutine sourcemethod_DGModel1D_t","tags":"","loc":"proc/sourcemethod_dgmodel1d_t.html"},{"title":"entropy_func_advection_diffusion_3d_t – SELF","text":"public pure function entropy_func_advection_diffusion_3d_t(this, s) result(e) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) Contents Source Code entropy_func_advection_diffusion_3d_t Source Code pure function entropy_func_advection_diffusion_3d_t ( this , s ) result ( e ) class ( advection_diffusion_3d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ) :: e ! Local integer :: ivar e = 0.0_prec do ivar = 1 , this % solution % nvar e = e + 0.5_prec * s ( ivar ) * s ( ivar ) enddo endfunction entropy_func_advection_diffusion_3d_t","tags":"","loc":"proc/entropy_func_advection_diffusion_3d_t.html"},{"title":"flux3d_advection_diffusion_3d_t – SELF","text":"public pure function flux3d_advection_diffusion_3d_t(this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar,1:3) Return Value real(kind=prec)(1:this%solution%nvar,1:3) Contents Source Code flux3d_advection_diffusion_3d_t Source Code pure function flux3d_advection_diffusion_3d_t ( this , s , dsdx ) result ( flux ) class ( advection_diffusion_3d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % solution % nvar , 1 : 3 ) real ( prec ) :: flux ( 1 : this % solution % nvar , 1 : 3 ) ! Local integer :: ivar do ivar = 1 , this % solution % nvar flux ( ivar , 1 ) = this % u * s ( ivar ) - this % nu * dsdx ( ivar , 1 ) ! advective flux + diffusive flux flux ( ivar , 2 ) = this % v * s ( ivar ) - this % nu * dsdx ( ivar , 2 ) ! advective flux + diffusive flux flux ( ivar , 3 ) = this % w * s ( ivar ) - this % nu * dsdx ( ivar , 3 ) ! advective flux + diffusive flux enddo endfunction flux3d_advection_diffusion_3d_t","tags":"","loc":"proc/flux3d_advection_diffusion_3d_t.html"},{"title":"riemannflux3d_advection_diffusion_3d_t – SELF","text":"public pure function riemannflux3d_advection_diffusion_3d_t(this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) Contents Source Code riemannflux3d_advection_diffusion_3d_t Source Code pure function riemannflux3d_advection_diffusion_3d_t ( this , sL , sR , dsdx , nhat ) result ( flux ) class ( advection_diffusion_3d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: sL ( 1 : this % nvar ) real ( prec ), intent ( in ) :: sR ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ), intent ( in ) :: nhat ( 1 : 3 ) real ( prec ) :: flux ( 1 : this % nvar ) ! Local integer :: ivar real ( prec ) :: un , dsdn un = this % u * nhat ( 1 ) + this % v * nhat ( 2 ) + this % w * nhat ( 3 ) do ivar = 1 , this % nvar dsdn = dsdx ( ivar , 1 ) * nhat ( 1 ) + dsdx ( ivar , 2 ) * nhat ( 2 ) + dsdx ( ivar , 3 ) * nhat ( 3 ) flux ( ivar ) = 0.5_prec * ( & ( sL ( ivar ) + sR ( ivar )) + abs ( un ) * ( sL ( ivar ) - sR ( ivar ))) - & ! advective flux this % nu * dsdn enddo endfunction riemannflux3d_advection_diffusion_3d_t","tags":"","loc":"proc/riemannflux3d_advection_diffusion_3d_t.html"},{"title":"AverageSides_Scalar1D_t – SELF","text":"public subroutine AverageSides_Scalar1D_t(this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this Contents Source Code AverageSides_Scalar1D_t Source Code subroutine AverageSides_Scalar1D_t ( this ) implicit none class ( Scalar1D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: ivar do concurrent ( iel = 1 : this % nElem , ivar = 1 : this % nVar ) ! Left side - we account for the -\\hat{x} normal this % avgboundary ( 1 , iel , ivar ) = 0.5_prec * ( & this % boundary ( 1 , iel , ivar ) + & this % extBoundary ( 1 , iel , ivar )) ! Right side - we account for the +\\hat{x} normal this % avgboundary ( 2 , iel , ivar ) = 0.5_prec * ( & this % boundary ( 2 , iel , ivar ) + & this % extBoundary ( 2 , iel , ivar )) enddo endsubroutine AverageSides_Scalar1D_t","tags":"","loc":"proc/averagesides_scalar1d_t.html"},{"title":"BoundaryInterp_Scalar1D_t – SELF","text":"public subroutine BoundaryInterp_Scalar1D_t(this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this Contents Source Code BoundaryInterp_Scalar1D_t Source Code subroutine BoundaryInterp_Scalar1D_t ( this ) implicit none class ( Scalar1D_t ), intent ( inout ) :: this ! Local integer :: ii , iel , ivar real ( prec ) :: fbl , fbr do concurrent ( iel = 1 : this % nElem , ivar = 1 : this % nVar ) fbl = 0.0_prec fbr = 0.0_prec do ii = 1 , this % N + 1 fbl = fbl + this % interp % bMatrix ( ii , 1 ) * this % interior ( ii , iel , ivar ) ! West fbr = fbr + this % interp % bMatrix ( ii , 2 ) * this % interior ( ii , iel , ivar ) ! East enddo this % boundary ( 1 , iel , ivar ) = fbl this % boundary ( 2 , iel , ivar ) = fbr enddo endsubroutine BoundaryInterp_Scalar1D_t","tags":"","loc":"proc/boundaryinterp_scalar1d_t.html"},{"title":"Derivative_Scalar1D_t – SELF","text":"public subroutine Derivative_Scalar1D_t(this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%nelem,1:this%nvar) Contents Source Code Derivative_Scalar1D_t Source Code subroutine Derivative_Scalar1D_t ( this , df ) implicit none class ( Scalar1D_t ), intent ( in ) :: this real ( prec ), intent ( inout ) :: df ( 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: i , ii , iel , ivar real ( prec ) :: dfloc do concurrent ( i = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfloc = 0.0_prec do ii = 1 , this % N + 1 dfloc = dfloc + this % interp % dMatrix ( ii , i ) * this % interior ( ii , iel , ivar ) enddo df ( i , iel , ivar ) = dfloc enddo endsubroutine Derivative_Scalar1D_t","tags":"","loc":"proc/derivative_scalar1d_t.html"},{"title":"Free_Scalar1D_t – SELF","text":"public subroutine Free_Scalar1D_t(this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this Contents Source Code Free_Scalar1D_t Source Code subroutine Free_Scalar1D_t ( this ) implicit none class ( Scalar1D_t ), intent ( inout ) :: this this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % boundarynormal ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) endsubroutine Free_Scalar1D_t","tags":"","loc":"proc/free_scalar1d_t.html"},{"title":"GridInterp_Scalar1D_t – SELF","text":"public subroutine GridInterp_Scalar1D_t(this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%nelem,1:this%nvar) Contents Source Code GridInterp_Scalar1D_t Source Code subroutine GridInterp_Scalar1D_t ( this , f ) implicit none class ( Scalar1D_t ), intent ( in ) :: this real ( prec ), intent ( inout ) :: f ( 1 : this % M + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iel , ivar , i , ii real ( prec ) :: floc do concurrent ( i = 1 : this % M + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) floc = 0.0_prec do ii = 1 , this % N + 1 floc = floc + this % interp % iMatrix ( ii , i ) * this % interior ( ii , iel , ivar ) enddo f ( i , iel , ivar ) = floc enddo endsubroutine GridInterp_Scalar1D_t","tags":"","loc":"proc/gridinterp_scalar1d_t.html"},{"title":"Init_Scalar1D_t – SELF","text":"public subroutine Init_Scalar1D_t(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar1D_t Source Code subroutine Init_Scalar1D_t ( this , interp , nVar , nElem ) implicit none class ( Scalar1D_t ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : nelem , 1 : nvar ), & this % boundary ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : 2 , 1 : nelem , 1 : nvar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % boundarynormal = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) endsubroutine Init_Scalar1D_t","tags":"","loc":"proc/init_scalar1d_t.html"},{"title":"UpdateDevice_Scalar1D_t – SELF","text":"public subroutine UpdateDevice_Scalar1D_t(this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this Contents Source Code UpdateDevice_Scalar1D_t Source Code subroutine UpdateDevice_Scalar1D_t ( this ) implicit none class ( Scalar1D_t ), intent ( inout ) :: this endsubroutine UpdateDevice_Scalar1D_t","tags":"","loc":"proc/updatedevice_scalar1d_t.html"},{"title":"UpdateHost_Scalar1D_t – SELF","text":"public subroutine UpdateHost_Scalar1D_t(this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this Contents Source Code UpdateHost_Scalar1D_t Source Code subroutine UpdateHost_Scalar1D_t ( this ) implicit none class ( Scalar1D_t ), intent ( inout ) :: this endsubroutine UpdateHost_Scalar1D_t","tags":"","loc":"proc/updatehost_scalar1d_t.html"},{"title":"WriteHDF5_Scalar1D_t – SELF","text":"public subroutine WriteHDF5_Scalar1D_t(this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group Contents Source Code WriteHDF5_Scalar1D_t Source Code subroutine WriteHDF5_Scalar1D_t ( this , fileId , group ) implicit none class ( Scalar1D_t ), intent ( in ) :: this integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: group ! Local integer :: ivar call CreateGroup_HDF5 ( fileId , trim ( group )) do ivar = 1 , this % nVar call this % meta ( ivar )% WriteHDF5 ( group , ivar , fileId ) enddo call WriteArray_HDF5 ( fileId , trim ( group ) // \"/interior\" , & this % interior ) call WriteArray_HDF5 ( fileId , trim ( group ) // \"/boundary\" , & this % boundary ) endsubroutine WriteHDF5_Scalar1D_t","tags":"","loc":"proc/writehdf5_scalar1d_t.html"},{"title":"ApplyFlip_MappedScalar2D_t – SELF","text":"public subroutine ApplyFlip_MappedScalar2D_t(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( Mesh2D ), intent(in) :: mesh Contents Source Code ApplyFlip_MappedScalar2D_t Source Code subroutine ApplyFlip_MappedScalar2D_t ( this , mesh ) ! Apply side flips to sides where MPI exchanges took place. implicit none class ( MappedScalar2D_t ), intent ( inout ) :: this type ( Mesh2D ), intent ( in ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 integer :: i , i2 integer :: r2 , flip , ivar integer :: globalSideId real ( prec ) :: extBuff ( 1 : this % interp % N + 1 ) do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 4 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element (global id) if ( e2 > 0 ) then ! Interior Element r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 ! Need to update extBoundary with flip applied if ( flip == 1 ) then do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i extBuff ( i ) = this % extBoundary ( i2 , s1 , e1 , ivar ) enddo do i = 1 , this % interp % N + 1 this % extBoundary ( i , s1 , e1 , ivar ) = extBuff ( i ) enddo endif endif endif enddo enddo enddo endsubroutine ApplyFlip_MappedScalar2D_t","tags":"","loc":"proc/applyflip_mappedscalar2d_t.html"},{"title":"AssociateGeometry_MappedScalar2D_t – SELF","text":"public subroutine AssociateGeometry_MappedScalar2D_t(this, geometry) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( SEMQuad ), intent(in), target :: geometry Contents Source Code AssociateGeometry_MappedScalar2D_t Source Code subroutine AssociateGeometry_MappedScalar2D_t ( this , geometry ) implicit none class ( MappedScalar2D_t ), intent ( inout ) :: this type ( SEMQuad ), target , intent ( in ) :: geometry if (. not . associated ( this % geometry )) then this % geometry => geometry this % geometry_associated = . true . endif endsubroutine AssociateGeometry_MappedScalar2D_t","tags":"","loc":"proc/associategeometry_mappedscalar2d_t.html"},{"title":"DissociateGeometry_MappedScalar2D_t – SELF","text":"public subroutine DissociateGeometry_MappedScalar2D_t(this) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this Contents Source Code DissociateGeometry_MappedScalar2D_t Source Code subroutine DissociateGeometry_MappedScalar2D_t ( this ) implicit none class ( MappedScalar2D_t ), intent ( inout ) :: this if ( associated ( this % geometry )) then this % geometry => null () this % geometry_associated = . false . endif endsubroutine DissociateGeometry_MappedScalar2D_t","tags":"","loc":"proc/dissociategeometry_mappedscalar2d_t.html"},{"title":"MPIExchangeAsync_MappedScalar2D_t – SELF","text":"public subroutine MPIExchangeAsync_MappedScalar2D_t(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh Contents Source Code MPIExchangeAsync_MappedScalar2D_t Source Code subroutine MPIExchangeAsync_MappedScalar2D_t ( this , mesh ) implicit none class ( MappedScalar2D_t ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount msgCount = 0 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 4 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) ! create unique tag for each side and each variable tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 ) msgCount = msgCount + 1 call MPI_IRECV ( this % extBoundary (:, s1 , e1 , ivar ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( this % boundary (:, s1 , e1 , ivar ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedScalar2D_t","tags":"","loc":"proc/mpiexchangeasync_mappedscalar2d_t.html"},{"title":"MappedDGGradient_MappedScalar2D_t – SELF","text":"public subroutine MappedDGGradient_MappedScalar2D_t(this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) Contents Source Code MappedDGGradient_MappedScalar2D_t Source Code subroutine MappedDGGradient_MappedScalar2D_t ( this , df ) !! implicit none class ( MappedScalar2D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 2 ) ! Local integer :: iEl , iVar , i , j , ii , idir real ( prec ) :: dfdx , dfdxb , ja , bfl , bfr do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar , idir = 1 : 2 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ja = this % geometry % dsdx % interior ( ii , j , iel , 1 , idir , 1 ) dfdx = dfdx + this % interp % dgMatrix ( ii , i ) * this % interior ( ii , j , iel , ivar ) * ja enddo bfl = this % avgboundary ( j , 4 , iel , ivar ) * this % geometry % dsdx % boundary ( j , 4 , iel , 1 , idir , 1 ) ! west bfr = this % avgboundary ( j , 2 , iel , ivar ) * this % geometry % dsdx % boundary ( j , 2 , iel , 1 , idir , 1 ) ! east dfdxb = ( this % interp % bMatrix ( i , 1 ) * bfl + this % interp % bMatrix ( i , 2 ) * bfr ) / this % interp % qweights ( i ) df ( i , j , iel , ivar , idir ) = dfdx + dfdxb enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar , idir = 1 : 2 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ja = this % geometry % dsdx % interior ( i , ii , iel , 1 , idir , 2 ) dfdx = dfdx + this % interp % dgMatrix ( ii , j ) * this % interior ( i , ii , iel , ivar ) * ja enddo bfl = this % avgboundary ( i , 1 , iel , ivar ) * this % geometry % dsdx % boundary ( i , 1 , iel , 1 , idir , 2 ) ! south bfr = this % avgboundary ( i , 3 , iel , ivar ) * this % geometry % dsdx % boundary ( i , 3 , iel , 1 , idir , 2 ) ! north dfdxb = ( this % interp % bMatrix ( j , 1 ) * bfl + this % interp % bMatrix ( j , 2 ) * bfr ) / this % interp % qweights ( j ) df ( i , j , iel , ivar , idir ) = ( df ( i , j , iel , ivar , idir ) + dfdx + dfdxb ) / this % geometry % J % interior ( i , j , iEl , 1 ) enddo endsubroutine MappedDGGradient_MappedScalar2D_t","tags":"","loc":"proc/mappeddggradient_mappedscalar2d_t.html"},{"title":"MappedGradient_MappedScalar2D_t – SELF","text":"public subroutine MappedGradient_MappedScalar2D_t(this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) Contents Source Code MappedGradient_MappedScalar2D_t Source Code subroutine MappedGradient_MappedScalar2D_t ( this , df ) !! Calculates the gradient of a function using the strong form of the gradient !! in mapped coordinates. implicit none class ( MappedScalar2D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 2 ) ! Local integer :: iEl , iVar , i , j , ii , idir real ( prec ) :: dfdx , ja do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar , idir = 1 : 2 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ! dsdx(j,i) is contravariant vector i, component j ja = this % geometry % dsdx % interior ( ii , j , iel , 1 , idir , 1 ) dfdx = dfdx + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , iel , ivar ) * ja enddo df ( i , j , iel , ivar , idir ) = dfdx enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar , idir = 1 : 2 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ja = this % geometry % dsdx % interior ( i , ii , iel , 1 , idir , 2 ) dfdx = dfdx + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , iel , ivar ) * ja enddo df ( i , j , iel , ivar , idir ) = ( df ( i , j , iel , ivar , idir ) + dfdx ) / this % geometry % J % interior ( i , j , iEl , 1 ) enddo endsubroutine MappedGradient_MappedScalar2D_t","tags":"","loc":"proc/mappedgradient_mappedscalar2d_t.html"},{"title":"SetInteriorFromEquation_MappedScalar2D_t – SELF","text":"public subroutine SetInteriorFromEquation_MappedScalar2D_t(this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time Contents Source Code SetInteriorFromEquation_MappedScalar2D_t Source Code subroutine SetInteriorFromEquation_MappedScalar2D_t ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedScalar2D_t ), intent ( inout ) :: this type ( SEMQuad ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , iEl , iVar real ( prec ) :: x real ( prec ) :: y do iVar = 1 , this % nVar do iEl = 1 , this % nElem do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , iEl , 1 , 2 ) this % interior ( i , j , iEl , iVar ) = & this % eqn ( iVar )% Evaluate (( / x , y , 0.0_prec , time / )) enddo enddo enddo enddo endsubroutine SetInteriorFromEquation_MappedScalar2D_t","tags":"","loc":"proc/setinteriorfromequation_mappedscalar2d_t.html"},{"title":"SideExchange_MappedScalar2D_t – SELF","text":"public subroutine SideExchange_MappedScalar2D_t(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh Contents Source Code SideExchange_MappedScalar2D_t Source Code subroutine SideExchange_MappedScalar2D_t ( this , mesh ) implicit none class ( MappedScalar2D_t ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: e1 , e2 , s1 , s2 , e2Global integer :: flip integer :: i1 , i2 , ivar integer :: r2 integer :: rankId , offset , N integer , pointer :: elemtorank (:) ! This mapping is needed to resolve a build error with ! amdflang that appears to be caused by referencing ! the elemToRank attribute within the do concurrent ! https://github.com/FluidNumerics/SELF/issues/54 elemtorank => mesh % decomp % elemToRank (:) rankId = mesh % decomp % rankId offset = mesh % decomp % offsetElem ( rankId + 1 ) N = this % interp % N if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif do concurrent ( s1 = 1 : 4 , e1 = 1 : mesh % nElem , ivar = 1 : this % nvar ) e2Global = mesh % sideInfo ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 if ( e2Global > 0 ) then r2 = elemToRank ( e2Global ) if ( r2 == rankId ) then if ( flip == 0 ) then do i1 = 1 , N + 1 this % extBoundary ( i1 , s1 , e1 , ivar ) = & this % boundary ( i1 , s2 , e2 , ivar ) enddo elseif ( flip == 1 ) then do i1 = 1 , N + 1 i2 = N + 2 - i1 this % extBoundary ( i1 , s1 , e1 , ivar ) = & this % boundary ( i2 , s2 , e2 , ivar ) enddo endif endif endif enddo if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call this % ApplyFlip ( mesh ) endif endsubroutine SideExchange_MappedScalar2D_t","tags":"","loc":"proc/sideexchange_mappedscalar2d_t.html"},{"title":"ApplyFlip_MappedScalar3D_t – SELF","text":"public subroutine ApplyFlip_MappedScalar3D_t(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh Contents Source Code ApplyFlip_MappedScalar3D_t Source Code subroutine ApplyFlip_MappedScalar3D_t ( this , mesh ) ! Apply side flips to sides where MPI exchanges took place. implicit none class ( MappedScalar3D_t ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 integer :: i , i2 , j , j2 integer :: r2 , flip , ivar integer :: bcid real ( prec ) :: extBuff ( 1 : this % interp % N + 1 , 1 : this % interp % N + 1 ) do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 6 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 bcid = mesh % sideInfo ( 5 , s1 , e1 ) if ( e2 > 0 ) then ! Interior Element r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 ! Need to update extBoundary with flip applied if ( flip == 0 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 extBuff ( i , j ) = this % extBoundary ( i , j , s1 , e1 , ivar ) enddo enddo else if ( flip == 1 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = j extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar ) enddo enddo else if ( flip == 2 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = this % interp % N + 2 - j extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar ) enddo enddo else if ( flip == 3 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = i j2 = this % interp % N + 2 - j extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar ) enddo enddo else if ( flip == 4 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 extBuff ( i , j ) = this % extBoundary ( j , i , s1 , e1 , ivar ) enddo enddo else if ( flip == 5 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = i extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar ) enddo enddo else if ( flip == 6 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = this % interp % N + 2 - i extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar ) enddo enddo else if ( flip == 7 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = j j2 = this % interp % N + 2 - i extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar ) enddo enddo endif do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 this % extBoundary ( i , j , s1 , e1 , ivar ) = extBuff ( i , j ) enddo enddo endif endif enddo enddo enddo endsubroutine ApplyFlip_MappedScalar3D_t","tags":"","loc":"proc/applyflip_mappedscalar3d_t.html"},{"title":"AssociateGeometry_MappedScalar3D_t – SELF","text":"public subroutine AssociateGeometry_MappedScalar3D_t(this, geometry) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( SEMHex ), intent(in), target :: geometry Contents Source Code AssociateGeometry_MappedScalar3D_t Source Code subroutine AssociateGeometry_MappedScalar3D_t ( this , geometry ) implicit none class ( MappedScalar3D_t ), intent ( inout ) :: this type ( SEMHex ), target , intent ( in ) :: geometry if (. not . associated ( this % geometry )) then this % geometry => geometry this % geometry_associated = . true . endif endsubroutine AssociateGeometry_MappedScalar3D_t","tags":"","loc":"proc/associategeometry_mappedscalar3d_t.html"},{"title":"DissociateGeometry_MappedScalar3D_t – SELF","text":"public subroutine DissociateGeometry_MappedScalar3D_t(this) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this Contents Source Code DissociateGeometry_MappedScalar3D_t Source Code subroutine DissociateGeometry_MappedScalar3D_t ( this ) implicit none class ( MappedScalar3D_t ), intent ( inout ) :: this if ( associated ( this % geometry )) then this % geometry => null () this % geometry_associated = . false . endif endsubroutine DissociateGeometry_MappedScalar3D_t","tags":"","loc":"proc/dissociategeometry_mappedscalar3d_t.html"},{"title":"MPIExchangeAsync_MappedScalar3D_t – SELF","text":"public subroutine MPIExchangeAsync_MappedScalar3D_t(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh Contents Source Code MPIExchangeAsync_MappedScalar3D_t Source Code subroutine MPIExchangeAsync_MappedScalar3D_t ( this , mesh ) implicit none class ( MappedScalar3D_t ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount msgCount = 0 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 6 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 ) msgCount = msgCount + 1 call MPI_IRECV ( this % extBoundary (:,:, s1 , e1 , ivar ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , globalSideId , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( this % boundary (:,:, s1 , e1 , ivar ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , globalSideId , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedScalar3D_t","tags":"","loc":"proc/mpiexchangeasync_mappedscalar3d_t.html"},{"title":"MappedDGGradient_MappedScalar3D_t – SELF","text":"public subroutine MappedDGGradient_MappedScalar3D_t(this, df) Calculates the gradient of a function using the weak form of the gradient\nand the average boundary state.\nThis method will compute the average boundary state from the\nand  attributes of Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) Contents Source Code MappedDGGradient_MappedScalar3D_t Source Code subroutine MappedDGGradient_MappedScalar3D_t ( this , df ) !! Calculates the gradient of a function using the weak form of the gradient !! and the average boundary state. !! This method will compute the average boundary state from the !! and  attributes of implicit none class ( MappedScalar3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 3 ) ! Local integer :: iEl , iVar , i , j , k , ii , idir real ( prec ) :: dfdx , jaf , bfl , bfr do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ! dsdx(j,i) is contravariant vector i, component j jaf = this % geometry % dsdx % interior ( ii , j , k , iel , 1 , idir , 1 ) * & this % interior ( ii , j , k , iel , ivar ) dfdx = dfdx + this % interp % dgMatrix ( ii , i ) * jaf enddo bfl = this % avgboundary ( j , k , 5 , iel , ivar ) * & this % geometry % dsdx % boundary ( j , k , 5 , iel , 1 , idir , 1 ) ! west bfr = this % avgboundary ( j , k , 3 , iel , ivar ) * & this % geometry % dsdx % boundary ( j , k , 3 , iel , 1 , idir , 1 ) ! east df ( i , j , k , iel , ivar , idir ) = dfdx + & ( this % interp % bMatrix ( i , 1 ) * bfl + & this % interp % bMatrix ( i , 2 ) * bfr ) / this % interp % qweights ( i ) enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 jaf = this % geometry % dsdx % interior ( i , ii , k , iel , 1 , idir , 2 ) * & this % interior ( i , ii , k , iel , ivar ) dfdx = dfdx + this % interp % dgMatrix ( ii , j ) * jaf enddo bfl = this % avgboundary ( i , k , 2 , iel , ivar ) * & this % geometry % dsdx % boundary ( i , k , 2 , iel , 1 , idir , 2 ) ! south bfr = this % avgboundary ( i , k , 4 , iel , ivar ) * & this % geometry % dsdx % boundary ( i , k , 4 , iel , 1 , idir , 2 ) ! north dfdx = dfdx + ( this % interp % bMatrix ( j , 1 ) * bfl + & this % interp % bMatrix ( j , 2 ) * bfr ) / this % interp % qweights ( j ) df ( i , j , k , iel , ivar , idir ) = ( df ( i , j , k , iel , ivar , idir ) + dfdx ) enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 jaf = this % geometry % dsdx % interior ( i , j , ii , iel , 1 , idir , 3 ) * & this % interior ( i , j , ii , iel , ivar ) dfdx = dfdx + this % interp % dgMatrix ( ii , k ) * jaf enddo bfl = this % avgboundary ( i , j , 1 , iel , ivar ) * & this % geometry % dsdx % boundary ( i , j , 1 , iel , 1 , idir , 3 ) ! bottom bfr = this % avgboundary ( i , j , 6 , iel , ivar ) * & this % geometry % dsdx % boundary ( i , j , 6 , iel , 1 , idir , 3 ) ! top dfdx = dfdx + ( this % interp % bMatrix ( k , 1 ) * bfl + & this % interp % bMatrix ( k , 2 ) * bfr ) / this % interp % qweights ( k ) df ( i , j , k , iel , ivar , idir ) = ( df ( i , j , k , iel , ivar , idir ) + dfdx ) / & this % geometry % J % interior ( i , j , k , iEl , 1 ) enddo endsubroutine MappedDGGradient_MappedScalar3D_t","tags":"","loc":"proc/mappeddggradient_mappedscalar3d_t.html"},{"title":"MappedGradient_MappedScalar3D_t – SELF","text":"public subroutine MappedGradient_MappedScalar3D_t(this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) Contents Source Code MappedGradient_MappedScalar3D_t Source Code subroutine MappedGradient_MappedScalar3D_t ( this , df ) !! Calculates the gradient of a function using the strong form of the gradient !! in mapped coordinates. implicit none class ( MappedScalar3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 3 ) ! Local integer :: iEl , iVar , i , j , k , ii , idir real ( prec ) :: dfdx , ja do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ! dsdx(j,i) is contravariant vector i, component j ja = this % geometry % dsdx % interior ( ii , j , k , iel , 1 , idir , 1 ) dfdx = dfdx + this % interp % dMatrix ( ii , i ) * & this % interior ( ii , j , k , iel , ivar ) * ja enddo df ( i , j , k , iel , ivar , idir ) = dfdx enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ja = this % geometry % dsdx % interior ( i , ii , k , iel , 1 , idir , 2 ) dfdx = dfdx + this % interp % dMatrix ( ii , j ) * & this % interior ( i , ii , k , iel , ivar ) * ja enddo df ( i , j , k , iel , ivar , idir ) = ( df ( i , j , k , iel , ivar , idir ) + dfdx ) enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ja = this % geometry % dsdx % interior ( i , j , ii , iel , 1 , idir , 3 ) dfdx = dfdx + this % interp % dMatrix ( ii , k ) * & this % interior ( i , j , ii , iel , ivar ) * ja enddo df ( i , j , k , iel , ivar , idir ) = ( df ( i , j , k , iel , ivar , idir ) + dfdx ) / & this % geometry % J % interior ( i , j , k , iEl , 1 ) enddo endsubroutine MappedGradient_MappedScalar3D_t","tags":"","loc":"proc/mappedgradient_mappedscalar3d_t.html"},{"title":"SetInteriorFromEquation_MappedScalar3D_t – SELF","text":"public subroutine SetInteriorFromEquation_MappedScalar3D_t(this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time Contents Source Code SetInteriorFromEquation_MappedScalar3D_t Source Code subroutine SetInteriorFromEquation_MappedScalar3D_t ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedScalar3D_t ), intent ( inout ) :: this type ( SEMHex ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , k , iEl , iVar real ( prec ) :: x real ( prec ) :: y real ( prec ) :: z do iVar = 1 , this % nVar do iEl = 1 , this % nElem do k = 1 , this % interp % N + 1 do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , k , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , k , iEl , 1 , 2 ) z = geometry % x % interior ( i , j , k , iEl , 1 , 3 ) this % interior ( i , j , k , iEl , iVar ) = & this % eqn ( iVar )% Evaluate (( / x , y , z , time / )) enddo enddo enddo enddo enddo endsubroutine SetInteriorFromEquation_MappedScalar3D_t","tags":"","loc":"proc/setinteriorfromequation_mappedscalar3d_t.html"},{"title":"SideExchange_MappedScalar3D_t – SELF","text":"public subroutine SideExchange_MappedScalar3D_t(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh Contents Source Code SideExchange_MappedScalar3D_t Source Code subroutine SideExchange_MappedScalar3D_t ( this , mesh ) implicit none class ( MappedScalar3D_t ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , e2 , s1 , s2 , e2Global integer :: flip integer :: i , i2 , j , j2 , ivar integer :: r2 integer :: rankId , offset integer , pointer :: elemtorank (:) elemtorank => mesh % decomp % elemToRank (:) rankId = mesh % decomp % rankId offset = mesh % decomp % offsetElem ( rankId + 1 ) if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif do concurrent ( s1 = 1 : 6 , e1 = 1 : mesh % nElem , ivar = 1 : this % nvar ) e2Global = mesh % sideInfo ( 3 , s1 , e1 ) s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 if ( e2Global > 0 ) then r2 = elemToRank ( e2Global ) if ( r2 == rankId ) then e2 = e2Global - offset if ( flip == 0 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( i , j , s2 , e2 , ivar ) enddo enddo else if ( flip == 1 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = j this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( i2 , j2 , s2 , e2 , ivar ) enddo enddo else if ( flip == 2 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = this % interp % N + 2 - j this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( i2 , j2 , s2 , e2 , ivar ) enddo enddo else if ( flip == 3 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = i j2 = this % interp % N + 2 - j this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( i2 , j2 , s2 , e2 , ivar ) enddo enddo else if ( flip == 4 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( j , i , s2 , e2 , ivar ) enddo enddo else if ( flip == 5 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = i this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( i2 , j2 , s2 , e2 , ivar ) enddo enddo else if ( flip == 6 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = this % interp % N + 2 - i this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( i2 , j2 , s2 , e2 , ivar ) enddo enddo else if ( flip == 7 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = j j2 = this % interp % N + 2 - i this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( i2 , j2 , s2 , e2 , ivar ) enddo enddo endif endif endif enddo if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call this % ApplyFlip ( mesh ) endif endsubroutine SideExchange_MappedScalar3D_t","tags":"","loc":"proc/sideexchange_mappedscalar3d_t.html"},{"title":"Free_MappedScalar3D – SELF","text":"public subroutine Free_MappedScalar3D(this) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this Contents Source Code Free_MappedScalar3D Source Code subroutine Free_MappedScalar3D ( this ) implicit none class ( MappedScalar3D ), intent ( inout ) :: this this % nVar = 0 this % nElem = 0 this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % boundarynormal ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call gpuCheck ( hipFree ( this % avgBoundary_gpu )) call gpuCheck ( hipFree ( this % boundarynormal_gpu )) call gpuCheck ( hipFree ( this % interpWork1 )) call gpuCheck ( hipFree ( this % interpWork2 )) call gpuCheck ( hipFree ( this % jas_gpu )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_MappedScalar3D","tags":"","loc":"proc/free_mappedscalar3d.html"},{"title":"Init_MappedScalar3D – SELF","text":"public subroutine Init_MappedScalar3D(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_MappedScalar3D Source Code subroutine Init_MappedScalar3D ( this , interp , nVar , nElem ) implicit none class ( MappedScalar3D ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! Local integer ( c_size_t ) :: workSize this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar ), & this % boundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : 3 * nvar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec this % boundarynormal = 0.0_prec allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( this % avgBoundary_gpu , sizeof ( this % avgBoundary ))) call gpuCheck ( hipMalloc ( this % boundarynormal_gpu , sizeof ( this % boundarynormal ))) workSize = ( interp % N + 1 ) * ( interp % N + 1 ) * ( interp % M + 1 ) * nelem * nvar * prec call gpuCheck ( hipMalloc ( this % interpWork1 , workSize )) workSize = ( interp % N + 1 ) * ( interp % M + 1 ) * ( interp % M + 1 ) * nelem * nvar * prec call gpuCheck ( hipMalloc ( this % interpWork2 , workSize )) workSize = ( interp % N + 1 ) * ( interp % N + 1 ) * ( interp % N + 1 ) * nelem * nvar * 9 * prec call gpuCheck ( hipMalloc ( this % jas_gpu , workSize )) call this % UpdateDevice () call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_MappedScalar3D","tags":"","loc":"proc/init_mappedscalar3d.html"},{"title":"MPIExchangeAsync_MappedScalar3D – SELF","text":"public subroutine MPIExchangeAsync_MappedScalar3D(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh Contents Source Code MPIExchangeAsync_MappedScalar3D Source Code subroutine MPIExchangeAsync_MappedScalar3D ( this , mesh ) implicit none class ( MappedScalar3D ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount real ( prec ), pointer :: boundary (:,:,:,:,:) real ( prec ), pointer :: extboundary (:,:,:,:,:) msgCount = 0 call c_f_pointer ( this % boundary_gpu , boundary ,[ this % interp % N + 1 , this % interp % N + 1 , 6 , this % nelem , this % nvar ]) call c_f_pointer ( this % extboundary_gpu , extboundary ,[ this % interp % N + 1 , this % interp % N + 1 , 6 , this % nelem , this % nvar ]) do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 6 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) ! create unique tag for each side and each variable tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 ) msgCount = msgCount + 1 call MPI_IRECV ( extBoundary (:,:, s1 , e1 , ivar ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( boundary (:,:, s1 , e1 , ivar ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedScalar3D","tags":"","loc":"proc/mpiexchangeasync_mappedscalar3d.html"},{"title":"MappedDGGradient_MappedScalar3D – SELF","text":"public subroutine MappedDGGradient_MappedScalar3D(this, df) Calculates the gradient of a function using the weak form of the gradient\nand the average boundary state.\nThis method will compute the average boundary state from the\nand  attributes of Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: this type(c_ptr), intent(inout) :: df Contents Source Code MappedDGGradient_MappedScalar3D Source Code subroutine MappedDGGradient_MappedScalar3D ( this , df ) !! Calculates the gradient of a function using the weak form of the gradient !! and the average boundary state. !! This method will compute the average boundary state from the !! and  attributes of implicit none class ( MappedScalar3D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:,:) type ( c_ptr ) :: fc call ContravariantWeight_3D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % jas_gpu , & this % interp % N , this % nvar , this % nelem ) ! From Vector divergence call c_f_pointer ( this % jas_gpu , f_p , & [ this % interp % N + 1 , this % interp % N + 1 , this % interp % N + 1 , this % nelem , 3 * this % nvar , 3 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_3d ( this % interp % dgMatrix_gpu , fc , df , & this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_3d ( this % interp % dgMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 3 )) call self_blas_matrixop_dim3_3d ( this % interp % dgMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) f_p => null () ! Do the boundary terms call NormalWeight_3D_gpu ( this % avgBoundary_gpu , & this % geometry % nhat % boundary_gpu , this % geometry % nscale % boundary_gpu , & this % boundarynormal_gpu , & this % interp % N , this % nvar , this % nelem ) call DG_BoundaryContribution_3D_gpu ( this % interp % bmatrix_gpu , this % interp % qweights_gpu , & this % boundarynormal_gpu , df , this % interp % N , 3 * this % nvar , this % nelem ) call JacobianWeight_3D_gpu ( df , this % geometry % J % interior_gpu , this % N , 3 * this % nVar , this % nelem ) endsubroutine MappedDGGradient_MappedScalar3D","tags":"","loc":"proc/mappeddggradient_mappedscalar3d.html"},{"title":"MappedGradient_MappedScalar3D – SELF","text":"public subroutine MappedGradient_MappedScalar3D(this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this type(c_ptr), intent(out) :: df Contents Source Code MappedGradient_MappedScalar3D Source Code subroutine MappedGradient_MappedScalar3D ( this , df ) !! Calculates the gradient of a function using the strong form of the gradient !! in mapped coordinates. implicit none class ( MappedScalar3D ), intent ( inout ) :: this type ( c_ptr ), intent ( out ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:,:) type ( c_ptr ) :: fc call ContravariantWeight_3D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % jas_gpu , & this % interp % N , this % nvar , this % nelem ) ! From Vector divergence call c_f_pointer ( this % jas_gpu , f_p , & [ this % interp % N + 1 , this % interp % N + 1 , this % interp % N + 1 , this % nelem , 3 * this % nvar , 3 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_3d ( this % interp % dMatrix_gpu , fc , df , & this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_3d ( this % interp % dMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 3 )) call self_blas_matrixop_dim3_3d ( this % interp % dMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) f_p => null () call JacobianWeight_3D_gpu ( df , this % geometry % J % interior_gpu , this % N , 3 * this % nVar , this % nelem ) endsubroutine MappedGradient_MappedScalar3D","tags":"","loc":"proc/mappedgradient_mappedscalar3d.html"},{"title":"SetInteriorFromEquation_MappedScalar3D – SELF","text":"public subroutine SetInteriorFromEquation_MappedScalar3D(this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time Contents Source Code SetInteriorFromEquation_MappedScalar3D Source Code subroutine SetInteriorFromEquation_MappedScalar3D ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedScalar3D ), intent ( inout ) :: this type ( SEMHex ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , k , iEl , iVar real ( prec ) :: x real ( prec ) :: y real ( prec ) :: z do iVar = 1 , this % nVar do iEl = 1 , this % nElem do k = 1 , this % interp % N + 1 do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , k , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , k , iEl , 1 , 2 ) z = geometry % x % interior ( i , j , k , iEl , 1 , 3 ) this % interior ( i , j , k , iEl , iVar ) = & this % eqn ( iVar )% Evaluate (( / x , y , z , time / )) enddo enddo enddo enddo enddo call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) endsubroutine SetInteriorFromEquation_MappedScalar3D","tags":"","loc":"proc/setinteriorfromequation_mappedscalar3d.html"},{"title":"SideExchange_MappedScalar3D – SELF","text":"public subroutine SideExchange_MappedScalar3D(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh Contents Source Code SideExchange_MappedScalar3D Source Code subroutine SideExchange_MappedScalar3D ( this , mesh ) implicit none class ( MappedScalar3D ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: offset offset = mesh % decomp % offsetElem ( mesh % decomp % rankId + 1 ) if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif call SideExchange_3D_gpu ( this % extboundary_gpu , & this % boundary_gpu , mesh % sideinfo_gpu , mesh % decomp % elemToRank_gpu , & mesh % decomp % rankid , offset , this % interp % N , this % nvar , this % nelem ) if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call ApplyFlip_3D_gpu ( this % extboundary_gpu , mesh % sideInfo_gpu , & mesh % decomp % elemToRank_gpu , mesh % decomp % rankId , & offset , this % interp % N , this % nVar , this % nElem ) endif endsubroutine SideExchange_MappedScalar3D","tags":"","loc":"proc/sideexchange_mappedscalar3d.html"},{"title":"ContravariantWeight_3D_gpu – SELF","text":"interface public subroutine ContravariantWeight_3D_gpu(f, dsdx, jaf, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: f type(c_ptr), value :: dsdx type(c_ptr), value :: jaf integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel","tags":"","loc":"interface/contravariantweight_3d_gpu.html"},{"title":"NormalWeight_3D_gpu – SELF","text":"interface public subroutine NormalWeight_3D_gpu(fb, nhat, nscale, fbn, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: fb type(c_ptr), value :: nhat type(c_ptr), value :: nscale type(c_ptr), value :: fbn integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel","tags":"","loc":"interface/normalweight_3d_gpu.html"},{"title":"AverageSides_Vector3D – SELF","text":"public subroutine AverageSides_Vector3D(this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this Contents Source Code AverageSides_Vector3D Source Code subroutine AverageSides_Vector3D ( this ) implicit none class ( Vector3D ), intent ( inout ) :: this call Average_gpu ( this % avgBoundary_gpu , this % boundary_gpu , this % extBoundary_gpu , size ( this % boundary )) endsubroutine AverageSides_Vector3D","tags":"","loc":"proc/averagesides_vector3d.html"},{"title":"BoundaryInterp_Vector3D – SELF","text":"public subroutine BoundaryInterp_Vector3D(this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this Contents Source Code BoundaryInterp_Vector3D Source Code subroutine BoundaryInterp_Vector3D ( this ) implicit none class ( Vector3D ), intent ( inout ) :: this call BoundaryInterp_3D_gpu ( this % interp % bMatrix_gpu , this % interior_gpu , this % boundary_gpu , & this % interp % N , 3 * this % nvar , this % nelem ) endsubroutine BoundaryInterp_Vector3D","tags":"","loc":"proc/boundaryinterp_vector3d.html"},{"title":"Divergence_Vector3D – SELF","text":"public subroutine Divergence_Vector3D(this, df) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df Contents Source Code Divergence_Vector3D Source Code subroutine Divergence_Vector3D ( this , df ) implicit none class ( Vector3D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df !Local real ( prec ), pointer :: f_p (:,:,:,:,:,:) type ( c_ptr ) :: fc call c_f_pointer ( this % interior_gpu , f_p , & [ this % interp % N + 1 , this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 3 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_3d ( this % interp % dMatrix_gpu , fc , df , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_3d ( this % interp % dMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 3 )) call self_blas_matrixop_dim3_3d ( this % interp % dMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) f_p => null () endsubroutine Divergence_Vector3D","tags":"","loc":"proc/divergence_vector3d.html"},{"title":"Free_Vector3D – SELF","text":"public subroutine Free_Vector3D(this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this Contents Source Code Free_Vector3D Source Code subroutine Free_Vector3D ( this ) implicit none class ( Vector3D ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % boundaryNormal ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call gpuCheck ( hipFree ( this % avgBoundary_gpu )) call gpuCheck ( hipFree ( this % boundaryNormal_gpu )) call gpuCheck ( hipFree ( this % interpWork1 )) call gpuCheck ( hipFree ( this % interpWork2 )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Vector3D","tags":"","loc":"proc/free_vector3d.html"},{"title":"Gradient_Vector3D – SELF","text":"public subroutine Gradient_Vector3D(this, df) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df Contents Source Code Gradient_Vector3D Source Code subroutine Gradient_Vector3D ( this , df ) implicit none class ( Vector3D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df !Local real ( prec ), pointer :: df_p (:,:,:,:,:,:,:) real ( prec ), pointer :: dfloc (:,:,:,:,:) type ( c_ptr ) :: dfc call c_f_pointer ( df , df_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 2 , 2 ]) dfloc ( 1 :, 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 :, 1 , 1 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim1_3d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , & this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) dfloc ( 1 :, 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 :, 1 , 2 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim2_3d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , 0.0_c_prec , & this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) dfloc ( 1 :, 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 :, 1 , 3 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim3_3d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , 0.0_c_prec , & this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) dfloc => null () df_p => null () endsubroutine Gradient_Vector3D","tags":"","loc":"proc/gradient_vector3d.html"},{"title":"GridInterp_Vector3D – SELF","text":"public subroutine GridInterp_Vector3D(this, f) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this type(c_ptr), intent(inout) :: f Contents Source Code GridInterp_Vector3D Source Code subroutine GridInterp_Vector3D ( this , f ) implicit none class ( Vector3D ), intent ( inout ) :: this type ( c_ptr ), intent ( inout ) :: f call self_blas_matrixop_dim1_3d ( this % interp % iMatrix_gpu , this % interior_gpu , & this % interpWork1 , this % N , this % M , 3 * this % nvar , this % nelem , & this % blas_handle ) call self_blas_matrixop_dim2_3d ( this % interp % iMatrix_gpu , this % interpWork1 , this % interpWork2 , & 0.0_c_prec , this % N , this % M , 3 * this % nvar , this % nelem , & this % blas_handle ) call self_blas_matrixop_dim3_3d ( this % interp % iMatrix_gpu , this % interpWork2 , f , & 0.0_c_prec , this % N , this % M , 3 * this % nvar , this % nelem , & this % blas_handle ) endsubroutine GridInterp_Vector3D","tags":"","loc":"proc/gridinterp_vector3d.html"},{"title":"Init_Vector3D – SELF","text":"public subroutine Init_Vector3D(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Vector3D Source Code subroutine Init_Vector3D ( this , interp , nVar , nElem ) implicit none class ( Vector3D ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i integer ( c_size_t ) :: workSize this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % boundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % boundaryNormal ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 3 * nVar )) ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 3 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo this % interior = 0.0_prec this % boundary = 0.0_prec this % boundarynormal = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( this % avgBoundary_gpu , sizeof ( this % avgBoundary ))) call gpuCheck ( hipMalloc ( this % boundaryNormal_gpu , sizeof ( this % boundaryNormal ))) workSize = ( interp % N + 1 ) * ( interp % N + 1 ) * ( interp % M + 1 ) * nelem * nvar * 3 * prec call gpuCheck ( hipMalloc ( this % interpWork1 , workSize )) workSize = ( interp % N + 1 ) * ( interp % M + 1 ) * ( interp % M + 1 ) * nelem * nvar * 3 * prec call gpuCheck ( hipMalloc ( this % interpWork2 , workSize )) call this % UpdateDevice () call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_Vector3D","tags":"","loc":"proc/init_vector3d.html"},{"title":"UpdateDevice_Vector3D – SELF","text":"public subroutine UpdateDevice_Vector3D(this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this Contents Source Code UpdateDevice_Vector3D Source Code subroutine UpdateDevice_Vector3D ( this ) implicit none class ( Vector3D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundary_gpu , c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % avgboundary_gpu , c_loc ( this % avgboundary ), sizeof ( this % avgboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundaryNormal_gpu , c_loc ( this % boundaryNormal ), sizeof ( this % boundaryNormal ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Vector3D","tags":"","loc":"proc/updatedevice_vector3d.html"},{"title":"UpdateHost_Vector3D – SELF","text":"public subroutine UpdateHost_Vector3D(this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this Contents Source Code UpdateHost_Vector3D Source Code subroutine UpdateHost_Vector3D ( this ) implicit none class ( Vector3D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), this % interior_gpu , sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), this % extboundary_gpu , sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % avgboundary ), this % avgboundary_gpu , sizeof ( this % avgboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundaryNormal ), this % boundaryNormal_gpu , sizeof ( this % boundaryNormal ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Vector3D","tags":"","loc":"proc/updatehost_vector3d.html"},{"title":"Free_Lagrange – SELF","text":"public subroutine Free_Lagrange(this) Frees all memory (host and device) associated with an instance of the Lagrange class Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: this Lagrange class instance Contents Source Code Free_Lagrange Source Code subroutine Free_Lagrange ( this ) !! Frees all memory (host and device) associated with an instance of the Lagrange class implicit none class ( Lagrange ), intent ( inout ) :: this !! Lagrange class instance deallocate ( this % controlPoints ) deallocate ( this % targetPoints ) deallocate ( this % bWeights ) deallocate ( this % qWeights ) deallocate ( this % iMatrix ) deallocate ( this % dMatrix ) deallocate ( this % dgMatrix ) deallocate ( this % bMatrix ) call gpuCheck ( hipFree ( this % iMatrix_gpu )) call gpuCheck ( hipFree ( this % dMatrix_gpu )) call gpuCheck ( hipFree ( this % dgMatrix_gpu )) call gpuCheck ( hipFree ( this % bMatrix_gpu )) call gpuCheck ( hipFree ( this % qWeights_gpu )) endsubroutine Free_Lagrange","tags":"","loc":"proc/free_lagrange.html"},{"title":"Init_Lagrange – SELF","text":"public subroutine Init_Lagrange(this, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange class\nOn output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(out) :: this Lagrange class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) Contents Source Code Init_Lagrange Source Code subroutine Init_Lagrange ( this , N , controlNodeType , M , targetNodeType ) !! Initialize an instance of the Lagrange class !! On output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of !! control points, number of target points, and the types for the control and target nodes. !! If a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. implicit none class ( Lagrange ), intent ( out ) :: this !! Lagrange class instance integer , intent ( in ) :: N !! The number of control points for interpolant integer , intent ( in ) :: M !! The number of target points for the interpolant integer , intent ( in ) :: controlNodeType !! The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) integer , intent ( in ) :: targetNodeType !! The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) ! -------! ! Local real ( prec ) :: q ( 0 : M ) if (. not . GPUAvailable ()) then print * , __ FILE__ , ':' , __ LINE__ , ' : Error : Attempt to use GPU extension, but GPU is not available.' stop 1 endif this % N = N this % M = M this % controlNodeType = controlNodeType this % targetNodeType = targetNodeType allocate ( this % controlPoints ( 1 : N + 1 ), & this % targetPoints ( 1 : M + 1 ), & this % bWeights ( 1 : N + 1 ), & this % qWeights ( 1 : N + 1 ), & this % iMatrix ( 1 : N + 1 , 1 : M + 1 ), & this % dMatrix ( 1 : N + 1 , 1 : N + 1 ), & this % dgMatrix ( 1 : N + 1 , 1 : N + 1 ), & this % bMatrix ( 1 : N + 1 , 1 : 2 )) if ( controlNodeType == GAUSS . or . controlNodeType == GAUSS_LOBATTO ) then call LegendreQuadrature ( N , & this % controlPoints , & this % qWeights , & controlNodeType ) elseif ( controlNodeType == CHEBYSHEV_GAUSS . or . controlNodeType == CHEBYSHEV_GAUSS_LOBATTO ) then call ChebyshevQuadrature ( N , & this % controlPoints , & this % qWeights , & controlNodeType ) elseif ( controlNodeType == UNIFORM ) then this % controlPoints = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , N ) this % qWeights = 2.0_prec / real ( N , prec ) endif ! Target Points if ( targetNodeType == GAUSS . or . targetNodeType == GAUSS_LOBATTO ) then call LegendreQuadrature ( M , & this % targetPoints , & q , & targetNodeType ) elseif ( targetNodeType == UNIFORM ) then this % targetPoints = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , M ) endif call this % CalculateBarycentricWeights () call this % CalculateInterpolationMatrix () call this % CalculateDerivativeMatrix () this % bMatrix ( 1 : N + 1 , 1 ) = this % CalculateLagrangePolynomials ( - 1.0_prec ) this % bMatrix ( 1 : N + 1 , 2 ) = this % CalculateLagrangePolynomials ( 1.0_prec ) call gpuCheck ( hipMalloc ( this % iMatrix_gpu , sizeof ( this % iMatrix ))) call gpuCheck ( hipMalloc ( this % dMatrix_gpu , sizeof ( this % dMatrix ))) call gpuCheck ( hipMalloc ( this % dgMatrix_gpu , sizeof ( this % dgMatrix ))) call gpuCheck ( hipMalloc ( this % bMatrix_gpu , sizeof ( this % bMatrix ))) call gpuCheck ( hipMalloc ( this % qWeights_gpu , sizeof ( this % qWeights ))) call gpuCheck ( hipMemcpy ( this % iMatrix_gpu , & c_loc ( this % iMatrix ), & sizeof ( this % iMatrix ), & hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % dMatrix_gpu , & c_loc ( this % dMatrix ), & sizeof ( this % dMatrix ), & hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % dgMatrix_gpu , & c_loc ( this % dgMatrix ), & sizeof ( this % dgMatrix ), & hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % bMatrix_gpu , & c_loc ( this % bMatrix ), & sizeof ( this % bMatrix ), & hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % qWeights_gpu , & c_loc ( this % qWeights ), & sizeof ( this % qWeights ), & hipMemcpyHostToDevice )) endsubroutine Init_Lagrange","tags":"","loc":"proc/init_lagrange.html"},{"title":"Free_DomainDecomposition – SELF","text":"public subroutine Free_DomainDecomposition(this) Arguments Type Intent Optional Attributes Name class( DomainDecomposition ), intent(inout) :: this Contents Source Code Free_DomainDecomposition Source Code subroutine Free_DomainDecomposition ( this ) implicit none class ( DomainDecomposition ), intent ( inout ) :: this ! Local integer :: ierror if ( associated ( this % offSetElem )) then deallocate ( this % offSetElem ) endif if ( associated ( this % elemToRank )) then deallocate ( this % elemToRank ) call gpuCheck ( hipFree ( this % elemToRank_gpu )) endif if ( allocated ( this % requests )) deallocate ( this % requests ) if ( allocated ( this % stats )) deallocate ( this % stats ) if ( this % mpiEnabled ) then print * , __ FILE__ , \" : Rank \" , this % rankId + 1 , \"/\" , this % nRanks , \" checking out.\" call MPI_FINALIZE ( ierror ) endif endsubroutine Free_DomainDecomposition","tags":"","loc":"proc/free_domaindecomposition.html"},{"title":"SetElemToRank_DomainDecomposition – SELF","text":"public subroutine SetElemToRank_DomainDecomposition(this, nElem) Arguments Type Intent Optional Attributes Name class( DomainDecomposition ), intent(inout) :: this integer, intent(in) :: nElem Contents Source Code SetElemToRank_DomainDecomposition Source Code subroutine SetElemToRank_DomainDecomposition ( this , nElem ) implicit none class ( DomainDecomposition ), intent ( inout ) :: this integer , intent ( in ) :: nElem ! Local integer :: iel this % nElem = nElem allocate ( this % elemToRank ( 1 : nelem )) call gpuCheck ( hipMalloc ( this % elemToRank_gpu , sizeof ( this % elemToRank ))) call DomainDecomp ( nElem , & this % nRanks , & this % offSetElem ) do iel = 1 , nElem call ElemToRank ( this % nRanks , & this % offSetElem , & iel , & this % elemToRank ( iel )) enddo call gpuCheck ( hipMemcpy ( this % elemToRank_gpu , c_loc ( this % elemToRank ), sizeof ( this % elemToRank ), hipMemcpyHostToDevice )) endsubroutine SetElemToRank_DomainDecomposition","tags":"","loc":"proc/setelemtorank_domaindecomposition.html"},{"title":"Free_Mesh2D – SELF","text":"public subroutine Free_Mesh2D(this) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: this Contents Source Code Free_Mesh2D Source Code subroutine Free_Mesh2D ( this ) implicit none class ( Mesh2D ), intent ( inout ) :: this this % nElem = 0 this % nNodes = 0 this % nSides = 0 this % nCornerNodes = 0 this % nUniqueSides = 0 this % nUniqueNodes = 0 this % nBCs = 0 deallocate ( this % elemInfo ) deallocate ( this % sideInfo ) deallocate ( this % nodeCoords ) deallocate ( this % globalNodeIDs ) deallocate ( this % CGNSCornerMap ) deallocate ( this % CGNSSideMap ) deallocate ( this % BCType ) deallocate ( this % BCNames ) call this % decomp % Free () call gpuCheck ( hipFree ( this % sideInfo_gpu )) endsubroutine Free_Mesh2D","tags":"","loc":"proc/free_mesh2d.html"},{"title":"Init_Mesh2D – SELF","text":"public subroutine Init_Mesh2D(this, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: this integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs Contents Source Code Init_Mesh2D Source Code subroutine Init_Mesh2D ( this , nGeo , nElem , nSides , nNodes , nBCs ) implicit none class ( Mesh2D ), intent ( inout ) :: this integer , intent ( in ) :: nGeo integer , intent ( in ) :: nElem integer , intent ( in ) :: nSides integer , intent ( in ) :: nNodes integer , intent ( in ) :: nBCs ! Local integer :: i , j , l this % nGeo = nGeo this % nElem = nElem this % nGlobalElem = nElem this % nNodes = nNodes this % nSides = nSides this % nCornerNodes = 0 this % nUniqueNodes = 0 this % nUniqueSides = 0 this % nBCs = nBCs allocate ( this % elemInfo ( 1 : 6 , 1 : nElem )) allocate ( this % sideInfo ( 1 : 5 , 1 : 4 , 1 : nElem )) allocate ( this % nodeCoords ( 1 : 2 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % globalNodeIDs ( 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % CGNSCornerMap ( 1 : 2 , 1 : 4 )) allocate ( this % CGNSSideMap ( 1 : 2 , 1 : 4 )) allocate ( this % BCType ( 1 : 4 , 1 : nBCs )) allocate ( this % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation this % CGNSCornerMap ( 1 : 2 , 1 ) = ( / 1 , 1 / ) this % CGNSCornerMap ( 1 : 2 , 2 ) = ( / nGeo + 1 , 1 / ) this % CGNSCornerMap ( 1 : 2 , 3 ) = ( / nGeo + 1 , nGeo + 1 / ) this % CGNSCornerMap ( 1 : 2 , 4 ) = ( / 1 , nGeo + 1 / ) ! Maps from local corner node id to CGNS side this % CGNSSideMap ( 1 : 2 , 1 ) = ( / 1 , 2 / ) this % CGNSSideMap ( 1 : 2 , 2 ) = ( / 2 , 3 / ) this % CGNSSideMap ( 1 : 2 , 3 ) = ( / 4 , 3 / ) this % CGNSSideMap ( 1 : 2 , 4 ) = ( / 1 , 4 / ) call gpuCheck ( hipMalloc ( this % sideInfo_gpu , sizeof ( this % sideInfo ))) endsubroutine Init_Mesh2D","tags":"","loc":"proc/init_mesh2d.html"},{"title":"Read_HOPr_Mesh2D – SELF","text":"public subroutine Read_HOPr_Mesh2D(this, meshFile, enableDomainDecomposition) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: this character, intent(in) :: meshFile logical, intent(in), optional :: enableDomainDecomposition Contents Source Code Read_HOPr_Mesh2D Source Code subroutine Read_HOPr_Mesh2D ( this , meshFile , enableDomainDecomposition ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 ! Adapted for 2D Mesh : Note that HOPR does not have 2D mesh output. implicit none class ( Mesh2D ), intent ( out ) :: this character ( * ), intent ( in ) :: meshFile logical , intent ( in ), optional :: enableDomainDecomposition ! Local integer ( HID_T ) :: fileId integer ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) integer :: nGlobalElem integer :: firstElem integer :: firstNode integer :: firstSide integer :: nLocalElems integer :: nLocalNodes3D integer :: nLocalSides3D integer :: nUniqueSides3D integer :: nLocalNodes2D integer :: nLocalSides2D integer :: nUniqueSides2D integer :: nGeo , nBCs integer :: eid , lsid , iSide integer :: i , j , nid integer , dimension (:,:), allocatable :: hopr_elemInfo integer , dimension (:,:), allocatable :: hopr_sideInfo real ( prec ), dimension (:,:), allocatable :: hopr_nodeCoords integer , dimension (:), allocatable :: hopr_globalNodeIDs integer , dimension (:,:), allocatable :: bcType if ( present ( enableDomainDecomposition )) then call this % decomp % init ( enableDomainDecomposition ) else call this % decomp % init (. false .) endif print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : Reading HOPr mesh from' // trim ( meshfile ) if ( this % decomp % mpiEnabled ) then call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId , this % decomp % mpiComm ) else call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId ) endif call ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) call ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) call ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) call ReadAttribute_HDF5 ( fileId , 'nUniqueSides' , nUniqueSides3D ) print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : N Global Elements = ' , nGlobalElem print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : Mesh geometry degree = ' , nGeo print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : N Boundary conditions = ' , nBCs print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : N Unique Sides (3D) = ' , nUniqueSides3D ! Read BCType allocate ( bcType ( 1 : 4 , 1 : nBCS )) if ( this % decomp % mpiEnabled ) then offset (:) = 0 call ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) else call ReadArray_HDF5 ( fileId , 'BCType' , bcType ) endif ! Read local subarray of ElemInfo call this % decomp % GenerateDecomposition ( nGlobalElem , nUniqueSides3D ) firstElem = this % decomp % offsetElem ( this % decomp % rankId + 1 ) + 1 nLocalElems = this % decomp % offsetElem ( this % decomp % rankId + 2 ) - & this % decomp % offsetElem ( this % decomp % rankId + 1 ) print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : element offset = ' , firstElem - 1 print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : n_elements = ' , nLocalElems ! Allocate Space for hopr_elemInfo! allocate ( hopr_elemInfo ( 1 : 6 , 1 : nLocalElems )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstElem - 1 / ) call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) else call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) endif ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo ( 5 , 1 ) + 1 nLocalNodes3D = hopr_elemInfo ( 6 , nLocalElems ) - hopr_elemInfo ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! allocate ( hopr_nodeCoords ( 1 : 3 , nLocalNodes3D ), hopr_globalNodeIDs ( 1 : nLocalNodes3D )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) else call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) endif ! Read local subarray of SideInfo firstSide = hopr_elemInfo ( 3 , 1 ) + 1 nLocalSides3D = hopr_elemInfo ( 4 , nLocalElems ) - hopr_elemInfo ( 3 , 1 ) ! Allocate space for hopr_sideInfo allocate ( hopr_sideInfo ( 1 : 5 , 1 : nLocalSides3D )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstSide - 1 / ) call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) else call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) endif call Close_HDF5 ( fileID ) ! ---- Done reading 3-D Mesh information ---- ! ! Now we need to convert from 3-D to 2-D ! nLocalSides2D = nLocalSides3D - 2 * nLocalElems nUniqueSides2D = nUniqueSides3D - 2 * nGlobalElem ! Remove the \"top\" and \"bottom\" faces nLocalNodes2D = nLocalNodes2D - nLocalElems * nGeo * ( nGeo + 1 ) ** 2 ! Remove the third dimension print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : N local sides  : ' , nLocalSides2D call this % Init ( nGeo , nLocalElems , nLocalSides2D , nLocalNodes2D , nBCs ) this % nUniqueSides = nUniqueSides2D ! Store the number of sides in the global mesh ! Copy data from local arrays into this !  elemInfo(1:6,iEl) !    1 - Element Type !    2 - Zone !    3 - offset index for side array (not needed when all quads are assumed) !    4 - last index for side array (not needed when all quads are assumed) !    5 - offset index for node array (not needed when all quads are assumed) !    6 - last index for node array (not needed when all quads are assumed) this % elemInfo = hopr_elemInfo this % quadrature = UNIFORM ! HOPr uses uniformly spaced points ! Grab the node coordinates (x and y only) from the \"bottom\" layer of the extruded mesh do eid = 1 , this % nElem do j = 1 , nGeo + 1 do i = 1 , nGeo + 1 nid = i + ( nGeo + 1 ) * ( j - 1 + ( nGeo + 1 ) * (( nGeo + 1 ) * ( eid - 1 ))) this % nodeCoords ( 1 : 2 , i , j , eid ) = hopr_nodeCoords ( 1 : 2 , nid ) this % globalNodeIDs ( i , j , eid ) = hopr_globalNodeIDs ( nid ) enddo enddo enddo ! Grab the south, west, north, and south sides of the elements !  sideInfo(1:5,iSide,iEl) ! !    1 - Side Type (currently unused in SELF) !    2 - Global Side ID (Used for message passing. Don't need to change) !    3 - Neighbor Element ID (Can stay the same) !    4 - 10*( neighbor local side )  + flip (Need to recalculate flip) !    5 - Boundary Condition ID (Can stay the same) do eid = 1 , this % nElem do lsid = 1 , 4 ! Calculate the 3-D side ID from the 2-D local side id and element ID iSide = lsid + 1 + 6 * ( eid - 1 ) this % sideInfo ( 1 : 5 , lsid , eid ) = hopr_sideInfo ( 1 : 5 , iSide ) ! Adjust the secondary side index for 2-D this % sideInfo ( 4 , lsid , eid ) = this % sideInfo ( 4 , lsid , eid ) - 10 enddo enddo call this % RecalculateFlip () deallocate ( hopr_elemInfo , hopr_nodeCoords , hopr_globalNodeIDs , hopr_sideInfo ) call gpuCheck ( hipMemcpy ( this % sideInfo_gpu , c_loc ( this % sideInfo ), sizeof ( this % sideInfo ), hipMemcpyHostToDevice )) endsubroutine Read_HOPr_Mesh2D","tags":"","loc":"proc/read_hopr_mesh2d.html"},{"title":"AverageSides_Scalar1D – SELF","text":"public subroutine AverageSides_Scalar1D(this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this Contents Source Code AverageSides_Scalar1D Source Code subroutine AverageSides_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this call Average_gpu ( this % avgBoundary_gpu , this % boundary_gpu , this % extBoundary_gpu , size ( this % avgBoundary )) endsubroutine AverageSides_Scalar1D","tags":"","loc":"proc/averagesides_scalar1d.html"},{"title":"BoundaryInterp_Scalar1D – SELF","text":"public subroutine BoundaryInterp_Scalar1D(this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this Contents Source Code BoundaryInterp_Scalar1D Source Code subroutine BoundaryInterp_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this call self_blas_matrixop_1d ( this % interp % bMatrix_gpu , & this % interior_gpu , & this % boundary_gpu , & 2 , this % N + 1 , & this % nvar * this % nelem , this % blas_handle ) endsubroutine BoundaryInterp_Scalar1D","tags":"","loc":"proc/boundaryinterp_scalar1d.html"},{"title":"Derivative_Scalar1D – SELF","text":"public subroutine Derivative_Scalar1D(this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: df Contents Source Code Derivative_Scalar1D Source Code subroutine Derivative_Scalar1D ( this , df ) implicit none class ( Scalar1D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df call self_blas_matrixop_1d ( this % interp % dMatrix_gpu , & this % interior_gpu , & df , this % N + 1 , this % N + 1 , & this % nvar * this % nelem , this % blas_handle ) endsubroutine Derivative_Scalar1D","tags":"","loc":"proc/derivative_scalar1d.html"},{"title":"Free_Scalar1D – SELF","text":"public subroutine Free_Scalar1D(this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this Contents Source Code Free_Scalar1D Source Code subroutine Free_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % boundarynormal_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call gpuCheck ( hipFree ( this % avgBoundary_gpu )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Scalar1D","tags":"","loc":"proc/free_scalar1d.html"},{"title":"GridInterp_Scalar1D – SELF","text":"public subroutine GridInterp_Scalar1D(this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: f Contents Source Code GridInterp_Scalar1D Source Code subroutine GridInterp_Scalar1D ( this , f ) implicit none class ( Scalar1D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: f call self_blas_matrixop_1d ( this % interp % iMatrix_gpu , & this % interior_gpu , & f , this % M + 1 , this % N + 1 , & this % nvar * this % nelem , this % blas_handle ) endsubroutine GridInterp_Scalar1D","tags":"","loc":"proc/gridinterp_scalar1d.html"},{"title":"Init_Scalar1D – SELF","text":"public subroutine Init_Scalar1D(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar1D Source Code subroutine Init_Scalar1D ( this , interp , nVar , nElem ) implicit none class ( Scalar1D ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem if (. not . GPUAvailable ()) then print * , __ FILE__ , ':' , __ LINE__ , ' : Error : Attempt to use GPU extension, but GPU is not available.' stop 1 endif this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : nelem , 1 : nvar ), & this % boundary ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : 2 , 1 : nelem , 1 : nvar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % boundarynormal = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % boundarynormal_gpu , sizeof ( this % boundarynormal ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( this % avgBoundary_gpu , sizeof ( this % avgBoundary ))) call this % UpdateDevice () call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_Scalar1D","tags":"","loc":"proc/init_scalar1d.html"},{"title":"UpdateDevice_Scalar1D – SELF","text":"public subroutine UpdateDevice_Scalar1D(this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this Contents Source Code UpdateDevice_Scalar1D Source Code subroutine UpdateDevice_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundary_gpu , c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundarynormal_gpu , c_loc ( this % boundarynormal ), sizeof ( this % boundarynormal ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % avgboundary_gpu , c_loc ( this % avgboundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Scalar1D","tags":"","loc":"proc/updatedevice_scalar1d.html"},{"title":"UpdateHost_Scalar1D – SELF","text":"public subroutine UpdateHost_Scalar1D(this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this Contents Source Code UpdateHost_Scalar1D Source Code subroutine UpdateHost_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), this % interior_gpu , sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundarynormal ), this % boundarynormal_gpu , sizeof ( this % boundarynormal ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), this % extboundary_gpu , sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % avgboundary ), this % avgboundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Scalar1D","tags":"","loc":"proc/updatehost_scalar1d.html"},{"title":"CalculateEntropy_advection_diffusion_2d – SELF","text":"public subroutine CalculateEntropy_advection_diffusion_2d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this Contents Source Code CalculateEntropy_advection_diffusion_2d Source Code subroutine CalculateEntropy_advection_diffusion_2d ( this ) implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this ! Local integer :: iel , i , j , ivar , ierror real ( prec ) :: e , s , jac call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) e = 0.0_prec do ivar = 1 , this % solution % nvar do iel = 1 , this % geometry % nelem do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 jac = this % geometry % J % interior ( i , j , iel , 1 ) s = this % solution % interior ( i , j , iel , ivar ) e = e + 0.5_prec * s * s * jac enddo enddo enddo enddo if ( this % mesh % decomp % mpiEnabled ) then call mpi_allreduce ( e , & this % entropy , & 1 , & this % mesh % decomp % mpiPrec , & MPI_SUM , & this % mesh % decomp % mpiComm , & iError ) else this % entropy = e endif endsubroutine CalculateEntropy_advection_diffusion_2d","tags":"","loc":"proc/calculateentropy_advection_diffusion_2d.html"},{"title":"boundaryflux_advection_diffusion_2d – SELF","text":"public subroutine boundaryflux_advection_diffusion_2d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this Contents Source Code boundaryflux_advection_diffusion_2d Source Code subroutine boundaryflux_advection_diffusion_2d ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this call boundaryflux_advection_diffusion_2d_gpu ( this % solution % boundary_gpu , & this % solution % extBoundary_gpu , this % solutionGradient % avgBoundary_gpu , & this % geometry % nhat % boundary_gpu , this % geometry % nscale % boundary_gpu , & this % flux % boundarynormal_gpu , this % u , this % v , this % nu , this % solution % interp % N , & this % solution % nelem , this % solution % nvar ) endsubroutine boundaryflux_advection_diffusion_2d","tags":"","loc":"proc/boundaryflux_advection_diffusion_2d.html"},{"title":"fluxmethod_advection_diffusion_2d – SELF","text":"public subroutine fluxmethod_advection_diffusion_2d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this Contents Source Code fluxmethod_advection_diffusion_2d Source Code subroutine fluxmethod_advection_diffusion_2d ( this ) implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this call fluxmethod_advection_diffusion_2d_gpu ( this % solution % interior_gpu , & this % solutiongradient % interior_gpu , this % flux % interior_gpu , & this % u , this % v , this % nu , this % solution % interp % N , this % solution % nelem , & this % solution % nvar ) endsubroutine fluxmethod_advection_diffusion_2d","tags":"","loc":"proc/fluxmethod_advection_diffusion_2d.html"},{"title":"setboundarycondition_advection_diffusion_2d – SELF","text":"public subroutine setboundarycondition_advection_diffusion_2d(this) Boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this Contents Source Code setboundarycondition_advection_diffusion_2d Source Code subroutine setboundarycondition_advection_diffusion_2d ( this ) !! Boundary conditions are set to periodic boundary conditions implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this call setboundarycondition_advection_diffusion_2d_gpu ( this % solution % extboundary_gpu , & this % solution % boundary_gpu , this % mesh % sideInfo_gpu , this % solution % interp % N , & this % solution % nelem , this % solution % nvar ) endsubroutine setboundarycondition_advection_diffusion_2d","tags":"","loc":"proc/setboundarycondition_advection_diffusion_2d.html"},{"title":"setgradientboundarycondition_advection_diffusion_2d – SELF","text":"public subroutine setgradientboundarycondition_advection_diffusion_2d(this) Gradient boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this Contents Source Code setgradientboundarycondition_advection_diffusion_2d Source Code subroutine setgradientboundarycondition_advection_diffusion_2d ( this ) !! Gradient boundary conditions are set to periodic boundary conditions implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this call setgradientboundarycondition_advection_diffusion_2d_gpu ( & this % solutiongradient % extboundary_gpu , & this % solutiongradient % boundary_gpu , this % mesh % sideInfo_gpu , & this % solution % interp % N , this % solution % nelem , this % solution % nvar ) endsubroutine setgradientboundarycondition_advection_diffusion_2d","tags":"","loc":"proc/setgradientboundarycondition_advection_diffusion_2d.html"},{"title":"boundaryflux_advection_diffusion_2d_gpu – SELF","text":"interface public subroutine boundaryflux_advection_diffusion_2d_gpu(fb, fextb, dfavg, nhat, nscale, flux, u, v, nu, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: fb type(c_ptr), value :: fextb type(c_ptr), value :: dfavg type(c_ptr), value :: nhat type(c_ptr), value :: nscale type(c_ptr), value :: flux real(kind=c_prec), value :: u real(kind=c_prec), value :: v real(kind=c_prec), value :: nu integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar","tags":"","loc":"interface/boundaryflux_advection_diffusion_2d_gpu.html"},{"title":"fluxmethod_advection_diffusion_2d_gpu – SELF","text":"interface public subroutine fluxmethod_advection_diffusion_2d_gpu(solution, solutiongradient, flux, u, v, nu, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: solution type(c_ptr), value :: solutiongradient type(c_ptr), value :: flux real(kind=c_prec), value :: u real(kind=c_prec), value :: v real(kind=c_prec), value :: nu integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar","tags":"","loc":"interface/fluxmethod_advection_diffusion_2d_gpu.html"},{"title":"setboundarycondition_advection_diffusion_2d_gpu – SELF","text":"interface public subroutine setboundarycondition_advection_diffusion_2d_gpu(extboundary, boundary, sideinfo, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extboundary type(c_ptr), value :: boundary type(c_ptr), value :: sideinfo integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar","tags":"","loc":"interface/setboundarycondition_advection_diffusion_2d_gpu.html"},{"title":"setgradientboundarycondition_advection_diffusion_2d_gpu – SELF","text":"interface public subroutine setgradientboundarycondition_advection_diffusion_2d_gpu(extboundary, boundary, sideinfo, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extboundary type(c_ptr), value :: boundary type(c_ptr), value :: sideinfo integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar","tags":"","loc":"interface/setgradientboundarycondition_advection_diffusion_2d_gpu.html"},{"title":"BoundaryFlux_DGModel2D – SELF","text":"public subroutine BoundaryFlux_DGModel2D(this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this Contents Source Code BoundaryFlux_DGModel2D Source Code subroutine BoundaryFlux_DGModel2D ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( DGModel2D ), intent ( inout ) :: this ! Local integer :: iel integer :: j integer :: i real ( prec ) :: sL ( 1 : this % nvar ), sR ( 1 : this % nvar ) real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ) :: nhat ( 1 : 2 ), nmag call gpuCheck ( hipMemcpy ( c_loc ( this % solution % boundary ), & this % solution % boundary_gpu , sizeof ( this % solution % boundary ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % extboundary ), & this % solution % extboundary_gpu , sizeof ( this % solution % extboundary ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % avgboundary ), & this % solutiongradient % avgboundary_gpu , sizeof ( this % solutiongradient % avgboundary ), & hipMemcpyDeviceToHost )) do iEl = 1 , this % solution % nElem do j = 1 , 4 do i = 1 , this % solution % interp % N + 1 ! Get the boundary normals on cell edges from the mesh geometry nhat = this % geometry % nHat % boundary ( i , j , iEl , 1 , 1 : 2 ) sL = this % solution % boundary ( i , j , iel , 1 : this % nvar ) ! interior solution sR = this % solution % extboundary ( i , j , iel , 1 : this % nvar ) ! exterior solution dsdx = this % solutiongradient % avgboundary ( i , j , iel , 1 : this % nvar , 1 : 2 ) nmag = this % geometry % nScale % boundary ( i , j , iEl , 1 ) this % flux % boundaryNormal ( i , j , iEl , 1 : this % nvar ) = this % riemannflux2d ( sL , sR , dsdx , nhat ) * nmag enddo enddo enddo call gpuCheck ( hipMemcpy ( this % flux % boundarynormal_gpu , & c_loc ( this % flux % boundarynormal ), & sizeof ( this % flux % boundarynormal ), & hipMemcpyHostToDevice )) endsubroutine BoundaryFlux_DGModel2D","tags":"","loc":"proc/boundaryflux_dgmodel2d.html"},{"title":"CalculateEntropy_DGModel2D – SELF","text":"public subroutine CalculateEntropy_DGModel2D(this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this Contents Source Code CalculateEntropy_DGModel2D Source Code subroutine CalculateEntropy_DGModel2D ( this ) implicit none class ( DGModel2D ), intent ( inout ) :: this ! Local integer :: iel , i , j , ierror real ( prec ) :: e , jac real ( prec ) :: s ( 1 : this % nvar ) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) e = 0.0_prec do iel = 1 , this % geometry % nelem do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 jac = this % geometry % J % interior ( i , j , iel , 1 ) s = this % solution % interior ( i , j , iel , 1 : this % nvar ) e = e + this % entropy_func ( s ) * jac enddo enddo enddo if ( this % mesh % decomp % mpiEnabled ) then call mpi_allreduce ( e , & this % entropy , & 1 , & this % mesh % decomp % mpiPrec , & MPI_SUM , & this % mesh % decomp % mpiComm , & iError ) else this % entropy = e endif endsubroutine CalculateEntropy_DGModel2D","tags":"","loc":"proc/calculateentropy_dgmodel2d.html"},{"title":"CalculateSolutionGradient_DGModel2D – SELF","text":"public subroutine CalculateSolutionGradient_DGModel2D(this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this Contents Source Code CalculateSolutionGradient_DGModel2D Source Code subroutine CalculateSolutionGradient_DGModel2D ( this ) implicit none class ( DGModel2D ), intent ( inout ) :: this call this % solution % AverageSides () call this % solution % MappedDGGradient ( this % solutionGradient % interior_gpu ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp () ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh ) endsubroutine CalculateSolutionGradient_DGModel2D","tags":"","loc":"proc/calculatesolutiongradient_dgmodel2d.html"},{"title":"CalculateTendency_DGModel2D – SELF","text":"public subroutine CalculateTendency_DGModel2D(this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this Contents Source Code CalculateTendency_DGModel2D Source Code subroutine CalculateTendency_DGModel2D ( this ) implicit none class ( DGModel2D ), intent ( inout ) :: this ! Local integer :: ndof call this % solution % BoundaryInterp () call this % solution % SideExchange ( this % mesh ) call this % PreTendency () ! User-supplied call this % SetBoundaryCondition () ! User-supplied if ( this % gradient_enabled ) then call this % CalculateSolutionGradient () call this % SetGradientBoundaryCondition () ! User-supplied call this % solutionGradient % AverageSides () endif call this % SourceMethod () ! User supplied call this % BoundaryFlux () ! User supplied call this % FluxMethod () ! User supplied call this % flux % MappedDGDivergence ( this % fluxDivergence % interior_gpu ) ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call CalculateDSDt_gpu ( this % fluxDivergence % interior_gpu , this % source % interior_gpu , & this % dsdt % interior_gpu , ndof ) endsubroutine CalculateTendency_DGModel2D","tags":"","loc":"proc/calculatetendency_dgmodel2d.html"},{"title":"UpdateGRK2_DGModel2D – SELF","text":"public subroutine UpdateGRK2_DGModel2D(this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK2_DGModel2D Source Code subroutine UpdateGRK2_DGModel2D ( this , m ) implicit none class ( DGModel2D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk2_a ( m ), rk2_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK2_DGModel2D","tags":"","loc":"proc/updategrk2_dgmodel2d.html"},{"title":"UpdateGRK3_DGModel2D – SELF","text":"public subroutine UpdateGRK3_DGModel2D(this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK3_DGModel2D Source Code subroutine UpdateGRK3_DGModel2D ( this , m ) implicit none class ( DGModel2D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk3_a ( m ), rk3_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK3_DGModel2D","tags":"","loc":"proc/updategrk3_dgmodel2d.html"},{"title":"UpdateGRK4_DGModel2D – SELF","text":"public subroutine UpdateGRK4_DGModel2D(this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK4_DGModel2D Source Code subroutine UpdateGRK4_DGModel2D ( this , m ) implicit none class ( DGModel2D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk4_a ( m ), rk4_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK4_DGModel2D","tags":"","loc":"proc/updategrk4_dgmodel2d.html"},{"title":"UpdateSolution_DGModel2D – SELF","text":"public subroutine UpdateSolution_DGModel2D(this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt Contents Source Code UpdateSolution_DGModel2D Source Code subroutine UpdateSolution_DGModel2D ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) implicit none class ( DGModel2D ), intent ( inout ) :: this real ( prec ), optional , intent ( in ) :: dt ! Local real ( prec ) :: dtLoc integer :: ndof if ( present ( dt )) then dtLoc = dt else dtLoc = this % dt endif ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateSolution_gpu ( this % solution % interior_gpu , this % dsdt % interior_gpu , dtLoc , ndof ) endsubroutine UpdateSolution_DGModel2D","tags":"","loc":"proc/updatesolution_dgmodel2d.html"},{"title":"fluxmethod_DGModel2D – SELF","text":"public subroutine fluxmethod_DGModel2D(this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this Contents Source Code fluxmethod_DGModel2D Source Code subroutine fluxmethod_DGModel2D ( this ) implicit none class ( DGModel2D ), intent ( inout ) :: this ! Local integer :: iel integer :: i integer :: j real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 2 ) do iel = 1 , this % mesh % nelem do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , iel , 1 : this % nvar , 1 : 2 ) this % flux % interior ( i , j , iel , 1 : this % nvar , 1 : 2 ) = this % flux2d ( s , dsdx ) enddo enddo enddo call gpuCheck ( hipMemcpy ( this % flux % interior_gpu , & c_loc ( this % flux % interior ), & sizeof ( this % flux % interior ), & hipMemcpyHostToDevice )) endsubroutine fluxmethod_DGModel2D","tags":"","loc":"proc/fluxmethod_dgmodel2d.html"},{"title":"setboundarycondition_DGModel2D – SELF","text":"public subroutine setboundarycondition_DGModel2D(this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this Contents Source Code setboundarycondition_DGModel2D Source Code subroutine setboundarycondition_DGModel2D ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel2D ), intent ( inout ) :: this ! local integer :: i , iEl , j , e2 , bcid real ( prec ) :: nhat ( 1 : 2 ), x ( 1 : 2 ) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % boundary ), & this % solution % boundary_gpu , sizeof ( this % solution % boundary ), & hipMemcpyDeviceToHost )) do iEl = 1 , this % solution % nElem ! Loop over all elements do j = 1 , 4 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , j , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , j , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points x = this % geometry % x % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solution % extBoundary ( i , j , iEl , 1 : this % nvar ) = & this % hbc2d_Prescribed ( x , this % t ) enddo elseif ( bcid == SELF_BC_RADIATION ) then do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solution % extBoundary ( i , j , iEl , 1 : this % nvar ) = & this % hbc2d_Radiation ( this % solution % boundary ( i , j , iEl , 1 : this % nvar ), nhat ) enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solution % extBoundary ( i , j , iEl , 1 : this % nvar ) = & this % hbc2d_NoNormalFlow ( this % solution % boundary ( i , j , iEl , 1 : this % nvar ), nhat ) enddo endif endif enddo enddo call gpuCheck ( hipMemcpy ( this % solution % extBoundary_gpu , & c_loc ( this % solution % extBoundary ), & sizeof ( this % solution % extBoundary ), & hipMemcpyHostToDevice )) endsubroutine setboundarycondition_DGModel2D","tags":"","loc":"proc/setboundarycondition_dgmodel2d.html"},{"title":"setgradientboundarycondition_DGModel2D – SELF","text":"public subroutine setgradientboundarycondition_DGModel2D(this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this Contents Source Code setgradientboundarycondition_DGModel2D Source Code subroutine setgradientboundarycondition_DGModel2D ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel2D ), intent ( inout ) :: this ! local integer :: i , iEl , j , e2 , bcid real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ) :: nhat ( 1 : 2 ), x ( 1 : 2 ) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % boundary ), & this % solutiongradient % boundary_gpu , sizeof ( this % solutiongradient % boundary ), & hipMemcpyDeviceToHost )) do iEl = 1 , this % solution % nElem ! Loop over all elements do j = 1 , 4 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , j , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , j , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points x = this % geometry % x % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solutiongradient % extBoundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) = & this % pbc2d_Prescribed ( x , this % t ) enddo elseif ( bcid == SELF_BC_RADIATION ) then do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) dsdx = this % solutiongradient % boundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) this % solutiongradient % extBoundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) = & this % pbc2d_Radiation ( dsdx , nhat ) enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) dsdx = this % solutiongradient % boundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) this % solutiongradient % extBoundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) = & this % pbc2d_NoNormalFlow ( dsdx , nhat ) enddo endif endif enddo enddo call gpuCheck ( hipMemcpy ( this % solutiongradient % extBoundary_gpu , & c_loc ( this % solutiongradient % extBoundary ), & sizeof ( this % solutiongradient % extBoundary ), & hipMemcpyHostToDevice )) endsubroutine setgradientboundarycondition_DGModel2D","tags":"","loc":"proc/setgradientboundarycondition_dgmodel2d.html"},{"title":"sourcemethod_DGModel2D – SELF","text":"public subroutine sourcemethod_DGModel2D(this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this Contents Source Code sourcemethod_DGModel2D Source Code subroutine sourcemethod_DGModel2D ( this ) implicit none class ( DGModel2D ), intent ( inout ) :: this ! Local integer :: iel integer :: i integer :: j real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 2 ) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % interior ), & this % solutiongradient % interior_gpu , sizeof ( this % solutiongradient % interior ), & hipMemcpyDeviceToHost )) do iel = 1 , this % mesh % nelem do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , iel , 1 : this % nvar , 1 : 2 ) this % source % interior ( i , j , iel , 1 : this % nvar ) = this % source2d ( s , dsdx ) enddo enddo enddo call gpuCheck ( hipMemcpy ( this % source % interior_gpu , & c_loc ( this % source % interior ), & sizeof ( this % source % interior ), & hipMemcpyHostToDevice )) endsubroutine sourcemethod_DGModel2D","tags":"","loc":"proc/sourcemethod_dgmodel2d.html"},{"title":"boundaryflux_advection_diffusion_1d – SELF","text":"public subroutine boundaryflux_advection_diffusion_1d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this Contents Source Code boundaryflux_advection_diffusion_1d Source Code subroutine boundaryflux_advection_diffusion_1d ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this ! Local integer :: ndof ndof = this % solution % nelem * this % solution % nvar * 2 call boundaryflux_advection_diffusion_1d_gpu ( this % solution % boundary_gpu , & this % solution % extBoundary_gpu , this % solutionGradient % avgBoundary_gpu , & this % flux % boundarynormal_gpu , this % u , this % nu , ndof ) endsubroutine boundaryflux_advection_diffusion_1d","tags":"","loc":"proc/boundaryflux_advection_diffusion_1d.html"},{"title":"fluxmethod_advection_diffusion_1d – SELF","text":"public subroutine fluxmethod_advection_diffusion_1d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this Contents Source Code fluxmethod_advection_diffusion_1d Source Code subroutine fluxmethod_advection_diffusion_1d ( this ) implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this ! Local integer :: ndof ndof = this % solution % nelem * this % solution % nvar * ( this % solution % interp % N + 1 ) call fluxmethod_advection_diffusion_1d_gpu ( this % solution % interior_gpu , & this % solutiongradient % interior_gpu , this % flux % interior_gpu , & this % u , this % nu , ndof ) endsubroutine fluxmethod_advection_diffusion_1d","tags":"","loc":"proc/fluxmethod_advection_diffusion_1d.html"},{"title":"setboundarycondition_advection_diffusion_1d – SELF","text":"public subroutine setboundarycondition_advection_diffusion_1d(this) Boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this Contents Source Code setboundarycondition_advection_diffusion_1d Source Code subroutine setboundarycondition_advection_diffusion_1d ( this ) !! Boundary conditions are set to periodic boundary conditions implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this call setboundarycondition_advection_diffusion_1d_gpu ( this % solution % extboundary_gpu , & this % solution % boundary_gpu , this % solution % nelem , this % solution % nvar ) endsubroutine setboundarycondition_advection_diffusion_1d","tags":"","loc":"proc/setboundarycondition_advection_diffusion_1d.html"},{"title":"setgradientboundarycondition_advection_diffusion_1d – SELF","text":"public subroutine setgradientboundarycondition_advection_diffusion_1d(this) Gradient boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this Contents Source Code setgradientboundarycondition_advection_diffusion_1d Source Code subroutine setgradientboundarycondition_advection_diffusion_1d ( this ) !! Gradient boundary conditions are set to periodic boundary conditions implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this call setboundarycondition_advection_diffusion_1d_gpu ( this % solutiongradient % extboundary_gpu , & this % solutiongradient % boundary_gpu , this % solution % nelem , this % solution % nvar ) endsubroutine setgradientboundarycondition_advection_diffusion_1d","tags":"","loc":"proc/setgradientboundarycondition_advection_diffusion_1d.html"},{"title":"boundaryflux_advection_diffusion_1d_gpu – SELF","text":"interface public subroutine boundaryflux_advection_diffusion_1d_gpu(fb, fextb, dfavg, flux, u, nu, ndof) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: fb type(c_ptr), value :: fextb type(c_ptr), value :: dfavg type(c_ptr), value :: flux real(kind=c_prec), value :: u real(kind=c_prec), value :: nu integer(kind=c_int), value :: ndof","tags":"","loc":"interface/boundaryflux_advection_diffusion_1d_gpu.html"},{"title":"fluxmethod_advection_diffusion_1d_gpu – SELF","text":"interface public subroutine fluxmethod_advection_diffusion_1d_gpu(solution, solutiongradient, flux, u, nu, ndof) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: solution type(c_ptr), value :: solutiongradient type(c_ptr), value :: flux real(kind=c_prec), value :: u real(kind=c_prec), value :: nu integer(kind=c_int), value :: ndof","tags":"","loc":"interface/fluxmethod_advection_diffusion_1d_gpu.html"},{"title":"setboundarycondition_advection_diffusion_1d_gpu – SELF","text":"interface public subroutine setboundarycondition_advection_diffusion_1d_gpu(extboundary, boundary, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extboundary type(c_ptr), value :: boundary integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar","tags":"","loc":"interface/setboundarycondition_advection_diffusion_1d_gpu.html"},{"title":"CalculateEntropy_advection_diffusion_3d – SELF","text":"public subroutine CalculateEntropy_advection_diffusion_3d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this Contents Source Code CalculateEntropy_advection_diffusion_3d Source Code subroutine CalculateEntropy_advection_diffusion_3d ( this ) implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this ! Local integer :: iel , i , j , k , ivar , ierror real ( prec ) :: e , s , jac call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) e = 0.0_prec do ivar = 1 , this % solution % nvar do iel = 1 , this % geometry % nelem do k = 1 , this % solution % interp % N + 1 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 jac = this % geometry % J % interior ( i , j , k , iel , 1 ) s = this % solution % interior ( i , j , k , iel , ivar ) e = e + 0.5_prec * s * s * jac enddo enddo enddo enddo enddo if ( this % mesh % decomp % mpiEnabled ) then call mpi_allreduce ( e , & this % entropy , & 1 , & this % mesh % decomp % mpiPrec , & MPI_SUM , & this % mesh % decomp % mpiComm , & iError ) else this % entropy = e endif endsubroutine CalculateEntropy_advection_diffusion_3d","tags":"","loc":"proc/calculateentropy_advection_diffusion_3d.html"},{"title":"boundaryflux_advection_diffusion_3d – SELF","text":"public subroutine boundaryflux_advection_diffusion_3d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this Contents Source Code boundaryflux_advection_diffusion_3d Source Code subroutine boundaryflux_advection_diffusion_3d ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this call boundaryflux_advection_diffusion_3d_gpu ( this % solution % boundary_gpu , & this % solution % extBoundary_gpu , this % solutionGradient % avgBoundary_gpu , & this % geometry % nhat % boundary_gpu , this % geometry % nscale % boundary_gpu , & this % flux % boundarynormal_gpu , this % u , this % v , this % w , & this % nu , this % solution % interp % N , & this % solution % nelem , this % solution % nvar ) endsubroutine boundaryflux_advection_diffusion_3d","tags":"","loc":"proc/boundaryflux_advection_diffusion_3d.html"},{"title":"fluxmethod_advection_diffusion_3d – SELF","text":"public subroutine fluxmethod_advection_diffusion_3d(this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this Contents Source Code fluxmethod_advection_diffusion_3d Source Code subroutine fluxmethod_advection_diffusion_3d ( this ) implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this call fluxmethod_advection_diffusion_3d_gpu ( this % solution % interior_gpu , & this % solutiongradient % interior_gpu , this % flux % interior_gpu , & this % u , this % v , this % w , this % nu , this % solution % interp % N , & this % solution % nelem , & this % solution % nvar ) endsubroutine fluxmethod_advection_diffusion_3d","tags":"","loc":"proc/fluxmethod_advection_diffusion_3d.html"},{"title":"setboundarycondition_advection_diffusion_3d – SELF","text":"public subroutine setboundarycondition_advection_diffusion_3d(this) Boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this Contents Source Code setboundarycondition_advection_diffusion_3d Source Code subroutine setboundarycondition_advection_diffusion_3d ( this ) !! Boundary conditions are set to periodic boundary conditions implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this call setboundarycondition_advection_diffusion_3d_gpu ( this % solution % extboundary_gpu , & this % solution % boundary_gpu , this % mesh % sideInfo_gpu , this % solution % interp % N , & this % solution % nelem , this % solution % nvar ) endsubroutine setboundarycondition_advection_diffusion_3d","tags":"","loc":"proc/setboundarycondition_advection_diffusion_3d.html"},{"title":"setgradientboundarycondition_advection_diffusion_3d – SELF","text":"public subroutine setgradientboundarycondition_advection_diffusion_3d(this) Gradient boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this Contents Source Code setgradientboundarycondition_advection_diffusion_3d Source Code subroutine setgradientboundarycondition_advection_diffusion_3d ( this ) !! Gradient boundary conditions are set to periodic boundary conditions implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this call setgradientboundarycondition_advection_diffusion_3d_gpu ( & this % solutiongradient % extboundary_gpu , & this % solutiongradient % boundary_gpu , this % mesh % sideInfo_gpu , & this % solution % interp % N , this % solution % nelem , this % solution % nvar ) endsubroutine setgradientboundarycondition_advection_diffusion_3d","tags":"","loc":"proc/setgradientboundarycondition_advection_diffusion_3d.html"},{"title":"boundaryflux_advection_diffusion_3d_gpu – SELF","text":"interface public subroutine boundaryflux_advection_diffusion_3d_gpu(fb, fextb, dfavg, nhat, nscale, flux, u, v, w, nu, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: fb type(c_ptr), value :: fextb type(c_ptr), value :: dfavg type(c_ptr), value :: nhat type(c_ptr), value :: nscale type(c_ptr), value :: flux real(kind=c_prec), value :: u real(kind=c_prec), value :: v real(kind=c_prec), value :: w real(kind=c_prec), value :: nu integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar","tags":"","loc":"interface/boundaryflux_advection_diffusion_3d_gpu.html"},{"title":"fluxmethod_advection_diffusion_3d_gpu – SELF","text":"interface public subroutine fluxmethod_advection_diffusion_3d_gpu(solution, solutiongradient, flux, u, v, w, nu, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: solution type(c_ptr), value :: solutiongradient type(c_ptr), value :: flux real(kind=c_prec), value :: u real(kind=c_prec), value :: v real(kind=c_prec), value :: w real(kind=c_prec), value :: nu integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar","tags":"","loc":"interface/fluxmethod_advection_diffusion_3d_gpu.html"},{"title":"setboundarycondition_advection_diffusion_3d_gpu – SELF","text":"interface public subroutine setboundarycondition_advection_diffusion_3d_gpu(extboundary, boundary, sideinfo, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extboundary type(c_ptr), value :: boundary type(c_ptr), value :: sideinfo integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar","tags":"","loc":"interface/setboundarycondition_advection_diffusion_3d_gpu.html"},{"title":"setgradientboundarycondition_advection_diffusion_3d_gpu – SELF","text":"interface public subroutine setgradientboundarycondition_advection_diffusion_3d_gpu(extboundary, boundary, sideinfo, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extboundary type(c_ptr), value :: boundary type(c_ptr), value :: sideinfo integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar","tags":"","loc":"interface/setgradientboundarycondition_advection_diffusion_3d_gpu.html"},{"title":"BoundaryFlux_DGModel1D – SELF","text":"public subroutine BoundaryFlux_DGModel1D(this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this Contents Source Code BoundaryFlux_DGModel1D Source Code subroutine BoundaryFlux_DGModel1D ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( DGModel1D ), intent ( inout ) :: this ! Local integer :: iel integer :: iside real ( prec ) :: fin ( 1 : this % solution % nvar ) real ( prec ) :: fout ( 1 : this % solution % nvar ) real ( prec ) :: dfdx ( 1 : this % solution % nvar ), nhat call gpuCheck ( hipMemcpy ( c_loc ( this % solution % boundary ), & this % solution % boundary_gpu , sizeof ( this % solution % boundary ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % extboundary ), & this % solution % extboundary_gpu , sizeof ( this % solution % extboundary ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % avgboundary ), & this % solutiongradient % avgboundary_gpu , sizeof ( this % solutiongradient % avgboundary ), & hipMemcpyDeviceToHost )) do iel = 1 , this % mesh % nelem do iside = 1 , 2 ! set the normal velocity if ( iside == 1 ) then nhat = - 1.0_prec else nhat = 1.0_prec endif fin = this % solution % boundary ( iside , iel , 1 : this % solution % nvar ) ! interior solution fout = this % solution % extboundary ( iside , iel , 1 : this % solution % nvar ) ! exterior solution dfdx = this % solutionGradient % avgboundary ( iside , iel , 1 : this % solution % nvar ) ! average solution gradient (with direction taken into account) this % flux % boundarynormal ( iside , iel , 1 : this % solution % nvar ) = & this % riemannflux1d ( fin , fout , dfdx , nhat ) enddo enddo call gpuCheck ( hipMemcpy ( this % flux % boundarynormal_gpu , & c_loc ( this % flux % boundarynormal ), & sizeof ( this % flux % boundarynormal ), & hipMemcpyHostToDevice )) endsubroutine BoundaryFlux_DGModel1D","tags":"","loc":"proc/boundaryflux_dgmodel1d.html"},{"title":"CalculateEntropy_DGModel1D – SELF","text":"public subroutine CalculateEntropy_DGModel1D(this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this Contents Source Code CalculateEntropy_DGModel1D Source Code subroutine CalculateEntropy_DGModel1D ( this ) implicit none class ( DGModel1D ), intent ( inout ) :: this ! Local integer :: iel , i , ivar real ( prec ) :: e , s ( 1 : this % solution % nvar ), J call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) e = 0.0_prec do iel = 1 , this % geometry % nelem do i = 1 , this % solution % interp % N + 1 J = this % geometry % dxds % interior ( i , iel , 1 ) s ( 1 : this % solution % nvar ) = this % solution % interior ( i , iel , 1 : this % solution % nvar ) e = e + this % entropy_func ( s ) * J enddo enddo this % entropy = e endsubroutine CalculateEntropy_DGModel1D","tags":"","loc":"proc/calculateentropy_dgmodel1d.html"},{"title":"CalculateSolutionGradient_DGModel1D – SELF","text":"public subroutine CalculateSolutionGradient_DGModel1D(this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this Contents Source Code CalculateSolutionGradient_DGModel1D Source Code subroutine CalculateSolutionGradient_DGModel1D ( this ) implicit none class ( DGModel1D ), intent ( inout ) :: this ! Local integer :: ndof call this % solution % AverageSides () ! Account for the outward pointing normal before computing dg derivative ndof = this % solution % nvar * this % solution % nelem * 2 call GradientNormal_1D_gpu ( this % solution % boundarynormal_gpu , & this % solution % avgBoundary_gpu , ndof ) call this % solution % MappedDGDerivative ( this % solutionGradient % interior_gpu ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp () ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh ) endsubroutine CalculateSolutionGradient_DGModel1D","tags":"","loc":"proc/calculatesolutiongradient_dgmodel1d.html"},{"title":"CalculateTendency_DGModel1D – SELF","text":"public subroutine CalculateTendency_DGModel1D(this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this Contents Source Code CalculateTendency_DGModel1D Source Code subroutine CalculateTendency_DGModel1D ( this ) implicit none class ( DGModel1D ), intent ( inout ) :: this ! Local integer :: ndof call this % solution % BoundaryInterp () call this % solution % SideExchange ( this % mesh ) call this % PreTendency () ! User-supplied call this % SetBoundaryCondition () ! User-supplied if ( this % gradient_enabled ) then call this % solution % AverageSides () call this % CalculateSolutionGradient () call this % SetGradientBoundaryCondition () ! User-supplied call this % solutionGradient % AverageSides () endif call this % SourceMethod () ! User supplied call this % BoundaryFlux () ! User supplied call this % FluxMethod () ! User supplied call this % flux % MappedDGDerivative ( this % fluxDivergence % interior_gpu ) ndof = this % solution % nvar * this % solution % nelem * ( this % solution % interp % N + 1 ) call CalculateDSDt_gpu ( this % fluxDivergence % interior_gpu , this % source % interior_gpu , & this % dsdt % interior_gpu , ndof ) endsubroutine CalculateTendency_DGModel1D","tags":"","loc":"proc/calculatetendency_dgmodel1d.html"},{"title":"UpdateGRK2_DGModel1D – SELF","text":"public subroutine UpdateGRK2_DGModel1D(this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK2_DGModel1D Source Code subroutine UpdateGRK2_DGModel1D ( this , m ) implicit none class ( DGModel1D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * this % solution % nelem * ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk2_a ( m ), rk2_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK2_DGModel1D","tags":"","loc":"proc/updategrk2_dgmodel1d.html"},{"title":"UpdateGRK3_DGModel1D – SELF","text":"public subroutine UpdateGRK3_DGModel1D(this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK3_DGModel1D Source Code subroutine UpdateGRK3_DGModel1D ( this , m ) implicit none class ( DGModel1D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * this % solution % nelem * ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk3_a ( m ), rk3_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK3_DGModel1D","tags":"","loc":"proc/updategrk3_dgmodel1d.html"},{"title":"UpdateGRK4_DGModel1D – SELF","text":"public subroutine UpdateGRK4_DGModel1D(this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK4_DGModel1D Source Code subroutine UpdateGRK4_DGModel1D ( this , m ) implicit none class ( DGModel1D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * this % solution % nelem * ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk4_a ( m ), rk4_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK4_DGModel1D","tags":"","loc":"proc/updategrk4_dgmodel1d.html"},{"title":"UpdateSolution_DGModel1D – SELF","text":"public subroutine UpdateSolution_DGModel1D(this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt Contents Source Code UpdateSolution_DGModel1D Source Code subroutine UpdateSolution_DGModel1D ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) implicit none class ( DGModel1D ), intent ( inout ) :: this real ( prec ), optional , intent ( in ) :: dt ! Local real ( prec ) :: dtLoc integer :: ndof if ( present ( dt )) then dtLoc = dt else dtLoc = this % dt endif ndof = this % solution % nvar * this % solution % nelem * ( this % solution % interp % N + 1 ) call UpdateSolution_gpu ( this % solution % interior_gpu , this % dsdt % interior_gpu , dtLoc , ndof ) endsubroutine UpdateSolution_DGModel1D","tags":"","loc":"proc/updatesolution_dgmodel1d.html"},{"title":"fluxmethod_DGModel1D – SELF","text":"public subroutine fluxmethod_DGModel1D(this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this Contents Source Code fluxmethod_DGModel1D Source Code subroutine fluxmethod_DGModel1D ( this ) implicit none class ( DGModel1D ), intent ( inout ) :: this ! Local integer :: iel integer :: i real ( prec ) :: f ( 1 : this % solution % nvar ), dfdx ( 1 : this % solution % nvar ) do iel = 1 , this % mesh % nelem do i = 1 , this % solution % interp % N + 1 f = this % solution % interior ( i , iel , 1 : this % solution % nvar ) dfdx = this % solutionGradient % interior ( i , iel , 1 : this % solution % nvar ) this % flux % interior ( i , iel , 1 : this % solution % nvar ) = & this % flux1d ( f , dfdx ) enddo enddo call gpuCheck ( hipMemcpy ( this % flux % interior_gpu , & c_loc ( this % flux % interior ), & sizeof ( this % flux % interior ), & hipMemcpyHostToDevice )) endsubroutine fluxmethod_DGModel1D","tags":"","loc":"proc/fluxmethod_dgmodel1d.html"},{"title":"setboundarycondition_DGModel1D – SELF","text":"public subroutine setboundarycondition_DGModel1D(this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this Contents Source Code setboundarycondition_DGModel1D Source Code subroutine setboundarycondition_DGModel1D ( this ) ! Here, we use the pre-tendency method to calculate the ! derivative of the solution using a bassi-rebay method ! We then do a boundary interpolation and side exchange ! on the gradient field implicit none class ( DGModel1D ), intent ( inout ) :: this ! local integer :: ivar integer :: N , nelem real ( prec ) :: x call gpuCheck ( hipMemcpy ( c_loc ( this % solution % boundary ), & this % solution % boundary_gpu , sizeof ( this % solution % boundary ), & hipMemcpyDeviceToHost )) nelem = this % geometry % nelem ! number of elements in the mesh N = this % solution % interp % N ! polynomial degree ! left-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 1 , 1 , 1 ) this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % hbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % hbc1d_Radiation ( this % solution % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % hbc1d_NoNormalFlow ( this % solution % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = this % solution % boundary ( 2 , nelem , 1 : this % nvar ) endif ! right-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 2 , nelem , 1 ) this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % hbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % hbc1d_Radiation ( this % solution % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % hbc1d_NoNormalFlow ( this % solution % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = this % solution % boundary ( 1 , 1 , 1 : this % nvar ) endif call gpuCheck ( hipMemcpy ( this % solution % extBoundary_gpu , & c_loc ( this % solution % extBoundary ), & sizeof ( this % solution % extBoundary ), & hipMemcpyHostToDevice )) endsubroutine setboundarycondition_DGModel1D","tags":"","loc":"proc/setboundarycondition_dgmodel1d.html"},{"title":"setgradientboundarycondition_DGModel1D – SELF","text":"public subroutine setgradientboundarycondition_DGModel1D(this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this Contents Source Code setgradientboundarycondition_DGModel1D Source Code subroutine setgradientboundarycondition_DGModel1D ( this ) ! Here, we set the boundary conditions for the ! solution and the solution gradient at the left ! and right most boundaries. ! ! Here, we use periodic boundary conditions implicit none class ( DGModel1D ), intent ( inout ) :: this ! local integer :: ivar integer :: nelem real ( prec ) :: x call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % boundary ), & this % solutiongradient % boundary_gpu , sizeof ( this % solutiongradient % boundary ), & hipMemcpyDeviceToHost )) nelem = this % geometry % nelem ! number of elements in the mesh ! left-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 1 , 1 , 1 ) this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % pbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % pbc1d_Radiation ( this % solutionGradient % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % pbc1d_NoNormalFlow ( this % solutionGradient % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = this % solutionGradient % boundary ( 2 , nelem , 1 : this % nvar ) endif ! right-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 2 , nelem , 1 ) this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % pbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % pbc1d_Radiation ( this % solutionGradient % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % pbc1d_NoNormalFlow ( this % solutionGradient % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = this % solutionGradient % boundary ( 1 , 1 , 1 : this % nvar ) endif call gpuCheck ( hipMemcpy ( this % solutiongradient % extBoundary_gpu , & c_loc ( this % solutiongradient % extBoundary ), & sizeof ( this % solutiongradient % extBoundary ), & hipMemcpyHostToDevice )) endsubroutine setgradientboundarycondition_DGModel1D","tags":"","loc":"proc/setgradientboundarycondition_dgmodel1d.html"},{"title":"sourcemethod_DGModel1D – SELF","text":"public subroutine sourcemethod_DGModel1D(this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this Contents Source Code sourcemethod_DGModel1D Source Code subroutine sourcemethod_DGModel1D ( this ) implicit none class ( DGModel1D ), intent ( inout ) :: this ! Local integer :: iel integer :: i real ( prec ) :: f ( 1 : this % solution % nvar ), dfdx ( 1 : this % solution % nvar ) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % interior ), & this % solutiongradient % interior_gpu , sizeof ( this % solutiongradient % interior ), & hipMemcpyDeviceToHost )) do iel = 1 , this % mesh % nelem do i = 1 , this % solution % interp % N + 1 f = this % solution % interior ( i , iel , 1 : this % solution % nvar ) dfdx = this % solutionGradient % interior ( i , iel , 1 : this % solution % nvar ) this % source % interior ( i , iel , 1 : this % solution % nvar ) = & this % source1d ( f , dfdx ) enddo enddo call gpuCheck ( hipMemcpy ( this % source % interior_gpu , & c_loc ( this % source % interior ), & sizeof ( this % source % interior ), & hipMemcpyHostToDevice )) endsubroutine sourcemethod_DGModel1D","tags":"","loc":"proc/sourcemethod_dgmodel1d.html"},{"title":"MPIExchangeAsync_MappedVector3D – SELF","text":"public subroutine MPIExchangeAsync_MappedVector3D(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh Contents Source Code MPIExchangeAsync_MappedVector3D Source Code subroutine MPIExchangeAsync_MappedVector3D ( this , mesh ) implicit none class ( MappedVector3D ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar , idir integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount real ( prec ), pointer :: boundary (:,:,:,:,:,:) real ( prec ), pointer :: extboundary (:,:,:,:,:,:) msgCount = 0 call c_f_pointer ( this % boundary_gpu , boundary ,[ this % interp % N + 1 , this % interp % N + 1 , 6 , this % nelem , this % nvar , 3 ]) call c_f_pointer ( this % extboundary_gpu , extboundary ,[ this % interp % N + 1 , this % interp % N + 1 , 6 , this % nelem , this % nvar , 3 ]) do idir = 1 , 3 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 6 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) ! create unique tag for each side and each variable tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 + this % nvar * ( idir - 1 )) msgCount = msgCount + 1 call MPI_IRECV ( extBoundary (:,:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( boundary (:,:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedVector3D","tags":"","loc":"proc/mpiexchangeasync_mappedvector3d.html"},{"title":"MappedDGDivergence_MappedVector3D – SELF","text":"public subroutine MappedDGDivergence_MappedVector3D(this, df) Computes the divergence of a 3-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df Contents Source Code MappedDGDivergence_MappedVector3D Source Code subroutine MappedDGDivergence_MappedVector3D ( this , df ) !! Computes the divergence of a 3-D vector using the weak form !! On input, the  attribute of the vector !! is assigned and the  attribute is set to the physical !! directions of the vector. This method will project the vector !! onto the contravariant basis vectors. implicit none class ( MappedVector3D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:,:) type ( c_ptr ) :: fc ! Contravariant projection call ContravariantProjection_3D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % interp % N , this % nvar , this % nelem ) call c_f_pointer ( this % interior_gpu , f_p , & [ this % interp % N + 1 , this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 3 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_3d ( this % interp % dgMatrix_gpu , fc , df , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_3d ( this % interp % dgMatrix_gpu , fc , df , 1.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 3 )) call self_blas_matrixop_dim3_3d ( this % interp % dgMatrix_gpu , fc , df , 1.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) f_p => null () ! Boundary terms call DG_BoundaryContribution_3D_gpu ( this % interp % bmatrix_gpu , this % interp % qweights_gpu , & this % boundarynormal_gpu , df , this % interp % N , this % nvar , this % nelem ) call JacobianWeight_3D_gpu ( df , this % geometry % J % interior_gpu , this % interp % N , this % nVar , this % nelem ) endsubroutine MappedDGDivergence_MappedVector3D","tags":"","loc":"proc/mappeddgdivergence_mappedvector3d.html"},{"title":"MappedDivergence_MappedVector3D – SELF","text":"public subroutine MappedDivergence_MappedVector3D(this, df) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df Contents Source Code MappedDivergence_MappedVector3D Source Code subroutine MappedDivergence_MappedVector3D ( this , df ) ! Strong Form Operator !    ! implicit none class ( MappedVector3D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:,:) type ( c_ptr ) :: fc ! Contravariant projection call ContravariantProjection_3D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % interp % N , this % nvar , this % nelem ) call c_f_pointer ( this % interior_gpu , f_p , & [ this % interp % N + 1 , this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 3 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_3d ( this % interp % dMatrix_gpu , fc , df , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_3d ( this % interp % dMatrix_gpu , fc , df , 1.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 3 )) call self_blas_matrixop_dim3_3d ( this % interp % dMatrix_gpu , fc , df , 1.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) f_p => null () call JacobianWeight_3D_gpu ( df , this % geometry % J % interior_gpu , this % interp % N , this % nVar , this % nelem ) endsubroutine MappedDivergence_MappedVector3D","tags":"","loc":"proc/mappeddivergence_mappedvector3d.html"},{"title":"SetInteriorFromEquation_MappedVector3D – SELF","text":"public subroutine SetInteriorFromEquation_MappedVector3D(this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: this type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time Contents Source Code SetInteriorFromEquation_MappedVector3D Source Code subroutine SetInteriorFromEquation_MappedVector3D ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedVector3D ), intent ( inout ) :: this type ( SEMHex ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , k , iEl , iVar real ( prec ) :: x real ( prec ) :: y real ( prec ) :: z do iVar = 1 , this % nVar do iEl = 1 , this % nElem do k = 1 , this % interp % N + 1 do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , k , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , k , iEl , 1 , 2 ) z = geometry % x % interior ( i , j , k , iEl , 1 , 3 ) this % interior ( i , j , k , iEl , iVar , 1 ) = & this % eqn ( 1 + 3 * ( iVar - 1 ))% Evaluate (( / x , y , z , time / )) this % interior ( i , j , k , iEl , iVar , 2 ) = & this % eqn ( 2 + 3 * ( iVar - 1 ))% Evaluate (( / x , y , z , time / )) this % interior ( i , j , k , iEl , iVar , 3 ) = & this % eqn ( 3 + 3 * ( iVar - 1 ))% Evaluate (( / x , y , z , time / )) enddo enddo enddo enddo enddo call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) endsubroutine SetInteriorFromEquation_MappedVector3D","tags":"","loc":"proc/setinteriorfromequation_mappedvector3d.html"},{"title":"SideExchange_MappedVector3D – SELF","text":"public subroutine SideExchange_MappedVector3D(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh Contents Source Code SideExchange_MappedVector3D Source Code subroutine SideExchange_MappedVector3D ( this , mesh ) implicit none class ( MappedVector3D ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: offset offset = mesh % decomp % offsetElem ( mesh % decomp % rankId + 1 ) if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif call SideExchange_3D_gpu ( this % extboundary_gpu , & this % boundary_gpu , mesh % sideinfo_gpu , mesh % decomp % elemToRank_gpu , & mesh % decomp % rankid , offset , this % interp % N , 3 * this % nvar , this % nelem ) if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call ApplyFlip_3D_gpu ( this % extboundary_gpu , mesh % sideInfo_gpu , & mesh % decomp % elemToRank_gpu , mesh % decomp % rankId , & offset , this % interp % N , 3 * this % nVar , this % nElem ) endif endsubroutine SideExchange_MappedVector3D","tags":"","loc":"proc/sideexchange_mappedvector3d.html"},{"title":"ContravariantProjection_3D_gpu – SELF","text":"interface public subroutine ContravariantProjection_3D_gpu(f, dsdx, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: f type(c_ptr), value :: dsdx integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel","tags":"","loc":"interface/contravariantprojection_3d_gpu.html"},{"title":"GPUAvailable – SELF","text":"public function GPUAvailable() result(avail) Arguments None Return Value logical Contents Source Code GPUAvailable Source Code function GPUAvailable () result ( avail ) implicit none logical :: avail ! Local integer ( c_int ) :: gpuCount integer ( kind ( hipSuccess )) :: err err = hipGetDeviceCount ( gpuCount ) if ( gpuCount > 0 . and . err == hipSuccess ) then avail = . true . else avail = . false . endif endfunction GPUAvailable","tags":"","loc":"proc/gpuavailable.html"},{"title":"gpuCheck – SELF","text":"public subroutine gpuCheck(gpuError_t) Arguments Type Intent Optional Attributes Name integer(kind=kind(hipSuccess)) :: gpuError_t Contents Source Code gpuCheck Source Code subroutine gpuCheck ( gpuError_t ) implicit none integer ( kind ( hipSuccess )) :: gpuError_t if ( gpuError_t /= hipSuccess ) then write ( * , * ) \"GPU ERROR: Error code = \" , gpuError_t call exit ( gpuError_t ) endif endsubroutine gpuCheck","tags":"","loc":"proc/gpucheck.html"},{"title":"hipFree – SELF","text":"public interface hipFree Contents Functions hipFree_ Functions public function hipFree_(ptr) bind(c,name=\"hipFree\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Return Value integer(kind=kind(hipSuccess))","tags":"","loc":"interface/hipfree.html"},{"title":"hipGetDeviceCount – SELF","text":"public interface hipGetDeviceCount Contents Functions hipGetDeviceCount_ Functions public function hipGetDeviceCount_(count) bind(c,name=\"hipGetDeviceCount\") Arguments Type Intent Optional Attributes Name integer(kind=c_int) :: count Return Value integer(kind=kind(hipSuccess))","tags":"","loc":"interface/hipgetdevicecount.html"},{"title":"hipMalloc – SELF","text":"public interface hipMalloc Contents Functions hipMalloc_ Functions public function hipMalloc_(ptr, mySize) bind(c,name=\"hipMalloc\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: ptr integer(kind=c_size_t), value :: mySize Return Value integer(kind=kind(hipSuccess))","tags":"","loc":"interface/hipmalloc.html"},{"title":"hipMemcpy – SELF","text":"public interface hipMemcpy Contents Functions hipMemcpy_ Functions public function hipMemcpy_(dest, src, sizeBytes, myKind) bind(c,name=\"hipMemcpy\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: dest type(c_ptr), value :: src integer(kind=c_size_t), value :: sizeBytes integer(kind=kind(hipMemcpyHostToHost)), value :: myKind Return Value integer(kind=kind(hipSuccess))","tags":"","loc":"interface/hipmemcpy.html"},{"title":"Free_Mesh3D – SELF","text":"public subroutine Free_Mesh3D(this) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: this Contents Source Code Free_Mesh3D Source Code subroutine Free_Mesh3D ( this ) implicit none class ( Mesh3D ), intent ( inout ) :: this this % nElem = 0 this % nSides = 0 this % nNodes = 0 this % nCornerNodes = 0 this % nUniqueSides = 0 this % nUniqueNodes = 0 this % nBCs = 0 deallocate ( this % elemInfo ) deallocate ( this % sideInfo ) deallocate ( this % nodeCoords ) deallocate ( this % globalNodeIDs ) deallocate ( this % CGNSCornerMap ) deallocate ( this % sideMap ) deallocate ( this % CGNSSideMap ) deallocate ( this % BCType ) deallocate ( this % BCNames ) call this % decomp % Free () call gpuCheck ( hipFree ( this % sideInfo_gpu )) endsubroutine Free_Mesh3D","tags":"","loc":"proc/free_mesh3d.html"},{"title":"Init_Mesh3D – SELF","text":"public subroutine Init_Mesh3D(this, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: this integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs Contents Source Code Init_Mesh3D Source Code subroutine Init_Mesh3D ( this , nGeo , nElem , nSides , nNodes , nBCs ) implicit none class ( Mesh3D ), intent ( inout ) :: this integer , intent ( in ) :: nGeo integer , intent ( in ) :: nElem integer , intent ( in ) :: nSides integer , intent ( in ) :: nNodes integer , intent ( in ) :: nBCs ! Local integer :: i , j , k , l this % nElem = nElem this % nGlobalElem = nElem this % nGeo = nGeo this % nSides = nSides this % nNodes = nNodes this % nCornerNodes = 0 this % nUniqueSides = 0 this % nUniqueNodes = 0 this % nBCs = nBCs allocate ( this % elemInfo ( 1 : 6 , 1 : nElem )) allocate ( this % sideInfo ( 1 : 5 , 1 : 6 , 1 : nElem )) allocate ( this % nodeCoords ( 1 : 3 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % globalNodeIDs ( 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % CGNSCornerMap ( 1 : 3 , 1 : 8 )) allocate ( this % CGNSSideMap ( 1 : 4 , 1 : 6 )) allocate ( this % sideMap ( 1 : 4 , 1 : 6 )) allocate ( this % BCType ( 1 : 4 , 1 : nBCs )) allocate ( this % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation this % CGNSCornerMap ( 1 : 3 , 1 ) = ( / 1 , 1 , 1 / ) ! Bottom-South-West this % CGNSCornerMap ( 1 : 3 , 2 ) = ( / nGeo + 1 , 1 , 1 / ) ! Bottom-South-East this % CGNSCornerMap ( 1 : 3 , 3 ) = ( / nGeo + 1 , nGeo + 1 , 1 / ) ! Bottom-North-East this % CGNSCornerMap ( 1 : 3 , 4 ) = ( / 1 , nGeo + 1 , 1 / ) ! Bottom-North-West this % CGNSCornerMap ( 1 : 3 , 5 ) = ( / 1 , 1 , nGeo + 1 / ) ! Top-South-West this % CGNSCornerMap ( 1 : 3 , 6 ) = ( / nGeo + 1 , 1 , nGeo + 1 / ) ! Top-South-East this % CGNSCornerMap ( 1 : 3 , 7 ) = ( / nGeo + 1 , nGeo + 1 , nGeo + 1 / ) ! Top-North-East this % CGNSCornerMap ( 1 : 3 , 8 ) = ( / 1 , nGeo + 1 , nGeo + 1 / ) ! Top-North-West ! Maps from local corner node id to CGNS side this % CGNSSideMap ( 1 : 4 , 1 ) = ( / 1 , 4 , 3 , 2 / ) this % CGNSSideMap ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) this % CGNSSideMap ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) this % CGNSSideMap ( 1 : 4 , 4 ) = ( / 3 , 4 , 8 , 7 / ) this % CGNSSideMap ( 1 : 4 , 5 ) = ( / 1 , 5 , 8 , 4 / ) this % CGNSSideMap ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) ! Sidemap traverses each face so that the normal ! formed by the right hand rule is the coordinate ! positive pointing normal. For east,north,and top ! this is an outward facing normal. ! For bottom, south, and west, the normal is inward ! facing. this % sideMap ( 1 : 4 , 1 ) = ( / 1 , 2 , 3 , 4 / ) ! Bottom this % sideMap ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) ! South this % sideMap ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) ! East this % sideMap ( 1 : 4 , 4 ) = ( / 4 , 3 , 7 , 8 / ) ! North this % sideMap ( 1 : 4 , 5 ) = ( / 1 , 4 , 8 , 5 / ) ! West this % sideMap ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) ! Top call gpuCheck ( hipMalloc ( this % sideInfo_gpu , sizeof ( this % sideInfo ))) endsubroutine Init_Mesh3D","tags":"","loc":"proc/init_mesh3d.html"},{"title":"Read_HOPr_Mesh3D – SELF","text":"public subroutine Read_HOPr_Mesh3D(this, meshFile, enableDomainDecomposition) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: this character, intent(in) :: meshFile logical, intent(in), optional :: enableDomainDecomposition Contents Source Code Read_HOPr_Mesh3D Source Code subroutine Read_HOPr_Mesh3D ( this , meshFile , enableDomainDecomposition ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 implicit none class ( Mesh3D ), intent ( out ) :: this character ( * ), intent ( in ) :: meshFile logical , intent ( in ), optional :: enableDomainDecomposition ! Local integer ( HID_T ) :: fileId integer ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) integer :: nGlobalElem integer :: firstElem integer :: firstNode integer :: firstSide integer :: nLocalElems integer :: nLocalNodes integer :: nLocalSides integer :: nUniqueSides integer :: nGeo , nBCs integer :: eid , lsid , iSide integer :: i , j , k , nid integer , dimension (:,:), allocatable :: hopr_elemInfo integer , dimension (:,:), allocatable :: hopr_sideInfo real ( prec ), dimension (:,:), allocatable :: hopr_nodeCoords integer , dimension (:), allocatable :: hopr_globalNodeIDs integer , dimension (:,:), allocatable :: bcType if ( present ( enableDomainDecomposition )) then call this % decomp % init ( enableDomainDecomposition ) else call this % decomp % init (. false .) endif if ( this % decomp % mpiEnabled ) then call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId , this % decomp % mpiComm ) else call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId ) endif call ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) call ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) call ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) call ReadAttribute_HDF5 ( fileId , 'nUniqueSides' , nUniqueSides ) ! Read BCType allocate ( bcType ( 1 : 4 , 1 : nBCs )) if ( this % decomp % mpiEnabled ) then offset (:) = 0 call ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) else call ReadArray_HDF5 ( fileId , 'BCType' , bcType ) endif ! Read local subarray of ElemInfo call this % decomp % GenerateDecomposition ( nGlobalElem , nUniqueSides ) firstElem = this % decomp % offsetElem ( this % decomp % rankId + 1 ) + 1 nLocalElems = this % decomp % offsetElem ( this % decomp % rankId + 2 ) - & this % decomp % offsetElem ( this % decomp % rankId + 1 ) ! Allocate Space for hopr_elemInfo! allocate ( hopr_elemInfo ( 1 : 6 , 1 : nLocalElems )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstElem - 1 / ) call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) else call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) endif ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo ( 5 , 1 ) + 1 nLocalNodes = hopr_elemInfo ( 6 , nLocalElems ) - hopr_elemInfo ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! allocate ( hopr_nodeCoords ( 1 : 3 , 1 : nLocalNodes ), hopr_globalNodeIDs ( 1 : nLocalNodes )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) else call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) endif ! Read local subarray of SideInfo firstSide = hopr_elemInfo ( 3 , 1 ) + 1 nLocalSides = hopr_elemInfo ( 4 , nLocalElems ) - hopr_elemInfo ( 3 , 1 ) ! Allocate space for hopr_sideInfo allocate ( hopr_sideInfo ( 1 : 5 , 1 : nLocalSides )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstSide - 1 / ) call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) else call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) endif call Close_HDF5 ( fileID ) ! ---- Done reading 3-D Mesh information ---- ! ! Load hopr data into mesh data structure call this % Init ( nGeo , nLocalElems , nLocalSides , nLocalNodes , nBCs ) ! Copy data from local arrays into this this % elemInfo = hopr_elemInfo this % nUniqueSides = nUniqueSides this % quadrature = UNIFORM ! Grab the node coordinates do eid = 1 , this % nElem do k = 1 , nGeo + 1 do j = 1 , nGeo + 1 do i = 1 , nGeo + 1 nid = i + ( nGeo + 1 ) * ( j - 1 + ( nGeo + 1 ) * ( k - 1 + ( nGeo + 1 ) * ( eid - 1 ))) this % nodeCoords ( 1 : 3 , i , j , k , eid ) = hopr_nodeCoords ( 1 : 3 , nid ) this % globalNodeIDs ( i , j , k , eid ) = hopr_globalNodeIDs ( nid ) enddo enddo enddo enddo iSide = 0 do eid = 1 , this % nElem do lsid = 1 , 6 iSide = iSide + 1 this % sideInfo ( 1 : 5 , lsid , eid ) = hopr_sideInfo ( 1 : 5 , iSide ) enddo enddo call this % RecalculateFlip () deallocate ( hopr_elemInfo , hopr_nodeCoords , hopr_globalNodeIDs , hopr_sideInfo ) call gpuCheck ( hipMemcpy ( this % sideInfo_gpu , c_loc ( this % sideInfo ), sizeof ( this % sideInfo ), hipMemcpyHostToDevice )) endsubroutine Read_HOPr_Mesh3D","tags":"","loc":"proc/read_hopr_mesh3d.html"},{"title":"MappedDGDerivative_MappedScalar1D – SELF","text":"public subroutine MappedDGDerivative_MappedScalar1D(this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: df Contents Source Code MappedDGDerivative_MappedScalar1D Source Code subroutine MappedDGDerivative_MappedScalar1D ( this , dF ) implicit none class ( MappedScalar1D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df ! Local integer :: iEl , iVar , i , ii real ( prec ) :: dfloc call self_blas_matrixop_1d ( this % interp % dgMatrix_gpu , & this % interior_gpu , & df , this % N + 1 , this % N + 1 , & this % nvar * this % nelem , this % blas_handle ) call DGDerivative_BoundaryContribution_1D_gpu ( this % interp % bMatrix_gpu , & this % interp % qWeights_gpu , & this % boundarynormal_gpu , df , & this % N , this % nVar , this % nelem ) call JacobianWeight_1D_gpu ( df , this % geometry % dxds % interior_gpu , this % N , this % nVar , this % nelem ) endsubroutine MappedDGDerivative_MappedScalar1D","tags":"","loc":"proc/mappeddgderivative_mappedscalar1d.html"},{"title":"MappedDerivative_MappedScalar1D – SELF","text":"public subroutine MappedDerivative_MappedScalar1D(this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: df Contents Source Code MappedDerivative_MappedScalar1D Source Code subroutine MappedDerivative_MappedScalar1D ( this , dF ) implicit none class ( MappedScalar1D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df ! Local integer :: iEl , iVar , i , ii real ( prec ) :: dfloc call this % Derivative ( df ) call JacobianWeight_1D_gpu ( df , this % geometry % dxds % interior_gpu , this % N , this % nVar , this % nelem ) endsubroutine MappedDerivative_MappedScalar1D","tags":"","loc":"proc/mappedderivative_mappedscalar1d.html"},{"title":"SetInteriorFromEquation_MappedScalar1D – SELF","text":"public subroutine SetInteriorFromEquation_MappedScalar1D(this, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: this real(kind=prec), intent(in) :: time Contents Source Code SetInteriorFromEquation_MappedScalar1D Source Code subroutine SetInteriorFromEquation_MappedScalar1D ( this , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedScalar1D ), intent ( inout ) :: this real ( prec ), intent ( in ) :: time ! Local integer :: iVar do ivar = 1 , this % nvar this % interior (:,:, ivar ) = this % eqn ( ivar )% evaluate ( this % geometry % x % interior ) enddo call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) endsubroutine SetInteriorFromEquation_MappedScalar1D","tags":"","loc":"proc/setinteriorfromequation_mappedscalar1d.html"},{"title":"SideExchange_MappedScalar1D – SELF","text":"public subroutine SideExchange_MappedScalar1D(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: this type( Mesh1D ), intent(inout) :: mesh Contents Source Code SideExchange_MappedScalar1D Source Code subroutine SideExchange_MappedScalar1D ( this , mesh ) implicit none class ( MappedScalar1D ), intent ( inout ) :: this type ( Mesh1D ), intent ( inout ) :: mesh ! Local integer :: e1 , e2 , s1 , s2 integer :: ivar call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) do ivar = 1 , this % nvar do e1 = 1 , mesh % nElem if ( e1 == 1 ) then s1 = 2 e2 = e1 + 1 s2 = 1 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) elseif ( e1 == mesh % nElem ) then s1 = 1 e2 = e1 - 1 s2 = 2 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) else s1 = 1 e2 = e1 - 1 s2 = 2 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) s1 = 2 e2 = e1 + 1 s2 = 1 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) endif enddo enddo call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) endsubroutine SideExchange_MappedScalar1D","tags":"","loc":"proc/sideexchange_mappedscalar1d.html"},{"title":"DGDerivative_BoundaryContribution_1D_gpu – SELF","text":"interface public subroutine DGDerivative_BoundaryContribution_1D_gpu(bMatrix, qWeights, bf, df, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: bMatrix type(c_ptr), value :: qWeights type(c_ptr), value :: bf type(c_ptr), value :: df integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl","tags":"","loc":"interface/dgderivative_boundarycontribution_1d_gpu.html"},{"title":"JacobianWeight_1D_gpu – SELF","text":"interface public subroutine JacobianWeight_1D_gpu(scalar, dxds, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: scalar type(c_ptr), value :: dxds integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl","tags":"","loc":"interface/jacobianweight_1d_gpu.html"},{"title":"Free_Tensor3D – SELF","text":"public subroutine Free_Tensor3D(this) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: this Contents Source Code Free_Tensor3D Source Code subroutine Free_Tensor3D ( this ) implicit none class ( Tensor3D ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Tensor3D","tags":"","loc":"proc/free_tensor3d.html"},{"title":"Init_Tensor3D – SELF","text":"public subroutine Init_Tensor3D(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Tensor3D Source Code subroutine Init_Tensor3D ( this , interp , nVar , nElem ) implicit none class ( Tensor3D ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 3 , 1 : 3 ), & this % boundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 , 1 : 3 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 , 1 : 3 )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 9 * nVar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 4 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call hipblasCheck ( hipblasCreate ( this % blas_handle )) call this % UpdateDevice () endsubroutine Init_Tensor3D","tags":"","loc":"proc/init_tensor3d.html"},{"title":"UpdateDevice_Tensor3D – SELF","text":"public subroutine UpdateDevice_Tensor3D(this) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: this Contents Source Code UpdateDevice_Tensor3D Source Code subroutine UpdateDevice_Tensor3D ( this ) implicit none class ( Tensor3D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundary_gpu , c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Tensor3D","tags":"","loc":"proc/updatedevice_tensor3d.html"},{"title":"UpdateHost_Tensor3D – SELF","text":"public subroutine UpdateHost_Tensor3D(this) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: this Contents Source Code UpdateHost_Tensor3D Source Code subroutine UpdateHost_Tensor3D ( this ) implicit none class ( Tensor3D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), this % interior_gpu , sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), this % extboundary_gpu , sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Tensor3D","tags":"","loc":"proc/updatehost_tensor3d.html"},{"title":"AverageSides_Scalar3D – SELF","text":"public subroutine AverageSides_Scalar3D(this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this Contents Source Code AverageSides_Scalar3D Source Code subroutine AverageSides_Scalar3D ( this ) implicit none class ( Scalar3D ), intent ( inout ) :: this call Average_gpu ( this % avgBoundary_gpu , this % boundary_gpu , this % extBoundary_gpu , size ( this % boundary )) endsubroutine AverageSides_Scalar3D","tags":"","loc":"proc/averagesides_scalar3d.html"},{"title":"BoundaryInterp_Scalar3D – SELF","text":"public subroutine BoundaryInterp_Scalar3D(this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this Contents Source Code BoundaryInterp_Scalar3D Source Code subroutine BoundaryInterp_Scalar3D ( this ) implicit none class ( Scalar3D ), intent ( inout ) :: this call BoundaryInterp_3D_gpu ( this % interp % bMatrix_gpu , this % interior_gpu , this % boundary_gpu , & this % interp % N , this % nvar , this % nelem ) endsubroutine BoundaryInterp_Scalar3D","tags":"","loc":"proc/boundaryinterp_scalar3d.html"},{"title":"Free_Scalar3D – SELF","text":"public subroutine Free_Scalar3D(this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this Contents Source Code Free_Scalar3D Source Code subroutine Free_Scalar3D ( this ) implicit none class ( Scalar3D ), intent ( inout ) :: this this % nVar = 0 this % nElem = 0 this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % boundarynormal ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call gpuCheck ( hipFree ( this % avgBoundary_gpu )) call gpuCheck ( hipFree ( this % boundarynormal_gpu )) call gpuCheck ( hipFree ( this % interpWork1 )) call gpuCheck ( hipFree ( this % interpWork2 )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Scalar3D","tags":"","loc":"proc/free_scalar3d.html"},{"title":"Gradient_Scalar3D – SELF","text":"public subroutine Gradient_Scalar3D(this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this type(c_ptr), intent(inout) :: df Contents Source Code Gradient_Scalar3D Source Code subroutine Gradient_Scalar3D ( this , df ) implicit none class ( Scalar3D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df !Local real ( prec ), pointer :: df_p (:,:,:,:,:,:) real ( prec ), pointer :: dfloc (:,:,:,:,:) type ( c_ptr ) :: dfc call c_f_pointer ( df , df_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 3 ]) dfloc ( 1 :, 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 :, 1 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim1_3d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) dfloc ( 1 :, 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 :, 2 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim2_3d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , 0.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) dfloc ( 1 :, 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 :, 3 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim3_3d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , 0.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) dfloc => null () df_p => null () endsubroutine Gradient_Scalar3D","tags":"","loc":"proc/gradient_scalar3d.html"},{"title":"GridInterp_Scalar3D – SELF","text":"public subroutine GridInterp_Scalar3D(this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this type(c_ptr), intent(inout) :: f Contents Source Code GridInterp_Scalar3D Source Code subroutine GridInterp_Scalar3D ( this , f ) implicit none class ( Scalar3D ), intent ( inout ) :: this type ( c_ptr ), intent ( inout ) :: f call self_blas_matrixop_dim1_3d ( this % interp % iMatrix_gpu , this % interior_gpu , & this % interpWork1 , this % N , this % M , this % nvar , this % nelem , & this % blas_handle ) call self_blas_matrixop_dim2_3d ( this % interp % iMatrix_gpu , this % interpWork1 , this % interpWork2 , & 0.0_c_prec , this % N , this % M , this % nvar , this % nelem , & this % blas_handle ) call self_blas_matrixop_dim3_3d ( this % interp % iMatrix_gpu , this % interpWork2 , f , & 0.0_c_prec , this % N , this % M , this % nvar , this % nelem , & this % blas_handle ) endsubroutine GridInterp_Scalar3D","tags":"","loc":"proc/gridinterp_scalar3d.html"},{"title":"Init_Scalar3D – SELF","text":"public subroutine Init_Scalar3D(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar3D Source Code subroutine Init_Scalar3D ( this , interp , nVar , nElem ) implicit none class ( Scalar3D ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! Local integer ( c_size_t ) :: workSize this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar ), & this % boundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : 3 * nvar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec this % boundarynormal = 0.0_prec allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( this % avgBoundary_gpu , sizeof ( this % avgBoundary ))) call gpuCheck ( hipMalloc ( this % boundarynormal_gpu , sizeof ( this % boundarynormal ))) workSize = ( interp % N + 1 ) * ( interp % N + 1 ) * ( interp % M + 1 ) * nelem * nvar * prec call gpuCheck ( hipMalloc ( this % interpWork1 , workSize )) workSize = ( interp % N + 1 ) * ( interp % M + 1 ) * ( interp % M + 1 ) * nelem * nvar * prec call gpuCheck ( hipMalloc ( this % interpWork2 , workSize )) call this % UpdateDevice () call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_Scalar3D","tags":"","loc":"proc/init_scalar3d.html"},{"title":"UpdateDevice_Scalar3D – SELF","text":"public subroutine UpdateDevice_Scalar3D(this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this Contents Source Code UpdateDevice_Scalar3D Source Code subroutine UpdateDevice_Scalar3D ( this ) implicit none class ( Scalar3D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundary_gpu , c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % avgboundary_gpu , c_loc ( this % avgboundary ), sizeof ( this % avgboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundarynormal_gpu , c_loc ( this % boundarynormal ), sizeof ( this % boundarynormal ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Scalar3D","tags":"","loc":"proc/updatedevice_scalar3d.html"},{"title":"UpdateHost_Scalar3D – SELF","text":"public subroutine UpdateHost_Scalar3D(this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this Contents Source Code UpdateHost_Scalar3D Source Code subroutine UpdateHost_Scalar3D ( this ) implicit none class ( Scalar3D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), this % interior_gpu , sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), this % extboundary_gpu , sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % avgboundary ), this % avgboundary_gpu , sizeof ( this % avgboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundarynormal ), this % boundarynormal_gpu , sizeof ( this % boundarynormal ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Scalar3D","tags":"","loc":"proc/updatehost_scalar3d.html"},{"title":"AverageSides_Scalar2D – SELF","text":"public subroutine AverageSides_Scalar2D(this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this Contents Source Code AverageSides_Scalar2D Source Code subroutine AverageSides_Scalar2D ( this ) implicit none class ( Scalar2D ), intent ( inout ) :: this call Average_gpu ( this % avgBoundary_gpu , this % boundary_gpu , this % extBoundary_gpu , size ( this % boundary )) endsubroutine AverageSides_Scalar2D","tags":"","loc":"proc/averagesides_scalar2d.html"},{"title":"BoundaryInterp_Scalar2D – SELF","text":"public subroutine BoundaryInterp_Scalar2D(this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this Contents Source Code BoundaryInterp_Scalar2D Source Code subroutine BoundaryInterp_Scalar2D ( this ) implicit none class ( Scalar2D ), intent ( inout ) :: this call BoundaryInterp_2D_gpu ( this % interp % bMatrix_gpu , this % interior_gpu , this % boundary_gpu , & this % interp % N , this % nvar , this % nelem ) endsubroutine BoundaryInterp_Scalar2D","tags":"","loc":"proc/boundaryinterp_scalar2d.html"},{"title":"Free_Scalar2D – SELF","text":"public subroutine Free_Scalar2D(this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this Contents Source Code Free_Scalar2D Source Code subroutine Free_Scalar2D ( this ) implicit none class ( Scalar2D ), intent ( inout ) :: this this % nVar = 0 this % nElem = 0 this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % boundarynormal ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call gpuCheck ( hipFree ( this % avgBoundary_gpu )) call gpuCheck ( hipFree ( this % boundarynormal_gpu )) call gpuCheck ( hipFree ( this % interpWork )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Scalar2D","tags":"","loc":"proc/free_scalar2d.html"},{"title":"Gradient_Scalar2D – SELF","text":"public subroutine Gradient_Scalar2D(this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this type(c_ptr), intent(inout) :: df Contents Source Code Gradient_Scalar2D Source Code subroutine Gradient_Scalar2D ( this , df ) implicit none class ( Scalar2D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df !Local real ( prec ), pointer :: df_p (:,:,:,:,:) real ( prec ), pointer :: dfloc (:,:,:,:) type ( c_ptr ) :: dfc call c_f_pointer ( df , df_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 2 ]) dfloc ( 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim1_2d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) dfloc ( 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 2 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim2_2d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , 0.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) dfloc => null () df_p => null () endsubroutine Gradient_Scalar2D","tags":"","loc":"proc/gradient_scalar2d.html"},{"title":"GridInterp_Scalar2D – SELF","text":"public subroutine GridInterp_Scalar2D(this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this type(c_ptr), intent(inout) :: f Contents Source Code GridInterp_Scalar2D Source Code subroutine GridInterp_Scalar2D ( this , f ) implicit none class ( Scalar2D ), intent ( inout ) :: this type ( c_ptr ), intent ( inout ) :: f call self_blas_matrixop_dim1_2d ( this % interp % iMatrix_gpu , this % interior_gpu , & this % interpWork , this % N , this % M , this % nvar , this % nelem , & this % blas_handle ) call self_blas_matrixop_dim2_2d ( this % interp % iMatrix_gpu , this % interpWork , f , & 0.0_c_prec , this % N , this % M , this % nvar , this % nelem , & this % blas_handle ) endsubroutine GridInterp_Scalar2D","tags":"","loc":"proc/gridinterp_scalar2d.html"},{"title":"Init_Scalar2D – SELF","text":"public subroutine Init_Scalar2D(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar2D Source Code subroutine Init_Scalar2D ( this , interp , nVar , nElem ) implicit none class ( Scalar2D ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! Local integer ( c_size_t ) :: workSize this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , interp % N + 1 , nelem , nvar ), & this % boundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : 2 * nvar )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec this % boundarynormal = 0.0_prec call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( this % avgBoundary_gpu , sizeof ( this % avgBoundary ))) call gpuCheck ( hipMalloc ( this % boundarynormal_gpu , sizeof ( this % boundarynormal ))) workSize = ( interp % N + 1 ) * ( interp % M + 1 ) * nelem * nvar * prec call gpuCheck ( hipMalloc ( this % interpWork , workSize )) call this % UpdateDevice () call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_Scalar2D","tags":"","loc":"proc/init_scalar2d.html"},{"title":"UpdateDevice_Scalar2D – SELF","text":"public subroutine UpdateDevice_Scalar2D(this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this Contents Source Code UpdateDevice_Scalar2D Source Code subroutine UpdateDevice_Scalar2D ( this ) implicit none class ( Scalar2D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundary_gpu , c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % avgboundary_gpu , c_loc ( this % avgboundary ), sizeof ( this % avgboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundarynormal_gpu , c_loc ( this % boundarynormal ), sizeof ( this % boundarynormal ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Scalar2D","tags":"","loc":"proc/updatedevice_scalar2d.html"},{"title":"UpdateHost_Scalar2D – SELF","text":"public subroutine UpdateHost_Scalar2D(this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this Contents Source Code UpdateHost_Scalar2D Source Code subroutine UpdateHost_Scalar2D ( this ) implicit none class ( Scalar2D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), this % interior_gpu , sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), this % extboundary_gpu , sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % avgboundary ), this % avgboundary_gpu , sizeof ( this % avgboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundarynormal ), this % boundarynormal_gpu , sizeof ( this % boundarynormal ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Scalar2D","tags":"","loc":"proc/updatehost_scalar2d.html"},{"title":"ApplyFlip_2D_gpu – SELF","text":"interface public subroutine ApplyFlip_2D_gpu(extBoundary, sideInfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extBoundary type(c_ptr), value :: sideInfo type(c_ptr), value :: elemToRank integer(kind=c_int), value :: rankId integer(kind=c_int), value :: offset integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl","tags":"","loc":"interface/applyflip_2d_gpu.html"},{"title":"ApplyFlip_3D_gpu – SELF","text":"interface public subroutine ApplyFlip_3D_gpu(extBoundary, sideInfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extBoundary type(c_ptr), value :: sideInfo type(c_ptr), value :: elemToRank integer(kind=c_int), value :: rankId integer(kind=c_int), value :: offset integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl","tags":"","loc":"interface/applyflip_3d_gpu.html"},{"title":"Average_gpu – SELF","text":"interface public subroutine Average_gpu(favg, f1, f2, ndof) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: favg type(c_ptr), value :: f1 type(c_ptr), value :: f2 integer(kind=c_int), value :: ndof","tags":"","loc":"interface/average_gpu.html"},{"title":"BoundaryInterp_2D_gpu – SELF","text":"interface public subroutine BoundaryInterp_2D_gpu(bMatrix_dev, f_dev, bf_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: bMatrix_dev type(c_ptr), value :: f_dev type(c_ptr), value :: bf_dev integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl","tags":"","loc":"interface/boundaryinterp_2d_gpu.html"},{"title":"BoundaryInterp_3D_gpu – SELF","text":"interface public subroutine BoundaryInterp_3D_gpu(bMatrix_dev, f_dev, bf_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: bMatrix_dev type(c_ptr), value :: f_dev type(c_ptr), value :: bf_dev integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl","tags":"","loc":"interface/boundaryinterp_3d_gpu.html"},{"title":"CalculateDSDt_gpu – SELF","text":"interface public subroutine CalculateDSDt_gpu(fluxDivergence, source, dsdt, ndof) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: fluxDivergence type(c_ptr), value :: source type(c_ptr), value :: dsdt integer(kind=c_int), value :: ndof","tags":"","loc":"interface/calculatedsdt_gpu.html"},{"title":"DG_BoundaryContribution_2D_gpu – SELF","text":"interface public subroutine DG_BoundaryContribution_2D_gpu(bmatrix, qweights, bf, df, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: bmatrix type(c_ptr), value :: qweights type(c_ptr), value :: bf type(c_ptr), value :: df integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel","tags":"","loc":"interface/dg_boundarycontribution_2d_gpu.html"},{"title":"DG_BoundaryContribution_3D_gpu – SELF","text":"interface public subroutine DG_BoundaryContribution_3D_gpu(bmatrix, qweights, bf, df, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: bmatrix type(c_ptr), value :: qweights type(c_ptr), value :: bf type(c_ptr), value :: df integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel","tags":"","loc":"interface/dg_boundarycontribution_3d_gpu.html"},{"title":"GradientNormal_1D_gpu – SELF","text":"interface public subroutine GradientNormal_1D_gpu(fbn, fbavg, ndof) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: fbn type(c_ptr), value :: fbavg integer(kind=c_int), value :: ndof","tags":"","loc":"interface/gradientnormal_1d_gpu.html"},{"title":"JacobianWeight_2D_gpu – SELF","text":"interface public subroutine JacobianWeight_2D_gpu(scalar, J, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: scalar type(c_ptr), value :: J integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl","tags":"","loc":"interface/jacobianweight_2d_gpu.html"},{"title":"JacobianWeight_3D_gpu – SELF","text":"interface public subroutine JacobianWeight_3D_gpu(scalar, J, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: scalar type(c_ptr), value :: J integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl","tags":"","loc":"interface/jacobianweight_3d_gpu.html"},{"title":"SideExchange_2D_gpu – SELF","text":"interface public subroutine SideExchange_2D_gpu(extboundary, boundary, sideinfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extboundary type(c_ptr), value :: boundary type(c_ptr), value :: sideinfo type(c_ptr), value :: elemToRank integer(kind=c_int), value :: rankId integer(kind=c_int), value :: offset integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl","tags":"","loc":"interface/sideexchange_2d_gpu.html"},{"title":"SideExchange_3D_gpu – SELF","text":"interface public subroutine SideExchange_3D_gpu(extboundary, boundary, sideinfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extboundary type(c_ptr), value :: boundary type(c_ptr), value :: sideinfo type(c_ptr), value :: elemToRank integer(kind=c_int), value :: rankId integer(kind=c_int), value :: offset integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl","tags":"","loc":"interface/sideexchange_3d_gpu.html"},{"title":"UpdateGRK_gpu – SELF","text":"interface public subroutine UpdateGRK_gpu(grk, solution, dsdt, rk_a, rk_g, dt, ndof) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: grk type(c_ptr), value :: solution type(c_ptr), value :: dsdt real(kind=c_prec), value :: rk_a real(kind=c_prec), value :: rk_g real(kind=c_prec), value :: dt integer(kind=c_int), value :: ndof","tags":"","loc":"interface/updategrk_gpu.html"},{"title":"UpdateSolution_gpu – SELF","text":"interface public subroutine UpdateSolution_gpu(solution, dsdt, dt, ndof) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: solution type(c_ptr), value :: dsdt real(kind=c_prec), value :: dt integer(kind=c_int), value :: ndof","tags":"","loc":"interface/updatesolution_gpu.html"},{"title":"AverageSides_Vector2D – SELF","text":"public subroutine AverageSides_Vector2D(this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this Contents Source Code AverageSides_Vector2D Source Code subroutine AverageSides_Vector2D ( this ) implicit none class ( Vector2D ), intent ( inout ) :: this call Average_gpu ( this % avgBoundary_gpu , this % boundary_gpu , this % extBoundary_gpu , size ( this % boundary )) endsubroutine AverageSides_Vector2D","tags":"","loc":"proc/averagesides_vector2d.html"},{"title":"BoundaryInterp_Vector2D – SELF","text":"public subroutine BoundaryInterp_Vector2D(this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this Contents Source Code BoundaryInterp_Vector2D Source Code subroutine BoundaryInterp_Vector2D ( this ) implicit none class ( Vector2D ), intent ( inout ) :: this call BoundaryInterp_2D_gpu ( this % interp % bMatrix_gpu , this % interior_gpu , this % boundary_gpu , & this % interp % N , 2 * this % nvar , this % nelem ) endsubroutine BoundaryInterp_Vector2D","tags":"","loc":"proc/boundaryinterp_vector2d.html"},{"title":"Divergence_Vector2D – SELF","text":"public subroutine Divergence_Vector2D(this, df) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this type(c_ptr), intent(inout) :: df Contents Source Code Divergence_Vector2D Source Code subroutine Divergence_Vector2D ( this , df ) implicit none class ( Vector2D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df !Local real ( prec ), pointer :: f_p (:,:,:,:,:) type ( c_ptr ) :: fc call c_f_pointer ( this % interior_gpu , f_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 2 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_2d ( this % interp % dMatrix_gpu , fc , df , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_2d ( this % interp % dMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) f_p => null () endsubroutine Divergence_Vector2D","tags":"","loc":"proc/divergence_vector2d.html"},{"title":"Free_Vector2D – SELF","text":"public subroutine Free_Vector2D(this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this Contents Source Code Free_Vector2D Source Code subroutine Free_Vector2D ( this ) implicit none class ( Vector2D ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % boundaryNormal ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call gpuCheck ( hipFree ( this % avgBoundary_gpu )) call gpuCheck ( hipFree ( this % boundaryNormal_gpu )) call gpuCheck ( hipFree ( this % interpWork )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Vector2D","tags":"","loc":"proc/free_vector2d.html"},{"title":"Gradient_Vector2D – SELF","text":"public subroutine Gradient_Vector2D(this, df) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this type(c_ptr), intent(inout) :: df Contents Source Code Gradient_Vector2D Source Code subroutine Gradient_Vector2D ( this , df ) implicit none class ( Vector2D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df !Local real ( prec ), pointer :: df_p (:,:,:,:,:,:) real ( prec ), pointer :: dfloc (:,:,:,:) type ( c_ptr ) :: dfc call c_f_pointer ( df , df_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 2 , 2 ]) dfloc ( 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 , 1 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim1_2d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , & this % interp % N , this % interp % N , 2 * this % nvar , this % nelem , this % blas_handle ) dfloc ( 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 , 2 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim2_2d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , 0.0_c_prec , & this % interp % N , this % interp % N , 2 * this % nvar , this % nelem , this % blas_handle ) dfloc => null () df_p => null () endsubroutine Gradient_Vector2D","tags":"","loc":"proc/gradient_vector2d.html"},{"title":"GridInterp_Vector2D – SELF","text":"public subroutine GridInterp_Vector2D(this, f) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this type(c_ptr), intent(inout) :: f Contents Source Code GridInterp_Vector2D Source Code subroutine GridInterp_Vector2D ( this , f ) implicit none class ( Vector2D ), intent ( inout ) :: this type ( c_ptr ), intent ( inout ) :: f call self_blas_matrixop_dim1_2d ( this % interp % iMatrix_gpu , this % interior_gpu , & this % interpWork , this % N , this % M , 2 * this % nvar , this % nelem , & this % blas_handle ) call self_blas_matrixop_dim2_2d ( this % interp % iMatrix_gpu , this % interpWork , f , & 0.0_c_prec , this % N , this % M , 2 * this % nvar , this % nelem , & this % blas_handle ) endsubroutine GridInterp_Vector2D","tags":"","loc":"proc/gridinterp_vector2d.html"},{"title":"Init_Vector2D – SELF","text":"public subroutine Init_Vector2D(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Vector2D Source Code subroutine Init_Vector2D ( this , interp , nVar , nElem ) implicit none class ( Vector2D ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i integer ( c_size_t ) :: workSize this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % boundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % boundaryNormal ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 2 * nVar )) ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 2 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo this % interior = 0.0_prec this % boundary = 0.0_prec this % boundarynormal = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( this % avgBoundary_gpu , sizeof ( this % avgBoundary ))) call gpuCheck ( hipMalloc ( this % boundaryNormal_gpu , sizeof ( this % boundaryNormal ))) workSize = ( interp % N + 1 ) * ( interp % M + 1 ) * nelem * nvar * 2 * prec call gpuCheck ( hipMalloc ( this % interpWork , workSize )) call this % UpdateDevice () call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_Vector2D","tags":"","loc":"proc/init_vector2d.html"},{"title":"UpdateDevice_Vector2D – SELF","text":"public subroutine UpdateDevice_Vector2D(this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this Contents Source Code UpdateDevice_Vector2D Source Code subroutine UpdateDevice_Vector2D ( this ) implicit none class ( Vector2D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundary_gpu , c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % avgboundary_gpu , c_loc ( this % avgboundary ), sizeof ( this % avgboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundaryNormal_gpu , c_loc ( this % boundaryNormal ), sizeof ( this % boundaryNormal ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Vector2D","tags":"","loc":"proc/updatedevice_vector2d.html"},{"title":"UpdateHost_Vector2D – SELF","text":"public subroutine UpdateHost_Vector2D(this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this Contents Source Code UpdateHost_Vector2D Source Code subroutine UpdateHost_Vector2D ( this ) implicit none class ( Vector2D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), this % interior_gpu , sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), this % extboundary_gpu , sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % avgboundary ), this % avgboundary_gpu , sizeof ( this % avgboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundaryNormal ), this % boundaryNormal_gpu , sizeof ( this % boundaryNormal ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Vector2D","tags":"","loc":"proc/updatehost_vector2d.html"},{"title":"Free_MappedScalar2D – SELF","text":"public subroutine Free_MappedScalar2D(this) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this Contents Source Code Free_MappedScalar2D Source Code subroutine Free_MappedScalar2D ( this ) implicit none class ( MappedScalar2D ), intent ( inout ) :: this this % nVar = 0 this % nElem = 0 this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % boundarynormal ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call gpuCheck ( hipFree ( this % avgBoundary_gpu )) call gpuCheck ( hipFree ( this % interpWork )) call gpuCheck ( hipFree ( this % jas_gpu )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_MappedScalar2D","tags":"","loc":"proc/free_mappedscalar2d.html"},{"title":"Init_MappedScalar2D – SELF","text":"public subroutine Init_MappedScalar2D(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_MappedScalar2D Source Code subroutine Init_MappedScalar2D ( this , interp , nVar , nElem ) implicit none class ( MappedScalar2D ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! Local integer ( c_size_t ) :: workSize this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , interp % N + 1 , nelem , nvar ), & this % boundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : 2 * nvar )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec this % boundarynormal = 0.0_prec call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( this % avgBoundary_gpu , sizeof ( this % avgBoundary ))) call gpuCheck ( hipMalloc ( this % boundarynormal_gpu , sizeof ( this % boundarynormal ))) workSize = ( interp % N + 1 ) * ( interp % M + 1 ) * nelem * nvar * prec call gpuCheck ( hipMalloc ( this % interpWork , workSize )) workSize = ( interp % N + 1 ) * ( interp % N + 1 ) * nelem * nvar * 4 * prec call gpuCheck ( hipMalloc ( this % jas_gpu , workSize )) call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_MappedScalar2D","tags":"","loc":"proc/init_mappedscalar2d.html"},{"title":"MPIExchangeAsync_MappedScalar2D – SELF","text":"public subroutine MPIExchangeAsync_MappedScalar2D(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh Contents Source Code MPIExchangeAsync_MappedScalar2D Source Code subroutine MPIExchangeAsync_MappedScalar2D ( this , mesh ) implicit none class ( MappedScalar2D ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount real ( prec ), pointer :: boundary (:,:,:,:) real ( prec ), pointer :: extboundary (:,:,:,:) msgCount = 0 call c_f_pointer ( this % boundary_gpu , boundary ,[ this % interp % N + 1 , 4 , this % nelem , this % nvar ]) call c_f_pointer ( this % extboundary_gpu , extboundary ,[ this % interp % N + 1 , 4 , this % nelem , this % nvar ]) do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 4 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) ! create unique tag for each side and each variable tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 ) msgCount = msgCount + 1 call MPI_IRECV ( extBoundary (:, s1 , e1 , ivar ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( boundary (:, s1 , e1 , ivar ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedScalar2D","tags":"","loc":"proc/mpiexchangeasync_mappedscalar2d.html"},{"title":"MappedDGGradient_MappedScalar2D – SELF","text":"public subroutine MappedDGGradient_MappedScalar2D(this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type(c_ptr), intent(inout) :: df Contents Source Code MappedDGGradient_MappedScalar2D Source Code subroutine MappedDGGradient_MappedScalar2D ( this , df ) !! implicit none class ( MappedScalar2D ), intent ( inout ) :: this type ( c_ptr ), intent ( inout ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:) type ( c_ptr ) :: fc call ContravariantWeight_2D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % jas_gpu , & this % interp % N , this % nvar , this % nelem ) ! From Vector divergence call c_f_pointer ( this % jas_gpu , f_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % nelem , 2 * this % nvar , 2 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_2d ( this % interp % dgMatrix_gpu , fc , df , & this % interp % N , this % interp % N , 2 * this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_2d ( this % interp % dgMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , 2 * this % nvar , this % nelem , this % blas_handle ) f_p => null () ! Do the boundary terms call NormalWeight_2D_gpu ( this % avgBoundary_gpu , & this % geometry % nhat % boundary_gpu , this % geometry % nscale % boundary_gpu , & this % boundarynormal_gpu , & this % interp % N , this % nvar , this % nelem ) call DG_BoundaryContribution_2D_gpu ( this % interp % bmatrix_gpu , this % interp % qweights_gpu , & this % boundarynormal_gpu , df , this % interp % N , 2 * this % nvar , this % nelem ) call JacobianWeight_2D_gpu ( df , this % geometry % J % interior_gpu , this % N , 2 * this % nVar , this % nelem ) endsubroutine MappedDGGradient_MappedScalar2D","tags":"","loc":"proc/mappeddggradient_mappedscalar2d.html"},{"title":"MappedGradient_MappedScalar2D – SELF","text":"public subroutine MappedGradient_MappedScalar2D(this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type(c_ptr), intent(out) :: df Contents Source Code MappedGradient_MappedScalar2D Source Code subroutine MappedGradient_MappedScalar2D ( this , df ) !! Calculates the gradient of a function using the strong form of the gradient !! in mapped coordinates. implicit none class ( MappedScalar2D ), intent ( inout ) :: this type ( c_ptr ), intent ( out ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:) type ( c_ptr ) :: fc call ContravariantWeight_2D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % jas_gpu , & this % interp % N , this % nvar , this % nelem ) ! From Vector divergence call c_f_pointer ( this % jas_gpu , f_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % nelem , 2 * this % nvar , 2 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_2d ( this % interp % dMatrix_gpu , fc , df , & this % interp % N , this % interp % N , 2 * this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_2d ( this % interp % dMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , 2 * this % nvar , this % nelem , this % blas_handle ) f_p => null () call JacobianWeight_2D_gpu ( df , this % geometry % J % interior_gpu , this % N , 2 * this % nVar , this % nelem ) endsubroutine MappedGradient_MappedScalar2D","tags":"","loc":"proc/mappedgradient_mappedscalar2d.html"},{"title":"SetInteriorFromEquation_MappedScalar2D – SELF","text":"public subroutine SetInteriorFromEquation_MappedScalar2D(this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time Contents Source Code SetInteriorFromEquation_MappedScalar2D Source Code subroutine SetInteriorFromEquation_MappedScalar2D ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedScalar2D ), intent ( inout ) :: this type ( SEMQuad ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , iEl , iVar real ( prec ) :: x real ( prec ) :: y do iVar = 1 , this % nVar do iEl = 1 , this % nElem do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , iEl , 1 , 2 ) this % interior ( i , j , iEl , iVar ) = & this % eqn ( iVar )% Evaluate (( / x , y , 0.0_prec , time / )) enddo enddo enddo enddo call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) endsubroutine SetInteriorFromEquation_MappedScalar2D","tags":"","loc":"proc/setinteriorfromequation_mappedscalar2d.html"},{"title":"SideExchange_MappedScalar2D – SELF","text":"public subroutine SideExchange_MappedScalar2D(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh Contents Source Code SideExchange_MappedScalar2D Source Code subroutine SideExchange_MappedScalar2D ( this , mesh ) implicit none class ( MappedScalar2D ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: offset offset = mesh % decomp % offsetElem ( mesh % decomp % rankId + 1 ) if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif ! Do the side exchange internal to this mpi process call SideExchange_2D_gpu ( this % extboundary_gpu , & this % boundary_gpu , mesh % sideinfo_gpu , mesh % decomp % elemToRank_gpu , & mesh % decomp % rankid , offset , this % interp % N , this % nvar , this % nelem ) if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call ApplyFlip_2D_gpu ( this % extboundary_gpu , mesh % sideInfo_gpu , & mesh % decomp % elemToRank_gpu , mesh % decomp % rankId , & offset , this % interp % N , this % nVar , this % nElem ) endif endsubroutine SideExchange_MappedScalar2D","tags":"","loc":"proc/sideexchange_mappedscalar2d.html"},{"title":"ContravariantWeight_2D_gpu – SELF","text":"interface public subroutine ContravariantWeight_2D_gpu(f, dsdx, jaf, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: f type(c_ptr), value :: dsdx type(c_ptr), value :: jaf integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel","tags":"","loc":"interface/contravariantweight_2d_gpu.html"},{"title":"NormalWeight_2D_gpu – SELF","text":"interface public subroutine NormalWeight_2D_gpu(fb, nhat, nscale, fbn, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: fb type(c_ptr), value :: nhat type(c_ptr), value :: nscale type(c_ptr), value :: fbn integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel","tags":"","loc":"interface/normalweight_2d_gpu.html"},{"title":"BoundaryFlux_DGModel3D – SELF","text":"public subroutine BoundaryFlux_DGModel3D(this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this Contents Source Code BoundaryFlux_DGModel3D Source Code subroutine BoundaryFlux_DGModel3D ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( DGModel3D ), intent ( inout ) :: this ! Local integer :: i , j , k , iel real ( prec ) :: sL ( 1 : this % nvar ), sR ( 1 : this % nvar ) real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ) :: nhat ( 1 : 3 ), nmag call gpuCheck ( hipMemcpy ( c_loc ( this % solution % boundary ), & this % solution % boundary_gpu , sizeof ( this % solution % boundary ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % extboundary ), & this % solution % extboundary_gpu , sizeof ( this % solution % extboundary ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % avgboundary ), & this % solutiongradient % avgboundary_gpu , sizeof ( this % solutiongradient % avgboundary ), & hipMemcpyDeviceToHost )) do iEl = 1 , this % solution % nElem do k = 1 , 6 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 ! Get the boundary normals on cell edges from the mesh geometry nhat = this % geometry % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) sL = this % solution % boundary ( i , j , k , iel , 1 : this % nvar ) ! interior solution sR = this % solution % extboundary ( i , j , k , iel , 1 : this % nvar ) ! exterior solution dsdx = this % solutiongradient % avgboundary ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) nmag = this % geometry % nScale % boundary ( i , j , k , iEl , 1 ) this % flux % boundaryNormal ( i , j , k , iEl , 1 : this % nvar ) = this % riemannflux3d ( sL , sR , dsdx , nhat ) * nmag enddo enddo enddo enddo call gpuCheck ( hipMemcpy ( this % flux % boundarynormal_gpu , & c_loc ( this % flux % boundarynormal ), & sizeof ( this % flux % boundarynormal ), & hipMemcpyHostToDevice )) endsubroutine BoundaryFlux_DGModel3D","tags":"","loc":"proc/boundaryflux_dgmodel3d.html"},{"title":"CalculateEntropy_DGModel3D – SELF","text":"public subroutine CalculateEntropy_DGModel3D(this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this Contents Source Code CalculateEntropy_DGModel3D Source Code subroutine CalculateEntropy_DGModel3D ( this ) implicit none class ( DGModel3D ), intent ( inout ) :: this ! Local integer :: iel , i , j , k , ierror real ( prec ) :: e , jac real ( prec ) :: s ( 1 : this % nvar ) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) e = 0.0_prec do iel = 1 , this % geometry % nelem do k = 1 , this % solution % interp % N + 1 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 jac = this % geometry % J % interior ( i , j , k , iel , 1 ) s = this % solution % interior ( i , j , k , iel , 1 : this % nvar ) e = e + this % entropy_func ( s ) * jac enddo enddo enddo enddo if ( this % mesh % decomp % mpiEnabled ) then call mpi_allreduce ( e , & this % entropy , & 1 , & this % mesh % decomp % mpiPrec , & MPI_SUM , & this % mesh % decomp % mpiComm , & iError ) else this % entropy = e endif endsubroutine CalculateEntropy_DGModel3D","tags":"","loc":"proc/calculateentropy_dgmodel3d.html"},{"title":"CalculateSolutionGradient_DGModel3D – SELF","text":"public subroutine CalculateSolutionGradient_DGModel3D(this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this Contents Source Code CalculateSolutionGradient_DGModel3D Source Code subroutine CalculateSolutionGradient_DGModel3D ( this ) implicit none class ( DGModel3D ), intent ( inout ) :: this call this % solution % AverageSides () call this % solution % MappedDGGradient ( this % solutionGradient % interior_gpu ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp () ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh ) endsubroutine CalculateSolutionGradient_DGModel3D","tags":"","loc":"proc/calculatesolutiongradient_dgmodel3d.html"},{"title":"CalculateTendency_DGModel3D – SELF","text":"public subroutine CalculateTendency_DGModel3D(this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this Contents Source Code CalculateTendency_DGModel3D Source Code subroutine CalculateTendency_DGModel3D ( this ) implicit none class ( DGModel3D ), intent ( inout ) :: this ! Local integer :: ndof call this % solution % BoundaryInterp () call this % solution % SideExchange ( this % mesh ) call this % PreTendency () ! User-supplied call this % SetBoundaryCondition () ! User-supplied if ( this % gradient_enabled ) then call this % solution % AverageSides () call this % CalculateSolutionGradient () call this % SetGradientBoundaryCondition () ! User-supplied call this % solutionGradient % AverageSides () endif call this % SourceMethod () ! User supplied call this % BoundaryFlux () ! User supplied call this % FluxMethod () ! User supplied call this % flux % MappedDGDivergence ( this % fluxDivergence % interior_gpu ) ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call CalculateDSDt_gpu ( this % fluxDivergence % interior_gpu , this % source % interior_gpu , & this % dsdt % interior_gpu , ndof ) endsubroutine CalculateTendency_DGModel3D","tags":"","loc":"proc/calculatetendency_dgmodel3d.html"},{"title":"UpdateGRK2_DGModel3D – SELF","text":"public subroutine UpdateGRK2_DGModel3D(this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK2_DGModel3D Source Code subroutine UpdateGRK2_DGModel3D ( this , m ) implicit none class ( DGModel3D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk2_a ( m ), rk2_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK2_DGModel3D","tags":"","loc":"proc/updategrk2_dgmodel3d.html"},{"title":"UpdateGRK3_DGModel3D – SELF","text":"public subroutine UpdateGRK3_DGModel3D(this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK3_DGModel3D Source Code subroutine UpdateGRK3_DGModel3D ( this , m ) implicit none class ( DGModel3D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk3_a ( m ), rk3_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK3_DGModel3D","tags":"","loc":"proc/updategrk3_dgmodel3d.html"},{"title":"UpdateGRK4_DGModel3D – SELF","text":"public subroutine UpdateGRK4_DGModel3D(this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m Contents Source Code UpdateGRK4_DGModel3D Source Code subroutine UpdateGRK4_DGModel3D ( this , m ) implicit none class ( DGModel3D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk4_a ( m ), rk4_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK4_DGModel3D","tags":"","loc":"proc/updategrk4_dgmodel3d.html"},{"title":"UpdateSolution_DGModel3D – SELF","text":"public subroutine UpdateSolution_DGModel3D(this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt Contents Source Code UpdateSolution_DGModel3D Source Code subroutine UpdateSolution_DGModel3D ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) implicit none class ( DGModel3D ), intent ( inout ) :: this real ( prec ), optional , intent ( in ) :: dt ! Local real ( prec ) :: dtLoc integer :: ndof if ( present ( dt )) then dtLoc = dt else dtLoc = this % dt endif ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateSolution_gpu ( this % solution % interior_gpu , this % dsdt % interior_gpu , dtLoc , ndof ) endsubroutine UpdateSolution_DGModel3D","tags":"","loc":"proc/updatesolution_dgmodel3d.html"},{"title":"fluxmethod_DGModel3D – SELF","text":"public subroutine fluxmethod_DGModel3D(this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this Contents Source Code fluxmethod_DGModel3D Source Code subroutine fluxmethod_DGModel3D ( this ) implicit none class ( DGModel3D ), intent ( inout ) :: this ! Local integer :: iel integer :: i , j , k real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 3 ) do iel = 1 , this % mesh % nelem do k = 1 , this % solution % interp % N + 1 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , k , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) this % flux % interior ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) = this % flux3d ( s , dsdx ) enddo enddo enddo enddo call gpuCheck ( hipMemcpy ( this % flux % interior_gpu , & c_loc ( this % flux % interior ), & sizeof ( this % flux % interior ), & hipMemcpyHostToDevice )) endsubroutine fluxmethod_DGModel3D","tags":"","loc":"proc/fluxmethod_dgmodel3d.html"},{"title":"setboundarycondition_DGModel3D – SELF","text":"public subroutine setboundarycondition_DGModel3D(this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this Contents Source Code setboundarycondition_DGModel3D Source Code subroutine setboundarycondition_DGModel3D ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel3D ), intent ( inout ) :: this ! local integer :: i , iEl , j , k , e2 , bcid real ( prec ) :: nhat ( 1 : 3 ), x ( 1 : 3 ) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % boundary ), & this % solution % boundary_gpu , sizeof ( this % solution % boundary ), & hipMemcpyDeviceToHost )) do iEl = 1 , this % solution % nElem ! Loop over all elements do k = 1 , 6 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , k , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , k , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do j = 1 , this % solution % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points x = this % geometry % x % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solution % extBoundary ( i , j , k , iEl , 1 : this % nvar ) = & this % hbc3d_Prescribed ( x , this % t ) enddo enddo elseif ( bcid == SELF_BC_RADIATION ) then do j = 1 , this % solution % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solution % extBoundary ( i , j , k , iEl , 1 : this % nvar ) = & this % hbc3d_Radiation ( this % solution % boundary ( i , j , k , iEl , 1 : this % nvar ), nhat ) enddo enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do j = 1 , this % solution % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solution % extBoundary ( i , j , k , iEl , 1 : this % nvar ) = & this % hbc3d_NoNormalFlow ( this % solution % boundary ( i , j , k , iEl , 1 : this % nvar ), nhat ) enddo enddo endif endif enddo enddo call gpuCheck ( hipMemcpy ( this % solution % extBoundary_gpu , & c_loc ( this % solution % extBoundary ), & sizeof ( this % solution % extBoundary ), & hipMemcpyHostToDevice )) endsubroutine setboundarycondition_DGModel3D","tags":"","loc":"proc/setboundarycondition_dgmodel3d.html"},{"title":"setgradientboundarycondition_DGModel3D – SELF","text":"public subroutine setgradientboundarycondition_DGModel3D(this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this Contents Source Code setgradientboundarycondition_DGModel3D Source Code subroutine setgradientboundarycondition_DGModel3D ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel3D ), intent ( inout ) :: this ! local integer :: i , iEl , j , k , e2 , bcid real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ) :: nhat ( 1 : 3 ), x ( 1 : 3 ) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % boundary ), & this % solutiongradient % boundary_gpu , sizeof ( this % solutiongradient % boundary ), & hipMemcpyDeviceToHost )) do iEl = 1 , this % solution % nElem ! Loop over all elements do k = 1 , 6 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , k , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , k , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do j = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points x = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solutiongradient % extBoundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) = & this % pbc3d_Prescribed ( x , this % t ) enddo enddo elseif ( bcid == SELF_BC_RADIATION ) then do j = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) dsdx = this % solutiongradient % boundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) this % solutiongradient % extBoundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) = & this % pbc3d_Radiation ( dsdx , nhat ) enddo enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do j = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) dsdx = this % solutiongradient % boundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) this % solutiongradient % extBoundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) = & this % pbc3d_NoNormalFlow ( dsdx , nhat ) enddo enddo endif endif enddo enddo call gpuCheck ( hipMemcpy ( this % solutiongradient % extBoundary_gpu , & c_loc ( this % solutiongradient % extBoundary ), & sizeof ( this % solutiongradient % extBoundary ), & hipMemcpyHostToDevice )) endsubroutine setgradientboundarycondition_DGModel3D","tags":"","loc":"proc/setgradientboundarycondition_dgmodel3d.html"},{"title":"sourcemethod_DGModel3D – SELF","text":"public subroutine sourcemethod_DGModel3D(this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this Contents Source Code sourcemethod_DGModel3D Source Code subroutine sourcemethod_DGModel3D ( this ) implicit none class ( DGModel3D ), intent ( inout ) :: this ! Local integer :: i , j , k , iel real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 3 ) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % interior ), & this % solutiongradient % interior_gpu , sizeof ( this % solutiongradient % interior ), & hipMemcpyDeviceToHost )) do iel = 1 , this % mesh % nelem do k = 1 , this % solution % interp % N + 1 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , k , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) this % source % interior ( i , j , k , iel , 1 : this % nvar ) = this % source3d ( s , dsdx ) enddo enddo enddo enddo call gpuCheck ( hipMemcpy ( this % source % interior_gpu , & c_loc ( this % source % interior ), & sizeof ( this % source % interior ), & hipMemcpyHostToDevice )) endsubroutine sourcemethod_DGModel3D","tags":"","loc":"proc/sourcemethod_dgmodel3d.html"},{"title":"MPIExchangeAsync_MappedVector2D – SELF","text":"public subroutine MPIExchangeAsync_MappedVector2D(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh Contents Source Code MPIExchangeAsync_MappedVector2D Source Code subroutine MPIExchangeAsync_MappedVector2D ( this , mesh ) implicit none class ( MappedVector2D ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar , idir integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount real ( prec ), pointer :: boundary (:,:,:,:,:) real ( prec ), pointer :: extboundary (:,:,:,:,:) msgCount = 0 call c_f_pointer ( this % boundary_gpu , boundary ,[ this % interp % N + 1 , 4 , this % nelem , this % nvar , 2 ]) call c_f_pointer ( this % extboundary_gpu , extboundary ,[ this % interp % N + 1 , 4 , this % nelem , this % nvar , 2 ]) do idir = 1 , 2 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 4 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) ! create unique tag for each side and each variable tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 + this % nvar * ( idir - 1 )) msgCount = msgCount + 1 call MPI_IRECV ( extBoundary (:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( boundary (:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedVector2D","tags":"","loc":"proc/mpiexchangeasync_mappedvector2d.html"},{"title":"MappedDGDivergence_MappedVector2D – SELF","text":"public subroutine MappedDGDivergence_MappedVector2D(this, df) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type(c_ptr), intent(out) :: df Contents Source Code MappedDGDivergence_MappedVector2D Source Code subroutine MappedDGDivergence_MappedVector2D ( this , df ) implicit none class ( MappedVector2D ), intent ( inout ) :: this type ( c_ptr ), intent ( out ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:) type ( c_ptr ) :: fc ! Contravariant projection call ContravariantProjection_2D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % interp % N , this % nvar , this % nelem ) call c_f_pointer ( this % interior_gpu , f_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 2 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_2d ( this % interp % dgMatrix_gpu , fc , df , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_2d ( this % interp % dgMatrix_gpu , fc , df , 1.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) f_p => null () ! Boundary terms call DG_BoundaryContribution_2D_gpu ( this % interp % bmatrix_gpu , this % interp % qweights_gpu , & this % boundarynormal_gpu , df , this % interp % N , this % nvar , this % nelem ) call JacobianWeight_2D_gpu ( df , this % geometry % J % interior_gpu , this % interp % N , this % nVar , this % nelem ) endsubroutine MappedDGDivergence_MappedVector2D","tags":"","loc":"proc/mappeddgdivergence_mappedvector2d.html"},{"title":"MappedDivergence_MappedVector2D – SELF","text":"public subroutine MappedDivergence_MappedVector2D(this, df) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type(c_ptr), intent(out) :: df Contents Source Code MappedDivergence_MappedVector2D Source Code subroutine MappedDivergence_MappedVector2D ( this , df ) implicit none class ( MappedVector2D ), intent ( inout ) :: this type ( c_ptr ), intent ( out ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:) type ( c_ptr ) :: fc ! Contravariant projection call ContravariantProjection_2D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % interp % N , this % nvar , this % nelem ) call c_f_pointer ( this % interior_gpu , f_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 2 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_2d ( this % interp % dMatrix_gpu , fc , df , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_2d ( this % interp % dMatrix_gpu , fc , df , 1.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) f_p => null () call JacobianWeight_2D_gpu ( df , this % geometry % J % interior_gpu , this % interp % N , this % nVar , this % nelem ) endsubroutine MappedDivergence_MappedVector2D","tags":"","loc":"proc/mappeddivergence_mappedvector2d.html"},{"title":"SetInteriorFromEquation_MappedVector2D – SELF","text":"public subroutine SetInteriorFromEquation_MappedVector2D(this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time Contents Source Code SetInteriorFromEquation_MappedVector2D Source Code subroutine SetInteriorFromEquation_MappedVector2D ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedVector2D ), intent ( inout ) :: this type ( SEMQuad ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , iEl , iVar real ( prec ) :: x real ( prec ) :: y do iVar = 1 , this % nVar do iEl = 1 , this % nElem do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , iEl , 1 , 2 ) this % interior ( i , j , iEl , iVar , 1 ) = & this % eqn ( 1 + 2 * ( iVar - 1 ))% Evaluate (( / x , y , 0.0_prec , time / )) this % interior ( i , j , iEl , iVar , 2 ) = & this % eqn ( 2 + 2 * ( iVar - 1 ))% Evaluate (( / x , y , 0.0_prec , time / )) enddo enddo enddo enddo call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) endsubroutine SetInteriorFromEquation_MappedVector2D","tags":"","loc":"proc/setinteriorfromequation_mappedvector2d.html"},{"title":"SideExchange_MappedVector2D – SELF","text":"public subroutine SideExchange_MappedVector2D(this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh Contents Source Code SideExchange_MappedVector2D Source Code subroutine SideExchange_MappedVector2D ( this , mesh ) implicit none class ( MappedVector2D ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: e1 , e2 , s1 , s2 , e2Global integer :: flip , bcid integer :: i1 , i2 , ivar , idir integer :: neighborRank integer :: offset offset = mesh % decomp % offsetElem ( mesh % decomp % rankid + 1 ) if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif ! Do the side exchange internal to this mpi process call SideExchange_2D_gpu ( this % extboundary_gpu , & this % boundary_gpu , mesh % sideinfo_gpu , mesh % decomp % elemToRank_gpu , & mesh % decomp % rankid , offset , this % interp % N , 2 * this % nvar , this % nelem ) if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call ApplyFlip_2D_gpu ( this % extboundary_gpu , mesh % sideInfo_gpu , & mesh % decomp % elemToRank_gpu , mesh % decomp % rankId , & offset , this % interp % N , 2 * this % nVar , this % nElem ) endif endsubroutine SideExchange_MappedVector2D","tags":"","loc":"proc/sideexchange_mappedvector2d.html"},{"title":"ContravariantProjection_2D_gpu – SELF","text":"interface public subroutine ContravariantProjection_2D_gpu(f, dsdx, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: f type(c_ptr), value :: dsdx integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel","tags":"","loc":"interface/contravariantprojection_2d_gpu.html"},{"title":"hipblasCheck – SELF","text":"public subroutine hipblasCheck(hipblasError_t) Uses SELF_GPU_enums Arguments Type Intent Optional Attributes Name integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasError_t Contents Source Code hipblasCheck Source Code subroutine hipblasCheck ( hipblasError_t ) use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasError_t if ( hipblasError_t /= HIPBLAS_STATUS_SUCCESS ) then write ( * , * ) \"GPUBLAS ERROR: Error code = \" , hipblasError_t call exit ( hipblasError_t ) endif endsubroutine hipblasCheck","tags":"","loc":"proc/hipblascheck.html"},{"title":"self_blas_matrixop_1d – SELF","text":"public subroutine self_blas_matrixop_1d(A, f, Af, opArows, opAcols, bcols, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A type(c_ptr), intent(in) :: f type(c_ptr), intent(inout) :: Af integer, intent(in) :: opArows integer, intent(in) :: opAcols integer, intent(in) :: bcols type(c_ptr), intent(in) :: handle Contents Source Code self_blas_matrixop_1d Source Code subroutine self_blas_matrixop_1d ( A , f , Af , opArows , opAcols , bcols , handle ) type ( c_ptr ), intent ( in ) :: A type ( c_ptr ), intent ( in ) :: f type ( c_ptr ), intent ( inout ) :: Af integer , intent ( in ) :: opArows , opAcols , bcols type ( c_ptr ), intent ( in ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n integer ( c_int ) :: k real ( c_prec ) :: alpha integer ( c_int ) :: lda integer ( c_int ) :: ldb integer ( c_int ) :: ldc real ( c_prec ) :: beta m = opArows ! number of rows of A&#94;T n = bcols ! number of columns of B k = opAcols ! number of columns of A&#94;T alpha = 1.0_c_prec lda = k ! leading dimension of A (matrix) ldb = k ! leading dimension of B (f) ldc = m ! leading dimension of C (Af) beta = 0.0_c_prec call hipblasCheck ( hipblasgemm ( handle , & HIPBLAS_OP_T , HIPBLAS_OP_N , & m , n , k , alpha , & A , lda , & f , ldb , & beta , & Af , ldc )) endsubroutine self_blas_matrixop_1d","tags":"","loc":"proc/self_blas_matrixop_1d.html"},{"title":"self_blas_matrixop_dim1_2d – SELF","text":"public subroutine self_blas_matrixop_dim1_2d(A, f, Af, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A type(c_ptr), intent(in) :: f type(c_ptr), intent(inout) :: Af integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(in) :: handle Contents Source Code self_blas_matrixop_dim1_2d Source Code subroutine self_blas_matrixop_dim1_2d ( A , f , Af , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A type ( c_ptr ), intent ( in ) :: f type ( c_ptr ), intent ( inout ) :: Af integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( in ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n integer ( c_int ) :: k real ( c_prec ) :: alpha integer ( c_int ) :: lda integer ( c_int ) :: ldb integer ( c_int ) :: ldc real ( c_prec ) :: beta m = targetdegree + 1 ! number of rows of A&#94;T n = nvars * nelems * ( controldegree + 1 ) ! number of columns of B k = controldegree + 1 ! number of columns of A&#94;T alpha = 1.0_c_prec lda = k ! leading dimension of A (interpolation/derivative matrix) ldb = k ! leading dimension of B (f) ldc = m ! leading dimension of C (fTarget) beta = 0.0_c_prec ! First pass interpolates in the first quadrature dimension call hipblasCheck ( hipblasgemm ( handle , & HIPBLAS_OP_T , HIPBLAS_OP_N , & m , n , k , alpha , & A , lda , & f , ldb , beta , & Af , ldc )) endsubroutine self_blas_matrixop_dim1_2d","tags":"","loc":"proc/self_blas_matrixop_dim1_2d.html"},{"title":"self_blas_matrixop_dim1_3d – SELF","text":"public subroutine self_blas_matrixop_dim1_3d(A, f, Af, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A type(c_ptr), intent(in) :: f type(c_ptr), intent(inout) :: Af integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(in) :: handle Contents Source Code self_blas_matrixop_dim1_3d Source Code subroutine self_blas_matrixop_dim1_3d ( A , f , Af , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A type ( c_ptr ), intent ( in ) :: f type ( c_ptr ), intent ( inout ) :: Af integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( in ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n integer ( c_int ) :: k real ( c_prec ) :: alpha integer ( c_int ) :: lda integer ( c_int ) :: ldb integer ( c_int ) :: ldc real ( c_prec ) :: beta m = targetdegree + 1 ! number of rows of A&#94;T n = nvars * nelems * ( controldegree + 1 ) * ( controldegree + 1 ) ! nreal(prec),pointerumber of columns of B k = controldegree + 1 ! number of columns of A&#94;T alpha = 1.0_c_prec lda = k ! leading dimension of A (interoplation matrix) ldb = k ! leading dimension of B (f) ldc = m ! leading dimension of C (fTarget) beta = 0.0_c_prec ! First pass interpolates in the first quadrature dimension call hipblasCheck ( hipblasgemm ( handle , & HIPBLAS_OP_T , HIPBLAS_OP_N , & m , n , k , alpha , & A , lda , & f , ldb , beta , & Af , ldc )) endsubroutine self_blas_matrixop_dim1_3d","tags":"","loc":"proc/self_blas_matrixop_dim1_3d.html"},{"title":"self_blas_matrixop_dim2_2d – SELF","text":"public subroutine self_blas_matrixop_dim2_2d(A, f, Af, beta, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A type(c_ptr), intent(in) :: f type(c_ptr), intent(inout) :: Af real(kind=c_prec), intent(in) :: beta integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(in) :: handle Contents Source Code self_blas_matrixop_dim2_2d Source Code subroutine self_blas_matrixop_dim2_2d ( A , f , Af , beta , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A type ( c_ptr ), intent ( in ) :: f type ( c_ptr ), intent ( inout ) :: Af real ( c_prec ), intent ( in ) :: beta integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( in ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n real ( c_prec ) :: alpha integer ( c_int ) :: lda integer :: i integer ( c_int64_t ) :: strideA integer ( c_int ) :: incx integer ( c_int64_t ) :: stridex integer ( c_int ) :: incy integer ( c_int64_t ) :: stridey integer ( c_int ) :: batchCount real ( prec ), pointer :: f_p (:,:,:,:) real ( prec ), pointer :: Af_p (:,:,:,:) m = controldegree + 1 ! number of rows of A n = targetdegree + 1 ! number of columns of A alpha = 1.0_c_prec lda = m ! leading dimension of A strideA = 0 ! stride for the batches of A (no stride) incx = targetdegree + 1 ! stridex = ( controldegree + 1 ) * ( targetdegree + 1 ) incy = targetdegree + 1 stridey = ( targetdegree + 1 ) * ( targetdegree + 1 ) batchCount = nvars * nelems call c_f_pointer ( f , f_p ,[ targetdegree + 1 , controldegree + 1 , nelems , nvars ]) call c_f_pointer ( Af , Af_p ,[ targetdegree + 1 , targetdegree + 1 , nelems , nvars ]) do i = 0 , targetdegree call hipblasCheck ( hipblasgemvStridedBatched ( handle , & HIPBLAS_OP_T , & m , n , alpha , & A , lda , strideA , & c_loc ( f_p ( 1 + i , 1 , 1 , 1 )), incx , stridex , beta , & c_loc ( Af_p ( 1 + i , 1 , 1 , 1 )), incy , stridey , batchCount )) enddo endsubroutine self_blas_matrixop_dim2_2d","tags":"","loc":"proc/self_blas_matrixop_dim2_2d.html"},{"title":"self_blas_matrixop_dim2_3d – SELF","text":"public subroutine self_blas_matrixop_dim2_3d(A, f, Af, beta, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A type(c_ptr), intent(in) :: f type(c_ptr), intent(inout) :: Af real(kind=c_prec), intent(in) :: beta integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(in) :: handle Contents Source Code self_blas_matrixop_dim2_3d Source Code subroutine self_blas_matrixop_dim2_3d ( A , f , Af , beta , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A type ( c_ptr ), intent ( in ) :: f type ( c_ptr ), intent ( inout ) :: Af real ( c_prec ), intent ( in ) :: beta integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( in ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n real ( c_prec ) :: alpha integer ( c_int ) :: lda integer :: i integer ( c_int64_t ) :: strideA integer ( c_int ) :: incx integer ( c_int64_t ) :: stridex integer ( c_int ) :: incy integer ( c_int64_t ) :: stridey integer ( c_int ) :: batchCount real ( prec ), pointer :: f_p (:,:,:,:,:) real ( prec ), pointer :: Af_p (:,:,:,:,:) m = controldegree + 1 ! number of rows of A n = targetdegree + 1 ! number of columns of A alpha = 1.0_c_prec lda = m ! leading dimension of A strideA = 0 ! stride for the batches of A (no stride) incx = targetdegree + 1 ! stridex = ( controldegree + 1 ) * ( targetdegree + 1 ) !beta = 0.0_c_prec incy = targetdegree + 1 stridey = ( targetdegree + 1 ) * ( targetdegree + 1 ) batchCount = ( controldegree + 1 ) * nvars * nelems call c_f_pointer ( f , f_p ,[ targetdegree + 1 , controldegree + 1 , controldegree + 1 , nelems , nvars ]) call c_f_pointer ( Af , Af_p ,[ targetdegree + 1 , targetdegree + 1 , controldegree + 1 , nelems , nvars ]) do i = 0 , targetdegree call hipblasCheck ( hipblasgemvStridedBatched ( handle , & HIPBLAS_OP_T , & m , n , alpha , & A , lda , strideA , & c_loc ( f_p ( 1 + i , 1 , 1 , 1 , 1 )), incx , stridex , beta , & c_loc ( Af_p ( 1 + i , 1 , 1 , 1 , 1 )), incy , stridey , batchCount )) enddo endsubroutine self_blas_matrixop_dim2_3d","tags":"","loc":"proc/self_blas_matrixop_dim2_3d.html"},{"title":"self_blas_matrixop_dim3_3d – SELF","text":"public subroutine self_blas_matrixop_dim3_3d(A, f, Af, beta, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A type(c_ptr), intent(in) :: f type(c_ptr), intent(inout) :: Af real(kind=c_prec), intent(in) :: beta integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(in) :: handle Contents Source Code self_blas_matrixop_dim3_3d Source Code subroutine self_blas_matrixop_dim3_3d ( A , f , Af , beta , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A type ( c_ptr ), intent ( in ) :: f type ( c_ptr ), intent ( inout ) :: Af real ( c_prec ), intent ( in ) :: beta integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( in ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n real ( c_prec ) :: alpha integer ( c_int ) :: lda integer :: i , j integer ( c_int64_t ) :: strideA integer ( c_int ) :: incx integer ( c_int64_t ) :: stridex integer ( c_int ) :: incy integer ( c_int64_t ) :: stridey integer ( c_int ) :: batchCount real ( prec ), pointer :: f_p (:,:,:,:,:) real ( prec ), pointer :: Af_p (:,:,:,:,:) m = controldegree + 1 ! number of rows of A n = targetdegree + 1 ! number of columns of A alpha = 1.0_c_prec lda = m ! leading dimension of A strideA = 0 ! stride for the batches of A (no stride) incx = ( targetdegree + 1 ) * ( targetdegree + 1 ) ! stridex = ( controldegree + 1 ) * ( targetdegree + 1 ) * ( targetdegree + 1 ) incy = ( targetdegree + 1 ) * ( targetdegree + 1 ) stridey = ( targetdegree + 1 ) * ( targetdegree + 1 ) * ( targetdegree + 1 ) batchCount = nvars * nelems call c_f_pointer ( f , f_p ,[ targetdegree + 1 , targetdegree + 1 , controldegree + 1 , nelems , nvars ]) call c_f_pointer ( Af , Af_p ,[ targetdegree + 1 , targetdegree + 1 , targetdegree + 1 , nelems , nvars ]) do j = 0 , targetdegree do i = 0 , targetdegree call hipblasCheck ( hipblasgemvStridedBatched ( handle , & HIPBLAS_OP_T , & m , n , alpha , & A , lda , strideA , & c_loc ( f_p ( 1 + i , 1 + j , 1 , 1 , 1 )), incx , stridex , beta , & c_loc ( Af_p ( 1 + i , 1 + j , 1 , 1 , 1 )), incy , stridey , batchCount )) enddo enddo endsubroutine self_blas_matrixop_dim3_3d","tags":"","loc":"proc/self_blas_matrixop_dim3_3d.html"},{"title":"hipblasCreate – SELF","text":"public interface hipblasCreate Contents Functions hipblasCreate_ Functions public function hipblasCreate_(handle) bind(c,name=\"cublasCreate_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: handle Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS))","tags":"","loc":"interface/hipblascreate.html"},{"title":"hipblasDestroy – SELF","text":"public interface hipblasDestroy Contents Functions hipblasDestroy_ Functions public function hipblasDestroy_(handle) bind(c,name=\"cublasDestroy_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS))","tags":"","loc":"interface/hipblasdestroy.html"},{"title":"hipblasDgemm – SELF","text":"public interface hipblasDgemm Contents Functions hipblasDgemm_ Functions public function hipblasDgemm_(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc) bind(c,name=\"cublasDgemm_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: transa integer(kind=kind(HIPBLAS_OP_N)), value :: transb integer(kind=c_int), value :: m integer(kind=c_int), value :: n integer(kind=c_int), value :: k real(kind=c_double) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda type(c_ptr), value :: B integer(kind=c_int), value :: ldb real(kind=c_double) :: beta type(c_ptr), value :: C integer(kind=c_int), value :: ldc Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS))","tags":"","loc":"interface/hipblasdgemm.html"},{"title":"hipblasDgemvStridedBatched – SELF","text":"public interface hipblasDgemvStridedBatched Contents Functions hipblasDgemvStridedBatched_ Functions public function hipblasDgemvStridedBatched_(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount) bind(c,name=\"cublasDgemvStridedBatched\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: trans integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda integer(kind=c_int64_t), value :: strideA type(c_ptr), value :: x integer(kind=c_int), value :: incx integer(kind=c_int64_t), value :: stridex real(kind=c_double) :: beta type(c_ptr), value :: y integer(kind=c_int), value :: incy integer(kind=c_int64_t), value :: stridey integer(kind=c_int), value :: batchCount Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS))","tags":"","loc":"interface/hipblasdgemvstridedbatched.html"},{"title":"hipblasSgemm – SELF","text":"public interface hipblasSgemm Contents Functions hipblasSgemm_ Functions public function hipblasSgemm_(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc) bind(c,name=\"cublasSgemm_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: transa integer(kind=kind(HIPBLAS_OP_N)), value :: transb integer(kind=c_int), value :: m integer(kind=c_int), value :: n integer(kind=c_int), value :: k real(kind=c_float) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda type(c_ptr), value :: B integer(kind=c_int), value :: ldb real(kind=c_float) :: beta type(c_ptr), value :: C integer(kind=c_int), value :: ldc Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS))","tags":"","loc":"interface/hipblassgemm.html"},{"title":"hipblasSgemvStridedBatched – SELF","text":"public interface hipblasSgemvStridedBatched Contents Functions hipblasSgemvStridedBatched_ Functions public function hipblasSgemvStridedBatched_(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount) bind(c,name=\"cublasSgemvStridedBatched\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: trans integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_float) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda integer(kind=c_int64_t), value :: strideA type(c_ptr), value :: x integer(kind=c_int), value :: incx integer(kind=c_int64_t), value :: stridex real(kind=c_float) :: beta type(c_ptr), value :: y integer(kind=c_int), value :: incy integer(kind=c_int64_t), value :: stridey integer(kind=c_int), value :: batchCount Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS))","tags":"","loc":"interface/hipblassgemvstridedbatched.html"},{"title":"Free_Tensor2D – SELF","text":"public subroutine Free_Tensor2D(this) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: this Contents Source Code Free_Tensor2D Source Code subroutine Free_Tensor2D ( this ) implicit none class ( Tensor2D ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Tensor2D","tags":"","loc":"proc/free_tensor2d.html"},{"title":"Init_Tensor2D – SELF","text":"public subroutine Init_Tensor2D(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Tensor2D Source Code subroutine Init_Tensor2D ( this , interp , nVar , nElem ) implicit none class ( Tensor2D ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 2 , 1 : 2 ), & this % boundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 , 1 : 2 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 , 1 : 2 )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 4 * nVar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 4 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call hipblasCheck ( hipblasCreate ( this % blas_handle )) call this % UpdateDevice () endsubroutine Init_Tensor2D","tags":"","loc":"proc/init_tensor2d.html"},{"title":"UpdateDevice_Tensor2D – SELF","text":"public subroutine UpdateDevice_Tensor2D(this) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: this Contents Source Code UpdateDevice_Tensor2D Source Code subroutine UpdateDevice_Tensor2D ( this ) implicit none class ( Tensor2D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundary_gpu , c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Tensor2D","tags":"","loc":"proc/updatedevice_tensor2d.html"},{"title":"UpdateHost_Tensor2D – SELF","text":"public subroutine UpdateHost_Tensor2D(this) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: this Contents Source Code UpdateHost_Tensor2D Source Code subroutine UpdateHost_Tensor2D ( this ) implicit none class ( Tensor2D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), this % interior_gpu , sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), this % extboundary_gpu , sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Tensor2D","tags":"","loc":"proc/updatehost_tensor2d.html"},{"title":"Free_Lagrange – SELF","text":"public subroutine Free_Lagrange(this) Frees all memory (host and device) associated with an instance of the Lagrange class Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: this Lagrange class instance Contents Source Code Free_Lagrange Source Code subroutine Free_Lagrange ( this ) !! Frees all memory (host and device) associated with an instance of the Lagrange class implicit none class ( Lagrange ), intent ( inout ) :: this !! Lagrange class instance deallocate ( this % controlPoints ) deallocate ( this % targetPoints ) deallocate ( this % bWeights ) deallocate ( this % qWeights ) deallocate ( this % iMatrix ) deallocate ( this % dMatrix ) deallocate ( this % dgMatrix ) deallocate ( this % bMatrix ) call gpuCheck ( hipFree ( this % iMatrix_gpu )) call gpuCheck ( hipFree ( this % dMatrix_gpu )) call gpuCheck ( hipFree ( this % dgMatrix_gpu )) call gpuCheck ( hipFree ( this % bMatrix_gpu )) call gpuCheck ( hipFree ( this % qWeights_gpu )) endsubroutine Free_Lagrange","tags":"","loc":"proc/free_lagrange~2.html"},{"title":"Init_Lagrange – SELF","text":"public subroutine Init_Lagrange(this, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange class\nOn output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(out) :: this Lagrange class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) Contents Source Code Init_Lagrange Source Code subroutine Init_Lagrange ( this , N , controlNodeType , M , targetNodeType ) !! Initialize an instance of the Lagrange class !! On output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of !! control points, number of target points, and the types for the control and target nodes. !! If a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. implicit none class ( Lagrange ), intent ( out ) :: this !! Lagrange class instance integer , intent ( in ) :: N !! The number of control points for interpolant integer , intent ( in ) :: M !! The number of target points for the interpolant integer , intent ( in ) :: controlNodeType !! The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) integer , intent ( in ) :: targetNodeType !! The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) ! -------! ! Local real ( prec ) :: q ( 0 : M ) if (. not . GPUAvailable ()) then print * , __ FILE__ , ':' , __ LINE__ , ' : Error : Attempt to use GPU extension, but GPU is not available.' stop 1 endif this % N = N this % M = M this % controlNodeType = controlNodeType this % targetNodeType = targetNodeType allocate ( this % controlPoints ( 1 : N + 1 ), & this % targetPoints ( 1 : M + 1 ), & this % bWeights ( 1 : N + 1 ), & this % qWeights ( 1 : N + 1 ), & this % iMatrix ( 1 : N + 1 , 1 : M + 1 ), & this % dMatrix ( 1 : N + 1 , 1 : N + 1 ), & this % dgMatrix ( 1 : N + 1 , 1 : N + 1 ), & this % bMatrix ( 1 : N + 1 , 1 : 2 )) if ( controlNodeType == GAUSS . or . controlNodeType == GAUSS_LOBATTO ) then call LegendreQuadrature ( N , & this % controlPoints , & this % qWeights , & controlNodeType ) elseif ( controlNodeType == CHEBYSHEV_GAUSS . or . controlNodeType == CHEBYSHEV_GAUSS_LOBATTO ) then call ChebyshevQuadrature ( N , & this % controlPoints , & this % qWeights , & controlNodeType ) elseif ( controlNodeType == UNIFORM ) then this % controlPoints = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , N ) this % qWeights = 2.0_prec / real ( N , prec ) endif ! Target Points if ( targetNodeType == GAUSS . or . targetNodeType == GAUSS_LOBATTO ) then call LegendreQuadrature ( M , & this % targetPoints , & q , & targetNodeType ) elseif ( targetNodeType == UNIFORM ) then this % targetPoints = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , M ) endif call this % CalculateBarycentricWeights () call this % CalculateInterpolationMatrix () call this % CalculateDerivativeMatrix () this % bMatrix ( 1 : N + 1 , 1 ) = this % CalculateLagrangePolynomials ( - 1.0_prec ) this % bMatrix ( 1 : N + 1 , 2 ) = this % CalculateLagrangePolynomials ( 1.0_prec ) print * , \"Lagrange malloc\" call gpuCheck ( hipMalloc ( this % iMatrix_gpu , sizeof ( this % iMatrix ))) call gpuCheck ( hipMalloc ( this % dMatrix_gpu , sizeof ( this % dMatrix ))) call gpuCheck ( hipMalloc ( this % dgMatrix_gpu , sizeof ( this % dgMatrix ))) call gpuCheck ( hipMalloc ( this % bMatrix_gpu , sizeof ( this % bMatrix ))) call gpuCheck ( hipMalloc ( this % qWeights_gpu , sizeof ( this % qWeights ))) print * , \"Lagrange memcpy\" print * , c_loc ( this % iMatrix ) call gpuCheck ( hipMemcpy ( this % iMatrix_gpu , & c_loc ( this % iMatrix ), & sizeof ( this % iMatrix ), & hipMemcpyHostToDevice )) print * , \"Lagrange memcpy\" call gpuCheck ( hipMemcpy ( this % dMatrix_gpu , & c_loc ( this % dMatrix ), & sizeof ( this % dMatrix ), & hipMemcpyHostToDevice )) print * , \"Lagrange memcpy\" call gpuCheck ( hipMemcpy ( this % dgMatrix_gpu , & c_loc ( this % dgMatrix ), & sizeof ( this % dgMatrix ), & hipMemcpyHostToDevice )) print * , \"Lagrange memcpy\" call gpuCheck ( hipMemcpy ( this % bMatrix_gpu , & c_loc ( this % bMatrix ), & sizeof ( this % bMatrix ), & hipMemcpyHostToDevice )) print * , \"Lagrange memcpy\" call gpuCheck ( hipMemcpy ( this % qWeights_gpu , & c_loc ( this % qWeights ), & sizeof ( this % qWeights ), & hipMemcpyHostToDevice )) endsubroutine Init_Lagrange","tags":"","loc":"proc/init_lagrange~2.html"},{"title":"BoundaryInterp_Scalar1D – SELF","text":"public subroutine BoundaryInterp_Scalar1D(this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this Contents Source Code BoundaryInterp_Scalar1D Source Code subroutine BoundaryInterp_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this call self_blas_matrixop_1d ( this % interp % bMatrix_gpu , & this % interior_gpu , & this % boundary_gpu , & 2 , this % N + 1 , & this % nvar * this % nelem , this % blas_handle ) endsubroutine BoundaryInterp_Scalar1D","tags":"","loc":"proc/boundaryinterp_scalar1d~2.html"},{"title":"Free_Scalar1D – SELF","text":"public subroutine Free_Scalar1D(this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this Contents Source Code Free_Scalar1D Source Code subroutine Free_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( c_loc ( this % interior_gpu ))) call gpuCheck ( hipFree ( c_loc ( this % boundary_gpu ))) call gpuCheck ( hipFree ( c_loc ( this % extBoundary_gpu ))) call gpuCheck ( hipFree ( c_loc ( this % avgBoundary_gpu ))) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Scalar1D","tags":"","loc":"proc/free_scalar1d~2.html"},{"title":"Init_Scalar1D – SELF","text":"public subroutine Init_Scalar1D(this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar1D Source Code subroutine Init_Scalar1D ( this , interp , nVar , nElem ) implicit none class ( Scalar1D ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem if (. not . GPUAvailable ()) then print * , __ FILE__ , ':' , __ LINE__ , ' : Error : Attempt to use GPU extension, but GPU is not available.' stop 1 endif this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : nelem , 1 : nvar ), & this % boundary ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : 2 , 1 : nelem , 1 : nvar )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) call gpuCheck ( hipMalloc ( c_loc ( this % interior_gpu ), sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( c_loc ( this % boundary_gpu ), sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( c_loc ( this % extBoundary_gpu ), sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( c_loc ( this % avgBoundary_gpu ), sizeof ( this % avgBoundary ))) call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_Scalar1D","tags":"","loc":"proc/init_scalar1d~2.html"},{"title":"UpdateDevice_Scalar1D – SELF","text":"public subroutine UpdateDevice_Scalar1D(this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this Contents Source Code UpdateDevice_Scalar1D Source Code subroutine UpdateDevice_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior_gpu ), c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary_gpu ), c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary_gpu ), c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( c_loc ( this % avgboundary_gpu ), c_loc ( this % avgboundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Scalar1D","tags":"","loc":"proc/updatedevice_scalar1d~2.html"},{"title":"UpdateHost_Scalar1D – SELF","text":"public subroutine UpdateHost_Scalar1D(this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this Contents Source Code UpdateHost_Scalar1D Source Code subroutine UpdateHost_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), c_loc ( this % interior_gpu ), sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), c_loc ( this % boundary_gpu ), sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), c_loc ( this % extboundary_gpu ), sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % avgboundary ), c_loc ( this % avgboundary_gpu ), sizeof ( this % boundary ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Scalar1D","tags":"","loc":"proc/updatehost_scalar1d~2.html"},{"title":"GPUAvailable – SELF","text":"public function GPUAvailable() result(avail) Arguments None Return Value logical Contents Source Code GPUAvailable Source Code function GPUAvailable () result ( avail ) implicit none logical :: avail ! Local integer ( c_int ) :: gpuCount integer ( kind ( hipSuccess )) :: err err = hipGetDeviceCount ( gpuCount ) if ( gpuCount > 0 . and . err == hipSuccess ) then avail = . true . else avail = . false . endif endfunction GPUAvailable","tags":"","loc":"proc/gpuavailable~2.html"},{"title":"gpuCheck – SELF","text":"public subroutine gpuCheck(gpuError_t) Arguments Type Intent Optional Attributes Name integer(kind=kind(hipSuccess)) :: gpuError_t Contents Source Code gpuCheck Source Code subroutine gpuCheck ( gpuError_t ) implicit none integer ( kind ( hipSuccess )) :: gpuError_t if ( gpuError_t /= hipSuccess ) then write ( * , * ) \"GPU ERROR: Error code = \" , gpuError_t call exit ( gpuError_t ) endif endsubroutine gpuCheck","tags":"","loc":"proc/gpucheck~2.html"},{"title":"hipFree – SELF","text":"public interface hipFree Contents Functions hipFree_ Functions public function hipFree_(ptr) bind(c,name=\"hipFree\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Return Value integer(kind=kind(hipSuccess))","tags":"","loc":"interface/hipfree~2.html"},{"title":"hipGetDeviceCount – SELF","text":"public interface hipGetDeviceCount Contents Functions hipGetDeviceCount_ Functions public function hipGetDeviceCount_(count) bind(c,name=\"hipGetDeviceCount\") Arguments Type Intent Optional Attributes Name integer(kind=c_int) :: count Return Value integer(kind=kind(hipSuccess))","tags":"","loc":"interface/hipgetdevicecount~2.html"},{"title":"hipMalloc – SELF","text":"public interface hipMalloc Contents Functions hipMalloc_ Functions public function hipMalloc_(ptr, mySize) bind(c,name=\"hipMalloc\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: ptr integer(kind=c_size_t), value :: mySize Return Value integer(kind=kind(hipSuccess))","tags":"","loc":"interface/hipmalloc~2.html"},{"title":"hipMemcpy – SELF","text":"public interface hipMemcpy Contents Functions hipMemcpy_ Functions public function hipMemcpy_(dest, src, sizeBytes, myKind) bind(c,name=\"hipMemcpy\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: dest type(c_ptr), value :: src integer(kind=c_size_t), value :: sizeBytes integer(kind=kind(hipMemcpyHostToHost)), value :: myKind Return Value integer(kind=kind(hipSuccess))","tags":"","loc":"interface/hipmemcpy~2.html"},{"title":"hipblasCheck – SELF","text":"public subroutine hipblasCheck(hipblasError_t) Uses SELF_GPU_enums Arguments Type Intent Optional Attributes Name integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasError_t Contents Source Code hipblasCheck Source Code subroutine hipblasCheck ( hipblasError_t ) use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasError_t if ( hipblasError_t /= HIPBLAS_STATUS_SUCCESS ) then write ( * , * ) \"GPUBLAS ERROR: Error code = \" , hipblasError_t call exit ( hipblasError_t ) endif endsubroutine hipblasCheck","tags":"","loc":"proc/hipblascheck~2.html"},{"title":"self_blas_matrixop_1d – SELF","text":"public subroutine self_blas_matrixop_1d(A, f, Af, opArows, opAcols, bcols, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A real(kind=prec), intent(in), pointer :: f (:,:,:) real(kind=prec), intent(inout), pointer :: Af (:,:,:) integer, intent(in) :: opArows integer, intent(in) :: opAcols integer, intent(in) :: bcols type(c_ptr), intent(inout) :: handle Contents Source Code self_blas_matrixop_1d Source Code subroutine self_blas_matrixop_1d ( A , f , Af , opArows , opAcols , bcols , handle ) type ( c_ptr ), intent ( in ) :: A real ( prec ), pointer , intent ( in ) :: f (:,:,:) real ( prec ), pointer , intent ( inout ) :: Af (:,:,:) integer , intent ( in ) :: opArows , opAcols , bcols type ( c_ptr ), intent ( inout ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n integer ( c_int ) :: k real ( c_prec ) :: alpha integer ( c_int ) :: lda integer ( c_int ) :: ldb integer ( c_int ) :: ldc real ( c_prec ) :: beta m = opArows ! number of rows of A&#94;T n = bcols ! number of columns of B k = opAcols ! number of columns of A&#94;T alpha = 1.0_c_prec lda = k ! leading dimension of A (matrix) ldb = k ! leading dimension of B (f) ldc = m ! leading dimension of C (Af) beta = 0.0_c_prec call hipblasCheck ( hipblasgemm ( handle , & HIPBLAS_OP_T , HIPBLAS_OP_N , & m , n , k , alpha , & A , lda , & c_loc ( f ), ldb , & beta , & c_loc ( Af ), ldc )) endsubroutine self_blas_matrixop_1d","tags":"","loc":"proc/self_blas_matrixop_1d~2.html"},{"title":"self_blas_matrixop_dim1_2d – SELF","text":"public subroutine self_blas_matrixop_dim1_2d(A, f, Af, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A real(kind=prec), intent(in), pointer :: f (:,:,:,:) real(kind=prec), intent(inout), pointer :: Af (:,:,:,:) integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(inout) :: handle Contents Source Code self_blas_matrixop_dim1_2d Source Code subroutine self_blas_matrixop_dim1_2d ( A , f , Af , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A real ( prec ), pointer , intent ( in ) :: f (:,:,:,:) real ( prec ), pointer , intent ( inout ) :: Af (:,:,:,:) integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( inout ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n integer ( c_int ) :: k real ( c_prec ) :: alpha integer ( c_int ) :: lda integer ( c_int ) :: ldb integer ( c_int ) :: ldc real ( c_prec ) :: beta m = targetdegree + 1 ! number of rows of A&#94;T n = nvars * nelems * ( controldegree + 1 ) ! number of columns of B k = controldegree + 1 ! number of columns of A&#94;T alpha = 1.0_c_prec lda = k ! leading dimension of A (interpolation/derivative matrix) ldb = k ! leading dimension of B (f) ldc = m ! leading dimension of C (fTarget) beta = 0.0_c_prec ! First pass interpolates in the first quadrature dimension call hipblasCheck ( hipblasgemm ( handle , & HIPBLAS_OP_T , HIPBLAS_OP_N , & m , n , k , alpha , & A , lda , & c_loc ( f ), ldb , beta , & c_loc ( Af ), ldc )) endsubroutine self_blas_matrixop_dim1_2d","tags":"","loc":"proc/self_blas_matrixop_dim1_2d~2.html"},{"title":"self_blas_matrixop_dim1_3d – SELF","text":"public subroutine self_blas_matrixop_dim1_3d(A, f, Af, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A real(kind=prec), intent(in), pointer :: f (:,:,:,:,:) real(kind=prec), intent(inout), pointer :: Af (:,:,:,:,:) integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(inout) :: handle Contents Source Code self_blas_matrixop_dim1_3d Source Code subroutine self_blas_matrixop_dim1_3d ( A , f , Af , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A real ( prec ), pointer , intent ( in ) :: f (:,:,:,:,:) real ( prec ), pointer , intent ( inout ) :: Af (:,:,:,:,:) integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( inout ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n integer ( c_int ) :: k real ( c_prec ) :: alpha integer ( c_int ) :: lda integer ( c_int ) :: ldb integer ( c_int ) :: ldc real ( c_prec ) :: beta m = targetdegree + 1 ! number of rows of A&#94;T n = nvars * nelems * ( controldegree + 1 ) * ( controldegree + 1 ) ! number of columns of B k = controldegree + 1 ! number of columns of A&#94;T alpha = 1.0_c_prec lda = k ! leading dimension of A (interoplation matrix) ldb = k ! leading dimension of B (f) ldc = m ! leading dimension of C (fTarget) beta = 0.0_c_prec ! First pass interpolates in the first quadrature dimension call hipblasCheck ( hipblasgemm ( handle , & HIPBLAS_OP_T , HIPBLAS_OP_N , & m , n , k , alpha , & A , lda , & c_loc ( f ), ldb , beta , & c_loc ( Af ), ldc )) endsubroutine self_blas_matrixop_dim1_3d","tags":"","loc":"proc/self_blas_matrixop_dim1_3d~2.html"},{"title":"self_blas_matrixop_dim2_2d – SELF","text":"public subroutine self_blas_matrixop_dim2_2d(A, f, Af, beta, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A real(kind=prec), intent(in), pointer :: f (:,:,:,:) real(kind=prec), intent(inout), pointer :: Af (:,:,:,:) real(kind=c_prec), intent(in) :: beta integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(inout) :: handle Contents Source Code self_blas_matrixop_dim2_2d Source Code subroutine self_blas_matrixop_dim2_2d ( A , f , Af , beta , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A real ( prec ), pointer , intent ( in ) :: f (:,:,:,:) real ( prec ), pointer , intent ( inout ) :: Af (:,:,:,:) real ( c_prec ), intent ( in ) :: beta integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( inout ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n real ( c_prec ) :: alpha integer ( c_int ) :: lda integer :: i integer ( c_int64_t ) :: strideA integer ( c_int ) :: incx integer ( c_int64_t ) :: stridex integer ( c_int ) :: incy integer ( c_int64_t ) :: stridey integer ( c_int ) :: batchCount m = controldegree + 1 ! number of rows of A n = targetdegree + 1 ! number of columns of A alpha = 1.0_c_prec lda = m ! leading dimension of A strideA = 0 ! stride for the batches of A (no stride) incx = targetdegree + 1 ! stridex = ( controldegree + 1 ) * ( targetdegree + 1 ) incy = targetdegree + 1 stridey = ( targetdegree + 1 ) * ( targetdegree + 1 ) batchCount = nvars * nelems do i = 0 , targetdegree call hipblasCheck ( hipblasgemvStridedBatched ( handle , & HIPBLAS_OP_T , & m , n , alpha , & A , lda , strideA , & c_loc ( f ( 1 + i , 1 , 1 , 1 )), incx , stridex , beta , & c_loc ( Af ( 1 + i , 1 , 1 , 1 )), incy , stridey , batchCount )) enddo endsubroutine self_blas_matrixop_dim2_2d","tags":"","loc":"proc/self_blas_matrixop_dim2_2d~2.html"},{"title":"self_blas_matrixop_dim2_3d – SELF","text":"public subroutine self_blas_matrixop_dim2_3d(A, f, Af, beta, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A real(kind=prec), intent(in), pointer :: f (:,:,:,:,:) real(kind=prec), intent(inout), pointer :: Af (:,:,:,:,:) real(kind=c_prec), intent(in) :: beta integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(inout) :: handle Contents Source Code self_blas_matrixop_dim2_3d Source Code subroutine self_blas_matrixop_dim2_3d ( A , f , Af , beta , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A real ( prec ), pointer , intent ( in ) :: f (:,:,:,:,:) real ( prec ), pointer , intent ( inout ) :: Af (:,:,:,:,:) real ( c_prec ), intent ( in ) :: beta integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( inout ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n real ( c_prec ) :: alpha integer ( c_int ) :: lda integer :: i integer ( c_int64_t ) :: strideA integer ( c_int ) :: incx integer ( c_int64_t ) :: stridex integer ( c_int ) :: incy integer ( c_int64_t ) :: stridey integer ( c_int ) :: batchCount m = controldegree + 1 ! number of rows of A n = targetdegree + 1 ! number of columns of A alpha = 1.0_c_prec lda = m ! leading dimension of A strideA = 0 ! stride for the batches of A (no stride) incx = targetdegree + 1 ! stridex = ( controldegree + 1 ) * ( targetdegree + 1 ) !beta = 0.0_c_prec incy = targetdegree + 1 stridey = ( targetdegree + 1 ) * ( targetdegree + 1 ) batchCount = ( controldegree + 1 ) * nvars * nelems do i = 0 , targetdegree call hipblasCheck ( hipblasgemvStridedBatched ( handle , & HIPBLAS_OP_T , & m , n , alpha , & A , lda , strideA , & c_loc ( f ( 1 + i , 1 , 1 , 1 , 1 )), incx , stridex , beta , & c_loc ( Af ( 1 + i , 1 , 1 , 1 , 1 )), incy , stridey , batchCount )) enddo endsubroutine self_blas_matrixop_dim2_3d","tags":"","loc":"proc/self_blas_matrixop_dim2_3d~2.html"},{"title":"self_blas_matrixop_dim3_3d – SELF","text":"public subroutine self_blas_matrixop_dim3_3d(A, f, Af, beta, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A real(kind=prec), intent(in), pointer :: f (:,:,:,:,:) real(kind=prec), intent(inout), pointer :: Af (:,:,:,:,:) real(kind=c_prec), intent(in) :: beta integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(inout) :: handle Contents Source Code self_blas_matrixop_dim3_3d Source Code subroutine self_blas_matrixop_dim3_3d ( A , f , Af , beta , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A real ( prec ), pointer , intent ( in ) :: f (:,:,:,:,:) real ( prec ), pointer , intent ( inout ) :: Af (:,:,:,:,:) real ( c_prec ), intent ( in ) :: beta integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( inout ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n real ( c_prec ) :: alpha integer ( c_int ) :: lda integer :: i , j integer ( c_int64_t ) :: strideA integer ( c_int ) :: incx integer ( c_int64_t ) :: stridex integer ( c_int ) :: incy integer ( c_int64_t ) :: stridey integer ( c_int ) :: batchCount m = controldegree + 1 ! number of rows of A n = targetdegree + 1 ! number of columns of A alpha = 1.0_c_prec lda = m ! leading dimension of A strideA = 0 ! stride for the batches of A (no stride) incx = ( targetdegree + 1 ) * ( targetdegree + 1 ) ! stridex = ( controldegree + 1 ) * ( targetdegree + 1 ) * ( targetdegree + 1 ) incy = ( targetdegree + 1 ) * ( targetdegree + 1 ) stridey = ( targetdegree + 1 ) * ( targetdegree + 1 ) * ( targetdegree + 1 ) batchCount = nvars * nelems do j = 0 , targetdegree do i = 0 , targetdegree call hipblasCheck ( hipblasgemvStridedBatched ( handle , & HIPBLAS_OP_T , & m , n , alpha , & A , lda , strideA , & c_loc ( f ( 1 + i , 1 + j , 1 , 1 , 1 )), incx , stridex , beta , & c_loc ( Af ( 1 + i , 1 + j , 1 , 1 , 1 )), incy , stridey , batchCount )) enddo enddo endsubroutine self_blas_matrixop_dim3_3d","tags":"","loc":"proc/self_blas_matrixop_dim3_3d~2.html"},{"title":"hipblasCreate – SELF","text":"public interface hipblasCreate Contents Functions hipblasCreate_ Functions public function hipblasCreate_(handle) bind(c,name=\"cublasCreate_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: handle Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS))","tags":"","loc":"interface/hipblascreate~2.html"},{"title":"hipblasDestroy – SELF","text":"public interface hipblasDestroy Contents Functions hipblasDestroy_ Functions public function hipblasDestroy_(handle) bind(c,name=\"cublasDestroy_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS))","tags":"","loc":"interface/hipblasdestroy~2.html"},{"title":"hipblasDgemm – SELF","text":"public interface hipblasDgemm Contents Functions hipblasDgemm_ Functions public function hipblasDgemm_(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc) bind(c,name=\"cublasDgemm_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: transa integer(kind=kind(HIPBLAS_OP_N)), value :: transb integer(kind=c_int), value :: m integer(kind=c_int), value :: n integer(kind=c_int), value :: k real(kind=c_double) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda type(c_ptr), value :: B integer(kind=c_int), value :: ldb real(kind=c_double) :: beta type(c_ptr), value :: C integer(kind=c_int), value :: ldc Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS))","tags":"","loc":"interface/hipblasdgemm~2.html"},{"title":"hipblasDgemvStridedBatched – SELF","text":"public interface hipblasDgemvStridedBatched Contents Functions hipblasDgemvStridedBatched_ Functions public function hipblasDgemvStridedBatched_(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount) bind(c,name=\"cublasDgemvStridedBatched\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: trans integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda integer(kind=c_int64_t), value :: strideA type(c_ptr), value :: x integer(kind=c_int), value :: incx integer(kind=c_int64_t), value :: stridex real(kind=c_double) :: beta type(c_ptr), value :: y integer(kind=c_int), value :: incy integer(kind=c_int64_t), value :: stridey integer(kind=c_int), value :: batchCount Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS))","tags":"","loc":"interface/hipblasdgemvstridedbatched~2.html"},{"title":"hipblasSgemm – SELF","text":"public interface hipblasSgemm Contents Functions hipblasSgemm_ Functions public function hipblasSgemm_(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc) bind(c,name=\"cublasSgemm_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: transa integer(kind=kind(HIPBLAS_OP_N)), value :: transb integer(kind=c_int), value :: m integer(kind=c_int), value :: n integer(kind=c_int), value :: k real(kind=c_float) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda type(c_ptr), value :: B integer(kind=c_int), value :: ldb real(kind=c_float) :: beta type(c_ptr), value :: C integer(kind=c_int), value :: ldc Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS))","tags":"","loc":"interface/hipblassgemm~2.html"},{"title":"hipblasSgemvStridedBatched – SELF","text":"public interface hipblasSgemvStridedBatched Contents Functions hipblasSgemvStridedBatched_ Functions public function hipblasSgemvStridedBatched_(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount) bind(c,name=\"cublasSgemvStridedBatched\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: trans integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_float) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda integer(kind=c_int64_t), value :: strideA type(c_ptr), value :: x integer(kind=c_int), value :: incx integer(kind=c_int64_t), value :: stridex real(kind=c_float) :: beta type(c_ptr), value :: y integer(kind=c_int), value :: incy integer(kind=c_int64_t), value :: stridey integer(kind=c_int), value :: batchCount Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS))","tags":"","loc":"interface/hipblassgemvstridedbatched~2.html"},{"title":"SELF_DGModel3D_t – SELF","text":"Uses HDF5 SELF_Geometry_3D SELF_HDF5 SELF_Mesh_3D SELF_SupportRoutines SELF_MappedVector_3D SELF_MappedScalar_3D FEQParse SELF_Model SELF_Metadata Contents Derived Types DGModel3D_t Subroutines BoundaryFlux_DGModel3D_t CalculateEntropy_DGModel3D_t CalculateSolutionGradient_DGModel3D_t CalculateTendency_DGModel3D_t Free_DGModel3D_t Init_DGModel3D_t Read_DGModel3D_t SetMetadata_DGModel3D_t SetSolutionFromChar_DGModel3D_t SetSolutionFromEqn_DGModel3D_t UpdateGRK2_DGModel3D_t UpdateGRK3_DGModel3D_t UpdateGRK4_DGModel3D_t UpdateSolution_DGModel3D_t WriteTecplot_DGModel3D_t Write_DGModel3D_t fluxmethod_DGModel3D_t setboundarycondition_DGModel3D_t setgradientboundarycondition_DGModel3D_t sourcemethod_DGModel3D_t Derived Types type, public, extends( Model ) :: DGModel3D_t Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D_t procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D_t procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D_t procedure, public :: CalculateTendency => CalculateTendency_DGModel3D_t procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel3D_t procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel3D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel3D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel3D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D_t procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D_t procedure, public :: SetMetadata => SetMetadata_DGModel3D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t, SetSolutionFromEqn_DGModel3D_t procedure, private :: SetSolutionFromChar_DGModel3D_t procedure, private :: SetSolutionFromEqn_DGModel3D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel3D_t procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D_t procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D_t procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D_t procedure, public :: UpdateSolution => UpdateSolution_DGModel3D_t procedure, public :: WriteModel => Write_DGModel3D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model Subroutines public subroutine BoundaryFlux_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this public subroutine CalculateEntropy_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this public subroutine CalculateSolutionGradient_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this public subroutine CalculateTendency_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this public subroutine Free_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this public subroutine Init_DGModel3D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh3D ), intent(in), target :: mesh type( SEMHex ), intent(in), target :: geometry public subroutine Read_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: fileName public subroutine SetMetadata_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this public subroutine SetSolutionFromChar_DGModel3D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel3D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) public subroutine UpdateGRK2_DGModel3D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK3_DGModel3D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK4_DGModel3D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateSolution_DGModel3D_t (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt public subroutine WriteTecplot_DGModel3D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: filename public subroutine Write_DGModel3D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this character, intent(in), optional :: fileName public subroutine fluxmethod_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this public subroutine setboundarycondition_DGModel3D_t (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this public subroutine setgradientboundarycondition_DGModel3D_t (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this public subroutine sourcemethod_DGModel3D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel3D_t ), intent(inout) :: this","tags":"","loc":"module/self_dgmodel3d_t.html"},{"title":"self_advection_diffusion_2d_t – SELF","text":"Uses SELF_DGModel2D SELF_Mesh Contents Derived Types advection_diffusion_2d_t Functions entropy_func_advection_diffusion_2d_t flux2d_advection_diffusion_2d_t riemannflux2d_advection_diffusion_2d_t Derived Types type, public, extends( DGModel2D ) :: advection_diffusion_2d_t Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D procedure, public :: CalculateTendency => CalculateTendency_DGModel2D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel2D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel2D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel2D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel2D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D procedure, public :: SetMetadata => SetMetadata_DGModel2D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t, SetSolutionFromEqn_DGModel2D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel2D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D procedure, public :: UpdateSolution => UpdateSolution_DGModel2D procedure, public :: WriteModel => Write_DGModel2D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t procedure, public :: entropy_func => entropy_func_advection_diffusion_2d_t procedure, public :: flux1D => flux1d_Model procedure, public :: flux2d => flux2d_advection_diffusion_2d_t procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_advection_diffusion_2d_t procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model Functions public pure function entropy_func_advection_diffusion_2d_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) public pure function flux2d_advection_diffusion_2d_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar,1:2) Return Value real(kind=prec)(1:this%solution%nvar,1:2) public pure function riemannflux2d_advection_diffusion_2d_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar)","tags":"","loc":"module/self_advection_diffusion_2d_t.html"},{"title":"SELF_SupportRoutines – SELF","text":"\\file SELF_SupportRoutines.f90\nContains the \\ref SELF_SupportRoutines module\n\\defgroup SELF_SupportRoutines SELF_SupportRoutines\nThis module defines a set of general purpose routines. Uses iso_fortran_env SELF_Constants Contents Variables tolerance Interfaces AlmostEqual Functions AlmostEqual_r64 CompareArray UniformPoints UpperCase newunit Subroutines ForwardShift Variables Type Visibility Attributes Name Initial real(kind=prec), private, parameter :: tolerance = 10.0**(-10) Interfaces public interface AlmostEqual public function AlmostEqual_r64 (a, b) result(AisB) \\addtogroup SELF_SupportRoutines\n @{\n \\fn AlmostEqual\n Compares two floating point numbers and determines if they are equal (to machine precision). Read more… Arguments Type Intent Optional Attributes Name real(kind=real64) :: a real(kind=real64) :: b Return Value logical Functions public function AlmostEqual_r64 (a, b) result(AisB) \\addtogroup SELF_SupportRoutines\n @{\n \\fn AlmostEqual\n Compares two floating point numbers and determines if they are equal (to machine precision). Read more… Arguments Type Intent Optional Attributes Name real(kind=real64) :: a real(kind=real64) :: b Return Value logical public function CompareArray (arrayOne, arrayTwo, N) result(arraysMatch) \\addtogroup SELF_SupportRoutines\n @{\n \\fn CompareArray\n Compares to INTEGER arrays and determines if they are identical. Read more… Arguments Type Intent Optional Attributes Name integer :: arrayOne (1:N) integer :: arrayTwo (1:N) integer :: N Return Value logical public function UniformPoints (a, b, firstInd, lastInd) result(xU) \\addtogroup SELF_SupportRoutines\n @{\n \\fn UniformPoints\n Generates a REAL(prec) array of N points evenly spaced between two points. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec) :: a real(kind=prec) :: b integer :: firstInd integer :: lastInd Return Value real(kind=prec)(firstInd:lastInd) public function UpperCase (str) result(Upper) Arguments Type Intent Optional Attributes Name character, intent(in) :: str Return Value character public function newunit (unit) Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: unit Return Value integer Subroutines public subroutine ForwardShift (myArray, N) \\addtogroup SELF_SupportRoutines\n @{\n \\fn ForwardShift\n Shift an array integers by one index forward, moving the last index to the first. Read more… Arguments Type Intent Optional Attributes Name integer, intent(inout) :: myArray (1:N) integer, intent(in) :: N","tags":"","loc":"module/self_supportroutines.html"},{"title":"SELF_Scalar_2D_t – SELF","text":"Uses HDF5 SELF_Lagrange SELF_HDF5 SELF_Data FEQParse iso_c_binding SELF_Metadata SELF_Constants Contents Derived Types Scalar2D_t Subroutines AverageSides_Scalar2D_t BoundaryInterp_Scalar2D_t Free_Scalar2D_t Gradient_Scalar2D_t GridInterp_Scalar2D_t Init_Scalar2D_t UpdateDevice_Scalar2D_t UpdateHost_Scalar2D_t WriteHDF5_MPI_Scalar2D_t WriteHDF5_Scalar2D_t Derived Types type, public, extends( SELF_DataObj ) :: Scalar2D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: avgBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundarynormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar2D_t procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D_t procedure, public :: Free => Free_Scalar2D_t generic, public :: Gradient => Gradient_Scalar2D_t procedure, private :: Gradient_Scalar2D_t generic, public :: GridInterp => GridInterp_Scalar2D_t procedure, private :: GridInterp_Scalar2D_t procedure, public :: Init => Init_Scalar2D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Scalar2D_t procedure, public :: UpdateHost => UpdateHost_Scalar2D_t generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D_t, WriteHDF5_Scalar2D_t procedure, private :: WriteHDF5_MPI_Scalar2D_t procedure, private :: WriteHDF5_Scalar2D_t Subroutines public subroutine AverageSides_Scalar2D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this public subroutine BoundaryInterp_Scalar2D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this public subroutine Free_Scalar2D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this public subroutine Gradient_Scalar2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) public subroutine GridInterp_Scalar2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) public subroutine Init_Scalar2D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine UpdateDevice_Scalar2D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this public subroutine UpdateHost_Scalar2D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(inout) :: this public subroutine WriteHDF5_MPI_Scalar2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group","tags":"","loc":"module/self_scalar_2d_t.html"},{"title":"SELF_DGModel2D_t – SELF","text":"Uses SELF_Geometry_2D HDF5 SELF_HDF5 SELF_SupportRoutines SELF_MappedVector_2D FEQParse SELF_Mesh_2D SELF_Model SELF_Metadata SELF_MappedScalar_2D Contents Derived Types DGModel2D_t Subroutines BoundaryFlux_DGModel2D_t CalculateEntropy_DGModel2D_t CalculateSolutionGradient_DGModel2D_t CalculateTendency_DGModel2D_t Free_DGModel2D_t Init_DGModel2D_t Read_DGModel2D_t SetMetadata_DGModel2D_t SetSolutionFromChar_DGModel2D_t SetSolutionFromEqn_DGModel2D_t UpdateGRK2_DGModel2D_t UpdateGRK3_DGModel2D_t UpdateGRK4_DGModel2D_t UpdateSolution_DGModel2D_t WriteTecplot_DGModel2D_t Write_DGModel2D_t fluxmethod_DGModel2D_t setboundarycondition_DGModel2D_t setgradientboundarycondition_DGModel2D_t sourcemethod_DGModel2D_t Derived Types type, public, extends( Model ) :: DGModel2D_t Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D_t procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D_t procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D_t procedure, public :: CalculateTendency => CalculateTendency_DGModel2D_t procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel2D_t procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel2D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel2D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel2D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D_t procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D_t procedure, public :: SetMetadata => SetMetadata_DGModel2D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t, SetSolutionFromEqn_DGModel2D_t procedure, private :: SetSolutionFromChar_DGModel2D_t procedure, private :: SetSolutionFromEqn_DGModel2D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel2D_t procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D_t procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D_t procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D_t procedure, public :: UpdateSolution => UpdateSolution_DGModel2D_t procedure, public :: WriteModel => Write_DGModel2D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model Subroutines public subroutine BoundaryFlux_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this public subroutine CalculateEntropy_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this public subroutine CalculateSolutionGradient_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this public subroutine CalculateTendency_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this public subroutine Free_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this public subroutine Init_DGModel2D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh2D ), intent(in), target :: mesh type( SEMQuad ), intent(in), target :: geometry public subroutine Read_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: fileName public subroutine SetMetadata_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this public subroutine SetSolutionFromChar_DGModel2D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel2D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) public subroutine UpdateGRK2_DGModel2D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK3_DGModel2D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK4_DGModel2D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateSolution_DGModel2D_t (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt public subroutine WriteTecplot_DGModel2D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: filename public subroutine Write_DGModel2D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this character, intent(in), optional :: fileName public subroutine fluxmethod_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this public subroutine setboundarycondition_DGModel2D_t (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this public subroutine setgradientboundarycondition_DGModel2D_t (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this public subroutine sourcemethod_DGModel2D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel2D_t ), intent(inout) :: this","tags":"","loc":"module/self_dgmodel2d_t.html"},{"title":"SELF_MappedScalar_1D_t – SELF","text":"Uses HDF5 SELF_Lagrange SELF_HDF5 SELF_Geometry_1D SELF_Mesh_1D SELF_Scalar_1D iso_c_binding FEQParse SELF_Constants Contents Derived Types MappedScalar1D_t Subroutines AssociateGeometry_MappedScalar1D_t DissociateGeometry_MappedScalar1D_t MappedDGDerivative_MappedScalar1D_t MappedDerivative_MappedScalar1D_t SetInteriorFromEquation_MappedScalar1D_t SideExchange_MappedScalar1D_t Derived Types type, public, extends( Scalar1D ) :: MappedScalar1D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( Geometry1D ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar1D_t procedure, public :: AverageSides => AverageSides_Scalar1D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D generic, public :: Derivative => Derivative_Scalar1D_t, Derivative_Scalar1D procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar1D_t procedure, public :: Free => Free_Scalar1D generic, public :: GridInterp => GridInterp_Scalar1D_t, GridInterp_Scalar1D procedure, public :: Init => Init_Scalar1D generic, public :: MappedDGDerivative => MappedDGDerivative_MappedScalar1D_t procedure, private :: MappedDGDerivative_MappedScalar1D_t generic, public :: MappedDerivative => MappedDerivative_MappedScalar1D_t procedure, private :: MappedDerivative_MappedScalar1D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar1D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedScalar1D_t procedure, public :: UpdateDevice => UpdateDevice_Scalar1D procedure, public :: UpdateHost => UpdateHost_Scalar1D generic, public :: WriteHDF5 => WriteHDF5_Scalar1D_t Subroutines public subroutine AssociateGeometry_MappedScalar1D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this type( Geometry1D ), intent(in), target :: geometry public subroutine DissociateGeometry_MappedScalar1D_t (this) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this public subroutine MappedDGDerivative_MappedScalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%nelem,1:this%nvar) public subroutine MappedDerivative_MappedScalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%nelem,1:this%nvar) public subroutine SetInteriorFromEquation_MappedScalar1D_t (this, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this real(kind=prec), intent(in) :: time public subroutine SideExchange_MappedScalar1D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar1D_t ), intent(inout) :: this type( Mesh1D ), intent(inout) :: mesh","tags":"","loc":"module/self_mappedscalar_1d_t.html"},{"title":"SELF_Geometry_1D – SELF","text":"Uses SELF_Lagrange SELF_Mesh_1D SELF_Scalar_1D SELF_SupportRoutines SELF_Data SELF_Constants Contents Derived Types Geometry1D Subroutines CalculateMetricTerms_Geometry1D Free_Geometry1D GenerateFromMesh_Geometry1D Init_Geometry1D Write_Geometry1D Derived Types type, public :: Geometry1D Components Type Visibility Attributes Name Initial type( Scalar1D ), public :: dxds integer, public :: nElem type( Scalar1D ), public :: x Type-Bound Procedures procedure, public :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D procedure, public :: Free => Free_Geometry1D procedure, public :: GenerateFromMesh => GenerateFromMesh_Geometry1D procedure, public :: Init => Init_Geometry1D procedure, public :: write => Write_Geometry1D Subroutines public subroutine CalculateMetricTerms_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom public subroutine Free_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom public subroutine GenerateFromMesh_Geometry1D (myGeom, mesh) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom type( Mesh1D ), intent(in) :: mesh public subroutine Init_Geometry1D (myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom type( Lagrange ), intent(in), pointer :: interp integer, intent(in) :: nElem public subroutine Write_Geometry1D (myGeom, fileName) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(in) :: myGeom character, intent(in), optional :: fileName","tags":"","loc":"module/self_geometry_1d.html"},{"title":"SELF_Model – SELF","text":"Uses HDF5 SELF_HDF5 SELF_SupportRoutines FEQParse SELF_Metadata Contents Variables SELF_EQUATION_LENGTH SELF_EULER SELF_FORMULATION_LENGTH SELF_INTEGRATOR_LENGTH SELF_RK2 SELF_RK3 SELF_RK4 rk2_a rk2_b rk2_g rk3_a rk3_b rk3_g rk4_a rk4_b rk4_g Interfaces CalculateTendency ReadModel SELF_timeIntegrator UpdateGRK UpdateSolution WriteModel WriteTecplot Derived Types Model Functions entropy_func_Model flux1d_Model flux2d_Model flux3d_Model hbc1d_Generic_Model hbc1d_Prescribed_Model hbc2d_Generic_Model hbc2d_Prescribed_Model hbc3d_Generic_Model hbc3d_Prescribed_Model pbc1d_Generic_Model pbc1d_Prescribed_Model pbc2d_Generic_Model pbc2d_Prescribed_Model pbc3d_Generic_Model pbc3d_Prescribed_Model riemannflux1d_Model riemannflux2d_Model riemannflux3d_Model source1d_Model source2d_Model source3d_Model Subroutines CalculateEntropy_Model Euler_timeIntegrator ForwardStep_Model GetSimulationTime IncrementIOCounter LowStorageRK2_timeIntegrator LowStorageRK3_timeIntegrator LowStorageRK4_timeIntegrator PreTendency_Model PrintType_Model ReportEntropy_Model SetSimulationTime SetTimeIntegrator_withChar Variables Type Visibility Attributes Name Initial integer, public, parameter :: SELF_EQUATION_LENGTH = 500 integer, public, parameter :: SELF_EULER = 100 integer, public, parameter :: SELF_FORMULATION_LENGTH = 30 integer, public, parameter :: SELF_INTEGRATOR_LENGTH = 10 integer, public, parameter :: SELF_RK2 = 200 integer, public, parameter :: SELF_RK3 = 300 integer, public, parameter :: SELF_RK4 = 400 real(kind=prec), public, parameter :: rk2_a (1:2) = (/0.0_prec, -0.5_prec/) real(kind=prec), public, parameter :: rk2_b (1:2) = (/0.5_prec, 0.5_prec/) real(kind=prec), public, parameter :: rk2_g (1:2) = (/0.5_prec, 1.0_prec/) real(kind=prec), public, parameter :: rk3_a (1:3) = (/0.0_prec, -5.0_prec/9.0_prec, -153.0_prec/128.0_prec/) real(kind=prec), public, parameter :: rk3_b (1:3) = (/0.0_prec, 1.0_prec/3.0_prec, 3.0_prec/4.0_prec/) real(kind=prec), public, parameter :: rk3_g (1:3) = (/1.0_prec/3.0_prec, 15.0_prec/16.0_prec, 8.0_prec/15.0_prec/) real(kind=prec), public, parameter :: rk4_a (1:5) = (/0.0_prec, -1.0_prec, -1.0_prec/3.0_prec+2.0_prec**(2.0_prec/3.0_prec)/6.0_prec, -2.0_prec**(1.0_prec/3.0_prec)-2.0_prec**(2.0_prec/3.0_prec)-2.0_prec, -1.0_prec+2.0_prec**(1.0_prec/3.0_prec)/) real(kind=prec), public, parameter :: rk4_b (1:5) = (/0.0_prec, 2.0_prec/3.0_prec+2.0_prec**(1.0_prec/3.0_prec)/3.0_prec+2.0_prec**(2.0_prec/3.0_prec)/6.0_prec, 2.0_prec/3.0_prec+2.0_prec**(1.0_prec/3.0_prec)/3.0_prec+2.0_prec**(2.0_prec/3.0_prec)/6.0_prec, 1.0_prec/3.0_prec-2.0_prec**(1.0_prec/3.0_prec)/3.0_prec-2.0_prec**(2.0_prec/3.0_prec)/6.0_prec, 1.0_prec/) real(kind=prec), public, parameter :: rk4_g (1:5) = (/2.0_prec/3.0_prec+2.0_prec**(1.0_prec/3.0_prec)/3.0_prec+2.0_prec**(2.0_prec/3.0_prec)/6.0_prec, -2.0_prec**(2.0_prec/3.0_prec)/6.0_prec+1.0_prec/6.0_prec, -1.0_prec/3.0_prec-2.0_prec*2.0_prec**(1.0_prec/3.0_prec)/3.0_prec-2.0_prec**(2.0_prec/3.0_prec)/3.0_prec, 1.0_prec/3.0_prec-2.0_prec**(1.0_prec/3.0_prec)/3.0_prec-2.0_prec**(2.0_prec/3.0_prec)/6.0_prec, 1.0_prec/3.0_prec+2.0_prec**(1.0_prec/3.0_prec)/6.0_prec+2.0_prec**(2.0_prec/3.0_prec)/12.0_prec/) Interfaces interface public subroutine CalculateTendency(this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this interface public subroutine ReadModel(this, filename) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: filename interface public subroutine SELF_timeIntegrator(this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn interface public subroutine UpdateGRK(this, m) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this integer, intent(in) :: m interface public subroutine UpdateSolution(this, dt) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt interface public subroutine WriteModel(this, filename) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in), optional :: filename interface public subroutine WriteTecplot(this, filename) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in), optional :: filename Derived Types type, public, abstract :: Model Components Type Visibility Attributes Name Initial real(kind=prec), public :: dt real(kind=prec), public :: entropy logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 integer, public :: nvar real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator Type-Bound Procedures procedure, public :: CalculateEntropy => CalculateEntropy_Model procedure(CalculateTendency), public :: CalculateTendency procedure, public :: Euler_timeIntegrator procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure(ReadModel), public :: ReadModel procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetSimulationTime generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, private :: SetTimeIntegrator_withChar procedure(UpdateGRK), public :: UpdateGRK2 procedure(UpdateGRK), public :: UpdateGRK3 procedure(UpdateGRK), public :: UpdateGRK4 procedure(UpdateSolution), public :: UpdateSolution procedure(WriteModel), public :: WriteModel procedure(WriteTecplot), public :: WriteTecplot procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model Functions public pure function entropy_func_Model (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) Return Value real(kind=prec) public pure function flux1d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) public pure function flux2d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar,1:2) public pure function flux3d_Model (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar,1:3) public pure function hbc1d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) public pure function hbc1d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) public pure function hbc2d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) public pure function hbc2d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) public pure function hbc3d_Generic_Model (this, s, nhat) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) public pure function hbc3d_Prescribed_Model (this, x, t) result(exts) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) public pure function pbc1d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) public pure function pbc1d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar) public pure function pbc2d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar,1:2) public pure function pbc2d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:2) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:2) public pure function pbc3d_Generic_Model (this, dsdx, nhat) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar,1:3) public pure function pbc3d_Prescribed_Model (this, x, t) result(extDsdx) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: x (1:3) real(kind=prec), intent(in) :: t Return Value real(kind=prec)(1:this%nvar,1:3) public pure function riemannflux1d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%nvar) public pure function riemannflux2d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) real(kind=prec), intent(in) :: nhat (1:2) Return Value real(kind=prec)(1:this%nvar) public pure function riemannflux3d_Model (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar) public pure function source1d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar) Return Value real(kind=prec)(1:this%nvar) public pure function source2d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:2) Return Value real(kind=prec)(1:this%nvar) public pure function source3d_Model (this, s, dsdx) result(source) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) Return Value real(kind=prec)(1:this%nvar) Subroutines public subroutine CalculateEntropy_Model (this) Base method for calculating entropy of a model\nWhen this method is not overridden, the entropy\nis simply set to 0.0. When you develop a model\nbuilt on top of this abstract class or one of its\nchildren, it is recommended that you define a\nconvex mathematical entropy function that is used\nas a measure of the model stability. Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this public subroutine Euler_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn public subroutine ForwardStep_Model (this, tn, dt, ioInterval) Forward steps the model using the associated tendency procedure and time integrator Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn real(kind=prec), intent(in) :: dt real(kind=prec), intent(in) :: ioInterval public subroutine GetSimulationTime (this, t) Returns the current simulation time stored in the model % t attribute Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this real(kind=prec), intent(out) :: t public subroutine IncrementIOCounter (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this public subroutine LowStorageRK2_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn public subroutine LowStorageRK3_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn public subroutine LowStorageRK4_timeIntegrator (this, tn) Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: tn public subroutine PreTendency_Model (this) PreTendency is a template routine that is used to house any additional calculations\nthat you want to execute at the beginning of the tendency calculation routine.\nThis default PreTendency simply returns back to the caller without executing any instructions Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this public subroutine PrintType_Model (this) Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this public subroutine ReportEntropy_Model (this) Base method for reporting the entropy of a model\nto stdout. Only override this procedure if additional\nreporting is needed. Alternatively, if you think\nadditional reporting would be valuable for all models,\nopen a pull request with modifications to this base\nmethod. Arguments Type Intent Optional Attributes Name class( Model ), intent(in) :: this public subroutine SetSimulationTime (this, t) Sets the model % t attribute with the provided simulation time Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this real(kind=prec), intent(in) :: t public subroutine SetTimeIntegrator_withChar (this, integrator) Sets the time integrator method, using a character input Read more… Arguments Type Intent Optional Attributes Name class( Model ), intent(inout) :: this character, intent(in) :: integrator","tags":"","loc":"module/self_model.html"},{"title":"SELF_Mesh_2D_t – SELF","text":"Uses HDF5 SELF_Lagrange SELF_HDF5 SELF_SupportRoutines SELF_DomainDecomposition iso_c_binding SELF_Mesh SELF_Constants Contents Variables selfSide2D_East selfSide2D_North selfSide2D_South selfSide2D_West Derived Types Mesh2D_t Subroutines Free_Mesh2D_t Init_Mesh2D_t Read_HOPr_Mesh2D_t RecalculateFlip_Mesh2D_t ResetBoundaryConditionType_Mesh2D_t UniformStructuredMesh_Mesh2D_t Write_Mesh2D_t Variables Type Visibility Attributes Name Initial integer, public, parameter :: selfSide2D_East = 2 integer, public, parameter :: selfSide2D_North = 3 integer, public, parameter :: selfSide2D_South = 1 integer, public, parameter :: selfSide2D_West = 4 Derived Types type, public, extends( SEMMesh ) :: Mesh2D_t Components Type Visibility Attributes Name Initial character(len=255), public, allocatable :: BCNames (:) integer, public, pointer, dimension(:,:) :: BCType integer, public, pointer, dimension(:,:) :: CGNSCornerMap integer, public, pointer, dimension(:,:) :: CGNSSideMap type( DomainDecomposition ), public :: decomp integer, public, pointer, dimension(:,:) :: elemInfo integer, public, pointer, dimension(:,:,:) :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides real(kind=prec), public, pointer, dimension(:,:,:,:) :: nodeCoords integer, public :: quadrature integer, public, pointer, dimension(:,:,:) :: sideInfo Type-Bound Procedures procedure, public :: Free => Free_Mesh2D_t procedure, public :: Init => Init_Mesh2D_t procedure, public :: Read_HOPr => Read_HOPr_Mesh2D_t procedure, public :: RecalculateFlip => RecalculateFlip_Mesh2D_t procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh2D_t generic, public :: StructuredMesh => UniformStructuredMesh_Mesh2D_t procedure, private :: UniformStructuredMesh_Mesh2D_t procedure, public :: Write_Mesh => Write_Mesh2D_t Subroutines public subroutine Free_Mesh2D_t (this) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this public subroutine Init_Mesh2D_t (this, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs public subroutine Read_HOPr_Mesh2D_t (this, meshFile, enableDomainDecomposition) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(out) :: this character, intent(in) :: meshFile logical, intent(in), optional :: enableDomainDecomposition public subroutine RecalculateFlip_Mesh2D_t (this) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this public subroutine ResetBoundaryConditionType_Mesh2D_t (this, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Read more… Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this integer, intent(in) :: bcid public subroutine UniformStructuredMesh_Mesh2D_t (this, nxPerTile, nyPerTile, nTileX, nTileY, dx, dy, bcids, enableDomainDecomposition) Create a structured mesh and store it in SELF's unstructured mesh format.\nThe mesh is created in tiles of size (tnx,tny). Tiling is used to determine\nthe element ordering. Read more… Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(out) :: this integer, intent(in) :: nxPerTile integer, intent(in) :: nyPerTile integer, intent(in) :: nTileX integer, intent(in) :: nTileY real(kind=prec), intent(in) :: dx real(kind=prec), intent(in) :: dy integer, intent(in) :: bcids (1:4) logical, intent(in), optional :: enableDomainDecomposition public subroutine Write_Mesh2D_t (this, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D_t ), intent(inout) :: this character, intent(in) :: meshFile","tags":"","loc":"module/self_mesh_2d_t.html"},{"title":"SELF_Geometry_2D – SELF","text":"Uses SELF_Lagrange SELF_Tensor_2D SELF_SupportRoutines SELF_Scalar_2D SELF_Data SELF_Vector_2D SELF_Constants SELF_Mesh_2D Contents Derived Types SEMQuad Subroutines CalculateContravariantBasis_SEMQuad CalculateMetricTerms_SEMQuad Free_SEMQuad GenerateFromMesh_SEMQuad Init_SEMQuad WriteTecplot_SEMQuad Derived Types type, public :: SEMQuad Components Type Visibility Attributes Name Initial type( Scalar2D ), public :: J type( Tensor2D ), public :: dsdx type( Tensor2D ), public :: dxds integer, public :: nElem type( Vector2D ), public :: nHat type( Scalar2D ), public :: nScale type( Vector2D ), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad procedure, public :: Free => Free_SEMQuad procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMQuad procedure, public :: Init => Init_SEMQuad procedure, public :: WriteTecplot => WriteTecplot_SEMQuad Subroutines public subroutine CalculateContravariantBasis_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine CalculateMetricTerms_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine Free_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine GenerateFromMesh_SEMQuad (myGeom, mesh) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom type( Mesh2D ), intent(in) :: mesh public subroutine Init_SEMQuad (myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom type( Lagrange ), intent(in), pointer :: interp integer, intent(in) :: nElem public subroutine WriteTecplot_SEMQuad (this, filename) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: this character, intent(in) :: filename","tags":"","loc":"module/self_geometry_2d.html"},{"title":"self_NullDGModel1D_t – SELF","text":"Uses SELF_Mesh SELF_Model SELF_DGModel1D Contents Derived Types NullDGModel1D_t Derived Types type, public, extends( DGModel1D ) :: NullDGModel1D_t Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D procedure, public :: CalculateTendency => CalculateTendency_DGModel1D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel1D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel1D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel1D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel1D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D procedure, public :: SetMetadata => SetMetadata_DGModel1D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t, SetSolutionFromEqn_DGModel1D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel1D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D procedure, public :: UpdateSolution => UpdateSolution_DGModel1D procedure, public :: WriteModel => Write_DGModel1D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_nulldgmodel1d_t.html"},{"title":"SELF_Metadata – SELF","text":"Uses HDF5 SELF_HDF5 Contents Variables SELF_MTD_DescriptionLength SELF_MTD_NameLength SELF_MTD_UnitsLength Derived Types Metadata Subroutines SetDescription_Metadata SetName_Metadata SetUnits_Metadata WriteHDF5_Metadata Variables Type Visibility Attributes Name Initial integer, public, parameter :: SELF_MTD_DescriptionLength = 1000 integer, public, parameter :: SELF_MTD_NameLength = 250 integer, public, parameter :: SELF_MTD_UnitsLength = 20 Derived Types type, public :: Metadata Components Type Visibility Attributes Name Initial character, public :: description character, public :: name character, public :: units Type-Bound Procedures procedure, public :: SetDescription => SetDescription_Metadata procedure, public :: SetName => SetName_Metadata procedure, public :: SetUnits => SetUnits_Metadata procedure, public :: WriteHDF5 => WriteHDF5_Metadata Subroutines public subroutine SetDescription_Metadata (mtd, description) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: description public subroutine SetName_Metadata (mtd, name) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: name public subroutine SetUnits_Metadata (mtd, units) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: units public subroutine WriteHDF5_Metadata (mtd, group, varid, fileId) Writes the metadata to a HDF5 file using the\nfields :\n * /metadata/{group}/name/{varid} * /metadata/{group}/description/{varid} * /metadata/{group}/units/{varid} Read more… Arguments Type Intent Optional Attributes Name class( Metadata ), intent(in) :: mtd character, intent(in) :: group integer, intent(in) :: varid integer(kind=HID_T), intent(in) :: fileId","tags":"","loc":"module/self_metadata.html"},{"title":"SELF_MappedVector_3D_t – SELF","text":"Uses SELF_Lagrange SELF_Geometry_3D SELF_Mesh_3D SELF_DomainDecomposition iso_c_binding FEQParse SELF_Constants Contents Derived Types MappedVector3D_t Subroutines ApplyFlip_MappedVector3D_t AssociateGeometry_MappedVector3D_t DissociateGeometry_MappedVector3D_t MPIExchangeAsync_MappedVector3D_t MappedDGDivergence_MappedVector3D_t MappedDivergence_MappedVector3D_t SetInteriorFromEquation_MappedVector3D_t SideExchange_MappedVector3D_t Derived Types type, public, extends( Vector3D ) :: MappedVector3D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMHex ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedVector3D_t procedure, public :: AssociateGeometry => AssociateGeometry_MappedVector3D_t procedure, public :: AverageSides => AverageSides_Vector3D procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D generic, public :: Curl => Curl_Vector3D_t procedure, public :: DissociateGeometry => DissociateGeometry_MappedVector3D_t generic, public :: Divergence => Divergence_Vector3D_t, Divergence_Vector3D procedure, public :: Free => Free_Vector3D generic, public :: Gradient => Gradient_Vector3D_t, Gradient_Vector3D generic, public :: GridInterp => GridInterp_Vector3D_t, GridInterp_Vector3D procedure, public :: Init => Init_Vector3D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D_t generic, public :: MappedDGDivergence => MappedDGDivergence_MappedVector3D_t procedure, private :: MappedDGDivergence_MappedVector3D_t generic, public :: MappedDivergence => MappedDivergence_MappedVector3D_t procedure, private :: MappedDivergence_MappedVector3D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector3D_t procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector3D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedVector3D_t procedure, public :: UpdateDevice => UpdateDevice_Vector3D procedure, public :: UpdateHost => UpdateHost_Vector3D generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D_t, WriteHDF5_Vector3D_t Subroutines public subroutine ApplyFlip_MappedVector3D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh public subroutine AssociateGeometry_MappedVector3D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( SEMHex ), intent(in), target :: geometry public subroutine DissociateGeometry_MappedVector3D_t (this) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this public subroutine MPIExchangeAsync_MappedVector3D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh public subroutine MappedDGDivergence_MappedVector3D_t (this, df) Computes the divergence of a 3-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine MappedDivergence_MappedVector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine SetInteriorFromEquation_MappedVector3D_t (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time public subroutine SideExchange_MappedVector3D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh","tags":"","loc":"module/self_mappedvector_3d_t.html"},{"title":"SELF_HDF5 – SELF","text":"Uses iso_fortran_env HDF5 mpi SELF_Constants Contents Interfaces Open_HDF5 ReadArray_HDF5 ReadAttribute_HDF5 WriteArray_HDF5 WriteAttribute_HDF5 WriteCharacter_HDF5 Subroutines Close_HDF5 CreateGroup_HDF5 Open_HDF5_parallel Open_HDF5_serial ReadArray_HDF5_int32_r1_parallel ReadArray_HDF5_int32_r1_serial ReadArray_HDF5_int32_r2_parallel ReadArray_HDF5_int32_r2_serial ReadArray_HDF5_real_r1_parallel ReadArray_HDF5_real_r1_serial ReadArray_HDF5_real_r2_parallel ReadArray_HDF5_real_r2_serial ReadArray_HDF5_real_r3_parallel ReadArray_HDF5_real_r3_serial ReadArray_HDF5_real_r4_parallel ReadArray_HDF5_real_r4_serial ReadArray_HDF5_real_r5_serial ReadAttribute_HDF5_character ReadAttribute_HDF5_int32 ReadAttribute_HDF5_real WriteArray_HDF5_int32_r1_serial WriteArray_HDF5_int32_r2_serial WriteArray_HDF5_int32_r3_serial WriteArray_HDF5_int32_r4_serial WriteArray_HDF5_real_r1_serial WriteArray_HDF5_real_r2_serial WriteArray_HDF5_real_r3_parallel WriteArray_HDF5_real_r3_serial WriteArray_HDF5_real_r4_parallel WriteArray_HDF5_real_r4_serial WriteArray_HDF5_real_r5_serial WriteAttribute_HDF5_int32 WriteCharacter_HDF5_serial Interfaces public interface Open_HDF5 private subroutine Open_HDF5_serial (fileName, accessFlag, fileId) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId private subroutine Open_HDF5_parallel (fileName, accessFlag, fileId, mpiComm) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId integer, intent(in) :: mpiComm public interface ReadArray_HDF5 private subroutine ReadArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:) :: hfArray private subroutine ReadArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:) :: hfArray private subroutine ReadArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:) :: hfArray private subroutine ReadArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:,:) :: hfArray private subroutine ReadArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:,:,:) :: hfArray private subroutine ReadArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:) :: hfArray private subroutine ReadArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:,:) :: hfArray private subroutine ReadArray_HDF5_real_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_real_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) private subroutine ReadArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) private subroutine ReadArray_HDF5_int32_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_int32_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) public interface ReadAttribute_HDF5 private subroutine ReadAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(out) :: attribute private subroutine ReadAttribute_HDF5_real (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(out) :: attribute private subroutine ReadAttribute_HDF5_character (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(out) :: attribute public interface WriteArray_HDF5 private subroutine WriteArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:) :: hfArray private subroutine WriteArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:) :: hfArray private subroutine WriteArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:) :: hfArray private subroutine WriteArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:,:) :: hfArray private subroutine WriteArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:,:,:) :: hfArray private subroutine WriteArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:) :: hfArray private subroutine WriteArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:,:) :: hfArray private subroutine WriteArray_HDF5_int32_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:,:,:) :: hfArray private subroutine WriteArray_HDF5_int32_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:,:,:,:) :: hfArray private subroutine WriteArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) public interface WriteAttribute_HDF5 private subroutine WriteAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(in) :: attribute public interface WriteCharacter_HDF5 private subroutine WriteCharacter_HDF5_serial (fileId, name, hfField) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character(len=*), intent(in) :: name character(len=*), intent(in) :: hfField Subroutines public subroutine Close_HDF5 (fileId) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId public subroutine CreateGroup_HDF5 (fileId, groupName) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: groupName private subroutine Open_HDF5_parallel (fileName, accessFlag, fileId, mpiComm) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId integer, intent(in) :: mpiComm private subroutine Open_HDF5_serial (fileName, accessFlag, fileId) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId private subroutine ReadArray_HDF5_int32_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:) :: hfArray private subroutine ReadArray_HDF5_int32_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(inout), dimension(:,:) :: hfArray private subroutine ReadArray_HDF5_real_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:) :: hfArray private subroutine ReadArray_HDF5_real_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:) :: hfArray private subroutine ReadArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) private subroutine ReadArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:) :: hfArray private subroutine ReadArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) private subroutine ReadArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:,:) :: hfArray private subroutine ReadArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(inout), dimension(:,:,:,:,:) :: hfArray private subroutine ReadAttribute_HDF5_character (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(out) :: attribute private subroutine ReadAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(out) :: attribute private subroutine ReadAttribute_HDF5_real (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(out) :: attribute private subroutine WriteArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:) :: hfArray private subroutine WriteArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:,:) :: hfArray private subroutine WriteArray_HDF5_int32_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:,:,:) :: hfArray private subroutine WriteArray_HDF5_int32_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName integer(kind=int32), intent(in), dimension(:,:,:,:) :: hfArray private subroutine WriteArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:) :: hfArray private subroutine WriteArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:) :: hfArray private subroutine WriteArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:) :: hfArray private subroutine WriteArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:,:) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) private subroutine WriteArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:,:) :: hfArray private subroutine WriteArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName real(kind=prec), intent(in), dimension(:,:,:,:,:) :: hfArray private subroutine WriteAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(in) :: attribute private subroutine WriteCharacter_HDF5_serial (fileId, name, hfField) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character(len=*), intent(in) :: name character(len=*), intent(in) :: hfField","tags":"","loc":"module/self_hdf5.html"},{"title":"SELF_Vector_2D_t – SELF","text":"Uses HDF5 SELF_Lagrange SELF_HDF5 SELF_Data FEQParse iso_c_binding SELF_Metadata SELF_Constants Contents Derived Types Vector2D_t Subroutines AverageSides_Vector2D_t BoundaryInterp_Vector2D_t Divergence_Vector2D_t Free_Vector2D_t Gradient_Vector2D_t GridInterp_Vector2D_t Init_Vector2D_t SetEquation_Vector2D_t UpdateDevice_Vector2D_t UpdateHost_Vector2D_t WriteHDF5_MPI_Vector2D_t WriteHDF5_Vector2D_t Derived Types type, public, extends( SELF_DataObj ) :: Vector2D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundaryNormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Vector2D_t procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D_t generic, public :: Divergence => Divergence_Vector2D_t procedure, private :: Divergence_Vector2D_t procedure, public :: Free => Free_Vector2D_t generic, public :: Gradient => Gradient_Vector2D_t procedure, private :: Gradient_Vector2D_t generic, public :: GridInterp => GridInterp_Vector2D_t procedure, private :: GridInterp_Vector2D_t procedure, public :: Init => Init_Vector2D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector2D_t procedure, private :: SetEquation_Vector2D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Vector2D_t procedure, public :: UpdateHost => UpdateHost_Vector2D_t generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D_t, WriteHDF5_Vector2D_t procedure, private :: WriteHDF5_MPI_Vector2D_t procedure, private :: WriteHDF5_Vector2D_t Subroutines public subroutine AverageSides_Vector2D_t (this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this public subroutine BoundaryInterp_Vector2D_t (this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this public subroutine Divergence_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Free_Vector2D_t (this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this public subroutine Gradient_Vector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2,1:2) public subroutine GridInterp_Vector2D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:2) public subroutine Init_Vector2D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine SetEquation_Vector2D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine UpdateDevice_Vector2D_t (this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this public subroutine UpdateHost_Vector2D_t (this) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(inout) :: this public subroutine WriteHDF5_MPI_Vector2D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector2D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector2D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group","tags":"","loc":"module/self_vector_2d_t.html"},{"title":"self_NullDGModel2D_t – SELF","text":"Uses SELF_DGModel2D SELF_Mesh SELF_Model Contents Derived Types NullDGModel2D_t Derived Types type, public, extends( DGModel2D ) :: NullDGModel2D_t Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D procedure, public :: CalculateTendency => CalculateTendency_DGModel2D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel2D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel2D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel2D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel2D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D procedure, public :: SetMetadata => SetMetadata_DGModel2D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t, SetSolutionFromEqn_DGModel2D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel2D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D procedure, public :: UpdateSolution => UpdateSolution_DGModel2D procedure, public :: WriteModel => Write_DGModel2D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_nulldgmodel2d_t.html"},{"title":"self_Burgers1D_t – SELF","text":"Uses SELF_Mesh SELF_Model SELF_DGModel1D Contents Derived Types Burgers1D_t Functions entropy_func_Burgers1D_t flux1d_Burgers1D_t riemannflux1d_Burgers1D_t Subroutines SetMetadata_Burgers1D_t Derived Types type, public, extends( DGModel1D ) :: Burgers1D_t Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh real(kind=prec), public :: nu = 0.0_prec integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D procedure, public :: CalculateTendency => CalculateTendency_DGModel1D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel1D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel1D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel1D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel1D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D procedure, public :: SetMetadata => SetMetadata_Burgers1D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t, SetSolutionFromEqn_DGModel1D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel1D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D procedure, public :: UpdateSolution => UpdateSolution_DGModel1D procedure, public :: WriteModel => Write_DGModel1D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t procedure, public :: entropy_func => entropy_func_Burgers1D_t procedure, public :: flux1d => flux1d_Burgers1D_t procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Burgers1D_t procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model Functions public pure function entropy_func_Burgers1D_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) public pure function flux1d_Burgers1D_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) Return Value real(kind=prec)(1:this%solution%nvar) public pure function riemannflux1d_Burgers1D_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%solution%nvar) real(kind=prec), intent(in) :: sR (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%solution%nvar) Subroutines public subroutine SetMetadata_Burgers1D_t (this) Arguments Type Intent Optional Attributes Name class( Burgers1D_t ), intent(inout) :: this","tags":"","loc":"module/self_burgers1d_t.html"},{"title":"SELF_Mesh – SELF","text":"Uses SELF_DomainDecomposition SELF_Constants iso_c_binding Contents Variables SELF_BC_NONORMALFLOW SELF_BC_NOSTRESS SELF_BC_PRESCRIBED SELF_BC_PRESCRIBED_STRESS SELF_BC_RADIATION SELF_MESH_HOPR_2D SELF_MESH_HOPR_3D SELF_MESH_ISM_V2_2D SELF_MESH_ISM_V2_3D selfHexahedronBilinear selfHexahedronLinear selfHexahedronNonlinear selfLineLinear selfLineNonlinear selfPrismBilinear selfPrismLinear selfPrismNonlinear selfPyramidBilinear selfPyramidLinear selfPyramidNonlinear selfQuadBilinear selfQuadLinear selfQuadNonlinear selfTetrahedronLinear selfTetrahedronNonlinear selfTriangleLinear selfTriangleNonlinear self_BCDefault self_nBCsDefault Derived Types SEMMesh Variables Type Visibility Attributes Name Initial integer, public, parameter :: SELF_BC_NONORMALFLOW = 102 integer, public, parameter :: SELF_BC_NOSTRESS = 201 integer, public, parameter :: SELF_BC_PRESCRIBED = 100 integer, public, parameter :: SELF_BC_PRESCRIBED_STRESS = 200 integer, public, parameter :: SELF_BC_RADIATION = 101 integer, public, parameter :: SELF_MESH_HOPR_2D = 3 integer, public, parameter :: SELF_MESH_HOPR_3D = 4 integer, public, parameter :: SELF_MESH_ISM_V2_2D = 1 integer, public, parameter :: SELF_MESH_ISM_V2_3D = 2 integer, public, parameter :: selfHexahedronBilinear = 118 integer, public, parameter :: selfHexahedronLinear = 108 integer, public, parameter :: selfHexahedronNonlinear = 208 integer, public, parameter :: selfLineLinear = 1 integer, public, parameter :: selfLineNonlinear = 2 integer, public, parameter :: selfPrismBilinear = 116 integer, public, parameter :: selfPrismLinear = 106 integer, public, parameter :: selfPrismNonlinear = 206 integer, public, parameter :: selfPyramidBilinear = 115 integer, public, parameter :: selfPyramidLinear = 105 integer, public, parameter :: selfPyramidNonlinear = 205 integer, public, parameter :: selfQuadBilinear = 14 integer, public, parameter :: selfQuadLinear = 4 integer, public, parameter :: selfQuadNonlinear = 24 integer, public, parameter :: selfTetrahedronLinear = 104 integer, public, parameter :: selfTetrahedronNonlinear = 204 integer, public, parameter :: selfTriangleLinear = 3 integer, public, parameter :: selfTriangleNonlinear = 23 integer, public, parameter :: self_BCDefault = 1 integer, public, parameter :: self_nBCsDefault = 5 Derived Types type, public :: SEMMesh Components Type Visibility Attributes Name Initial type( DomainDecomposition ), public :: decomp integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides integer, public :: quadrature","tags":"","loc":"module/self_mesh.html"},{"title":"SELF_Lagrange_t – SELF","text":"Uses HDF5 SELF_Quadrature SELF_HDF5 iso_fortran_env SELF_SupportRoutines iso_c_binding SELF_Constants Contents Derived Types Lagrange_t Functions CalculateLagrangePolynomials Subroutines CalculateBarycentricWeights CalculateDerivativeMatrix CalculateInterpolationMatrix Free_Lagrange_t Init_Lagrange_t WriteHDF5_Lagrange_t Derived Types type, public :: Lagrange_t A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions.\nThe Lagrange data-structure stores the information necessary to interpolate between two\nsets of grid-points and to estimate the derivative of data at native grid points. Routines for\nmultidimensional interpolation are based on the tensor product of 1-D interpolants. It is\nassumed that the polynomial degree (and the interpolation nodes) are the same in each direction.\nThis assumption permits the storage of only one array of interpolation nodes and barycentric\nweights and is what allows this data structure to be flexible. Components Type Visibility Attributes Name Initial integer, public :: M The number of target points. integer, public :: N The number of control points. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: bMatrix The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. real(kind=prec), public, pointer, contiguous, dimension(:) :: bWeights The barycentric weights that are calculated from the controlPoints and used for interpolation. type(c_ptr), public :: blas_handle = c_null_ptr A handle for working with hipblas integer, public :: controlNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: controlPoints The set of nodes in one dimension where data is known.\nTo create higher dimension interpolation and differentiation operators, structured grids in two and three\ndimensions are created by tensor products of the controlPoints. This design decision implies that all\nspectral element methods supported by the Lagrange class have the same polynomial degree in each\ncomputational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto,\nLegendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over\nthe domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of\nthese quadrature types or uniform points on [-1,1]. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The\ndMatrix is based on a strong form of the derivative. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dgMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based\non a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: iMatrix The interpolation matrix (transpose) for mapping data from the control grid to the target grid. real(kind=prec), public, pointer, contiguous, dimension(:) :: qWeights The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints\nprovided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss,\nChebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant . integer, public :: targetNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: targetPoints The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation\nand differentiation operators, structured grids in two and three dimensions are created by tensor products of\nthe targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1]\n(computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. Type-Bound Procedures procedure, public :: CalculateBarycentricWeights procedure, public :: CalculateDerivativeMatrix procedure, public :: CalculateInterpolationMatrix procedure, public :: CalculateLagrangePolynomials procedure, public :: Free => Free_Lagrange_t procedure, public :: Init => Init_Lagrange_t procedure, public :: WriteHDF5 => WriteHDF5_Lagrange_t Functions public function CalculateLagrangePolynomials (this, sE) result(lAtS) Arguments Type Intent Optional Attributes Name class( Lagrange_t ) :: this real(kind=prec) :: sE Return Value real(kind=prec)(0:this%N) Subroutines public subroutine CalculateBarycentricWeights (this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this public subroutine CalculateDerivativeMatrix (this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this public subroutine CalculateInterpolationMatrix (this) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this public subroutine Free_Lagrange_t (this) Frees all memory (host and device) associated with an instance of the Lagrange_t class Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(inout) :: this Lagrange_t class instance public subroutine Init_Lagrange_t (this, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange_t class\nOn output, all of the attributes for the Lagrange_t class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange_t attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(out) :: this Lagrange_t class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) public subroutine WriteHDF5_Lagrange_t (this, fileId) Arguments Type Intent Optional Attributes Name class( Lagrange_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId","tags":"","loc":"module/self_lagrange_t.html"},{"title":"SELF_MappedVector_2D_t – SELF","text":"Uses SELF_Geometry_2D SELF_Lagrange SELF_Tensor_2D SELF_DomainDecomposition iso_c_binding SELF_Vector_2D FEQParse SELF_Constants SELF_Mesh_2D Contents Derived Types MappedVector2D_t Subroutines ApplyFlip_MappedVector2D_t AssociateGeometry_MappedVector2D_t DissociateGeometry_MappedVector2D_t MPIExchangeAsync_MappedVector2D_t MappedDGDivergence_MappedVector2D_t MappedDivergence_MappedVector2D_t SetInteriorFromEquation_MappedVector2D_t SideExchange_MappedVector2D_t Derived Types type, public, extends( Vector2D ) :: MappedVector2D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMQuad ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedVector2D_t procedure, public :: AssociateGeometry => AssociateGeometry_MappedVector2D_t procedure, public :: AverageSides => AverageSides_Vector2D procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D procedure, public :: DissociateGeometry => DissociateGeometry_MappedVector2D_t generic, public :: Divergence => Divergence_Vector2D_t, Divergence_Vector2D procedure, public :: Free => Free_Vector2D generic, public :: Gradient => Gradient_Vector2D_t, Gradient_Vector2D generic, public :: GridInterp => GridInterp_Vector2D_t, GridInterp_Vector2D procedure, public :: Init => Init_Vector2D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D_t generic, public :: MappedDGDivergence => MappedDGDivergence_MappedVector2D_t procedure, private :: MappedDGDivergence_MappedVector2D_t generic, public :: MappedDivergence => MappedDivergence_MappedVector2D_t procedure, private :: MappedDivergence_MappedVector2D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector2D_t procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector2D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedVector2D_t procedure, public :: UpdateDevice => UpdateDevice_Vector2D procedure, public :: UpdateHost => UpdateHost_Vector2D generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D_t, WriteHDF5_Vector2D_t Subroutines public subroutine ApplyFlip_MappedVector2D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( Mesh2D ), intent(in) :: mesh public subroutine AssociateGeometry_MappedVector2D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( SEMQuad ), intent(in), target :: geometry public subroutine DissociateGeometry_MappedVector2D_t (this) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this public subroutine MPIExchangeAsync_MappedVector2D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh public subroutine MappedDGDivergence_MappedVector2D_t (this, df) Computes the divergence of a 2-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(in) :: this real(kind=prec) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine MappedDivergence_MappedVector2D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine SetInteriorFromEquation_MappedVector2D_t (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time public subroutine SideExchange_MappedVector2D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D_t ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh","tags":"","loc":"module/self_mappedvector_2d_t.html"},{"title":"SELF_Vector_3D_t – SELF","text":"Uses HDF5 SELF_Lagrange SELF_HDF5 SELF_Data FEQParse iso_c_binding SELF_Metadata SELF_Constants Contents Derived Types Vector3D_t Subroutines AverageSides_Vector3D_t BoundaryInterp_Vector3D_t Curl_Vector3D_t Divergence_Vector3D_t Free_Vector3D_t Gradient_Vector3D_t GridInterp_Vector3D_t Init_Vector3D_t SetEquation_Vector3D_t UpdateDevice_Vector3D_t UpdateHost_Vector3D_t WriteHDF5_MPI_Vector3D_t WriteHDF5_Vector3D_t Derived Types type, public, extends( SELF_DataObj ) :: Vector3D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: avgBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundaryNormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Vector3D_t procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D_t generic, public :: Curl => Curl_Vector3D_t procedure, private :: Curl_Vector3D_t generic, public :: Divergence => Divergence_Vector3D_t procedure, private :: Divergence_Vector3D_t procedure, public :: Free => Free_Vector3D_t generic, public :: Gradient => Gradient_Vector3D_t procedure, private :: Gradient_Vector3D_t generic, public :: GridInterp => GridInterp_Vector3D_t procedure, private :: GridInterp_Vector3D_t procedure, public :: Init => Init_Vector3D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector3D_t procedure, private :: SetEquation_Vector3D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Vector3D_t procedure, public :: UpdateHost => UpdateHost_Vector3D_t generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D_t, WriteHDF5_Vector3D_t procedure, private :: WriteHDF5_MPI_Vector3D_t procedure, private :: WriteHDF5_Vector3D_t Subroutines public subroutine AverageSides_Vector3D_t (this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this public subroutine BoundaryInterp_Vector3D_t (this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this public subroutine Curl_Vector3D_t (this, curlf) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: curlf (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) public subroutine Divergence_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Free_Vector3D_t (this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this public subroutine Gradient_Vector3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3,1:3) public subroutine GridInterp_Vector3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:3) (Output) Array of function values, defined on the target grid public subroutine Init_Vector3D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine SetEquation_Vector3D_t (this, idir, ivar, eqnChar) Sets the equation parser for the idir direction and ivar-th variable Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this integer, intent(in) :: idir integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine UpdateDevice_Vector3D_t (this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this public subroutine UpdateHost_Vector3D_t (this) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(inout) :: this public subroutine WriteHDF5_MPI_Vector3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Vector3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Vector3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group","tags":"","loc":"module/self_vector_3d_t.html"},{"title":"SELF_Scalar_3D_t – SELF","text":"Uses HDF5 SELF_Lagrange SELF_HDF5 SELF_Data FEQParse iso_c_binding SELF_Metadata SELF_Constants Contents Derived Types Scalar3D_t Subroutines AverageSides_Scalar3D_t BoundaryInterp_Scalar3D_t Free_Scalar3D_t Gradient_Scalar3D_t GridInterp_Scalar3D_t Init_Scalar3D_t UpdateDevice_Scalar3D_t UpdateHost_Scalar3D_t WriteHDF5_MPI_Scalar3D_t WriteHDF5_Scalar3D_t Derived Types type, public, extends( SELF_DataObj ) :: Scalar3D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundarynormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar3D_t procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D_t procedure, public :: Free => Free_Scalar3D_t generic, public :: Gradient => Gradient_Scalar3D_t procedure, private :: Gradient_Scalar3D_t generic, public :: GridInterp => GridInterp_Scalar3D_t procedure, private :: GridInterp_Scalar3D_t procedure, public :: Init => Init_Scalar3D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Scalar3D_t procedure, public :: UpdateHost => UpdateHost_Scalar3D_t generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D_t, WriteHDF5_Scalar3D_t procedure, private :: WriteHDF5_MPI_Scalar3D_t procedure, private :: WriteHDF5_Scalar3D_t Subroutines public subroutine AverageSides_Scalar3D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this public subroutine BoundaryInterp_Scalar3D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this public subroutine Free_Scalar3D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this public subroutine Gradient_Scalar3D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) public subroutine GridInterp_Scalar3D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: f (1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) (Output) Array of function values, defined on the target grid public subroutine Init_Scalar3D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine UpdateDevice_Scalar3D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this public subroutine UpdateHost_Scalar3D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(inout) :: this public subroutine WriteHDF5_MPI_Scalar3D_t (this, fileId, group, elemoffset, nglobalelem) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group integer, intent(in) :: elemoffset integer, intent(in) :: nglobalelem public subroutine WriteHDF5_Scalar3D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar3D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group","tags":"","loc":"module/self_scalar_3d_t.html"},{"title":"SELF_Tensor_2D_t – SELF","text":"Uses HDF5 SELF_Lagrange SELF_HDF5 SELF_Data FEQParse iso_c_binding SELF_Metadata SELF_Constants Contents Derived Types Tensor2D_t Subroutines BoundaryInterp_Tensor2D_t Determinant_Tensor2D_t Free_Tensor2D_t Init_Tensor2D_t UpdateDevice_Tensor2D_t UpdateHost_Tensor2D_t Derived Types type, public, extends( SELF_DataObj ) :: Tensor2D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor2D_t generic, public :: Determinant => Determinant_Tensor2D_t procedure, private :: Determinant_Tensor2D_t procedure, public :: Free => Free_Tensor2D_t procedure, public :: Init => Init_Tensor2D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Tensor2D_t procedure, public :: UpdateHost => UpdateHost_Tensor2D_t Subroutines public subroutine BoundaryInterp_Tensor2D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this public subroutine Determinant_Tensor2D_t (this, det) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(in) :: this real(kind=prec), intent(out) :: det (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Free_Tensor2D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this public subroutine Init_Tensor2D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine UpdateDevice_Tensor2D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this public subroutine UpdateHost_Tensor2D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor2D_t ), intent(inout) :: this","tags":"","loc":"module/self_tensor_2d_t.html"},{"title":"SELF_Quadrature – SELF","text":"Uses iso_fortran_env SELF_Constants Contents Subroutines ChebyshevGauss ChebyshevGaussLobatto ChebyshevQuadrature LegendreGauss LegendreGaussLobatto LegendrePolynomial LegendreQandL LegendreQuadrature Subroutines private subroutine ChebyshevGauss (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) private subroutine ChebyshevGaussLobatto (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) public subroutine ChebyshevQuadrature (N, nodes, weights, QuadType) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=prec), intent(out) :: nodes (0:N) real(kind=prec), intent(out) :: weights (0:N) integer, intent(in) :: QuadType private subroutine LegendreGauss (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) private subroutine LegendreGaussLobatto (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) public subroutine LegendrePolynomial (N, x, lAtX, dLdxAtX) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: lAtX real(kind=real64) :: dLdxAtX private subroutine LegendreQandL (N, x, q, qprime, lN) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: q real(kind=real64) :: qprime real(kind=real64) :: lN public subroutine LegendreQuadrature (N, nodes, weights, QuadType) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=prec), intent(out) :: nodes (0:N) real(kind=prec), intent(out) :: weights (0:N) integer, intent(in) :: QuadType","tags":"","loc":"module/self_quadrature.html"},{"title":"SELF_Data – SELF","text":"Uses HDF5 SELF_Lagrange SELF_HDF5 FEQParse iso_c_binding SELF_Metadata SELF_Constants Contents Variables selfStrongForm selfWeakBRForm selfWeakCGForm selfWeakDGForm Derived Types SELF_DataObj Subroutines SetDescription_DataObj SetEquation_DataObj SetName_DataObj SetUnits_DataObj Variables Type Visibility Attributes Name Initial integer, public, parameter :: selfStrongForm = 0 integer, public, parameter :: selfWeakBRForm = 3 integer, public, parameter :: selfWeakCGForm = 2 integer, public, parameter :: selfWeakDGForm = 1 Derived Types type, public :: SELF_DataObj The SELF_DataObj class is a base class for all data objects in SELF.\nA data object in SELF is a multidimensional array of data, represented\non both host and device, that is associated with an interpolant, metadata,\nand (optionally) an equation string.\nType extensions of the SELF_DataObj include scalars, vectors, and tensors\nin 1-D, 2-D, and 3-D using the storage patterns that are expected for\nderivative and interpolation operations defined in SELF_Lagrange.f90\nAdditionally, each extended type has the necessary attributes to store\ninformation on element interiors and element boundaries, both of which\nare commonly used for spectral element solvers. Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(EquationParser), public, allocatable :: eqn (:) type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, private :: SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj Subroutines public subroutine SetDescription_DataObj (this, ivar, description) Set the description of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: description public subroutine SetEquation_DataObj (this, ivar, eqnChar) Sets the equation parser for the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: eqnChar public subroutine SetName_DataObj (this, ivar, name) Set the name of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: name public subroutine SetUnits_DataObj (this, ivar, units) Set the units of the ivar-th variable Arguments Type Intent Optional Attributes Name class( SELF_DataObj ), intent(inout) :: this integer, intent(in) :: ivar character, intent(in) :: units","tags":"","loc":"module/self_data.html"},{"title":"SELF_Mesh_1D – SELF","text":"Uses HDF5 SELF_Lagrange SELF_HDF5 SELF_Scalar_1D SELF_SupportRoutines SELF_Data iso_c_binding SELF_Mesh SELF_Constants Contents Derived Types Mesh1D Subroutines Free_Mesh1D Init_Mesh1D ResetBoundaryConditionType_Mesh1D UniformBlockMesh_Mesh1D Write_Mesh1D Derived Types type, public, extends( SEMMesh ) :: Mesh1D Components Type Visibility Attributes Name Initial character(len=255), public, allocatable :: BCNames (:) integer, public, pointer, dimension(:,:) :: BCType integer, public, dimension(2) :: bcid = 0 type( DomainDecomposition ), public :: decomp integer, public, pointer, dimension(:,:) :: elemInfo integer, public, pointer, dimension(:) :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides real(kind=prec), public, pointer, dimension(:) :: nodeCoords integer, public :: quadrature Type-Bound Procedures procedure, public :: Free => Free_Mesh1D procedure, public :: Init => Init_Mesh1D procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh1D generic, public :: StructuredMesh => UniformBlockMesh_Mesh1D procedure, private :: UniformBlockMesh_Mesh1D procedure, public :: Write_Mesh => Write_Mesh1D Subroutines public subroutine Free_Mesh1D (this) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: this public subroutine Init_Mesh1D (this, nElem, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: this integer, intent(in) :: nElem integer, intent(in) :: nNodes integer, intent(in) :: nBCs public subroutine ResetBoundaryConditionType_Mesh1D (this, leftbc, rightbc) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Read more… Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: this integer, intent(in) :: leftbc integer, intent(in) :: rightbc public subroutine UniformBlockMesh_Mesh1D (this, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: this integer, intent(in) :: nElem real(kind=prec), intent(in) :: x (1:2) public subroutine Write_Mesh1D (this, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: this character, intent(in) :: meshFile","tags":"","loc":"module/self_mesh_1d.html"},{"title":"self_NullDGModel3D_t – SELF","text":"Uses SELF_Mesh SELF_Model SELF_DGModel3D Contents Derived Types NullDGModel3D_t Derived Types type, public, extends( DGModel3D ) :: NullDGModel3D_t Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D procedure, public :: CalculateTendency => CalculateTendency_DGModel3D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel3D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel3D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel3D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel3D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D procedure, public :: SetMetadata => SetMetadata_DGModel3D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t, SetSolutionFromEqn_DGModel3D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel3D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D procedure, public :: UpdateSolution => UpdateSolution_DGModel3D procedure, public :: WriteModel => Write_DGModel3D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_nulldgmodel3d_t.html"},{"title":"SELF_Geometry_3D – SELF","text":"Uses SELF_Lagrange SELF_Mesh_3D SELF_SupportRoutines SELF_Data SELF_Scalar_3D SELF_Tensor_3D SELF_Vector_3D SELF_Constants Contents Derived Types SEMHex Subroutines CalculateContravariantBasis_SEMHex CalculateMetricTerms_SEMHex Free_SEMHex GenerateFromMesh_SEMHex Init_SEMHex Derived Types type, public :: SEMHex Components Type Visibility Attributes Name Initial type( Scalar3D ), public :: J type( Tensor3D ), public :: dsdx type( Tensor3D ), public :: dxds integer, public :: nElem type( Vector3D ), public :: nHat type( Scalar3D ), public :: nScale type( Vector3D ), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMHex procedure, public :: Free => Free_SEMHex procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMHex procedure, public :: Init => Init_SEMHex Subroutines public subroutine CalculateContravariantBasis_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine CalculateMetricTerms_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine Free_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine GenerateFromMesh_SEMHex (myGeom, mesh) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom type( Mesh3D ), intent(in) :: mesh public subroutine Init_SEMHex (myGeom, interp, nElem) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom type( Lagrange ), intent(in), pointer :: interp integer, intent(in) :: nElem","tags":"","loc":"module/self_geometry_3d.html"},{"title":"SELF_Mesh_3D_t – SELF","text":"Uses HDF5 SELF_Lagrange SELF_HDF5 SELF_SupportRoutines SELF_DomainDecomposition iso_c_binding SELF_Mesh SELF_Constants Contents Variables CGNStoSELFflip selfSide3D_Bottom selfSide3D_East selfSide3D_North selfSide3D_South selfSide3D_Top selfSide3D_West Derived Types Mesh3D_t Subroutines Free_Mesh3D_t Init_Mesh3D_t Read_HOPr_Mesh3D_t RecalculateFlip_Mesh3D_t ResetBoundaryConditionType_Mesh3D_t Write_Mesh3D_t Variables Type Visibility Attributes Name Initial integer, private :: CGNStoSELFflip (1:6,1:6,1:4) integer, public, parameter :: selfSide3D_Bottom = 1 integer, public, parameter :: selfSide3D_East = 3 integer, public, parameter :: selfSide3D_North = 4 integer, public, parameter :: selfSide3D_South = 2 integer, public, parameter :: selfSide3D_Top = 6 integer, public, parameter :: selfSide3D_West = 5 Derived Types type, public, extends( SEMMesh ) :: Mesh3D_t Components Type Visibility Attributes Name Initial character(len=255), public, allocatable :: BCNames (:) integer, public, pointer, dimension(:,:) :: BCType integer, public, pointer, dimension(:,:) :: CGNSCornerMap integer, public, pointer, dimension(:,:) :: CGNSSideMap type( DomainDecomposition ), public :: decomp integer, public, pointer, dimension(:,:) :: elemInfo integer, public, pointer, dimension(:,:,:,:) :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides real(kind=prec), public, pointer, dimension(:,:,:,:,:) :: nodeCoords integer, public :: quadrature integer, public, pointer, dimension(:,:,:) :: sideInfo integer, public, pointer, dimension(:,:) :: sideMap Type-Bound Procedures procedure, public :: Free => Free_Mesh3D_t procedure, public :: Init => Init_Mesh3D_t procedure, public :: Read_HOPr => Read_HOPr_Mesh3D_t procedure, public :: RecalculateFlip => RecalculateFlip_Mesh3D_t procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh3D_t procedure, public :: Write_Mesh => Write_Mesh3D_t Subroutines public subroutine Free_Mesh3D_t (this) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this public subroutine Init_Mesh3D_t (this, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs public subroutine Read_HOPr_Mesh3D_t (this, meshFile, enableDomainDecomposition) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(out) :: this character, intent(in) :: meshFile logical, intent(in), optional :: enableDomainDecomposition public subroutine RecalculateFlip_Mesh3D_t (this) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this public subroutine ResetBoundaryConditionType_Mesh3D_t (this, bcid) This method can be used to reset all of the boundary elements\nboundary condition type to the desired value. Read more… Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this integer, intent(in) :: bcid public subroutine Write_Mesh3D_t (this, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh3D_t ), intent(inout) :: this character, intent(in) :: meshFile","tags":"","loc":"module/self_mesh_3d_t.html"},{"title":"SELF_DomainDecomposition_t – SELF","text":"Uses SELF_Lagrange SELF_SupportRoutines mpi iso_c_binding SELF_Constants Contents Derived Types DomainDecomposition_t Subroutines DomainDecomp ElemToRank FinalizeMPIExchangeAsync Free_DomainDecomposition_t GenerateDecomposition_DomainDecomposition_t Init_DomainDecomposition_t SetElemToRank_DomainDecomposition_t Derived Types type, public :: DomainDecomposition_t Components Type Visibility Attributes Name Initial integer, public, pointer, dimension(:) :: elemToRank integer, public :: maxMsg integer, public :: mpiComm logical, public :: mpiEnabled integer, public :: mpiPrec integer, public :: msgCount integer, public :: nElem integer, public :: nRanks integer, public, pointer, dimension(:) :: offSetElem integer, public :: rankId integer, public, allocatable :: requests (:) integer, public, allocatable :: stats (:,:) Type-Bound Procedures procedure, public :: FinalizeMPIExchangeAsync procedure, public :: Free => Free_DomainDecomposition_t procedure, public :: GenerateDecomposition => GenerateDecomposition_DomainDecomposition_t procedure, public :: Init => Init_DomainDecomposition_t procedure, public :: SetElemToRank => SetElemToRank_DomainDecomposition_t Subroutines public subroutine DomainDecomp (nElems, nDomains, offsetElem) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nElems integer, intent(in) :: nDomains integer, intent(out) :: offsetElem (0:nDomains) public subroutine ElemToRank (nDomains, offsetElem, elemID, domain) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDomains integer, intent(in) :: offsetElem (0:nDomains) integer, intent(in) :: elemID integer, intent(out) :: domain public subroutine FinalizeMPIExchangeAsync (mpiHandler) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: mpiHandler public subroutine Free_DomainDecomposition_t (this) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this public subroutine GenerateDecomposition_DomainDecomposition_t (this, nGlobalElem, maxMsg) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this integer, intent(in) :: nGlobalElem integer, intent(in) :: maxMsg public subroutine Init_DomainDecomposition_t (this, enableMPI) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this logical, intent(in) :: enableMPI public subroutine SetElemToRank_DomainDecomposition_t (this, nElem) Arguments Type Intent Optional Attributes Name class( DomainDecomposition_t ), intent(inout) :: this integer, intent(in) :: nElem","tags":"","loc":"module/self_domaindecomposition_t.html"},{"title":"SELF_Tensor_3D_t – SELF","text":"Uses HDF5 SELF_Lagrange SELF_HDF5 SELF_Data FEQParse iso_c_binding SELF_Metadata SELF_Constants Contents Derived Types Tensor3D_t Subroutines BoundaryInterp_Tensor3D_t Determinant_Tensor3D_t Free_Tensor3D_t Init_Tensor3D_t UpdateDevice_Tensor3D_t UpdateHost_Tensor3D_t Derived Types type, public, extends( SELF_DataObj ) :: Tensor3D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: boundary type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor3D_t generic, public :: Determinant => Determinant_Tensor3D_t procedure, private :: Determinant_Tensor3D_t procedure, public :: Free => Free_Tensor3D_t procedure, public :: Init => Init_Tensor3D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Tensor3D_t procedure, public :: UpdateHost => UpdateHost_Tensor3D_t Subroutines public subroutine BoundaryInterp_Tensor3D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this public subroutine Determinant_Tensor3D_t (this, det) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(in) :: this real(kind=prec), intent(out) :: det (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Free_Tensor3D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this public subroutine Init_Tensor3D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine UpdateDevice_Tensor3D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this public subroutine UpdateHost_Tensor3D_t (this) Arguments Type Intent Optional Attributes Name class( Tensor3D_t ), intent(inout) :: this","tags":"","loc":"module/self_tensor_3d_t.html"},{"title":"self_advection_diffusion_1d_t – SELF","text":"Uses SELF_Mesh SELF_Model SELF_DGModel1D Contents Derived Types advection_diffusion_1d_t Functions entropy_func_advection_diffusion_1d_t flux1d_advection_diffusion_1d_t riemannflux1d_advection_diffusion_1d_t Derived Types type, public, extends( DGModel1D ) :: advection_diffusion_1d_t Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D procedure, public :: CalculateTendency => CalculateTendency_DGModel1D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel1D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel1D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel1D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel1D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D procedure, public :: SetMetadata => SetMetadata_DGModel1D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t, SetSolutionFromEqn_DGModel1D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel1D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D procedure, public :: UpdateSolution => UpdateSolution_DGModel1D procedure, public :: WriteModel => Write_DGModel1D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t procedure, public :: entropy_func => entropy_func_advection_diffusion_1d_t procedure, public :: flux1d => flux1d_advection_diffusion_1d_t procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_advection_diffusion_1d_t procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model Functions public pure function entropy_func_advection_diffusion_1d_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) public pure function flux1d_advection_diffusion_1d_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) Return Value real(kind=prec)(1:this%solution%nvar) public pure function riemannflux1d_advection_diffusion_1d_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%solution%nvar) real(kind=prec), intent(in) :: sR (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar) real(kind=prec), intent(in) :: nhat Return Value real(kind=prec)(1:this%solution%nvar)","tags":"","loc":"module/self_advection_diffusion_1d_t.html"},{"title":"SELF_DGModel1D_t – SELF","text":"Uses HDF5 SELF_HDF5 SELF_Mesh_1D SELF_SupportRoutines SELF_MappedScalar_1D FEQParse SELF_Model SELF_Metadata Contents Derived Types DGModel1D_t Subroutines BoundaryFlux_DGModel1D_t CalculateEntropy_DGModel1D_t CalculateSolutionGradient_DGModel1D_t CalculateTendency_DGModel1D_t Free_DGModel1D_t Init_DGModel1D_t Read_DGModel1D_t SetMetadata_DGModel1D_t SetSolutionFromChar_DGModel1D_t SetSolutionFromEqn_DGModel1D_t UpdateGRK2_DGModel1D_t UpdateGRK3_DGModel1D_t UpdateGRK4_DGModel1D_t UpdateSolution_DGModel1D_t WriteTecplot_DGModel1D_t Write_DGModel1D_t fluxmethod_DGModel1D_t setboundarycondition_DGModel1D_t setgradientboundarycondition_DGModel1D_t sourcemethod_DGModel1D_t Derived Types type, public, extends( Model ) :: DGModel1D_t Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D_t procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D_t procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D_t procedure, public :: CalculateTendency => CalculateTendency_DGModel1D_t procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel1D_t procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel1D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel1D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel1D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D_t procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D_t procedure, public :: SetMetadata => SetMetadata_DGModel1D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t, SetSolutionFromEqn_DGModel1D_t procedure, private :: SetSolutionFromChar_DGModel1D_t procedure, private :: SetSolutionFromEqn_DGModel1D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel1D_t procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D_t procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D_t procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D_t procedure, public :: UpdateSolution => UpdateSolution_DGModel1D_t procedure, public :: WriteModel => Write_DGModel1D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model Subroutines public subroutine BoundaryFlux_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this public subroutine CalculateEntropy_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this public subroutine CalculateSolutionGradient_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this public subroutine CalculateTendency_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this public subroutine Free_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this public subroutine Init_DGModel1D_t (this, nvar, mesh, geometry) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(out) :: this integer, intent(in) :: nvar type( Mesh1D ), intent(in), target :: mesh type( Geometry1D ), intent(in), target :: geometry public subroutine Read_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in) :: fileName public subroutine SetMetadata_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this public subroutine SetSolutionFromChar_DGModel1D_t (this, eqnChar) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character(len=SELF_EQUATION_LENGTH), intent(in) :: eqnChar (1:this%solution%nVar) public subroutine SetSolutionFromEqn_DGModel1D_t (this, eqn) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) public subroutine UpdateGRK2_DGModel1D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK3_DGModel1D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK4_DGModel1D_t (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateSolution_DGModel1D_t (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt public subroutine WriteTecplot_DGModel1D_t (this, filename) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: filename public subroutine Write_DGModel1D_t (this, fileName) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this character, intent(in), optional :: fileName public subroutine fluxmethod_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this public subroutine setboundarycondition_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this public subroutine setgradientboundarycondition_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this public subroutine sourcemethod_DGModel1D_t (this) Arguments Type Intent Optional Attributes Name class( DGModel1D_t ), intent(inout) :: this","tags":"","loc":"module/self_dgmodel1d_t.html"},{"title":"self_advection_diffusion_3d_t – SELF","text":"Uses SELF_Mesh SELF_Model SELF_DGModel3D Contents Derived Types advection_diffusion_3d_t Functions entropy_func_advection_diffusion_3d_t flux3d_advection_diffusion_3d_t riemannflux3d_advection_diffusion_3d_t Derived Types type, public, extends( DGModel3D ) :: advection_diffusion_3d_t Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v real(kind=prec), public :: w type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D procedure, public :: CalculateTendency => CalculateTendency_DGModel3D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel3D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel3D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel3D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel3D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D procedure, public :: SetMetadata => SetMetadata_DGModel3D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t, SetSolutionFromEqn_DGModel3D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel3D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D procedure, public :: UpdateSolution => UpdateSolution_DGModel3D procedure, public :: WriteModel => Write_DGModel3D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t procedure, public :: entropy_func => entropy_func_advection_diffusion_3d_t procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3d => flux3d_advection_diffusion_3d_t procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_advection_diffusion_3d_t procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model Functions public pure function entropy_func_advection_diffusion_3d_t (this, s) result(e) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) Return Value real(kind=prec) public pure function flux3d_advection_diffusion_3d_t (this, s, dsdx) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d_t ), intent(in) :: this real(kind=prec), intent(in) :: s (1:this%solution%nvar) real(kind=prec), intent(in) :: dsdx (1:this%solution%nvar,1:3) Return Value real(kind=prec)(1:this%solution%nvar,1:3) public pure function riemannflux3d_advection_diffusion_3d_t (this, sL, sR, dsdx, nhat) result(flux) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d_t ), intent(in) :: this real(kind=prec), intent(in) :: sL (1:this%nvar) real(kind=prec), intent(in) :: sR (1:this%nvar) real(kind=prec), intent(in) :: dsdx (1:this%nvar,1:3) real(kind=prec), intent(in) :: nhat (1:3) Return Value real(kind=prec)(1:this%nvar)","tags":"","loc":"module/self_advection_diffusion_3d_t.html"},{"title":"SELF_Scalar_1D_t – SELF","text":"Uses HDF5 SELF_Lagrange SELF_HDF5 SELF_Data FEQParse iso_c_binding SELF_Metadata SELF_Constants Contents Derived Types Scalar1D_t Subroutines AverageSides_Scalar1D_t BoundaryInterp_Scalar1D_t Derivative_Scalar1D_t Free_Scalar1D_t GridInterp_Scalar1D_t Init_Scalar1D_t UpdateDevice_Scalar1D_t UpdateHost_Scalar1D_t WriteHDF5_Scalar1D_t Derived Types type, public, extends( SELF_DataObj ) :: Scalar1D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: avgBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundarynormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar1D_t procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D_t generic, public :: Derivative => Derivative_Scalar1D_t procedure, private :: Derivative_Scalar1D_t procedure, public :: Free => Free_Scalar1D_t generic, public :: GridInterp => GridInterp_Scalar1D_t procedure, private :: GridInterp_Scalar1D_t procedure, public :: Init => Init_Scalar1D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Scalar1D_t procedure, public :: UpdateHost => UpdateHost_Scalar1D_t generic, public :: WriteHDF5 => WriteHDF5_Scalar1D_t procedure, private :: WriteHDF5_Scalar1D_t Subroutines public subroutine AverageSides_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this public subroutine BoundaryInterp_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this public subroutine Derivative_Scalar1D_t (this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: df (1:this%N+1,1:this%nelem,1:this%nvar) public subroutine Free_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this public subroutine GridInterp_Scalar1D_t (this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this real(kind=prec), intent(inout) :: f (1:this%M+1,1:this%nelem,1:this%nvar) public subroutine Init_Scalar1D_t (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine UpdateDevice_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this public subroutine UpdateHost_Scalar1D_t (this) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(inout) :: this public subroutine WriteHDF5_Scalar1D_t (this, fileId, group) Arguments Type Intent Optional Attributes Name class( Scalar1D_t ), intent(in) :: this integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: group","tags":"","loc":"module/self_scalar_1d_t.html"},{"title":"SELF_Constants – SELF","text":"Uses iso_fortran_env iso_c_binding Contents Variables CG CHEBYSHEV_GAUSS CHEBYSHEV_GAUSS_LOBATTO DG GAUSS GAUSS_LOBATTO MsgFmt SELF_EQN_DEFAULT_LENGTH SELF_FILE_DEFAULT_LENGTH TOL UNIFORM c_prec c_prec daysToMonths daysToSeconds fillValue fillValueInt hoursToDays maxInverseIters minutesToHours monthsToYears nada newtonMax newtonTolerance pi prec prec secondsToMinutes self_EquationLength self_FileNameLength self_FormatLength self_IntegratorTypeCharLength self_QuadratureTypeCharLength self_TecplotHeaderLength Variables Type Visibility Attributes Name Initial integer, public, parameter :: CG = 2001 integer, public, parameter :: CHEBYSHEV_GAUSS = 3 integer, public, parameter :: CHEBYSHEV_GAUSS_LOBATTO = 4 integer, public, parameter :: DG = 2000 integer, public, parameter :: GAUSS = 1 integer, public, parameter :: GAUSS_LOBATTO = 2 character(len=6), public, parameter :: MsgFmt = '(2x,A)' integer, public, parameter :: SELF_EQN_DEFAULT_LENGTH = 100 integer, public, parameter :: SELF_FILE_DEFAULT_LENGTH = 500 real(kind=prec), public, parameter :: TOL = epsilon(1.0_prec) integer, public, parameter :: UNIFORM = 5 integer, public, parameter :: c_prec = c_double integer, public, parameter :: c_prec = c_float real(kind=prec), public, parameter :: daysToMonths = 12.0_prec/365.25_prec real(kind=prec), public, parameter :: daysToSeconds = 86400.0_prec real(kind=prec), public, parameter :: fillValue = -9999.99_prec integer, public, parameter :: fillValueInt = -99999 real(kind=prec), public, parameter :: hoursToDays = 1.0_prec/24.0_prec integer, public, parameter :: maxInverseIters = 1000 real(kind=prec), public, parameter :: minutesToHours = 1.0_prec/60.0_prec real(kind=prec), public, parameter :: monthsToYears = 1.0_prec/12.0_prec character(len=1), public, parameter :: nada = ' ' integer, public, parameter :: newtonMax = 500 real(kind=prec), public, parameter :: newtonTolerance = 10.0**(-8) real(kind=prec), public, parameter :: pi = 4.0_prec*atan(1.0_prec) integer, public, parameter :: prec = c_double integer, public, parameter :: prec = c_float real(kind=prec), public, parameter :: secondsToMinutes = 1.0_prec/60.0_prec integer, public, parameter :: self_EquationLength = 210 integer, public, parameter :: self_FileNameLength = 500 integer, public, parameter :: self_FormatLength = 30 integer, public, parameter :: self_IntegratorTypeCharLength = 50 integer, public, parameter :: self_QuadratureTypeCharLength = 50 integer, public, parameter :: self_TecplotHeaderLength = 500","tags":"","loc":"module/self_constants.html"},{"title":"SELF_MappedScalar_2D_t – SELF","text":"Uses SELF_Geometry_2D SELF_Lagrange SELF_Tensor_2D SELF_Scalar_2D SELF_DomainDecomposition iso_c_binding FEQParse SELF_Constants SELF_Mesh_2D Contents Derived Types MappedScalar2D_t Subroutines ApplyFlip_MappedScalar2D_t AssociateGeometry_MappedScalar2D_t DissociateGeometry_MappedScalar2D_t MPIExchangeAsync_MappedScalar2D_t MappedDGGradient_MappedScalar2D_t MappedGradient_MappedScalar2D_t SetInteriorFromEquation_MappedScalar2D_t SideExchange_MappedScalar2D_t Derived Types type, public, extends( Scalar2D ) :: MappedScalar2D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMQuad ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedScalar2D_t procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar2D_t procedure, public :: AverageSides => AverageSides_Scalar2D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar2D_t procedure, public :: Free => Free_Scalar2D generic, public :: Gradient => Gradient_Scalar2D_t, Gradient_Scalar2D generic, public :: GridInterp => GridInterp_Scalar2D_t, GridInterp_Scalar2D procedure, public :: Init => Init_Scalar2D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D_t generic, public :: MappedDGGradient => MappedDGGradient_MappedScalar2D_t procedure, private :: MappedDGGradient_MappedScalar2D_t generic, public :: MappedGradient => MappedGradient_MappedScalar2D_t procedure, private :: MappedGradient_MappedScalar2D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar2D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedScalar2D_t procedure, public :: UpdateDevice => UpdateDevice_Scalar2D procedure, public :: UpdateHost => UpdateHost_Scalar2D generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D_t, WriteHDF5_Scalar2D_t Subroutines public subroutine ApplyFlip_MappedScalar2D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( Mesh2D ), intent(in) :: mesh public subroutine AssociateGeometry_MappedScalar2D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( SEMQuad ), intent(in), target :: geometry public subroutine DissociateGeometry_MappedScalar2D_t (this) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this public subroutine MPIExchangeAsync_MappedScalar2D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh public subroutine MappedDGGradient_MappedScalar2D_t (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) public subroutine MappedGradient_MappedScalar2D_t (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:2) public subroutine SetInteriorFromEquation_MappedScalar2D_t (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time public subroutine SideExchange_MappedScalar2D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D_t ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh","tags":"","loc":"module/self_mappedscalar_2d_t.html"},{"title":"SELF_MappedScalar_3D_t – SELF","text":"Uses SELF_Lagrange SELF_Geometry_3D SELF_Mesh_3D SELF_Scalar_3D SELF_Tensor_3D SELF_DomainDecomposition iso_c_binding FEQParse SELF_Constants Contents Derived Types MappedScalar3D_t Subroutines ApplyFlip_MappedScalar3D_t AssociateGeometry_MappedScalar3D_t DissociateGeometry_MappedScalar3D_t MPIExchangeAsync_MappedScalar3D_t MappedDGGradient_MappedScalar3D_t MappedGradient_MappedScalar3D_t SetInteriorFromEquation_MappedScalar3D_t SideExchange_MappedScalar3D_t Derived Types type, public, extends( Scalar3D ) :: MappedScalar3D_t Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMHex ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedScalar3D_t procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar3D_t procedure, public :: AverageSides => AverageSides_Scalar3D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar3D_t procedure, public :: Free => Free_Scalar3D generic, public :: Gradient => Gradient_Scalar3D_t, Gradient_Scalar3D generic, public :: GridInterp => GridInterp_Scalar3D_t, GridInterp_Scalar3D procedure, public :: Init => Init_Scalar3D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D_t generic, public :: MappedDGGradient => MappedDGGradient_MappedScalar3D_t procedure, private :: MappedDGGradient_MappedScalar3D_t generic, public :: MappedGradient => MappedGradient_MappedScalar3D_t procedure, private :: MappedGradient_MappedScalar3D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar3D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedScalar3D_t procedure, public :: UpdateDevice => UpdateDevice_Scalar3D procedure, public :: UpdateHost => UpdateHost_Scalar3D generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D_t, WriteHDF5_Scalar3D_t Subroutines public subroutine ApplyFlip_MappedScalar3D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh public subroutine AssociateGeometry_MappedScalar3D_t (this, geometry) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( SEMHex ), intent(in), target :: geometry public subroutine DissociateGeometry_MappedScalar3D_t (this) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this public subroutine MPIExchangeAsync_MappedScalar3D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh public subroutine MappedDGGradient_MappedScalar3D_t (this, df) Calculates the gradient of a function using the weak form of the gradient\nand the average boundary state.\nThis method will compute the average boundary state from the\nand  attributes of Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) public subroutine MappedGradient_MappedScalar3D_t (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(in) :: this real(kind=prec), intent(out) :: df (1:this%N+1,1:this%N+1,1:this%N+1,1:this%nelem,1:this%nvar,1:3) public subroutine SetInteriorFromEquation_MappedScalar3D_t (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time public subroutine SideExchange_MappedScalar3D_t (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D_t ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh","tags":"","loc":"module/self_mappedscalar_3d_t.html"},{"title":"self_NullDGModel3D – SELF","text":"Uses self_NullDGModel3D_t Contents Derived Types NullDGModel3D Derived Types type, public, extends( NullDGModel3D_t ) :: NullDGModel3D Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D procedure, public :: CalculateTendency => CalculateTendency_DGModel3D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel3D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel3D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel3D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel3D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D procedure, public :: SetMetadata => SetMetadata_DGModel3D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t, SetSolutionFromEqn_DGModel3D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel3D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D procedure, public :: UpdateSolution => UpdateSolution_DGModel3D procedure, public :: WriteModel => Write_DGModel3D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_nulldgmodel3d~2.html"},{"title":"SELF_MappedScalar_3D – SELF","text":"Uses SELF_GPU SELF_MappedScalar_3D_t SELF_GPUInterfaces iso_c_binding Contents Interfaces ContravariantWeight_3D_gpu NormalWeight_3D_gpu Derived Types MappedScalar3D Subroutines Free_MappedScalar3D Init_MappedScalar3D MPIExchangeAsync_MappedScalar3D MappedDGGradient_MappedScalar3D MappedGradient_MappedScalar3D SetInteriorFromEquation_MappedScalar3D SideExchange_MappedScalar3D Interfaces interface public subroutine ContravariantWeight_3D_gpu(f, dsdx, jaf, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: f type(c_ptr), value :: dsdx type(c_ptr), value :: jaf integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel interface public subroutine NormalWeight_3D_gpu(fb, nhat, nscale, fbn, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: fb type(c_ptr), value :: nhat type(c_ptr), value :: nscale type(c_ptr), value :: fbn integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel Derived Types type, public, extends( MappedScalar3D_t ) :: MappedScalar3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMHex ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type(c_ptr), public :: jas_gpu type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar3D_t procedure, public :: AverageSides => AverageSides_Scalar3D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar3D_t procedure, public :: Free => Free_MappedScalar3D generic, public :: Gradient => Gradient_Scalar3D_t, Gradient_Scalar3D generic, public :: GridInterp => GridInterp_Scalar3D_t, GridInterp_Scalar3D procedure, public :: Init => Init_MappedScalar3D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D generic, public :: MappedDGGradient => MappedDGGradient_MappedScalar3D_t, MappedDGGradient_MappedScalar3D procedure, private :: MappedDGGradient_MappedScalar3D generic, public :: MappedGradient => MappedGradient_MappedScalar3D_t, MappedGradient_MappedScalar3D procedure, private :: MappedGradient_MappedScalar3D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar3D procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedScalar3D procedure, public :: UpdateDevice => UpdateDevice_Scalar3D procedure, public :: UpdateHost => UpdateHost_Scalar3D generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D_t, WriteHDF5_Scalar3D_t Subroutines public subroutine Free_MappedScalar3D (this) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this public subroutine Init_MappedScalar3D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine MPIExchangeAsync_MappedScalar3D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh public subroutine MappedDGGradient_MappedScalar3D (this, df) Calculates the gradient of a function using the weak form of the gradient\nand the average boundary state.\nThis method will compute the average boundary state from the\nand  attributes of Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: this type(c_ptr), intent(inout) :: df public subroutine MappedGradient_MappedScalar3D (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this type(c_ptr), intent(out) :: df public subroutine SetInteriorFromEquation_MappedScalar3D (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time public subroutine SideExchange_MappedScalar3D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh","tags":"","loc":"module/self_mappedscalar_3d.html"},{"title":"SELF_Vector_3D – SELF","text":"Uses SELF_GPUBLAS SELF_Vector_3D_t SELF_GPUInterfaces iso_c_binding SELF_GPU SELF_Constants Contents Derived Types Vector3D Subroutines AverageSides_Vector3D BoundaryInterp_Vector3D Divergence_Vector3D Free_Vector3D Gradient_Vector3D GridInterp_Vector3D Init_Vector3D UpdateDevice_Vector3D UpdateHost_Vector3D Derived Types type, public, extends( Vector3D_t ) :: Vector3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Vector3D procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D generic, public :: Curl => Curl_Vector3D_t generic, public :: Divergence => Divergence_Vector3D_t, Divergence_Vector3D procedure, private :: Divergence_Vector3D procedure, public :: Free => Free_Vector3D generic, public :: Gradient => Gradient_Vector3D_t, Gradient_Vector3D procedure, private :: Gradient_Vector3D generic, public :: GridInterp => GridInterp_Vector3D_t, GridInterp_Vector3D procedure, private :: GridInterp_Vector3D procedure, public :: Init => Init_Vector3D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector3D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Vector3D procedure, public :: UpdateHost => UpdateHost_Vector3D generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D_t, WriteHDF5_Vector3D_t Subroutines public subroutine AverageSides_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this public subroutine BoundaryInterp_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this public subroutine Divergence_Vector3D (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df public subroutine Free_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this public subroutine Gradient_Vector3D (this, df) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df public subroutine GridInterp_Vector3D (this, f) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this type(c_ptr), intent(inout) :: f public subroutine Init_Vector3D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine UpdateDevice_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this public subroutine UpdateHost_Vector3D (this) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: this","tags":"","loc":"module/self_vector_3d~2.html"},{"title":"self_Burgers1D – SELF","text":"Uses self_Burgers1D_t Contents Derived Types Burgers1D Derived Types type, public, extends( Burgers1D_t ) :: Burgers1D Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh real(kind=prec), public :: nu = 0.0_prec integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D procedure, public :: CalculateTendency => CalculateTendency_DGModel1D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel1D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel1D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel1D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel1D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D procedure, public :: SetMetadata => SetMetadata_Burgers1D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t, SetSolutionFromEqn_DGModel1D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel1D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D procedure, public :: UpdateSolution => UpdateSolution_DGModel1D procedure, public :: WriteModel => Write_DGModel1D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t procedure, public :: entropy_func => entropy_func_Burgers1D_t procedure, public :: flux1d => flux1d_Burgers1D_t procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Burgers1D_t procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_burgers1d.html"},{"title":"SELF_Lagrange – SELF","text":"Uses SELF_Lagrange_t iso_fortran_env iso_c_binding SELF_GPU SELF_Constants Contents Derived Types Lagrange Subroutines Free_Lagrange Init_Lagrange Derived Types type, public, extends( Lagrange_t ) :: Lagrange Components Type Visibility Attributes Name Initial integer, public :: M The number of target points. integer, public :: N The number of control points. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: bMatrix The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. type(c_ptr), public :: bMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:) :: bWeights The barycentric weights that are calculated from the controlPoints and used for interpolation. character(len=3), public :: backend = 'gpu' type(c_ptr), public :: blas_handle = c_null_ptr A handle for working with hipblas integer, public :: controlNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: controlPoints The set of nodes in one dimension where data is known.\nTo create higher dimension interpolation and differentiation operators, structured grids in two and three\ndimensions are created by tensor products of the controlPoints. This design decision implies that all\nspectral element methods supported by the Lagrange class have the same polynomial degree in each\ncomputational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto,\nLegendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over\nthe domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of\nthese quadrature types or uniform points on [-1,1]. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The\ndMatrix is based on a strong form of the derivative. type(c_ptr), public :: dMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dgMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based\non a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. type(c_ptr), public :: dgMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:) :: iMatrix The interpolation matrix (transpose) for mapping data from the control grid to the target grid. type(c_ptr), public :: iMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:) :: qWeights The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints\nprovided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss,\nChebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant . type(c_ptr), public :: qWeights_gpu integer, public :: targetNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: targetPoints The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation\nand differentiation operators, structured grids in two and three dimensions are created by tensor products of\nthe targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1]\n(computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. Type-Bound Procedures procedure, public :: CalculateBarycentricWeights procedure, public :: CalculateDerivativeMatrix procedure, public :: CalculateInterpolationMatrix procedure, public :: CalculateLagrangePolynomials procedure, public :: Free => Free_Lagrange procedure, public :: Init => Init_Lagrange procedure, public :: WriteHDF5 => WriteHDF5_Lagrange_t Subroutines public subroutine Free_Lagrange (this) Frees all memory (host and device) associated with an instance of the Lagrange class Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: this Lagrange class instance public subroutine Init_Lagrange (this, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange class\nOn output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(out) :: this Lagrange class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3)","tags":"","loc":"module/self_lagrange.html"},{"title":"SELF_DomainDecomposition – SELF","text":"Uses mpi SELF_DomainDecomposition_t iso_c_binding Contents Derived Types DomainDecomposition Subroutines Free_DomainDecomposition SetElemToRank_DomainDecomposition Derived Types type, public, extends( DomainDecomposition_t ) :: DomainDecomposition Components Type Visibility Attributes Name Initial integer, public, pointer, dimension(:) :: elemToRank type(c_ptr), public :: elemToRank_gpu integer, public :: maxMsg integer, public :: mpiComm logical, public :: mpiEnabled integer, public :: mpiPrec integer, public :: msgCount integer, public :: nElem integer, public :: nRanks integer, public, pointer, dimension(:) :: offSetElem integer, public :: rankId integer, public, allocatable :: requests (:) integer, public, allocatable :: stats (:,:) Type-Bound Procedures procedure, public :: FinalizeMPIExchangeAsync procedure, public :: Free => Free_DomainDecomposition procedure, public :: GenerateDecomposition => GenerateDecomposition_DomainDecomposition_t procedure, public :: Init => Init_DomainDecomposition_t procedure, public :: SetElemToRank => SetElemToRank_DomainDecomposition Subroutines public subroutine Free_DomainDecomposition (this) Arguments Type Intent Optional Attributes Name class( DomainDecomposition ), intent(inout) :: this public subroutine SetElemToRank_DomainDecomposition (this, nElem) Arguments Type Intent Optional Attributes Name class( DomainDecomposition ), intent(inout) :: this integer, intent(in) :: nElem","tags":"","loc":"module/self_domaindecomposition~2.html"},{"title":"SELF_Mesh_2D – SELF","text":"Uses SELF_Mesh_2D_t SELF_GPU iso_c_binding Contents Derived Types Mesh2D Subroutines Free_Mesh2D Init_Mesh2D Read_HOPr_Mesh2D Derived Types type, public, extends( Mesh2D_t ) :: Mesh2D Components Type Visibility Attributes Name Initial character(len=255), public, allocatable :: BCNames (:) integer, public, pointer, dimension(:,:) :: BCType integer, public, pointer, dimension(:,:) :: CGNSCornerMap integer, public, pointer, dimension(:,:) :: CGNSSideMap type( DomainDecomposition ), public :: decomp integer, public, pointer, dimension(:,:) :: elemInfo integer, public, pointer, dimension(:,:,:) :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides real(kind=prec), public, pointer, dimension(:,:,:,:) :: nodeCoords integer, public :: quadrature integer, public, pointer, dimension(:,:,:) :: sideInfo type(c_ptr), public :: sideInfo_gpu Type-Bound Procedures procedure, public :: Free => Free_Mesh2D procedure, public :: Init => Init_Mesh2D procedure, public :: Read_HOPr => Read_HOPr_Mesh2D procedure, public :: RecalculateFlip => RecalculateFlip_Mesh2D_t procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh2D_t generic, public :: StructuredMesh => UniformStructuredMesh_Mesh2D_t procedure, public :: Write_Mesh => Write_Mesh2D_t Subroutines public subroutine Free_Mesh2D (this) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: this public subroutine Init_Mesh2D (this, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: this integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs public subroutine Read_HOPr_Mesh2D (this, meshFile, enableDomainDecomposition) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: this character, intent(in) :: meshFile logical, intent(in), optional :: enableDomainDecomposition","tags":"","loc":"module/self_mesh_2d~2.html"},{"title":"SELF_Scalar_1D – SELF","text":"Uses SELF_Scalar_1D_t SELF_GPUBLAS SELF_GPUInterfaces iso_c_binding SELF_GPU SELF_Constants Contents Derived Types Scalar1D Subroutines AverageSides_Scalar1D BoundaryInterp_Scalar1D Derivative_Scalar1D Free_Scalar1D GridInterp_Scalar1D Init_Scalar1D UpdateDevice_Scalar1D UpdateHost_Scalar1D Derived Types type, public, extends( Scalar1D_t ) :: Scalar1D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar1D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D generic, public :: Derivative => Derivative_Scalar1D_t, Derivative_Scalar1D procedure, private :: Derivative_Scalar1D procedure, public :: Free => Free_Scalar1D generic, public :: GridInterp => GridInterp_Scalar1D_t, GridInterp_Scalar1D procedure, private :: GridInterp_Scalar1D procedure, public :: Init => Init_Scalar1D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Scalar1D procedure, public :: UpdateHost => UpdateHost_Scalar1D generic, public :: WriteHDF5 => WriteHDF5_Scalar1D_t Subroutines public subroutine AverageSides_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this public subroutine BoundaryInterp_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this public subroutine Derivative_Scalar1D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: df public subroutine Free_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this public subroutine GridInterp_Scalar1D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: f public subroutine Init_Scalar1D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine UpdateDevice_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this public subroutine UpdateHost_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this","tags":"","loc":"module/self_scalar_1d.html"},{"title":"self_advection_diffusion_2d – SELF","text":"Uses self_advection_diffusion_2d_t Contents Interfaces boundaryflux_advection_diffusion_2d_gpu fluxmethod_advection_diffusion_2d_gpu setboundarycondition_advection_diffusion_2d_gpu setgradientboundarycondition_advection_diffusion_2d_gpu Derived Types advection_diffusion_2d Subroutines CalculateEntropy_advection_diffusion_2d boundaryflux_advection_diffusion_2d fluxmethod_advection_diffusion_2d setboundarycondition_advection_diffusion_2d setgradientboundarycondition_advection_diffusion_2d Interfaces interface public subroutine boundaryflux_advection_diffusion_2d_gpu(fb, fextb, dfavg, nhat, nscale, flux, u, v, nu, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: fb type(c_ptr), value :: fextb type(c_ptr), value :: dfavg type(c_ptr), value :: nhat type(c_ptr), value :: nscale type(c_ptr), value :: flux real(kind=c_prec), value :: u real(kind=c_prec), value :: v real(kind=c_prec), value :: nu integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar interface public subroutine fluxmethod_advection_diffusion_2d_gpu(solution, solutiongradient, flux, u, v, nu, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: solution type(c_ptr), value :: solutiongradient type(c_ptr), value :: flux real(kind=c_prec), value :: u real(kind=c_prec), value :: v real(kind=c_prec), value :: nu integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar interface public subroutine setboundarycondition_advection_diffusion_2d_gpu(extboundary, boundary, sideinfo, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extboundary type(c_ptr), value :: boundary type(c_ptr), value :: sideinfo integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar interface public subroutine setgradientboundarycondition_advection_diffusion_2d_gpu(extboundary, boundary, sideinfo, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extboundary type(c_ptr), value :: boundary type(c_ptr), value :: sideinfo integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar Derived Types type, public, extends( advection_diffusion_2d_t ) :: advection_diffusion_2d Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: CalculateEntropy => CalculateEntropy_advection_diffusion_2d procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D procedure, public :: CalculateTendency => CalculateTendency_DGModel2D procedure, public :: Euler_timeIntegrator procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel2D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel2D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel2D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetMetadata => SetMetadata_DGModel2D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t, SetSolutionFromEqn_DGModel2D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel2D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D procedure, public :: UpdateSolution => UpdateSolution_DGModel2D procedure, public :: WriteModel => Write_DGModel2D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t procedure, public :: boundaryflux => boundaryflux_advection_diffusion_2d procedure, public :: entropy_func => entropy_func_advection_diffusion_2d_t procedure, public :: flux1D => flux1d_Model procedure, public :: flux2d => flux2d_advection_diffusion_2d_t procedure, public :: flux3D => flux3d_Model procedure, public :: fluxmethod => fluxmethod_advection_diffusion_2d procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_advection_diffusion_2d_t procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: setboundarycondition => setboundarycondition_advection_diffusion_2d procedure, public :: setgradientboundarycondition => setgradientboundarycondition_advection_diffusion_2d procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model Subroutines public subroutine CalculateEntropy_advection_diffusion_2d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this public subroutine boundaryflux_advection_diffusion_2d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this public subroutine fluxmethod_advection_diffusion_2d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this public subroutine setboundarycondition_advection_diffusion_2d (this) Boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this public subroutine setgradientboundarycondition_advection_diffusion_2d (this) Gradient boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_2d ), intent(inout) :: this","tags":"","loc":"module/self_advection_diffusion_2d~2.html"},{"title":"SELF_DGModel2D – SELF","text":"Uses SELF_DGModel2D_t SELF_GPU SELF_GPUInterfaces Contents Derived Types DGModel2D Subroutines BoundaryFlux_DGModel2D CalculateEntropy_DGModel2D CalculateSolutionGradient_DGModel2D CalculateTendency_DGModel2D UpdateGRK2_DGModel2D UpdateGRK3_DGModel2D UpdateGRK4_DGModel2D UpdateSolution_DGModel2D fluxmethod_DGModel2D setboundarycondition_DGModel2D setgradientboundarycondition_DGModel2D sourcemethod_DGModel2D Derived Types type, public, extends( DGModel2D_t ) :: DGModel2D Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D procedure, public :: CalculateTendency => CalculateTendency_DGModel2D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel2D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel2D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel2D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel2D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D procedure, public :: SetMetadata => SetMetadata_DGModel2D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t, SetSolutionFromEqn_DGModel2D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel2D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D procedure, public :: UpdateSolution => UpdateSolution_DGModel2D procedure, public :: WriteModel => Write_DGModel2D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model Subroutines public subroutine BoundaryFlux_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this public subroutine CalculateEntropy_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this public subroutine CalculateSolutionGradient_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this public subroutine CalculateTendency_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this public subroutine UpdateGRK2_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK3_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK4_DGModel2D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateSolution_DGModel2D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt public subroutine fluxmethod_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this public subroutine setboundarycondition_DGModel2D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this public subroutine setgradientboundarycondition_DGModel2D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this public subroutine sourcemethod_DGModel2D (this) Arguments Type Intent Optional Attributes Name class( DGModel2D ), intent(inout) :: this","tags":"","loc":"module/self_dgmodel2d~2.html"},{"title":"self_advection_diffusion_1d – SELF","text":"Uses self_advection_diffusion_1d_t SELF_GPU SELF_DGModel1D Contents Interfaces boundaryflux_advection_diffusion_1d_gpu fluxmethod_advection_diffusion_1d_gpu setboundarycondition_advection_diffusion_1d_gpu Derived Types advection_diffusion_1d Subroutines boundaryflux_advection_diffusion_1d fluxmethod_advection_diffusion_1d setboundarycondition_advection_diffusion_1d setgradientboundarycondition_advection_diffusion_1d Interfaces interface public subroutine boundaryflux_advection_diffusion_1d_gpu(fb, fextb, dfavg, flux, u, nu, ndof) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: fb type(c_ptr), value :: fextb type(c_ptr), value :: dfavg type(c_ptr), value :: flux real(kind=c_prec), value :: u real(kind=c_prec), value :: nu integer(kind=c_int), value :: ndof interface public subroutine fluxmethod_advection_diffusion_1d_gpu(solution, solutiongradient, flux, u, nu, ndof) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: solution type(c_ptr), value :: solutiongradient type(c_ptr), value :: flux real(kind=c_prec), value :: u real(kind=c_prec), value :: nu integer(kind=c_int), value :: ndof interface public subroutine setboundarycondition_advection_diffusion_1d_gpu(extboundary, boundary, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extboundary type(c_ptr), value :: boundary integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar Derived Types type, public, extends( advection_diffusion_1d_t ) :: advection_diffusion_1d Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D procedure, public :: CalculateTendency => CalculateTendency_DGModel1D procedure, public :: Euler_timeIntegrator procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel1D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel1D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel1D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetMetadata => SetMetadata_DGModel1D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t, SetSolutionFromEqn_DGModel1D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel1D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D procedure, public :: UpdateSolution => UpdateSolution_DGModel1D procedure, public :: WriteModel => Write_DGModel1D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t procedure, public :: boundaryflux => boundaryflux_advection_diffusion_1d procedure, public :: entropy_func => entropy_func_advection_diffusion_1d_t procedure, public :: flux1d => flux1d_advection_diffusion_1d_t procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: fluxmethod => fluxmethod_advection_diffusion_1d procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_advection_diffusion_1d_t procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: setboundarycondition => setboundarycondition_advection_diffusion_1d procedure, public :: setgradientboundarycondition => setgradientboundarycondition_advection_diffusion_1d procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model Subroutines public subroutine boundaryflux_advection_diffusion_1d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this public subroutine fluxmethod_advection_diffusion_1d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this public subroutine setboundarycondition_advection_diffusion_1d (this) Boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this public subroutine setgradientboundarycondition_advection_diffusion_1d (this) Gradient boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_1d ), intent(inout) :: this","tags":"","loc":"module/self_advection_diffusion_1d.html"},{"title":"self_advection_diffusion_3d – SELF","text":"Uses self_advection_diffusion_3d_t Contents Interfaces boundaryflux_advection_diffusion_3d_gpu fluxmethod_advection_diffusion_3d_gpu setboundarycondition_advection_diffusion_3d_gpu setgradientboundarycondition_advection_diffusion_3d_gpu Derived Types advection_diffusion_3d Subroutines CalculateEntropy_advection_diffusion_3d boundaryflux_advection_diffusion_3d fluxmethod_advection_diffusion_3d setboundarycondition_advection_diffusion_3d setgradientboundarycondition_advection_diffusion_3d Interfaces interface public subroutine boundaryflux_advection_diffusion_3d_gpu(fb, fextb, dfavg, nhat, nscale, flux, u, v, w, nu, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: fb type(c_ptr), value :: fextb type(c_ptr), value :: dfavg type(c_ptr), value :: nhat type(c_ptr), value :: nscale type(c_ptr), value :: flux real(kind=c_prec), value :: u real(kind=c_prec), value :: v real(kind=c_prec), value :: w real(kind=c_prec), value :: nu integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar interface public subroutine fluxmethod_advection_diffusion_3d_gpu(solution, solutiongradient, flux, u, v, w, nu, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: solution type(c_ptr), value :: solutiongradient type(c_ptr), value :: flux real(kind=c_prec), value :: u real(kind=c_prec), value :: v real(kind=c_prec), value :: w real(kind=c_prec), value :: nu integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar interface public subroutine setboundarycondition_advection_diffusion_3d_gpu(extboundary, boundary, sideinfo, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extboundary type(c_ptr), value :: boundary type(c_ptr), value :: sideinfo integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar interface public subroutine setgradientboundarycondition_advection_diffusion_3d_gpu(extboundary, boundary, sideinfo, N, nel, nvar) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extboundary type(c_ptr), value :: boundary type(c_ptr), value :: sideinfo integer(kind=c_int), value :: N integer(kind=c_int), value :: nel integer(kind=c_int), value :: nvar Derived Types type, public, extends( advection_diffusion_3d_t ) :: advection_diffusion_3d Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v real(kind=prec), public :: w type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: CalculateEntropy => CalculateEntropy_advection_diffusion_3d procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D procedure, public :: CalculateTendency => CalculateTendency_DGModel3D procedure, public :: Euler_timeIntegrator procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel3D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel3D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel3D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetMetadata => SetMetadata_DGModel3D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t, SetSolutionFromEqn_DGModel3D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel3D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D procedure, public :: UpdateSolution => UpdateSolution_DGModel3D procedure, public :: WriteModel => Write_DGModel3D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t procedure, public :: boundaryflux => boundaryflux_advection_diffusion_3d procedure, public :: entropy_func => entropy_func_advection_diffusion_3d_t procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3d => flux3d_advection_diffusion_3d_t procedure, public :: fluxmethod => fluxmethod_advection_diffusion_3d procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_advection_diffusion_3d_t procedure, public :: setboundarycondition => setboundarycondition_advection_diffusion_3d procedure, public :: setgradientboundarycondition => setgradientboundarycondition_advection_diffusion_3d procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model Subroutines public subroutine CalculateEntropy_advection_diffusion_3d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this public subroutine boundaryflux_advection_diffusion_3d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this public subroutine fluxmethod_advection_diffusion_3d (this) Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this public subroutine setboundarycondition_advection_diffusion_3d (this) Boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this public subroutine setgradientboundarycondition_advection_diffusion_3d (this) Gradient boundary conditions are set to periodic boundary conditions Arguments Type Intent Optional Attributes Name class( advection_diffusion_3d ), intent(inout) :: this","tags":"","loc":"module/self_advection_diffusion_3d.html"},{"title":"SELF_GPU_enums – SELF","text":"Uses iso_c_binding Contents Enumerations Enumerations enum, bind(c) Enumerators enumerator :: hipSuccess = 0 enum, bind(c) Enumerators enumerator :: hipMemcpyHostToHost = 0 enumerator :: hipMemcpyHostToDevice = 1 enumerator :: hipMemcpyDeviceToHost = 2 enumerator :: hipMemcpyDeviceToDevice = 3 enumerator :: hipMemcpyDefault = 4 enum, bind(c) Enumerators enumerator :: HIPBLAS_STATUS_SUCCESS = 0 enumerator :: HIPBLAS_STATUS_NOT_INITIALIZED = 1 enumerator :: HIPBLAS_STATUS_ALLOC_FAILED = 2 enumerator :: HIPBLAS_STATUS_INVALID_VALUE = 3 enumerator :: HIPBLAS_STATUS_MAPPING_ERROR = 4 enumerator :: HIPBLAS_STATUS_EXECUTION_FAILED = 5 enumerator :: HIPBLAS_STATUS_INTERNAL_ERROR = 6 enumerator :: HIPBLAS_STATUS_NOT_SUPPORTED = 7 enumerator :: HIPBLAS_STATUS_ARCH_MISMATCH = 8 enumerator :: HIPBLAS_STATUS_HANDLE_IS_NULLPTR = 9 enumerator :: HIPBLAS_STATUS_INVALID_ENUM = 10 enumerator :: HIPBLAS_STATUS_UNKNOWN = 11 enum, bind(c) Enumerators enumerator :: HIPBLAS_OP_N = 0 enumerator :: HIPBLAS_OP_N = 111 enumerator :: HIPBLAS_OP_T = 1 enumerator :: HIPBLAS_OP_T = 112","tags":"","loc":"module/self_gpu_enums~2.html"},{"title":"self_NullDGModel1D – SELF","text":"Uses self_NullDGModel1D_t Contents Derived Types NullDGModel1D Derived Types type, public, extends( NullDGModel1D_t ) :: NullDGModel1D Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D procedure, public :: CalculateTendency => CalculateTendency_DGModel1D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel1D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel1D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel1D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel1D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D procedure, public :: SetMetadata => SetMetadata_DGModel1D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t, SetSolutionFromEqn_DGModel1D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel1D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D procedure, public :: UpdateSolution => UpdateSolution_DGModel1D procedure, public :: WriteModel => Write_DGModel1D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_nulldgmodel1d.html"},{"title":"SELF_DGModel1D – SELF","text":"Uses HDF5 SELF_HDF5 SELF_Mesh_1D SELF_SupportRoutines SELF_MappedScalar_1D SELF_GPU SELF_GPUInterfaces FEQParse SELF_Model SELF_Metadata SELF_DGModel1D_t Contents Derived Types DGModel1D Subroutines BoundaryFlux_DGModel1D CalculateEntropy_DGModel1D CalculateSolutionGradient_DGModel1D CalculateTendency_DGModel1D UpdateGRK2_DGModel1D UpdateGRK3_DGModel1D UpdateGRK4_DGModel1D UpdateSolution_DGModel1D fluxmethod_DGModel1D setboundarycondition_DGModel1D setgradientboundarycondition_DGModel1D sourcemethod_DGModel1D Derived Types type, public, extends( DGModel1D_t ) :: DGModel1D Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D procedure, public :: CalculateTendency => CalculateTendency_DGModel1D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel1D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel1D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel1D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel1D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D procedure, public :: SetMetadata => SetMetadata_DGModel1D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t, SetSolutionFromEqn_DGModel1D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel1D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D procedure, public :: UpdateSolution => UpdateSolution_DGModel1D procedure, public :: WriteModel => Write_DGModel1D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model Subroutines public subroutine BoundaryFlux_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this public subroutine CalculateEntropy_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this public subroutine CalculateSolutionGradient_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this public subroutine CalculateTendency_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this public subroutine UpdateGRK2_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK3_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK4_DGModel1D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateSolution_DGModel1D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt public subroutine fluxmethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this public subroutine setboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this public subroutine setgradientboundarycondition_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this public subroutine sourcemethod_DGModel1D (this) Arguments Type Intent Optional Attributes Name class( DGModel1D ), intent(inout) :: this","tags":"","loc":"module/self_dgmodel1d~2.html"},{"title":"SELF_MappedVector_3D – SELF","text":"Uses SELF_GPUBLAS SELF_MappedVector_3D_t SELF_GPUInterfaces iso_c_binding SELF_GPU Contents Interfaces ContravariantProjection_3D_gpu Derived Types MappedVector3D Subroutines MPIExchangeAsync_MappedVector3D MappedDGDivergence_MappedVector3D MappedDivergence_MappedVector3D SetInteriorFromEquation_MappedVector3D SideExchange_MappedVector3D Interfaces interface public subroutine ContravariantProjection_3D_gpu(f, dsdx, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: f type(c_ptr), value :: dsdx integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel Derived Types type, public, extends( MappedVector3D_t ) :: MappedVector3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMHex ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedVector3D_t procedure, public :: AverageSides => AverageSides_Vector3D procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D generic, public :: Curl => Curl_Vector3D_t procedure, public :: DissociateGeometry => DissociateGeometry_MappedVector3D_t generic, public :: Divergence => Divergence_Vector3D_t, Divergence_Vector3D procedure, public :: Free => Free_Vector3D generic, public :: Gradient => Gradient_Vector3D_t, Gradient_Vector3D generic, public :: GridInterp => GridInterp_Vector3D_t, GridInterp_Vector3D procedure, public :: Init => Init_Vector3D procedure, public :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D generic, public :: MappedDGDivergence => MappedDGDivergence_MappedVector3D_t, MappedDGDivergence_MappedVector3D procedure, private :: MappedDGDivergence_MappedVector3D generic, public :: MappedDivergence => MappedDivergence_MappedVector3D_t, MappedDivergence_MappedVector3D procedure, private :: MappedDivergence_MappedVector3D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector3D_t procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector3D procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedVector3D procedure, public :: UpdateDevice => UpdateDevice_Vector3D procedure, public :: UpdateHost => UpdateHost_Vector3D generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D_t, WriteHDF5_Vector3D_t Subroutines public subroutine MPIExchangeAsync_MappedVector3D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh public subroutine MappedDGDivergence_MappedVector3D (this, df) Computes the divergence of a 3-D vector using the weak form\nOn input, the  attribute of the vector\nis assigned and the  attribute is set to the physical\ndirections of the vector. This method will project the vector\nonto the contravariant basis vectors. Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df public subroutine MappedDivergence_MappedVector3D (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: this type(c_ptr), intent(inout) :: df public subroutine SetInteriorFromEquation_MappedVector3D (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: this type( SEMHex ), intent(in) :: geometry real(kind=prec), intent(in) :: time public subroutine SideExchange_MappedVector3D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: this type( Mesh3D ), intent(inout) :: mesh","tags":"","loc":"module/self_mappedvector_3d~2.html"},{"title":"SELF_GPU – SELF","text":"Uses SELF_GPU_enums iso_c_binding Contents Interfaces hipFree hipGetDeviceCount hipMalloc hipMemcpy Functions GPUAvailable Subroutines gpuCheck Interfaces public interface hipFree public function hipFree_(ptr) bind(c,name=\"hipFree\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Return Value integer(kind=kind(hipSuccess)) public interface hipGetDeviceCount public function hipGetDeviceCount_(count) bind(c,name=\"hipGetDeviceCount\") Arguments Type Intent Optional Attributes Name integer(kind=c_int) :: count Return Value integer(kind=kind(hipSuccess)) public interface hipMalloc public function hipMalloc_(ptr, mySize) bind(c,name=\"hipMalloc\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: ptr integer(kind=c_size_t), value :: mySize Return Value integer(kind=kind(hipSuccess)) public interface hipMemcpy public function hipMemcpy_(dest, src, sizeBytes, myKind) bind(c,name=\"hipMemcpy\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: dest type(c_ptr), value :: src integer(kind=c_size_t), value :: sizeBytes integer(kind=kind(hipMemcpyHostToHost)), value :: myKind Return Value integer(kind=kind(hipSuccess)) Functions public function GPUAvailable () result(avail) Arguments None Return Value logical Subroutines public subroutine gpuCheck (gpuError_t) Arguments Type Intent Optional Attributes Name integer(kind=kind(hipSuccess)) :: gpuError_t","tags":"","loc":"module/self_gpu~2.html"},{"title":"SELF_Mesh_3D – SELF","text":"Uses SELF_GPU SELF_Mesh_3D_t iso_c_binding Contents Derived Types Mesh3D Subroutines Free_Mesh3D Init_Mesh3D Read_HOPr_Mesh3D Derived Types type, public, extends( Mesh3D_t ) :: Mesh3D Components Type Visibility Attributes Name Initial character(len=255), public, allocatable :: BCNames (:) integer, public, pointer, dimension(:,:) :: BCType integer, public, pointer, dimension(:,:) :: CGNSCornerMap integer, public, pointer, dimension(:,:) :: CGNSSideMap type( DomainDecomposition ), public :: decomp integer, public, pointer, dimension(:,:) :: elemInfo integer, public, pointer, dimension(:,:,:,:) :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides real(kind=prec), public, pointer, dimension(:,:,:,:,:) :: nodeCoords integer, public :: quadrature integer, public, pointer, dimension(:,:,:) :: sideInfo type(c_ptr), public :: sideInfo_gpu integer, public, pointer, dimension(:,:) :: sideMap Type-Bound Procedures procedure, public :: Free => Free_Mesh3D procedure, public :: Init => Init_Mesh3D procedure, public :: Read_HOPr => Read_HOPr_Mesh3D procedure, public :: RecalculateFlip => RecalculateFlip_Mesh3D_t procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh3D_t procedure, public :: Write_Mesh => Write_Mesh3D_t Subroutines public subroutine Free_Mesh3D (this) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: this public subroutine Init_Mesh3D (this, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: this integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs public subroutine Read_HOPr_Mesh3D (this, meshFile, enableDomainDecomposition) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: this character, intent(in) :: meshFile logical, intent(in), optional :: enableDomainDecomposition","tags":"","loc":"module/self_mesh_3d.html"},{"title":"SELF_MappedScalar_1D – SELF","text":"Uses SELF_GPU SELF_MappedScalar_1D_t iso_c_binding Contents Interfaces DGDerivative_BoundaryContribution_1D_gpu JacobianWeight_1D_gpu Derived Types MappedScalar1D Subroutines MappedDGDerivative_MappedScalar1D MappedDerivative_MappedScalar1D SetInteriorFromEquation_MappedScalar1D SideExchange_MappedScalar1D Interfaces interface public subroutine DGDerivative_BoundaryContribution_1D_gpu(bMatrix, qWeights, bf, df, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: bMatrix type(c_ptr), value :: qWeights type(c_ptr), value :: bf type(c_ptr), value :: df integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl interface public subroutine JacobianWeight_1D_gpu(scalar, dxds, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: scalar type(c_ptr), value :: dxds integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl Derived Types type, public, extends( MappedScalar1D_t ) :: MappedScalar1D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( Geometry1D ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar1D_t procedure, public :: AverageSides => AverageSides_Scalar1D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D generic, public :: Derivative => Derivative_Scalar1D_t, Derivative_Scalar1D procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar1D_t procedure, public :: Free => Free_Scalar1D generic, public :: GridInterp => GridInterp_Scalar1D_t, GridInterp_Scalar1D procedure, public :: Init => Init_Scalar1D generic, public :: MappedDGDerivative => MappedDGDerivative_MappedScalar1D_t, MappedDGDerivative_MappedScalar1D procedure, private :: MappedDGDerivative_MappedScalar1D generic, public :: MappedDerivative => MappedDerivative_MappedScalar1D_t, MappedDerivative_MappedScalar1D procedure, private :: MappedDerivative_MappedScalar1D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar1D procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedScalar1D procedure, public :: UpdateDevice => UpdateDevice_Scalar1D procedure, public :: UpdateHost => UpdateHost_Scalar1D generic, public :: WriteHDF5 => WriteHDF5_Scalar1D_t Subroutines public subroutine MappedDGDerivative_MappedScalar1D (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: df public subroutine MappedDerivative_MappedScalar1D (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: this type(c_ptr), intent(inout) :: df public subroutine SetInteriorFromEquation_MappedScalar1D (this, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: this real(kind=prec), intent(in) :: time public subroutine SideExchange_MappedScalar1D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: this type( Mesh1D ), intent(inout) :: mesh","tags":"","loc":"module/self_mappedscalar_1d~2.html"},{"title":"SELF_Tensor_3D – SELF","text":"Uses SELF_GPUBLAS iso_fortran_env iso_c_binding SELF_Tensor_3D_t SELF_GPU SELF_Constants Contents Derived Types Tensor3D Subroutines Free_Tensor3D Init_Tensor3D UpdateDevice_Tensor3D UpdateHost_Tensor3D Derived Types type, public, extends( Tensor3D_t ) :: Tensor3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor3D_t generic, public :: Determinant => Determinant_Tensor3D_t procedure, public :: Free => Free_Tensor3D procedure, public :: Init => Init_Tensor3D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Tensor3D procedure, public :: UpdateHost => UpdateHost_Tensor3D Subroutines public subroutine Free_Tensor3D (this) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: this public subroutine Init_Tensor3D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine UpdateDevice_Tensor3D (this) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: this public subroutine UpdateHost_Tensor3D (this) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: this","tags":"","loc":"module/self_tensor_3d~2.html"},{"title":"self_NullDGModel2D – SELF","text":"Uses self_NullDGModel2D_t Contents Derived Types NullDGModel2D Derived Types type, public, extends( NullDGModel2D_t ) :: NullDGModel2D Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D procedure, public :: CalculateTendency => CalculateTendency_DGModel2D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel2D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel2D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel2D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel2D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D procedure, public :: SetMetadata => SetMetadata_DGModel2D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t, SetSolutionFromEqn_DGModel2D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel2D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D procedure, public :: UpdateSolution => UpdateSolution_DGModel2D procedure, public :: WriteModel => Write_DGModel2D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_nulldgmodel2d~2.html"},{"title":"SELF_Scalar_3D – SELF","text":"Uses SELF_GPUBLAS SELF_Scalar_3D_t SELF_GPUInterfaces iso_c_binding SELF_GPU SELF_Constants Contents Derived Types Scalar3D Subroutines AverageSides_Scalar3D BoundaryInterp_Scalar3D Free_Scalar3D Gradient_Scalar3D GridInterp_Scalar3D Init_Scalar3D UpdateDevice_Scalar3D UpdateHost_Scalar3D Derived Types type, public, extends( Scalar3D_t ) :: Scalar3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar3D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D procedure, public :: Free => Free_Scalar3D generic, public :: Gradient => Gradient_Scalar3D_t, Gradient_Scalar3D procedure, private :: Gradient_Scalar3D generic, public :: GridInterp => GridInterp_Scalar3D_t, GridInterp_Scalar3D procedure, private :: GridInterp_Scalar3D procedure, public :: Init => Init_Scalar3D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Scalar3D procedure, public :: UpdateHost => UpdateHost_Scalar3D generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D_t, WriteHDF5_Scalar3D_t Subroutines public subroutine AverageSides_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this public subroutine BoundaryInterp_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this public subroutine Free_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this public subroutine Gradient_Scalar3D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: this type(c_ptr), intent(inout) :: df public subroutine GridInterp_Scalar3D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this type(c_ptr), intent(inout) :: f public subroutine Init_Scalar3D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine UpdateDevice_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this public subroutine UpdateHost_Scalar3D (this) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: this","tags":"","loc":"module/self_scalar_3d.html"},{"title":"SELF_Scalar_2D – SELF","text":"Uses SELF_GPUBLAS SELF_Scalar_2D_t SELF_GPUInterfaces iso_c_binding SELF_GPU SELF_Constants Contents Derived Types Scalar2D Subroutines AverageSides_Scalar2D BoundaryInterp_Scalar2D Free_Scalar2D Gradient_Scalar2D GridInterp_Scalar2D Init_Scalar2D UpdateDevice_Scalar2D UpdateHost_Scalar2D Derived Types type, public, extends( Scalar2D_t ) :: Scalar2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar2D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D procedure, public :: Free => Free_Scalar2D generic, public :: Gradient => Gradient_Scalar2D_t, Gradient_Scalar2D procedure, private :: Gradient_Scalar2D generic, public :: GridInterp => GridInterp_Scalar2D_t, GridInterp_Scalar2D procedure, private :: GridInterp_Scalar2D procedure, public :: Init => Init_Scalar2D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Scalar2D procedure, public :: UpdateHost => UpdateHost_Scalar2D generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D_t, WriteHDF5_Scalar2D_t Subroutines public subroutine AverageSides_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this public subroutine BoundaryInterp_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this public subroutine Free_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this public subroutine Gradient_Scalar2D (this, df) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: this type(c_ptr), intent(inout) :: df public subroutine GridInterp_Scalar2D (this, f) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this type(c_ptr), intent(inout) :: f public subroutine Init_Scalar2D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine UpdateDevice_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this public subroutine UpdateHost_Scalar2D (this) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: this","tags":"","loc":"module/self_scalar_2d~2.html"},{"title":"SELF_GPUInterfaces – SELF","text":"Uses SELF_GPU iso_c_binding Contents Interfaces ApplyFlip_2D_gpu ApplyFlip_3D_gpu Average_gpu BoundaryInterp_2D_gpu BoundaryInterp_3D_gpu CalculateDSDt_gpu DG_BoundaryContribution_2D_gpu DG_BoundaryContribution_3D_gpu GradientNormal_1D_gpu JacobianWeight_2D_gpu JacobianWeight_3D_gpu SideExchange_2D_gpu SideExchange_3D_gpu UpdateGRK_gpu UpdateSolution_gpu Interfaces interface public subroutine ApplyFlip_2D_gpu(extBoundary, sideInfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extBoundary type(c_ptr), value :: sideInfo type(c_ptr), value :: elemToRank integer(kind=c_int), value :: rankId integer(kind=c_int), value :: offset integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl interface public subroutine ApplyFlip_3D_gpu(extBoundary, sideInfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extBoundary type(c_ptr), value :: sideInfo type(c_ptr), value :: elemToRank integer(kind=c_int), value :: rankId integer(kind=c_int), value :: offset integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl interface public subroutine Average_gpu(favg, f1, f2, ndof) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: favg type(c_ptr), value :: f1 type(c_ptr), value :: f2 integer(kind=c_int), value :: ndof interface public subroutine BoundaryInterp_2D_gpu(bMatrix_dev, f_dev, bf_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: bMatrix_dev type(c_ptr), value :: f_dev type(c_ptr), value :: bf_dev integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl interface public subroutine BoundaryInterp_3D_gpu(bMatrix_dev, f_dev, bf_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: bMatrix_dev type(c_ptr), value :: f_dev type(c_ptr), value :: bf_dev integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl interface public subroutine CalculateDSDt_gpu(fluxDivergence, source, dsdt, ndof) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: fluxDivergence type(c_ptr), value :: source type(c_ptr), value :: dsdt integer(kind=c_int), value :: ndof interface public subroutine DG_BoundaryContribution_2D_gpu(bmatrix, qweights, bf, df, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: bmatrix type(c_ptr), value :: qweights type(c_ptr), value :: bf type(c_ptr), value :: df integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel interface public subroutine DG_BoundaryContribution_3D_gpu(bmatrix, qweights, bf, df, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: bmatrix type(c_ptr), value :: qweights type(c_ptr), value :: bf type(c_ptr), value :: df integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel interface public subroutine GradientNormal_1D_gpu(fbn, fbavg, ndof) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: fbn type(c_ptr), value :: fbavg integer(kind=c_int), value :: ndof interface public subroutine JacobianWeight_2D_gpu(scalar, J, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: scalar type(c_ptr), value :: J integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl interface public subroutine JacobianWeight_3D_gpu(scalar, J, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: scalar type(c_ptr), value :: J integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl interface public subroutine SideExchange_2D_gpu(extboundary, boundary, sideinfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extboundary type(c_ptr), value :: boundary type(c_ptr), value :: sideinfo type(c_ptr), value :: elemToRank integer(kind=c_int), value :: rankId integer(kind=c_int), value :: offset integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl interface public subroutine SideExchange_3D_gpu(extboundary, boundary, sideinfo, elemToRank, rankId, offset, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: extboundary type(c_ptr), value :: boundary type(c_ptr), value :: sideinfo type(c_ptr), value :: elemToRank integer(kind=c_int), value :: rankId integer(kind=c_int), value :: offset integer(kind=c_int), value :: N integer(kind=c_int), value :: nVar integer(kind=c_int), value :: nEl interface public subroutine UpdateGRK_gpu(grk, solution, dsdt, rk_a, rk_g, dt, ndof) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: grk type(c_ptr), value :: solution type(c_ptr), value :: dsdt real(kind=c_prec), value :: rk_a real(kind=c_prec), value :: rk_g real(kind=c_prec), value :: dt integer(kind=c_int), value :: ndof interface public subroutine UpdateSolution_gpu(solution, dsdt, dt, ndof) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: solution type(c_ptr), value :: dsdt real(kind=c_prec), value :: dt integer(kind=c_int), value :: ndof","tags":"","loc":"module/self_gpuinterfaces.html"},{"title":"SELF_Vector_2D – SELF","text":"Uses SELF_GPUBLAS SELF_Vector_2D_t SELF_GPUInterfaces iso_c_binding SELF_GPU SELF_Constants Contents Derived Types Vector2D Subroutines AverageSides_Vector2D BoundaryInterp_Vector2D Divergence_Vector2D Free_Vector2D Gradient_Vector2D GridInterp_Vector2D Init_Vector2D UpdateDevice_Vector2D UpdateHost_Vector2D Derived Types type, public, extends( Vector2D_t ) :: Vector2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Vector2D procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D generic, public :: Divergence => Divergence_Vector2D_t, Divergence_Vector2D procedure, private :: Divergence_Vector2D procedure, public :: Free => Free_Vector2D generic, public :: Gradient => Gradient_Vector2D_t, Gradient_Vector2D procedure, private :: Gradient_Vector2D generic, public :: GridInterp => GridInterp_Vector2D_t, GridInterp_Vector2D procedure, private :: GridInterp_Vector2D procedure, public :: Init => Init_Vector2D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector2D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Vector2D procedure, public :: UpdateHost => UpdateHost_Vector2D generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D_t, WriteHDF5_Vector2D_t Subroutines public subroutine AverageSides_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this public subroutine BoundaryInterp_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this public subroutine Divergence_Vector2D (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this type(c_ptr), intent(inout) :: df public subroutine Free_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this public subroutine Gradient_Vector2D (this, df) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: this type(c_ptr), intent(inout) :: df public subroutine GridInterp_Vector2D (this, f) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this type(c_ptr), intent(inout) :: f public subroutine Init_Vector2D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine UpdateDevice_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this public subroutine UpdateHost_Vector2D (this) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: this","tags":"","loc":"module/self_vector_2d~2.html"},{"title":"SELF_MappedScalar_2D – SELF","text":"Uses SELF_MappedScalar_2D_t SELF_GPU SELF_GPUInterfaces iso_c_binding Contents Interfaces ContravariantWeight_2D_gpu NormalWeight_2D_gpu Derived Types MappedScalar2D Subroutines Free_MappedScalar2D Init_MappedScalar2D MPIExchangeAsync_MappedScalar2D MappedDGGradient_MappedScalar2D MappedGradient_MappedScalar2D SetInteriorFromEquation_MappedScalar2D SideExchange_MappedScalar2D Interfaces interface public subroutine ContravariantWeight_2D_gpu(f, dsdx, jaf, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: f type(c_ptr), value :: dsdx type(c_ptr), value :: jaf integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel interface public subroutine NormalWeight_2D_gpu(fb, nhat, nscale, fbn, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: fb type(c_ptr), value :: nhat type(c_ptr), value :: nscale type(c_ptr), value :: fbn integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel Derived Types type, public, extends( MappedScalar2D_t ) :: MappedScalar2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMQuad ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type(c_ptr), public :: jas_gpu type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar2D_t procedure, public :: AverageSides => AverageSides_Scalar2D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar2D_t procedure, public :: Free => Free_MappedScalar2D generic, public :: Gradient => Gradient_Scalar2D_t, Gradient_Scalar2D generic, public :: GridInterp => GridInterp_Scalar2D_t, GridInterp_Scalar2D procedure, public :: Init => Init_MappedScalar2D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D generic, public :: MappedDGGradient => MappedDGGradient_MappedScalar2D_t, MappedDGGradient_MappedScalar2D procedure, private :: MappedDGGradient_MappedScalar2D generic, public :: MappedGradient => MappedGradient_MappedScalar2D_t, MappedGradient_MappedScalar2D procedure, private :: MappedGradient_MappedScalar2D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar2D procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedScalar2D procedure, public :: UpdateDevice => UpdateDevice_Scalar2D procedure, public :: UpdateHost => UpdateHost_Scalar2D generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D_t, WriteHDF5_Scalar2D_t Subroutines public subroutine Free_MappedScalar2D (this) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this public subroutine Init_MappedScalar2D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine MPIExchangeAsync_MappedScalar2D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh public subroutine MappedDGGradient_MappedScalar2D (this, df) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type(c_ptr), intent(inout) :: df public subroutine MappedGradient_MappedScalar2D (this, df) Calculates the gradient of a function using the strong form of the gradient\nin mapped coordinates. Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type(c_ptr), intent(out) :: df public subroutine SetInteriorFromEquation_MappedScalar2D (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time public subroutine SideExchange_MappedScalar2D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh","tags":"","loc":"module/self_mappedscalar_2d~2.html"},{"title":"SELF_DGModel3D – SELF","text":"Uses SELF_GPU SELF_DGModel3D_t SELF_GPUInterfaces Contents Derived Types DGModel3D Subroutines BoundaryFlux_DGModel3D CalculateEntropy_DGModel3D CalculateSolutionGradient_DGModel3D CalculateTendency_DGModel3D UpdateGRK2_DGModel3D UpdateGRK3_DGModel3D UpdateGRK4_DGModel3D UpdateSolution_DGModel3D fluxmethod_DGModel3D setboundarycondition_DGModel3D setgradientboundarycondition_DGModel3D sourcemethod_DGModel3D Derived Types type, public, extends( DGModel3D_t ) :: DGModel3D Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D procedure, public :: CalculateTendency => CalculateTendency_DGModel3D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel3D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel3D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel3D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel3D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D procedure, public :: SetMetadata => SetMetadata_DGModel3D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t, SetSolutionFromEqn_DGModel3D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel3D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D procedure, public :: UpdateSolution => UpdateSolution_DGModel3D procedure, public :: WriteModel => Write_DGModel3D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model Subroutines public subroutine BoundaryFlux_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this public subroutine CalculateEntropy_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this public subroutine CalculateSolutionGradient_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this public subroutine CalculateTendency_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this public subroutine UpdateGRK2_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK3_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateGRK4_DGModel3D (this, m) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this integer, intent(in) :: m public subroutine UpdateSolution_DGModel3D (this, dt) Computes a solution update as , where dt is either provided through the interface\nor taken as the Model's stored time step size (model % dt) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this real(kind=prec), intent(in), optional :: dt public subroutine fluxmethod_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this public subroutine setboundarycondition_DGModel3D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this public subroutine setgradientboundarycondition_DGModel3D (this) Boundary conditions for the solution are set to\n0 for the external state to provide radiation type\nboundary conditions. Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this public subroutine sourcemethod_DGModel3D (this) Arguments Type Intent Optional Attributes Name class( DGModel3D ), intent(inout) :: this","tags":"","loc":"module/self_dgmodel3d~2.html"},{"title":"SELF_MappedVector_2D – SELF","text":"Uses SELF_GPUBLAS SELF_GPUInterfaces iso_c_binding SELF_MappedVector_2D_t SELF_GPU Contents Interfaces ContravariantProjection_2D_gpu Derived Types MappedVector2D Subroutines MPIExchangeAsync_MappedVector2D MappedDGDivergence_MappedVector2D MappedDivergence_MappedVector2D SetInteriorFromEquation_MappedVector2D SideExchange_MappedVector2D Interfaces interface public subroutine ContravariantProjection_2D_gpu(f, dsdx, N, nvar, nel) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: f type(c_ptr), value :: dsdx integer(kind=c_int), value :: N integer(kind=c_int), value :: nvar integer(kind=c_int), value :: nel Derived Types type, public, extends( MappedVector2D_t ) :: MappedVector2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMQuad ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedVector2D_t procedure, public :: AverageSides => AverageSides_Vector2D procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D procedure, public :: DissociateGeometry => DissociateGeometry_MappedVector2D_t generic, public :: Divergence => Divergence_Vector2D_t, Divergence_Vector2D procedure, public :: Free => Free_Vector2D generic, public :: Gradient => Gradient_Vector2D_t, Gradient_Vector2D generic, public :: GridInterp => GridInterp_Vector2D_t, GridInterp_Vector2D procedure, public :: Init => Init_Vector2D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D generic, public :: MappedDGDivergence => MappedDGDivergence_MappedVector2D_t, MappedDGDivergence_MappedVector2D procedure, private :: MappedDGDivergence_MappedVector2D generic, public :: MappedDivergence => MappedDivergence_MappedVector2D_t, MappedDivergence_MappedVector2D procedure, private :: MappedDivergence_MappedVector2D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector2D_t procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector2D procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedVector2D procedure, public :: UpdateDevice => UpdateDevice_Vector2D procedure, public :: UpdateHost => UpdateHost_Vector2D generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D_t, WriteHDF5_Vector2D_t Subroutines public subroutine MPIExchangeAsync_MappedVector2D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh public subroutine MappedDGDivergence_MappedVector2D (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type(c_ptr), intent(out) :: df public subroutine MappedDivergence_MappedVector2D (this, df) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type(c_ptr), intent(out) :: df public subroutine SetInteriorFromEquation_MappedVector2D (this, geometry, time) Sets the this % interior attribute using the eqn attribute,\ngeometry (for physical positions), and provided simulation time. Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type( SEMQuad ), intent(in) :: geometry real(kind=prec), intent(in) :: time public subroutine SideExchange_MappedVector2D (this, mesh) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: this type( Mesh2D ), intent(inout) :: mesh","tags":"","loc":"module/self_mappedvector_2d~2.html"},{"title":"SELF_GPUBLAS – SELF","text":"Uses iso_c_binding iso_fortran_env SELF_Constants SELF_GPU_enums Contents Interfaces hipblasCreate hipblasDestroy hipblasDgemm hipblasDgemvStridedBatched hipblasSgemm hipblasSgemvStridedBatched Subroutines hipblasCheck self_blas_matrixop_1d self_blas_matrixop_dim1_2d self_blas_matrixop_dim1_3d self_blas_matrixop_dim2_2d self_blas_matrixop_dim2_3d self_blas_matrixop_dim3_3d Interfaces public interface hipblasCreate public function hipblasCreate_(handle) bind(c,name=\"cublasCreate_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: handle Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) public interface hipblasDestroy public function hipblasDestroy_(handle) bind(c,name=\"cublasDestroy_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) public interface hipblasDgemm public function hipblasDgemm_(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc) bind(c,name=\"cublasDgemm_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: transa integer(kind=kind(HIPBLAS_OP_N)), value :: transb integer(kind=c_int), value :: m integer(kind=c_int), value :: n integer(kind=c_int), value :: k real(kind=c_double) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda type(c_ptr), value :: B integer(kind=c_int), value :: ldb real(kind=c_double) :: beta type(c_ptr), value :: C integer(kind=c_int), value :: ldc Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) public interface hipblasDgemvStridedBatched public function hipblasDgemvStridedBatched_(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount) bind(c,name=\"cublasDgemvStridedBatched\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: trans integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda integer(kind=c_int64_t), value :: strideA type(c_ptr), value :: x integer(kind=c_int), value :: incx integer(kind=c_int64_t), value :: stridex real(kind=c_double) :: beta type(c_ptr), value :: y integer(kind=c_int), value :: incy integer(kind=c_int64_t), value :: stridey integer(kind=c_int), value :: batchCount Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) public interface hipblasSgemm public function hipblasSgemm_(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc) bind(c,name=\"cublasSgemm_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: transa integer(kind=kind(HIPBLAS_OP_N)), value :: transb integer(kind=c_int), value :: m integer(kind=c_int), value :: n integer(kind=c_int), value :: k real(kind=c_float) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda type(c_ptr), value :: B integer(kind=c_int), value :: ldb real(kind=c_float) :: beta type(c_ptr), value :: C integer(kind=c_int), value :: ldc Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) public interface hipblasSgemvStridedBatched public function hipblasSgemvStridedBatched_(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount) bind(c,name=\"cublasSgemvStridedBatched\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: trans integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_float) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda integer(kind=c_int64_t), value :: strideA type(c_ptr), value :: x integer(kind=c_int), value :: incx integer(kind=c_int64_t), value :: stridex real(kind=c_float) :: beta type(c_ptr), value :: y integer(kind=c_int), value :: incy integer(kind=c_int64_t), value :: stridey integer(kind=c_int), value :: batchCount Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) Subroutines public subroutine hipblasCheck (hipblasError_t) Arguments Type Intent Optional Attributes Name integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasError_t public subroutine self_blas_matrixop_1d (A, f, Af, opArows, opAcols, bcols, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A type(c_ptr), intent(in) :: f type(c_ptr), intent(inout) :: Af integer, intent(in) :: opArows integer, intent(in) :: opAcols integer, intent(in) :: bcols type(c_ptr), intent(in) :: handle public subroutine self_blas_matrixop_dim1_2d (A, f, Af, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A type(c_ptr), intent(in) :: f type(c_ptr), intent(inout) :: Af integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(in) :: handle public subroutine self_blas_matrixop_dim1_3d (A, f, Af, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A type(c_ptr), intent(in) :: f type(c_ptr), intent(inout) :: Af integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(in) :: handle public subroutine self_blas_matrixop_dim2_2d (A, f, Af, beta, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A type(c_ptr), intent(in) :: f type(c_ptr), intent(inout) :: Af real(kind=c_prec), intent(in) :: beta integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(in) :: handle public subroutine self_blas_matrixop_dim2_3d (A, f, Af, beta, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A type(c_ptr), intent(in) :: f type(c_ptr), intent(inout) :: Af real(kind=c_prec), intent(in) :: beta integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(in) :: handle public subroutine self_blas_matrixop_dim3_3d (A, f, Af, beta, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A type(c_ptr), intent(in) :: f type(c_ptr), intent(inout) :: Af real(kind=c_prec), intent(in) :: beta integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(in) :: handle","tags":"","loc":"module/self_gpublas.html"},{"title":"SELF_Tensor_2D – SELF","text":"Uses SELF_GPUBLAS iso_fortran_env SELF_Tensor_2D_t iso_c_binding SELF_GPU SELF_Constants Contents Derived Types Tensor2D Subroutines Free_Tensor2D Init_Tensor2D UpdateDevice_Tensor2D UpdateHost_Tensor2D Derived Types type, public, extends( Tensor2D_t ) :: Tensor2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor2D_t generic, public :: Determinant => Determinant_Tensor2D_t procedure, public :: Free => Free_Tensor2D procedure, public :: Init => Init_Tensor2D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Tensor2D procedure, public :: UpdateHost => UpdateHost_Tensor2D Subroutines public subroutine Free_Tensor2D (this) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: this public subroutine Init_Tensor2D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine UpdateDevice_Tensor2D (this) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: this public subroutine UpdateHost_Tensor2D (this) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: this","tags":"","loc":"module/self_tensor_2d.html"},{"title":"SELF_Lagrange – SELF","text":"Uses SELF_Lagrange_t iso_fortran_env iso_c_binding SELF_GPU SELF_Constants Contents Derived Types Lagrange Subroutines Free_Lagrange Init_Lagrange Derived Types type, public, extends( Lagrange_t ) :: Lagrange Components Type Visibility Attributes Name Initial integer, public :: M The number of target points. integer, public :: N The number of control points. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: bMatrix The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. type(c_ptr), public :: bMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:) :: bWeights The barycentric weights that are calculated from the controlPoints and used for interpolation. character(len=3), public :: backend = 'gpu' type(c_ptr), public :: blas_handle = c_null_ptr A handle for working with hipblas integer, public :: controlNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: controlPoints The set of nodes in one dimension where data is known.\nTo create higher dimension interpolation and differentiation operators, structured grids in two and three\ndimensions are created by tensor products of the controlPoints. This design decision implies that all\nspectral element methods supported by the Lagrange class have the same polynomial degree in each\ncomputational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto,\nLegendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over\nthe domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of\nthese quadrature types or uniform points on [-1,1]. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The\ndMatrix is based on a strong form of the derivative. type(c_ptr), public :: dMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dgMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based\non a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. type(c_ptr), public :: dgMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:) :: iMatrix The interpolation matrix (transpose) for mapping data from the control grid to the target grid. type(c_ptr), public :: iMatrix_gpu real(kind=prec), public, pointer, contiguous, dimension(:) :: qWeights The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints\nprovided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss,\nChebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant . type(c_ptr), public :: qWeights_gpu integer, public :: targetNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: targetPoints The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation\nand differentiation operators, structured grids in two and three dimensions are created by tensor products of\nthe targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1]\n(computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. Type-Bound Procedures procedure, public :: CalculateBarycentricWeights procedure, public :: CalculateDerivativeMatrix procedure, public :: CalculateInterpolationMatrix procedure, public :: CalculateLagrangePolynomials procedure, public :: Free => Free_Lagrange procedure, public :: Init => Init_Lagrange procedure, public :: WriteHDF5 => WriteHDF5_Lagrange_t Subroutines public subroutine Free_Lagrange (this) Frees all memory (host and device) associated with an instance of the Lagrange class Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: this Lagrange class instance public subroutine Init_Lagrange (this, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange class\nOn output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(out) :: this Lagrange class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3)","tags":"","loc":"module/self_lagrange~2.html"},{"title":"SELF_Scalar_1D – SELF","text":"Uses SELF_Scalar_1D_t SELF_GPUBLAS iso_c_binding SELF_GPU SELF_Constants Contents Derived Types Scalar1D Subroutines BoundaryInterp_Scalar1D Free_Scalar1D Init_Scalar1D UpdateDevice_Scalar1D UpdateHost_Scalar1D Derived Types type, public, extends( Scalar1D_t ) :: Scalar1D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: avgBoundary character(len=3), public :: backend = \"apu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundarynormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar1D_t procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D generic, public :: Derivative => Derivative_Scalar1D_t procedure, public :: Free => Free_Scalar1D generic, public :: GridInterp => GridInterp_Scalar1D_t procedure, public :: Init => Init_Scalar1D procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Scalar1D_t procedure, public :: UpdateHost => UpdateHost_Scalar1D_t generic, public :: WriteHDF5 => WriteHDF5_Scalar1D_t Subroutines public subroutine BoundaryInterp_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this public subroutine Free_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this public subroutine Init_Scalar1D (this, interp, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: this type( Lagrange ), intent(in), target :: interp integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine UpdateDevice_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this public subroutine UpdateHost_Scalar1D (this) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: this","tags":"","loc":"module/self_scalar_1d~2.html"},{"title":"SELF_GPU_enums – SELF","text":"Uses iso_c_binding Contents Enumerations Enumerations enum, bind(c) Enumerators enumerator :: hipSuccess = 0 enum, bind(c) Enumerators enumerator :: hipMemcpyHostToHost = 0 enumerator :: hipMemcpyHostToDevice = 1 enumerator :: hipMemcpyDeviceToHost = 2 enumerator :: hipMemcpyDeviceToDevice = 3 enumerator :: hipMemcpyDefault = 4 enum, bind(c) Enumerators enumerator :: HIPBLAS_STATUS_SUCCESS = 0 enumerator :: HIPBLAS_STATUS_NOT_INITIALIZED = 1 enumerator :: HIPBLAS_STATUS_ALLOC_FAILED = 2 enumerator :: HIPBLAS_STATUS_INVALID_VALUE = 3 enumerator :: HIPBLAS_STATUS_MAPPING_ERROR = 4 enumerator :: HIPBLAS_STATUS_EXECUTION_FAILED = 5 enumerator :: HIPBLAS_STATUS_INTERNAL_ERROR = 6 enumerator :: HIPBLAS_STATUS_NOT_SUPPORTED = 7 enumerator :: HIPBLAS_STATUS_ARCH_MISMATCH = 8 enumerator :: HIPBLAS_STATUS_HANDLE_IS_NULLPTR = 9 enumerator :: HIPBLAS_STATUS_INVALID_ENUM = 10 enumerator :: HIPBLAS_STATUS_UNKNOWN = 11 enum, bind(c) Enumerators enumerator :: HIPBLAS_OP_N = 0 enumerator :: HIPBLAS_OP_N = 111 enumerator :: HIPBLAS_OP_T = 1 enumerator :: HIPBLAS_OP_T = 112","tags":"","loc":"module/self_gpu_enums.html"},{"title":"SELF_GPU – SELF","text":"Uses SELF_GPU_enums iso_c_binding Contents Interfaces hipFree hipGetDeviceCount hipMalloc hipMemcpy Functions GPUAvailable Subroutines gpuCheck Interfaces public interface hipFree public function hipFree_(ptr) bind(c,name=\"hipFree\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: ptr Return Value integer(kind=kind(hipSuccess)) public interface hipGetDeviceCount public function hipGetDeviceCount_(count) bind(c,name=\"hipGetDeviceCount\") Arguments Type Intent Optional Attributes Name integer(kind=c_int) :: count Return Value integer(kind=kind(hipSuccess)) public interface hipMalloc public function hipMalloc_(ptr, mySize) bind(c,name=\"hipMalloc\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: ptr integer(kind=c_size_t), value :: mySize Return Value integer(kind=kind(hipSuccess)) public interface hipMemcpy public function hipMemcpy_(dest, src, sizeBytes, myKind) bind(c,name=\"hipMemcpy\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: dest type(c_ptr), value :: src integer(kind=c_size_t), value :: sizeBytes integer(kind=kind(hipMemcpyHostToHost)), value :: myKind Return Value integer(kind=kind(hipSuccess)) Functions public function GPUAvailable () result(avail) Arguments None Return Value logical Subroutines public subroutine gpuCheck (gpuError_t) Arguments Type Intent Optional Attributes Name integer(kind=kind(hipSuccess)) :: gpuError_t","tags":"","loc":"module/self_gpu.html"},{"title":"SELF_GPUBLAS – SELF","text":"Uses iso_c_binding iso_fortran_env SELF_Constants SELF_GPU_enums Contents Interfaces hipblasCreate hipblasDestroy hipblasDgemm hipblasDgemvStridedBatched hipblasSgemm hipblasSgemvStridedBatched Subroutines hipblasCheck self_blas_matrixop_1d self_blas_matrixop_dim1_2d self_blas_matrixop_dim1_3d self_blas_matrixop_dim2_2d self_blas_matrixop_dim2_3d self_blas_matrixop_dim3_3d Interfaces public interface hipblasCreate public function hipblasCreate_(handle) bind(c,name=\"cublasCreate_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: handle Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) public interface hipblasDestroy public function hipblasDestroy_(handle) bind(c,name=\"cublasDestroy_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) public interface hipblasDgemm public function hipblasDgemm_(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc) bind(c,name=\"cublasDgemm_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: transa integer(kind=kind(HIPBLAS_OP_N)), value :: transb integer(kind=c_int), value :: m integer(kind=c_int), value :: n integer(kind=c_int), value :: k real(kind=c_double) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda type(c_ptr), value :: B integer(kind=c_int), value :: ldb real(kind=c_double) :: beta type(c_ptr), value :: C integer(kind=c_int), value :: ldc Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) public interface hipblasDgemvStridedBatched public function hipblasDgemvStridedBatched_(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount) bind(c,name=\"cublasDgemvStridedBatched\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: trans integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda integer(kind=c_int64_t), value :: strideA type(c_ptr), value :: x integer(kind=c_int), value :: incx integer(kind=c_int64_t), value :: stridex real(kind=c_double) :: beta type(c_ptr), value :: y integer(kind=c_int), value :: incy integer(kind=c_int64_t), value :: stridey integer(kind=c_int), value :: batchCount Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) public interface hipblasSgemm public function hipblasSgemm_(handle, transa, transb, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc) bind(c,name=\"cublasSgemm_v2\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: transa integer(kind=kind(HIPBLAS_OP_N)), value :: transb integer(kind=c_int), value :: m integer(kind=c_int), value :: n integer(kind=c_int), value :: k real(kind=c_float) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda type(c_ptr), value :: B integer(kind=c_int), value :: ldb real(kind=c_float) :: beta type(c_ptr), value :: C integer(kind=c_int), value :: ldc Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) public interface hipblasSgemvStridedBatched public function hipblasSgemvStridedBatched_(handle, trans, m, n, alpha, A, lda, strideA, x, incx, stridex, beta, y, incy, stridey, batchCount) bind(c,name=\"cublasSgemvStridedBatched\") Arguments Type Intent Optional Attributes Name type(c_ptr), value :: handle integer(kind=kind(HIPBLAS_OP_N)), value :: trans integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_float) :: alpha type(c_ptr), value :: A integer(kind=c_int), value :: lda integer(kind=c_int64_t), value :: strideA type(c_ptr), value :: x integer(kind=c_int), value :: incx integer(kind=c_int64_t), value :: stridex real(kind=c_float) :: beta type(c_ptr), value :: y integer(kind=c_int), value :: incy integer(kind=c_int64_t), value :: stridey integer(kind=c_int), value :: batchCount Return Value integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) Subroutines public subroutine hipblasCheck (hipblasError_t) Arguments Type Intent Optional Attributes Name integer(kind=kind(HIPBLAS_STATUS_SUCCESS)) :: hipblasError_t public subroutine self_blas_matrixop_1d (A, f, Af, opArows, opAcols, bcols, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A real(kind=prec), intent(in), pointer :: f (:,:,:) real(kind=prec), intent(inout), pointer :: Af (:,:,:) integer, intent(in) :: opArows integer, intent(in) :: opAcols integer, intent(in) :: bcols type(c_ptr), intent(inout) :: handle public subroutine self_blas_matrixop_dim1_2d (A, f, Af, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A real(kind=prec), intent(in), pointer :: f (:,:,:,:) real(kind=prec), intent(inout), pointer :: Af (:,:,:,:) integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(inout) :: handle public subroutine self_blas_matrixop_dim1_3d (A, f, Af, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A real(kind=prec), intent(in), pointer :: f (:,:,:,:,:) real(kind=prec), intent(inout), pointer :: Af (:,:,:,:,:) integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(inout) :: handle public subroutine self_blas_matrixop_dim2_2d (A, f, Af, beta, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A real(kind=prec), intent(in), pointer :: f (:,:,:,:) real(kind=prec), intent(inout), pointer :: Af (:,:,:,:) real(kind=c_prec), intent(in) :: beta integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(inout) :: handle public subroutine self_blas_matrixop_dim2_3d (A, f, Af, beta, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A real(kind=prec), intent(in), pointer :: f (:,:,:,:,:) real(kind=prec), intent(inout), pointer :: Af (:,:,:,:,:) real(kind=c_prec), intent(in) :: beta integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(inout) :: handle public subroutine self_blas_matrixop_dim3_3d (A, f, Af, beta, controldegree, targetdegree, nvars, nelems, handle) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: A real(kind=prec), intent(in), pointer :: f (:,:,:,:,:) real(kind=prec), intent(inout), pointer :: Af (:,:,:,:,:) real(kind=c_prec), intent(in) :: beta integer, intent(in) :: controldegree integer, intent(in) :: targetdegree integer, intent(in) :: nvars integer, intent(in) :: nelems type(c_ptr), intent(inout) :: handle","tags":"","loc":"module/self_gpublas~2.html"},{"title":"self_NullDGModel3D – SELF","text":"Uses self_NullDGModel3D_t Contents Derived Types NullDGModel3D Derived Types type, public, extends( NullDGModel3D_t ) :: NullDGModel3D Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D procedure, public :: CalculateTendency => CalculateTendency_DGModel3D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel3D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel3D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel3D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel3D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D procedure, public :: SetMetadata => SetMetadata_DGModel3D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t, SetSolutionFromEqn_DGModel3D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel3D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D procedure, public :: UpdateSolution => UpdateSolution_DGModel3D procedure, public :: WriteModel => Write_DGModel3D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_nulldgmodel3d.html"},{"title":"SELF_MappedScalar_3D – SELF","text":"Uses SELF_MappedScalar_3D_t Contents Derived Types MappedScalar3D Derived Types type, public, extends( MappedScalar3D_t ) :: MappedScalar3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMHex ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar3D_t procedure, public :: AverageSides => AverageSides_Scalar3D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar3D_t procedure, public :: Free => Free_Scalar3D generic, public :: Gradient => Gradient_Scalar3D_t, Gradient_Scalar3D generic, public :: GridInterp => GridInterp_Scalar3D_t, GridInterp_Scalar3D procedure, public :: Init => Init_Scalar3D generic, public :: MappedDGGradient => MappedDGGradient_MappedScalar3D_t generic, public :: MappedGradient => MappedGradient_MappedScalar3D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar3D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedScalar3D_t procedure, public :: UpdateDevice => UpdateDevice_Scalar3D procedure, public :: UpdateHost => UpdateHost_Scalar3D generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D_t, WriteHDF5_Scalar3D_t","tags":"","loc":"module/self_mappedscalar_3d~2.html"},{"title":"SELF_Vector_3D – SELF","text":"Uses SELF_Vector_3D_t Contents Derived Types Vector3D Derived Types type, public, extends( Vector3D_t ) :: Vector3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: avgBoundary character(len=3), public :: backend = \"cpu\" real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundaryNormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Vector3D_t procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D_t generic, public :: Curl => Curl_Vector3D_t generic, public :: Divergence => Divergence_Vector3D_t procedure, public :: Free => Free_Vector3D_t generic, public :: Gradient => Gradient_Vector3D_t generic, public :: GridInterp => GridInterp_Vector3D_t procedure, public :: Init => Init_Vector3D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector3D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Vector3D_t procedure, public :: UpdateHost => UpdateHost_Vector3D_t generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D_t, WriteHDF5_Vector3D_t","tags":"","loc":"module/self_vector_3d.html"},{"title":"self_Burgers1D – SELF","text":"Uses self_Burgers1D_t Contents Derived Types Burgers1D Derived Types type, public, extends( Burgers1D_t ) :: Burgers1D Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh real(kind=prec), public :: nu = 0.0_prec integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D procedure, public :: CalculateTendency => CalculateTendency_DGModel1D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel1D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel1D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel1D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel1D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D procedure, public :: SetMetadata => SetMetadata_Burgers1D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t, SetSolutionFromEqn_DGModel1D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel1D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D procedure, public :: UpdateSolution => UpdateSolution_DGModel1D procedure, public :: WriteModel => Write_DGModel1D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t procedure, public :: entropy_func => entropy_func_Burgers1D_t procedure, public :: flux1d => flux1d_Burgers1D_t procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Burgers1D_t procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_burgers1d~2.html"},{"title":"SELF_Lagrange – SELF","text":"Uses iso_fortran_env SELF_Lagrange_t SELF_Constants iso_c_binding Contents Derived Types Lagrange Derived Types type, public, extends( Lagrange_t ) :: Lagrange Components Type Visibility Attributes Name Initial integer, public :: M The number of target points. integer, public :: N The number of control points. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: bMatrix The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. real(kind=prec), public, pointer, contiguous, dimension(:) :: bWeights The barycentric weights that are calculated from the controlPoints and used for interpolation. character(len=3), public :: backend = 'cpu' type(c_ptr), public :: blas_handle = c_null_ptr A handle for working with hipblas integer, public :: controlNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: controlPoints The set of nodes in one dimension where data is known.\nTo create higher dimension interpolation and differentiation operators, structured grids in two and three\ndimensions are created by tensor products of the controlPoints. This design decision implies that all\nspectral element methods supported by the Lagrange class have the same polynomial degree in each\ncomputational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto,\nLegendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over\nthe domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of\nthese quadrature types or uniform points on [-1,1]. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The\ndMatrix is based on a strong form of the derivative. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: dgMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based\non a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. real(kind=prec), public, pointer, contiguous, dimension(:,:) :: iMatrix The interpolation matrix (transpose) for mapping data from the control grid to the target grid. real(kind=prec), public, pointer, contiguous, dimension(:) :: qWeights The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints\nprovided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss,\nChebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant . integer, public :: targetNodeType real(kind=prec), public, pointer, contiguous, dimension(:) :: targetPoints The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation\nand differentiation operators, structured grids in two and three dimensions are created by tensor products of\nthe targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1]\n(computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. Type-Bound Procedures procedure, public :: CalculateBarycentricWeights procedure, public :: CalculateDerivativeMatrix procedure, public :: CalculateInterpolationMatrix procedure, public :: CalculateLagrangePolynomials procedure, public :: Free => Free_Lagrange_t procedure, public :: Init => Init_Lagrange_t procedure, public :: WriteHDF5 => WriteHDF5_Lagrange_t","tags":"","loc":"module/self_lagrange~3.html"},{"title":"SELF_DomainDecomposition – SELF","text":"Uses SELF_DomainDecomposition_t Contents Derived Types DomainDecomposition Derived Types type, public, extends( DomainDecomposition_t ) :: DomainDecomposition Components Type Visibility Attributes Name Initial integer, public, pointer, dimension(:) :: elemToRank integer, public :: maxMsg integer, public :: mpiComm logical, public :: mpiEnabled integer, public :: mpiPrec integer, public :: msgCount integer, public :: nElem integer, public :: nRanks integer, public, pointer, dimension(:) :: offSetElem integer, public :: rankId integer, public, allocatable :: requests (:) integer, public, allocatable :: stats (:,:) Type-Bound Procedures procedure, public :: FinalizeMPIExchangeAsync procedure, public :: Free => Free_DomainDecomposition_t procedure, public :: GenerateDecomposition => GenerateDecomposition_DomainDecomposition_t procedure, public :: Init => Init_DomainDecomposition_t procedure, public :: SetElemToRank => SetElemToRank_DomainDecomposition_t","tags":"","loc":"module/self_domaindecomposition.html"},{"title":"SELF_Mesh_2D – SELF","text":"Uses SELF_Mesh_2D_t Contents Derived Types Mesh2D Derived Types type, public, extends( Mesh2D_t ) :: Mesh2D Components Type Visibility Attributes Name Initial character(len=255), public, allocatable :: BCNames (:) integer, public, pointer, dimension(:,:) :: BCType integer, public, pointer, dimension(:,:) :: CGNSCornerMap integer, public, pointer, dimension(:,:) :: CGNSSideMap type( DomainDecomposition ), public :: decomp integer, public, pointer, dimension(:,:) :: elemInfo integer, public, pointer, dimension(:,:,:) :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides real(kind=prec), public, pointer, dimension(:,:,:,:) :: nodeCoords integer, public :: quadrature integer, public, pointer, dimension(:,:,:) :: sideInfo Type-Bound Procedures procedure, public :: Free => Free_Mesh2D_t procedure, public :: Init => Init_Mesh2D_t procedure, public :: Read_HOPr => Read_HOPr_Mesh2D_t procedure, public :: RecalculateFlip => RecalculateFlip_Mesh2D_t procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh2D_t generic, public :: StructuredMesh => UniformStructuredMesh_Mesh2D_t procedure, public :: Write_Mesh => Write_Mesh2D_t","tags":"","loc":"module/self_mesh_2d.html"},{"title":"SELF_Scalar_1D – SELF","text":"Uses SELF_Scalar_1D_t Contents Derived Types Scalar1D Derived Types type, public, extends( Scalar1D_t ) :: Scalar1D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: avgBoundary character(len=3), public :: backend = \"cpu\" real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundarynormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar1D_t procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D_t generic, public :: Derivative => Derivative_Scalar1D_t procedure, public :: Free => Free_Scalar1D_t generic, public :: GridInterp => GridInterp_Scalar1D_t procedure, public :: Init => Init_Scalar1D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Scalar1D_t procedure, public :: UpdateHost => UpdateHost_Scalar1D_t generic, public :: WriteHDF5 => WriteHDF5_Scalar1D_t","tags":"","loc":"module/self_scalar_1d~3.html"},{"title":"self_advection_diffusion_2d – SELF","text":"Uses self_advection_diffusion_2d_t Contents Derived Types advection_diffusion_2d Derived Types type, public, extends( advection_diffusion_2d_t ) :: advection_diffusion_2d Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D procedure, public :: CalculateTendency => CalculateTendency_DGModel2D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel2D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel2D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel2D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel2D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D procedure, public :: SetMetadata => SetMetadata_DGModel2D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t, SetSolutionFromEqn_DGModel2D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel2D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D procedure, public :: UpdateSolution => UpdateSolution_DGModel2D procedure, public :: WriteModel => Write_DGModel2D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t procedure, public :: entropy_func => entropy_func_advection_diffusion_2d_t procedure, public :: flux1D => flux1d_Model procedure, public :: flux2d => flux2d_advection_diffusion_2d_t procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_advection_diffusion_2d_t procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_advection_diffusion_2d.html"},{"title":"SELF_DGModel2D – SELF","text":"Uses SELF_DGModel2D_t Contents Derived Types DGModel2D Derived Types type, public, extends( DGModel2D_t ) :: DGModel2D Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D_t procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D_t procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D_t procedure, public :: CalculateTendency => CalculateTendency_DGModel2D_t procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel2D_t procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel2D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel2D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel2D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D_t procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D_t procedure, public :: SetMetadata => SetMetadata_DGModel2D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t, SetSolutionFromEqn_DGModel2D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel2D_t procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D_t procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D_t procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D_t procedure, public :: UpdateSolution => UpdateSolution_DGModel2D_t procedure, public :: WriteModel => Write_DGModel2D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_dgmodel2d.html"},{"title":"self_advection_diffusion_1d – SELF","text":"Uses self_advection_diffusion_1d_t Contents Derived Types advection_diffusion_1d Derived Types type, public, extends( advection_diffusion_1d_t ) :: advection_diffusion_1d Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D procedure, public :: CalculateTendency => CalculateTendency_DGModel1D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel1D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel1D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel1D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel1D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D procedure, public :: SetMetadata => SetMetadata_DGModel1D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t, SetSolutionFromEqn_DGModel1D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel1D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D procedure, public :: UpdateSolution => UpdateSolution_DGModel1D procedure, public :: WriteModel => Write_DGModel1D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t procedure, public :: entropy_func => entropy_func_advection_diffusion_1d_t procedure, public :: flux1d => flux1d_advection_diffusion_1d_t procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_advection_diffusion_1d_t procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_advection_diffusion_1d~2.html"},{"title":"self_advection_diffusion_3d – SELF","text":"Uses self_advection_diffusion_3d_t Contents Derived Types advection_diffusion_3d Derived Types type, public, extends( advection_diffusion_3d_t ) :: advection_diffusion_3d Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh real(kind=prec), public :: nu integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator real(kind=prec), public :: u real(kind=prec), public :: v real(kind=prec), public :: w type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D procedure, public :: CalculateTendency => CalculateTendency_DGModel3D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel3D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel3D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel3D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel3D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D procedure, public :: SetMetadata => SetMetadata_DGModel3D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t, SetSolutionFromEqn_DGModel3D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel3D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D procedure, public :: UpdateSolution => UpdateSolution_DGModel3D procedure, public :: WriteModel => Write_DGModel3D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t procedure, public :: entropy_func => entropy_func_advection_diffusion_3d_t procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3d => flux3d_advection_diffusion_3d_t procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_advection_diffusion_3d_t procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_advection_diffusion_3d~2.html"},{"title":"self_NullDGModel1D – SELF","text":"Uses self_NullDGModel1D_t Contents Derived Types NullDGModel1D Derived Types type, public, extends( NullDGModel1D_t ) :: NullDGModel1D Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D procedure, public :: CalculateTendency => CalculateTendency_DGModel1D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel1D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel1D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel1D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel1D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D procedure, public :: SetMetadata => SetMetadata_DGModel1D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t, SetSolutionFromEqn_DGModel1D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel1D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D procedure, public :: UpdateSolution => UpdateSolution_DGModel1D procedure, public :: WriteModel => Write_DGModel1D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_nulldgmodel1d~2.html"},{"title":"SELF_DGModel1D – SELF","text":"Uses SELF_DGModel1D_t Contents Derived Types DGModel1D Derived Types type, public, extends( DGModel1D_t ) :: DGModel1D Components Type Visibility Attributes Name Initial type( MappedScalar1D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedScalar1D ), public :: flux type( MappedScalar1D ), public :: fluxDivergence type( Geometry1D ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh1D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar1D ), public :: solution type( MappedScalar1D ), public :: solutionGradient type( MappedScalar1D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar1D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel1D_t procedure, public :: CalculateEntropy => CalculateEntropy_DGModel1D_t procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D_t procedure, public :: CalculateTendency => CalculateTendency_DGModel1D_t procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel1D_t procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel1D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel1D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel1D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel1D_t procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D_t procedure, public :: SetMetadata => SetMetadata_DGModel1D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel1D_t, SetSolutionFromEqn_DGModel1D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel1D_t procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel1D_t procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel1D_t procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel1D_t procedure, public :: UpdateSolution => UpdateSolution_DGModel1D_t procedure, public :: WriteModel => Write_DGModel1D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel1D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_dgmodel1d.html"},{"title":"SELF_MappedVector_3D – SELF","text":"Uses SELF_MappedVector_3D_t Contents Derived Types MappedVector3D Derived Types type, public, extends( MappedVector3D_t ) :: MappedVector3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMHex ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork1 type(c_ptr), public :: interpWork2 type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedVector3D_t procedure, public :: AverageSides => AverageSides_Vector3D procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D generic, public :: Curl => Curl_Vector3D_t procedure, public :: DissociateGeometry => DissociateGeometry_MappedVector3D_t generic, public :: Divergence => Divergence_Vector3D_t, Divergence_Vector3D procedure, public :: Free => Free_Vector3D generic, public :: Gradient => Gradient_Vector3D_t, Gradient_Vector3D generic, public :: GridInterp => GridInterp_Vector3D_t, GridInterp_Vector3D procedure, public :: Init => Init_Vector3D generic, public :: MappedDGDivergence => MappedDGDivergence_MappedVector3D_t generic, public :: MappedDivergence => MappedDivergence_MappedVector3D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector3D_t procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector3D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedVector3D_t procedure, public :: UpdateDevice => UpdateDevice_Vector3D procedure, public :: UpdateHost => UpdateHost_Vector3D generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector3D_t, WriteHDF5_Vector3D_t","tags":"","loc":"module/self_mappedvector_3d.html"},{"title":"SELF_Mesh_3D – SELF","text":"Uses SELF_Mesh_3D_t Contents Derived Types Mesh3D Derived Types type, public, extends( Mesh3D_t ) :: Mesh3D Components Type Visibility Attributes Name Initial character(len=255), public, allocatable :: BCNames (:) integer, public, pointer, dimension(:,:) :: BCType integer, public, pointer, dimension(:,:) :: CGNSCornerMap integer, public, pointer, dimension(:,:) :: CGNSSideMap type( DomainDecomposition ), public :: decomp integer, public, pointer, dimension(:,:) :: elemInfo integer, public, pointer, dimension(:,:,:,:) :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nGlobalElem integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides real(kind=prec), public, pointer, dimension(:,:,:,:,:) :: nodeCoords integer, public :: quadrature integer, public, pointer, dimension(:,:,:) :: sideInfo integer, public, pointer, dimension(:,:) :: sideMap Type-Bound Procedures procedure, public :: Free => Free_Mesh3D_t procedure, public :: Init => Init_Mesh3D_t procedure, public :: Read_HOPr => Read_HOPr_Mesh3D_t procedure, public :: RecalculateFlip => RecalculateFlip_Mesh3D_t procedure, public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh3D_t procedure, public :: Write_Mesh => Write_Mesh3D_t","tags":"","loc":"module/self_mesh_3d~2.html"},{"title":"SELF_MappedScalar_1D – SELF","text":"Uses SELF_MappedScalar_1D_t Contents Derived Types MappedScalar1D Derived Types type, public, extends( MappedScalar1D_t ) :: MappedScalar1D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( Geometry1D ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar1D_t procedure, public :: AverageSides => AverageSides_Scalar1D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D generic, public :: Derivative => Derivative_Scalar1D_t, Derivative_Scalar1D procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar1D_t procedure, public :: Free => Free_Scalar1D generic, public :: GridInterp => GridInterp_Scalar1D_t, GridInterp_Scalar1D procedure, public :: Init => Init_Scalar1D generic, public :: MappedDGDerivative => MappedDGDerivative_MappedScalar1D_t generic, public :: MappedDerivative => MappedDerivative_MappedScalar1D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar1D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedScalar1D_t procedure, public :: UpdateDevice => UpdateDevice_Scalar1D procedure, public :: UpdateHost => UpdateHost_Scalar1D generic, public :: WriteHDF5 => WriteHDF5_Scalar1D_t","tags":"","loc":"module/self_mappedscalar_1d.html"},{"title":"SELF_Tensor_3D – SELF","text":"Uses SELF_Tensor_3D_t Contents Derived Types Tensor3D Derived Types type, public, extends( Tensor3D_t ) :: Tensor3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N character(len=3), public :: backend = \"cpu\" real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: boundary type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor3D_t generic, public :: Determinant => Determinant_Tensor3D_t procedure, public :: Free => Free_Tensor3D_t procedure, public :: Init => Init_Tensor3D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Tensor3D_t procedure, public :: UpdateHost => UpdateHost_Tensor3D_t","tags":"","loc":"module/self_tensor_3d.html"},{"title":"self_NullDGModel2D – SELF","text":"Uses self_NullDGModel2D_t Contents Derived Types NullDGModel2D Derived Types type, public, extends( NullDGModel2D_t ) :: NullDGModel2D Components Type Visibility Attributes Name Initial type( MappedScalar2D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector2D ), public :: flux type( MappedScalar2D ), public :: fluxDivergence type( SEMQuad ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh2D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar2D ), public :: solution type( MappedVector2D ), public :: solutionGradient type( MappedScalar2D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar2D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel2D procedure, public :: CalculateEntropy => CalculateEntropy_DGModel2D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D procedure, public :: CalculateTendency => CalculateTendency_DGModel2D procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel2D procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel2D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel2D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel2D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel2D procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D procedure, public :: SetMetadata => SetMetadata_DGModel2D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel2D_t, SetSolutionFromEqn_DGModel2D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel2D procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel2D procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel2D procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel2D procedure, public :: UpdateSolution => UpdateSolution_DGModel2D procedure, public :: WriteModel => Write_DGModel2D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel2D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_nulldgmodel2d.html"},{"title":"SELF_Scalar_3D – SELF","text":"Uses SELF_Scalar_3D_t SELF_Constants iso_c_binding Contents Derived Types Scalar3D Derived Types type, public, extends( Scalar3D_t ) :: Scalar3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary character(len=3), public :: backend = \"cpu\" real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundarynormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar3D_t procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D_t procedure, public :: Free => Free_Scalar3D_t generic, public :: Gradient => Gradient_Scalar3D_t generic, public :: GridInterp => GridInterp_Scalar3D_t procedure, public :: Init => Init_Scalar3D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Scalar3D_t procedure, public :: UpdateHost => UpdateHost_Scalar3D_t generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D_t, WriteHDF5_Scalar3D_t","tags":"","loc":"module/self_scalar_3d~2.html"},{"title":"SELF_Scalar_2D – SELF","text":"Uses SELF_Scalar_2D_t SELF_Constants iso_c_binding Contents Derived Types Scalar2D Derived Types type, public, extends( Scalar2D_t ) :: Scalar2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: avgBoundary character(len=3), public :: backend = \"cpu\" real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundarynormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Scalar2D_t procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D_t procedure, public :: Free => Free_Scalar2D_t generic, public :: Gradient => Gradient_Scalar2D_t generic, public :: GridInterp => GridInterp_Scalar2D_t procedure, public :: Init => Init_Scalar2D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Scalar2D_t procedure, public :: UpdateHost => UpdateHost_Scalar2D_t generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D_t, WriteHDF5_Scalar2D_t","tags":"","loc":"module/self_scalar_2d.html"},{"title":"SELF_Vector_2D – SELF","text":"Uses SELF_Vector_2D_t Contents Derived Types Vector2D Derived Types type, public, extends( Vector2D_t ) :: Vector2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary character(len=3), public :: backend = \"cpu\" real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundaryNormal type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AverageSides => AverageSides_Vector2D_t procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D_t generic, public :: Divergence => Divergence_Vector2D_t procedure, public :: Free => Free_Vector2D_t generic, public :: Gradient => Gradient_Vector2D_t generic, public :: GridInterp => GridInterp_Vector2D_t procedure, public :: Init => Init_Vector2D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector2D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Vector2D_t procedure, public :: UpdateHost => UpdateHost_Vector2D_t generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D_t, WriteHDF5_Vector2D_t","tags":"","loc":"module/self_vector_2d.html"},{"title":"SELF_MappedScalar_2D – SELF","text":"Uses SELF_MappedScalar_2D_t Contents Derived Types MappedScalar2D Derived Types type, public, extends( MappedScalar2D_t ) :: MappedScalar2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundary type(c_ptr), public :: boundary_gpu real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundarynormal type(c_ptr), public :: boundarynormal_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMQuad ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedScalar2D_t procedure, public :: AverageSides => AverageSides_Scalar2D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D procedure, public :: DissociateGeometry => DissociateGeometry_MappedScalar2D_t procedure, public :: Free => Free_Scalar2D generic, public :: Gradient => Gradient_Scalar2D_t, Gradient_Scalar2D generic, public :: GridInterp => GridInterp_Scalar2D_t, GridInterp_Scalar2D procedure, public :: Init => Init_Scalar2D generic, public :: MappedDGGradient => MappedDGGradient_MappedScalar2D_t generic, public :: MappedGradient => MappedGradient_MappedScalar2D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar2D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedScalar2D_t procedure, public :: UpdateDevice => UpdateDevice_Scalar2D procedure, public :: UpdateHost => UpdateHost_Scalar2D generic, public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D_t, WriteHDF5_Scalar2D_t","tags":"","loc":"module/self_mappedscalar_2d.html"},{"title":"SELF_DGModel3D – SELF","text":"Uses SELF_DGModel3D_t Contents Derived Types DGModel3D Derived Types type, public, extends( DGModel3D_t ) :: DGModel3D Components Type Visibility Attributes Name Initial type( MappedScalar3D ), public :: dSdt real(kind=prec), public :: dt real(kind=prec), public :: entropy type( MappedVector3D ), public :: flux type( MappedScalar3D ), public :: fluxDivergence type( SEMHex ), public, pointer :: geometry logical, public :: gradient_enabled = .false. integer, public :: ioIterate = 0 type( Mesh3D ), public, pointer :: mesh integer, public :: nvar type( MappedScalar3D ), public :: solution type( MappedVector3D ), public :: solutionGradient type( MappedScalar3D ), public :: source real(kind=prec), public :: t procedure( SELF_timeIntegrator ), public, pointer :: timeIntegrator => Euler_timeIntegrator type( MappedScalar3D ), public :: workSol Type-Bound Procedures procedure, public :: BoundaryFlux => BoundaryFlux_DGModel3D_t procedure, public :: CalculateEntropy => CalculateEntropy_DGModel3D_t procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D_t procedure, public :: CalculateTendency => CalculateTendency_DGModel3D_t procedure, public :: Euler_timeIntegrator procedure, public :: FluxMethod => fluxmethod_DGModel3D_t procedure, public :: ForwardStep => ForwardStep_Model procedure, public :: Free => Free_DGModel3D_t procedure, public :: GetSimulationTime procedure, public :: IncrementIOCounter procedure, public :: Init => Init_DGModel3D_t procedure, public :: LowStorageRK2_timeIntegrator procedure, public :: LowStorageRK3_timeIntegrator procedure, public :: LowStorageRK4_timeIntegrator procedure, public :: PreTendency => PreTendency_Model procedure, public :: PrintType => PrintType_Model procedure, public :: ReadModel => Read_DGModel3D_t procedure, public :: ReportEntropy => ReportEntropy_Model procedure, public :: SetBoundaryCondition => setboundarycondition_DGModel3D_t procedure, public :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D_t procedure, public :: SetMetadata => SetMetadata_DGModel3D_t procedure, public :: SetSimulationTime generic, public :: SetSolution => SetSolutionFromChar_DGModel3D_t, SetSolutionFromEqn_DGModel3D_t generic, public :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure, public :: SourceMethod => sourcemethod_DGModel3D_t procedure, public :: UpdateGRK2 => UpdateGRK2_DGModel3D_t procedure, public :: UpdateGRK3 => UpdateGRK3_DGModel3D_t procedure, public :: UpdateGRK4 => UpdateGRK4_DGModel3D_t procedure, public :: UpdateSolution => UpdateSolution_DGModel3D_t procedure, public :: WriteModel => Write_DGModel3D_t procedure, public :: WriteTecplot => WriteTecplot_DGModel3D_t procedure, public :: entropy_func => entropy_func_Model procedure, public :: flux1D => flux1d_Model procedure, public :: flux2D => flux2d_Model procedure, public :: flux3D => flux3d_Model procedure, public :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure, public :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure, public :: hbc1d_Radiation => hbc1d_Generic_Model procedure, public :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure, public :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure, public :: hbc2d_Radiation => hbc2d_Generic_Model procedure, public :: hbc3d_NoNormalFlow => hbc3d_Generic_Model procedure, public :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure, public :: hbc3d_Radiation => hbc3d_Generic_Model procedure, public :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure, public :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure, public :: pbc1d_Radiation => pbc1d_Generic_Model procedure, public :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure, public :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure, public :: pbc2d_Radiation => pbc2d_Generic_Model procedure, public :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure, public :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure, public :: pbc3d_Radiation => pbc3d_Generic_Model procedure, public :: riemannflux1d => riemannflux1d_Model procedure, public :: riemannflux2d => riemannflux2d_Model procedure, public :: riemannflux3d => riemannflux3d_Model procedure, public :: source1d => source1d_Model procedure, public :: source2d => source2d_Model procedure, public :: source3d => source3d_Model","tags":"","loc":"module/self_dgmodel3d.html"},{"title":"SELF_MappedVector_2D – SELF","text":"Uses SELF_MappedVector_2D_t Contents Derived Types MappedVector2D Derived Types type, public, extends( MappedVector2D_t ) :: MappedVector2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: avgBoundary type(c_ptr), public :: avgBoundary_gpu character(len=3), public :: backend = \"gpu\" type(c_ptr), public :: blas_handle real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: boundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:) :: boundaryNormal type(c_ptr), public :: boundaryNormal_gpu type(c_ptr), public :: boundary_gpu type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: extBoundary type(c_ptr), public :: extBoundary_gpu type( SEMQuad ), public, pointer :: geometry => null() logical, public :: geometry_associated = .false. real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:) :: interior type(c_ptr), public :: interior_gpu type( Lagrange ), public, pointer :: interp type(c_ptr), public :: interpWork type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: AssociateGeometry => AssociateGeometry_MappedVector2D_t procedure, public :: AverageSides => AverageSides_Vector2D procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D procedure, public :: DissociateGeometry => DissociateGeometry_MappedVector2D_t generic, public :: Divergence => Divergence_Vector2D_t, Divergence_Vector2D procedure, public :: Free => Free_Vector2D generic, public :: Gradient => Gradient_Vector2D_t, Gradient_Vector2D generic, public :: GridInterp => GridInterp_Vector2D_t, GridInterp_Vector2D procedure, public :: Init => Init_Vector2D generic, public :: MappedDGDivergence => MappedDGDivergence_MappedVector2D_t generic, public :: MappedDivergence => MappedDivergence_MappedVector2D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj, SetEquation_Vector2D_t procedure, public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector2D_t procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: SideExchange => SideExchange_MappedVector2D_t procedure, public :: UpdateDevice => UpdateDevice_Vector2D procedure, public :: UpdateHost => UpdateHost_Vector2D generic, public :: WriteHDF5 => WriteHDF5_MPI_Vector2D_t, WriteHDF5_Vector2D_t","tags":"","loc":"module/self_mappedvector_2d.html"},{"title":"SELF_Tensor_2D – SELF","text":"Uses SELF_Tensor_2D_t Contents Derived Types Tensor2D Derived Types type, public, extends( Tensor2D_t ) :: Tensor2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N character(len=3), public :: backend = \"cpu\" real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: boundary type(EquationParser), public, allocatable :: eqn (:) real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: extBoundary real(kind=prec), public, pointer, contiguous, dimension(:,:,:,:,:,:) :: interior type( Lagrange ), public, pointer :: interp type( Metadata ), public, allocatable :: meta (:) integer, public :: nElem integer, public :: nVar Type-Bound Procedures procedure, public :: BoundaryInterp => BoundaryInterp_Tensor2D_t generic, public :: Determinant => Determinant_Tensor2D_t procedure, public :: Free => Free_Tensor2D_t procedure, public :: Init => Init_Tensor2D_t procedure, public :: SetDescription => SetDescription_DataObj generic, public :: SetEquation => SetEquation_DataObj procedure, public :: SetName => SetName_DataObj procedure, public :: SetUnits => SetUnits_DataObj procedure, public :: UpdateDevice => UpdateDevice_Tensor2D_t procedure, public :: UpdateHost => UpdateHost_Tensor2D_t","tags":"","loc":"module/self_tensor_2d~2.html"},{"title":"SELF_DGModel3D_t.f90 – SELF","text":"Contents Modules SELF_DGModel3D_t Source Code SELF_DGModel3D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_DGModel3D_t use SELF_SupportRoutines use SELF_Metadata use SELF_Geometry_3D use SELF_Mesh_3D use SELF_MappedScalar_3D use SELF_MappedVector_3D use SELF_HDF5 use HDF5 use FEQParse use SELF_Model implicit none type , extends ( Model ) :: DGModel3D_t type ( MappedScalar3D ) :: solution type ( MappedVector3D ) :: solutionGradient type ( MappedVector3D ) :: flux type ( MappedScalar3D ) :: source type ( MappedScalar3D ) :: fluxDivergence type ( MappedScalar3D ) :: dSdt type ( MappedScalar3D ) :: workSol type ( Mesh3D ), pointer :: mesh type ( SEMHex ), pointer :: geometry contains procedure :: Init => Init_DGModel3D_t procedure :: SetMetadata => SetMetadata_DGModel3D_t procedure :: Free => Free_DGModel3D_t procedure :: CalculateEntropy => CalculateEntropy_DGModel3D_t procedure :: BoundaryFlux => BoundaryFlux_DGModel3D_t procedure :: FluxMethod => fluxmethod_DGModel3D_t procedure :: SourceMethod => sourcemethod_DGModel3D_t procedure :: SetBoundaryCondition => setboundarycondition_DGModel3D_t procedure :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D_t procedure :: UpdateSolution => UpdateSolution_DGModel3D_t procedure :: UpdateGRK2 => UpdateGRK2_DGModel3D_t procedure :: UpdateGRK3 => UpdateGRK3_DGModel3D_t procedure :: UpdateGRK4 => UpdateGRK4_DGModel3D_t procedure :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D_t procedure :: CalculateTendency => CalculateTendency_DGModel3D_t generic :: SetSolution => SetSolutionFromChar_DGModel3D_t , & SetSolutionFromEqn_DGModel3D_t procedure , private :: SetSolutionFromChar_DGModel3D_t procedure , private :: SetSolutionFromEqn_DGModel3D_t procedure :: ReadModel => Read_DGModel3D_t procedure :: WriteModel => Write_DGModel3D_t procedure :: WriteTecplot => WriteTecplot_DGModel3D_t endtype DGModel3D_t contains subroutine Init_DGModel3D_t ( this , nvar , mesh , geometry ) implicit none class ( DGModel3D_t ), intent ( out ) :: this integer , intent ( in ) :: nvar type ( Mesh3D ), intent ( in ), target :: mesh type ( SEMHex ), intent ( in ), target :: geometry ! Local integer :: ivar character ( LEN = 3 ) :: ivarChar character ( LEN = 25 ) :: varname this % mesh => mesh this % geometry => geometry this % nvar = nvar call this % solution % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % workSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % dSdt % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % solutionGradient % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % flux % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % source % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % fluxDivergence % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % solution % AssociateGeometry ( geometry ) call this % solutionGradient % AssociateGeometry ( geometry ) call this % flux % AssociateGeometry ( geometry ) call this % fluxDivergence % AssociateGeometry ( geometry ) call this % SetMetadata () endsubroutine Init_DGModel3D_t subroutine SetMetadata_DGModel3D_t ( this ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! Local integer :: ivar character ( LEN = 3 ) :: ivarChar character ( LEN = 25 ) :: varname do ivar = 1 , this % nvar write ( ivarChar , '(I3.3)' ) ivar varname = \"solution\" // trim ( ivarChar ) call this % solution % SetName ( ivar , varname ) call this % solution % SetUnits ( ivar , \"[null]\" ) enddo endsubroutine SetMetadata_DGModel3D_t subroutine Free_DGModel3D_t ( this ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this call this % solution % Free () call this % workSol % Free () call this % dSdt % Free () call this % solutionGradient % Free () call this % flux % Free () call this % source % Free () call this % fluxDivergence % Free () endsubroutine Free_DGModel3D_t subroutine SetSolutionFromEqn_DGModel3D_t ( this , eqn ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this type ( EquationParser ), intent ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local integer :: iVar ! Copy the equation parser do iVar = 1 , this % solution % nVar call this % solution % SetEquation ( ivar , eqn ( iVar )% equation ) enddo call this % solution % SetInteriorFromEquation ( this % geometry , this % t ) call this % solution % BoundaryInterp () endsubroutine SetSolutionFromEqn_DGModel3D_t subroutine SetSolutionFromChar_DGModel3D_t ( this , eqnChar ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: eqnChar ( 1 : this % solution % nVar ) ! Local integer :: iVar do iVar = 1 , this % solution % nVar call this % solution % SetEquation ( ivar , trim ( eqnChar ( iVar ))) enddo call this % solution % SetInteriorFromEquation ( this % geometry , this % t ) call this % solution % BoundaryInterp () endsubroutine SetSolutionFromChar_DGModel3D_t subroutine UpdateSolution_DGModel3D_t ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) implicit none class ( DGModel3D_t ), intent ( inout ) :: this real ( prec ), optional , intent ( in ) :: dt ! Local real ( prec ) :: dtLoc integer :: i , j , k , iVar , iEl if ( present ( dt )) then dtLoc = dt else dtLoc = this % dt endif do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & k = 1 : this % solution % N + 1 , iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % solution % interior ( i , j , k , iEl , iVar ) = & this % solution % interior ( i , j , k , iEl , iVar ) + & dtLoc * this % dSdt % interior ( i , j , k , iEl , iVar ) enddo endsubroutine UpdateSolution_DGModel3D_t subroutine UpdateGRK2_DGModel3D_t ( this , m ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , j , k , iVar , iEl do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & k = 1 : this % solution % N + 1 , iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , j , k , iEl , iVar ) = rk2_a ( m ) * & this % workSol % interior ( i , j , k , iEl , iVar ) + & this % dSdt % interior ( i , j , k , iEl , iVar ) this % solution % interior ( i , j , k , iEl , iVar ) = & this % solution % interior ( i , j , k , iEl , iVar ) + & rk2_g ( m ) * this % dt * this % workSol % interior ( i , j , k , iEl , iVar ) enddo endsubroutine UpdateGRK2_DGModel3D_t subroutine UpdateGRK3_DGModel3D_t ( this , m ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , j , k , iVar , iEl do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & k = 1 : this % solution % N + 1 , iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , j , k , iEl , iVar ) = rk3_a ( m ) * & this % workSol % interior ( i , j , k , iEl , iVar ) + & this % dSdt % interior ( i , j , k , iEl , iVar ) this % solution % interior ( i , j , k , iEl , iVar ) = & this % solution % interior ( i , j , k , iEl , iVar ) + & rk3_g ( m ) * this % dt * this % workSol % interior ( i , j , k , iEl , iVar ) enddo endsubroutine UpdateGRK3_DGModel3D_t subroutine UpdateGRK4_DGModel3D_t ( this , m ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , j , k , iVar , iEl do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & k = 1 : this % solution % N + 1 , iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , j , k , iEl , iVar ) = rk4_a ( m ) * & this % workSol % interior ( i , j , k , iEl , iVar ) + & this % dSdt % interior ( i , j , k , iEl , iVar ) this % solution % interior ( i , j , k , iEl , iVar ) = & this % solution % interior ( i , j , k , iEl , iVar ) + & rk4_g ( m ) * this % dt * this % workSol % interior ( i , j , k , iEl , iVar ) enddo endsubroutine UpdateGRK4_DGModel3D_t subroutine CalculateSolutionGradient_DGModel3D_t ( this ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this call this % solution % AverageSides () call this % solution % MappedDGGradient ( this % solutionGradient % interior ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp () ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh ) endsubroutine CalculateSolutionGradient_DGModel3D_t subroutine CalculateEntropy_DGModel3D_t ( this ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! Local integer :: iel , i , j , k , ierror real ( prec ) :: e , jac real ( prec ) :: s ( 1 : this % nvar ) e = 0.0_prec do iel = 1 , this % geometry % nelem do k = 1 , this % solution % interp % N + 1 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 jac = this % geometry % J % interior ( i , j , k , iel , 1 ) s = this % solution % interior ( i , j , k , iel , 1 : this % nvar ) e = e + this % entropy_func ( s ) * jac enddo enddo enddo enddo if ( this % mesh % decomp % mpiEnabled ) then call mpi_allreduce ( e , & this % entropy , & 1 , & this % mesh % decomp % mpiPrec , & MPI_SUM , & this % mesh % decomp % mpiComm , & iError ) else this % entropy = e endif endsubroutine CalculateEntropy_DGModel3D_t subroutine fluxmethod_DGModel3D_t ( this ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: i , j , k real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 3 ) do iel = 1 , this % mesh % nelem do k = 1 , this % solution % interp % N + 1 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , k , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) this % flux % interior ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) = this % flux3d ( s , dsdx ) enddo enddo enddo enddo endsubroutine fluxmethod_DGModel3D_t subroutine BoundaryFlux_DGModel3D_t ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! Local integer :: i , j , k , iel real ( prec ) :: sL ( 1 : this % nvar ), sR ( 1 : this % nvar ) real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ) :: nhat ( 1 : 3 ), nmag do iEl = 1 , this % solution % nElem do k = 1 , 6 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 ! Get the boundary normals on cell edges from the mesh geometry nhat = this % geometry % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) sL = this % solution % boundary ( i , j , k , iel , 1 : this % nvar ) ! interior solution sR = this % solution % extboundary ( i , j , k , iel , 1 : this % nvar ) ! exterior solution dsdx = this % solutiongradient % avgboundary ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) nmag = this % geometry % nScale % boundary ( i , j , k , iEl , 1 ) this % flux % boundaryNormal ( i , j , k , iEl , 1 : this % nvar ) = this % riemannflux3d ( sL , sR , dsdx , nhat ) * nmag enddo enddo enddo enddo endsubroutine BoundaryFlux_DGModel3D_t subroutine sourcemethod_DGModel3D_t ( this ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! Local integer :: i , j , k , iel real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 3 ) do iel = 1 , this % mesh % nelem do k = 1 , this % solution % interp % N + 1 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , k , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) this % source % interior ( i , j , k , iel , 1 : this % nvar ) = this % source3d ( s , dsdx ) enddo enddo enddo enddo endsubroutine sourcemethod_DGModel3D_t subroutine setboundarycondition_DGModel3D_t ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! local integer :: i , iEl , j , k , e2 , bcid real ( prec ) :: nhat ( 1 : 3 ), x ( 1 : 3 ) do iEl = 1 , this % solution % nElem ! Loop over all elements do k = 1 , 6 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , k , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , k , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do j = 1 , this % solution % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points x = this % geometry % x % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solution % extBoundary ( i , j , k , iEl , 1 : this % nvar ) = & this % hbc3d_Prescribed ( x , this % t ) enddo enddo elseif ( bcid == SELF_BC_RADIATION ) then do j = 1 , this % solution % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solution % extBoundary ( i , j , k , iEl , 1 : this % nvar ) = & this % hbc3d_Radiation ( this % solution % boundary ( i , j , k , iEl , 1 : this % nvar ), nhat ) enddo enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do j = 1 , this % solution % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solution % extBoundary ( i , j , k , iEl , 1 : this % nvar ) = & this % hbc3d_NoNormalFlow ( this % solution % boundary ( i , j , k , iEl , 1 : this % nvar ), nhat ) enddo enddo endif endif enddo enddo endsubroutine setboundarycondition_DGModel3D_t subroutine setgradientboundarycondition_DGModel3D_t ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! local integer :: i , iEl , j , k , e2 , bcid real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ) :: nhat ( 1 : 3 ), x ( 1 : 3 ) do iEl = 1 , this % solution % nElem ! Loop over all elements do k = 1 , 6 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , k , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , k , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do j = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points x = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solutiongradient % extBoundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) = & this % pbc3d_Prescribed ( x , this % t ) enddo enddo elseif ( bcid == SELF_BC_RADIATION ) then do j = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) dsdx = this % solutiongradient % boundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) this % solutiongradient % extBoundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) = & this % pbc3d_Radiation ( dsdx , nhat ) enddo enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do j = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) dsdx = this % solutiongradient % boundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) this % solutiongradient % extBoundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) = & this % pbc3d_NoNormalFlow ( dsdx , nhat ) enddo enddo endif endif enddo enddo endsubroutine setgradientboundarycondition_DGModel3D_t subroutine CalculateTendency_DGModel3D_t ( this ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this ! Local integer :: i , j , k , iVar , iEl call this % solution % BoundaryInterp () call this % solution % SideExchange ( this % mesh ) call this % PreTendency () ! User-supplied call this % SetBoundaryCondition () ! User-supplied if ( this % gradient_enabled ) then call this % solution % AverageSides () call this % CalculateSolutionGradient () call this % SetGradientBoundaryCondition () ! User-supplied call this % solutionGradient % AverageSides () endif call this % SourceMethod () ! User supplied call this % BoundaryFlux () ! User supplied call this % FluxMethod () ! User supplied call this % flux % MappedDGDivergence ( this % fluxDivergence % interior ) do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & k = 1 : this % solution % N + 1 , iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % dSdt % interior ( i , j , k , iEl , iVar ) = & this % source % interior ( i , j , k , iEl , iVar ) - & this % fluxDivergence % interior ( i , j , k , iEl , iVar ) enddo endsubroutine CalculateTendency_DGModel3D_t subroutine Write_DGModel3D_t ( this , fileName ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this character ( * ), optional , intent ( in ) :: fileName ! Local integer ( HID_T ) :: fileId character ( LEN = self_FileNameLength ) :: pickupFile character ( 13 ) :: timeStampString if ( present ( filename )) then pickupFile = filename else write ( timeStampString , '(I13.13)' ) this % ioIterate pickupFile = 'solution.' // timeStampString // '.h5' endif print * , __ FILE__ // \" : Writing pickup file : \" // trim ( pickupFile ) if ( this % mesh % decomp % mpiEnabled ) then call Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId , this % mesh % decomp % mpiComm ) ! Write the interpolant to the file print * , __ FILE__ // \" : Writing interpolant data to file\" call this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file print * , __ FILE__ // \" : Writing control grid solution to file\" call CreateGroup_HDF5 ( fileId , '/controlgrid' ) call this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' , & this % mesh % decomp % offsetElem ( this % mesh % decomp % rankId + 1 ), this % mesh % decomp % nElem ) ! Write the geometry to file print * , __ FILE__ // \" : Writing control grid geometry to file\" call this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry' , & this % mesh % decomp % offsetElem ( this % mesh % decomp % rankId + 1 ), this % mesh % decomp % nElem ) ! -- END : writing solution on control grid -- ! call Close_HDF5 ( fileId ) else call Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) ! Write the interpolant to the file print * , __ FILE__ // \" : Writing interpolant data to file\" call this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file print * , __ FILE__ // \" : Writing control grid solution to file\" call CreateGroup_HDF5 ( fileId , '/controlgrid' ) call this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' ) ! Write the geometry to file print * , __ FILE__ // \" : Writing control grid geometry to file\" call this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry' ) ! -- END : writing solution on control grid -- ! call Close_HDF5 ( fileId ) endif endsubroutine Write_DGModel3D_t subroutine Read_DGModel3D_t ( this , fileName ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: fileName ! Local integer ( HID_T ) :: fileId integer ( HID_T ) :: solOffset ( 1 : 4 ) integer :: firstElem , ivar if ( this % mesh % decomp % mpiEnabled ) then call Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % mesh % decomp % mpiComm ) else call Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) endif if ( this % mesh % decomp % mpiEnabled ) then firstElem = this % mesh % decomp % offsetElem ( this % mesh % decomp % rankId + 1 ) solOffset ( 1 : 4 ) = ( / 0 , 0 , 0 , firstElem / ) do ivar = 1 , this % solution % nvar call ReadArray_HDF5 ( fileId , & '/controlgrid/solution/' // trim ( this % solution % meta ( ivar )% name ), & this % solution % interior (:,:,:,:, ivar ), solOffset ) enddo else do ivar = 1 , this % solution % nvar call ReadArray_HDF5 ( fileId , & '/controlgrid/solution/' // trim ( this % solution % meta ( ivar )% name ), & this % solution % interior (:,:,:,:, ivar )) enddo endif call Close_HDF5 ( fileId ) endsubroutine Read_DGModel3D_t subroutine WriteTecplot_DGModel3D_t ( this , filename ) implicit none class ( DGModel3D_t ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: filename ! Local character ( 8 ) :: zoneID integer :: fUnit integer :: iEl , i , j , k , iVar character ( LEN = self_FileNameLength ) :: tecFile character ( LEN = self_TecplotHeaderLength ) :: tecHeader character ( LEN = self_FormatLength ) :: fmat character ( 13 ) :: timeStampString character ( 5 ) :: rankString type ( Scalar3D ) :: solution type ( Vector3D ) :: solutionGradient type ( Vector3D ) :: x type ( Lagrange ), target :: interp if ( present ( filename )) then tecFile = filename else write ( timeStampString , '(I13.13)' ) this % ioIterate if ( this % mesh % decomp % mpiEnabled ) then write ( rankString , '(I5.5)' ) this % mesh % decomp % rankId tecFile = 'solution.' // rankString // '.' // timeStampString // '.tec' else tecFile = 'solution.' // timeStampString // '.tec' endif endif ! Create an interpolant for the uniform grid call interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) call solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) call solutionGradient % Init ( interp , & this % solution % nVar , this % solution % nElem ) call x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid call this % geometry % x % GridInterp ( x % interior ) call this % solution % UpdateHost () call this % solutionGradient % UpdateHost () ! Map the solution to the target grid call this % solution % GridInterp ( solution % interior ) ! Map the solution to the target grid call this % solutionGradient % GridInterp ( solutionGradient % interior ) open ( UNIT = NEWUNIT ( fUnit ), & FILE = trim ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) tecHeader = 'VARIABLES = \"X\", \"Y\", \"Z\"' do iVar = 1 , this % solution % nVar tecHeader = trim ( tecHeader ) // ', \"' // trim ( this % solution % meta ( iVar )% name ) // '\"' enddo do iVar = 1 , this % solution % nVar tecHeader = trim ( tecHeader ) // ', \"d/dx(' // trim ( this % solution % meta ( iVar )% name ) // ')\"' enddo do iVar = 1 , this % solution % nVar tecHeader = trim ( tecHeader ) // ', \"d/dy(' // trim ( this % solution % meta ( iVar )% name ) // ')\"' enddo write ( fUnit , * ) trim ( tecHeader ) ! Create format statement write ( fmat , * ) 3 * this % solution % nvar + 3 fmat = '(' // trim ( fmat ) // '(ES16.7E3,1x))' do iEl = 1 , this % solution % nElem ! TO DO :: Get the global element ID write ( zoneID , '(I8.8)' ) iEl write ( fUnit , * ) 'ZONE T=\"el' // trim ( zoneID ) // '\", I=' , this % solution % interp % M + 1 , & ', J=' , this % solution % interp % M + 1 do k = 1 , this % solution % interp % M + 1 do j = 1 , this % solution % interp % M + 1 do i = 1 , this % solution % interp % M + 1 write ( fUnit , fmat ) x % interior ( i , j , k , iEl , 1 , 1 ), & x % interior ( i , j , k , iEl , 1 , 2 ), & x % interior ( i , j , k , iEl , 1 , 3 ), & solution % interior ( i , j , k , iEl , 1 : this % solution % nvar ), & solutionGradient % interior ( i , j , k , iEl , 1 : this % solution % nvar , 1 ), & solutionGradient % interior ( i , j , k , iEl , 1 : this % solution % nvar , 2 ), & solutionGradient % interior ( i , j , k , iEl , 1 : this % solution % nvar , 3 ) enddo enddo enddo enddo close ( UNIT = fUnit ) call x % Free () call solution % Free () call interp % Free () endsubroutine WriteTecplot_DGModel3D_t endmodule SELF_DGModel3D_t","tags":"","loc":"sourcefile/self_dgmodel3d_t.f90.html"},{"title":"SELF_advection_diffusion_2d_t.f90 – SELF","text":"Contents Modules self_advection_diffusion_2d_t Source Code SELF_advection_diffusion_2d_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_advection_diffusion_2d_t use self_dgmodel2d use self_mesh implicit none type , extends ( dgmodel2d ) :: advection_diffusion_2d_t real ( prec ) :: nu ! diffusion coefficient real ( prec ) :: u ! constant x-component of velocity real ( prec ) :: v ! constant y-component of velocity contains procedure :: riemannflux2d => riemannflux2d_advection_diffusion_2d_t procedure :: flux2d => flux2d_advection_diffusion_2d_t procedure :: entropy_func => entropy_func_advection_diffusion_2d_t endtype advection_diffusion_2d_t contains pure function entropy_func_advection_diffusion_2d_t ( this , s ) result ( e ) class ( advection_diffusion_2d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ) :: e ! Local integer :: ivar e = 0.0_prec do ivar = 1 , this % solution % nvar e = e + 0.5_prec * s ( ivar ) * s ( ivar ) enddo endfunction entropy_func_advection_diffusion_2d_t pure function flux2d_advection_diffusion_2d_t ( this , s , dsdx ) result ( flux ) class ( advection_diffusion_2d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % solution % nvar , 1 : 2 ) real ( prec ) :: flux ( 1 : this % solution % nvar , 1 : 2 ) ! Local integer :: ivar do ivar = 1 , this % solution % nvar flux ( ivar , 1 ) = this % u * s ( ivar ) - this % nu * dsdx ( ivar , 1 ) ! advective flux + diffusive flux flux ( ivar , 2 ) = this % v * s ( ivar ) - this % nu * dsdx ( ivar , 2 ) ! advective flux + diffusive flux enddo endfunction flux2d_advection_diffusion_2d_t pure function riemannflux2d_advection_diffusion_2d_t ( this , sL , sR , dsdx , nhat ) result ( flux ) class ( advection_diffusion_2d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: sL ( 1 : this % nvar ) real ( prec ), intent ( in ) :: sR ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ), intent ( in ) :: nhat ( 1 : 2 ) real ( prec ) :: flux ( 1 : this % nvar ) ! Local integer :: ivar real ( prec ) :: un , dsdn un = this % u * nhat ( 1 ) + this % v * nhat ( 2 ) do ivar = 1 , this % nvar dsdn = dsdx ( ivar , 1 ) * nhat ( 1 ) + dsdx ( ivar , 2 ) * nhat ( 2 ) flux ( ivar ) = 0.5_prec * ( & ( sL ( ivar ) + sR ( ivar )) + abs ( un ) * ( sL ( ivar ) - sR ( ivar ))) - & ! advective flux this % nu * dsdn enddo endfunction riemannflux2d_advection_diffusion_2d_t endmodule self_advection_diffusion_2d_t","tags":"","loc":"sourcefile/self_advection_diffusion_2d_t.f90.html"},{"title":"SELF_SupportRoutines.f90 – SELF","text":"Contents Modules SELF_SupportRoutines Source Code SELF_SupportRoutines.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! !> \\file SELF_SupportRoutines.f90 !! Contains the \\ref SELF_SupportRoutines module !> \\defgroup SELF_SupportRoutines SELF_SupportRoutines !! This module defines a set of general purpose routines. module SELF_SupportRoutines use iso_fortran_env use SELF_Constants implicit none interface AlmostEqual module procedure AlmostEqual_r64 endinterface AlmostEqual real ( prec ), private , parameter :: tolerance = 1 0.0 ** ( - 10 ) contains !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! Function AlmostEqual ! !> \\fn AlmostEqual !! Compares two floating point numbers and determines if they are equal (to machine precision). !! !!   This function is from Alg. 139 on pg. 359 of D.A. Kopriva, 2009, \"Implementing Spectral Element !!    Methods for Scientists and Engineers\" !! !! <H2> Usage : </H2> !! <B>Logical</B> :: AisB <BR> !! <B>REAL</B>(prec) :: a, b <BR> !!         .... <BR> !!     AisB = AlmostEqual( a, b ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> a <td> REAL(prec) <td> scalar !!   <tr> <td> in <th> b <td> REAL(prec) <td> scalar !!   <tr> <td> in <th> AisB <td> Logical <td> !!                     <B>.TRUE.</B> IF a=b to machine precision <BR> !!                     <B>.FALSE.</B> otherwise !!  </table> !! ! ================================================================================================ ! !>@} function AlmostEqual_r64 ( a , b ) result ( AisB ) implicit none real ( real64 ) :: a , b logical :: AisB if ( a == 0.0_real64 . or . b == 0.0_real64 ) then if ( abs ( a - b ) <= epsilon ( 1.0_real64 )) then AisB = . true . else AisB = . false . endif else if (( abs ( a - b ) <= epsilon ( 1.0_real64 ) * abs ( a )) . or . ( abs ( a - b ) <= epsilon ( 1.0_real64 ) * abs ( b ))) then AisB = . true . else AisB = . false . endif endif endfunction AlmostEqual_r64 !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R ForwardShift ! !> \\fn ForwardShift !! Shift an array integers by one index forward, moving the last index to the first. !! !! Shifts the array entries as follows : <BR> !!  myArray(1) <-- myArray(N) <BR> !!  myArray(2) <-- myArray(1) <BR> !!  myArray(3) <-- myArray(2) <BR> !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: N !! <B>INTEGER</B> :: myArray(1:N) <BR> !!         .... <BR> !!     <B>CALL</B> ForwardShift( myArray, N ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myArray(1:N) <td> INTEGER <td> !!                         On <B>output</B>, the input array with elements shifted forward by !!                         one index. !!   <tr> <td> in <th> N <td> INTEGER <td> !!                     The number of elements in the array !!  </table> !! ! ================================================================================================ ! !>@} subroutine ForwardShift ( myArray , N ) implicit none integer , intent ( in ) :: N integer , intent ( inout ) :: myArray ( 1 : N ) ! LOCAL integer :: temp ( 1 : N ) temp = myArray myArray ( 1 ) = temp ( N ) myArray ( 2 : N ) = temp ( 1 : N - 1 ) endsubroutine ForwardShift ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R CompareArray ! !> \\fn CompareArray !! Compares to INTEGER arrays and determines if they are identical. !! !! A logical is returned that specifies whether or not two arrays are identical. To determine !! if the two arrays are identical, the sum of the difference between each element in the input !! array is calculated. If the arrays are identical, each contribution to the sum is zero and hence !! the sum is zero. If the sum is non-zero, the arrays are distinct. !! !! This routine is used in the \\ref HexMeshClass module. A face of an element in an unstructured !! mesh is identified by its four corner nodes. When identifying unique faces in an unstructured !! mesh, we need to determine if two elements share a face. This can be accomplished by comparing !! the four corner nodes (from each element) that define each face. !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: N <BR> !! <B>INTEGER</B> :: arrayOne(1:N) <BR> !! <B>INTEGER</B> :: arrayTwo(1:N) <BR> !! <B>LOGICAL</B> :: arraysMatch <BR> !!         .... <BR> !!     arraysMatch = CompareArray( arrayOne, arrayTwo, N ) <BR> !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> arrayOne(1:N) <td> INTEGER <td> !!   <tr> <td> in <th> arrayTwo(1:N) <td> INTEGER <td> !!   <tr> <td> in <th> N <td> INTEGER <td> !!   <tr> <td> out <th> arraysMatch <td> INTEGER <td> !! !!  </table> !! ! ================================================================================================ ! !>@} function CompareArray ( arrayOne , arrayTwo , N ) result ( arraysMatch ) implicit none integer :: N integer :: arrayOne ( 1 : N ), arrayTwo ( 1 : N ) logical :: arraysMatch ! LOCAL integer :: i , theSumOfDiffs theSumOfDiffs = 0 do i = 1 , N theSumOfDiffs = theSumOfDiffs + abs ( arrayOne ( i ) - arrayTwo ( i )) enddo if ( theSumOfDiffs == 0 ) then arraysMatch = . true . else arraysMatch = . false . endif endfunction CompareArray ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R UniformPoints ! !> \\fn UniformPoints !! Generates a REAL(prec) array of N points evenly spaced between two points. !! !! !! <H2> Usage : </H2> !! <B>REAL</B>(prec) :: a <BR> !! <B>REAL</B>(prec) :: b <BR> !! <B>REAL</B>(prec) :: xU(0:N) <BR> !! <B>INTEGER</B> :: N <BR> !!         .... <BR> !!     xU = UniformPoints( a, b, N ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> a <td> REAL(prec) <td> Starting point of the interval !!   <tr> <td> in <th> b <td> REAL(prec) <td> Ending point of the interval !!   <tr> <td> in <th> N <td> INTEGER <td> The number of points in the interval \\f$[a,b]\\f$ !!   <tr> <td> in <th> xU(0:N) <td> REAL(prec) <td> !!                     Array of evenly spaced points in the interval \\f$[a,b]\\f$ !!  </table> !! ! ================================================================================================ ! !>@} function UniformPoints ( a , b , firstInd , lastInd ) result ( xU ) implicit none real ( prec ) :: a , b integer :: firstInd , lastInd real ( prec ) :: xU ( firstInd : lastInd ) ! LOCAL real ( prec ) :: dx integer :: i dx = ( b - a ) / real (( lastInd - firstInd ), prec ) do i = firstInd , lastInd xU ( i ) = a + dx * real ( i - firstInd , prec ) enddo endfunction UniformPoints integer function newunit ( unit ) !  https://fortranwiki.org/fortran/show/newunit integer , intent ( out ), optional :: unit ! local integer , parameter :: LUN_MIN = 10 , LUN_MAX = 1000 logical :: opened integer :: lun ! begin newunit = - 1 do lun = LUN_MIN , LUN_MAX inquire ( unit = lun , opened = opened ) if (. not . opened ) then newunit = lun exit endif enddo if ( present ( unit )) unit = newunit endfunction newunit function UpperCase ( str ) result ( upper ) implicit none character ( * ), intent ( In ) :: str character ( len ( str )) :: Upper integer :: ic , i character ( 27 ), parameter :: cap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ ' character ( 27 ), parameter :: low = 'abcdefghijklmnopqrstuvwxyz ' do i = 1 , len ( str ) ic = index ( low , str ( i : i )) if ( ic > 0 ) then Upper ( i : i ) = cap ( ic : ic ) else Upper ( i : i ) = str ( i : i ) endif enddo endfunction UpperCase endmodule SELF_SupportRoutines","tags":"","loc":"sourcefile/self_supportroutines.f90.html"},{"title":"SELF_Scalar_2D_t.f90 – SELF","text":"Contents Modules SELF_Scalar_2D_t Source Code SELF_Scalar_2D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Scalar_2D_t use SELF_Constants use SELF_Lagrange use SELF_Metadata use FEQParse use SELF_HDF5 use SELF_Data use HDF5 use iso_c_binding implicit none #include \"SELF_Macros.h\" type , extends ( SELF_DataObj ), public :: Scalar2D_t real ( prec ), pointer , contiguous , dimension (:,:,:,:) :: interior real ( prec ), pointer , contiguous , dimension (:,:,:,:) :: boundary real ( prec ), pointer , contiguous , dimension (:,:,:,:) :: extBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:) :: avgBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:) :: boundarynormal contains procedure , public :: Init => Init_Scalar2D_t procedure , public :: Free => Free_Scalar2D_t procedure , public :: UpdateHost => UpdateHost_Scalar2D_t procedure , public :: UpdateDevice => UpdateDevice_Scalar2D_t procedure , public :: BoundaryInterp => BoundaryInterp_Scalar2D_t procedure , public :: AverageSides => AverageSides_Scalar2D_t generic , public :: GridInterp => GridInterp_Scalar2D_t procedure , private :: GridInterp_Scalar2D_t generic , public :: Gradient => Gradient_Scalar2D_t procedure , private :: Gradient_Scalar2D_t generic , public :: WriteHDF5 => WriteHDF5_MPI_Scalar2D_t , WriteHDF5_Scalar2D_t procedure , private :: WriteHDF5_MPI_Scalar2D_t procedure , private :: WriteHDF5_Scalar2D_t endtype Scalar2D_t contains subroutine Init_Scalar2D_t ( this , interp , nVar , nElem ) implicit none class ( Scalar2D_t ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , interp % N + 1 , nelem , nvar ), & this % boundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : 2 * nvar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec this % boundarynormal = 0.0_prec allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) endsubroutine Init_Scalar2D_t subroutine Free_Scalar2D_t ( this ) implicit none class ( Scalar2D_t ), intent ( inout ) :: this this % nVar = 0 this % nElem = 0 this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % boundarynormal ) deallocate ( this % meta ) deallocate ( this % eqn ) endsubroutine Free_Scalar2D_t subroutine UpdateHost_Scalar2D_t ( this ) implicit none class ( Scalar2D_t ), intent ( inout ) :: this endsubroutine UpdateHost_Scalar2D_t subroutine UpdateDevice_Scalar2D_t ( this ) implicit none class ( Scalar2D_t ), intent ( inout ) :: this endsubroutine UpdateDevice_Scalar2D_t subroutine BoundaryInterp_Scalar2D_t ( this ) implicit none class ( Scalar2D_t ), intent ( inout ) :: this ! Local integer :: i , ii , iel , ivar real ( prec ) :: fbs , fbe , fbn , fbw do concurrent ( i = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) fbs = 0.0_prec fbe = 0.0_prec fbn = 0.0_prec fbw = 0.0_prec do ii = 1 , this % N + 1 fbs = fbs + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , ii , iel , ivar ) ! South fbe = fbe + this % interp % bMatrix ( ii , 2 ) * this % interior ( ii , i , iel , ivar ) ! East fbn = fbn + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , ii , iel , ivar ) ! North fbw = fbw + this % interp % bMatrix ( ii , 1 ) * this % interior ( ii , i , iel , ivar ) ! West enddo this % boundary ( i , 1 , iel , ivar ) = fbs this % boundary ( i , 2 , iel , ivar ) = fbe this % boundary ( i , 3 , iel , ivar ) = fbn this % boundary ( i , 4 , iel , ivar ) = fbw enddo endsubroutine BoundaryInterp_Scalar2D_t subroutine AverageSides_Scalar2D_t ( this ) implicit none class ( Scalar2D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: iside integer :: ivar integer :: i do concurrent ( i = 1 : this % interp % N + 1 , iside = 1 : 4 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) this % avgBoundary ( i , iside , iel , ivar ) = 0.5_prec * ( & this % boundary ( i , iside , iel , ivar ) + & this % extBoundary ( i , iside , iel , ivar )) enddo endsubroutine AverageSides_Scalar2D_t subroutine GridInterp_Scalar2D_t ( this , f ) implicit none class ( Scalar2D_t ), intent ( in ) :: this real ( prec ), intent ( inout ) :: f ( 1 : this % M + 1 , 1 : this % M + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: i , j , ii , jj , iel , ivar real ( prec ) :: fi , fij do concurrent ( i = 1 : this % M + 1 , j = 1 : this % M + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) fij = 0.0_prec do jj = 1 , this % N + 1 fi = 0.0_prec do ii = 1 , this % N + 1 fi = fi + this % interior ( ii , jj , iel , ivar ) * this % interp % iMatrix ( ii , i ) enddo fij = fij + fi * this % interp % iMatrix ( jj , j ) enddo f ( i , j , iel , ivar ) = fij enddo endsubroutine GridInterp_Scalar2D_t subroutine Gradient_Scalar2D_t ( this , df ) implicit none class ( Scalar2D_t ), intent ( in ) :: this real ( prec ), intent ( inout ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 2 ) ! Local integer :: i , j , ii , iel , ivar real ( prec ) :: df1 , df2 do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) df1 = 0.0_prec df2 = 0.0_prec do ii = 1 , this % N + 1 df1 = df1 + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , iel , ivar ) df2 = df2 + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , iel , ivar ) enddo df ( i , j , iel , ivar , 1 ) = df1 df ( i , j , iel , ivar , 2 ) = df2 enddo endsubroutine Gradient_Scalar2D_t subroutine WriteHDF5_MPI_Scalar2D_t ( this , fileId , group , elemoffset , nglobalelem ) implicit none class ( Scalar2D_t ), intent ( in ) :: this character ( * ), intent ( in ) :: group integer ( HID_T ), intent ( in ) :: fileId integer , intent ( in ) :: elemoffset integer , intent ( in ) :: nglobalelem ! Local integer ( HID_T ) :: offset ( 1 : 3 ) integer ( HID_T ) :: globalDims ( 1 : 3 ) integer :: ivar offset ( 1 : 3 ) = ( / 0 , 0 , elemoffset / ) globalDims ( 1 : 3 ) = ( / this % interp % N + 1 , & this % interp % N + 1 , & nglobalelem / ) call CreateGroup_HDF5 ( fileId , trim ( group )) do ivar = 1 , this % nVar !call this%meta(ivar)%WriteHDF5(group,ivar,fileId) call WriteArray_HDF5 ( fileId , & trim ( group ) // \"/\" // trim ( this % meta ( ivar )% name ), & this % interior (:,:,:, ivar ), offset , globalDims ) enddo endsubroutine WriteHDF5_MPI_Scalar2D_t subroutine WriteHDF5_Scalar2D_t ( this , fileId , group ) implicit none class ( Scalar2D_t ), intent ( in ) :: this integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: group ! Local integer :: ivar call CreateGroup_HDF5 ( fileId , trim ( group )) do ivar = 1 , this % nVar call this % meta ( ivar )% WriteHDF5 ( group , ivar , fileId ) call WriteArray_HDF5 ( fileId , & trim ( group ) // \"/\" // trim ( this % meta ( ivar )% name ), & this % interior (:,:,:, ivar )) enddo endsubroutine WriteHDF5_Scalar2D_t endmodule SELF_Scalar_2D_t","tags":"","loc":"sourcefile/self_scalar_2d_t.f90.html"},{"title":"SELF_DGModel2D_t.f90 – SELF","text":"Contents Modules SELF_DGModel2D_t Source Code SELF_DGModel2D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_DGModel2D_t use SELF_SupportRoutines use SELF_Metadata use SELF_Geometry_2D use SELF_Mesh_2D use SELF_MappedScalar_2D use SELF_MappedVector_2D use SELF_HDF5 use HDF5 use FEQParse use SELF_Model implicit none #include \"SELF_Macros.h\" type , extends ( Model ) :: DGModel2D_t type ( MappedScalar2D ) :: solution type ( MappedVector2D ) :: solutionGradient type ( MappedVector2D ) :: flux type ( MappedScalar2D ) :: source type ( MappedScalar2D ) :: fluxDivergence type ( MappedScalar2D ) :: dSdt type ( MappedScalar2D ) :: workSol type ( Mesh2D ), pointer :: mesh type ( SEMQuad ), pointer :: geometry contains procedure :: Init => Init_DGModel2D_t procedure :: SetMetadata => SetMetadata_DGModel2D_t procedure :: Free => Free_DGModel2D_t procedure :: CalculateEntropy => CalculateEntropy_DGModel2D_t procedure :: BoundaryFlux => BoundaryFlux_DGModel2D_t procedure :: FluxMethod => fluxmethod_DGModel2D_t procedure :: SourceMethod => sourcemethod_DGModel2D_t procedure :: SetBoundaryCondition => setboundarycondition_DGModel2D_t procedure :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D_t procedure :: UpdateSolution => UpdateSolution_DGModel2D_t procedure :: UpdateGRK2 => UpdateGRK2_DGModel2D_t procedure :: UpdateGRK3 => UpdateGRK3_DGModel2D_t procedure :: UpdateGRK4 => UpdateGRK4_DGModel2D_t procedure :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D_t procedure :: CalculateTendency => CalculateTendency_DGModel2D_t generic :: SetSolution => SetSolutionFromChar_DGModel2D_t , & SetSolutionFromEqn_DGModel2D_t procedure , private :: SetSolutionFromChar_DGModel2D_t procedure , private :: SetSolutionFromEqn_DGModel2D_t procedure :: ReadModel => Read_DGModel2D_t procedure :: WriteModel => Write_DGModel2D_t procedure :: WriteTecplot => WriteTecplot_DGModel2D_t endtype DGModel2D_t contains subroutine Init_DGModel2D_t ( this , nvar , mesh , geometry ) implicit none class ( DGModel2D_t ), intent ( out ) :: this integer , intent ( in ) :: nvar type ( Mesh2D ), intent ( in ), target :: mesh type ( SEMQuad ), intent ( in ), target :: geometry ! Local integer :: ivar character ( LEN = 3 ) :: ivarChar character ( LEN = 25 ) :: varname this % mesh => mesh this % geometry => geometry this % nvar = nvar call this % solution % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % workSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % dSdt % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % solutionGradient % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % flux % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % source % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % fluxDivergence % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % solution % AssociateGeometry ( geometry ) call this % solutionGradient % AssociateGeometry ( geometry ) call this % flux % AssociateGeometry ( geometry ) call this % fluxDivergence % AssociateGeometry ( geometry ) call this % SetMetadata () endsubroutine Init_DGModel2D_t subroutine SetMetadata_DGModel2D_t ( this ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! Local integer :: ivar character ( LEN = 3 ) :: ivarChar character ( LEN = 25 ) :: varname do ivar = 1 , this % nvar write ( ivarChar , '(I3.3)' ) ivar varname = \"solution\" // trim ( ivarChar ) call this % solution % SetName ( ivar , varname ) call this % solution % SetUnits ( ivar , \"[null]\" ) enddo endsubroutine SetMetadata_DGModel2D_t subroutine Free_DGModel2D_t ( this ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this call this % solution % Free () call this % workSol % Free () call this % dSdt % Free () call this % solutionGradient % Free () call this % flux % Free () call this % source % Free () call this % fluxDivergence % Free () endsubroutine Free_DGModel2D_t subroutine SetSolutionFromEqn_DGModel2D_t ( this , eqn ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this type ( EquationParser ), intent ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local integer :: iVar ! Copy the equation parser do iVar = 1 , this % solution % nVar call this % solution % SetEquation ( ivar , eqn ( iVar )% equation ) enddo call this % solution % SetInteriorFromEquation ( this % geometry , this % t ) call this % solution % BoundaryInterp () endsubroutine SetSolutionFromEqn_DGModel2D_t subroutine SetSolutionFromChar_DGModel2D_t ( this , eqnChar ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: eqnChar ( 1 : this % solution % nVar ) ! Local integer :: iVar do iVar = 1 , this % solution % nVar call this % solution % SetEquation ( ivar , trim ( eqnChar ( iVar ))) enddo call this % solution % SetInteriorFromEquation ( this % geometry , this % t ) call this % solution % BoundaryInterp () endsubroutine SetSolutionFromChar_DGModel2D_t subroutine UpdateSolution_DGModel2D_t ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) implicit none class ( DGModel2D_t ), intent ( inout ) :: this real ( prec ), optional , intent ( in ) :: dt ! Local real ( prec ) :: dtLoc integer :: i , j , iEl , iVar if ( present ( dt )) then dtLoc = dt else dtLoc = this % dt endif do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % solution % interior ( i , j , iEl , iVar ) = & this % solution % interior ( i , j , iEl , iVar ) + & dtLoc * this % dSdt % interior ( i , j , iEl , iVar ) enddo endsubroutine UpdateSolution_DGModel2D_t subroutine UpdateGRK2_DGModel2D_t ( this , m ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , j , iEl , iVar do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , j , iEl , iVar ) = rk2_a ( m ) * & this % workSol % interior ( i , j , iEl , iVar ) + & this % dSdt % interior ( i , j , iEl , iVar ) this % solution % interior ( i , j , iEl , iVar ) = & this % solution % interior ( i , j , iEl , iVar ) + & rk2_g ( m ) * this % dt * this % workSol % interior ( i , j , iEl , iVar ) enddo endsubroutine UpdateGRK2_DGModel2D_t subroutine UpdateGRK3_DGModel2D_t ( this , m ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , j , iEl , iVar do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , j , iEl , iVar ) = rk3_a ( m ) * & this % workSol % interior ( i , j , iEl , iVar ) + & this % dSdt % interior ( i , j , iEl , iVar ) this % solution % interior ( i , j , iEl , iVar ) = & this % solution % interior ( i , j , iEl , iVar ) + & rk3_g ( m ) * this % dt * this % workSol % interior ( i , j , iEl , iVar ) enddo endsubroutine UpdateGRK3_DGModel2D_t subroutine UpdateGRK4_DGModel2D_t ( this , m ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , j , iEl , iVar do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , j , iEl , iVar ) = rk4_a ( m ) * & this % workSol % interior ( i , j , iEl , iVar ) + & this % dSdt % interior ( i , j , iEl , iVar ) this % solution % interior ( i , j , iEl , iVar ) = & this % solution % interior ( i , j , iEl , iVar ) + & rk4_g ( m ) * this % dt * this % workSol % interior ( i , j , iEl , iVar ) enddo endsubroutine UpdateGRK4_DGModel2D_t subroutine CalculateSolutionGradient_DGModel2D_t ( this ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this call this % solution % AverageSides () call this % solution % MappedDGGradient ( this % solutionGradient % interior ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp () ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh ) endsubroutine CalculateSolutionGradient_DGModel2D_t subroutine CalculateEntropy_DGModel2D_t ( this ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! Local integer :: iel , i , j , ierror real ( prec ) :: e , jac real ( prec ) :: s ( 1 : this % nvar ) e = 0.0_prec do iel = 1 , this % geometry % nelem do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 jac = this % geometry % J % interior ( i , j , iel , 1 ) s = this % solution % interior ( i , j , iel , 1 : this % nvar ) e = e + this % entropy_func ( s ) * jac enddo enddo enddo if ( this % mesh % decomp % mpiEnabled ) then call mpi_allreduce ( e , & this % entropy , & 1 , & this % mesh % decomp % mpiPrec , & MPI_SUM , & this % mesh % decomp % mpiComm , & iError ) else this % entropy = e endif endsubroutine CalculateEntropy_DGModel2D_t subroutine fluxmethod_DGModel2D_t ( this ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: i integer :: j real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 2 ) do iel = 1 , this % mesh % nelem do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , iel , 1 : this % nvar , 1 : 2 ) this % flux % interior ( i , j , iel , 1 : this % nvar , 1 : 2 ) = this % flux2d ( s , dsdx ) enddo enddo enddo endsubroutine fluxmethod_DGModel2D_t subroutine BoundaryFlux_DGModel2D_t ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: j integer :: i real ( prec ) :: sL ( 1 : this % nvar ), sR ( 1 : this % nvar ) real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ) :: nhat ( 1 : 2 ), nmag do iEl = 1 , this % solution % nElem do j = 1 , 4 do i = 1 , this % solution % interp % N + 1 ! Get the boundary normals on cell edges from the mesh geometry nhat = this % geometry % nHat % boundary ( i , j , iEl , 1 , 1 : 2 ) sL = this % solution % boundary ( i , j , iel , 1 : this % nvar ) ! interior solution sR = this % solution % extboundary ( i , j , iel , 1 : this % nvar ) ! exterior solution dsdx = this % solutiongradient % avgboundary ( i , j , iel , 1 : this % nvar , 1 : 2 ) nmag = this % geometry % nScale % boundary ( i , j , iEl , 1 ) this % flux % boundaryNormal ( i , j , iEl , 1 : this % nvar ) = this % riemannflux2d ( sL , sR , dsdx , nhat ) * nmag enddo enddo enddo endsubroutine BoundaryFlux_DGModel2D_t subroutine sourcemethod_DGModel2D_t ( this ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: i integer :: j real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 2 ) do iel = 1 , this % mesh % nelem do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , iel , 1 : this % nvar , 1 : 2 ) this % source % interior ( i , j , iel , 1 : this % nvar ) = this % source2d ( s , dsdx ) enddo enddo enddo endsubroutine sourcemethod_DGModel2D_t subroutine setboundarycondition_DGModel2D_t ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! local integer :: i , iEl , j , e2 , bcid real ( prec ) :: nhat ( 1 : 2 ), x ( 1 : 2 ) do iEl = 1 , this % solution % nElem ! Loop over all elements do j = 1 , 4 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , j , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , j , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points x = this % geometry % x % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solution % extBoundary ( i , j , iEl , 1 : this % nvar ) = & this % hbc2d_Prescribed ( x , this % t ) enddo elseif ( bcid == SELF_BC_RADIATION ) then do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solution % extBoundary ( i , j , iEl , 1 : this % nvar ) = & this % hbc2d_Radiation ( this % solution % boundary ( i , j , iEl , 1 : this % nvar ), nhat ) enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solution % extBoundary ( i , j , iEl , 1 : this % nvar ) = & this % hbc2d_NoNormalFlow ( this % solution % boundary ( i , j , iEl , 1 : this % nvar ), nhat ) enddo endif endif enddo enddo endsubroutine setboundarycondition_DGModel2D_t subroutine setgradientboundarycondition_DGModel2D_t ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! local integer :: i , iEl , j , e2 , bcid real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ) :: nhat ( 1 : 2 ), x ( 1 : 2 ) do iEl = 1 , this % solution % nElem ! Loop over all elements do j = 1 , 4 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , j , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , j , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points x = this % geometry % x % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solutiongradient % extBoundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) = & this % pbc2d_Prescribed ( x , this % t ) enddo elseif ( bcid == SELF_BC_RADIATION ) then do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) dsdx = this % solutiongradient % boundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) this % solutiongradient % extBoundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) = & this % pbc2d_Radiation ( dsdx , nhat ) enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) dsdx = this % solutiongradient % boundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) this % solutiongradient % extBoundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) = & this % pbc2d_NoNormalFlow ( dsdx , nhat ) enddo endif endif enddo enddo endsubroutine setgradientboundarycondition_DGModel2D_t subroutine CalculateTendency_DGModel2D_t ( this ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this ! Local integer :: i , j , iEl , iVar call this % solution % BoundaryInterp () call this % solution % SideExchange ( this % mesh ) call this % PreTendency () ! User-supplied call this % SetBoundaryCondition () ! User-supplied if ( this % gradient_enabled ) then call this % solution % AverageSides () call this % CalculateSolutionGradient () call this % SetGradientBoundaryCondition () ! User-supplied call this % solutionGradient % AverageSides () endif call this % SourceMethod () ! User supplied call this % BoundaryFlux () ! User supplied call this % FluxMethod () ! User supplied call this % flux % MappedDGDivergence ( this % fluxDivergence % interior ) do concurrent ( i = 1 : this % solution % N + 1 , j = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % dSdt % interior ( i , j , iEl , iVar ) = & this % source % interior ( i , j , iEl , iVar ) - & this % fluxDivergence % interior ( i , j , iEl , iVar ) enddo endsubroutine CalculateTendency_DGModel2D_t subroutine Write_DGModel2D_t ( this , fileName ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this character ( * ), optional , intent ( in ) :: fileName ! Local integer ( HID_T ) :: fileId character ( LEN = self_FileNameLength ) :: pickupFile character ( 13 ) :: timeStampString if ( present ( filename )) then pickupFile = filename else write ( timeStampString , '(I13.13)' ) this % ioIterate pickupFile = 'solution.' // timeStampString // '.h5' endif print * , __ FILE__ // \" : Writing pickup file : \" // trim ( pickupFile ) call this % solution % UpdateHost () if ( this % mesh % decomp % mpiEnabled ) then call Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId , this % mesh % decomp % mpiComm ) ! Write the interpolant to the file print * , __ FILE__ // \" : Writing interpolant data to file\" call this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file print * , __ FILE__ // \" : Writing control grid solution to file\" call CreateGroup_HDF5 ( fileId , '/controlgrid' ) print * , \" offset, nglobal_elem : \" , this % mesh % decomp % offsetElem ( this % mesh % decomp % rankId + 1 ), this % mesh % decomp % nElem call this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' , & this % mesh % decomp % offsetElem ( this % mesh % decomp % rankId + 1 ), this % mesh % decomp % nElem ) ! Write the geometry to file print * , __ FILE__ // \" : Writing control grid geometry to file\" call this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry' , & this % mesh % decomp % offsetElem ( this % mesh % decomp % rankId + 1 ), this % mesh % decomp % nElem ) ! -- END : writing solution on control grid -- ! call Close_HDF5 ( fileId ) else call Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) ! Write the interpolant to the file print * , __ FILE__ // \" : Writing interpolant data to file\" call this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file print * , __ FILE__ // \" : Writing control grid solution to file\" call CreateGroup_HDF5 ( fileId , '/controlgrid' ) call this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' ) ! Write the geometry to file print * , __ FILE__ // \" : Writing control grid geometry to file\" call this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry' ) ! -- END : writing solution on control grid -- ! call Close_HDF5 ( fileId ) endif endsubroutine Write_DGModel2D_t subroutine Read_DGModel2D_t ( this , fileName ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: fileName ! Local integer ( HID_T ) :: fileId integer ( HID_T ) :: solOffset ( 1 : 3 ) integer :: firstElem integer :: N , ivar if ( this % mesh % decomp % mpiEnabled ) then call Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % mesh % decomp % mpiComm ) else call Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) endif if ( this % mesh % decomp % mpiEnabled ) then firstElem = this % mesh % decomp % offsetElem ( this % mesh % decomp % rankId + 1 ) solOffset ( 1 : 3 ) = ( / 0 , 0 , firstElem / ) do ivar = 1 , this % solution % nvar call ReadArray_HDF5 ( fileId , & '/controlgrid/solution/' // trim ( this % solution % meta ( ivar )% name ), & this % solution % interior (:,:,:, ivar ), solOffset ) enddo else do ivar = 1 , this % solution % nvar call ReadArray_HDF5 ( fileId , & '/controlgrid/solution/' // trim ( this % solution % meta ( ivar )% name ), & this % solution % interior (:,:,:, ivar )) enddo endif call Close_HDF5 ( fileId ) endsubroutine Read_DGModel2D_t subroutine WriteTecplot_DGModel2D_t ( this , filename ) implicit none class ( DGModel2D_t ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: filename ! Local character ( 8 ) :: zoneID integer :: fUnit integer :: iEl , i , j , iVar character ( LEN = self_FileNameLength ) :: tecFile character ( LEN = self_TecplotHeaderLength ) :: tecHeader character ( LEN = self_FormatLength ) :: fmat character ( 13 ) :: timeStampString character ( 5 ) :: rankString type ( Scalar2D ) :: solution type ( Scalar2D ) :: dsdt type ( Vector2D ) :: solutionGradient type ( Vector2D ) :: x type ( Lagrange ), target :: interp if ( present ( filename )) then tecFile = filename else write ( timeStampString , '(I13.13)' ) this % ioIterate if ( this % mesh % decomp % mpiEnabled ) then write ( rankString , '(I5.5)' ) this % mesh % decomp % rankId tecFile = 'solution.' // rankString // '.' // timeStampString // '.tec' else tecFile = 'solution.' // timeStampString // '.tec' endif endif ! Create an interpolant for the uniform grid call interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) call solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) call dsdt % Init ( interp , & this % solution % nVar , this % solution % nElem ) call solutionGradient % Init ( interp , & this % solution % nVar , this % solution % nElem ) call x % Init ( interp , 1 , this % solution % nElem ) call this % solution % UpdateHost () call this % solutionGradient % UpdateHost () call this % dsdt % UpdateHost () ! Map the mesh positions to the target grid call this % geometry % x % GridInterp ( x % interior ) ! Map the solution to the target grid call this % solution % GridInterp ( solution % interior ) call this % dsdt % GridInterp ( dsdt % interior ) ! Map the solution to the target grid call this % solutionGradient % GridInterp ( solutionGradient % interior ) open ( UNIT = NEWUNIT ( fUnit ), & FILE = trim ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) tecHeader = 'VARIABLES = \"X\", \"Y\"' do iVar = 1 , this % solution % nVar tecHeader = trim ( tecHeader ) // ', \"' // trim ( this % solution % meta ( iVar )% name ) // '\"' enddo do iVar = 1 , this % solution % nVar tecHeader = trim ( tecHeader ) // ', \"d/dx(' // trim ( this % solution % meta ( iVar )% name ) // ')\"' enddo do iVar = 1 , this % solution % nVar tecHeader = trim ( tecHeader ) // ', \"d/dy(' // trim ( this % solution % meta ( iVar )% name ) // ')\"' enddo do iVar = 1 , this % solution % nVar tecHeader = trim ( tecHeader ) // ', \"d/dt(' // trim ( this % solution % meta ( iVar )% name ) // ')\"' enddo write ( fUnit , * ) trim ( tecHeader ) ! Create format statement write ( fmat , * ) 4 * this % solution % nvar + 2 fmat = '(' // trim ( fmat ) // '(ES16.7E3,1x))' do iEl = 1 , this % solution % nElem ! TO DO :: Get the global element ID write ( zoneID , '(I8.8)' ) iEl write ( fUnit , * ) 'ZONE T=\"el' // trim ( zoneID ) // '\", I=' , this % solution % interp % M + 1 , & ', J=' , this % solution % interp % M + 1 do j = 1 , this % solution % interp % M + 1 do i = 1 , this % solution % interp % M + 1 write ( fUnit , fmat ) x % interior ( i , j , iEl , 1 , 1 ), & x % interior ( i , j , iEl , 1 , 2 ), & solution % interior ( i , j , iEl , 1 : this % solution % nvar ), & solutionGradient % interior ( i , j , iEl , 1 : this % solution % nvar , 1 ), & solutionGradient % interior ( i , j , iEl , 1 : this % solution % nvar , 2 ), & dsdt % interior ( i , j , iEl , 1 : this % solution % nvar ) enddo enddo enddo close ( UNIT = fUnit ) call x % Free () call solution % Free () call dsdt % Free () call interp % Free () endsubroutine WriteTecplot_DGModel2D_t endmodule SELF_DGModel2D_t","tags":"","loc":"sourcefile/self_dgmodel2d_t.f90.html"},{"title":"SELF_MappedScalar_1D_t.f90 – SELF","text":"Contents Modules SELF_MappedScalar_1D_t Source Code SELF_MappedScalar_1D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_MappedScalar_1D_t use SELF_Constants use SELF_Lagrange use SELF_Scalar_1D use SELF_Mesh_1D use SELF_Geometry_1D use SELF_HDF5 use HDF5 use FEQParse use iso_c_binding implicit none #include \"SELF_Macros.h\" type , extends ( Scalar1D ), public :: MappedScalar1D_t logical :: geometry_associated = . false . type ( Geometry1D ), pointer :: geometry => null () contains procedure , public :: AssociateGeometry => AssociateGeometry_MappedScalar1D_t procedure , public :: DissociateGeometry => DissociateGeometry_MappedScalar1D_t procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar1D_t procedure , public :: SideExchange => SideExchange_MappedScalar1D_t generic , public :: MappedDerivative => MappedDerivative_MappedScalar1D_t procedure , private :: MappedDerivative_MappedScalar1D_t generic , public :: MappedDGDerivative => MappedDGDerivative_MappedScalar1D_t procedure , private :: MappedDGDerivative_MappedScalar1D_t endtype MappedScalar1D_t contains ! ---------------------- Scalars ---------------------- ! subroutine AssociateGeometry_MappedScalar1D_t ( this , geometry ) implicit none class ( MappedScalar1D_t ), intent ( inout ) :: this type ( Geometry1D ), target , intent ( in ) :: geometry if (. not . associated ( this % geometry )) then this % geometry => geometry this % geometry_associated = . true . endif endsubroutine AssociateGeometry_MappedScalar1D_t subroutine DissociateGeometry_MappedScalar1D_t ( this ) implicit none class ( MappedScalar1D_t ), intent ( inout ) :: this if ( associated ( this % geometry )) then this % geometry => null () this % geometry_associated = . false . endif endsubroutine DissociateGeometry_MappedScalar1D_t subroutine SetInteriorFromEquation_MappedScalar1D_t ( this , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedScalar1D_t ), intent ( inout ) :: this real ( prec ), intent ( in ) :: time ! Local integer :: iVar do ivar = 1 , this % nvar this % interior (:,:, ivar ) = this % eqn ( ivar )% evaluate ( this % geometry % x % interior ) enddo endsubroutine SetInteriorFromEquation_MappedScalar1D_t subroutine SideExchange_MappedScalar1D_t ( this , mesh ) implicit none class ( MappedScalar1D_t ), intent ( inout ) :: this type ( Mesh1D ), intent ( inout ) :: mesh ! Local integer :: e1 , e2 , s1 , s2 integer :: ivar do concurrent ( e1 = 1 : mesh % nElem , ivar = 1 : this % nvar ) if ( e1 == 1 ) then s1 = 2 e2 = e1 + 1 s2 = 1 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) elseif ( e1 == mesh % nElem ) then s1 = 1 e2 = e1 - 1 s2 = 2 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) else s1 = 1 e2 = e1 - 1 s2 = 2 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) s1 = 2 e2 = e1 + 1 s2 = 1 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) endif enddo endsubroutine SideExchange_MappedScalar1D_t subroutine MappedDerivative_MappedScalar1D_t ( this , dF ) implicit none class ( MappedScalar1D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , ii real ( prec ) :: dfloc do concurrent ( i = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfloc = 0.0_prec do ii = 1 , this % N + 1 dfloc = dfloc + this % interp % dMatrix ( ii , i ) * this % interior ( ii , iel , ivar ) enddo df ( i , iel , ivar ) = dfloc / this % geometry % dxds % interior ( i , iEl , 1 ) enddo endsubroutine MappedDerivative_MappedScalar1D_t subroutine MappedDGDerivative_MappedScalar1D_t ( this , dF ) implicit none class ( MappedScalar1D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , ii real ( prec ) :: dfloc do concurrent ( i = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfloc = 0.0_prec do ii = 1 , this % N + 1 dfloc = dfloc + this % interp % dgMatrix ( ii , i ) * this % interior ( ii , iel , ivar ) enddo dfloc = dfloc + ( this % boundarynormal ( 2 , iel , ivar ) * this % interp % bMatrix ( i , 2 ) + & this % boundarynormal ( 1 , iel , ivar ) * this % interp % bMatrix ( i , 1 )) / & this % interp % qWeights ( i ) df ( i , iel , ivar ) = dfloc / this % geometry % dxds % interior ( i , iEl , 1 ) enddo endsubroutine MappedDGDerivative_MappedScalar1D_t endmodule SELF_MappedScalar_1D_t","tags":"","loc":"sourcefile/self_mappedscalar_1d_t.f90.html"},{"title":"SELF_Geometry_1D.f90 – SELF","text":"Contents Modules SELF_Geometry_1D Source Code SELF_Geometry_1D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Geometry_1D use SELF_Constants use SELF_Lagrange use SELF_Data use SELF_Scalar_1D use SELF_SupportRoutines use SELF_Mesh_1D implicit none #include \"SELF_Macros.h\" type , public :: Geometry1D type ( Scalar1D ) :: x ! Physical Positions type ( Scalar1D ) :: dxds ! Conversion from computational to physical space integer :: nElem contains procedure , public :: Init => Init_Geometry1D procedure , public :: Free => Free_Geometry1D procedure , public :: GenerateFromMesh => GenerateFromMesh_Geometry1D procedure , public :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D procedure :: write => Write_Geometry1D endtype Geometry1D contains subroutine Init_Geometry1D ( myGeom , interp , nElem ) implicit none class ( Geometry1D ), intent ( out ) :: myGeom type ( Lagrange ), pointer , intent ( in ) :: interp integer , intent ( in ) :: nElem myGeom % nElem = nElem call myGeom % x % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % dxds % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) endsubroutine Init_Geometry1D subroutine Free_Geometry1D ( myGeom ) implicit none class ( Geometry1D ), intent ( inout ) :: myGeom call myGeom % x % Free () call myGeom % dxds % Free () endsubroutine Free_Geometry1D subroutine GenerateFromMesh_Geometry1D ( myGeom , mesh ) ! Generates the geometry for a 1-D mesh ( set of line segments ) ! Assumes that mesh is using Gauss-Lobatto quadrature and the degree is given by mesh % nGeo implicit none class ( Geometry1D ), intent ( inout ) :: myGeom type ( Mesh1D ), intent ( in ) :: mesh ! Local integer :: iel , i , nid type ( Lagrange ), target :: meshToModel type ( Scalar1D ) :: xMesh call meshToModel % Init ( mesh % nGeo , mesh % quadrature , & myGeom % x % interp % N , & myGeom % x % interp % controlNodeType ) call xMesh % Init ( meshToModel , & 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 do iel = 1 , mesh % nElem do i = 1 , mesh % nGeo + 1 xMesh % interior ( i , iel , 1 ) = mesh % nodeCoords ( nid ) nid = nid + 1 enddo enddo ! Interpolate from the mesh hopr_nodeCoords to the geometry (Possibly not gauss_lobatto quadrature) call xMesh % GridInterp ( myGeom % x % interior ) call myGeom % x % UpdateDevice () call myGeom % x % BoundaryInterp () call myGeom % CalculateMetricTerms () call xMesh % Free () call meshToModel % Free () endsubroutine GenerateFromMesh_Geometry1D subroutine CalculateMetricTerms_Geometry1D ( myGeom ) implicit none class ( Geometry1D ), intent ( inout ) :: myGeom call myGeom % x % Derivative ( myGeom % dxds % interior ) call myGeom % dxds % UpdateDevice () call myGeom % dxds % BoundaryInterp () endsubroutine CalculateMetricTerms_Geometry1D subroutine Write_Geometry1D ( myGeom , fileName ) implicit none class ( Geometry1D ), intent ( in ) :: myGeom character ( * ), optional , intent ( in ) :: fileName ! Local integer ( HID_T ) :: fileId ! Local character ( LEN = self_FileNameLength ) :: pickupFile if ( present ( filename )) then pickupFile = filename else pickupFile = 'mesh.h5' endif call Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) call CreateGroup_HDF5 ( fileId , '/quadrature' ) call WriteArray_HDF5 ( fileId , '/quadrature/xi' , & myGeom % x % interp % controlPoints ) call WriteArray_HDF5 ( fileId , '/quadrature/weights' , & myGeom % x % interp % qWeights ) call WriteArray_HDF5 ( fileId , '/quadrature/dgmatrix' , & myGeom % x % interp % dgMatrix ) call WriteArray_HDF5 ( fileId , '/quadrature/dmatrix' , & myGeom % x % interp % dMatrix ) call CreateGroup_HDF5 ( fileId , '/mesh' ) call CreateGroup_HDF5 ( fileId , '/mesh/interior' ) call CreateGroup_HDF5 ( fileId , '/mesh/boundary' ) call WriteArray_HDF5 ( fileId , '/mesh/interior/x' , myGeom % x % interior ) call WriteArray_HDF5 ( fileId , '/mesh/interior/dxds' , myGeom % dxds % interior ) call WriteArray_HDF5 ( fileId , '/mesh/boundary/x' , myGeom % x % boundary ) call WriteArray_HDF5 ( fileId , '/mesh/boundary/dxds' , myGeom % dxds % boundary ) call Close_HDF5 ( fileId ) endsubroutine Write_Geometry1D endmodule SELF_Geometry_1D","tags":"","loc":"sourcefile/self_geometry_1d.f90.html"},{"title":"SELF_Model.f90 – SELF","text":"Contents Modules SELF_Model Source Code SELF_Model.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Model use SELF_SupportRoutines use SELF_Metadata use SELF_HDF5 use HDF5 use FEQParse implicit none #include \"SELF_Macros.h\" ! //////////////////////////////////////////////// ! !   Time integration parameters ! Runge-Kutta 2nd Order (Low Storage) real ( prec ), parameter :: rk2_a ( 1 : 2 ) = ( / 0.0_prec , - 0.5_prec / ) real ( prec ), parameter :: rk2_b ( 1 : 2 ) = ( / 0.5_prec , 0.5_prec / ) real ( prec ), parameter :: rk2_g ( 1 : 2 ) = ( / 0.5_prec , 1.0_prec / ) ! Williamson's Runge-Kutta 3rd Order (Low Storage) real ( prec ), parameter :: rk3_a ( 1 : 3 ) = ( / 0.0_prec , - 5.0_prec / 9.0_prec , - 15 3.0_prec / 12 8.0_prec / ) real ( prec ), parameter :: rk3_b ( 1 : 3 ) = ( / 0.0_prec , 1.0_prec / 3.0_prec , 3.0_prec / 4.0_prec / ) real ( prec ), parameter :: rk3_g ( 1 : 3 ) = ( / 1.0_prec / 3.0_prec , 1 5.0_prec / 1 6.0_prec , 8.0_prec / 1 5.0_prec / ) ! Carpenter-Kennedy Runge-Kuttta 4th Order (Low Storage) real ( prec ), parameter :: rk4_a ( 1 : 5 ) = ( / 0.0_prec , & - 1.0_prec , & - 1.0_prec / 3.0_prec + & 2.0_prec ** ( 2.0_prec / 3.0_prec ) / 6.0_prec , & - 2.0_prec ** ( 1.0_prec / 3.0_prec ) - & 2.0_prec ** ( 2.0_prec / 3.0_prec ) - 2.0_prec , & - 1.0_prec + 2.0_prec ** ( 1.0_prec / 3.0_prec ) / ) real ( prec ), parameter :: rk4_b ( 1 : 5 ) = ( / & 0.0_prec , & 2.0_prec / 3.0_prec + 2.0_prec ** ( 1.0_prec / 3.0_prec ) / 3.0_prec + & 2.0_prec ** ( 2.0_prec / 3.0_prec ) / 6.0_prec , & 2.0_prec / 3.0_prec + 2.0_prec ** ( 1.0_prec / 3.0_prec ) / 3.0_prec + & 2.0_prec ** ( 2.0_prec / 3.0_prec ) / 6.0_prec , & 1.0_prec / 3.0_prec - 2.0_prec ** ( 1.0_prec / 3.0_prec ) / 3.0_prec - & 2.0_prec ** ( 2.0_prec / 3.0_prec ) / 6.0_prec , & 1.0_prec / ) real ( prec ), parameter :: rk4_g ( 1 : 5 ) = ( / & 2.0_prec / 3.0_prec + 2.0_prec ** ( 1.0_prec / 3.0_prec ) / 3.0_prec + & 2.0_prec ** ( 2.0_prec / 3.0_prec ) / 6.0_prec , & - 2.0_prec ** ( 2.0_prec / 3.0_prec ) / 6.0_prec + 1.0_prec / 6.0_prec , & - 1.0_prec / 3.0_prec - 2.0_prec * 2.0_prec ** ( 1.0_prec / 3.0_prec ) / 3.0_prec - & 2.0_prec ** ( 2.0_prec / 3.0_prec ) / 3.0_prec , & 1.0_prec / 3.0_prec - 2.0_prec ** ( 1.0_prec / 3.0_prec ) / 3.0_prec - & 2.0_prec ** ( 2.0_prec / 3.0_prec ) / 6.0_prec , & 1.0_prec / 3.0_prec + 2.0_prec ** ( 1.0_prec / 3.0_prec ) / 6.0_prec + & 2.0_prec ** ( 2.0_prec / 3.0_prec ) / 1 2.0_prec / ) ! integer , parameter :: SELF_EULER = 100 integer , parameter :: SELF_RK2 = 200 integer , parameter :: SELF_RK3 = 300 integer , parameter :: SELF_RK4 = 400 ! integer,parameter :: SELF_AB2 = 201 ! integer,parameter :: SELF_AB3 = 301 ! integer,parameter :: SELF_AB4 = 401 integer , parameter :: SELF_INTEGRATOR_LENGTH = 10 ! max length of integrator methods when specified as char integer , parameter :: SELF_EQUATION_LENGTH = 500 ! //////////////////////////////////////////////// ! !   Model Formulations ! integer , parameter :: SELF_FORMULATION_LENGTH = 30 ! max length of integrator methods when specified as char type , abstract :: Model ! Time integration attributes procedure ( SELF_timeIntegrator ), pointer :: timeIntegrator => Euler_timeIntegrator real ( prec ) :: dt real ( prec ) :: t integer :: ioIterate = 0 logical :: gradient_enabled = . false . integer :: nvar ! Standard Diagnostics real ( prec ) :: entropy ! Mathematical entropy function for the model contains procedure :: IncrementIOCounter procedure :: PrintType => PrintType_Model procedure :: ForwardStep => ForwardStep_Model procedure :: Euler_timeIntegrator ! Runge-Kutta methods procedure :: LowStorageRK2_timeIntegrator procedure ( UpdateGRK ), deferred :: UpdateGRK2 procedure :: LowStorageRK3_timeIntegrator procedure ( UpdateGRK ), deferred :: UpdateGRK3 procedure :: LowStorageRK4_timeIntegrator procedure ( UpdateGRK ), deferred :: UpdateGRK4 procedure :: PreTendency => PreTendency_Model procedure :: entropy_func => entropy_func_Model procedure :: flux1D => flux1d_Model procedure :: flux2D => flux2d_Model procedure :: flux3D => flux3d_Model procedure :: riemannflux1d => riemannflux1d_Model procedure :: riemannflux2d => riemannflux2d_Model procedure :: riemannflux3d => riemannflux3d_Model procedure :: source1d => source1d_Model procedure :: source2d => source2d_Model procedure :: source3d => source3d_Model ! Boundary condition functions (hyperbolic) procedure :: hbc1d_Prescribed => hbc1d_Prescribed_Model procedure :: hbc1d_Radiation => hbc1d_Generic_Model procedure :: hbc1d_NoNormalFlow => hbc1d_Generic_Model procedure :: hbc2d_Prescribed => hbc2d_Prescribed_Model procedure :: hbc2d_Radiation => hbc2d_Generic_Model procedure :: hbc2d_NoNormalFlow => hbc2d_Generic_Model procedure :: hbc3d_Prescribed => hbc3d_Prescribed_Model procedure :: hbc3d_Radiation => hbc3d_Generic_Model procedure :: hbc3d_NoNormalFlow => hbc3d_Generic_Model ! Boundary condition functions (parabolic) procedure :: pbc1d_Prescribed => pbc1d_Prescribed_Model procedure :: pbc1d_Radiation => pbc1d_Generic_Model procedure :: pbc1d_NoNormalFlow => pbc1d_Generic_Model procedure :: pbc2d_Prescribed => pbc2d_Prescribed_Model procedure :: pbc2d_Radiation => pbc2d_Generic_Model procedure :: pbc2d_NoNormalFlow => pbc2d_Generic_Model procedure :: pbc3d_Prescribed => pbc3d_Prescribed_Model procedure :: pbc3d_Radiation => pbc3d_Generic_Model procedure :: pbc3d_NoNormalFlow => pbc3d_Generic_Model procedure :: ReportEntropy => ReportEntropy_Model procedure :: CalculateEntropy => CalculateEntropy_Model procedure ( UpdateSolution ), deferred :: UpdateSolution procedure ( CalculateTendency ), deferred :: CalculateTendency procedure ( ReadModel ), deferred :: ReadModel procedure ( WriteModel ), deferred :: WriteModel procedure ( WriteTecplot ), deferred :: WriteTecplot generic :: SetTimeIntegrator => SetTimeIntegrator_withChar procedure , private :: SetTimeIntegrator_withChar procedure :: SetSimulationTime procedure :: GetSimulationTime endtype Model interface subroutine SELF_timeIntegrator ( this , tn ) use SELF_Constants , only : prec import Model implicit none class ( Model ), intent ( inout ) :: this real ( prec ), intent ( in ) :: tn endsubroutine SELF_timeIntegrator endinterface interface subroutine UpdateGRK ( this , m ) import Model implicit none class ( Model ), intent ( inout ) :: this integer , intent ( in ) :: m endsubroutine UpdateGRK endinterface interface subroutine UpdateSolution ( this , dt ) use SELF_Constants , only : prec import Model implicit none class ( Model ), intent ( inout ) :: this real ( prec ), optional , intent ( in ) :: dt endsubroutine UpdateSolution endinterface interface subroutine CalculateTendency ( this ) import Model implicit none class ( Model ), intent ( inout ) :: this endsubroutine CalculateTendency endinterface interface subroutine WriteModel ( this , filename ) import Model implicit none class ( Model ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: filename endsubroutine WriteModel endinterface interface subroutine ReadModel ( this , filename ) import Model implicit none class ( Model ), intent ( inout ) :: this character ( * ), intent ( in ) :: filename endsubroutine ReadModel endinterface interface subroutine WriteTecplot ( this , filename ) import Model implicit none class ( Model ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: filename endsubroutine WriteTecplot endinterface contains subroutine IncrementIOCounter ( this ) implicit none class ( Model ), intent ( inout ) :: this ! Increment the ioIterate this % ioIterate = this % ioIterate + 1 endsubroutine IncrementIOCounter subroutine PrintType_Model ( this ) implicit none class ( Model ), intent ( in ) :: this print * , __ FILE__ // \" : Model : No model type\" endsubroutine PrintType_Model subroutine PreTendency_Model ( this ) !! PreTendency is a template routine that is used to house any additional calculations !! that you want to execute at the beginning of the tendency calculation routine. !! This default PreTendency simply returns back to the caller without executing any instructions !! !! The intention is to provide a method that can be overridden through type-extension, to handle !! any steps that need to be executed before proceeding with the usual tendency calculation methods. !! implicit none class ( Model ), intent ( inout ) :: this return endsubroutine PreTendency_Model pure function entropy_func_Model ( this , s ) result ( e ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ) :: e e = 0.0_prec endfunction entropy_func_Model pure function riemannflux1d_Model ( this , sL , sR , dsdx , nhat ) result ( flux ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: sL ( 1 : this % nvar ) real ( prec ), intent ( in ) :: sR ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar ) real ( prec ), intent ( in ) :: nhat real ( prec ) :: flux ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar flux ( ivar ) = 0.0_prec enddo endfunction riemannflux1d_Model pure function riemannflux2d_Model ( this , sL , sR , dsdx , nhat ) result ( flux ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: sL ( 1 : this % nvar ) real ( prec ), intent ( in ) :: sR ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ), intent ( in ) :: nhat ( 1 : 2 ) real ( prec ) :: flux ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar flux ( ivar ) = 0.0_prec enddo endfunction riemannflux2d_Model pure function riemannflux3d_Model ( this , sL , sR , dsdx , nhat ) result ( flux ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: sL ( 1 : this % nvar ) real ( prec ), intent ( in ) :: sR ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ), intent ( in ) :: nhat ( 1 : 3 ) real ( prec ) :: flux ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar flux ( ivar ) = 0.0_prec enddo endfunction riemannflux3d_Model pure function flux1d_Model ( this , s , dsdx ) result ( flux ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar ) real ( prec ) :: flux ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar flux ( ivar ) = 0.0_prec enddo endfunction flux1d_Model pure function flux2d_Model ( this , s , dsdx ) result ( flux ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ) :: flux ( 1 : this % nvar , 1 : 2 ) ! Local integer :: ivar do ivar = 1 , this % nvar flux ( ivar , 1 : 2 ) = 0.0_prec enddo endfunction flux2d_Model pure function flux3d_Model ( this , s , dsdx ) result ( flux ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ) :: flux ( 1 : this % nvar , 1 : 3 ) ! Local integer :: ivar do ivar = 1 , this % nvar flux ( ivar , 1 : 3 ) = 0.0_prec enddo endfunction flux3d_Model pure function source1d_Model ( this , s , dsdx ) result ( source ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar ) real ( prec ) :: source ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar source ( ivar ) = 0.0_prec enddo endfunction source1d_Model pure function source2d_Model ( this , s , dsdx ) result ( source ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ) :: source ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar source ( ivar ) = 0.0_prec enddo endfunction source2d_Model pure function source3d_Model ( this , s , dsdx ) result ( source ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ) :: source ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar source ( ivar ) = 0.0_prec enddo endfunction source3d_Model pure function hbc1d_Generic_Model ( this , s , nhat ) result ( exts ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: nhat real ( prec ) :: exts ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar exts ( ivar ) = 0.0_prec enddo endfunction hbc1d_Generic_Model pure function hbc1d_Prescribed_Model ( this , x , t ) result ( exts ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: x real ( prec ), intent ( in ) :: t real ( prec ) :: exts ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar exts ( ivar ) = 0.0_prec enddo endfunction hbc1d_Prescribed_Model pure function hbc2d_Generic_Model ( this , s , nhat ) result ( exts ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: nhat ( 1 : 2 ) real ( prec ) :: exts ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar exts ( ivar ) = 0.0_prec enddo endfunction hbc2d_Generic_Model pure function hbc2d_Prescribed_Model ( this , x , t ) result ( exts ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: x ( 1 : 2 ) real ( prec ), intent ( in ) :: t real ( prec ) :: exts ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar exts ( ivar ) = 0.0_prec enddo endfunction hbc2d_Prescribed_Model pure function hbc3d_Generic_Model ( this , s , nhat ) result ( exts ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % nvar ) real ( prec ), intent ( in ) :: nhat ( 1 : 3 ) real ( prec ) :: exts ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar exts ( ivar ) = 0.0_prec enddo endfunction hbc3d_Generic_Model pure function hbc3d_Prescribed_Model ( this , x , t ) result ( exts ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: x ( 1 : 3 ) real ( prec ), intent ( in ) :: t real ( prec ) :: exts ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar exts ( ivar ) = 0.0_prec enddo endfunction hbc3d_Prescribed_Model pure function pbc1d_Generic_Model ( this , dsdx , nhat ) result ( extDsdx ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar ) real ( prec ), intent ( in ) :: nhat real ( prec ) :: extDsdx ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar extDsdx ( ivar ) = dsdx ( ivar ) enddo endfunction pbc1d_Generic_Model pure function pbc1d_Prescribed_Model ( this , x , t ) result ( extDsdx ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: x real ( prec ), intent ( in ) :: t real ( prec ) :: extDsdx ( 1 : this % nvar ) ! Local integer :: ivar do ivar = 1 , this % nvar extDsdx ( ivar ) = 0.0_prec enddo endfunction pbc1d_Prescribed_Model pure function pbc2d_Generic_Model ( this , dsdx , nhat ) result ( extDsdx ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ), intent ( in ) :: nhat ( 1 : 2 ) real ( prec ) :: extDsdx ( 1 : this % nvar , 1 : 2 ) ! Local integer :: ivar do ivar = 1 , this % nvar extDsdx ( ivar , 1 : 2 ) = dsdx ( ivar , 1 : 2 ) enddo endfunction pbc2d_Generic_Model pure function pbc2d_Prescribed_Model ( this , x , t ) result ( extDsdx ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: x ( 1 : 2 ) real ( prec ), intent ( in ) :: t real ( prec ) :: extDsdx ( 1 : this % nvar , 1 : 2 ) ! Local integer :: ivar do ivar = 1 , this % nvar extDsdx ( ivar , 1 : 2 ) = 0.0_prec enddo endfunction pbc2d_Prescribed_Model pure function pbc3d_Generic_Model ( this , dsdx , nhat ) result ( extDsdx ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ), intent ( in ) :: nhat ( 1 : 3 ) real ( prec ) :: extDsdx ( 1 : this % nvar , 1 : 3 ) ! Local integer :: ivar do ivar = 1 , this % nvar extDsdx ( ivar , 1 : 3 ) = dsdx ( ivar , 1 : 3 ) enddo endfunction pbc3d_Generic_Model pure function pbc3d_Prescribed_Model ( this , x , t ) result ( extDsdx ) class ( Model ), intent ( in ) :: this real ( prec ), intent ( in ) :: x ( 1 : 3 ) real ( prec ), intent ( in ) :: t real ( prec ) :: extDsdx ( 1 : this % nvar , 1 : 3 ) ! Local integer :: ivar do ivar = 1 , this % nvar extDsdx ( ivar , 1 : 3 ) = 0.0_prec enddo endfunction pbc3d_Prescribed_Model subroutine SetTimeIntegrator_withChar ( this , integrator ) !! Sets the time integrator method, using a character input !! !! Valid options for integrator are !! !!   \"euler\" !!   \"rk2\" !!   \"rk3\" !!   \"rk4\" !! !! Note that the character provided is not case-sensitive !! implicit none class ( Model ), intent ( inout ) :: this character ( * ), intent ( in ) :: integrator ! Local character ( SELF_INTEGRATOR_LENGTH ) :: upperCaseInt upperCaseInt = UpperCase ( trim ( integrator )) select case ( trim ( upperCaseInt )) case ( \"EULER\" ) this % timeIntegrator => Euler_timeIntegrator case ( \"RK2\" ) this % timeIntegrator => LowStorageRK2_timeIntegrator case ( \"RK3\" ) this % timeIntegrator => LowStorageRK3_timeIntegrator case ( \"RK4\" ) this % timeIntegrator => LowStorageRK4_timeIntegrator case DEFAULT this % timeIntegrator => LowStorageRK3_timeIntegrator endselect endsubroutine SetTimeIntegrator_withChar subroutine GetSimulationTime ( this , t ) !! Returns the current simulation time stored in the model % t attribute implicit none class ( Model ), intent ( in ) :: this real ( prec ), intent ( out ) :: t t = this % t endsubroutine GetSimulationTime subroutine SetSimulationTime ( this , t ) !! Sets the model % t attribute with the provided simulation time implicit none class ( Model ), intent ( inout ) :: this real ( prec ), intent ( in ) :: t this % t = t endsubroutine SetSimulationTime subroutine CalculateEntropy_Model ( this ) !! Base method for calculating entropy of a model !! When this method is not overridden, the entropy !! is simply set to 0.0. When you develop a model !! built on top of this abstract class or one of its !! children, it is recommended that you define a !! convex mathematical entropy function that is used !! as a measure of the model stability. implicit none class ( Model ), intent ( inout ) :: this this % entropy = 0.0_prec endsubroutine CalculateEntropy_Model subroutine ReportEntropy_Model ( this ) !! Base method for reporting the entropy of a model !! to stdout. Only override this procedure if additional !! reporting is needed. Alternatively, if you think !! additional reporting would be valuable for all models, !! open a pull request with modifications to this base !! method. implicit none class ( Model ), intent ( in ) :: this ! Local character ( len = 20 ) :: modelTime character ( len = 20 ) :: entropy character ( len = :), allocatable :: str ! Copy the time and entropy to a string write ( modelTime , \"(ES16.7E3)\" ) this % t write ( entropy , \"(ES16.7E3)\" ) this % entropy ! Write the output to STDOUT open ( output_unit , ENCODING = 'utf-8' ) write ( output_unit , '(A,\" : \")' , ADVANCE = 'no' ) __ FILE__ str = 'tᵢ =' // trim ( modelTime ) write ( output_unit , '(A)' , ADVANCE = 'no' ) str str = '  |  eᵢ =' // trim ( entropy ) write ( output_unit , '(A)' , ADVANCE = 'yes' ) str endsubroutine ReportEntropy_Model ! ////////////////////////////////////// ! !       Time Integrators                 ! subroutine ForwardStep_Model ( this , tn , dt , ioInterval ) !!  Forward steps the model using the associated tendency procedure and time integrator !! !!  If the final time  is provided, the model is forward stepped to that final time, !!  otherwise, the model is forward stepped only a single time step !! !!  If a time step is provided through the interface, the model time step size is updated !!  and that time step is used to update the model !! !! If ioInterval is provided, file IO will be conducted every ioInterval seconds until tn !! is reached implicit none class ( Model ), intent ( inout ) :: this real ( prec ), intent ( in ) :: tn real ( prec ), intent ( in ) :: dt real ( prec ), intent ( in ) :: ioInterval ! Local real ( prec ) :: targetTime , tNext integer :: i , nIO this % dt = dt targetTime = tn nIO = int (( targetTime - this % t ) / ioInterval ) do i = 1 , nIO tNext = this % t + ioInterval call this % timeIntegrator ( tNext ) this % t = tNext call this % WriteModel () call this % WriteTecplot () call this % IncrementIOCounter () call this % CalculateEntropy () call this % ReportEntropy () enddo endsubroutine ForwardStep_Model subroutine Euler_timeIntegrator ( this , tn ) implicit none class ( Model ), intent ( inout ) :: this real ( prec ), intent ( in ) :: tn ! Local real ( prec ) :: tRemain real ( prec ) :: dtLim dtLim = this % dt ! Get the max time step size from the dt attribute do while ( this % t < tn ) tRemain = tn - this % t this % dt = min ( dtLim , tRemain ) call this % CalculateTendency () call this % UpdateSolution () this % t = this % t + this % dt enddo this % dt = dtLim endsubroutine Euler_timeIntegrator subroutine LowStorageRK2_timeIntegrator ( this , tn ) implicit none class ( Model ), intent ( inout ) :: this real ( prec ), intent ( in ) :: tn ! Local integer :: m real ( prec ) :: tRemain real ( prec ) :: dtLim real ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute do while ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = min ( dtLim , tRemain ) do m = 1 , 2 call this % CalculateTendency () call this % UpdateGRK2 ( m ) this % t = t0 + rk2_b ( m ) * this % dt enddo this % t = t0 + this % dt enddo this % dt = dtLim endsubroutine LowStorageRK2_timeIntegrator subroutine LowStorageRK3_timeIntegrator ( this , tn ) implicit none class ( Model ), intent ( inout ) :: this real ( prec ), intent ( in ) :: tn ! Local integer :: m real ( prec ) :: tRemain real ( prec ) :: dtLim real ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute do while ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = min ( dtLim , tRemain ) do m = 1 , 3 call this % CalculateTendency () call this % UpdateGRK3 ( m ) this % t = t0 + rk3_b ( m ) * this % dt enddo this % t = t0 + this % dt enddo this % dt = dtLim endsubroutine LowStorageRK3_timeIntegrator subroutine LowStorageRK4_timeIntegrator ( this , tn ) implicit none class ( Model ), intent ( inout ) :: this real ( prec ), intent ( in ) :: tn ! Local integer :: m real ( prec ) :: tRemain real ( prec ) :: dtLim real ( prec ) :: t0 dtLim = this % dt ! Get the max time step size from the dt attribute do while ( this % t < tn ) t0 = this % t tRemain = tn - this % t this % dt = min ( dtLim , tRemain ) do m = 1 , 5 call this % CalculateTendency () call this % UpdateGRK4 ( m ) this % t = t0 + rk4_b ( m ) * this % dt enddo this % t = t0 + this % dt enddo this % dt = dtLim endsubroutine LowStorageRK4_timeIntegrator endmodule SELF_Model","tags":"","loc":"sourcefile/self_model.f90.html"},{"title":"SELF_Mesh_2D_t.f90 – SELF","text":"Contents Modules SELF_Mesh_2D_t Source Code SELF_Mesh_2D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Mesh_2D_t use SELF_Constants use SELF_Lagrange use SELF_SupportRoutines use SELF_HDF5 use SELF_Mesh use SELF_DomainDecomposition ! External Libs ! use HDF5 use iso_c_binding implicit none ! ========================================================================= ! ! Node, Edge, Face, Element and Connectivity Standard ! ========================================================================= ! ! ! To define the element corner nodes, the side order and side connectivity, ! we follow the standard from CGNS SIDS (CFD General Notation System, ! Standard Interface Data Structures, http: //cgns.sourceforge.net/ ). ! ! Computational coordinate directions are defined as follows ! ! xi1 direction points from \"West\" (xi1=-1) to \"East\" (xi1=1) ! xi2 direction points from \"South\" (xi2=-1) to \"North\" (xi2=1) ! ! 2-D Hexahedreal Element sides are defined as ! ! Side 1 = South  (xi2 = -1) = [CN1, CN2] ! Side 2 = East   (xi1 = 1) = [CN2, CN3] ! Side 3 = North  (xi2 = 1) = [CN4, CN3] ! Side 4 = West   (xi1 = -1) = [CN1, CN4] ! ! In 2-D, corner nodes are order counter-clockwise (looking in the -xi3 direction). ! ! CornerNode 1 = South-West = (-1,-1) ! CornerNode 2 = South-East = ( 1,-1) ! CornerNode 3 = North-East = ( 1, 1) ! CornerNode 4 = North-West = (-1, 1) ! ! Notes: !  * cornerNode attributes have not been implemented yet ! !  * For line segments, quads, and hexes, SELF uses Legendre-Gauss-Lobatto quadrature ! ! ! Connectivity information ! !  sideInfo(1:5,iSide,iEl) ! !    1 - Side Type !    2 - Global Side ID !    3 - Neighbor Element ID !    4 - 10*( neighbor local side )  + flip !    5 - Boundary Condition ID ! ! ! ========================================================================= ! ! Side Ordering integer , parameter :: selfSide2D_South = 1 integer , parameter :: selfSide2D_East = 2 integer , parameter :: selfSide2D_North = 3 integer , parameter :: selfSide2D_West = 4 ! Mesh format is set up similar to the HOPr format ! See https://hopr-project.org/externals/MeshFormat.pdf type , extends ( SEMMesh ) :: Mesh2D_t integer , pointer , dimension (:,:,:) :: sideInfo real ( prec ), pointer , dimension (:,:,:,:) :: nodeCoords integer , pointer , dimension (:,:) :: elemInfo integer , pointer , dimension (:,:,:) :: globalNodeIDs integer , pointer , dimension (:,:) :: CGNSCornerMap integer , pointer , dimension (:,:) :: CGNSSideMap integer , pointer , dimension (:,:) :: BCType character ( LEN = 255 ), allocatable :: BCNames (:) contains procedure , public :: Init => Init_Mesh2D_t procedure , public :: Free => Free_Mesh2D_t generic , public :: StructuredMesh => UniformStructuredMesh_Mesh2D_t procedure , private :: UniformStructuredMesh_Mesh2D_t procedure , public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh2D_t procedure , public :: Read_HOPr => Read_HOPr_Mesh2D_t procedure , public :: Write_Mesh => Write_Mesh2D_t procedure , public :: RecalculateFlip => RecalculateFlip_Mesh2D_t endtype Mesh2D_t contains subroutine Init_Mesh2D_t ( this , nGeo , nElem , nSides , nNodes , nBCs ) implicit none class ( Mesh2D_t ), intent ( inout ) :: this integer , intent ( in ) :: nGeo integer , intent ( in ) :: nElem integer , intent ( in ) :: nSides integer , intent ( in ) :: nNodes integer , intent ( in ) :: nBCs ! Local integer :: i , j , l this % nGeo = nGeo this % nElem = nElem this % nGlobalElem = nElem this % nNodes = nNodes this % nSides = nSides this % nCornerNodes = 0 this % nUniqueNodes = 0 this % nUniqueSides = 0 this % nBCs = nBCs allocate ( this % elemInfo ( 1 : 6 , 1 : nElem )) allocate ( this % sideInfo ( 1 : 5 , 1 : 4 , 1 : nElem )) allocate ( this % nodeCoords ( 1 : 2 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % globalNodeIDs ( 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % CGNSCornerMap ( 1 : 2 , 1 : 4 )) allocate ( this % CGNSSideMap ( 1 : 2 , 1 : 4 )) allocate ( this % BCType ( 1 : 4 , 1 : nBCs )) allocate ( this % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation this % CGNSCornerMap ( 1 : 2 , 1 ) = ( / 1 , 1 / ) this % CGNSCornerMap ( 1 : 2 , 2 ) = ( / nGeo + 1 , 1 / ) this % CGNSCornerMap ( 1 : 2 , 3 ) = ( / nGeo + 1 , nGeo + 1 / ) this % CGNSCornerMap ( 1 : 2 , 4 ) = ( / 1 , nGeo + 1 / ) ! Maps from local corner node id to CGNS side this % CGNSSideMap ( 1 : 2 , 1 ) = ( / 1 , 2 / ) this % CGNSSideMap ( 1 : 2 , 2 ) = ( / 2 , 3 / ) this % CGNSSideMap ( 1 : 2 , 3 ) = ( / 4 , 3 / ) this % CGNSSideMap ( 1 : 2 , 4 ) = ( / 1 , 4 / ) endsubroutine Init_Mesh2D_t subroutine Free_Mesh2D_t ( this ) implicit none class ( Mesh2D_t ), intent ( inout ) :: this this % nElem = 0 this % nNodes = 0 this % nSides = 0 this % nCornerNodes = 0 this % nUniqueSides = 0 this % nUniqueNodes = 0 this % nBCs = 0 deallocate ( this % elemInfo ) deallocate ( this % sideInfo ) deallocate ( this % nodeCoords ) deallocate ( this % globalNodeIDs ) deallocate ( this % CGNSCornerMap ) deallocate ( this % CGNSSideMap ) deallocate ( this % BCType ) deallocate ( this % BCNames ) call this % decomp % Free () endsubroutine Free_Mesh2D_t subroutine ResetBoundaryConditionType_Mesh2D_t ( this , bcid ) !! This method can be used to reset all of the boundary elements !! boundary condition type to the desired value. !! !! Note that ALL physical boundaries will be set to have this boundary !! condition implicit none class ( Mesh2D_t ), intent ( inout ) :: this integer , intent ( in ) :: bcid ! Local integer :: iSide , iEl , e2 do iEl = 1 , this % nElem do iSide = 1 , 4 e2 = this % sideInfo ( 3 , iSide , iEl ) if ( e2 == 0 ) then this % sideInfo ( 5 , iSide , iEl ) = bcid endif enddo enddo endsubroutine ResetBoundaryConditionType_Mesh2D_t subroutine UniformStructuredMesh_Mesh2D_t ( this , nxPerTile , nyPerTile , nTileX , nTileY , dx , dy , bcids , enableDomainDecomposition ) !! !! Create a structured mesh and store it in SELF's unstructured mesh format. !! The mesh is created in tiles of size (tnx,tny). Tiling is used to determine !! the element ordering. !! !! !!  Input !!    - this : Fresh/empty mesh2d_t object !!    - nxPerTile : The number of elements in the x direction within a tile !!    - nyPerTile : The number of elements in the y direction within a tile !!    - nTileX : The number of tiles in the x direction !!    - nTileY : The number of tiles in the y direction !!    - dx : Element width in the x-direction !!    - dy : Element width in the y-direction !!    - bcids(1:4) : Boundary condition flags for the south, east, north, and west sides of the domain !!    - enableDomainDecomposition : Boolean to determine if domain decomposition is used. !! !!  Output !!    - this : mesh2d_t object with vertices, edges, and element information !! !! Total number of elements in the x-direction is nX = nxPerTile*nTileX !! Total number of elements in the y-direction is nY = nyPerTile*nTileY !! !! Length of the domain in the x-direction is Lx = dx*nX !! Length of the domain in the y-direction is Ly = dy*nY !! implicit none class ( Mesh2D_t ), intent ( out ) :: this integer , intent ( in ) :: nxPerTile integer , intent ( in ) :: nyPerTile integer , intent ( in ) :: nTileX integer , intent ( in ) :: nTileY real ( prec ), intent ( in ) :: dx real ( prec ), intent ( in ) :: dy integer , intent ( in ) :: bcids ( 1 : 4 ) logical , optional , intent ( in ) :: enableDomainDecomposition ! Local integer :: nX , nY , nGeo , nBCs integer :: nGlobalElem integer :: nUniqueSides integer :: nUniqueNodes integer :: nLocalElems integer :: nLocalSides integer :: nLocalNodes real ( prec ), allocatable :: nodeCoords (:,:,:,:) integer , allocatable :: globalNodeIDs (:,:,:) integer , allocatable :: sideInfo (:,:,:) integer :: i , j , ti , tj integer :: ix , iy , iel integer :: ni , nj integer :: e1 , e2 integer :: nedges if ( present ( enableDomainDecomposition )) then call this % decomp % init ( enableDomainDecomposition ) else call this % decomp % init (. false .) endif nX = nTileX * nxPerTile nY = nTileY * nyPerTile nGeo = 1 ! Force the geometry to be linear nBCs = 4 ! Force the number of boundary conditions to 4 nGlobalElem = nX * nY nUniqueSides = ( nX + 1 ) * nY + ( nY + 1 ) * nX nUniqueNodes = ( nX + 1 ) * ( nY + 1 ) allocate ( nodeCoords ( 1 : 2 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nGlobalElem )) allocate ( globalNodeIDs ( 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nGlobalElem )) allocate ( sideInfo ( 1 : 5 , 1 : 4 , 1 : nGlobalElem )) do tj = 1 , nTileY do ti = 1 , nTileX do j = 1 , nyPerTile iy = j + nyPerTile * ( tj - 1 ) do i = 1 , nxPerTile iel = i + nxPerTile * ( j - 1 + nyPerTile * ( ti - 1 + nTilex * ( tj - 1 ))) ix = i + nxPerTile * ( ti - 1 ) ! nxpertile + nxpertile*(nTileX-1) = nxperTile*nTilex = 1 do nj = 1 , nGeo + 1 do ni = 1 , nGeo + 1 nodeCoords ( 1 , ni , nj , iel ) = real ( ni - 1 + ix - 1 , prec ) * dx nodeCoords ( 2 , ni , nj , iel ) = real ( nj - 1 + iy - 1 , prec ) * dy globalNodeIDs ( ni , nj , iel ) = ni - 1 + i + ( nxPerTile + 1 ) * ( nj - 1 + j - 1 + ( nyPerTile + 1 ) * ( ti - 1 + nTileX * ( tj - 1 )) ) enddo enddo enddo enddo enddo enddo ! Fill in edge information !  sideInfo(1:5,iSide,iEl) !    1 - Side Type (currently unused in SELF) !    2 - Global Side ID (Used for message passing. Don't need to change) !    3 - Neighbor Element ID (Can stay the same) !    4 - 10*( neighbor local side )  + flip (Need to recalculate flip) !    5 - Boundary Condition ID (Can stay the same) nedges = 0 do tj = 1 , nTileY do ti = 1 , nTileX do j = 1 , nyPerTile do i = 1 , nxPerTile iel = i + nxPerTile * ( j - 1 + nyPerTile * ( ti - 1 + nTilex * ( tj - 1 ))) ! south, iside=1 ! Get the corner node ids for this edge ! sideInfo(2,1,iel) = (nc1+nc2)*(nc1+nc2+1)/2 + nc2 if ( j == 1 ) then ! southern most part of the tile if ( tj == 1 ) then ! southern most tile nedges = nedges + 1 sideinfo ( 2 , 1 , iel ) = nedges sideinfo ( 3 , 1 , iel ) = 0 ! Neigbor element (null, boundary condition) sideinfo ( 4 , 1 , iel ) = 0 ! Neighbor side id (null, boundary condition) sideinfo ( 5 , 1 , iel ) = bcids ( 1 ) ! Boundary condition id; set from the user input else ! interior tile, but souther most edge of the tile e2 = i + nxPerTile * ( nyPerTile - 1 + nyPerTile * ( ti - 1 + nTilex * ( tj - 2 ))) ! Neigbor element, northernmost element, in tile to the south sideinfo ( 2 , 1 , iel ) = sideInfo ( 2 , 3 , e2 ) ! Copy the edge id from neighbor's north edge sideinfo ( 3 , 1 , iel ) = e2 sideinfo ( 4 , 1 , iel ) = 10 * 3 ! Neighbor side id - neighbor to the south, north side (3) sideinfo ( 5 , 1 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif else ! interior to the tile e2 = i + nxPerTile * ( j - 2 + nyPerTile * ( ti - 1 + nTilex * ( tj - 1 ))) ! Neigbor element, inside same tile, to the south sideinfo ( 2 , 1 , iel ) = sideInfo ( 2 , 3 , e2 ) ! Copy the edge id from neighbor's north edge sideinfo ( 3 , 1 , iel ) = e2 sideinfo ( 4 , 1 , iel ) = 10 * 3 ! Neighbor side id - neighbor to the south, north side (3) sideinfo ( 5 , 1 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif ! east, iside=2 ! Get the corner node ids for this edge ! East edges are always new edges, due to the way we are traversing the grid nedges = nedges + 1 sideinfo ( 2 , 2 , iel ) = nedges if ( i == nxPerTile ) then ! eastern most part of the tile if ( ti == nTileX ) then ! eastern most tile sideinfo ( 3 , 2 , iel ) = 0 ! Neigbor element (null, boundary condition) sideinfo ( 4 , 2 , iel ) = 0 ! Neighbor side id (null, boundary condition) sideinfo ( 5 , 2 , iel ) = bcids ( 2 ) ! Boundary condition id; eastern boundary set from the user input else ! interior tile, but eastern most edge of the tile sideinfo ( 3 , 2 , iel ) = 1 + nxPerTile * ( j - 1 + nyPerTile * ( ti + nTilex * ( tj - 1 ))) ! Neigbor element, westernnmost element, in tile to the east sideinfo ( 4 , 2 , iel ) = 10 * 4 ! Neighbor side id - neighbor to the east, west side (4) sideinfo ( 5 , 2 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif else ! interior to the tile sideinfo ( 3 , 2 , iel ) = i + 1 + nxPerTile * ( j - 1 + nyPerTile * ( ti - 1 + nTilex * ( tj - 1 ))) ! Neigbor element, inside same tile, to the east sideinfo ( 4 , 2 , iel ) = 10 * 4 ! Neighbor side id - neighbor to the east, west side (4) sideinfo ( 5 , 2 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif ! north, iside=3 ! Get the corner node ids for this edge ! East edges are always new edges, due to the way we are traversing the grid nedges = nedges + 1 sideinfo ( 2 , 3 , iel ) = nedges if ( j == nyPerTile ) then ! northern most part of the tile if ( tj == nTileY ) then ! northern most tile sideinfo ( 3 , 3 , iel ) = 0 ! Neigbor element (null, boundary condition) sideinfo ( 4 , 3 , iel ) = 0 ! Neighbor side id (null, boundary condition) sideinfo ( 5 , 3 , iel ) = bcids ( 3 ) ! Boundary condition id; set from the user input else ! interior tile, but northern most edge of the tile sideinfo ( 3 , 3 , iel ) = i + nxPerTile * ( nyPerTile * ( ti - 1 + nTilex * ( tj ))) ! Neigbor element, southernmost element in tile to the north sideinfo ( 4 , 3 , iel ) = 10 * 1 ! Neighbor side id - neighbor to the north, south side (1) sideinfo ( 5 , 3 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif else ! interior to the tile sideinfo ( 3 , 3 , iel ) = i + nxPerTile * ( j + nyPerTile * ( ti - 1 + nTilex * ( tj - 1 ))) ! Neigbor element, inside same tile, to the north sideinfo ( 4 , 3 , iel ) = 10 * 1 ! Neighbor side id - neighbor to the north, south side (1) sideinfo ( 5 , 3 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif ! west, iside=4 ! Get the corner node ids for this edge ! n1 = globalNodeIds(this%CGNSCornerMap(1,1),this%CGNSCornerMap(2,1),iel) ! n2 = globalNodeIds(this%CGNSCornerMap(1,4),this%CGNSCornerMap(2,4),iel) ! nc1 = min(n1,n2) ! nc2 = max(n1,n2) ! sideInfo(2,1,iel) = (nc1+nc2)*(nc1+nc2+1)/2 + nc2 if ( i == 1 ) then ! western most part of the tile if ( ti == 1 ) then ! western most tile nedges = nedges + 1 sideinfo ( 2 , 4 , iel ) = nedges sideinfo ( 3 , 4 , iel ) = 0 ! Neigbor element (null, boundary condition) sideinfo ( 4 , 4 , iel ) = 0 ! Neighbor side id (null, boundary condition) sideinfo ( 5 , 4 , iel ) = bcids ( 4 ) ! Boundary condition id; eastern boundary set from the user input else ! interior tile, but western most edge of the tile e2 = nxPerTile + nxPerTile * ( j - 1 + nyPerTile * ( ti - 2 + nTilex * ( tj - 1 ))) ! Neigbor element, easternnmost element in tile to the west sideinfo ( 3 , 4 , iel ) = sideInfo ( 2 , 2 , e2 ) ! Copy the edge id from neighbor's east edge sideinfo ( 3 , 4 , iel ) = e2 sideinfo ( 4 , 4 , iel ) = 10 * 2 ! Neighbor side id - neighbor to the west, east side (2) sideinfo ( 5 , 4 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif else ! interior to the tile e2 = i - 1 + nxPerTile * ( j - 1 + nyPerTile * ( ti - 1 + nTilex * ( tj - 1 ))) ! Neigbor element, inside same tile, to the west sideinfo ( 3 , 4 , iel ) = sideInfo ( 2 , 2 , e2 ) ! Copy the edge id from neighbor's east edge sideinfo ( 3 , 4 , iel ) = e2 sideinfo ( 4 , 4 , iel ) = 10 * 2 ! Neighbor side id - neighbor to the west, east side (2) sideinfo ( 5 , 4 , iel ) = 0 ! Boundary condition id; (null, interior edge) endif enddo enddo enddo enddo if ( nedges /= nUniqueSides ) then print * , \"nedges not equal to nuniquesides, wtf : \" , nedges , nUniqueSides endif call this % decomp % GenerateDecomposition ( nGlobalElem , nUniqueSides ) e1 = this % decomp % offsetElem ( this % decomp % rankId + 1 ) + 1 e2 = this % decomp % offsetElem ( this % decomp % rankId + 2 ) nLocalElems = e2 - e1 + 1 nLocalSides = nLocalElems * 4 nLocalNodes = nLocalElems * 4 call this % Init ( nGeo , nLocalElems , nLocalSides , nLocalNodes , nBCs ) this % nUniqueSides = nUniqueSides this % quadrature = UNIFORM this % nodeCoords ( 1 : 2 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nLocalElems ) = nodeCoords ( 1 : 2 , 1 : nGeo + 1 , 1 : nGeo + 1 , e1 : e2 ) this % globalNodeIDs ( 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nLocalElems ) = globalNodeIDs ( 1 : nGeo + 1 , 1 : nGeo + 1 , e1 : e2 ) this % sideInfo ( 1 : 5 , 1 : 4 , 1 : nLocalElems ) = sideInfo ( 1 : 5 , 1 : 4 , e1 : e2 ) deallocate ( nodeCoords ) deallocate ( globalNodeIDs ) deallocate ( sideInfo ) endsubroutine UniformStructuredMesh_Mesh2D_t subroutine Read_HOPr_Mesh2D_t ( this , meshFile , enableDomainDecomposition ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 ! Adapted for 2D Mesh : Note that HOPR does not have 2D mesh output. implicit none class ( Mesh2D_t ), intent ( out ) :: this character ( * ), intent ( in ) :: meshFile logical , intent ( in ), optional :: enableDomainDecomposition ! Local integer ( HID_T ) :: fileId integer ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) integer :: nGlobalElem integer :: firstElem integer :: firstNode integer :: firstSide integer :: nLocalElems integer :: nLocalNodes3D integer :: nLocalSides3D integer :: nUniqueSides3D integer :: nLocalNodes2D integer :: nLocalSides2D integer :: nUniqueSides2D integer :: nGeo , nBCs integer :: eid , lsid , iSide integer :: i , j , nid integer , dimension (:,:), allocatable :: hopr_elemInfo integer , dimension (:,:), allocatable :: hopr_sideInfo real ( prec ), dimension (:,:), allocatable :: hopr_nodeCoords integer , dimension (:), allocatable :: hopr_globalNodeIDs integer , dimension (:,:), allocatable :: bcType if ( present ( enableDomainDecomposition )) then call this % decomp % init ( enableDomainDecomposition ) else call this % decomp % init (. false .) endif print * , __ FILE__ // ' : Reading HOPr mesh from' // trim ( meshfile ) if ( this % decomp % mpiEnabled ) then call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId , this % decomp % mpiComm ) else call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId ) endif print * , __ FILE__ // ' : Loading mesh attributes' call ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) call ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) call ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) call ReadAttribute_HDF5 ( fileId , 'nUniqueSides' , nUniqueSides3D ) print * , __ FILE__ // ' : N Global Elements = ' , nGlobalElem print * , __ FILE__ // ' : Mesh geometry degree = ' , nGeo print * , __ FILE__ // ' : N Boundary conditions = ' , nBCs print * , __ FILE__ // ' : N Unique Sides (3D) = ' , nUniqueSides3D ! Read BCType allocate ( bcType ( 1 : 4 , 1 : nBCS )) if ( this % decomp % mpiEnabled ) then offset (:) = 0 call ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) else call ReadArray_HDF5 ( fileId , 'BCType' , bcType ) endif ! Read local subarray of ElemInfo print * , __ FILE__ // ' : Generating Domain Decomposition' call this % decomp % GenerateDecomposition ( nGlobalElem , nUniqueSides3D ) firstElem = this % decomp % offsetElem ( this % decomp % rankId + 1 ) + 1 nLocalElems = this % decomp % offsetElem ( this % decomp % rankId + 2 ) - & this % decomp % offsetElem ( this % decomp % rankId + 1 ) print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : element offset = ' , firstElem print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : n_elements = ' , nLocalElems ! Allocate Space for hopr_elemInfo! allocate ( hopr_elemInfo ( 1 : 6 , 1 : nLocalElems )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstElem - 1 / ) call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) else call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) endif ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo ( 5 , 1 ) + 1 nLocalNodes3D = hopr_elemInfo ( 6 , nLocalElems ) - hopr_elemInfo ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! allocate ( hopr_nodeCoords ( 1 : 3 , nLocalNodes3D ), hopr_globalNodeIDs ( 1 : nLocalNodes3D )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) else call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) endif ! Read local subarray of SideInfo firstSide = hopr_elemInfo ( 3 , 1 ) + 1 nLocalSides3D = hopr_elemInfo ( 4 , nLocalElems ) - hopr_elemInfo ( 3 , 1 ) ! Allocate space for hopr_sideInfo allocate ( hopr_sideInfo ( 1 : 5 , 1 : nLocalSides3D )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstSide - 1 / ) print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' Reading side information' call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) else call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) endif call Close_HDF5 ( fileID ) ! ---- Done reading 3-D Mesh information ---- ! ! Now we need to convert from 3-D to 2-D ! nLocalSides2D = nLocalSides3D - 2 * nLocalElems nUniqueSides2D = nUniqueSides3D - 2 * nGlobalElem ! Remove the \"top\" and \"bottom\" faces nLocalNodes2D = nLocalNodes2D - nLocalElems * nGeo * ( nGeo + 1 ) ** 2 ! Remove the third dimension print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' Allocating memory for mesh' print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' n local sides  : ' , nLocalSides2D call this % Init ( nGeo , nLocalElems , nLocalSides2D , nLocalNodes2D , nBCs ) this % nUniqueSides = nUniqueSides2D ! Store the number of sides in the global mesh ! Copy data from local arrays into this !  elemInfo(1:6,iEl) !    1 - Element Type !    2 - Zone !    3 - offset index for side array (not needed when all quads are assumed) !    4 - last index for side array (not needed when all quads are assumed) !    5 - offset index for node array (not needed when all quads are assumed) !    6 - last index for node array (not needed when all quads are assumed) this % elemInfo = hopr_elemInfo this % quadrature = UNIFORM ! HOPr uses uniformly spaced points ! Grab the node coordinates (x and y only) from the \"bottom\" layer of the extruded mesh do eid = 1 , this % nElem do j = 1 , nGeo + 1 do i = 1 , nGeo + 1 nid = i + ( nGeo + 1 ) * ( j - 1 + ( nGeo + 1 ) * (( nGeo + 1 ) * ( eid - 1 ))) this % nodeCoords ( 1 : 2 , i , j , eid ) = hopr_nodeCoords ( 1 : 2 , nid ) this % globalNodeIDs ( i , j , eid ) = hopr_globalNodeIDs ( nid ) enddo enddo enddo ! Grab the south, west, north, and south sides of the elements !  sideInfo(1:5,iSide,iEl) ! !    1 - Side Type (currently unused in SELF) !    2 - Global Side ID (Used for message passing. Don't need to change) !    3 - Neighbor Element ID (Can stay the same) !    4 - 10*( neighbor local side )  + flip (Need to recalculate flip) !    5 - Boundary Condition ID (Can stay the same) do eid = 1 , this % nElem do lsid = 1 , 4 ! Calculate the 3-D side ID from the 2-D local side id and element ID iSide = lsid + 1 + 6 * ( eid - 1 ) this % sideInfo ( 1 : 5 , lsid , eid ) = hopr_sideInfo ( 1 : 5 , iSide ) ! Adjust the secondary side index for 2-D this % sideInfo ( 4 , lsid , eid ) = this % sideInfo ( 4 , lsid , eid ) - 10 enddo enddo call this % RecalculateFlip () deallocate ( hopr_elemInfo , hopr_nodeCoords , hopr_globalNodeIDs , hopr_sideInfo ) endsubroutine Read_HOPr_Mesh2D_t subroutine RecalculateFlip_Mesh2D_t ( this ) implicit none class ( Mesh2D_t ), intent ( inout ) :: this ! Local integer :: e1 integer :: s1 integer :: e2 integer :: e2Global integer :: s2 integer :: flip integer :: bcid integer :: lnid1 ( 1 : 2 ) integer :: lnid2 ( 1 : 2 ) integer :: nid1 ( 1 : 2 , 1 : 4 , 1 : this % nElem ) integer :: nid2 ( 1 : 2 , 1 : 4 , 1 : this % nElem ) integer :: nloc1 ( 1 : 2 ) integer :: nloc2 ( 1 : 2 ) integer :: n1 integer :: n1Global integer :: n2 integer :: n2Global integer :: c1 integer :: c2 integer :: i , j integer :: l integer :: nShifts integer :: neighborRank integer :: rankId integer :: offset integer :: msgCount integer :: globalSideId integer , allocatable :: requests (:) integer , allocatable :: stats (:,:) integer :: iError integer :: tag logical :: theyMatch allocate ( requests ( 1 : this % nSides * 2 )) allocate ( stats ( MPI_STATUS_SIZE , 1 : this % nSides * 2 )) if ( this % decomp % mpiEnabled ) then rankId = this % decomp % rankId offset = this % decomp % offsetElem ( rankId + 1 ) else rankId = 0 offset = 0 endif msgCount = 0 do e1 = 1 , this % nElem do s1 = 1 , 4 e2Global = this % sideInfo ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = this % sideInfo ( 4 , s1 , e1 ) / 10 flip = this % sideInfo ( 4 , s1 , e1 ) - s2 * 10 bcid = this % sideInfo ( 5 , s1 , e1 ) if ( e2Global > 0 ) then if ( this % decomp % mpiEnabled ) then neighborRank = this % decomp % elemToRank ( e2Global ) else neighborRank = 0 endif if ( neighborRank == rankId ) then lnid1 = this % CGNSSideMap ( 1 : 2 , s1 ) ! local CGNS corner node ids for element 1 side lnid2 = this % CGNSSideMap ( 1 : 2 , s2 ) ! local CGNS corner node ids for element 2 side do l = 1 , 2 i = this % CGNSCornerMap ( 1 , lnid1 ( l )) j = this % CGNSCornerMap ( 2 , lnid1 ( l )) nid1 ( l , s1 , e1 ) = this % globalNodeIDs ( i , j , e1 ) i = this % CGNSCornerMap ( 1 , lnid2 ( l )) j = this % CGNSCornerMap ( 2 , lnid2 ( l )) nid2 ( l , s1 , e1 ) = this % globalNodeIDs ( i , j , e2 ) enddo else ! In this case, we need to exchange globalSideId = abs ( this % sideInfo ( 2 , s1 , e1 )) lnid1 = this % CGNSSideMap ( 1 : 2 , s1 ) ! local CGNS corner node ids for element 1 side do l = 1 , 2 i = this % CGNSCornerMap ( 1 , lnid1 ( l )) j = this % CGNSCornerMap ( 2 , lnid1 ( l )) nid1 ( l , s1 , e1 ) = this % globalNodeIDs ( i , j , e1 ) tag = l + 2 * globalSideId msgCount = msgCount + 1 call MPI_IRECV ( nid2 ( l , s1 , e1 ), & 1 , & MPI_INTEGER , & neighborRank , tag , & this % decomp % mpiComm , & requests ( msgCount ), iError ) ! Send nid1(l) from this rank to nid2(l) on the other rank msgCount = msgCount + 1 call MPI_ISEND ( nid1 ( l , s1 , e1 ), & 1 , & MPI_INTEGER , & neighborRank , tag , & this % decomp % mpiComm , & requests ( msgCount ), iError ) enddo endif ! MPI or not endif ! If not physical boundary enddo enddo if ( this % decomp % mpiEnabled . and . msgCount > 0 ) then call MPI_WaitAll ( msgCount , & requests ( 1 : msgCount ), & stats ( 1 : MPI_STATUS_SIZE , 1 : msgCount ), & iError ) endif do e1 = 1 , this % nElem do s1 = 1 , 4 e2Global = this % sideInfo ( 3 , s1 , e1 ) s2 = this % sideInfo ( 4 , s1 , e1 ) / 10 nloc1 ( 1 : 2 ) = nid1 ( 1 : 2 , s1 , e1 ) nloc2 ( 1 : 2 ) = nid2 ( 1 : 2 , s1 , e1 ) if ( e2Global > 0 ) then theyMatch = CompareArray ( nloc1 , nloc2 , 2 ) if ( theyMatch ) then this % sideInfo ( 4 , s1 , e1 ) = 10 * s2 else this % sideInfo ( 4 , s1 , e1 ) = 10 * s2 + 1 endif endif enddo enddo deallocate ( requests ) deallocate ( stats ) endsubroutine RecalculateFlip_Mesh2D_t subroutine Write_Mesh2D_t ( this , meshFile ) ! Writes mesh output in HOPR format (serial only) implicit none class ( Mesh2D_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: meshFile ! Local integer ( HID_T ) :: fileId call Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) call WriteAttribute_HDF5 ( fileId , 'nElems' , this % nElem ) call WriteAttribute_HDF5 ( fileId , 'Ngeo' , this % nGeo ) call WriteAttribute_HDF5 ( fileId , 'nBCs' , this % nBCs ) call WriteArray_HDF5 ( fileId , 'BCType' , this % bcType ) ! Write local subarray of ElemInfo call WriteArray_HDF5 ( fileId , 'ElemInfo' , this % elemInfo ) ! Write local subarray of NodeCoords and GlobalNodeIDs call WriteArray_HDF5 ( fileId , 'NodeCoords' , this % nodeCoords ) call WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , this % globalNodeIDs ) ! Write local subarray of SideInfo call WriteArray_HDF5 ( fileId , 'SideInfo' , this % sideInfo ) call Close_HDF5 ( fileID ) endsubroutine Write_Mesh2D_t endmodule SELF_Mesh_2D_t","tags":"","loc":"sourcefile/self_mesh_2d_t.f90.html"},{"title":"SELF_Geometry_2D.f90 – SELF","text":"Contents Modules SELF_Geometry_2D Source Code SELF_Geometry_2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Geometry_2D use SELF_Constants use SELF_Lagrange use SELF_Data use SELF_Scalar_2D use SELF_Vector_2D use SELF_Tensor_2D use SELF_SupportRoutines use SELF_Mesh_2D implicit none #include \"SELF_Macros.h\" type , public :: SEMQuad type ( Vector2D ) :: x ! Physical positions type ( Tensor2D ) :: dxds ! Covariant basis vectors type ( Tensor2D ) :: dsdx ! Contavariant basis vectors type ( Vector2D ) :: nHat ! Normal Vectors pointing across coordinate lines type ( Scalar2D ) :: nScale ! Boundary scale type ( Scalar2D ) :: J ! Jacobian of the transformation integer :: nElem contains procedure , public :: Init => Init_SEMQuad procedure , public :: Free => Free_SEMQuad procedure , public :: GenerateFromMesh => GenerateFromMesh_SEMQuad procedure , public :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad procedure , private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad procedure , public :: WriteTecplot => WriteTecplot_SEMQuad endtype SEMQuad contains subroutine Init_SEMQuad ( myGeom , interp , nElem ) implicit none class ( SEMQuad ), intent ( out ) :: myGeom type ( Lagrange ), pointer , intent ( in ) :: interp integer , intent ( in ) :: nElem myGeom % nElem = nElem call myGeom % x % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % x % meta ( 1 )% SetName ( \"x\" ) call myGeom % dxds % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % dsdx % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % nHat % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % nScale % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % J % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) endsubroutine Init_SEMQuad subroutine Free_SEMQuad ( myGeom ) implicit none class ( SEMQuad ), intent ( inout ) :: myGeom call myGeom % x % Free () call myGeom % dxds % Free () call myGeom % dsdx % Free () call myGeom % nHat % Free () call myGeom % nScale % Free () call myGeom % J % Free () endsubroutine Free_SEMQuad subroutine GenerateFromMesh_SEMQuad ( myGeom , mesh ) implicit none class ( SEMQuad ), intent ( inout ) :: myGeom type ( Mesh2D ), intent ( in ) :: mesh ! Local integer :: iel integer :: i , j type ( Lagrange ), target :: meshToModel type ( Vector2D ) :: xMesh call meshToModel % Init ( mesh % nGeo , & mesh % quadrature , & myGeom % x % interp % N , & myGeom % x % interp % controlNodeType ) call xMesh % Init ( meshToModel , 1 , mesh % nElem ) ! Set the element internal mesh locations do iel = 1 , mesh % nElem do j = 1 , mesh % nGeo + 1 do i = 1 , mesh % nGeo + 1 xMesh % interior ( i , j , iel , 1 , 1 : 2 ) = mesh % nodeCoords ( 1 : 2 , i , j , iel ) enddo enddo enddo call xMesh % GridInterp ( myGeom % x % interior ) call myGeom % x % UpdateDevice () call myGeom % x % BoundaryInterp () ! Boundary interp will run on GPU if enabled, hence why we close in update host/device call myGeom % x % UpdateHost () call myGeom % CalculateMetricTerms () call xMesh % Free () call meshToModel % Free () endsubroutine GenerateFromMesh_SEMQuad subroutine CalculateContravariantBasis_SEMQuad ( myGeom ) implicit none class ( SEMQuad ), intent ( inout ) :: myGeom ! Local integer :: iEl , i , j , k real ( prec ) :: fac real ( prec ) :: mag ! Now calculate the contravariant basis vectors ! In this convention, dsdx(j,i) is contravariant vector i, component j ! To project onto contravariant vector i, dot vector along the first dimension do iEl = 1 , myGeom % nElem do j = 1 , myGeom % dxds % interp % N + 1 do i = 1 , myGeom % dxds % interp % N + 1 myGeom % dsdx % interior ( i , j , iel , 1 , 1 , 1 ) = myGeom % dxds % interior ( i , j , iel , 1 , 2 , 2 ) myGeom % dsdx % interior ( i , j , iel , 1 , 2 , 1 ) = - myGeom % dxds % interior ( i , j , iel , 1 , 1 , 2 ) myGeom % dsdx % interior ( i , j , iel , 1 , 1 , 2 ) = - myGeom % dxds % interior ( i , j , iel , 1 , 2 , 1 ) myGeom % dsdx % interior ( i , j , iel , 1 , 2 , 2 ) = myGeom % dxds % interior ( i , j , iel , 1 , 1 , 1 ) enddo enddo enddo ! Interpolate the contravariant tensor to the boundaries call myGeom % dsdx % BoundaryInterp () ! Tensor boundary interp is not offloaded ! Now, modify the sign of dsdx so that ! myGeom % dsdx % boundary is equal to the outward pointing normal vector do iEl = 1 , myGeom % nElem do k = 1 , 4 do i = 1 , myGeom % J % interp % N + 1 if ( k == selfSide2D_East . or . k == selfSide2D_North ) then fac = sign ( 1.0_prec , myGeom % J % boundary ( i , k , iEl , 1 )) else fac = - sign ( 1.0_prec , myGeom % J % boundary ( i , k , iEl , 1 )) endif if ( k == 1 ) then ! South mag = sqrt ( myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 , 2 ) ** 2 + & myGeom % dsdx % boundary ( i , k , iEl , 1 , 2 , 2 ) ** 2 ) myGeom % nScale % boundary ( i , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , k , iEl , 1 , 1 : 2 ) = & fac * myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 : 2 , 2 ) / mag elseif ( k == 2 ) then ! East mag = sqrt ( myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 , 1 ) ** 2 + & myGeom % dsdx % boundary ( i , k , iEl , 1 , 2 , 1 ) ** 2 ) myGeom % nScale % boundary ( i , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , k , iEl , 1 , 1 : 2 ) = & fac * myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 : 2 , 1 ) / mag elseif ( k == 3 ) then ! North mag = sqrt ( myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 , 2 ) ** 2 + & myGeom % dsdx % boundary ( i , k , iEl , 1 , 2 , 2 ) ** 2 ) myGeom % nScale % boundary ( i , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , k , iEl , 1 , 1 : 2 ) = & fac * myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 : 2 , 2 ) / mag elseif ( k == 4 ) then ! West mag = sqrt ( myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 , 1 ) ** 2 + & myGeom % dsdx % boundary ( i , k , iEl , 1 , 2 , 1 ) ** 2 ) myGeom % nScale % boundary ( i , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , k , iEl , 1 , 1 : 2 ) = & fac * myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 : 2 , 1 ) / mag endif ! Set the directionality for dsdx on the boundaries myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 : 2 , 1 : 2 ) = & myGeom % dsdx % boundary ( i , k , iEl , 1 , 1 : 2 , 1 : 2 ) * fac enddo enddo enddo call myGeom % dsdx % UpdateDevice () call myGeom % nHat % UpdateDevice () call myGeom % nScale % UpdateDevice () endsubroutine CalculateContravariantBasis_SEMQuad subroutine CalculateMetricTerms_SEMQuad ( myGeom ) implicit none class ( SEMQuad ), intent ( inout ) :: myGeom call myGeom % x % Gradient ( myGeom % dxds % interior ) call myGeom % dxds % BoundaryInterp () ! Tensor boundary interp is not offloaded to GPU call myGeom % dxds % UpdateDevice () call myGeom % dxds % Determinant ( myGeom % J % interior ) call myGeom % J % UpdateDevice () call myGeom % J % BoundaryInterp () call myGeom % J % UpdateHost () call myGeom % CalculateContravariantBasis () endsubroutine CalculateMetricTerms_SEMQuad subroutine WriteTecplot_SEMQuad ( this , filename ) implicit none class ( SEMQuad ), intent ( inout ) :: this character ( * ), intent ( in ) :: filename ! Local character ( 8 ) :: zoneID integer :: fUnit integer :: iEl , i , j , iVar character ( LEN = self_TecplotHeaderLength ) :: tecHeader character ( LEN = self_FormatLength ) :: fmat open ( UNIT = NEWUNIT ( fUnit ), & FILE = trim ( filename ), & FORM = 'formatted' , & STATUS = 'replace' ) tecHeader = 'VARIABLES = \"X\", \"Y\", \"eID\"' write ( fUnit , * ) trim ( tecHeader ) ! Create format statement write ( fmat , * ) 3 fmat = '(' // trim ( fmat ) // '(ES16.7E3,1x))' do iEl = 1 , this % x % nElem ! TO DO :: Get the global element ID write ( zoneID , '(I8.8)' ) iEl write ( fUnit , * ) 'ZONE T=\"el' // trim ( zoneID ) // '\", I=' , this % x % interp % N + 1 , & ', J=' , this % x % interp % N + 1 do j = 1 , this % x % interp % N + 1 do i = 1 , this % x % interp % N + 1 write ( fUnit , fmat ) this % x % interior ( i , j , iEl , 1 , 1 ), & this % x % interior ( i , j , iEl , 1 , 2 ), real ( iEl , prec ) enddo enddo enddo close ( UNIT = fUnit ) endsubroutine WriteTecplot_SEMQuad endmodule SELF_Geometry_2D","tags":"","loc":"sourcefile/self_geometry_2d.f90.html"},{"title":"SELF_NullDGModel1D_t.f90 – SELF","text":"Contents Modules self_NullDGModel1D_t Source Code SELF_NullDGModel1D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUsLESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARIsLG IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_NullDGModel1D_t use self_model use self_dgmodel1d use self_mesh implicit none type , extends ( dgmodel1d ) :: NullDGModel1D_t ! Add any additional attributes here that are specific to your model contains !   procedure :: hbc1d_Prescribed => hbc1d_Prescribed_Model !   procedure :: hbc1d_Radiation => hbc1d_Generic_Model !   procedure :: hbc1d_NoNormalFlow => hbc1d_Generic_Model !   procedure :: pbc1d_Prescribed => pbc1d_Prescribed_Model !   procedure :: pbc1d_Radiation => pbc1d_Generic_Model !   procedure :: pbc1d_NoNormalFlow => pbc1d_Generic_Model !   procedure :: SetMetadata => SetMetadata_NullDGModel1D_t !   procedure :: pretendency => pretendency_NullDGModel1D_t !   procedure :: entropy_func => entropy_func_NullDGModel1D_t !   procedure :: flux1d => flux1d_NullDGModel1D_t !   procedure :: riemannflux1d => riemannflux1d_NullDGModel1D_t !   procedure :: source1d => source1d_NullDGModel1D_t endtype NullDGModel1D_t contains ! subroutine SetMetadata_NullDGModel1D_t(this) !   implicit none !   class(NullDGModel1D_t),intent(inout) :: this !   ! Local !   integer :: ivar !   character(LEN=3) :: ivarChar !   character(LEN=25) :: varname !   do ivar = 1,this%nvar !     write(ivarChar,'(I3.3)') ivar !     varname = \"solution\"//trim(ivarChar) !     call this%solution%SetName(ivar,varname) !     call this%solution%SetUnits(ivar,\"[null]\") !   enddo ! endsubroutine SetMetadata_NullDGModel1D_t ! pure function entropy_func_NullDGModel1D_t(this,s) result(e) !   class(NullDGModel1D_t),intent(in) :: this !   real(prec),intent(in) :: s(1:this%solution%nvar) !   real(prec) :: e !   e = 0.0_prec ! endfunction entropy_func_NullDGModel1D_t ! pure function flux1d_NullDGModel1D_t(this,s,dsdx) result(flux) !   class(NullDGModel1D_t),intent(in) :: this !   real(prec),intent(in) :: s(1:this%solution%nvar) !   real(prec),intent(in) :: dsdx(1:this%solution%nvar) !   real(prec) :: flux(1:this%solution%nvar) !   flux(1:this%nvar) = 0.0_prec ! endfunction flux1d_NullDGModel1D_t ! pure function riemannflux1d_NullDGModel1D_t(this,sL,sR,dsdx,nhat) result(flux) !   class(NullDGModel1D_t),intent(in) :: this !   real(prec),intent(in) :: sL(1:this%solution%nvar) !   real(prec),intent(in) :: sR(1:this%solution%nvar) !   real(prec),intent(in) :: dsdx(1:this%solution%nvar) !   real(prec),intent(in) :: nhat !   real(prec) :: flux(1:this%solution%nvar) !   flux(1:this%nvar) = 0.0_prec ! endfunction riemannflux1d_NullDGModel1D_t ! subroutine PreTendency_NulDGModel1D_t(this) ! !! PreTendency is a template routine that is used to house any additional calculations ! !! that you want to execute at the beginning of the tendency calculation routine. ! !! This default PreTendency simply returns back to the caller without executing any instructions ! !! ! !! The intention is to provide a method that can be overridden through type-extension, to handle ! !! any steps that need to be executed before proceeding with the usual tendency calculation methods. ! !! !   implicit none !   class(Model),intent(inout) :: this !   return ! endsubroutine PreTendency_NulDGModel1D_t ! pure function source1d_NullDGModel1D_t(this,s,dsdx) result(source) !   class(NullDGModel1D_t),intent(in) :: this !   real(prec),intent(in) :: s(1:this%solution%nvar) !   real(prec),intent(in) :: dsdx(1:this%solution%nvar) !   real(prec) :: source(1:this%solution%nvar) !   source(1:this%nvar) = 0.0_prec ! endfunction source1d_NullDGModel1D_t endmodule self_NullDGModel1D_t","tags":"","loc":"sourcefile/self_nulldgmodel1d_t.f90.html"},{"title":"SELF_Metadata.f90 – SELF","text":"Contents Modules SELF_Metadata Source Code SELF_Metadata.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Metadata use SELF_HDF5 use HDF5 integer , parameter , public :: SELF_MTD_NameLength = 250 integer , parameter , public :: SELF_MTD_DescriptionLength = 1000 integer , parameter , public :: SELF_MTD_UnitsLength = 20 ! A class for storing metadata information, intended for file IO type Metadata character ( SELF_MTD_NameLength ) :: name character ( SELF_MTD_DescriptionLength ) :: description character ( SELF_MTD_UnitsLength ) :: units contains procedure , public :: SetName => SetName_Metadata procedure , public :: SetDescription => SetDescription_Metadata procedure , public :: SetUnits => SetUnits_Metadata procedure , public :: WriteHDF5 => WriteHDF5_Metadata endtype Metadata contains subroutine SetName_Metadata ( mtd , name ) implicit none class ( Metadata ), intent ( inout ) :: mtd character ( * ), intent ( in ) :: name mtd % name = name endsubroutine SetName_Metadata subroutine SetDescription_Metadata ( mtd , description ) implicit none class ( Metadata ), intent ( inout ) :: mtd character ( * ), intent ( in ) :: description mtd % description = description endsubroutine SetDescription_Metadata subroutine SetUnits_Metadata ( mtd , units ) implicit none class ( Metadata ), intent ( inout ) :: mtd character ( * ), intent ( in ) :: units mtd % units = units endsubroutine SetUnits_Metadata subroutine WriteHDF5_Metadata ( mtd , group , varid , fileId ) !! Writes the metadata to a HDF5 file using the !! fields : !!  * `/metadata/{group}/name/{varid}` !!  * `/metadata/{group}/description/{varid}` !!  * `/metadata/{group}/units/{varid}` !! !! This method assumes that an HDF5 file is already !! open for writing and is associated with the `fileId` !! input. class ( Metadata ), intent ( in ) :: mtd character ( * ), intent ( in ) :: group integer , intent ( in ) :: varid integer ( HID_T ), intent ( in ) :: fileId ! Local character ( 4 ) :: varNumber ! Add variable names to the file call CreateGroup_HDF5 ( fileId , trim ( group ) // \"/metadata\" ) call CreateGroup_HDF5 ( fileId , trim ( group ) // \"/metadata/name\" ) call CreateGroup_HDF5 ( fileId , trim ( group ) // \"/metadata/description\" ) call CreateGroup_HDF5 ( fileId , trim ( group ) // \"/metadata/units\" ) write ( varNumber , \"(I0)\" ) varid call WriteCharacter_HDF5 ( fileId , trim ( group ) // \"/metadata/name/\" // trim ( varnumber ), & trim ( mtd % name )) call WriteCharacter_HDF5 ( fileId , trim ( group ) // \"/metadata/description/\" // trim ( varnumber ), & trim ( mtd % description )) call WriteCharacter_HDF5 ( fileId , trim ( group ) // \"/metadata/units/\" // trim ( varnumber ), & trim ( mtd % units )) endsubroutine WriteHDF5_Metadata endmodule SELF_Metadata","tags":"","loc":"sourcefile/self_metadata.f90.html"},{"title":"SELF_MappedVector_3D_t.f90 – SELF","text":"Contents Modules SELF_MappedVector_3D_t Source Code SELF_MappedVector_3D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_MappedVector_3D_t use SELF_Constants use SELF_Lagrange use SELF_Mesh_3D use SELF_Geometry_3D use SELF_DomainDecomposition use FEQParse use iso_c_binding implicit none type , extends ( Vector3D ), public :: MappedVector3D_t logical :: geometry_associated = . false . type ( SEMHex ), pointer :: geometry => null () contains procedure , public :: AssociateGeometry => AssociateGeometry_MappedVector3D_t procedure , public :: DissociateGeometry => DissociateGeometry_MappedVector3D_t procedure , public :: SideExchange => SideExchange_MappedVector3D_t generic , public :: MappedDivergence => MappedDivergence_MappedVector3D_t procedure , private :: MappedDivergence_MappedVector3D_t generic , public :: MappedDGDivergence => MappedDGDivergence_MappedVector3D_t procedure , private :: MappedDGDivergence_MappedVector3D_t procedure , private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D_t procedure , private :: ApplyFlip => ApplyFlip_MappedVector3D_t procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector3D_t !procedure,public :: WriteTecplot => WriteTecplot_MappedVector3D_t endtype MappedVector3D_t contains subroutine AssociateGeometry_MappedVector3D_t ( this , geometry ) implicit none class ( MappedVector3D_t ), intent ( inout ) :: this type ( SEMHex ), target , intent ( in ) :: geometry if (. not . associated ( this % geometry )) then this % geometry => geometry this % geometry_associated = . true . endif endsubroutine AssociateGeometry_MappedVector3D_t subroutine DissociateGeometry_MappedVector3D_t ( this ) implicit none class ( MappedVector3D_t ), intent ( inout ) :: this if ( associated ( this % geometry )) then this % geometry => null () this % geometry_associated = . false . endif endsubroutine DissociateGeometry_MappedVector3D_t subroutine SetInteriorFromEquation_MappedVector3D_t ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedVector3D_t ), intent ( inout ) :: this type ( SEMHex ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , k , iEl , iVar real ( prec ) :: x real ( prec ) :: y real ( prec ) :: z do iVar = 1 , this % nVar do iEl = 1 , this % nElem do k = 1 , this % interp % N + 1 do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , k , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , k , iEl , 1 , 2 ) z = geometry % x % interior ( i , j , k , iEl , 1 , 3 ) this % interior ( i , j , k , iEl , iVar , 1 ) = & this % eqn ( 1 + 3 * ( iVar - 1 ))% Evaluate (( / x , y , z , time / )) this % interior ( i , j , k , iEl , iVar , 2 ) = & this % eqn ( 2 + 3 * ( iVar - 1 ))% Evaluate (( / x , y , z , time / )) this % interior ( i , j , k , iEl , iVar , 3 ) = & this % eqn ( 3 + 3 * ( iVar - 1 ))% Evaluate (( / x , y , z , time / )) enddo enddo enddo enddo enddo endsubroutine SetInteriorFromEquation_MappedVector3D_t subroutine MPIExchangeAsync_MappedVector3D_t ( this , mesh ) implicit none class ( MappedVector3D_t ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar , idir integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount msgCount = 0 do idir = 1 , 3 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 6 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 + this % nvar * ( idir - 1 )) msgCount = msgCount + 1 call MPI_IRECV ( this % extBoundary (:,:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , globalSideId , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( this % boundary (:,:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , globalSideId , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedVector3D_t subroutine ApplyFlip_MappedVector3D_t ( this , mesh ) ! Apply side flips to sides where MPI exchanges took place. implicit none class ( MappedVector3D_t ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , idir integer :: i , i2 , j , j2 integer :: r2 , flip , ivar integer :: bcid real ( prec ) :: extBuff ( 1 : this % interp % N + 1 , 1 : this % interp % N + 1 ) do idir = 1 , 3 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 6 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 bcid = mesh % sideInfo ( 5 , s1 , e1 ) if ( e2 > 0 ) then ! Interior Element r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 ! Need to update extBoundary with flip applied if ( flip == 0 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 extBuff ( i , j ) = this % extBoundary ( i , j , s1 , e1 , ivar , idir ) enddo enddo else if ( flip == 1 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = j extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar , idir ) enddo enddo else if ( flip == 2 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = this % interp % N + 2 - j extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar , idir ) enddo enddo else if ( flip == 3 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = i j2 = this % interp % N + 2 - j extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar , idir ) enddo enddo else if ( flip == 4 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 extBuff ( i , j ) = this % extBoundary ( j , i , s1 , e1 , ivar , idir ) enddo enddo else if ( flip == 5 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = i extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar , idir ) enddo enddo else if ( flip == 6 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = this % interp % N + 2 - i extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar , idir ) enddo enddo else if ( flip == 7 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = j j2 = this % interp % N + 2 - i extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar , idir ) enddo enddo endif do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = extBuff ( i , j ) enddo enddo endif endif enddo enddo enddo enddo endsubroutine ApplyFlip_MappedVector3D_t subroutine SideExchange_MappedVector3D_t ( this , mesh ) implicit none class ( MappedVector3D_t ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , e2 , s1 , s2 , e2Global integer :: flip integer :: i , i2 , j , j2 , ivar integer :: r2 integer :: rankId , offset integer :: idir integer , pointer :: elemtorank (:) elemtorank => mesh % decomp % elemToRank (:) rankId = mesh % decomp % rankId offset = mesh % decomp % offsetElem ( rankId + 1 ) if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif do concurrent ( s1 = 1 : 6 , e1 = 1 : mesh % nElem , ivar = 1 : this % nvar , idir = 1 : 3 ) e2Global = mesh % sideInfo ( 3 , s1 , e1 ) s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 if ( e2Global > 0 ) then r2 = elemToRank ( e2Global ) if ( r2 == rankId ) then e2 = e2Global - offset if ( flip == 0 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = & this % boundary ( i , j , s2 , e2 , ivar , idir ) enddo enddo else if ( flip == 1 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = j this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = & this % boundary ( i2 , j2 , s2 , e2 , ivar , idir ) enddo enddo else if ( flip == 2 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = this % interp % N + 2 - j this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = & this % boundary ( i2 , j2 , s2 , e2 , ivar , idir ) enddo enddo else if ( flip == 3 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = i j2 = this % interp % N + 2 - j this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = & this % boundary ( i2 , j2 , s2 , e2 , ivar , idir ) enddo enddo else if ( flip == 4 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = & this % boundary ( j , i , s2 , e2 , ivar , idir ) enddo enddo else if ( flip == 5 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = i this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = this % boundary ( i2 , j2 , s2 , e2 , ivar , idir ) enddo enddo else if ( flip == 6 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = this % interp % N + 2 - i this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = this % boundary ( i2 , j2 , s2 , e2 , ivar , idir ) enddo enddo else if ( flip == 7 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = j j2 = this % interp % N + 2 - i this % extBoundary ( i , j , s1 , e1 , ivar , idir ) = this % boundary ( i2 , j2 , s2 , e2 , ivar , idir ) enddo enddo endif endif endif enddo if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call this % ApplyFlip ( mesh ) endif endsubroutine SideExchange_MappedVector3D_t subroutine MappedDivergence_MappedVector3D_t ( this , df ) ! Strong Form Operator !    ! implicit none class ( MappedVector3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , j , k , ii real ( prec ) :: dfLoc , Fx , Fy , Fz , Fc do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( ii , j , k , iEl , iVar , 1 ) Fy = this % interior ( ii , j , k , iEl , iVar , 2 ) Fz = this % interior ( ii , j , k , iEl , iVar , 3 ) Fc = this % geometry % dsdx % interior ( ii , j , k , iEl , 1 , 1 , 1 ) * Fx + & this % geometry % dsdx % interior ( ii , j , k , iEl , 1 , 2 , 1 ) * Fy + & this % geometry % dsdx % interior ( ii , j , k , iEl , 1 , 3 , 1 ) * Fz dfLoc = dfLoc + this % interp % dMatrix ( ii , i ) * Fc enddo dF ( i , j , k , iel , ivar ) = dfLoc enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( i , ii , k , iEl , iVar , 1 ) Fy = this % interior ( i , ii , k , iEl , iVar , 2 ) Fz = this % interior ( i , ii , k , iEl , iVar , 3 ) Fc = this % geometry % dsdx % interior ( i , ii , k , iEl , 1 , 1 , 2 ) * Fx + & this % geometry % dsdx % interior ( i , ii , k , iEl , 1 , 2 , 2 ) * Fy + & this % geometry % dsdx % interior ( i , ii , k , iEl , 1 , 3 , 2 ) * Fz dfLoc = dfLoc + this % interp % dMatrix ( ii , j ) * Fc enddo dF ( i , j , k , iel , ivar ) = ( dF ( i , j , k , iel , ivar ) + dfLoc ) enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( i , j , ii , iEl , iVar , 1 ) Fy = this % interior ( i , j , ii , iEl , iVar , 2 ) Fz = this % interior ( i , j , ii , iEl , iVar , 3 ) Fc = this % geometry % dsdx % interior ( i , j , ii , iEl , 1 , 1 , 3 ) * Fx + & this % geometry % dsdx % interior ( i , j , ii , iEl , 1 , 2 , 3 ) * Fy + & this % geometry % dsdx % interior ( i , j , ii , iEl , 1 , 3 , 3 ) * Fz dfLoc = dfLoc + this % interp % dMatrix ( ii , k ) * Fc enddo dF ( i , j , k , iel , ivar ) = ( dF ( i , j , k , iel , ivar ) + dfLoc ) / this % geometry % J % interior ( i , j , k , iEl , 1 ) enddo endsubroutine MappedDivergence_MappedVector3D_t subroutine MappedDGDivergence_MappedVector3D_t ( this , df ) !! Computes the divergence of a 3-D vector using the weak form !! On input, the  attribute of the vector !! is assigned and the  attribute is set to the physical !! directions of the vector. This method will project the vector !! onto the contravariant basis vectors. implicit none class ( MappedVector3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , j , k , ii real ( prec ) :: dfLoc , Fx , Fy , Fz , Fc do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( ii , j , k , iEl , iVar , 1 ) Fy = this % interior ( ii , j , k , iEl , iVar , 2 ) Fz = this % interior ( ii , j , k , iEl , iVar , 3 ) Fc = this % geometry % dsdx % interior ( ii , j , k , iEl , 1 , 1 , 1 ) * Fx + & this % geometry % dsdx % interior ( ii , j , k , iEl , 1 , 2 , 1 ) * Fy + & this % geometry % dsdx % interior ( ii , j , k , iEl , 1 , 3 , 1 ) * Fz dfLoc = dfLoc + this % interp % dgMatrix ( ii , i ) * Fc enddo dfLoc = dfLoc + & ( this % interp % bMatrix ( i , 2 ) * this % boundaryNormal ( j , k , 3 , iel , ivar ) + & ! east this % interp % bMatrix ( i , 1 ) * this % boundaryNormal ( j , k , 5 , iel , ivar )) / & ! west this % interp % qweights ( i ) dF ( i , j , k , iel , ivar ) = dfLoc enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( i , ii , k , iEl , iVar , 1 ) Fy = this % interior ( i , ii , k , iEl , iVar , 2 ) Fz = this % interior ( i , ii , k , iEl , iVar , 3 ) Fc = this % geometry % dsdx % interior ( i , ii , k , iEl , 1 , 1 , 2 ) * Fx + & this % geometry % dsdx % interior ( i , ii , k , iEl , 1 , 2 , 2 ) * Fy + & this % geometry % dsdx % interior ( i , ii , k , iEl , 1 , 3 , 2 ) * Fz dfLoc = dfLoc + this % interp % dgMatrix ( ii , j ) * Fc enddo dfLoc = + dfLoc + & ( this % interp % bMatrix ( j , 2 ) * this % boundaryNormal ( i , k , 4 , iel , ivar ) + & ! north this % interp % bMatrix ( j , 1 ) * this % boundaryNormal ( i , k , 2 , iel , ivar )) / & ! south this % interp % qweights ( j ) dF ( i , j , k , iel , ivar ) = ( dF ( i , j , k , iel , ivar ) + dfLoc ) enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( i , j , ii , iEl , iVar , 1 ) Fy = this % interior ( i , j , ii , iEl , iVar , 2 ) Fz = this % interior ( i , j , ii , iEl , iVar , 3 ) Fc = this % geometry % dsdx % interior ( i , j , ii , iEl , 1 , 1 , 3 ) * Fx + & this % geometry % dsdx % interior ( i , j , ii , iEl , 1 , 2 , 3 ) * Fy + & this % geometry % dsdx % interior ( i , j , ii , iEl , 1 , 3 , 3 ) * Fz dfLoc = dfLoc + this % interp % dgMatrix ( ii , k ) * Fc enddo dfLoc = dfLoc + & ( this % interp % bMatrix ( k , 2 ) * this % boundaryNormal ( i , j , 6 , iel , ivar ) + & ! top this % interp % bMatrix ( k , 1 ) * this % boundaryNormal ( i , j , 1 , iel , ivar )) / & ! bottom this % interp % qweights ( k ) dF ( i , j , k , iel , ivar ) = ( dF ( i , j , k , iel , ivar ) + dfLoc ) / this % geometry % J % interior ( i , j , k , iEl , 1 ) enddo endsubroutine MappedDGDivergence_MappedVector3D_t ! subroutine WriteTecplot_MappedVector3D_t(this,geometry,filename) !   implicit none !   class(MappedVector3D_t),intent(inout) :: this !   type(SEMHex),intent(in) :: geometry !   character(*),intent(in),optional :: filename !   ! Local !   character(8) :: zoneID !   integer :: fUnit !   integer :: iEl,i,j,k,iVar !   character(LEN=self_FileNameLength) :: tecFile !   character(LEN=self_TecplotHeaderLength) :: tecHeader !   character(LEN=self_FormatLength) :: fmat !   character(13) :: timeStampString !   character(5) :: rankString !   real(prec) :: f(1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:3) !   real(prec) :: x(1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:3) !   if(present(filename)) then !     tecFile = filename !   else !     tecFile = \"mappedvector.tec\" !   endif !   ! Map the mesh positions to the target grid !   x = geometry%x%GridInterp() !   ! Map the solution to the target grid !   f = this%GridInterp() !   open(UNIT=NEWUNIT(fUnit), & !        FILE=trim(tecFile), & !        FORM='formatted', & !        STATUS='replace') !   tecHeader = 'VARIABLES = \"X\", \"Y\", \"Z\"' !   do iVar = 1,this%nVar !     tecHeader = trim(tecHeader)//', \"'//trim(this%meta(iVar)%name)//'_x\"' !   enddo !   do iVar = 1,this%nVar !     tecHeader = trim(tecHeader)//', \"'//trim(this%meta(iVar)%name)//'_y\"' !   enddo !   do iVar = 1,this%nVar !     tecHeader = trim(tecHeader)//', \"'//trim(this%meta(iVar)%name)//'_z\"' !   enddo !   write(fUnit,*) trim(tecHeader) !   ! Create format statement !   write(fmat,*) 3*this%nvar+3 !   fmat = '('//trim(fmat)//'(ES16.7E3,1x))' !   do iEl = 1,this%nElem !     write(zoneID,'(I8.8)') iEl !     write(fUnit,*) 'ZONE T=\"el'//trim(zoneID)//'\", I=',this%interp%M+1, & !       ', J=',this%interp%M+1,', K=',this%interp%M+1 !     do k = 1,this%interp%M+1 !       do j = 1,this%interp%M+1 !         do i = 1,this%interp%M+1 !           write(fUnit,fmat) x(i,j,k,iEl,1,1), & !             x(i,j,k,iEl,1,2), & !             x(i,j,k,iEl,1,3), & !             f(i,j,k,iEl,1:this%nvar,1), & !             f(i,j,k,iEl,1:this%nvar,2), & !             f(i,j,k,iEl,1:this%nvar,3) !         enddo !       enddo !     enddo !   enddo !   close(UNIT=fUnit) ! endsubroutine WriteTecplot_MappedVector3D_t endmodule SELF_MappedVector_3D_t","tags":"","loc":"sourcefile/self_mappedvector_3d_t.f90.html"},{"title":"SELF_HDF5.f90 – SELF","text":"Contents Modules SELF_HDF5 Source Code SELF_HDF5.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_HDF5 use SELF_Constants use iso_fortran_env use HDF5 use mpi #ifdef DOUBLE_PRECISION #define HDF5_IO_PREC H5T_IEEE_F64LE #else #define HDF5_IO_PREC H5T_IEEE_F32LE #endif implicit none interface Open_HDF5 module procedure :: Open_HDF5_serial module procedure :: Open_HDF5_parallel endinterface interface ReadAttribute_HDF5 module procedure :: ReadAttribute_HDF5_int32 module procedure :: ReadAttribute_HDF5_real module procedure :: ReadAttribute_HDF5_character endinterface interface WriteAttribute_HDF5 module procedure :: WriteAttribute_HDF5_int32 endinterface interface ReadArray_HDF5 module procedure :: ReadArray_HDF5_real_r1_serial module procedure :: ReadArray_HDF5_real_r2_serial module procedure :: ReadArray_HDF5_real_r3_serial module procedure :: ReadArray_HDF5_real_r4_serial module procedure :: ReadArray_HDF5_real_r5_serial ! module procedure :: ReadArray_HDF5_real_r6_serial module procedure :: ReadArray_HDF5_int32_r1_serial module procedure :: ReadArray_HDF5_int32_r2_serial module procedure :: ReadArray_HDF5_real_r1_parallel module procedure :: ReadArray_HDF5_real_r2_parallel module procedure :: ReadArray_HDF5_real_r3_parallel module procedure :: ReadArray_HDF5_real_r4_parallel ! module procedure :: ReadArray_HDF5_real_r5_parallel ! module procedure :: ReadArray_HDF5_real_r6_parallel module procedure :: ReadArray_HDF5_int32_r1_parallel module procedure :: ReadArray_HDF5_int32_r2_parallel endinterface interface WriteCharacter_HDF5 module procedure :: WriteCharacter_HDF5_serial endinterface WriteCharacter_HDF5 interface WriteArray_HDF5 module procedure :: WriteArray_HDF5_real_r1_serial module procedure :: WriteArray_HDF5_real_r2_serial module procedure :: WriteArray_HDF5_real_r3_serial module procedure :: WriteArray_HDF5_real_r4_serial module procedure :: WriteArray_HDF5_real_r5_serial ! module procedure :: WriteArray_HDF5_real_r6_serial module procedure :: WriteArray_HDF5_int32_r1_serial module procedure :: WriteArray_HDF5_int32_r2_serial module procedure :: WriteArray_HDF5_int32_r3_serial module procedure :: WriteArray_HDF5_int32_r4_serial module procedure :: WriteArray_HDF5_real_r3_parallel module procedure :: WriteArray_HDF5_real_r4_parallel !module procedure :: WriteArray_HDF5_int32_r3_parallel !module procedure :: WriteArray_HDF5_int32_r4_parallel endinterface private public :: Open_HDF5 public :: Close_HDF5 public :: CreateGroup_HDF5 public :: ReadAttribute_HDF5 public :: WriteAttribute_HDF5 public :: ReadArray_HDF5 public :: WriteArray_HDF5 public :: WriteCharacter_HDF5 contains subroutine Open_HDF5_serial ( fileName , accessFlag , fileId ) implicit none character ( * ), intent ( in ) :: fileName integer , intent ( in ) :: accessFlag integer ( HID_T ), intent ( inout ) :: fileId ! Local integer :: error call h5open_f ( error ) if ( accessFlag == H5F_ACC_TRUNC_F ) then call h5fcreate_f ( trim ( fileName ), accessFlag , fileId , error ) else call h5fopen_f ( trim ( fileName ), accessFlag , fileId , error ) endif if ( error == - 1 ) then print * , 'Failed to open ' // trim ( fileName ) // '.' stop 1 endif endsubroutine Open_HDF5_serial subroutine Open_HDF5_parallel ( fileName , accessFlag , fileId , mpiComm ) implicit none character ( * ), intent ( in ) :: fileName integer , intent ( in ) :: accessFlag integer ( HID_T ), intent ( inout ) :: fileId integer , intent ( in ) :: mpiComm ! Local integer ( HID_T ) :: plistId integer :: error call h5open_f ( error ) call h5pcreate_f ( H5P_FILE_ACCESS_F , plistId , error ) call h5pset_fapl_mpio_f ( plistId , mpiComm , MPI_INFO_NULL , error ) if ( accessFlag == H5F_ACC_TRUNC_F ) then call h5fcreate_f ( trim ( fileName ), accessFlag , fileId , error , access_prp = plistId ) else call h5fopen_f ( trim ( fileName ), accessFlag , fileId , error , access_prp = plistId ) endif call h5pclose_f ( plistId , error ) if ( error == - 1 ) then print * , 'Failed to open ' // trim ( fileName ) // '.' stop 1 endif endsubroutine Open_HDF5_parallel subroutine Close_HDF5 ( fileId ) implicit none integer ( HID_T ), intent ( in ) :: fileId ! Local integer :: error call h5fclose_f ( fileId , error ) call h5close_f ( error ) endsubroutine Close_HDF5 subroutine CreateGroup_HDF5 ( fileId , groupName ) #undef __FUNC__ #define __FUNC__ \"CreateGroup_HDF5\" implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: groupName ! Local integer ( HID_T ) :: groupId logical :: groupExists integer :: error call h5lexists_f ( fileId , trim ( groupName ), groupExists , error ) if ( error /= 0 ) then print * , __ FILE__ , \" : Link check failure for \" // trim ( groupName ) else if (. not . groupExists ) then ! Create groups call h5gcreate_f ( fileId , trim ( groupName ), groupId , error ) if ( error /= 0 ) then print * , __ FILE__ , \" :Failed to create group \" // trim ( groupName ) endif call h5gclose_f ( groupId , error ) if ( error /= 0 ) then print * , __ FILE__ , \" :Failed to close group \" // trim ( groupName ) endif endif endif endsubroutine CreateGroup_HDF5 subroutine ReadAttribute_HDF5_int32 ( fileId , attributeName , attribute ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: attributeName integer , intent ( out ) :: attribute ! Local integer ( HID_T ) :: attrId integer ( HID_T ) :: typeId integer ( HSIZE_T ) :: dims ( 1 : 1 ) integer :: error dims ( 1 ) = 1 call h5aopen_f ( fileId , trim ( attributeName ), attrId , error ) call h5aget_type_f ( attrId , typeId , error ) call h5aread_f ( attrId , typeId , attribute , dims , error ) call h5tclose_f ( typeId , error ) call h5aclose_f ( attrId , error ) endsubroutine ReadAttribute_HDF5_int32 subroutine ReadAttribute_HDF5_real ( fileId , attributeName , attribute ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: attributeName real ( prec ), intent ( out ) :: attribute ! Local integer ( HID_T ) :: attrId integer ( HID_T ) :: typeId integer ( HSIZE_T ) :: dims ( 1 : 1 ) integer :: error dims ( 1 ) = 1 call h5aopen_f ( fileId , trim ( attributeName ), attrId , error ) call h5aget_type_f ( attrId , typeId , error ) call h5aread_f ( attrId , typeId , attribute , dims , error ) call h5tclose_f ( typeId , error ) call h5aclose_f ( attrId , error ) endsubroutine ReadAttribute_HDF5_real subroutine ReadAttribute_HDF5_character ( fileId , attributeName , attribute ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: attributeName character ( * ), intent ( out ) :: attribute ! Local integer ( HID_T ) :: attrId integer ( HID_T ) :: typeId integer ( HSIZE_T ) :: dims ( 1 : 1 ) integer :: error dims ( 1 ) = 1 call h5aopen_f ( fileId , trim ( attributeName ), attrId , error ) call h5aget_type_f ( attrId , typeId , error ) call h5aread_f ( attrId , typeId , attribute , dims , error ) call h5tclose_f ( typeId , error ) call h5aclose_f ( attrId , error ) endsubroutine ReadAttribute_HDF5_character subroutine WriteAttribute_HDF5_int32 ( fileId , attributeName , attribute ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: attributeName integer , intent ( in ) :: attribute ! Local integer ( HID_T ) :: aspaceId integer ( HID_T ) :: attrId integer ( HSIZE_T ) :: dims ( 1 : 1 ) integer :: error dims ( 1 ) = 1 call h5screate_f ( H5S_SCALAR_F , aspaceId , error ) call h5acreate_f ( fileId , trim ( attributeName ), H5T_STD_I32LE , & aspaceId , attrId , error ) call h5awrite_f ( attrId , H5T_STD_I32LE , attribute , dims , error ) call h5sclose_f ( aspaceId , error ) call h5aclose_f ( attrId , error ) endsubroutine WriteAttribute_HDF5_int32 subroutine WriteArray_HDF5_real_r1_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 1 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_real_r1_serial subroutine WriteArray_HDF5_real_r2_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 2 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 2 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_real_r2_serial subroutine WriteArray_HDF5_real_r3_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:,:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 3 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 3 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_real_r3_serial subroutine WriteArray_HDF5_real_r4_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:,:,:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 4 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 4 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_real_r4_serial subroutine WriteArray_HDF5_real_r5_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:,:,:,:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 5 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 5 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), HDF5_IO_PREC , memspace , dsetId , error ) call h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_real_r5_serial ! subroutine WriteArray_HDF5_real_r6_serial(fileId,arrayName,hfArray) !   implicit none !   integer(HID_T),intent(in) :: fileId !   character(*),intent(in) :: arrayName !   real(prec),dimension(:,:,:,:,:,:),intent(in) :: hfArray !   ! Local !   integer(HID_T) :: dsetId !   integer(HID_T) :: memspace !   integer(HSIZE_T) :: dims(1:6) !   integer :: error !   dims = shape(hfArray) !   call h5screate_simple_f(6,dims,memspace,error) !   call h5dcreate_f(fileId,trim(arrayName),HDF5_IO_PREC,memspace,dsetId,error) !   call h5dwrite_f(dsetId,HDF5_IO_PREC, & !                   hfArray,dims,error) !   call h5dclose_f(dSetId,error) !   call h5sclose_f(memspace,error) ! endsubroutine WriteArray_HDF5_real_r6_serial subroutine WriteArray_HDF5_int32_r1_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( int32 ), dimension (:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 1 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_int32_r1_serial subroutine WriteArray_HDF5_int32_r2_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( int32 ), dimension (:,:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 2 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 2 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_int32_r2_serial subroutine WriteArray_HDF5_int32_r3_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( int32 ), dimension (:,:,:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 3 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 3 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_int32_r3_serial subroutine WriteArray_HDF5_int32_r4_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( int32 ), dimension (:,:,:,:), intent ( in ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 4 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 4 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) call h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray , dims , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_int32_r4_serial subroutine WriteArray_HDF5_real_r3_parallel ( fileId , arrayName , hfArray , offset , globalDims ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 : 3 ) real ( prec ), dimension (:,:,:), intent ( in ) :: hfArray integer ( HID_T ), intent ( in ) :: globalDims ( 1 : 3 ) ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 3 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 3 , globalDims , filespace , error ) call h5screate_simple_f ( 3 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) call h5sselect_hyperslab_f ( filespace , & H5S_SELECT_SET_F , & offset , & dims , & error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray , dims , error , & mem_space_id = memspace , file_space_id = filespace , xfer_prp = plistId ) if ( error /= 0 ) then print * , 'Failure to write dataset' stop 1 endif call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_real_r3_parallel subroutine WriteArray_HDF5_real_r4_parallel ( fileId , arrayName , hfArray , offset , globalDims ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 : 4 ) real ( prec ), dimension (:,:,:,:), intent ( in ) :: hfArray integer ( HID_T ), intent ( in ) :: globalDims ( 1 : 4 ) ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HSIZE_T ) :: dims ( 1 : 4 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 4 , globalDims , filespace , error ) call h5screate_simple_f ( 4 , dims , memspace , error ) call h5dcreate_f ( fileId , trim ( arrayName ), HDF5_IO_PREC , filespace , dsetId , error ) call h5sselect_hyperslab_f ( filespace , & H5S_SELECT_SET_F , & offset , & dims , & error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dwrite_f ( dsetId , HDF5_IO_PREC , hfArray , dims , error , & mem_space_id = memspace , file_space_id = filespace , xfer_prp = plistId ) if ( error /= 0 ) then print * , 'Failure to write dataset' stop 1 endif call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dSetId , error ) call h5sclose_f ( memspace , error ) endsubroutine WriteArray_HDF5_real_r4_parallel ! subroutine WriteArray_HDF5_int32_r3_parallel(fileId,arrayName,hfArray,offset,globalDims) !   implicit none !   integer(HID_T),intent(in) :: fileId !   character(*),intent(in) :: arrayName !   integer(HID_T),intent(in) :: offset(1:3) !   integer(int32),dimension(:,:,:),intent(in) :: hfArray !   integer(HID_T),intent(in) :: globalDims(1:3) !   ! Local !   integer(HID_T) :: plistId !   integer(HID_T) :: dsetId !   integer(HID_T) :: filespace !   integer(HID_T) :: memspace !   integer(HSIZE_T) :: dims(1:3) !   integer :: error !   dims = shape(hfArray) !   call h5screate_simple_f(3,globalDims,filespace,error) !   call h5screate_simple_f(3,dims,memspace,error) !   call h5dcreate_f(fileId,trim(arrayName),HDF5_IO_PREC,filespace,dsetId,error) !   call h5sselect_hyperslab_f(filespace, & !                              H5S_SELECT_SET_F, & !                              offset, & !                              dims, & !                              error) !   call h5pcreate_f(H5P_DATASET_XFER_F,plistId,error) !   call h5pset_dxpl_mpio_f(plistId,H5FD_MPIO_COLLECTIVE_F,error) !   call h5dwrite_f(dsetId,H5T_STD_I32LE,hfArray,dims,error, & !                   mem_space_id=memspace,file_space_id=filespace,xfer_prp=plistId) !   if(error /= 0) then !     print*,'Failure to write dataset' !     stop 1 !   endif !   call h5pclose_f(plistId,error) !   call h5sclose_f(filespace,error) !   call h5dclose_f(dSetId,error) !   call h5sclose_f(memspace,error) ! endsubroutine WriteArray_HDF5_int32_r3_parallel ! subroutine WriteArray_HDF5_int32_r4_parallel(fileId,arrayName,hfArray,offset,globalDims) !   implicit none !   integer(HID_T),intent(in) :: fileId !   character(*),intent(in) :: arrayName !   integer(HID_T),intent(in) :: offset(1:4) !   integer(int32),dimension(:,:,:,:),intent(in) :: hfArray !   integer(HID_T),intent(in) :: globalDims(1:4) !   ! Local !   integer(HID_T) :: plistId !   integer(HID_T) :: dsetId !   integer(HID_T) :: filespace !   integer(HID_T) :: memspace !   integer(HSIZE_T) :: dims(1:4) !   integer :: error !   dims = shape(hfArray) !   call h5screate_simple_f(4,globalDims,filespace,error) !   call h5screate_simple_f(4,dims,memspace,error) !   call h5dcreate_f(fileId,trim(arrayName),HDF5_IO_PREC,filespace,dsetId,error) !   call h5sselect_hyperslab_f(filespace, & !                              H5S_SELECT_SET_F, & !                              offset, & !                              dims, & !                              error) !   call h5pcreate_f(H5P_DATASET_XFER_F,plistId,error) !   call h5pset_dxpl_mpio_f(plistId,H5FD_MPIO_COLLECTIVE_F,error) !   call h5dwrite_f(dsetId,H5T_STD_I32LE,hfArray,dims,error, & !                   mem_space_id=memspace,file_space_id=filespace,xfer_prp=plistId) !   if(error /= 0) then !     print*,'Failure to write dataset' !     stop 1 !   endif !   call h5pclose_f(plistId,error) !   call h5sclose_f(filespace,error) !   call h5dclose_f(dSetId,error) !   call h5sclose_f(memspace,error) ! endsubroutine WriteArray_HDF5_int32_r4_parallel subroutine WriteCharacter_HDF5_serial ( fileid , name , hfField ) ! adapted from https://forum.hdfgroup.org/t/writing-a-string-array-as-attribute-in-fortran/8503/6 implicit none integer ( HID_T ), intent ( in ) :: fileId character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: hfField ! Local integer ( HID_T ) :: h5_strtype , h5_dspace , h5_dset integer ( HSIZE_T ), dimension ( 2 ) :: size character ( len = len ( hfField ) + 1 ), dimension ( 1 ) :: str_data integer ( SIZE_T ), dimension ( 1 ) :: str_len integer :: error ! string output requires to open a file local = non-parallel str_len ( 1 ) = len_trim ( hfField ) size ( 1 ) = str_len ( 1 ) size ( 2 ) = 1 str_data ( 1 ) = hfField // char ( 0 ) ! create data space call H5Tcopy_f ( H5T_STRING , h5_strtype , error ) call H5Tset_strpad_f ( h5_strtype , H5T_STR_NULLPAD_F , error ) call h5screate_simple_f ( 1 , size ( 2 ), h5_dspace , error ) call h5dcreate_f ( fileid , trim ( name ), h5_strtype , h5_dspace , h5_dset , error ) call h5dwrite_vl_f ( h5_dset , h5_strtype , str_data , size , str_len , error , h5_dspace ) call h5dclose_f ( h5_dset , error ) call h5sclose_f ( h5_dspace , error ) endsubroutine WriteCharacter_HDF5_serial subroutine ReadArray_HDF5_real_r1_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: dims ( 1 ) integer :: error dims = shape ( hfArray ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray , dims , error ) call h5dclose_f ( dsetId , error ) endsubroutine ReadArray_HDF5_real_r1_serial subroutine ReadArray_HDF5_real_r2_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: dims ( 1 : 2 ) integer :: error dims = shape ( hfArray ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray , dims , error ) call h5dclose_f ( dsetId , error ) endsubroutine ReadArray_HDF5_real_r2_serial subroutine ReadArray_HDF5_real_r3_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: dims ( 1 : 3 ) integer :: error dims = shape ( hfArray ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray , dims , error ) call h5dclose_f ( dsetId , error ) endsubroutine ReadArray_HDF5_real_r3_serial subroutine ReadArray_HDF5_real_r4_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:,:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: dims ( 1 : 4 ) integer :: error dims = shape ( hfArray ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray , dims , error ) call h5dclose_f ( dsetId , error ) endsubroutine ReadArray_HDF5_real_r4_serial subroutine ReadArray_HDF5_real_r5_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName real ( prec ), dimension (:,:,:,:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: dims ( 1 : 5 ) integer :: error dims = shape ( hfArray ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dread_f ( dsetId , h5kind_to_type ( prec , H5_REAL_KIND ), hfArray , dims , error ) call h5dclose_f ( dsetId , error ) endsubroutine ReadArray_HDF5_real_r5_serial ! subroutine ReadArray_HDF5_real_r6_serial(fileId,arrayName,hfArray) !   implicit none !   integer(HID_T),intent(in) :: fileId !   character(*),intent(in) :: arrayName !   real(prec),dimension(:,:,:,:,:,:),intent(inout) :: hfArray !   ! Local !   integer(HID_T) :: dsetId !   integer(HID_T) :: dims(1:6) !   integer :: error !   dims = shape(hfArray) !   call h5dopen_f(fileId,arrayName,dsetId,error) !   call h5dread_f(dsetId,h5kind_to_type(prec,H5_REAL_KIND),hfArray,dims,error) !   call h5dclose_f(dsetId,error) ! endsubroutine ReadArray_HDF5_real_r6_serial subroutine ReadArray_HDF5_int32_r1_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( int32 ), dimension (:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: dims ( 1 ) integer :: error dims = shape ( hfArray ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dread_f ( dsetId , h5kind_to_type ( int32 , H5_INTEGER_KIND ), hfArray , dims , error ) call h5dclose_f ( dsetId , error ) endsubroutine ReadArray_HDF5_int32_r1_serial subroutine ReadArray_HDF5_int32_r2_serial ( fileId , arrayName , hfArray ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( int32 ), dimension (:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: dsetId integer ( HID_T ) :: dims ( 1 : 2 ) integer :: error dims = shape ( hfArray ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dread_f ( dsetId , h5kind_to_type ( int32 , H5_INTEGER_KIND ), hfArray , dims , error ) call h5dclose_f ( dsetId , error ) endsubroutine ReadArray_HDF5_int32_r2_serial subroutine ReadArray_HDF5_real_r1_parallel ( fileId , arrayName , hfArray , offset ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 ) real ( prec ), dimension (:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: dtypeId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HID_T ) :: dims ( 1 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 1 , dims , memspace , error ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dget_space_f ( dsetId , filespace , error ) call h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dget_type_f ( dsetId , dtypeId , error ) call h5dread_f ( dsetId , dtypeId , hfArray , dims , & error , memspace , filespace , plistId ) call h5tclose_f ( dtypeId , error ) call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dsetId , error ) call h5sclose_f ( memspace , error ) endsubroutine ReadArray_HDF5_real_r1_parallel subroutine ReadArray_HDF5_real_r2_parallel ( fileId , arrayName , hfArray , offset ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 : 2 ) real ( prec ), dimension (:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: dtypeId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HID_T ) :: dims ( 1 : 2 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 2 , dims , memspace , error ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dget_space_f ( dsetId , filespace , error ) call h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dget_type_f ( dsetId , dtypeId , error ) call h5dread_f ( dsetId , dtypeId , hfArray , dims , & error , memspace , filespace , plistId ) call h5tclose_f ( dtypeId , error ) call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dsetId , error ) call h5sclose_f ( memspace , error ) endsubroutine ReadArray_HDF5_real_r2_parallel subroutine ReadArray_HDF5_real_r3_parallel ( fileId , arrayName , hfArray , offset ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 : 3 ) real ( prec ), dimension (:,:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: dtypeId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HID_T ) :: dims ( 1 : 3 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 3 , dims , memspace , error ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dget_space_f ( dsetId , filespace , error ) call h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dget_type_f ( dsetId , dtypeId , error ) call h5dread_f ( dsetId , dtypeId , hfArray , dims , & error , memspace , filespace , plistId ) call h5tclose_f ( dtypeId , error ) call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dsetId , error ) call h5sclose_f ( memspace , error ) endsubroutine ReadArray_HDF5_real_r3_parallel subroutine ReadArray_HDF5_real_r4_parallel ( fileId , arrayName , hfArray , offset ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 : 4 ) real ( prec ), dimension (:,:,:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: dtypeId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HID_T ) :: dims ( 1 : 4 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 4 , dims , memspace , error ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dget_space_f ( dsetId , filespace , error ) call h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dget_type_f ( dsetId , dtypeId , error ) call h5dread_f ( dsetId , dtypeId , hfArray , dims , & error , memspace , filespace , plistId ) call h5tclose_f ( dtypeId , error ) call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dsetId , error ) call h5sclose_f ( memspace , error ) endsubroutine ReadArray_HDF5_real_r4_parallel ! subroutine ReadArray_HDF5_real_r5_parallel(fileId,arrayName,hfArray,offset) !   implicit none !   integer(HID_T),intent(in) :: fileId !   character(*),intent(in) :: arrayName !   integer(HID_T),intent(in) :: offset(1:5) !   real(prec),dimension(:,:,:,:,:),intent(inout) :: hfArray !   ! Local !   integer(HID_T) :: plistId !   integer(HID_T) :: dsetId !   integer(HID_T) :: dtypeId !   integer(HID_T) :: filespace !   integer(HID_T) :: memspace !   integer(HID_T) :: dims(1:5) !   integer :: error !   dims = shape(hfArray) !   call h5screate_simple_f(5,dims,memspace,error) !   call h5dopen_f(fileId,arrayName,dsetId,error) !   call h5dget_space_f(dsetId,filespace,error) !   call h5sselect_hyperslab_f(filespace,H5S_SELECT_SET_F,offset,dims,error) !   call h5pcreate_f(H5P_DATASET_XFER_F,plistId,error) !   call h5pset_dxpl_mpio_f(plistId,H5FD_MPIO_COLLECTIVE_F,error) !   call h5dget_type_f(dsetId,dtypeId,error) !   call h5dread_f(dsetId,dtypeId,hfArray,dims, & !                  error,memspace,filespace,plistId) !   call h5tclose_f(dtypeId,error) !   call h5pclose_f(plistId,error) !   call h5sclose_f(filespace,error) !   call h5dclose_f(dsetId,error) !   call h5sclose_f(memspace,error) ! endsubroutine ReadArray_HDF5_real_r5_parallel ! subroutine ReadArray_HDF5_real_r6_parallel(fileId,arrayName,hfArray,offset) !   implicit none !   integer(HID_T),intent(in) :: fileId !   character(*),intent(in) :: arrayName !   integer(HID_T),intent(in) :: offset(1:6) !   real(prec),dimension(:,:,:,:,:,:),intent(inout) :: hfArray !   ! Local !   integer(HID_T) :: plistId !   integer(HID_T) :: dsetId !   integer(HID_T) :: dtypeId !   integer(HID_T) :: filespace !   integer(HID_T) :: memspace !   integer(HID_T) :: dims(1:6) !   integer :: error !   dims = shape(hfArray) !   call h5screate_simple_f(6,dims,memspace,error) !   call h5dopen_f(fileId,arrayName,dsetId,error) !   call h5dget_space_f(dsetId,filespace,error) !   call h5sselect_hyperslab_f(filespace,H5S_SELECT_SET_F,offset,dims,error) !   call h5pcreate_f(H5P_DATASET_XFER_F,plistId,error) !   call h5pset_dxpl_mpio_f(plistId,H5FD_MPIO_COLLECTIVE_F,error) !   call h5dget_type_f(dsetId,dtypeId,error) !   call h5dread_f(dsetId,dtypeId,hfArray,dims, & !                  error,memspace,filespace,plistId) !   call h5tclose_f(dtypeId,error) !   call h5pclose_f(plistId,error) !   call h5sclose_f(filespace,error) !   call h5dclose_f(dsetId,error) !   call h5sclose_f(memspace,error) ! endsubroutine ReadArray_HDF5_real_r6_parallel subroutine ReadArray_HDF5_int32_r1_parallel ( fileId , arrayName , hfArray , offset ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 ) integer ( int32 ), dimension (:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: dtypeId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HID_T ) :: dims ( 1 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 1 , dims , memspace , error ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dget_space_f ( dsetId , filespace , error ) call h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dget_type_f ( dsetId , dtypeId , error ) call h5dread_f ( dsetId , dtypeId , hfArray , dims , & error , memspace , filespace , plistId ) call h5tclose_f ( dtypeId , error ) call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dsetId , error ) call h5sclose_f ( memspace , error ) endsubroutine ReadArray_HDF5_int32_r1_parallel subroutine ReadArray_HDF5_int32_r2_parallel ( fileId , arrayName , hfArray , offset ) implicit none integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: arrayName integer ( HID_T ), intent ( in ) :: offset ( 1 : 2 ) integer ( int32 ), dimension (:,:), intent ( inout ) :: hfArray ! Local integer ( HID_T ) :: plistId integer ( HID_T ) :: dsetId integer ( HID_T ) :: dtypeId integer ( HID_T ) :: filespace integer ( HID_T ) :: memspace integer ( HID_T ) :: dims ( 1 : 2 ) integer :: error dims = shape ( hfArray ) call h5screate_simple_f ( 2 , dims , memspace , error ) call h5dopen_f ( fileId , arrayName , dsetId , error ) call h5dget_space_f ( dsetId , filespace , error ) call h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) call h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) call h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) call h5dget_type_f ( dsetId , dtypeId , error ) call h5dread_f ( dsetId , dtypeId , hfArray , dims , & error , memspace , filespace , plistId ) call h5tclose_f ( dtypeId , error ) call h5pclose_f ( plistId , error ) call h5sclose_f ( filespace , error ) call h5dclose_f ( dsetId , error ) call h5sclose_f ( memspace , error ) endsubroutine ReadArray_HDF5_int32_r2_parallel endmodule SELF_HDF5","tags":"","loc":"sourcefile/self_hdf5.f90.html"},{"title":"SELF_Vector_2D_t.f90 – SELF","text":"Contents Modules SELF_Vector_2D_t Source Code SELF_Vector_2D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Vector_2D_t use SELF_Constants use SELF_Lagrange use SELF_Metadata use FEQParse use SELF_HDF5 use SELF_Data use HDF5 use iso_c_binding implicit none type , extends ( SELF_DataObj ), public :: Vector2D_t real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: interior real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: boundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: extBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: avgBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:) :: boundaryNormal contains procedure , public :: Init => Init_Vector2D_t procedure , public :: Free => Free_Vector2D_t procedure , public :: UpdateHost => UpdateHost_Vector2D_t procedure , public :: UpdateDevice => UpdateDevice_Vector2D_t procedure , public :: BoundaryInterp => BoundaryInterp_Vector2D_t procedure , public :: AverageSides => AverageSides_Vector2D_t generic , public :: GridInterp => GridInterp_Vector2D_t procedure , private :: GridInterp_Vector2D_t generic , public :: Gradient => Gradient_Vector2D_t procedure , private :: Gradient_Vector2D_t generic , public :: Divergence => Divergence_Vector2D_t procedure , private :: Divergence_Vector2D_t generic , public :: SetEquation => SetEquation_Vector2D_t procedure , private :: SetEquation_Vector2D_t generic , public :: WriteHDF5 => WriteHDF5_MPI_Vector2D_t , WriteHDF5_Vector2D_t procedure , private :: WriteHDF5_MPI_Vector2D_t procedure , private :: WriteHDF5_Vector2D_t endtype Vector2D_t contains subroutine Init_Vector2D_t ( this , interp , nVar , nElem ) implicit none class ( Vector2D_t ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % boundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % boundaryNormal ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 2 * nVar )) ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 2 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo this % interior = 0.0_prec this % boundary = 0.0_prec this % boundarynormal = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec endsubroutine Init_Vector2D_t subroutine Free_Vector2D_t ( this ) implicit none class ( Vector2D_t ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % boundaryNormal ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) endsubroutine Free_Vector2D_t subroutine UpdateHost_Vector2D_t ( this ) implicit none class ( Vector2D_t ), intent ( inout ) :: this endsubroutine UpdateHost_Vector2D_t subroutine UpdateDevice_Vector2D_t ( this ) implicit none class ( Vector2D_t ), intent ( inout ) :: this endsubroutine UpdateDevice_Vector2D_t subroutine SetEquation_Vector2D_t ( this , idir , ivar , eqnChar ) !! Sets the equation parser for the `idir` direction and `ivar-th` variable implicit none class ( Vector2D_t ), intent ( inout ) :: this integer , intent ( in ) :: idir , ivar character ( * ), intent ( in ) :: eqnChar this % eqn ( idir + 2 * ( ivar - 1 )) = EquationParser ( trim ( eqnChar ), & ( / 'x' , 'y' , 'z' , 't' / )) endsubroutine SetEquation_Vector2D_t subroutine GridInterp_Vector2D_t ( this , f ) implicit none class ( Vector2D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: f ( 1 : this % M + 1 , 1 : this % M + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 2 ) ! Local integer :: i , j , ii , jj , iel , ivar , idir real ( prec ) :: fi , fij do concurrent ( i = 1 : this % M + 1 , j = 1 : this % M + 1 , iel = 1 : this % nElem , & ivar = 1 : this % nVar , idir = 1 : 2 ) fij = 0.0_prec do jj = 1 , this % N + 1 fi = 0.0_prec do ii = 1 , this % N + 1 fi = fi + this % interior ( ii , jj , iel , ivar , idir ) * this % interp % iMatrix ( ii , i ) enddo fij = fij + fi * this % interp % iMatrix ( jj , j ) enddo f ( i , j , iel , ivar , idir ) = fij enddo endsubroutine GridInterp_Vector2D_t subroutine AverageSides_Vector2D_t ( this ) implicit none class ( Vector2D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: iside integer :: ivar integer :: i integer :: idir do concurrent ( i = 1 : this % interp % N + 1 , iside = 1 : 4 , iel = 1 : this % nElem , & ivar = 1 : this % nVar , idir = 1 : 2 ) this % avgboundary ( i , iside , iel , ivar , idir ) = 0.5_prec * ( & this % boundary ( i , iside , iel , ivar , idir ) + & this % extBoundary ( i , iside , iel , ivar , idir )) enddo endsubroutine AverageSides_Vector2D_t subroutine BoundaryInterp_Vector2D_t ( this ) implicit none class ( Vector2D_t ), intent ( inout ) :: this ! Local integer :: i , ii , idir , iel , ivar real ( prec ) :: fbs , fbe , fbn , fbw do concurrent ( i = 1 : this % N + 1 , iel = 1 : this % nelem , & ivar = 1 : this % nvar , idir = 1 : 2 ) fbs = 0.0_prec fbe = 0.0_prec fbn = 0.0_prec fbw = 0.0_prec do ii = 1 , this % N + 1 fbs = fbs + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , ii , iel , ivar , idir ) ! South fbe = fbe + this % interp % bMatrix ( ii , 2 ) * this % interior ( ii , i , iel , ivar , idir ) ! East fbn = fbn + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , ii , iel , ivar , idir ) ! North fbw = fbw + this % interp % bMatrix ( ii , 1 ) * this % interior ( ii , i , iel , ivar , idir ) ! West enddo this % boundary ( i , 1 , iel , ivar , idir ) = fbs this % boundary ( i , 2 , iel , ivar , idir ) = fbe this % boundary ( i , 3 , iel , ivar , idir ) = fbn this % boundary ( i , 4 , iel , ivar , idir ) = fbw enddo endsubroutine BoundaryInterp_Vector2D_t subroutine Gradient_Vector2D_t ( this , df ) implicit none class ( Vector2D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 2 , 1 : 2 ) ! Local integer :: i , j , ii , iEl , iVar , idir real ( prec ) :: dfds1 , dfds2 do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , & ivar = 1 : this % nVar , idir = 1 : 2 ) dfds1 = 0.0_prec dfds2 = 0.0_prec do ii = 1 , this % N + 1 dfds1 = dfds1 + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , iel , ivar , idir ) dfds2 = dfds2 + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , iel , ivar , idir ) enddo df ( i , j , iel , ivar , idir , 1 ) = dfds1 df ( i , j , iel , ivar , idir , 2 ) = dfds2 enddo endsubroutine Gradient_Vector2D_t subroutine Divergence_Vector2D_t ( this , df ) implicit none class ( Vector2D_t ), intent ( in ) :: this real ( prec ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: i , j , ii , iel , ivar real ( prec ) :: dfLoc do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 dfLoc = dfLoc + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , iel , ivar , 1 ) enddo dF ( i , j , iel , ivar ) = dfLoc enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 dfLoc = dfLoc + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , iel , ivar , 2 ) enddo dF ( i , j , iel , ivar ) = dF ( i , j , iel , ivar ) + dfLoc enddo endsubroutine Divergence_Vector2D_t subroutine WriteHDF5_MPI_Vector2D_t ( this , fileId , group , elemoffset , nglobalelem ) implicit none class ( Vector2D_t ), intent ( in ) :: this character ( * ), intent ( in ) :: group integer ( HID_T ), intent ( in ) :: fileId integer , intent ( in ) :: elemoffset integer , intent ( in ) :: nglobalelem ! Local integer ( HID_T ) :: offset ( 1 : 3 ) integer ( HID_T ) :: globalDims ( 1 : 3 ) integer :: ivar , idir character ( 4 ) :: dimvar offset ( 1 : 3 ) = ( / 0 , 0 , elemoffset / ) globalDims ( 1 : 3 ) = ( / this % interp % N + 1 , & this % interp % N + 1 , & nglobalelem / ) call CreateGroup_HDF5 ( fileId , trim ( group )) do idir = 1 , 2 write ( dimvar , '(I1)' ) idir dimvar = \"dim\" // trim ( dimvar ) do ivar = 1 , this % nVar !call this%meta(ivar)%WriteHDF5(group,ivar,fileId) call WriteArray_HDF5 ( fileId , & trim ( group ) // \"/\" // trim ( this % meta ( ivar )% name ) // \"_\" // dimvar , & this % interior (:,:,:, ivar , idir ), offset , globalDims ) enddo enddo endsubroutine WriteHDF5_MPI_Vector2D_t subroutine WriteHDF5_Vector2D_t ( this , fileId , group ) implicit none class ( Vector2D_t ), intent ( in ) :: this integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: group ! Local integer :: ivar , idir character ( 4 ) :: dimvar call CreateGroup_HDF5 ( fileId , trim ( group )) do ivar = 1 , this % nVar call this % meta ( ivar )% WriteHDF5 ( group , ivar , fileId ) enddo do idir = 1 , 2 write ( dimvar , '(I1)' ) idir dimvar = \"dim\" // trim ( dimvar ) do ivar = 1 , this % nVar call WriteArray_HDF5 ( fileId , & trim ( group ) // \"/\" // trim ( this % meta ( ivar )% name ) // \"_\" // dimvar , & this % interior (:,:,:, ivar , idir )) enddo enddo endsubroutine WriteHDF5_Vector2D_t endmodule SELF_Vector_2D_t","tags":"","loc":"sourcefile/self_vector_2d_t.f90.html"},{"title":"SELF_NullDGModel2D_t.f90 – SELF","text":"Contents Modules self_NullDGModel2D_t Source Code SELF_NullDGModel2D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUsLESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARIsLG IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_NullDGModel2D_t use self_model use self_dgmodel2d use self_mesh implicit none type , extends ( dgmodel2d ) :: NullDGModel2D_t ! Add any additional attributes here that are specific to your model contains !   procedure :: hbc2d_Prescribed => hbc2d_Generic_Model !   procedure :: hbc2d_Radiation => hbc2d_Generic_Model !   procedure :: hbc2d_NoNormalFlow => hbc2d_Generic_Model !   procedure :: pbc2d_Prescribed => pbc2d_Generic_Model !   procedure :: pbc2d_Radiation => pbc2d_Generic_Model !   procedure :: pbc2d_NoNormalFlow => pbc2d_Generic_Model !   procedure :: SetMetadata => SetMetadata_NullDGModel2D_t !   procedure :: pretendency => pretendency_NullDGModel2D_t !   procedure :: entropy_func => entropy_func_NullDGModel2D_t !   procedure :: flux2d => flux2d_NullDGModel2D_t !   procedure :: riemannflux2d => riemannflux2d_NullDGModel2D_t !   procedure :: source2d => source2d_NullDGModel2D_t endtype NullDGModel2D_t contains ! subroutine SetMetadata_NullDGModel2D_t(this) !   implicit none !   class(NullDGModel2D_t),intent(inout) :: this !   ! Local !   integer :: ivar !   character(LEN=3) :: ivarChar !   character(LEN=25) :: varname !   do ivar = 1,this%nvar !     write(ivarChar,'(I3.3)') ivar !     varname = \"solution\"//trim(ivarChar) !     call this%solution%SetName(ivar,varname) !     call this%solution%SetUnits(ivar,\"[null]\") !   enddo ! endsubroutine SetMetadata_NullDGModel2D_t !   pure function bcGeneric_NullDGModel2D_t(this,s) result(exts) !   class(NullDGModel2D_t),intent(in) :: this !   real(prec),intent(in) :: s(1:this%nvar) !   real(prec) :: exts(1:this%nvar) !   ! Local !   integer :: ivar !   do ivar = 1,this%nvar !     exts(ivar) = 0.0_prec !   enddo ! endfunction bcGeneric_NullDGModel2D_t ! pure function pbc2dGeneric_NullDGModel2D_t(this,dsdx) result(extDsdx) !   class(NullDGModel2D_t),intent(in) :: this !   real(prec),intent(in) :: dsdx(1:this%nvar,1:2) !   real(prec) :: extDsdx(1:this%nvar,1:2) !   ! Local !   integer :: ivar !   do ivar = 1,this%nvar !     extDsdx(ivar,1:2) = dsdx(ivar,1:2) !   enddo ! endfunction pbc2dGeneric_NullDGModel2D_t ! pure function entropy_func_NullDGModel2D_t(this,s) result(e) !   class(NullDGModel2D_t),intent(in) :: this !   real(prec),intent(in) :: s(1:this%solution%nvar) !   real(prec) :: e !   e = 0.0_prec ! endfunction entropy_func_NullDGModel2D_t ! pure function flux2d_NullDGModel2D_t(this,s,dsdx) result(flux) !   class(NullDGModel2D_t),intent(in) :: this !   real(prec),intent(in) :: s(1:this%solution%nvar) !   real(prec),intent(in) :: dsdx(1:this%solution%nvar,1:2) !   real(prec) :: flux(1:this%solution%nvar,1:2) !   flux(1:this%nvar,1:2) = 0.0_prec ! endfunction flux2d_NullDGModel2D_t ! pure function riemannflux2d_NullDGModel2D_t(this,sL,sR,dsdx,nhat) result(flux) !   class(NullDGModel2D_t),intent(in) :: this !   real(prec),intent(in) :: sL(1:this%solution%nvar) !   real(prec),intent(in) :: sR(1:this%solution%nvar) !   real(prec),intent(in) :: dsdx(1:this%solution%nvar,1:2) !   real(prec),intent(in) :: nhat(1:2) !   real(prec) :: flux(1:this%solution%nvar) !   flux(1:this%nvar) = 0.0_prec ! endfunction riemannflux2d_NullDGModel2D_t ! subroutine PreTendency_NulDGModel2D_t(this) ! !! PreTendency is a template routine that is used to house any additional calculations ! !! that you want to execute at the beginning of the tendency calculation routine. ! !! This default PreTendency simply returns back to the caller without executing any instructions ! !! ! !! The intention is to provide a method that can be overridden through type-extension, to handle ! !! any steps that need to be executed before proceeding with the usual tendency calculation methods. ! !! !   implicit none !   class(Model),intent(inout) :: this !   return ! endsubroutine PreTendency_NulDGModel2D_t ! pure function source2d_NullDGModel2D_t(this,s,dsdx) result(source) !   class(NullDGModel2D_t),intent(in) :: this !   real(prec),intent(in) :: s(1:this%solution%nvar) !   real(prec),intent(in) :: dsdx(1:this%solution%nvar,1:2) !   real(prec) :: source(1:this%solution%nvar) !   source(1:this%nvar) = 0.0_prec ! endfunction source2d_NullDGModel2D_t endmodule self_NullDGModel2D_t","tags":"","loc":"sourcefile/self_nulldgmodel2d_t.f90.html"},{"title":"SELF_Burgers1D_t.f90 – SELF","text":"Contents Modules self_Burgers1D_t Source Code SELF_Burgers1D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUsLESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARIsLG IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_Burgers1D_t use self_model use self_dgmodel1d use self_mesh implicit none type , extends ( dgmodel1d ) :: Burgers1D_t ! Add any additional attributes here that are specific to your model real ( prec ) :: nu = 0.0_prec ! Diffusivity/viscosity contains procedure :: SetMetadata => SetMetadata_Burgers1D_t procedure :: entropy_func => entropy_func_Burgers1D_t procedure :: flux1d => flux1d_Burgers1D_t procedure :: riemannflux1d => riemannflux1d_Burgers1D_t endtype Burgers1D_t contains subroutine SetMetadata_Burgers1D_t ( this ) implicit none class ( Burgers1D_t ), intent ( inout ) :: this call this % solution % SetName ( 1 , \"s\" ) call this % solution % SetUnits ( 1 , \"[null]\" ) endsubroutine SetMetadata_Burgers1D_t pure function entropy_func_Burgers1D_t ( this , s ) result ( e ) class ( Burgers1D_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ) :: e e = 0.5_prec * s ( 1 ) * s ( 1 ) endfunction entropy_func_Burgers1D_t pure function flux1d_Burgers1D_t ( this , s , dsdx ) result ( flux ) class ( Burgers1D_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % solution % nvar ) real ( prec ) :: flux ( 1 : this % solution % nvar ) flux ( 1 ) = 0.5_prec * s ( 1 ) * s ( 1 ) - this % nu * dsdx ( 1 ) endfunction flux1d_Burgers1D_t pure function riemannflux1d_Burgers1D_t ( this , sL , sR , dsdx , nhat ) result ( flux ) class ( Burgers1D_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: sL ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: sR ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: nhat real ( prec ) :: flux ( 1 : this % solution % nvar ) ! Local real ( prec ) :: fL , fR , cmax ! Local Lax-Friedrich's flux fL = 0.5_prec * sL ( 1 ) * sL ( 1 ) * nhat fR = 0.5_prec * sR ( 1 ) * sR ( 1 ) * nhat cmax = max ( abs ( sL ( 1 ) * nhat ), abs ( sR ( 1 ) * nhat )) ! maximum wave speed flux ( 1 ) = 0.5_prec * ( fL + fR ) + cmax * ( sL ( 1 ) - sR ( 1 )) & ! advective flux - this % nu * dsdx ( 1 ) * nhat endfunction riemannflux1d_Burgers1D_t endmodule self_Burgers1D_t","tags":"","loc":"sourcefile/self_burgers1d_t.f90.html"},{"title":"SELF_Mesh.f90 – SELF","text":"Contents Modules SELF_Mesh Source Code SELF_Mesh.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Mesh use SELF_Constants use SELF_DomainDecomposition use iso_c_binding implicit none #include \"SELF_Macros.h\" type :: SEMMesh integer :: nGeo integer :: nElem integer :: nGlobalElem integer :: nNodes integer :: nSides integer :: nCornerNodes integer :: nUniqueNodes integer :: nUniqueSides integer :: nBCs integer :: quadrature type ( DomainDecomposition ) :: decomp endtype SEMMesh ! Element Types - From Table 4.1 of https://www.hopr-project.org/externals/Meshformat.pdf integer , parameter :: selfLineLinear = 1 integer , parameter :: selfLineNonlinear = 2 integer , parameter :: selfTriangleLinear = 3 integer , parameter :: selfQuadLinear = 4 integer , parameter :: selfQuadBilinear = 14 integer , parameter :: selfTriangleNonlinear = 23 integer , parameter :: selfQuadNonlinear = 24 integer , parameter :: selfTetrahedronLinear = 104 integer , parameter :: selfPyramidLinear = 105 integer , parameter :: selfPrismLinear = 106 integer , parameter :: selfHexahedronLinear = 108 integer , parameter :: selfPyramidBilinear = 115 integer , parameter :: selfPrismBilinear = 116 integer , parameter :: selfHexahedronBilinear = 118 integer , parameter :: selfTetrahedronNonlinear = 204 integer , parameter :: selfPyramidNonlinear = 205 integer , parameter :: selfPrismNonlinear = 206 integer , parameter :: selfHexahedronNonlinear = 208 integer , parameter :: self_BCDefault = 1 integer , parameter :: self_nBCsDefault = 5 !==============================================! ! --------------- File Types------------------ ! !==============================================! integer , parameter :: SELF_MESH_ISM_V2_2D = 1 integer , parameter :: SELF_MESH_ISM_V2_3D = 2 integer , parameter :: SELF_MESH_HOPR_2D = 3 integer , parameter :: SELF_MESH_HOPR_3D = 4 ! //////////////////////////////////////////////// ! !   Boundary Condition parameters ! ! Conditions on the solution integer , parameter :: SELF_BC_PRESCRIBED = 100 integer , parameter :: SELF_BC_RADIATION = 101 integer , parameter :: SELF_BC_NONORMALFLOW = 102 ! Conditions on the solution gradients integer , parameter :: SELF_BC_PRESCRIBED_STRESS = 200 integer , parameter :: SELF_BC_NOSTRESS = 201 endmodule SELF_Mesh","tags":"","loc":"sourcefile/self_mesh.f90.html"},{"title":"SELF_Lagrange_t.f90 – SELF","text":"Contents Modules SELF_Lagrange_t Source Code SELF_Lagrange_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Lagrange_t use iso_fortran_env use iso_c_binding use SELF_Constants use SELF_SupportRoutines use SELF_Quadrature use SELF_HDF5 use HDF5 use iso_c_binding implicit none type , public :: Lagrange_t !! A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions. !! The Lagrange data-structure stores the information necessary to interpolate between two !! sets of grid-points and to estimate the derivative of data at native grid points. Routines for !! multidimensional interpolation are based on the tensor product of 1-D interpolants. It is !! assumed that the polynomial degree (and the interpolation nodes) are the same in each direction. !! This assumption permits the storage of only one array of interpolation nodes and barycentric !! weights and is what allows this data structure to be flexible. integer :: N !! The number of control points. integer :: controlNodeType integer :: M !! The number of target points. integer :: targetNodeType type ( c_ptr ) :: blas_handle = c_null_ptr !! A handle for working with hipblas real ( prec ), pointer , contiguous , dimension (:) :: controlPoints !! The set of nodes in one dimension where data is known. !! To create higher dimension interpolation and differentiation operators, structured grids in two and three !! dimensions are created by tensor products of the controlPoints. This design decision implies that all !! spectral element methods supported by the Lagrange class have the same polynomial degree in each !! computational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto, !! Legendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over !! the domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of !! these quadrature types or uniform points on [-1,1]. real ( prec ), pointer , contiguous , dimension (:) :: targetPoints !! The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation !! and differentiation operators, structured grids in two and three dimensions are created by tensor products of !! the targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1] !! (computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. real ( prec ), pointer , contiguous , dimension (:) :: bWeights !! The barycentric weights that are calculated from the controlPoints and used for interpolation. real ( prec ), pointer , contiguous , dimension (:) :: qWeights !! The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints !! provided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss, !! Chebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant !! dx = \\frac{2.0}{N+1}. real ( prec ), pointer , contiguous , dimension (:,:) :: iMatrix !! The interpolation matrix (transpose) for mapping data from the control grid to the target grid. real ( prec ), pointer , contiguous , dimension (:,:) :: dMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The !! dMatrix is based on a strong form of the derivative. real ( prec ), pointer , contiguous , dimension (:,:) :: dgMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based !! on a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. real ( prec ), pointer , contiguous , dimension (:,:) :: bMatrix !! The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. contains procedure , public :: Init => Init_Lagrange_t procedure , public :: Free => Free_Lagrange_t procedure , public :: WriteHDF5 => WriteHDF5_Lagrange_t procedure , public :: CalculateBarycentricWeights procedure , public :: CalculateInterpolationMatrix procedure , public :: CalculateDerivativeMatrix procedure , public :: CalculateLagrangePolynomials endtype Lagrange_t contains subroutine Init_Lagrange_t ( this , N , controlNodeType , M , targetNodeType ) !! Initialize an instance of the Lagrange_t class !! On output, all of the attributes for the Lagrange_t class are allocated and values are initialized according to the number of !! control points, number of target points, and the types for the control and target nodes. !! If a GPU is available, device pointers for the Lagrange_t attributes are allocated and initialized. implicit none class ( Lagrange_t ), intent ( out ) :: this !! Lagrange_t class instance integer , intent ( in ) :: N !! The number of control points for interpolant integer , intent ( in ) :: M !! The number of target points for the interpolant integer , intent ( in ) :: controlNodeType !! The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) integer , intent ( in ) :: targetNodeType !! The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) ! -------! ! Local real ( prec ) :: q ( 0 : M ) this % N = N this % M = M this % controlNodeType = controlNodeType this % targetNodeType = targetNodeType allocate ( this % controlPoints ( 1 : N + 1 ), & this % targetPoints ( 1 : M + 1 ), & this % bWeights ( 1 : N + 1 ), & this % qWeights ( 1 : N + 1 ), & this % iMatrix ( 1 : N + 1 , 1 : M + 1 ), & this % dMatrix ( 1 : N + 1 , 1 : N + 1 ), & this % dgMatrix ( 1 : N + 1 , 1 : N + 1 ), & this % bMatrix ( 1 : N + 1 , 1 : 2 )) if ( controlNodeType == GAUSS . or . controlNodeType == GAUSS_LOBATTO ) then call LegendreQuadrature ( N , & this % controlPoints , & this % qWeights , & controlNodeType ) elseif ( controlNodeType == CHEBYSHEV_GAUSS . or . controlNodeType == CHEBYSHEV_GAUSS_LOBATTO ) then call ChebyshevQuadrature ( N , & this % controlPoints , & this % qWeights , & controlNodeType ) elseif ( controlNodeType == UNIFORM ) then this % controlPoints = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , N ) this % qWeights = 2.0_prec / real ( N , prec ) endif ! Target Points if ( targetNodeType == GAUSS . or . targetNodeType == GAUSS_LOBATTO ) then call LegendreQuadrature ( M , & this % targetPoints , & q , & targetNodeType ) elseif ( targetNodeType == UNIFORM ) then this % targetPoints = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , M ) endif call this % CalculateBarycentricWeights () call this % CalculateInterpolationMatrix () call this % CalculateDerivativeMatrix () this % bMatrix ( 1 : N + 1 , 1 ) = this % CalculateLagrangePolynomials ( - 1.0_prec ) this % bMatrix ( 1 : N + 1 , 2 ) = this % CalculateLagrangePolynomials ( 1.0_prec ) endsubroutine Init_Lagrange_t subroutine Free_Lagrange_t ( this ) !! Frees all memory (host and device) associated with an instance of the Lagrange_t class implicit none class ( Lagrange_t ), intent ( inout ) :: this !! Lagrange_t class instance deallocate ( this % controlPoints ) deallocate ( this % targetPoints ) deallocate ( this % bWeights ) deallocate ( this % qWeights ) deallocate ( this % iMatrix ) deallocate ( this % dMatrix ) deallocate ( this % dgMatrix ) deallocate ( this % bMatrix ) endsubroutine Free_Lagrange_t ! ================================================================================================ ! ! ! CalculateBarycentricWeights (PRIVATE) ! !   A PRIVATE routine that calculates and stores the barycentric weights for the Lagrange_t !   data-structure. ! !   This routine is from Alg. 30 on pg. 75 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! subroutine CalculateBarycentricWeights ( this ) implicit none class ( Lagrange_t ), intent ( inout ) :: this ! Local integer :: i , j real ( real64 ) :: bWeights ( 0 : this % N ) real ( real64 ) :: controlPoints ( 0 : this % N ) do i = 0 , this % N bWeights ( i ) = 1.0_real64 controlPoints ( i ) = real ( this % controlPoints ( i + 1 ), real64 ) enddo ! Computes the product w_k = w_k*(s_k - s_j), k /= j do j = 1 , this % N do i = 0 , j - 1 bWeights ( i ) = bWeights ( i ) * ( controlPoints ( i ) - controlPoints ( j )) bWeights ( j ) = bWeights ( j ) * ( controlPoints ( j ) - controlPoints ( i )) enddo enddo do j = 0 , this % N bWeights ( j ) = 1.0_prec / bWeights ( j ) this % bWeights ( j + 1 ) = real ( bWeights ( j ), prec ) enddo endsubroutine CalculateBarycentricWeights ! ================================================================================================ ! ! ! CalculateInterpolationMatrix (PRIVATE) ! !   A PRIVATE routine that fills in the interpolation matrix for the Lagrange_t data structure. ! !   This function is from Alg. 32 on pg. 76 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! subroutine CalculateInterpolationMatrix ( this ) implicit none class ( Lagrange_t ), intent ( inout ) :: this ! Local integer :: row , col logical :: rowHasMatch real ( real64 ) :: temp1 , temp2 real ( real64 ) :: iMatrix ( 0 : this % M , 0 : this % N ) real ( real64 ) :: bWeights ( 0 : this % N ) real ( real64 ) :: controlPoints ( 0 : this % N ) real ( real64 ) :: targetPoints ( 0 : this % M ) do col = 0 , this % N controlPoints ( col ) = real ( this % controlPoints ( col + 1 ), real64 ) bWeights ( col ) = real ( this % bWeights ( col + 1 ), real64 ) enddo do row = 0 , this % M targetPoints ( row ) = real ( this % targetPoints ( row + 1 ), real64 ) enddo do row = 0 , this % M rowHasMatch = . false . do col = 0 , this % N iMatrix ( row , col ) = 0.0_real64 if ( AlmostEqual ( targetPoints ( row ), controlPoints ( col ))) then rowHasMatch = . true . iMatrix ( row , col ) = 1.0_real64 endif enddo if (. not .( rowHasMatch )) then temp1 = 0.0_real64 do col = 0 , this % N temp2 = bWeights ( col ) / & ( targetPoints ( row ) - & controlPoints ( col )) iMatrix ( row , col ) = temp2 temp1 = temp1 + temp2 enddo do col = 0 , this % N iMatrix ( row , col ) = iMatrix ( row , col ) / temp1 enddo endif enddo do row = 0 , this % M do col = 0 , this % N this % iMatrix ( col + 1 , row + 1 ) = real ( iMatrix ( row , col ), prec ) enddo enddo endsubroutine CalculateInterpolationMatrix ! ================================================================================================ ! ! ! CalculateDerivativeMatrix (PRIVATE) ! !   Calculates and stores the derivative matrix and its transpose. !   Generates a matrix that can be used to approximate derivatives at the interpolation nodes. ! !   This function is from Alg. 37 on pg. 82 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! subroutine CalculateDerivativeMatrix ( this ) implicit none class ( Lagrange_t ), intent ( inout ) :: this ! Local integer :: row , col real ( real64 ) :: dmat ( 0 : this % N , 0 : this % N ) real ( real64 ) :: dgmat ( 0 : this % N , 0 : this % N ) real ( real64 ) :: bWeights ( 0 : this % N ) real ( real64 ) :: qWeights ( 0 : this % N ) real ( real64 ) :: controlPoints ( 0 : this % N ) do row = 0 , this % N bWeights ( row ) = real ( this % bWeights ( row + 1 ), real64 ) qWeights ( row ) = real ( this % qWeights ( row + 1 ), real64 ) controlPoints ( row ) = real ( this % controlPoints ( row + 1 ), real64 ) enddo do row = 0 , this % N dmat ( row , row ) = 0.0_prec do col = 0 , this % N if (. not .( col == row )) then dmat ( row , col ) = bWeights ( col ) / & ( bWeights ( row ) * & ( controlPoints ( row ) - & controlPoints ( col ))) dmat ( row , row ) = dmat ( row , row ) - dmat ( row , col ) endif enddo enddo do row = 0 , this % N do col = 0 , this % N dgmat ( row , col ) = - dmat ( col , row ) * & qWeights ( col ) / & qWeights ( row ) enddo enddo do row = 0 , this % N do col = 0 , this % N this % dMatrix ( row + 1 , col + 1 ) = real ( dmat ( col , row ), prec ) this % dgMatrix ( row + 1 , col + 1 ) = real ( dgmat ( col , row ), prec ) enddo enddo endsubroutine CalculateDerivativeMatrix ! ================================================================================================ ! ! ! CalculateLagrangePolynomials ! !   Evaluates each of the 1-D Lagrange interpolating polynomials at a specified point. ! !   This function is from Alg. 34 on pg. 77 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! function CalculateLagrangePolynomials ( this , sE ) result ( lAtS ) implicit none class ( Lagrange_t ) :: this real ( prec ) :: sE real ( prec ) :: lAtS ( 0 : this % N ) ! Local integer :: j logical :: xMatchesNode real ( real64 ) :: temp1 , temp2 real ( real64 ) :: sELocal real ( real64 ) :: controlPoints ( 0 : this % N ) real ( real64 ) :: bWeights ( 0 : this % N ) real ( real64 ) :: lS ( 0 : this % N ) sELocal = real ( sE , real64 ) do j = 0 , this % N controlPoints ( j ) = real ( this % controlPoints ( j + 1 ), real64 ) bWeights ( j ) = real ( this % bWeights ( j + 1 ), real64 ) enddo xMatchesNode = . false . do j = 0 , this % N lS ( j ) = 0.0_real64 if ( AlmostEqual ( sELocal , controlPoints ( j ))) then lS ( j ) = 1.0_real64 xMatchesNode = . true . endif enddo if ( xMatchesNode ) then do j = 0 , this % N lAtS ( j ) = real ( lS ( j ), prec ) enddo return endif temp1 = 0.0_real64 do j = 0 , this % N temp2 = bWeights ( j ) / ( sE - controlPoints ( j )) lS ( j ) = temp2 temp1 = temp1 + temp2 enddo lS = lS / temp1 do j = 0 , this % N lAtS ( j ) = real ( lS ( j ), prec ) enddo endfunction CalculateLagrangePolynomials subroutine WriteHDF5_Lagrange_t ( this , fileId ) implicit none class ( Lagrange_t ), intent ( in ) :: this integer ( HID_T ), intent ( in ) :: fileId call CreateGroup_HDF5 ( fileId , '/interp' ) call WriteArray_HDF5 ( fileId , '/interp/controlpoints' , & this % controlPoints ) call WriteArray_HDF5 ( fileId , '/interp/qweights' , & this % qWeights ) call WriteArray_HDF5 ( fileId , '/interp/dgmatrix' , & this % dgMatrix ) call WriteArray_HDF5 ( fileId , '/interp/dmatrix' , & this % dMatrix ) call WriteArray_HDF5 ( fileId , '/interp/bmatrix' , & this % bMatrix ) call WriteArray_HDF5 ( fileId , '/interp/imatrix' , & this % iMatrix ) endsubroutine WriteHDF5_Lagrange_t endmodule SELF_Lagrange_t","tags":"","loc":"sourcefile/self_lagrange_t.f90.html"},{"title":"SELF_MappedVector_2D_t.f90 – SELF","text":"Contents Modules SELF_MappedVector_2D_t Source Code SELF_MappedVector_2D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_MappedVector_2D_t use SELF_Constants use SELF_Lagrange use SELF_Vector_2D use SELF_Tensor_2D use SELF_Mesh_2D use SELF_Geometry_2D use SELF_DomainDecomposition use FEQParse use iso_c_binding implicit none type , extends ( Vector2D ), public :: MappedVector2D_t logical :: geometry_associated = . false . type ( SEMQuad ), pointer :: geometry => null () contains procedure , public :: AssociateGeometry => AssociateGeometry_MappedVector2D_t procedure , public :: DissociateGeometry => DissociateGeometry_MappedVector2D_t procedure , public :: SideExchange => SideExchange_MappedVector2D_t generic , public :: MappedDivergence => MappedDivergence_MappedVector2D_t procedure , private :: MappedDivergence_MappedVector2D_t generic , public :: MappedDGDivergence => MappedDGDivergence_MappedVector2D_t procedure , private :: MappedDGDivergence_MappedVector2D_t procedure , private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D_t procedure , private :: ApplyFlip => ApplyFlip_MappedVector2D_t procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector2D_t endtype MappedVector2D_t contains subroutine AssociateGeometry_MappedVector2D_t ( this , geometry ) implicit none class ( MappedVector2D_t ), intent ( inout ) :: this type ( SEMQuad ), target , intent ( in ) :: geometry if (. not . associated ( this % geometry )) then this % geometry => geometry this % geometry_associated = . true . endif endsubroutine AssociateGeometry_MappedVector2D_t subroutine DissociateGeometry_MappedVector2D_t ( this ) implicit none class ( MappedVector2D_t ), intent ( inout ) :: this if ( associated ( this % geometry )) then this % geometry => null () this % geometry_associated = . false . endif endsubroutine DissociateGeometry_MappedVector2D_t subroutine SetInteriorFromEquation_MappedVector2D_t ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedVector2D_t ), intent ( inout ) :: this type ( SEMQuad ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , iEl , iVar real ( prec ) :: x real ( prec ) :: y do iVar = 1 , this % nVar do iEl = 1 , this % nElem do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , iEl , 1 , 2 ) this % interior ( i , j , iEl , iVar , 1 ) = & this % eqn ( 1 + 2 * ( iVar - 1 ))% Evaluate (( / x , y , 0.0_prec , time / )) this % interior ( i , j , iEl , iVar , 2 ) = & this % eqn ( 2 + 2 * ( iVar - 1 ))% Evaluate (( / x , y , 0.0_prec , time / )) enddo enddo enddo enddo endsubroutine SetInteriorFromEquation_MappedVector2D_t subroutine MPIExchangeAsync_MappedVector2D_t ( this , mesh ) implicit none class ( MappedVector2D_t ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar , idir integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount msgCount = 0 do idir = 1 , 2 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 4 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) ! create unique tag for each side and each variable tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 + this % nvar * ( idir - 1 )) msgCount = msgCount + 1 call MPI_IRECV ( this % extBoundary (:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( this % boundary (:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedVector2D_t subroutine ApplyFlip_MappedVector2D_t ( this , mesh ) ! Apply side flips to sides where MPI exchanges took place. implicit none class ( MappedVector2D_t ), intent ( inout ) :: this type ( Mesh2D ), intent ( in ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 integer :: i , i2 integer :: r2 , flip , ivar , idir real ( prec ) :: extBuff ( 1 : this % interp % N + 1 ) do idir = 1 , 2 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 4 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element (global id) if ( e2 > 0 ) then ! Interior Element r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 ! Need to update extBoundary with flip applied if ( flip == 1 ) then do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i extBuff ( i ) = this % extBoundary ( i2 , s1 , e1 , ivar , idir ) enddo do i = 1 , this % interp % N + 1 this % extBoundary ( i , s1 , e1 , ivar , idir ) = extBuff ( i ) enddo endif endif endif enddo enddo enddo enddo endsubroutine ApplyFlip_MappedVector2D_t subroutine SideExchange_MappedVector2D_t ( this , mesh ) implicit none class ( MappedVector2D_t ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: e1 , e2 , s1 , s2 , e2Global integer :: flip , bcid integer :: i1 , i2 , ivar , idir integer :: r2 integer :: rankId , offset integer , pointer :: elemtorank (:) ! This mapping is needed to resolve a build error with ! amdflang that appears to be caused by referencing ! the elemToRank attribute within the do concurrent ! https://github.com/FluidNumerics/SELF/issues/54 elemtorank => mesh % decomp % elemToRank (:) rankId = mesh % decomp % rankId offset = mesh % decomp % offsetElem ( rankId + 1 ) if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif do concurrent ( s1 = 1 : 4 , e1 = 1 : mesh % nElem , ivar = 1 : this % nvar , idir = 1 : 2 ) e2Global = mesh % sideInfo ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % sideInfo ( 5 , s1 , e1 ) if ( e2Global > 0 ) then r2 = elemToRank ( e2Global ) ! Neighbor rank if ( r2 == mesh % decomp % rankId ) then if ( flip == 0 ) then do i1 = 1 , this % interp % N + 1 this % extBoundary ( i1 , s1 , e1 , ivar , idir ) = & this % boundary ( i1 , s2 , e2 , ivar , idir ) enddo elseif ( flip == 1 ) then do i1 = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i1 this % extBoundary ( i1 , s1 , e1 , ivar , idir ) = & this % boundary ( i2 , s2 , e2 , ivar , idir ) enddo endif endif endif enddo if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call this % ApplyFlip ( mesh ) endif endsubroutine SideExchange_MappedVector2D_t subroutine MappedDivergence_MappedVector2D_t ( this , df ) ! Strong Form Operator !    ! implicit none class ( MappedVector2D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , j , ii real ( prec ) :: dfLoc , Fx , Fy , Fc do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( ii , j , iEl , iVar , 1 ) Fy = this % interior ( ii , j , iEl , iVar , 2 ) Fc = this % geometry % dsdx % interior ( ii , j , iEl , 1 , 1 , 1 ) * Fx + & this % geometry % dsdx % interior ( ii , j , iEl , 1 , 2 , 1 ) * Fy dfLoc = dfLoc + this % interp % dMatrix ( ii , i ) * Fc enddo dF ( i , j , iel , ivar ) = dfLoc enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( i , ii , iEl , iVar , 1 ) Fy = this % interior ( i , ii , iEl , iVar , 2 ) Fc = this % geometry % dsdx % interior ( i , ii , iEl , 1 , 1 , 2 ) * Fx + & this % geometry % dsdx % interior ( i , ii , iEl , 1 , 2 , 2 ) * Fy dfLoc = dfLoc + this % interp % dMatrix ( ii , j ) * Fc enddo dF ( i , j , iel , ivar ) = ( dF ( i , j , iel , ivar ) + dfLoc ) / this % geometry % J % interior ( i , j , iEl , 1 ) enddo endsubroutine MappedDivergence_MappedVector2D_t subroutine MappedDGDivergence_MappedVector2D_t ( this , df ) !! Computes the divergence of a 2-D vector using the weak form !! On input, the  attribute of the vector !! is assigned and the  attribute is set to the physical !! directions of the vector. This method will project the vector !! onto the contravariant basis vectors. implicit none class ( MappedVector2D_t ), intent ( in ) :: this real ( prec ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , j , ii real ( prec ) :: dfLoc , Fx , Fy , Fc do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( ii , j , iEl , iVar , 1 ) Fy = this % interior ( ii , j , iEl , iVar , 2 ) Fc = this % geometry % dsdx % interior ( ii , j , iEl , 1 , 1 , 1 ) * Fx + & this % geometry % dsdx % interior ( ii , j , iEl , 1 , 2 , 1 ) * Fy dfLoc = dfLoc + this % interp % dgMatrix ( ii , i ) * Fc enddo dF ( i , j , iel , ivar ) = dfLoc + & ( this % interp % bMatrix ( i , 2 ) * this % boundaryNormal ( j , 2 , iel , ivar ) + & this % interp % bMatrix ( i , 1 ) * this % boundaryNormal ( j , 4 , iel , ivar )) / & this % interp % qweights ( i ) enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 ! Convert from physical to computational space Fx = this % interior ( i , ii , iEl , iVar , 1 ) Fy = this % interior ( i , ii , iEl , iVar , 2 ) Fc = this % geometry % dsdx % interior ( i , ii , iEl , 1 , 1 , 2 ) * Fx + & this % geometry % dsdx % interior ( i , ii , iEl , 1 , 2 , 2 ) * Fy dfLoc = dfLoc + this % interp % dgMatrix ( ii , j ) * Fc enddo dfLoc = dfLoc + & ( this % interp % bMatrix ( j , 2 ) * this % boundaryNormal ( i , 3 , iel , ivar ) + & this % interp % bMatrix ( j , 1 ) * this % boundaryNormal ( i , 1 , iel , ivar )) / & this % interp % qweights ( j ) dF ( i , j , iel , ivar ) = ( dF ( i , j , iel , ivar ) + dfLoc ) / this % geometry % J % interior ( i , j , iEl , 1 ) enddo endsubroutine MappedDGDivergence_MappedVector2D_t endmodule SELF_MappedVector_2D_t","tags":"","loc":"sourcefile/self_mappedvector_2d_t.f90.html"},{"title":"SELF_Vector_3D_t.f90 – SELF","text":"Contents Modules SELF_Vector_3D_t Source Code SELF_Vector_3D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Vector_3D_t use SELF_Constants use SELF_Lagrange use SELF_Metadata use FEQParse use SELF_HDF5 use SELF_Data use HDF5 use iso_c_binding implicit none type , extends ( SELF_DataObj ), public :: Vector3D_t real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:) :: interior real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:) :: boundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:) :: extBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:) :: avgBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: boundaryNormal contains procedure , public :: Init => Init_Vector3D_t procedure , public :: Free => Free_Vector3D_t procedure , public :: UpdateHost => UpdateHost_Vector3D_t procedure , public :: UpdateDevice => UpdateDevice_Vector3D_t procedure , public :: BoundaryInterp => BoundaryInterp_Vector3D_t procedure , public :: AverageSides => AverageSides_Vector3D_t generic , public :: GridInterp => GridInterp_Vector3D_t procedure , private :: GridInterp_Vector3D_t generic , public :: Gradient => Gradient_Vector3D_t procedure , private :: Gradient_Vector3D_t generic , public :: Curl => Curl_Vector3D_t procedure , private :: Curl_Vector3D_t generic , public :: Divergence => Divergence_Vector3D_t procedure , private :: Divergence_Vector3D_t generic , public :: SetEquation => SetEquation_Vector3D_t procedure , private :: SetEquation_Vector3D_t generic , public :: WriteHDF5 => WriteHDF5_MPI_Vector3D_t , WriteHDF5_Vector3D_t procedure , private :: WriteHDF5_MPI_Vector3D_t procedure , private :: WriteHDF5_Vector3D_t endtype Vector3D_t contains subroutine Init_Vector3D_t ( this , interp , nVar , nElem ) implicit none class ( Vector3D_t ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % boundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % boundaryNormal ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 3 * nVar )) ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 3 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo this % interior = 0.0_prec this % boundary = 0.0_prec this % boundarynormal = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec endsubroutine Init_Vector3D_t subroutine Free_Vector3D_t ( this ) implicit none class ( Vector3D_t ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % boundaryNormal ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) endsubroutine Free_Vector3D_t subroutine UpdateHost_Vector3D_t ( this ) implicit none class ( Vector3D_t ), intent ( inout ) :: this endsubroutine UpdateHost_Vector3D_t subroutine UpdateDevice_Vector3D_t ( this ) implicit none class ( Vector3D_t ), intent ( inout ) :: this endsubroutine UpdateDevice_Vector3D_t subroutine SetEquation_Vector3D_t ( this , idir , ivar , eqnChar ) !! Sets the equation parser for the `idir` direction and `ivar-th` variable implicit none class ( Vector3D_t ), intent ( inout ) :: this integer , intent ( in ) :: idir , ivar character ( * ), intent ( in ) :: eqnChar this % eqn ( idir + 3 * ( ivar - 1 )) = EquationParser ( trim ( eqnChar ), & ( / 'x' , 'y' , 'z' , 't' / )) endsubroutine SetEquation_Vector3D_t subroutine GridInterp_Vector3D_t ( this , f ) implicit none class ( Vector3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: f ( 1 : this % M + 1 , 1 : this % M + 1 , 1 : this % M + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 3 ) !! (Output) Array of function values, defined on the target grid ! Local integer :: i , j , k , ii , jj , kk , iel , ivar , idir real ( prec ) :: fi , fij , fijk do concurrent ( i = 1 : this % M + 1 , j = 1 : this % M + 1 , & k = 1 : this % M + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) fijk = 0.0_prec do kk = 1 , this % N + 1 fij = 0.0_prec do jj = 1 , this % N + 1 fi = 0.0_prec do ii = 1 , this % N + 1 fi = fi + this % interior ( ii , jj , kk , iel , ivar , idir ) * this % interp % iMatrix ( ii , i ) enddo fij = fij + fi * this % interp % iMatrix ( jj , j ) enddo fijk = fijk + fij * this % interp % iMatrix ( kk , k ) enddo f ( i , j , k , iel , ivar , idir ) = fijk enddo endsubroutine GridInterp_Vector3D_t subroutine AverageSides_Vector3D_t ( this ) implicit none class ( Vector3D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: iside integer :: ivar integer :: i , j integer :: idir do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & iside = 1 : 6 , iel = 1 : this % nelem , ivar = 1 : this % nvar , & idir = 1 : 3 ) this % boundary ( i , j , iside , iel , ivar , idir ) = 0.5_prec * ( & this % boundary ( i , j , iside , iel , ivar , idir ) + & this % extBoundary ( i , j , iside , iel , ivar , idir )) enddo endsubroutine AverageSides_Vector3D_t subroutine BoundaryInterp_Vector3D_t ( this ) implicit none class ( Vector3D_t ), intent ( inout ) :: this ! Local integer :: i , j , ii , idir , iel , ivar real ( prec ) :: fbb , fbs , fbe , fbn , fbw , fbt do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) fbb = 0.0_prec fbs = 0.0_prec fbe = 0.0_prec fbn = 0.0_prec fbw = 0.0_prec fbt = 0.0_prec do ii = 1 , this % N + 1 fbb = fbb + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , j , ii , iel , ivar , idir ) ! Bottom fbs = fbs + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , ii , j , iel , ivar , idir ) ! South fbe = fbe + this % interp % bMatrix ( ii , 2 ) * this % interior ( ii , i , j , iel , ivar , idir ) ! East fbn = fbn + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , ii , j , iel , ivar , idir ) ! North fbw = fbw + this % interp % bMatrix ( ii , 1 ) * this % interior ( ii , i , j , iel , ivar , idir ) ! West fbt = fbt + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , j , ii , iel , ivar , idir ) ! Top enddo this % boundary ( i , j , 1 , iel , ivar , idir ) = fbb this % boundary ( i , j , 2 , iel , ivar , idir ) = fbs this % boundary ( i , j , 3 , iel , ivar , idir ) = fbe this % boundary ( i , j , 4 , iel , ivar , idir ) = fbn this % boundary ( i , j , 5 , iel , ivar , idir ) = fbw this % boundary ( i , j , 6 , iel , ivar , idir ) = fbt enddo endsubroutine BoundaryInterp_Vector3D_t subroutine Gradient_Vector3D_t ( this , df ) implicit none class ( Vector3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 3 , 1 : 3 ) ! Local integer :: i , j , k , ii , idir , iel , ivar real ( prec ) :: dfds1 , dfds2 , dfds3 do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , & idir = 1 : 3 ) dfds1 = 0.0_prec dfds2 = 0.0_prec dfds3 = 0.0_prec do ii = 1 , this % N + 1 dfds1 = dfds1 + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , k , iel , ivar , idir ) dfds2 = dfds2 + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , k , iel , ivar , idir ) dfds3 = dfds3 + this % interp % dMatrix ( ii , k ) * this % interior ( i , j , ii , iel , ivar , idir ) enddo df ( i , j , k , iel , ivar , idir , 1 ) = dfds1 df ( i , j , k , iel , ivar , idir , 2 ) = dfds2 df ( i , j , k , iel , ivar , idir , 3 ) = dfds3 enddo endsubroutine Gradient_Vector3D_t subroutine Curl_Vector3D_t ( this , curlf ) implicit none class ( Vector3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: curlf ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 3 ) ! Local integer :: i , j , k , ii , idir , iel , ivar real ( prec ) :: dfds1 , dfds2 , dfds3 real ( prec ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 3 , 1 : 3 ) do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , & idir = 1 : 3 ) dfds1 = 0.0_prec dfds2 = 0.0_prec dfds3 = 0.0_prec do ii = 1 , this % N + 1 dfds1 = dfds1 + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , k , iel , ivar , idir ) dfds2 = dfds2 + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , k , iel , ivar , idir ) dfds3 = dfds3 + this % interp % dMatrix ( ii , k ) * this % interior ( i , j , ii , iel , ivar , idir ) enddo df ( i , j , k , iel , ivar , idir , 1 ) = dfds1 df ( i , j , k , iel , ivar , idir , 2 ) = dfds2 df ( i , j , k , iel , ivar , idir , 3 ) = dfds3 enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) curlf ( i , j , k , iel , ivar , 1 ) = ( df ( i , j , k , iel , ivar , 3 , 2 ) - df ( i , j , k , iel , ivar , 2 , 3 )) curlf ( i , j , k , iel , ivar , 2 ) = ( df ( i , j , k , iel , ivar , 1 , 3 ) - df ( i , j , k , iel , ivar , 3 , 1 )) curlf ( i , j , k , iel , ivar , 3 ) = ( df ( i , j , k , iel , ivar , 2 , 1 ) - df ( i , j , k , iel , ivar , 1 , 2 )) enddo endsubroutine Curl_Vector3D_t subroutine Divergence_Vector3D_t ( this , df ) implicit none class ( Vector3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: i , j , k , ii , iel , ivar real ( prec ) :: dfLoc do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 dfLoc = dfLoc + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , k , iel , ivar , 1 ) enddo dF ( i , j , k , iel , ivar ) = dfLoc enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 dfLoc = dfLoc + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , k , iel , ivar , 2 ) enddo dF ( i , j , k , iel , ivar ) = dF ( i , j , k , iel , ivar ) + dfLoc enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) dfLoc = 0.0_prec do ii = 1 , this % N + 1 dfLoc = dfLoc + this % interp % dMatrix ( ii , k ) * this % interior ( i , j , ii , iel , ivar , 3 ) enddo dF ( i , j , k , iel , ivar ) = dF ( i , j , k , iel , ivar ) + dfLoc enddo endsubroutine Divergence_Vector3D_t subroutine WriteHDF5_MPI_Vector3D_t ( this , fileId , group , elemoffset , nglobalelem ) implicit none class ( Vector3D_t ), intent ( in ) :: this character ( * ), intent ( in ) :: group integer ( HID_T ), intent ( in ) :: fileId integer , intent ( in ) :: elemoffset integer , intent ( in ) :: nglobalelem ! Local integer ( HID_T ) :: offset ( 1 : 4 ) integer ( HID_T ) :: globalDims ( 1 : 4 ) integer :: ivar , idir character ( 4 ) :: dimvar offset ( 1 : 4 ) = ( / 0 , 0 , 0 , elemoffset / ) globalDims ( 1 : 4 ) = ( / this % interp % N + 1 , & this % interp % N + 1 , & this % interp % N + 1 , & nglobalelem / ) call CreateGroup_HDF5 ( fileId , trim ( group )) do idir = 1 , 3 write ( dimvar , '(I1)' ) idir dimvar = \"dim\" // trim ( dimvar ) do ivar = 1 , this % nVar call WriteArray_HDF5 ( fileId , & trim ( group ) // \"/\" // trim ( this % meta ( ivar )% name ) // \"_\" // dimvar , & this % interior (:,:,:,:, ivar , idir ), offset , globalDims ) enddo enddo endsubroutine WriteHDF5_MPI_Vector3D_t subroutine WriteHDF5_Vector3D_t ( this , fileId , group ) implicit none class ( Vector3D_t ), intent ( in ) :: this integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: group ! Local integer :: ivar , idir character ( 4 ) :: dimvar call CreateGroup_HDF5 ( fileId , trim ( group )) do ivar = 1 , this % nVar call this % meta ( ivar )% WriteHDF5 ( group , ivar , fileId ) enddo do idir = 1 , 3 write ( dimvar , '(I1)' ) idir dimvar = \"dim\" // trim ( dimvar ) do ivar = 1 , this % nVar call WriteArray_HDF5 ( fileId , & trim ( group ) // \"/\" // trim ( this % meta ( ivar )% name ) // \"_\" // dimvar , & this % interior (:,:,:,:, ivar , idir )) enddo enddo endsubroutine WriteHDF5_Vector3D_t endmodule SELF_Vector_3D_t","tags":"","loc":"sourcefile/self_vector_3d_t.f90.html"},{"title":"SELF_Scalar_3D_t.f90 – SELF","text":"Contents Modules SELF_Scalar_3D_t Source Code SELF_Scalar_3D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Scalar_3D_t use SELF_Constants use SELF_Lagrange use SELF_Metadata use FEQParse use SELF_HDF5 use SELF_Data use HDF5 use iso_c_binding implicit none #include \"SELF_Macros.h\" type , extends ( SELF_DataObj ), public :: Scalar3D_t real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: interior real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: boundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: extBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: avgBoundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:) :: boundarynormal contains procedure , public :: Init => Init_Scalar3D_t procedure , public :: Free => Free_Scalar3D_t procedure , public :: UpdateHost => UpdateHost_Scalar3D_t procedure , public :: UpdateDevice => UpdateDevice_Scalar3D_t procedure , public :: BoundaryInterp => BoundaryInterp_Scalar3D_t procedure , public :: AverageSides => AverageSides_Scalar3D_t generic , public :: GridInterp => GridInterp_Scalar3D_t procedure , private :: GridInterp_Scalar3D_t generic , public :: Gradient => Gradient_Scalar3D_t procedure , private :: Gradient_Scalar3D_t generic , public :: WriteHDF5 => WriteHDF5_MPI_Scalar3D_t , WriteHDF5_Scalar3D_t procedure , private :: WriteHDF5_MPI_Scalar3D_t procedure , private :: WriteHDF5_Scalar3D_t endtype Scalar3D_t contains subroutine Init_Scalar3D_t ( this , interp , nVar , nElem ) implicit none class ( Scalar3D_t ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar ), & this % boundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : 3 * nvar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec this % boundarynormal = 0.0_prec allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) endsubroutine Init_Scalar3D_t subroutine Free_Scalar3D_t ( this ) implicit none class ( Scalar3D_t ), intent ( inout ) :: this this % nVar = 0 this % nElem = 0 this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % boundarynormal ) deallocate ( this % meta ) deallocate ( this % eqn ) endsubroutine Free_Scalar3D_t subroutine UpdateHost_Scalar3D_t ( this ) implicit none class ( Scalar3D_t ), intent ( inout ) :: this endsubroutine UpdateHost_Scalar3D_t subroutine UpdateDevice_Scalar3D_t ( this ) implicit none class ( Scalar3D_t ), intent ( inout ) :: this endsubroutine UpdateDevice_Scalar3D_t subroutine BoundaryInterp_Scalar3D_t ( this ) implicit none class ( Scalar3D_t ), intent ( inout ) :: this ! Local integer :: i , j , ii , iel , ivar real ( prec ) :: fbb , fbs , fbe , fbn , fbw , fbt do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & iel = 1 : this % nelem , ivar = 1 : this % nvar ) fbb = 0.0_prec fbs = 0.0_prec fbe = 0.0_prec fbn = 0.0_prec fbw = 0.0_prec fbt = 0.0_prec do ii = 1 , this % N + 1 fbb = fbb + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , j , ii , iel , ivar ) ! Bottom fbs = fbs + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , ii , j , iel , ivar ) ! South fbe = fbe + this % interp % bMatrix ( ii , 2 ) * this % interior ( ii , i , j , iel , ivar ) ! East fbn = fbn + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , ii , j , iel , ivar ) ! North fbw = fbw + this % interp % bMatrix ( ii , 1 ) * this % interior ( ii , i , j , iel , ivar ) ! West fbt = fbt + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , j , ii , iel , ivar ) ! Top enddo this % boundary ( i , j , 1 , iel , ivar ) = fbb this % boundary ( i , j , 2 , iel , ivar ) = fbs this % boundary ( i , j , 3 , iel , ivar ) = fbe this % boundary ( i , j , 4 , iel , ivar ) = fbn this % boundary ( i , j , 5 , iel , ivar ) = fbw this % boundary ( i , j , 6 , iel , ivar ) = fbt enddo endsubroutine BoundaryInterp_Scalar3D_t subroutine AverageSides_Scalar3D_t ( this ) implicit none class ( Scalar3D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: iside integer :: ivar integer :: i , j do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & iside = 1 : 6 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) this % avgboundary ( i , j , iside , iel , ivar ) = 0.5_prec * ( & this % boundary ( i , j , iside , iel , ivar ) + & this % extBoundary ( i , j , iside , iel , ivar )) enddo endsubroutine AverageSides_Scalar3D_t subroutine GridInterp_Scalar3D_t ( this , f ) implicit none class ( Scalar3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: f ( 1 : this % M + 1 , 1 : this % M + 1 , 1 : this % M + 1 , 1 : this % nelem , 1 : this % nvar ) !! (Output) Array of function values, defined on the target grid ! Local integer :: i , j , k , ii , jj , kk , iel , ivar real ( prec ) :: fi , fij , fijk do concurrent ( i = 1 : this % M + 1 , j = 1 : this % M + 1 , & k = 1 : this % M + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) fijk = 0.0_prec do kk = 1 , this % N + 1 fij = 0.0_prec do jj = 1 , this % N + 1 fi = 0.0_prec do ii = 1 , this % N + 1 fi = fi + this % interior ( ii , jj , kk , iel , ivar ) * this % interp % iMatrix ( ii , i ) enddo fij = fij + fi * this % interp % iMatrix ( jj , j ) enddo fijk = fijk + fij * this % interp % iMatrix ( kk , k ) enddo f ( i , j , k , iel , ivar ) = fijk enddo endsubroutine GridInterp_Scalar3D_t subroutine Gradient_Scalar3D_t ( this , df ) implicit none class ( Scalar3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 3 ) ! Local integer :: i , j , k , ii , iel , ivar real ( prec ) :: df1 , df2 , df3 do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) df1 = 0.0_prec df2 = 0.0_prec df3 = 0.0_prec do ii = 1 , this % N + 1 df1 = df1 + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , k , iel , ivar ) df2 = df2 + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , k , iel , ivar ) df3 = df3 + this % interp % dMatrix ( ii , k ) * this % interior ( i , j , ii , iel , ivar ) enddo df ( i , j , k , iel , ivar , 1 ) = df1 df ( i , j , k , iel , ivar , 2 ) = df2 df ( i , j , k , iel , ivar , 3 ) = df3 enddo endsubroutine Gradient_Scalar3D_t subroutine WriteHDF5_MPI_Scalar3D_t ( this , fileId , group , elemoffset , nglobalelem ) implicit none class ( Scalar3D_t ), intent ( in ) :: this character ( * ), intent ( in ) :: group integer ( HID_T ), intent ( in ) :: fileId integer , intent ( in ) :: elemoffset integer , intent ( in ) :: nglobalelem ! Local integer ( HID_T ) :: offset ( 1 : 4 ) integer ( HID_T ) :: globalDims ( 1 : 4 ) integer :: ivar offset ( 1 : 4 ) = ( / 0 , 0 , 0 , elemoffset / ) globalDims ( 1 : 4 ) = ( / this % interp % N + 1 , & this % interp % N + 1 , & this % interp % N + 1 , & nglobalelem / ) call CreateGroup_HDF5 ( fileId , trim ( group )) do ivar = 1 , this % nVar !call this%meta(ivar)%WriteHDF5(group,ivar,fileId) call WriteArray_HDF5 ( fileId , & trim ( group ) // \"/\" // trim ( this % meta ( ivar )% name ), & this % interior (:,:,:,:, ivar ), offset , globalDims ) enddo endsubroutine WriteHDF5_MPI_Scalar3D_t subroutine WriteHDF5_Scalar3D_t ( this , fileId , group ) implicit none class ( Scalar3D_t ), intent ( in ) :: this integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: group ! Local integer :: ivar call CreateGroup_HDF5 ( fileId , trim ( group )) do ivar = 1 , this % nVar call this % meta ( ivar )% WriteHDF5 ( group , ivar , fileId ) call WriteArray_HDF5 ( fileId , & trim ( group ) // trim ( this % meta ( ivar )% name ), & this % interior (:,:,:,:, ivar )) enddo endsubroutine WriteHDF5_Scalar3D_t endmodule SELF_Scalar_3D_t","tags":"","loc":"sourcefile/self_scalar_3d_t.f90.html"},{"title":"SELF_Tensor_2D_t.f90 – SELF","text":"Contents Modules SELF_Tensor_2D_t Source Code SELF_Tensor_2D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Tensor_2D_t use SELF_Constants use SELF_Lagrange use SELF_Metadata use FEQParse use SELF_HDF5 use SELF_Data use HDF5 use iso_c_binding implicit none type , extends ( SELF_DataObj ), public :: Tensor2D_t real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:) :: interior real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:) :: boundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:) :: extBoundary contains procedure , public :: Init => Init_Tensor2D_t procedure , public :: Free => Free_Tensor2D_t procedure , public :: UpdateHost => UpdateHost_Tensor2D_t procedure , public :: UpdateDevice => UpdateDevice_Tensor2D_t procedure , public :: BoundaryInterp => BoundaryInterp_Tensor2D_t generic , public :: Determinant => Determinant_Tensor2D_t procedure , private :: Determinant_Tensor2D_t endtype Tensor2D_t contains subroutine Init_Tensor2D_t ( this , interp , nVar , nElem ) implicit none class ( Tensor2D_t ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 2 , 1 : 2 ), & this % boundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 , 1 : 2 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 , 1 : 2 )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 4 * nVar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 4 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo endsubroutine Init_Tensor2D_t subroutine Free_Tensor2D_t ( this ) implicit none class ( Tensor2D_t ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) endsubroutine Free_Tensor2D_t subroutine UpdateHost_Tensor2D_t ( this ) implicit none class ( Tensor2D_t ), intent ( inout ) :: this endsubroutine UpdateHost_Tensor2D_t subroutine UpdateDevice_Tensor2D_t ( this ) implicit none class ( Tensor2D_t ), intent ( inout ) :: this endsubroutine UpdateDevice_Tensor2D_t subroutine BoundaryInterp_Tensor2D_t ( this ) implicit none class ( Tensor2D_t ), intent ( inout ) :: this ! Local integer :: i , ii , idir , jdir , iel , ivar real ( prec ) :: fbs , fbe , fbn , fbw do concurrent ( i = 1 : this % N + 1 , & iel = 1 : this % nelem , ivar = 1 : this % nvar , & idir = 1 : 2 , jdir = 1 : 2 ) fbs = 0.0_prec fbe = 0.0_prec fbn = 0.0_prec fbw = 0.0_prec do ii = 1 , this % N + 1 fbs = fbs + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , ii , iel , ivar , idir , jdir ) ! South fbe = fbe + this % interp % bMatrix ( ii , 2 ) * this % interior ( ii , i , iel , ivar , idir , jdir ) ! East fbn = fbn + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , ii , iel , ivar , idir , jdir ) ! North fbw = fbw + this % interp % bMatrix ( ii , 1 ) * this % interior ( ii , i , iel , ivar , idir , jdir ) ! West enddo this % boundary ( i , 1 , iel , ivar , idir , jdir ) = fbs this % boundary ( i , 2 , iel , ivar , idir , jdir ) = fbe this % boundary ( i , 3 , iel , ivar , idir , jdir ) = fbn this % boundary ( i , 4 , iel , ivar , idir , jdir ) = fbw enddo endsubroutine BoundaryInterp_Tensor2D_t subroutine Determinant_Tensor2D_t ( this , det ) implicit none class ( Tensor2D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: det ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , j do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & iel = 1 : this % nelem , ivar = 1 : this % nvar ) det ( i , j , iEl , iVar ) = this % interior ( i , j , iEl , iVar , 1 , 1 ) * & this % interior ( i , j , iEl , iVar , 2 , 2 ) - & this % interior ( i , j , iEl , iVar , 1 , 2 ) * & this % interior ( i , j , iEl , iVar , 2 , 1 ) enddo endsubroutine Determinant_Tensor2D_t endmodule SELF_Tensor_2D_t","tags":"","loc":"sourcefile/self_tensor_2d_t.f90.html"},{"title":"SELF_Quadrature.f90 – SELF","text":"Contents Modules SELF_Quadrature Source Code SELF_Quadrature.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Contains routines from D.A. Kopriva, 2009, \"Implementing Spectral Methods for Partial ! Differential Equations: Algorithms for Scientists and Engineers\", Springer. ! ! Routines are defined for computing Legendre and Chebyshev Gauss and Gauss-Lobatto ! quadrature nodes and weights. module SELF_Quadrature use iso_fortran_env use SELF_Constants implicit none public :: ChebyshevQuadrature , LegendreQuadrature private :: ChebyshevGauss , ChebyshevGaussLobatto , & LegendreGauss , LegendreGaussLobatto , & LegendreQandL contains ! =============================================================================================== ! ! LegendreQuadrature !   Returns the specified Legendre quadrature nodes and integration weights. ! !   Given a polynomial degree, and quadrature type (Gauss or Gauss Lobatto), this subroutine manages !   the calls to underlying private routines to generate the desired Legendre quadrature. ! !   Usage : ! !     INTEGER    :: N, quadType !     REAL(real64) :: nodes(0:N), weights(0:N) ! !       CALL LegendreQuadrature( N, quadType, nodes, weights ) ! !   Parameters : ! !     N (in) !       Degree of the quadrature ! !     quadType (in) !       Flag specifying the quadrature type. Can be set to GAUSS or GAUSS_LOBATTO ! !     nodes(0:N) (out) !       Array of quadrature nodes ! !     weights(0:N) (out) !       Array of quadrature weights ! ! =============================================================================================== ! subroutine LegendreQuadrature ( N , nodes , weights , QuadType ) implicit none integer , intent ( in ) :: N real ( prec ), intent ( out ) :: nodes ( 0 : N ) real ( prec ), intent ( out ) :: weights ( 0 : N ) integer , intent ( in ) :: QuadType ! Local real ( real64 ) :: nodesLocal ( 0 : N ) real ( real64 ) :: weightsLocal ( 0 : N ) integer :: i if ( QuadType == GAUSS_LOBATTO ) then call LegendreGaussLobatto ( N , nodesLocal , weightsLocal ) elseif ( QuadType == GAUSS ) then call LegendreGauss ( N , nodesLocal , weightsLocal ) endif do i = 0 , N nodes ( i ) = real ( nodesLocal ( i ), prec ) weights ( i ) = real ( weightsLocal ( i ), prec ) enddo endsubroutine LegendreQuadrature ! =============================================================================================== ! ! ChebyshevQuadrature ! !   Returns the specified Chebyshev quadrature nodes and integration weights. ! !   Given a polynomial degree, and quadrature type (Gauss or Gauss Lobatto), this subroutine manages !   the calls to underlying private routines to generate the desired Chebyshev quadrature. ! !   Usage : ! !     INTEGER    :: N, quadType !     REAL(real64) :: nodes(0:N), weights(0:N) ! !       CALL ChebyshevQuadrature( N, quadType, nodes, weights ) ! !   Input/Output : ! !     N (in) !       Degree of the quadrature ! !     quadType (in) !       Flag specifying the quadrature type. Can be set to GAUSS or GAUSS_LOBATTO ! !     nodes(0:N) (out) !       Array of quadrature nodes ! !     weights(0:N) (out) !       Array of quadrature weights ! ! ================================================================================================ ! subroutine ChebyshevQuadrature ( N , nodes , weights , quadType ) implicit none integer , intent ( in ) :: N real ( prec ), intent ( out ) :: nodes ( 0 : N ) real ( prec ), intent ( out ) :: weights ( 0 : N ) integer , intent ( in ) :: QuadType ! Local real ( real64 ) :: nodesLocal ( 0 : N ) real ( real64 ) :: weightsLocal ( 0 : N ) integer :: i if ( QuadType == CHEBYSHEV_GAUSS_LOBATTO ) then call ChebyshevGaussLobatto ( N , nodesLocal , weightsLocal ) elseif ( QuadType == CHEBYSHEV_GAUSS ) then call ChebyshevGauss ( N , nodesLocal , weightsLocal ) endif do i = 0 , N nodes ( i ) = real ( nodesLocal ( i ), prec ) weights ( i ) = real ( weightsLocal ( i ), prec ) enddo endsubroutine ChebyshevQuadrature ! =============================================================================================== ! ! S/R ChebyshevGauss !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 67 !   Algorithm 26 ! =============================================================================================== ! subroutine ChebyshevGauss ( N , nodes , weights ) implicit none integer :: N real ( real64 ) :: nodes ( 0 : N ) real ( real64 ) :: weights ( 0 : N ) ! Local integer :: j do j = 0 , N weights ( j ) = pi / ( real ( N , real64 ) + 1.0_real64 ) nodes ( j ) = - cos ( pi * ( 2.0_real64 * real ( j , real64 ) + 1.0_real64 ) / ( 2.0_real64 * real ( N , real64 ) + 2.0_real64 )) enddo endsubroutine ChebyshevGauss ! =============================================================================================== ! ! S/R ChebyshevGaussLobatto !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 68 !   Algorithm 27 ! =============================================================================================== ! subroutine ChebyshevGaussLobatto ( N , nodes , weights ) implicit none integer :: N real ( real64 ) :: nodes ( 0 : N ) real ( real64 ) :: weights ( 0 : N ) ! LOCAL integer :: j do j = 0 , N weights ( j ) = pi / real ( N , real64 ) nodes ( j ) = - cos ( pi * real ( j , real64 ) / real ( N , real64 )) enddo weights ( 0 ) = weights ( 0 ) * 0.5_real64 weights ( N ) = weights ( N ) * 0.5_real64 endsubroutine ChebyshevGaussLobatto ! =============================================================================================== ! ! S/R LegendreGauss !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 64 !   Algorithm 23 ! =============================================================================================== ! subroutine LegendreGauss ( N , nodes , weights ) implicit none integer :: N real ( real64 ) :: nodes ( 0 : N ) real ( real64 ) :: weights ( 0 : N ) ! Local real ( real64 ) :: nodes_local ( 0 : N ) real ( real64 ) :: weights_local ( 0 : N ) real ( real64 ) :: lN1 , dlN1 real ( real64 ) :: delta integer :: j , kIt if ( N == 0 ) then nodes_local ( 0 ) = 0.0_real64 weights_local ( 0 ) = 2.0_real64 elseif ( N == 1 ) then nodes_local ( 0 ) = - sqrt ( 1.0_real64 / 3.0_real64 ) weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = - nodes ( 0 ) weights_local ( 1 ) = weights ( 0 ) else do j = 0 ,(( N + 1 ) / 2 ) nodes_local ( j ) = - cos (( 2.0_real64 * real ( j , real64 ) + 1.0_real64 ) * pi / ( 2.0_real64 * real ( N , real64 ) + 1.0_real64 )) do kIt = 1 , newtonMax call LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) delta = - lN1 / dlN1 nodes_local ( j ) = nodes_local ( j ) + delta if ( abs ( delta ) <= TOL * nodes_local ( j )) exit enddo call LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) weights_local ( j ) = 2.0_real64 / (( 1.0_real64 - nodes_local ( j ) * nodes_local ( j )) * dlN1 * dlN1 ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) enddo endif if ( mod ( real ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) then call LegendrePolynomial ( N + 1 , 0.0_real64 , lN1 , dlN1 ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0 / ( dlN1 * dlN1 ) endif do j = 0 , N nodes ( j ) = real ( nodes_local ( j ), real64 ) weights ( j ) = real ( weights_local ( j ), real64 ) enddo endsubroutine LegendreGauss ! =============================================================================================== ! ! S/R LegendreGaussLobatto !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 66 !   Algorithm 25 ! =============================================================================================== ! subroutine LegendreGaussLobatto ( N , nodes , weights ) implicit none integer :: N real ( real64 ) :: nodes ( 0 : N ) real ( real64 ) :: weights ( 0 : N ) ! Local real ( real64 ) :: nodes_local ( 0 : N ) real ( real64 ) :: weights_local ( 0 : N ) real ( real64 ) :: delta , q , qprime , lN integer :: j , kIt if ( N == 1 ) then nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = 1.0_real64 weights_local ( 1 ) = 1.0_real64 else nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 2.0_real64 / ( real ( N , real64 ) * ( real ( N , real64 ) + 1.0_real64 )) nodes_local ( N ) = 1.0_real64 weights_local ( N ) = weights_local ( 0 ) do j = 1 ,(( N + 1 ) / 2 - 1 ) nodes_local ( j ) = - cos (( real ( j , real64 ) + 0.25_real64 ) * pi / real ( N , real64 ) - & 3.0_real64 / ( 8.0_real64 * real ( N , real64 ) * pi * ( real ( j , real64 ) + 0.25_real64 ))) do kIt = 1 , newtonMax call LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) delta = - q / qprime nodes_local ( j ) = nodes_local ( j ) + delta if ( abs ( delta ) <= TOL * nodes_local ( j )) exit enddo call LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) weights_local ( j ) = 2.0_real64 / ( real ( N , real64 ) * ( real ( N , real64 ) + 1.0_real64 ) * lN * lN ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) enddo endif if ( mod ( real ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) then call LegendreQandL ( N , 0.0_real64 , q , qprime , lN ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0_real64 / ( real ( N , real64 ) * ( real ( N , real64 ) + 1.0_real64 ) * lN * lN ) endif do j = 0 , N nodes ( j ) = real ( nodes_local ( j ), real64 ) weights ( j ) = real ( weights_local ( j ), real64 ) enddo endsubroutine LegendreGaussLobatto ! =============================================================================================== ! ! S/R LegendrePolynomial !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 63 !   Algorithm 22 ! =============================================================================================== ! subroutine LegendrePolynomial ( N , x , lAtX , dLdxAtX ) implicit none integer :: N real ( real64 ) :: x real ( real64 ) :: lAtX , dLdxAtX ! Local real ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 integer :: i if ( N == 0 ) then lAtX = 1.0_real64 dLdxAtX = 0.0_real64 elseif ( N == 1 ) then lAtX = x dLdxAtX = 1.0_real64 else lnM2 = 1.0_real64 lnM1 = x dlnM2 = 0.0_real64 dlnM1 = 1.0_real64 do i = 2 , N lAtX = (( 2.0_real64 * real ( i , real64 ) - 1.0_real64 ) * x * lnM1 - & ( real ( i , real64 ) - 1.0_real64 ) * lnM2 ) / ( real ( i , real64 )) dldxAtX = dlnM2 + ( 2.0_real64 * real ( i , real64 ) - 1.0_real64 ) * lnM1 lnM2 = lnM1 lnM1 = lAtX dlnM2 = dlnM1 dlnM1 = dldxAtX enddo endif endsubroutine LegendrePolynomial ! =============================================================================================== ! ! S/R LegendreQandL !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 65 !   Algorithm 24 ! =============================================================================================== ! subroutine LegendreQandL ( N , x , q , qprime , lN ) implicit none integer :: N real ( real64 ) :: x real ( real64 ) :: lN , q , qprime ! Local real ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 , dlN , lN1 , dlN1 integer :: i lNm2 = 1.0_real64 lNm1 = x dlNm2 = 0.0_real64 dlNm1 = 1.0_real64 do i = 2 , N lN = ( 2.0_real64 * i - 1.0_real64 ) / ( real ( i , real64 )) * x * lNm1 - ( real ( i , real64 ) - 1.0_real64 ) / ( real ( i , real64 )) * lNm2 dlN = dlNm2 + ( 2.0_real64 * real ( i , real64 ) - 1.0_real64 ) * lNm1 lNm2 = lNm1 lNm1 = lN dlNm2 = dlNm1 dlNm1 = dlN enddo i = N + 1 lN1 = ( 2.0_real64 * i - 1.0_real64 ) / ( real ( i , real64 )) * x * lN - ( real ( i , real64 ) - 1.0_real64 ) / ( real ( i , real64 )) * lNm2 dlN1 = dlNm2 + ( 2.0_real64 * real ( i , real64 ) - 1.0_real64 ) * lNm1 q = lN1 - lNm2 qprime = dlN1 - dlNm2 endsubroutine LegendreQandL endmodule SELF_Quadrature","tags":"","loc":"sourcefile/self_quadrature.f90.html"},{"title":"SELF_Data.f90 – SELF","text":"Contents Modules SELF_Data Source Code SELF_Data.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Data use SELF_Constants use SELF_Lagrange use SELF_Metadata use FEQParse use SELF_HDF5 use HDF5 use iso_c_binding implicit none #include \"SELF_Macros.h\" type , public :: SELF_DataObj !! The SELF_DataObj class is a base class for all data objects in SELF. !! A data object in SELF is a multidimensional array of data, represented !! on both host and device, that is associated with an interpolant, metadata, !! and (optionally) an equation string. !! Type extensions of the SELF_DataObj include scalars, vectors, and tensors !! in 1-D, 2-D, and 3-D using the storage patterns that are expected for !! derivative and interpolation operations defined in SELF_Lagrange.f90 !! Additionally, each extended type has the necessary attributes to store !! information on element interiors and element boundaries, both of which !! are commonly used for spectral element solvers. integer :: nVar integer :: nElem integer :: N integer :: M type ( Lagrange ), pointer :: interp type ( Metadata ), allocatable :: meta (:) type ( EquationParser ), allocatable :: eqn (:) contains ! Procedures for setting metadata for procedure , public :: SetName => SetName_DataObj procedure , public :: SetDescription => SetDescription_DataObj procedure , public :: SetUnits => SetUnits_DataObj generic , public :: SetEquation => SetEquation_DataObj procedure , private :: SetEquation_DataObj endtype SELF_DataObj integer , parameter :: selfStrongForm = 0 integer , parameter :: selfWeakDGForm = 1 integer , parameter :: selfWeakCGForm = 2 integer , parameter :: selfWeakBRForm = 3 contains ! -- DataObj -- ! subroutine SetName_DataObj ( this , ivar , name ) !! Set the name of the `ivar-th` variable implicit none class ( SELF_DataObj ), intent ( inout ) :: this integer , intent ( in ) :: ivar character ( * ), intent ( in ) :: name call this % meta ( ivar )% SetName ( name ) endsubroutine SetName_DataObj subroutine SetDescription_DataObj ( this , ivar , description ) !! Set the description of the `ivar-th` variable implicit none class ( SELF_DataObj ), intent ( inout ) :: this integer , intent ( in ) :: ivar character ( * ), intent ( in ) :: description call this % meta ( ivar )% SetDescription ( description ) endsubroutine SetDescription_DataObj subroutine SetUnits_DataObj ( this , ivar , units ) !! Set the units of the `ivar-th` variable implicit none class ( SELF_DataObj ), intent ( inout ) :: this integer , intent ( in ) :: ivar character ( * ), intent ( in ) :: units call this % meta ( ivar )% SetUnits ( units ) endsubroutine SetUnits_DataObj subroutine SetEquation_DataObj ( this , ivar , eqnChar ) !! Sets the equation parser for the `ivar-th` variable implicit none class ( SELF_DataObj ), intent ( inout ) :: this integer , intent ( in ) :: ivar character ( * ), intent ( in ) :: eqnChar this % eqn ( ivar ) = EquationParser ( trim ( eqnChar ), & ( / 'x' , 'y' , 'z' , 't' / )) endsubroutine SetEquation_DataObj endmodule SELF_Data","tags":"","loc":"sourcefile/self_data.f90.html"},{"title":"SELF_Mesh_1D.f90 – SELF","text":"Contents Modules SELF_Mesh_1D Source Code SELF_Mesh_1D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Mesh_1D use SELF_Constants use SELF_Lagrange use SELF_Data use SELF_Scalar_1D use SELF_SupportRoutines use SELF_HDF5 use SELF_Mesh ! External Libs ! use HDF5 use iso_c_binding implicit none type , extends ( SEMMesh ) :: Mesh1D integer , pointer , dimension (:,:) :: elemInfo real ( prec ), pointer , dimension (:) :: nodeCoords integer , pointer , dimension (:) :: globalNodeIDs integer , pointer , dimension (:,:) :: BCType character ( LEN = 255 ), allocatable :: BCNames (:) integer , dimension ( 2 ) :: bcid = 0 ! Boundary conditions for the left and right endpoints contains procedure , public :: Init => Init_Mesh1D procedure , public :: Free => Free_Mesh1D generic , public :: StructuredMesh => UniformBlockMesh_Mesh1D procedure , private :: UniformBlockMesh_Mesh1D procedure , public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh1D procedure , public :: Write_Mesh => Write_Mesh1D endtype Mesh1D contains subroutine Init_Mesh1D ( this , nElem , nNodes , nBCs ) implicit none class ( Mesh1D ), intent ( out ) :: this integer , intent ( in ) :: nElem integer , intent ( in ) :: nNodes integer , intent ( in ) :: nBCs this % nGeo = 1 this % nElem = nElem this % nGlobalElem = nElem this % nNodes = nNodes this % nCornerNodes = nElem * 2 this % nUniqueNodes = 0 this % nBCs = nBCs this % bcid = 0 allocate ( this % elemInfo ( 1 : 4 , 1 : nElem )) allocate ( this % nodeCoords ( 1 : nNodes )) allocate ( this % globalNodeIDs ( 1 : nNodes )) allocate ( this % BCType ( 1 : 4 , 1 : nBCs )) allocate ( this % BCNames ( 1 : nBCs )) call this % decomp % Init (. false .) endsubroutine Init_Mesh1D subroutine Free_Mesh1D ( this ) implicit none class ( Mesh1D ), intent ( inout ) :: this this % nElem = 0 this % nNodes = 0 this % nCornerNodes = 0 this % nUniqueNodes = 0 this % nBCs = 0 deallocate ( this % elemInfo ) deallocate ( this % nodeCoords ) deallocate ( this % globalNodeIDs ) deallocate ( this % BCType ) deallocate ( this % BCNames ) call this % decomp % Free () endsubroutine Free_Mesh1D subroutine UniformBlockMesh_Mesh1D ( this , nElem , x ) implicit none class ( Mesh1D ), intent ( out ) :: this integer , intent ( in ) :: nElem real ( prec ), intent ( in ) :: x ( 1 : 2 ) ! Local integer :: iel , ngeo integer :: nid , nNodes integer :: i real ( prec ) :: xU ( 1 : nElem + 1 ) type ( Lagrange ), target :: linearInterp type ( Lagrange ), target :: nGeoInterp type ( Scalar1D ) :: xLinear type ( Scalar1D ) :: xGeo ngeo = 1 nNodes = nElem * ( nGeo + 1 ) call this % Init ( nElem , nNodes , 2 ) this % quadrature = GAUSS_LOBATTO ! Set the hopr_nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem + 1 ) call linearInterp % Init ( 1 , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO ) call nGeoInterp % Init ( nGeo , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO ) ! Create a linear interpolant to interpolate to nGeo grid call xLinear % Init ( linearInterp , 1 , nElem ) call xGeo % Init ( nGeoInterp , 1 , nElem ) do iel = 1 , nElem xLinear % interior ( 1 : 2 , iel , 1 ) = xU ( iel : iel + 1 ) enddo call xLinear % GridInterp ( xGeo % interior ) ! Set the element information nid = 1 do iel = 1 , nElem this % elemInfo ( 1 , iel ) = selfLineLinear ! Element Type this % elemInfo ( 2 , iel ) = 1 ! Element Zone this % elemInfo ( 3 , iel ) = nid ! Node Index Start do i = 1 , nGeo + 1 this % nodeCoords ( nid ) = xGeo % interior ( i , iel , 1 ) nid = nid + 1 enddo this % elemInfo ( 4 , iel ) = nid - 1 ! Node Index End enddo call xLinear % Free () call xGeo % Free () call linearInterp % Free () call nGeoInterp % Free () endsubroutine UniformBlockMesh_Mesh1D subroutine ResetBoundaryConditionType_Mesh1D ( this , leftbc , rightbc ) !! This method can be used to reset all of the boundary elements !! boundary condition type to the desired value. !! !! Note that ALL physical boundaries will be set to have this boundary !! condition implicit none class ( Mesh1D ), intent ( inout ) :: this integer , intent ( in ) :: leftbc , rightbc this % bcid ( 1 ) = leftbc this % bcid ( 2 ) = rightbc endsubroutine ResetBoundaryConditionType_Mesh1D subroutine Write_Mesh1D ( this , meshFile ) ! Writes mesh output in HOPR format (serial IO only) implicit none class ( Mesh1D ), intent ( inout ) :: this character ( * ), intent ( in ) :: meshFile ! Local integer ( HID_T ) :: fileId call Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) call WriteAttribute_HDF5 ( fileId , 'nElems' , this % nElem ) call WriteAttribute_HDF5 ( fileId , 'Ngeo' , this % nGeo ) call WriteAttribute_HDF5 ( fileId , 'nBCs' , this % nBCs ) call WriteArray_HDF5 ( fileId , 'BCType' , this % bcType ) ! Read local subarray of ElemInfo call WriteArray_HDF5 ( fileId , 'ElemInfo' , this % elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs call WriteArray_HDF5 ( fileId , 'NodeCoords' , this % nodeCoords ) call WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , this % globalNodeIDs ) call Close_HDF5 ( fileID ) endsubroutine Write_Mesh1D endmodule SELF_Mesh_1D","tags":"","loc":"sourcefile/self_mesh_1d.f90.html"},{"title":"SELF_NullDGModel3D_t.f90 – SELF","text":"Contents Modules self_NullDGModel3D_t Source Code SELF_NullDGModel3D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUsLESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARIsLG IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_NullDGModel3D_t use self_model use self_dgmodel3d use self_mesh implicit none type , extends ( dgmodel3d ) :: NullDGModel3D_t ! Add any additional attributes here that are specific to your model contains !   procedure :: hbc3d_Prescribed => hbc3d_Generic_Model !   procedure :: hbc3d_Radiation => hbc3d_Generic_Model !   procedure :: hbc3d_NoNormalFlow => hbc3d_Generic_Model !   procedure :: pbc3d_Prescribed => pbc3d_Generic_Model !   procedure :: pbc3d_Radiation => pbc3d_Generic_Model !   procedure :: pbc3d_NoNormalFlow => pbc3d_Generic_Model !   procedure :: SetMetadata => SetMetadata_NullDGModel3D_t !   procedure :: pretendency => pretendency_NullDGModel3D_t !   procedure :: entropy_func => entropy_func_NullDGModel3D_t !   procedure :: flux3d => flux3d_NullDGModel3D_t !   procedure :: riemannflux3d => riemannflux3d_NullDGModel3D_t !   procedure :: source3d => source3d_NullDGModel3D_t endtype NullDGModel3D_t contains ! subroutine SetMetadata_NullDGModel3D_t(this) !   implicit none !   class(NullDGModel3D_t),intent(inout) :: this !   ! Local !   integer :: ivar !   character(LEN=3) :: ivarChar !   character(LEN=25) :: varname !   do ivar = 1,this%nvar !     write(ivarChar,'(I3.3)') ivar !     varname = \"solution\"//trim(ivarChar) !     call this%solution%SetName(ivar,varname) !     call this%solution%SetUnits(ivar,\"[null]\") !   enddo ! endsubroutine SetMetadata_NullDGModel3D_t !   pure function bcGeneric_NullDGModel3D_t(this,s) result(exts) !   class(NullDGModel3D_t),intent(in) :: this !   real(prec),intent(in) :: s(1:this%nvar) !   real(prec) :: exts(1:this%nvar) !   ! Local !   integer :: ivar !   do ivar = 1,this%nvar !     exts(ivar) = 0.0_prec !   enddo ! endfunction bcGeneric_NullDGModel3D_t ! pure function bcGrad3dGeneric_NullDGModel3D_t(this,dsdx) result(extDsdx) !   class(NullDGModel3D_t),intent(in) :: this !   real(prec),intent(in) :: dsdx(1:this%nvar,1:3) !   real(prec) :: extDsdx(1:this%nvar,1:3) !   ! Local !   integer :: ivar !   do ivar = 1,this%nvar !     extDsdx(ivar,1:3) = dsdx(ivar,1:3) !   enddo ! endfunction bcGrad3dGeneric_NullDGModel3D_t ! pure function entropy_func_NullDGModel3D_t(this,s) result(e) !   class(NullDGModel3D_t),intent(in) :: this !   real(prec),intent(in) :: s(1:this%solution%nvar) !   real(prec) :: e !   e = 0.0_prec ! endfunction entropy_func_NullDGModel3D_t ! pure function flux3d_NullDGModel3D_t(this,s,dsdx) result(flux) !   class(NullDGModel3D_t),intent(in) :: this !   real(prec),intent(in) :: s(1:this%solution%nvar) !   real(prec),intent(in) :: dsdx(1:this%solution%nvar,1:3) !   real(prec) :: flux(1:this%solution%nvar,1:3) !   flux(1:this%nvar,1:3) = 0.0_prec ! endfunction flux3d_NullDGModel3D_t ! pure function riemannflux3d_NullDGModel3D_t(this,sL,sR,dsdx,nhat) result(flux) !   class(NullDGModel3D_t),intent(in) :: this !   real(prec),intent(in) :: sL(1:this%solution%nvar) !   real(prec),intent(in) :: sR(1:this%solution%nvar) !   real(prec),intent(in) :: dsdx(1:this%solution%nvar,1:3) !   real(prec),intent(in) :: nhat(1:3) !   real(prec) :: flux(1:this%solution%nvar) !   flux(1:this%nvar) = 0.0_prec ! endfunction riemannflux3d_NullDGModel3D_t ! subroutine PreTendency_NulDGModel3D_t(this) ! !! PreTendency is a template routine that is used to house any additional calculations ! !! that you want to execute at the beginning of the tendency calculation routine. ! !! This default PreTendency simply returns back to the caller without executing any instructions ! !! ! !! The intention is to provide a method that can be overridden through type-extension, to handle ! !! any steps that need to be executed before proceeding with the usual tendency calculation methods. ! !! !   implicit none !   class(Model),intent(inout) :: this !   return ! endsubroutine PreTendency_NulDGModel3D_t ! pure function source3d_NullDGModel3D_t(this,s,dsdx) result(source) !   class(NullDGModel3D_t),intent(in) :: this !   real(prec),intent(in) :: s(1:this%solution%nvar) !   real(prec),intent(in) :: dsdx(1:this%solution%nvar,1:3) !   real(prec) :: source(1:this%solution%nvar) !   source(1:this%nvar) = 0.0_prec ! endfunction source3d_NullDGModel3D_t endmodule self_NullDGModel3D_t","tags":"","loc":"sourcefile/self_nulldgmodel3d_t.f90.html"},{"title":"SELF_Geometry_3D.f90 – SELF","text":"Contents Modules SELF_Geometry_3D Source Code SELF_Geometry_3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Geometry_3D use SELF_Constants use SELF_Lagrange use SELF_Data use SELF_Scalar_3D use SELF_Vector_3D use SELF_Tensor_3D use SELF_SupportRoutines use SELF_Mesh_3D implicit none #include \"SELF_Macros.h\" type , public :: SEMHex type ( Vector3D ) :: x ! Physical positions type ( Tensor3D ) :: dxds ! Covariant basis vectors type ( Tensor3D ) :: dsdx ! Contavariant basis vectors type ( Vector3D ) :: nHat ! Normal Vectors pointing across coordinate lines type ( Scalar3D ) :: nScale ! Boundary scale type ( Scalar3D ) :: J ! Jacobian of the transformation integer :: nElem contains procedure , public :: Init => Init_SEMHex procedure , public :: Free => Free_SEMHex procedure , public :: GenerateFromMesh => GenerateFromMesh_SEMHex procedure , public :: CalculateMetricTerms => CalculateMetricTerms_SEMHex procedure , private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex endtype SEMHex contains subroutine Init_SEMHex ( myGeom , interp , nElem ) implicit none class ( SEMHex ), intent ( out ) :: myGeom type ( Lagrange ), pointer , intent ( in ) :: interp integer , intent ( in ) :: nElem myGeom % nElem = nElem call myGeom % x % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % x % meta ( 1 )% SetName ( \"x\" ) call myGeom % dxds % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % dsdx % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % nHat % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % nScale % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) call myGeom % J % Init ( interp = interp , & nVar = 1 , & nElem = nElem ) endsubroutine Init_SEMHex subroutine Free_SEMHex ( myGeom ) implicit none class ( SEMHex ), intent ( inout ) :: myGeom call myGeom % x % Free () call myGeom % dxds % Free () call myGeom % dsdx % Free () call myGeom % nHat % Free () call myGeom % nScale % Free () call myGeom % J % Free () endsubroutine Free_SEMHex subroutine GenerateFromMesh_SEMHex ( myGeom , mesh ) implicit none class ( SEMHex ), intent ( inout ) :: myGeom type ( Mesh3D ), intent ( in ) :: mesh ! Local integer :: iel integer :: i , j , k type ( Lagrange ), target :: meshToModel type ( Vector3D ) :: xMesh call meshToModel % Init ( mesh % nGeo , mesh % quadrature , & myGeom % x % interp % N , & myGeom % x % interp % controlNodeType ) call xMesh % Init ( meshToModel , & 1 , mesh % nElem ) ! Set the element internal mesh locations do iel = 1 , mesh % nElem do k = 1 , mesh % nGeo + 1 do j = 1 , mesh % nGeo + 1 do i = 1 , mesh % nGeo + 1 xMesh % interior ( i , j , k , iel , 1 , 1 : 3 ) = mesh % nodeCoords ( 1 : 3 , i , j , k , iel ) enddo enddo enddo enddo call xMesh % GridInterp ( myGeom % x % interior ) call myGeom % x % UpdateDevice () call myGeom % x % BoundaryInterp () call myGeom % x % UpdateHost () call myGeom % CalculateMetricTerms () call xMesh % Free () call meshToModel % Free () endsubroutine GenerateFromMesh_SEMHex subroutine CalculateContravariantBasis_SEMHex ( myGeom ) implicit none class ( SEMHex ), intent ( inout ) :: myGeom ! Local integer :: iEl , i , j , k real ( prec ) :: fac real ( prec ) :: mag type ( Vector3D ) :: xlgradxm , xmgradxl type ( Vector3D ) :: curl_xlgradxm , curl_xmgradxl ! Here we use the curl invariant form from Kopriva (2006) ! to calculate the contravariant basis vectors call xlgradxm % Init ( myGeom % x % interp , 1 , myGeom % x % nElem ) call xmgradxl % Init ( myGeom % x % interp , 1 , myGeom % x % nElem ) call curl_xlgradxm % Init ( myGeom % x % interp , 1 , myGeom % x % nElem ) call curl_xmgradxl % Init ( myGeom % x % interp , 1 , myGeom % x % nElem ) ! Ja&#94;{1:3}_1 (n=1, m=2, l=3) First component of the contravariant basis vectors do iEl = 1 , myGeom % nElem do k = 1 , myGeom % dxds % interp % N + 1 do j = 1 , myGeom % dxds % interp % N + 1 do i = 1 , myGeom % dxds % interp % N + 1 xlgradxm % interior ( i , j , k , iel , 1 , 1 : 3 ) = myGeom % x % interior ( i , j , k , iel , 1 , 3 ) * myGeom % dxds % interior ( i , j , k , iel , 1 , 2 , 1 : 3 ) ! x(...,l)*dxds(...,m,1:3) ; l=3,m=2 xmgradxl % interior ( i , j , k , iel , 1 , 1 : 3 ) = myGeom % x % interior ( i , j , k , iel , 1 , 2 ) * myGeom % dxds % interior ( i , j , k , iel , 1 , 3 , 1 : 3 ) ! x(...,m)*dxds(...,l,1:3) ; l=3,m=2 enddo enddo enddo enddo call xlgradxm % Curl ( curl_xlgradxm % interior ) call xmgradxl % Curl ( curl_xmgradxl % interior ) do iEl = 1 , myGeom % nElem do k = 1 , myGeom % dxds % interp % N + 1 do j = 1 , myGeom % dxds % interp % N + 1 do i = 1 , myGeom % dxds % interp % N + 1 ! In our convention, dsdx(i,j) is contravariant vector j, component i ! dsdx(...,n,i) = Ja&#94;{i}_{n} = contravariant vector i, component n; ! Here, i = 1:3, and n=1 myGeom % dsdx % interior ( i , j , k , iel , 1 , 1 , 1 : 3 ) = 0.5_prec * ( & curl_xmgradxl % interior ( i , j , k , iel , 1 , 1 : 3 ) - & curl_xlgradxm % interior ( i , j , k , iel , 1 , 1 : 3 )) enddo enddo enddo enddo ! Ja&#94;{1:3}_2 (n=2, m=3, l=1) Second component of the contravariant basis vectors do iEl = 1 , myGeom % nElem do k = 1 , myGeom % dxds % interp % N + 1 do j = 1 , myGeom % dxds % interp % N + 1 do i = 1 , myGeom % dxds % interp % N + 1 xlgradxm % interior ( i , j , k , iel , 1 , 1 : 3 ) = myGeom % x % interior ( i , j , k , iel , 1 , 1 ) * myGeom % dxds % interior ( i , j , k , iel , 1 , 3 , 1 : 3 ) ! x(...,l)*dxds(...,m,1:3) ; l=1,m=3 xmgradxl % interior ( i , j , k , iel , 1 , 1 : 3 ) = myGeom % x % interior ( i , j , k , iel , 1 , 3 ) * myGeom % dxds % interior ( i , j , k , iel , 1 , 1 , 1 : 3 ) ! x(...,m)*dxds(...,l,1:3) ; l=1,m=3 enddo enddo enddo enddo call xlgradxm % Curl ( curl_xlgradxm % interior ) call xmgradxl % Curl ( curl_xmgradxl % interior ) do iEl = 1 , myGeom % nElem do k = 1 , myGeom % dxds % interp % N + 1 do j = 1 , myGeom % dxds % interp % N + 1 do i = 1 , myGeom % dxds % interp % N + 1 ! In our convention, dsdx(i,j) is contravariant vector j, component i ! dsdx(...,n,i) = Ja&#94;{i}_{n} = contravariant vector i, component n; ! Here, i = 1:3, and n=2 myGeom % dsdx % interior ( i , j , k , iel , 1 , 2 , 1 : 3 ) = 0.5_prec * ( & curl_xmgradxl % interior ( i , j , k , iel , 1 , 1 : 3 ) - & curl_xlgradxm % interior ( i , j , k , iel , 1 , 1 : 3 )) enddo enddo enddo enddo ! Ja&#94;{1:3}_3 (n=3, m=1, l=2) Third component of the contravariant basis vectors do iEl = 1 , myGeom % nElem do k = 1 , myGeom % dxds % interp % N + 1 do j = 1 , myGeom % dxds % interp % N + 1 do i = 1 , myGeom % dxds % interp % N + 1 xlgradxm % interior ( i , j , k , iel , 1 , 1 : 3 ) = myGeom % x % interior ( i , j , k , iel , 1 , 2 ) * myGeom % dxds % interior ( i , j , k , iel , 1 , 1 , 1 : 3 ) ! x(...,l)*dxds(...,m,1:3) ; l=2,m=1 xmgradxl % interior ( i , j , k , iel , 1 , 1 : 3 ) = myGeom % x % interior ( i , j , k , iel , 1 , 1 ) * myGeom % dxds % interior ( i , j , k , iel , 1 , 2 , 1 : 3 ) ! x(...,m)*dxds(...,l,1:3) ; l=2,m=1 enddo enddo enddo enddo call xlgradxm % Curl ( curl_xlgradxm % interior ) call xmgradxl % Curl ( curl_xmgradxl % interior ) do iEl = 1 , myGeom % nElem do k = 1 , myGeom % dxds % interp % N + 1 do j = 1 , myGeom % dxds % interp % N + 1 do i = 1 , myGeom % dxds % interp % N + 1 ! In our convention, dsdx(i,j) is contravariant vector j, component i ! dsdx(...,n,i) = Ja&#94;{i}_{n} = contravariant vector i, component n; ! Here, i = 1:3, and n=3 myGeom % dsdx % interior ( i , j , k , iel , 1 , 3 , 1 : 3 ) = 0.5_prec * ( & curl_xmgradxl % interior ( i , j , k , iel , 1 , 1 : 3 ) - & curl_xlgradxm % interior ( i , j , k , iel , 1 , 1 : 3 )) enddo enddo enddo enddo call xlgradxm % Free () call xmgradxl % Free () call curl_xlgradxm % Free () call curl_xmgradxl % Free () ! Interpolate the contravariant tensor to the boundaries call myGeom % dsdx % BoundaryInterp () ! Tensor boundary interp is not offloaded ! Now, calculate nHat (outward pointing normal) do iEl = 1 , myGeom % nElem do k = 1 , 6 do j = 1 , myGeom % J % interp % N + 1 do i = 1 , myGeom % J % interp % N + 1 if ( k == selfSide3D_Top . or . k == selfSide3D_East . or . k == selfSide3D_North ) then fac = sign ( 1.0_prec , myGeom % J % boundary ( i , j , k , iEl , 1 )) else fac = - sign ( 1.0_prec , myGeom % J % boundary ( i , j , k , iEl , 1 )) endif if ( k == 1 ) then ! Bottom mag = sqrt ( myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 , 3 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 2 , 3 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 3 , 3 ) ** 2 ) myGeom % nScale % boundary ( i , j , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) = & fac * myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 3 ) / mag ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 3 ) = & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 3 ) * fac elseif ( k == 2 ) then ! South mag = sqrt ( myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 , 2 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 2 , 2 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 3 , 2 ) ** 2 ) myGeom % nScale % boundary ( i , j , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) = & fac * myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 2 ) / mag ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 2 ) = & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 2 ) * fac elseif ( k == 3 ) then ! East mag = sqrt ( myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 , 1 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 2 , 1 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 3 , 1 ) ** 2 ) myGeom % nScale % boundary ( i , j , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) = & fac * myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 1 ) / mag ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 1 ) = & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 1 ) * fac elseif ( k == 4 ) then ! North mag = sqrt ( myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 , 2 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 2 , 2 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 3 , 2 ) ** 2 ) myGeom % nScale % boundary ( i , j , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) = & fac * myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 2 ) / mag ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 2 ) = & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 2 ) * fac elseif ( k == 5 ) then ! West mag = sqrt ( myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 , 1 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 2 , 1 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 3 , 1 ) ** 2 ) myGeom % nScale % boundary ( i , j , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) = & fac * myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 1 ) / mag ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 1 ) = & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 1 ) * fac elseif ( k == 6 ) then ! Top mag = sqrt ( myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 , 3 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 2 , 3 ) ** 2 + & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 3 , 3 ) ** 2 ) myGeom % nScale % boundary ( i , j , k , iEl , 1 ) = mag myGeom % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) = & fac * myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 3 ) / mag ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 3 ) = & myGeom % dsdx % boundary ( i , j , k , iEl , 1 , 1 : 3 , 3 ) * fac endif enddo enddo enddo enddo call myGeom % dsdx % UpdateDevice () call myGeom % nHat % UpdateDevice () call myGeom % nScale % UpdateDevice () endsubroutine CalculateContravariantBasis_SEMHex subroutine CalculateMetricTerms_SEMHex ( myGeom ) implicit none class ( SEMHex ), intent ( inout ) :: myGeom call myGeom % x % Gradient ( myGeom % dxds % interior ) call myGeom % dxds % BoundaryInterp () ! Tensor boundary interp is not offloaded to GPU call myGeom % dxds % UpdateDevice () call myGeom % dxds % Determinant ( myGeom % J % interior ) call myGeom % J % UpdateDevice () call myGeom % J % BoundaryInterp () call myGeom % J % UpdateHost () call myGeom % CalculateContravariantBasis () endsubroutine CalculateMetricTerms_SEMHex endmodule SELF_Geometry_3D","tags":"","loc":"sourcefile/self_geometry_3d.f90.html"},{"title":"SELF_Mesh_3D_t.f90 – SELF","text":"Contents Modules SELF_Mesh_3D_t Source Code SELF_Mesh_3D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Mesh_3D_t use SELF_Constants use SELF_Lagrange use SELF_SupportRoutines use SELF_HDF5 use SELF_Mesh use SELF_DomainDecomposition ! External Libs ! use HDF5 use iso_c_binding implicit none #include \"SELF_Macros.h\" ! ========================================================================= ! ! Node, Edge, Face, Element and Connectivity Standard ! ========================================================================= ! ! ! To define the element corner nodes, the side order and side connectivity, ! we follow the standard from CGNS SIDS (CFD General Notation System, ! Standard Interface Data Structures, http: //cgns.sourceforge.net/ ). ! ! Computational coordinate directions are defined as follows ! ! xi1 direction points from \"West\" (xi1=-1) to \"East\" (xi1=1) ! xi2 direction points from \"South\" (xi2=-1) to \"North\" (xi2=1) ! xi3 direction points from \"Bottom\" (xi3=-1) to \"Top\" (xi3=1) ! ! 3-D Hexahedreal Element sides are defined as ! ! Side 1 = Bottom (xi3 = -1) = [CN1, CN4, CN3, CN2] ! Side 2 = South  (xi2 = -1) = [CN1, CN2, CN6, CN5] ! Side 3 = East   (xi1 = 1) = [CN2, CN3, CN7, CN6] ! Side 4 = North  (xi2 = 1) = [CN3, CN4, CN8, CN7] ! Side 5 = West   (xi1 = -1) = [CN1, CN5, CN8, CN4] ! Side 6 = Top    (xi3 = 1) = [CN5, CN6, CN7, CN8] ! ! In 3-D, corner nodes are order counter-clockwise (looking in the -xi3 direction) from ! bottom to top. ! ! CornerNode 1 = Bottom-South-West = (-1,-1,-1) ! CornerNode 2 = Bottom-South-East = ( 1,-1,-1) ! CornerNode 3 = Bottom-North-East = ( 1, 1,-1) ! CornerNode 4 = Bottom-North-West = (-1, 1,-1) ! CornerNode 5 = Top-South-West = (-1,-1, 1) ! CornerNode 6 = Top-South-East = ( 1,-1, 1) ! CornerNode 7 = Top-North-East = ( 1, 1, 1) ! CornerNode 8 = Top-North-West = (-1, 1, 1) ! ! ! Notes: !  * cornerNode attributes have not been implemented yet ! !  * For line segments, quads, and hexes, SELF uses Legendre-Gauss-Lobatto quadrature ! ! ! Connectivity information ! !  sideInfo(1:5,iSide,iEl) ! !    1 - Side Type !    2 - Global Side ID !    3 - Neighbor Element ID !    4 - 10*( neighbor local side )  + flip !    5 - Boundary Condition ID ! ! ! ========================================================================= ! ! Side Ordering integer , parameter :: selfSide3D_Bottom = 1 integer , parameter :: selfSide3D_South = 2 integer , parameter :: selfSide3D_East = 3 integer , parameter :: selfSide3D_North = 4 integer , parameter :: selfSide3D_West = 5 integer , parameter :: selfSide3D_Top = 6 type , extends ( SEMMesh ) :: Mesh3D_t integer , pointer , dimension (:,:,:) :: sideInfo real ( prec ), pointer , dimension (:,:,:,:,:) :: nodeCoords integer , pointer , dimension (:,:) :: elemInfo integer , pointer , dimension (:,:,:,:) :: globalNodeIDs integer , pointer , dimension (:,:) :: CGNSCornerMap integer , pointer , dimension (:,:) :: sideMap integer , pointer , dimension (:,:) :: CGNSSideMap integer , pointer , dimension (:,:) :: BCType character ( LEN = 255 ), allocatable :: BCNames (:) contains procedure , public :: Init => Init_Mesh3D_t procedure , public :: Free => Free_Mesh3D_t procedure , public :: Read_HOPr => Read_HOPr_Mesh3D_t procedure , public :: ResetBoundaryConditionType => ResetBoundaryConditionType_Mesh3D_t procedure , public :: Write_Mesh => Write_Mesh3D_t procedure , public :: RecalculateFlip => RecalculateFlip_Mesh3D_t endtype Mesh3D_t integer , private :: CGNStoSELFflip ( 1 : 6 , 1 : 6 , 1 : 4 ) ! This table maps the primary side, secondary side, and CGNS flip values ! to indexing flips that are used in SELF. ! This table is used after reading in HOPr mesh information in \"RecalculateFlip\" ! SELF's flip indices correspond to the following scenarios ! ! 0    i2 = i1     j2 = j1 ! 1    i2 = N-i1   j2 = j1 ! 2    i2 = N-i1   j2 = N-j1 ! 3    i2 = i1     j2 = N-j1 ! 4    i2 = j1     j2 = i1 ! 5    i2 = N-j1   j2 = i1 ! 6    i2 = N-j1   j2 = N-i1 ! 7    i2 = j1     j2 = N-i1 ! data CGNStoSELFflip / & 4 , 0 , 0 , 1 , 4 , 0 , & 0 , 4 , 4 , 5 , 0 , 4 , & 0 , 4 , 4 , 5 , 0 , 4 , & 1 , 7 , 7 , 6 , 1 , 7 , & 4 , 0 , 0 , 1 , 4 , 0 , & 0 , 4 , 4 , 5 , 0 , 4 , & 3 , 5 , 5 , 4 , 3 , 5 , & 7 , 1 , 1 , 0 , 7 , 1 , & 7 , 1 , 1 , 0 , 7 , 1 , & 4 , 0 , 0 , 1 , 4 , 0 , & 3 , 5 , 5 , 4 , 3 , 5 , & 7 , 1 , 1 , 0 , 7 , 1 , & 6 , 2 , 2 , 3 , 6 , 2 , & 2 , 6 , 6 , 7 , 2 , 6 , & 2 , 6 , 6 , 7 , 2 , 6 , & 3 , 5 , 5 , 4 , 3 , 5 , & 6 , 2 , 2 , 3 , 6 , 2 , & 2 , 6 , 6 , 7 , 2 , 6 , & 1 , 7 , 7 , 6 , 1 , 7 , & 5 , 3 , 3 , 2 , 5 , 3 , & 5 , 3 , 3 , 2 , 5 , 3 , & 6 , 2 , 2 , 3 , 6 , 2 , & 1 , 7 , 7 , 6 , 1 , 7 , & 5 , 3 , 3 , 2 , 5 , 3 / contains subroutine Init_Mesh3D_t ( this , nGeo , nElem , nSides , nNodes , nBCs ) implicit none class ( Mesh3D_t ), intent ( inout ) :: this integer , intent ( in ) :: nGeo integer , intent ( in ) :: nElem integer , intent ( in ) :: nSides integer , intent ( in ) :: nNodes integer , intent ( in ) :: nBCs ! Local integer :: i , j , k , l this % nElem = nElem this % nGlobalElem = nElem this % nGeo = nGeo this % nSides = nSides this % nNodes = nNodes this % nCornerNodes = 0 this % nUniqueSides = 0 this % nUniqueNodes = 0 this % nBCs = nBCs allocate ( this % elemInfo ( 1 : 6 , 1 : nElem )) allocate ( this % sideInfo ( 1 : 5 , 1 : 6 , 1 : nElem )) allocate ( this % nodeCoords ( 1 : 3 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % globalNodeIDs ( 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % CGNSCornerMap ( 1 : 3 , 1 : 8 )) allocate ( this % CGNSSideMap ( 1 : 4 , 1 : 6 )) allocate ( this % sideMap ( 1 : 4 , 1 : 6 )) allocate ( this % BCType ( 1 : 4 , 1 : nBCs )) allocate ( this % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation this % CGNSCornerMap ( 1 : 3 , 1 ) = ( / 1 , 1 , 1 / ) ! Bottom-South-West this % CGNSCornerMap ( 1 : 3 , 2 ) = ( / nGeo + 1 , 1 , 1 / ) ! Bottom-South-East this % CGNSCornerMap ( 1 : 3 , 3 ) = ( / nGeo + 1 , nGeo + 1 , 1 / ) ! Bottom-North-East this % CGNSCornerMap ( 1 : 3 , 4 ) = ( / 1 , nGeo + 1 , 1 / ) ! Bottom-North-West this % CGNSCornerMap ( 1 : 3 , 5 ) = ( / 1 , 1 , nGeo + 1 / ) ! Top-South-West this % CGNSCornerMap ( 1 : 3 , 6 ) = ( / nGeo + 1 , 1 , nGeo + 1 / ) ! Top-South-East this % CGNSCornerMap ( 1 : 3 , 7 ) = ( / nGeo + 1 , nGeo + 1 , nGeo + 1 / ) ! Top-North-East this % CGNSCornerMap ( 1 : 3 , 8 ) = ( / 1 , nGeo + 1 , nGeo + 1 / ) ! Top-North-West ! Maps from local corner node id to CGNS side this % CGNSSideMap ( 1 : 4 , 1 ) = ( / 1 , 4 , 3 , 2 / ) this % CGNSSideMap ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) this % CGNSSideMap ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) this % CGNSSideMap ( 1 : 4 , 4 ) = ( / 3 , 4 , 8 , 7 / ) this % CGNSSideMap ( 1 : 4 , 5 ) = ( / 1 , 5 , 8 , 4 / ) this % CGNSSideMap ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) ! Sidemap traverses each face so that the normal ! formed by the right hand rule is the coordinate ! positive pointing normal. For east,north,and top ! this is an outward facing normal. ! For bottom, south, and west, the normal is inward ! facing. this % sideMap ( 1 : 4 , 1 ) = ( / 1 , 2 , 3 , 4 / ) ! Bottom this % sideMap ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) ! South this % sideMap ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) ! East this % sideMap ( 1 : 4 , 4 ) = ( / 4 , 3 , 7 , 8 / ) ! North this % sideMap ( 1 : 4 , 5 ) = ( / 1 , 4 , 8 , 5 / ) ! West this % sideMap ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) ! Top endsubroutine Init_Mesh3D_t subroutine Free_Mesh3D_t ( this ) implicit none class ( Mesh3D_t ), intent ( inout ) :: this this % nElem = 0 this % nSides = 0 this % nNodes = 0 this % nCornerNodes = 0 this % nUniqueSides = 0 this % nUniqueNodes = 0 this % nBCs = 0 deallocate ( this % elemInfo ) deallocate ( this % sideInfo ) deallocate ( this % nodeCoords ) deallocate ( this % globalNodeIDs ) deallocate ( this % CGNSCornerMap ) deallocate ( this % sideMap ) deallocate ( this % CGNSSideMap ) deallocate ( this % BCType ) deallocate ( this % BCNames ) call this % decomp % Free () endsubroutine Free_Mesh3D_t subroutine ResetBoundaryConditionType_Mesh3D_t ( this , bcid ) !! This method can be used to reset all of the boundary elements !! boundary condition type to the desired value. !! !! Note that ALL physical boundaries will be set to have this boundary !! condition implicit none class ( Mesh3D_t ), intent ( inout ) :: this integer , intent ( in ) :: bcid ! Local integer :: iSide , iEl , e2 do iEl = 1 , this % nElem do iSide = 1 , 6 e2 = this % sideInfo ( 3 , iSide , iEl ) if ( e2 == 0 ) then this % sideInfo ( 5 , iSide , iEl ) = bcid endif enddo enddo endsubroutine ResetBoundaryConditionType_Mesh3D_t subroutine RecalculateFlip_Mesh3D_t ( this ) implicit none class ( Mesh3D_t ), intent ( inout ) :: this ! Local integer :: e1 integer :: s1 integer :: e2 integer :: s2 integer :: cgnsFlip , selfFlip do e1 = 1 , this % nElem do s1 = 1 , 6 e2 = this % sideInfo ( 3 , s1 , e1 ) s2 = this % sideInfo ( 4 , s1 , e1 ) / 10 cgnsFlip = this % sideInfo ( 4 , s1 , e1 ) - s2 * 10 if ( e2 /= 0 ) then selfFlip = CGNStoSELFflip ( s2 , s1 , cgnsFlip ) this % sideInfo ( 4 , s1 , e1 ) = 10 * s2 + selfFlip endif enddo enddo endsubroutine RecalculateFlip_Mesh3D_t subroutine Read_HOPr_Mesh3D_t ( this , meshFile , enableDomainDecomposition ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 implicit none class ( Mesh3D_t ), intent ( out ) :: this character ( * ), intent ( in ) :: meshFile logical , intent ( in ), optional :: enableDomainDecomposition ! Local integer ( HID_T ) :: fileId integer ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) integer :: nGlobalElem integer :: firstElem integer :: firstNode integer :: firstSide integer :: nLocalElems integer :: nLocalNodes integer :: nLocalSides integer :: nUniqueSides integer :: nGeo , nBCs integer :: eid , lsid , iSide integer :: i , j , k , nid integer , dimension (:,:), allocatable :: hopr_elemInfo integer , dimension (:,:), allocatable :: hopr_sideInfo real ( prec ), dimension (:,:), allocatable :: hopr_nodeCoords integer , dimension (:), allocatable :: hopr_globalNodeIDs integer , dimension (:,:), allocatable :: bcType if ( present ( enableDomainDecomposition )) then call this % decomp % init ( enableDomainDecomposition ) else call this % decomp % init (. false .) endif if ( this % decomp % mpiEnabled ) then call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId , this % decomp % mpiComm ) else call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId ) endif call ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) call ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) call ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) call ReadAttribute_HDF5 ( fileId , 'nUniqueSides' , nUniqueSides ) ! Read BCType allocate ( bcType ( 1 : 4 , 1 : nBCs )) if ( this % decomp % mpiEnabled ) then offset (:) = 0 call ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) else call ReadArray_HDF5 ( fileId , 'BCType' , bcType ) endif ! Read local subarray of ElemInfo call this % decomp % GenerateDecomposition ( nGlobalElem , nUniqueSides ) firstElem = this % decomp % offsetElem ( this % decomp % rankId + 1 ) + 1 nLocalElems = this % decomp % offsetElem ( this % decomp % rankId + 2 ) - & this % decomp % offsetElem ( this % decomp % rankId + 1 ) ! Allocate Space for hopr_elemInfo! allocate ( hopr_elemInfo ( 1 : 6 , 1 : nLocalElems )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstElem - 1 / ) call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) else call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) endif ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo ( 5 , 1 ) + 1 nLocalNodes = hopr_elemInfo ( 6 , nLocalElems ) - hopr_elemInfo ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! allocate ( hopr_nodeCoords ( 1 : 3 , 1 : nLocalNodes ), hopr_globalNodeIDs ( 1 : nLocalNodes )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) else call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) endif ! Read local subarray of SideInfo firstSide = hopr_elemInfo ( 3 , 1 ) + 1 nLocalSides = hopr_elemInfo ( 4 , nLocalElems ) - hopr_elemInfo ( 3 , 1 ) ! Allocate space for hopr_sideInfo allocate ( hopr_sideInfo ( 1 : 5 , 1 : nLocalSides )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstSide - 1 / ) call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) else call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) endif call Close_HDF5 ( fileID ) ! ---- Done reading 3-D Mesh information ---- ! ! Load hopr data into mesh data structure call this % Init ( nGeo , nLocalElems , nLocalSides , nLocalNodes , nBCs ) ! Copy data from local arrays into this this % elemInfo = hopr_elemInfo this % nUniqueSides = nUniqueSides this % quadrature = UNIFORM ! Grab the node coordinates do eid = 1 , this % nElem do k = 1 , nGeo + 1 do j = 1 , nGeo + 1 do i = 1 , nGeo + 1 nid = i + ( nGeo + 1 ) * ( j - 1 + ( nGeo + 1 ) * ( k - 1 + ( nGeo + 1 ) * ( eid - 1 ))) this % nodeCoords ( 1 : 3 , i , j , k , eid ) = hopr_nodeCoords ( 1 : 3 , nid ) this % globalNodeIDs ( i , j , k , eid ) = hopr_globalNodeIDs ( nid ) enddo enddo enddo enddo iSide = 0 do eid = 1 , this % nElem do lsid = 1 , 6 iSide = iSide + 1 this % sideInfo ( 1 : 5 , lsid , eid ) = hopr_sideInfo ( 1 : 5 , iSide ) enddo enddo call this % RecalculateFlip () deallocate ( hopr_elemInfo , hopr_nodeCoords , hopr_globalNodeIDs , hopr_sideInfo ) endsubroutine Read_HOPr_Mesh3D_t subroutine Write_Mesh3D_t ( this , meshFile ) ! Writes mesh output in HOPR format (serial only) implicit none class ( Mesh3D_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: meshFile ! Local integer ( HID_T ) :: fileId call Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) call WriteAttribute_HDF5 ( fileId , 'nElems' , this % nElem ) call WriteAttribute_HDF5 ( fileId , 'Ngeo' , this % nGeo ) call WriteAttribute_HDF5 ( fileId , 'nBCs' , this % nBCs ) call WriteArray_HDF5 ( fileId , 'BCType' , this % bcType ) call WriteArray_HDF5 ( fileId , 'ElemInfo' , this % elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs call WriteArray_HDF5 ( fileId , 'NodeCoords' , this % nodeCoords ) call WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , this % globalNodeIDs ) ! Read local subarray of SideInfo call WriteArray_HDF5 ( fileId , 'SideInfo' , this % sideInfo ) call Close_HDF5 ( fileID ) endsubroutine Write_Mesh3D_t endmodule SELF_Mesh_3D_t","tags":"","loc":"sourcefile/self_mesh_3d_t.f90.html"},{"title":"SELF_DomainDecomposition_t.f90 – SELF","text":"Contents Modules SELF_DomainDecomposition_t Source Code SELF_DomainDecomposition_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_DomainDecomposition_t use SELF_Constants use SELF_Lagrange use SELF_SupportRoutines use mpi use iso_c_binding implicit none type DomainDecomposition_t logical :: mpiEnabled integer :: mpiComm integer :: mpiPrec integer :: rankId integer :: nRanks integer :: nElem integer :: maxMsg integer :: msgCount integer , pointer , dimension (:) :: elemToRank integer , pointer , dimension (:) :: offSetElem integer , allocatable :: requests (:) integer , allocatable :: stats (:,:) contains procedure :: Init => Init_DomainDecomposition_t procedure :: Free => Free_DomainDecomposition_t procedure :: GenerateDecomposition => GenerateDecomposition_DomainDecomposition_t procedure :: SetElemToRank => SetElemToRank_DomainDecomposition_t procedure , public :: FinalizeMPIExchangeAsync endtype DomainDecomposition_t contains subroutine Init_DomainDecomposition_t ( this , enableMPI ) #undef __FUNC__ #define __FUNC__ \"Init_DomainDecomposition_t\" implicit none class ( DomainDecomposition_t ), intent ( inout ) :: this logical , intent ( in ) :: enableMPI ! Local integer :: ierror this % mpiComm = 0 this % mpiPrec = prec this % rankId = 0 this % nRanks = 1 this % nElem = 0 this % mpiEnabled = enableMPI if ( enableMPI ) then this % mpiComm = MPI_COMM_WORLD print * , __ FILE__ , \" : Initializing MPI\" call mpi_init ( ierror ) call mpi_comm_rank ( this % mpiComm , this % rankId , ierror ) call mpi_comm_size ( this % mpiComm , this % nRanks , ierror ) print * , __ FILE__ , \" : Rank \" , this % rankId + 1 , \"/\" , this % nRanks , \" checking in.\" else print * , __ FILE__ , \" : MPI not initialized. No domain decomposition used.\" endif if ( prec == real32 ) then this % mpiPrec = MPI_FLOAT else this % mpiPrec = MPI_DOUBLE endif allocate ( this % offsetElem ( 1 : this % nRanks + 1 )) endsubroutine Init_DomainDecomposition_t subroutine Free_DomainDecomposition_t ( this ) implicit none class ( DomainDecomposition_t ), intent ( inout ) :: this ! Local integer :: ierror if ( associated ( this % offSetElem )) then deallocate ( this % offSetElem ) endif if ( associated ( this % elemToRank )) then deallocate ( this % elemToRank ) endif if ( allocated ( this % requests )) deallocate ( this % requests ) if ( allocated ( this % stats )) deallocate ( this % stats ) if ( this % mpiEnabled ) then print * , __ FILE__ , \" : Rank \" , this % rankId + 1 , \"/\" , this % nRanks , \" checking out.\" call MPI_FINALIZE ( ierror ) endif endsubroutine Free_DomainDecomposition_t subroutine GenerateDecomposition_DomainDecomposition_t ( this , nGlobalElem , maxMsg ) implicit none class ( DomainDecomposition_t ), intent ( inout ) :: this integer , intent ( in ) :: nGlobalElem integer , intent ( in ) :: maxMsg call this % setElemToRank ( nGlobalElem ) if ( allocated ( this % requests )) deallocate ( this % requests ) if ( allocated ( this % stats )) deallocate ( this % stats ) allocate ( this % requests ( 1 : maxMsg )) allocate ( this % stats ( MPI_STATUS_SIZE , 1 : maxMsg )) this % maxMsg = maxMsg print * , __ FILE__ // \" : Rank \" , this % rankId + 1 , \" : n_elements = \" , & this % offSetElem ( this % rankId + 2 ) - this % offSetElem ( this % rankId + 1 ) endsubroutine GenerateDecomposition_DomainDecomposition_t subroutine SetElemToRank_DomainDecomposition_t ( this , nElem ) implicit none class ( DomainDecomposition_t ), intent ( inout ) :: this integer , intent ( in ) :: nElem ! Local integer :: iel this % nElem = nElem allocate ( this % elemToRank ( 1 : nelem )) call DomainDecomp ( nElem , & this % nRanks , & this % offSetElem ) do iel = 1 , nElem call ElemToRank ( this % nRanks , & this % offSetElem , & iel , & this % elemToRank ( iel )) enddo endsubroutine SetElemToRank_DomainDecomposition_t subroutine DomainDecomp ( nElems , nDomains , offSetElem ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 4 implicit none integer , intent ( in ) :: nElems integer , intent ( in ) :: nDomains integer , intent ( out ) :: offsetElem ( 0 : nDomains ) ! Local integer :: nLocalElems integer :: remainElems integer :: iDom nLocalElems = nElems / nDomains remainElems = nElems - nLocalElems * nDomains do iDom = 0 , nDomains - 1 offSetElem ( iDom ) = iDom * nLocalElems + min ( iDom , remainElems ) enddo offSetElem ( nDomains ) = nElems endsubroutine DomainDecomp subroutine ElemToRank ( nDomains , offsetElem , elemID , domain ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 7 !   \"Find domain containing element index\" ! implicit none integer , intent ( in ) :: nDomains integer , intent ( in ) :: offsetElem ( 0 : nDomains ) integer , intent ( in ) :: elemID integer , intent ( out ) :: domain ! Local integer :: maxSteps integer :: low , up , mid integer :: i domain = 0 maxSteps = int ( log10 ( real ( nDomains )) / log10 ( 2.0 )) + 1 low = 0 up = nDomains - 1 if ( offsetElem ( low ) < elemID . and . elemID <= offsetElem ( low + 1 )) then domain = low elseif ( offsetElem ( up ) < elemID . and . elemID <= offsetElem ( up + 1 )) then domain = up else do i = 1 , maxSteps mid = ( up - low ) / 2 + low if ( offsetElem ( mid ) < elemID . and . elemID <= offsetElem ( mid + 1 )) then domain = mid return elseif ( elemID > offsetElem ( mid + 1 )) then low = mid + 1 else up = mid endif enddo endif endsubroutine ElemToRank subroutine FinalizeMPIExchangeAsync ( mpiHandler ) class ( DomainDecomposition_t ), intent ( inout ) :: mpiHandler ! Local integer :: ierror integer :: msgCount if ( mpiHandler % mpiEnabled ) then msgCount = mpiHandler % msgCount call MPI_WaitAll ( msgCount , & mpiHandler % requests ( 1 : msgCount ), & mpiHandler % stats ( 1 : MPI_STATUS_SIZE , 1 : msgCount ), & iError ) endif endsubroutine FinalizeMPIExchangeAsync endmodule SELF_DomainDecomposition_t","tags":"","loc":"sourcefile/self_domaindecomposition_t.f90.html"},{"title":"SELF_Tensor_3D_t.f90 – SELF","text":"Contents Modules SELF_Tensor_3D_t Source Code SELF_Tensor_3D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Tensor_3D_t use SELF_Constants use SELF_Lagrange use SELF_Metadata use FEQParse use SELF_HDF5 use SELF_Data use HDF5 use iso_c_binding implicit none type , extends ( SELF_DataObj ), public :: Tensor3D_t real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:,:) :: interior real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:,:) :: boundary real ( prec ), pointer , contiguous , dimension (:,:,:,:,:,:,:) :: extBoundary contains procedure , public :: Init => Init_Tensor3D_t procedure , public :: Free => Free_Tensor3D_t procedure , public :: BoundaryInterp => BoundaryInterp_Tensor3D_t procedure , public :: UpdateHost => UpdateHost_Tensor3D_t procedure , public :: UpdateDevice => UpdateDevice_Tensor3D_t generic , public :: Determinant => Determinant_Tensor3D_t procedure , private :: Determinant_Tensor3D_t endtype Tensor3D_t contains subroutine Init_Tensor3D_t ( this , interp , nVar , nElem ) implicit none class ( Tensor3D_t ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 3 , 1 : 3 ), & this % boundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 , 1 : 3 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 , 1 : 3 )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 9 * nVar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 9 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo endsubroutine Init_Tensor3D_t subroutine Free_Tensor3D_t ( this ) implicit none class ( Tensor3D_t ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) endsubroutine Free_Tensor3D_t subroutine UpdateHost_Tensor3D_t ( this ) implicit none class ( Tensor3D_t ), intent ( inout ) :: this endsubroutine UpdateHost_Tensor3D_t subroutine UpdateDevice_Tensor3D_t ( this ) implicit none class ( Tensor3D_t ), intent ( inout ) :: this endsubroutine UpdateDevice_Tensor3D_t subroutine BoundaryInterp_Tensor3D_t ( this ) implicit none class ( Tensor3D_t ), intent ( inout ) :: this ! Local integer :: i , j , ii , idir , jdir , iel , ivar real ( prec ) :: fbb , fbs , fbe , fbn , fbw , fbt do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & iel = 1 : this % nelem , ivar = 1 : this % nvar , & idir = 1 : 3 , jdir = 1 : 3 ) fbb = 0.0_prec fbs = 0.0_prec fbe = 0.0_prec fbn = 0.0_prec fbw = 0.0_prec fbt = 0.0_prec do ii = 1 , this % N + 1 fbb = fbb + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , j , ii , iel , ivar , idir , jdir ) ! Bottom fbs = fbs + this % interp % bMatrix ( ii , 1 ) * this % interior ( i , ii , j , iel , ivar , idir , jdir ) ! South fbe = fbe + this % interp % bMatrix ( ii , 2 ) * this % interior ( ii , i , j , iel , ivar , idir , jdir ) ! East fbn = fbn + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , ii , j , iel , ivar , idir , jdir ) ! North fbw = fbw + this % interp % bMatrix ( ii , 1 ) * this % interior ( ii , i , j , iel , ivar , idir , jdir ) ! West fbt = fbt + this % interp % bMatrix ( ii , 2 ) * this % interior ( i , j , ii , iel , ivar , idir , jdir ) ! Top enddo this % boundary ( i , j , 1 , iel , ivar , idir , jdir ) = fbb this % boundary ( i , j , 2 , iel , ivar , idir , jdir ) = fbs this % boundary ( i , j , 3 , iel , ivar , idir , jdir ) = fbe this % boundary ( i , j , 4 , iel , ivar , idir , jdir ) = fbn this % boundary ( i , j , 5 , iel , ivar , idir , jdir ) = fbw this % boundary ( i , j , 6 , iel , ivar , idir , jdir ) = fbt enddo endsubroutine BoundaryInterp_Tensor3D_t subroutine Determinant_Tensor3D_t ( this , det ) implicit none class ( Tensor3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: det ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iEl , iVar , i , j , k do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar ) det ( i , j , k , iEl , iVar ) = & this % interior ( i , j , k , iEl , iVar , 1 , 1 ) * & ( this % interior ( i , j , k , iEl , iVar , 2 , 2 ) * & this % interior ( i , j , k , iEl , iVar , 3 , 3 ) - & this % interior ( i , j , k , iEl , iVar , 2 , 3 ) * & this % interior ( i , j , k , iEl , iVar , 3 , 2 )) - & this % interior ( i , j , k , iEl , iVar , 2 , 1 ) * & ( this % interior ( i , j , k , iEl , iVar , 1 , 2 ) * & this % interior ( i , j , k , iEl , iVar , 3 , 3 ) - & this % interior ( i , j , k , iEl , iVar , 1 , 3 ) * & this % interior ( i , j , k , iEl , iVar , 3 , 2 )) + & this % interior ( i , j , k , iEl , iVar , 3 , 1 ) * & ( this % interior ( i , j , k , iEl , iVar , 1 , 2 ) * & this % interior ( i , j , k , iEl , iVar , 2 , 3 ) - & this % interior ( i , j , k , iEl , iVar , 1 , 3 ) * & this % interior ( i , j , k , iEl , iVar , 2 , 2 )) enddo endsubroutine Determinant_Tensor3D_t endmodule SELF_Tensor_3D_t","tags":"","loc":"sourcefile/self_tensor_3d_t.f90.html"},{"title":"SELF_advection_diffusion_1d_t.f90 – SELF","text":"Contents Modules self_advection_diffusion_1d_t Source Code SELF_advection_diffusion_1d_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUsLESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARIsLG IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_advection_diffusion_1d_t use self_model use self_dgmodel1d use self_mesh implicit none type , extends ( dgmodel1d ) :: advection_diffusion_1d_t real ( prec ) :: nu ! diffusion coefficient real ( prec ) :: u ! constant velocity contains procedure :: riemannflux1d => riemannflux1d_advection_diffusion_1d_t procedure :: flux1d => flux1d_advection_diffusion_1d_t procedure :: entropy_func => entropy_func_advection_diffusion_1d_t endtype advection_diffusion_1d_t contains pure function entropy_func_advection_diffusion_1d_t ( this , s ) result ( e ) class ( advection_diffusion_1d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ) :: e ! Local integer :: ivar e = 0.0_prec do ivar = 1 , this % solution % nvar e = e + 0.5_prec * s ( ivar ) * s ( ivar ) enddo endfunction entropy_func_advection_diffusion_1d_t pure function riemannflux1d_advection_diffusion_1d_t ( this , sL , sR , dsdx , nhat ) result ( flux ) class ( advection_diffusion_1d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: sL ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: sR ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: nhat real ( prec ) :: flux ( 1 : this % solution % nvar ) ! Local integer :: ivar do ivar = 1 , this % solution % nvar flux ( ivar ) = 0.5_prec * ( this % u * nhat * ( sL ( ivar ) + sR ( ivar )) + & abs ( this % u * nhat ) * ( sL ( ivar ) - sR ( ivar ))) - & ! advective flux this % nu * dsdx ( ivar ) * nhat ! diffusive flux enddo endfunction riemannflux1d_advection_diffusion_1d_t pure function flux1d_advection_diffusion_1d_t ( this , s , dsdx ) result ( flux ) class ( advection_diffusion_1d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % solution % nvar ) real ( prec ) :: flux ( 1 : this % solution % nvar ) ! Local integer :: ivar do ivar = 1 , this % solution % nvar flux ( ivar ) = this % u * s ( ivar ) - this % nu * dsdx ( ivar ) ! advective flux + diffusive flux enddo endfunction flux1d_advection_diffusion_1d_t endmodule self_advection_diffusion_1d_t","tags":"","loc":"sourcefile/self_advection_diffusion_1d_t.f90.html"},{"title":"SELF_DGModel1D_t.f90 – SELF","text":"Contents Modules SELF_DGModel1D_t Source Code SELF_DGModel1D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_DGModel1D_t use SELF_SupportRoutines use SELF_Metadata use SELF_Mesh_1D use SELF_MappedScalar_1D use SELF_HDF5 use HDF5 use FEQParse use SELF_Model implicit none #include \"SELF_Macros.h\" type , extends ( Model ) :: DGModel1D_t type ( MappedScalar1D ) :: solution type ( MappedScalar1D ) :: solutionGradient type ( MappedScalar1D ) :: flux type ( MappedScalar1D ) :: source type ( MappedScalar1D ) :: fluxDivergence type ( MappedScalar1D ) :: dSdt type ( MappedScalar1D ) :: workSol type ( Mesh1D ), pointer :: mesh type ( Geometry1D ), pointer :: geometry contains procedure :: Init => Init_DGModel1D_t procedure :: SetMetadata => SetMetadata_DGModel1D_t procedure :: Free => Free_DGModel1D_t procedure :: CalculateEntropy => CalculateEntropy_DGModel1D_t procedure :: BoundaryFlux => BoundaryFlux_DGModel1D_t procedure :: FluxMethod => fluxmethod_DGModel1D_t procedure :: SourceMethod => sourcemethod_DGModel1D_t procedure :: SetBoundaryCondition => setboundarycondition_DGModel1D_t procedure :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D_t procedure :: UpdateSolution => UpdateSolution_DGModel1D_t procedure :: UpdateGRK2 => UpdateGRK2_DGModel1D_t procedure :: UpdateGRK3 => UpdateGRK3_DGModel1D_t procedure :: UpdateGRK4 => UpdateGRK4_DGModel1D_t procedure :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D_t procedure :: CalculateTendency => CalculateTendency_DGModel1D_t generic :: SetSolution => SetSolutionFromChar_DGModel1D_t , & SetSolutionFromEqn_DGModel1D_t procedure , private :: SetSolutionFromChar_DGModel1D_t procedure , private :: SetSolutionFromEqn_DGModel1D_t procedure :: ReadModel => Read_DGModel1D_t procedure :: WriteModel => Write_DGModel1D_t procedure :: WriteTecplot => WriteTecplot_DGModel1D_t endtype DGModel1D_t contains subroutine Init_DGModel1D_t ( this , nvar , mesh , geometry ) implicit none class ( DGModel1D_t ), intent ( out ) :: this integer , intent ( in ) :: nvar type ( Mesh1D ), intent ( in ), target :: mesh type ( Geometry1D ), intent ( in ), target :: geometry this % mesh => mesh this % geometry => geometry this % nvar = nvar call this % solution % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % workSol % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % dSdt % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % solutionGradient % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % flux % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % source % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % fluxDivergence % Init ( geometry % x % interp , nVar , this % mesh % nElem ) call this % solution % AssociateGeometry ( geometry ) call this % solutionGradient % AssociateGeometry ( geometry ) call this % flux % AssociateGeometry ( geometry ) call this % fluxDivergence % AssociateGeometry ( geometry ) call this % SetMetadata () endsubroutine Init_DGModel1D_t subroutine SetMetadata_DGModel1D_t ( this ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! Local integer :: ivar character ( LEN = 3 ) :: ivarChar character ( LEN = 25 ) :: varname do ivar = 1 , this % nvar write ( ivarChar , '(I3.3)' ) ivar varname = \"solution\" // trim ( ivarChar ) call this % solution % SetName ( ivar , varname ) call this % solution % SetUnits ( ivar , \"[null]\" ) enddo endsubroutine SetMetadata_DGModel1D_t subroutine Free_DGModel1D_t ( this ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this call this % solution % DissociateGeometry () call this % solutionGradient % DissociateGeometry () call this % flux % DissociateGeometry () call this % fluxDivergence % DissociateGeometry () call this % solution % Free () call this % workSol % Free () call this % dSdt % Free () call this % solutionGradient % Free () call this % flux % Free () call this % source % Free () call this % fluxDivergence % Free () endsubroutine Free_DGModel1D_t subroutine SetSolutionFromEqn_DGModel1D_t ( this , eqn ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this type ( EquationParser ), intent ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local integer :: iVar ! Copy the equation parser do iVar = 1 , this % solution % nVar call this % solution % SetEquation ( ivar , eqn ( iVar )% equation ) enddo call this % solution % SetInteriorFromEquation ( this % t ) call this % solution % BoundaryInterp () endsubroutine SetSolutionFromEqn_DGModel1D_t subroutine SetSolutionFromChar_DGModel1D_t ( this , eqnChar ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this character ( LEN = SELF_EQUATION_LENGTH ), intent ( in ) :: eqnChar ( 1 : this % solution % nVar ) ! Local integer :: iVar do iVar = 1 , this % solution % nVar print * , iVar , eqnChar ( iVar ) call this % solution % SetEquation ( ivar , eqnChar ( iVar )) enddo call this % solution % SetInteriorFromEquation ( this % t ) call this % solution % BoundaryInterp () endsubroutine SetSolutionFromChar_DGModel1D_t subroutine UpdateSolution_DGModel1D_t ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) implicit none class ( DGModel1D_t ), intent ( inout ) :: this real ( prec ), optional , intent ( in ) :: dt ! Local real ( prec ) :: dtLoc integer :: i , iEl , iVar if ( present ( dt )) then dtLoc = dt else dtLoc = this % dt endif do concurrent ( i = 1 : this % solution % N + 1 , iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % solution % interior ( i , iEl , iVar ) = & this % solution % interior ( i , iEl , iVar ) + & dtLoc * this % dSdt % interior ( i , iEl , iVar ) enddo endsubroutine UpdateSolution_DGModel1D_t subroutine UpdateGRK2_DGModel1D_t ( this , m ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , iEl , iVar do concurrent ( i = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , iEl , iVar ) = rk2_a ( m ) * & this % workSol % interior ( i , iEl , iVar ) + & this % dSdt % interior ( i , iEl , iVar ) this % solution % interior ( i , iEl , iVar ) = & this % solution % interior ( i , iEl , iVar ) + & rk2_g ( m ) * this % dt * this % workSol % interior ( i , iEl , iVar ) enddo endsubroutine UpdateGRK2_DGModel1D_t subroutine UpdateGRK3_DGModel1D_t ( this , m ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , iEl , iVar do concurrent ( i = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , iEl , iVar ) = rk3_a ( m ) * & this % workSol % interior ( i , iEl , iVar ) + & this % dSdt % interior ( i , iEl , iVar ) this % solution % interior ( i , iEl , iVar ) = & this % solution % interior ( i , iEl , iVar ) + & rk3_g ( m ) * this % dt * this % workSol % interior ( i , iEl , iVar ) enddo endsubroutine UpdateGRK3_DGModel1D_t subroutine UpdateGRK4_DGModel1D_t ( this , m ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: i , iEl , iVar do concurrent ( i = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % workSol % interior ( i , iEl , iVar ) = rk4_a ( m ) * & this % workSol % interior ( i , iEl , iVar ) + & this % dSdt % interior ( i , iEl , iVar ) this % solution % interior ( i , iEl , iVar ) = & this % solution % interior ( i , iEl , iVar ) + & rk4_g ( m ) * this % dt * this % workSol % interior ( i , iEl , iVar ) enddo endsubroutine UpdateGRK4_DGModel1D_t subroutine CalculateSolutionGradient_DGModel1D_t ( this ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this call this % solution % AverageSides () this % solution % boundarynormal ( 1 ,:,:) = - this % solution % avgBoundary ( 1 ,:,:) ! Account for left facing normal this % solution % boundarynormal ( 2 ,:,:) = this % solution % avgBoundary ( 2 ,:,:) ! Account for right facing normal call this % solution % MappedDGDerivative ( this % solutionGradient % interior ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp () ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh ) endsubroutine CalculateSolutionGradient_DGModel1D_t subroutine CalculateEntropy_DGModel1D_t ( this ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! Local integer :: iel , i , ivar real ( prec ) :: e , s ( 1 : this % solution % nvar ), J e = 0.0_prec do iel = 1 , this % geometry % nelem do i = 1 , this % solution % interp % N + 1 J = this % geometry % dxds % interior ( i , iel , 1 ) s ( 1 : this % solution % nvar ) = this % solution % interior ( i , iel , 1 : this % solution % nvar ) e = e + this % entropy_func ( s ) * J enddo enddo this % entropy = e endsubroutine CalculateEntropy_DGModel1D_t subroutine setboundarycondition_DGModel1D_t ( this ) ! Here, we use the pre-tendency method to calculate the ! derivative of the solution using a bassi-rebay method ! We then do a boundary interpolation and side exchange ! on the gradient field implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! local integer :: ivar integer :: N , nelem real ( prec ) :: x nelem = this % geometry % nelem ! number of elements in the mesh N = this % solution % interp % N ! polynomial degree ! left-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 1 , 1 , 1 ) this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % hbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % hbc1d_Radiation ( this % solution % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % hbc1d_NoNormalFlow ( this % solution % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = this % solution % boundary ( 2 , nelem , 1 : this % nvar ) endif ! right-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 2 , nelem , 1 ) this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % hbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % hbc1d_Radiation ( this % solution % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % hbc1d_NoNormalFlow ( this % solution % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = this % solution % boundary ( 1 , 1 , 1 : this % nvar ) endif endsubroutine setboundarycondition_DGModel1D_t subroutine setgradientboundarycondition_DGModel1D_t ( this ) ! Here, we set the boundary conditions for the ! solution and the solution gradient at the left ! and right most boundaries. ! ! Here, we use periodic boundary conditions implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! local real ( prec ) :: x integer :: nelem nelem = this % geometry % nelem ! number of elements in the mesh ! left-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 1 , 1 , 1 ) this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % pbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % pbc1d_Radiation ( this % solutionGradient % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % pbc1d_NoNormalFlow ( this % solutionGradient % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = this % solutionGradient % boundary ( 2 , nelem , 1 : this % nvar ) endif ! right-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 2 , nelem , 1 ) this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % pbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % pbc1d_Radiation ( this % solutionGradient % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % pbc1d_NoNormalFlow ( this % solutionGradient % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = this % solutionGradient % boundary ( 1 , 1 , 1 : this % nvar ) endif endsubroutine setgradientboundarycondition_DGModel1D_t subroutine BoundaryFlux_DGModel1D_t ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: iside real ( prec ) :: fin ( 1 : this % solution % nvar ) real ( prec ) :: fout ( 1 : this % solution % nvar ) real ( prec ) :: dfdx ( 1 : this % solution % nvar ), nhat do iel = 1 , this % mesh % nelem do iside = 1 , 2 ! set the normal velocity if ( iside == 1 ) then nhat = - 1.0_prec else nhat = 1.0_prec endif fin = this % solution % boundary ( iside , iel , 1 : this % solution % nvar ) ! interior solution fout = this % solution % extboundary ( iside , iel , 1 : this % solution % nvar ) ! exterior solution dfdx = this % solutionGradient % avgboundary ( iside , iel , 1 : this % solution % nvar ) ! average solution gradient (with direction taken into account) this % flux % boundarynormal ( iside , iel , 1 : this % solution % nvar ) = & this % riemannflux1d ( fin , fout , dfdx , nhat ) enddo enddo endsubroutine BoundaryFlux_DGModel1D_t subroutine fluxmethod_DGModel1D_t ( this ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: i real ( prec ) :: f ( 1 : this % solution % nvar ), dfdx ( 1 : this % solution % nvar ) do iel = 1 , this % mesh % nelem do i = 1 , this % solution % interp % N + 1 f = this % solution % interior ( i , iel , 1 : this % solution % nvar ) dfdx = this % solutionGradient % interior ( i , iel , 1 : this % solution % nvar ) this % flux % interior ( i , iel , 1 : this % solution % nvar ) = & this % flux1d ( f , dfdx ) enddo enddo endsubroutine fluxmethod_DGModel1D_t subroutine sourcemethod_DGModel1D_t ( this ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: i real ( prec ) :: f ( 1 : this % solution % nvar ), dfdx ( 1 : this % solution % nvar ) do iel = 1 , this % mesh % nelem do i = 1 , this % solution % interp % N + 1 f = this % solution % interior ( i , iel , 1 : this % solution % nvar ) dfdx = this % solutionGradient % interior ( i , iel , 1 : this % solution % nvar ) this % source % interior ( i , iel , 1 : this % solution % nvar ) = & this % source1d ( f , dfdx ) enddo enddo endsubroutine sourcemethod_DGModel1D_t subroutine CalculateTendency_DGModel1D_t ( this ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this ! Local integer :: i , iEl , iVar call this % solution % BoundaryInterp () call this % solution % SideExchange ( this % mesh ) call this % PreTendency () ! User-supplied call this % SetBoundaryCondition () ! User-supplied if ( this % gradient_enabled ) then call this % CalculateSolutionGradient () call this % SetGradientBoundaryCondition () ! User-supplied call this % solutionGradient % AverageSides () endif call this % SourceMethod () ! User supplied call this % BoundaryFlux () ! User supplied call this % FluxMethod () ! User supplied call this % flux % MappedDGDerivative ( this % fluxDivergence % interior ) do concurrent ( i = 1 : this % solution % N + 1 , & iel = 1 : this % mesh % nElem , ivar = 1 : this % solution % nVar ) this % dSdt % interior ( i , iEl , iVar ) = & this % source % interior ( i , iEl , iVar ) - & this % fluxDivergence % interior ( i , iEl , iVar ) enddo endsubroutine CalculateTendency_DGModel1D_t subroutine Write_DGModel1D_t ( this , fileName ) #undef __FUNC__ #define __FUNC__ \"Write_DGModel1D_t\" implicit none class ( DGModel1D_t ), intent ( inout ) :: this character ( * ), optional , intent ( in ) :: fileName ! Local integer ( HID_T ) :: fileId type ( Scalar1D ) :: solution type ( Scalar1D ) :: x type ( Lagrange ), target :: interp character ( LEN = self_FileNameLength ) :: pickupFile character ( 13 ) :: timeStampString write ( timeStampString , '(I13.13)' ) this % ioIterate if ( present ( filename )) then pickupFile = trim ( filename ) else pickupFile = 'solution.' // timeStampString // '.h5' endif INFO ( \"Writing pickup file : \" // trim ( pickupFile )) call this % solution % UpdateHost () call Open_HDF5 ( pickupFile , H5F_ACC_TRUNC_F , fileId ) ! Write the interpolant to the file INFO ( \"Writing interpolant data to file\" ) call this % solution % interp % WriteHDF5 ( fileId ) ! In this section, we write the solution and geometry on the control (quadrature) grid ! which can be used for model pickup runs or post-processing ! Write the model state to file INFO ( \"Writing control grid solution to file\" ) call CreateGroup_HDF5 ( fileId , '/controlgrid' ) call this % solution % WriteHDF5 ( fileId , '/controlgrid/solution' ) ! Write the geometry to file INFO ( \"Writing control grid  geometry to file\" ) call CreateGroup_HDF5 ( fileId , '/controlgrid/geometry' ) call this % geometry % x % WriteHDF5 ( fileId , '/controlgrid/geometry/x' ) ! -- END : writing solution on control grid -- ! ! Interpolate the solution to a grid for plotting results ! Create an interpolant for the uniform grid call interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) call solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) call x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid call this % geometry % x % GridInterp ( x % interior ) ! Map the solution to the target grid call this % solution % GridInterp ( solution % interior ) ! Write the model state to file INFO ( \"Writing target grid solution to file\" ) call CreateGroup_HDF5 ( fileId , '/targetgrid' ) call solution % WriteHDF5 ( fileId , '/targetgrid/solution' ) ! Write the geometry to file INFO ( \"Writing target grid geometry to file\" ) call CreateGroup_HDF5 ( fileId , '/targetgrid/geometry' ) call x % WriteHDF5 ( fileId , '/targetgrid/geometry/x' ) call Close_HDF5 ( fileId ) call x % Free () call solution % Free () call interp % Free () endsubroutine Write_DGModel1D_t subroutine Read_DGModel1D_t ( this , fileName ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: fileName ! Local integer ( HID_T ) :: fileId integer ( HID_T ) :: solOffset ( 1 : 3 ) integer :: firstElem integer :: N call Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) call ReadArray_HDF5 ( fileId , '/controlgrid/solution/interior' , this % solution % interior ) call Close_HDF5 ( fileId ) call this % solution % UpdateDevice () endsubroutine Read_DGModel1D_t subroutine WriteTecplot_DGModel1D_t ( this , filename ) implicit none class ( DGModel1D_t ), intent ( inout ) :: this character ( * ), intent ( in ), optional :: filename ! Local character ( 8 ) :: zoneID integer :: fUnit integer :: iEl , i , iVar character ( LEN = self_FileNameLength ) :: tecFile character ( LEN = self_TecplotHeaderLength ) :: tecHeader character ( LEN = self_FormatLength ) :: fmat character ( 13 ) :: timeStampString character ( 5 ) :: rankString type ( Scalar1D ) :: solution type ( Scalar1D ) :: x type ( Lagrange ), target :: interp if ( present ( filename )) then tecFile = filename else ! Create a 0-padded integer for the output iterate write ( timeStampString , '(I13.13)' ) this % ioIterate ! Increment the ioIterate this % ioIterate = this % ioIterate + 1 tecFile = 'solution.' // timeStampString // '.curve' endif call this % solution % UpdateHost () ! Create an interpolant for the uniform grid call interp % Init ( this % solution % interp % M , & this % solution % interp % targetNodeType , & this % solution % interp % N , & this % solution % interp % controlNodeType ) call solution % Init ( interp , & this % solution % nVar , this % solution % nElem ) call x % Init ( interp , 1 , this % solution % nElem ) ! Map the mesh positions to the target grid call this % geometry % x % GridInterp ( x % Interior ) ! Map the solution to the target grid call this % solution % GridInterp ( solution % interior ) fmat = '(2(ES16.7E3,1x))' ! Let's write some tecplot!! open ( UNIT = NEWUNIT ( fUnit ), & FILE = trim ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) do iVar = 1 , this % solution % nVar write ( tecHeader , '(E15.6)' ) this % t tecHeader = \"#TIME \" // trim ( tecHeader ) write ( fUnit , * ) trim ( tecHeader ) tecHeader = \"#\" // trim ( this % solution % meta ( iVar )% name ) // \" vs position\" write ( fUnit , * ) trim ( tecHeader ) do iEl = 1 , this % solution % nElem do i = 1 , this % solution % interp % M + 1 write ( fUnit , fmat ) x % interior ( i , iEl , 1 ), & solution % interior ( i , iEl , iVar ) enddo enddo enddo close ( UNIT = fUnit ) call x % Free () call solution % Free () call interp % Free () endsubroutine WriteTecplot_DGModel1D_t endmodule SELF_DGModel1D_t","tags":"","loc":"sourcefile/self_dgmodel1d_t.f90.html"},{"title":"SELF_advection_diffusion_3d_t.f90 – SELF","text":"Contents Modules self_advection_diffusion_3d_t Source Code SELF_advection_diffusion_3d_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_advection_diffusion_3d_t use self_model use self_dgmodel3d use self_mesh implicit none type , extends ( dgmodel3d ) :: advection_diffusion_3d_t real ( prec ) :: nu ! diffusion coefficient real ( prec ) :: u ! constant x-component of velocity real ( prec ) :: v ! constant y-component of velocity real ( prec ) :: w ! constant z-component of velocity contains procedure :: riemannflux3d => riemannflux3d_advection_diffusion_3d_t procedure :: flux3d => flux3d_advection_diffusion_3d_t procedure :: entropy_func => entropy_func_advection_diffusion_3d_t endtype advection_diffusion_3d_t contains pure function entropy_func_advection_diffusion_3d_t ( this , s ) result ( e ) class ( advection_diffusion_3d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ) :: e ! Local integer :: ivar e = 0.0_prec do ivar = 1 , this % solution % nvar e = e + 0.5_prec * s ( ivar ) * s ( ivar ) enddo endfunction entropy_func_advection_diffusion_3d_t pure function flux3d_advection_diffusion_3d_t ( this , s , dsdx ) result ( flux ) class ( advection_diffusion_3d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: s ( 1 : this % solution % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % solution % nvar , 1 : 3 ) real ( prec ) :: flux ( 1 : this % solution % nvar , 1 : 3 ) ! Local integer :: ivar do ivar = 1 , this % solution % nvar flux ( ivar , 1 ) = this % u * s ( ivar ) - this % nu * dsdx ( ivar , 1 ) ! advective flux + diffusive flux flux ( ivar , 2 ) = this % v * s ( ivar ) - this % nu * dsdx ( ivar , 2 ) ! advective flux + diffusive flux flux ( ivar , 3 ) = this % w * s ( ivar ) - this % nu * dsdx ( ivar , 3 ) ! advective flux + diffusive flux enddo endfunction flux3d_advection_diffusion_3d_t pure function riemannflux3d_advection_diffusion_3d_t ( this , sL , sR , dsdx , nhat ) result ( flux ) class ( advection_diffusion_3d_t ), intent ( in ) :: this real ( prec ), intent ( in ) :: sL ( 1 : this % nvar ) real ( prec ), intent ( in ) :: sR ( 1 : this % nvar ) real ( prec ), intent ( in ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ), intent ( in ) :: nhat ( 1 : 3 ) real ( prec ) :: flux ( 1 : this % nvar ) ! Local integer :: ivar real ( prec ) :: un , dsdn un = this % u * nhat ( 1 ) + this % v * nhat ( 2 ) + this % w * nhat ( 3 ) do ivar = 1 , this % nvar dsdn = dsdx ( ivar , 1 ) * nhat ( 1 ) + dsdx ( ivar , 2 ) * nhat ( 2 ) + dsdx ( ivar , 3 ) * nhat ( 3 ) flux ( ivar ) = 0.5_prec * ( & ( sL ( ivar ) + sR ( ivar )) + abs ( un ) * ( sL ( ivar ) - sR ( ivar ))) - & ! advective flux this % nu * dsdn enddo endfunction riemannflux3d_advection_diffusion_3d_t endmodule self_advection_diffusion_3d_t","tags":"","loc":"sourcefile/self_advection_diffusion_3d_t.f90.html"},{"title":"SELF_Scalar_1D_t.f90 – SELF","text":"Contents Modules SELF_Scalar_1D_t Source Code SELF_Scalar_1D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Scalar_1D_t use SELF_Constants use SELF_Lagrange use SELF_Metadata use FEQParse use SELF_Data use SELF_HDF5 use HDF5 use iso_c_binding implicit none #include \"SELF_Macros.h\" ! ---------------------- Scalars ---------------------- ! type , extends ( SELF_DataObj ), public :: Scalar1D_t real ( prec ), pointer , contiguous , dimension (:,:,:) :: interior real ( prec ), pointer , contiguous , dimension (:,:,:) :: boundary real ( prec ), pointer , contiguous , dimension (:,:,:) :: boundarynormal real ( prec ), pointer , contiguous , dimension (:,:,:) :: extBoundary real ( prec ), pointer , contiguous , dimension (:,:,:) :: avgBoundary contains procedure , public :: Init => Init_Scalar1D_t procedure , public :: Free => Free_Scalar1D_t procedure , public :: UpdateHost => UpdateHost_Scalar1D_t procedure , public :: UpdateDevice => UpdateDevice_Scalar1D_t procedure , public :: AverageSides => AverageSides_Scalar1D_t procedure , public :: BoundaryInterp => BoundaryInterp_Scalar1D_t generic , public :: GridInterp => GridInterp_Scalar1D_t procedure , private :: GridInterp_Scalar1D_t generic , public :: Derivative => Derivative_Scalar1D_t procedure , private :: Derivative_Scalar1D_t generic , public :: WriteHDF5 => WriteHDF5_Scalar1D_t procedure , private :: WriteHDF5_Scalar1D_t endtype Scalar1D_t contains ! -- Scalar1D_t -- ! subroutine Init_Scalar1D_t ( this , interp , nVar , nElem ) implicit none class ( Scalar1D_t ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : nelem , 1 : nvar ), & this % boundary ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : 2 , 1 : nelem , 1 : nvar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % boundarynormal = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) endsubroutine Init_Scalar1D_t subroutine Free_Scalar1D_t ( this ) implicit none class ( Scalar1D_t ), intent ( inout ) :: this this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % boundarynormal ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) endsubroutine Free_Scalar1D_t subroutine UpdateHost_Scalar1D_t ( this ) implicit none class ( Scalar1D_t ), intent ( inout ) :: this endsubroutine UpdateHost_Scalar1D_t subroutine UpdateDevice_Scalar1D_t ( this ) implicit none class ( Scalar1D_t ), intent ( inout ) :: this endsubroutine UpdateDevice_Scalar1D_t subroutine AverageSides_Scalar1D_t ( this ) implicit none class ( Scalar1D_t ), intent ( inout ) :: this ! Local integer :: iel integer :: ivar do concurrent ( iel = 1 : this % nElem , ivar = 1 : this % nVar ) ! Left side - we account for the -\\hat{x} normal this % avgboundary ( 1 , iel , ivar ) = 0.5_prec * ( & this % boundary ( 1 , iel , ivar ) + & this % extBoundary ( 1 , iel , ivar )) ! Right side - we account for the +\\hat{x} normal this % avgboundary ( 2 , iel , ivar ) = 0.5_prec * ( & this % boundary ( 2 , iel , ivar ) + & this % extBoundary ( 2 , iel , ivar )) enddo endsubroutine AverageSides_Scalar1D_t subroutine BoundaryInterp_Scalar1D_t ( this ) implicit none class ( Scalar1D_t ), intent ( inout ) :: this ! Local integer :: ii , iel , ivar real ( prec ) :: fbl , fbr do concurrent ( iel = 1 : this % nElem , ivar = 1 : this % nVar ) fbl = 0.0_prec fbr = 0.0_prec do ii = 1 , this % N + 1 fbl = fbl + this % interp % bMatrix ( ii , 1 ) * this % interior ( ii , iel , ivar ) ! West fbr = fbr + this % interp % bMatrix ( ii , 2 ) * this % interior ( ii , iel , ivar ) ! East enddo this % boundary ( 1 , iel , ivar ) = fbl this % boundary ( 2 , iel , ivar ) = fbr enddo endsubroutine BoundaryInterp_Scalar1D_t subroutine GridInterp_Scalar1D_t ( this , f ) implicit none class ( Scalar1D_t ), intent ( in ) :: this real ( prec ), intent ( inout ) :: f ( 1 : this % M + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: iel , ivar , i , ii real ( prec ) :: floc do concurrent ( i = 1 : this % M + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) floc = 0.0_prec do ii = 1 , this % N + 1 floc = floc + this % interp % iMatrix ( ii , i ) * this % interior ( ii , iel , ivar ) enddo f ( i , iel , ivar ) = floc enddo endsubroutine GridInterp_Scalar1D_t subroutine Derivative_Scalar1D_t ( this , df ) implicit none class ( Scalar1D_t ), intent ( in ) :: this real ( prec ), intent ( inout ) :: df ( 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar ) ! Local integer :: i , ii , iel , ivar real ( prec ) :: dfloc do concurrent ( i = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar ) dfloc = 0.0_prec do ii = 1 , this % N + 1 dfloc = dfloc + this % interp % dMatrix ( ii , i ) * this % interior ( ii , iel , ivar ) enddo df ( i , iel , ivar ) = dfloc enddo endsubroutine Derivative_Scalar1D_t subroutine WriteHDF5_Scalar1D_t ( this , fileId , group ) implicit none class ( Scalar1D_t ), intent ( in ) :: this integer ( HID_T ), intent ( in ) :: fileId character ( * ), intent ( in ) :: group ! Local integer :: ivar call CreateGroup_HDF5 ( fileId , trim ( group )) do ivar = 1 , this % nVar call this % meta ( ivar )% WriteHDF5 ( group , ivar , fileId ) enddo call WriteArray_HDF5 ( fileId , trim ( group ) // \"/interior\" , & this % interior ) call WriteArray_HDF5 ( fileId , trim ( group ) // \"/boundary\" , & this % boundary ) endsubroutine WriteHDF5_Scalar1D_t endmodule SELF_Scalar_1D_t","tags":"","loc":"sourcefile/self_scalar_1d_t.f90.html"},{"title":"SELF_Constants.f90 – SELF","text":"Contents Modules SELF_Constants Source Code SELF_Constants.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Constants use iso_c_binding use iso_fortran_env implicit none #include \"SELF_Macros.h\" #ifdef DOUBLE_PRECISION integer , parameter :: prec = c_double integer , parameter :: c_prec = c_double #else integer , parameter :: prec = c_float integer , parameter :: c_prec = c_float #endif !*************************************************************! ! ------------------ CHARACTER LENGTHS----- ------------------! ! ************************************************************! !                                                             ! integer , parameter :: SELF_EQN_DEFAULT_LENGTH = 100 integer , parameter :: SELF_FILE_DEFAULT_LENGTH = 500 ! ------------------------------------------------------------! !*************************************************************! ! ------------------ MATHEMATICAL CONSTANTS ------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! real ( prec ), parameter :: pi = 4.0_prec * atan ( 1.0_prec ) real ( prec ), parameter :: TOL = epsilon ( 1.0_prec ) real ( prec ), parameter :: fillValue = - 999 9.99_prec integer , parameter :: fillValueInt = - 99999 !*************************************************************! ! ----------------- ROOT FINDER CONSTANTS --------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! integer , parameter :: maxInverseIters = 1000 real ( prec ), parameter :: newtonTolerance = 1 0.0 ** ( - 8 ) integer , parameter :: newtonMax = 500 !*************************************************************! ! ----------------- TIME STEPPING CONSTANTS ------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! !*************************************************************! ! ------------------- PHYSICAL CONSTANTS ---------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! ! Time conversion factors real ( prec ), parameter :: secondsToMinutes = 1.0_prec / 6 0.0_prec ! conversion for seconds to minutes real ( prec ), parameter :: minutesToHours = 1.0_prec / 6 0.0_prec ! conversion for minutes to hours real ( prec ), parameter :: hoursToDays = 1.0_prec / 2 4.0_prec ! conversion for hours to days real ( prec ), parameter :: daysToMonths = 1 2.0_prec / 36 5.25_prec ! conversion for days to months real ( prec ), parameter :: monthsToYears = 1.0_prec / 1 2.0_prec ! conversion for months to years real ( prec ), parameter :: daysToSeconds = 8640 0.0_prec !==============================================! ! --------------- Quadrature------------------ ! !==============================================! integer , parameter :: GAUSS = 1 integer , parameter :: GAUSS_LOBATTO = 2 integer , parameter :: CHEBYSHEV_GAUSS = 3 integer , parameter :: CHEBYSHEV_GAUSS_LOBATTO = 4 integer , parameter :: UNIFORM = 5 integer , parameter :: DG = 2000 integer , parameter :: CG = 2001 ! Misc. INTEGER and CHARACTER flag definitions character ( 1 ), parameter :: nada = ' ' character ( 6 ), parameter :: MsgFmt = '(2x,A)' integer , parameter :: self_FileNameLength = 500 integer , parameter :: self_TecplotHeaderLength = 500 integer , parameter :: self_EquationLength = 210 integer , parameter :: self_FormatLength = 30 integer , parameter :: self_QuadratureTypeCharLength = 50 integer , parameter :: self_IntegratorTypeCharLength = 50 endmodule SELF_Constants","tags":"","loc":"sourcefile/self_constants.f90.html"},{"title":"SELF_MappedScalar_2D_t.f90 – SELF","text":"Contents Modules SELF_MappedScalar_2D_t Source Code SELF_MappedScalar_2D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_MappedScalar_2D_t use SELF_Constants use SELF_Lagrange use SELF_Scalar_2D use SELF_Tensor_2D use SELF_Mesh_2D use SELF_Geometry_2D use SELF_DomainDecomposition use FEQParse use iso_c_binding implicit none type , extends ( Scalar2D ), public :: MappedScalar2D_t logical :: geometry_associated = . false . type ( SEMQuad ), pointer :: geometry => null () contains procedure , public :: AssociateGeometry => AssociateGeometry_MappedScalar2D_t procedure , public :: DissociateGeometry => DissociateGeometry_MappedScalar2D_t procedure , public :: SideExchange => SideExchange_MappedScalar2D_t generic , public :: MappedGradient => MappedGradient_MappedScalar2D_t procedure , private :: MappedGradient_MappedScalar2D_t generic , public :: MappedDGGradient => MappedDGGradient_MappedScalar2D_t procedure , private :: MappedDGGradient_MappedScalar2D_t procedure , private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D_t procedure , private :: ApplyFlip => ApplyFlip_MappedScalar2D_t procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar2D_t endtype MappedScalar2D_t contains subroutine AssociateGeometry_MappedScalar2D_t ( this , geometry ) implicit none class ( MappedScalar2D_t ), intent ( inout ) :: this type ( SEMQuad ), target , intent ( in ) :: geometry if (. not . associated ( this % geometry )) then this % geometry => geometry this % geometry_associated = . true . endif endsubroutine AssociateGeometry_MappedScalar2D_t subroutine DissociateGeometry_MappedScalar2D_t ( this ) implicit none class ( MappedScalar2D_t ), intent ( inout ) :: this if ( associated ( this % geometry )) then this % geometry => null () this % geometry_associated = . false . endif endsubroutine DissociateGeometry_MappedScalar2D_t subroutine SetInteriorFromEquation_MappedScalar2D_t ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedScalar2D_t ), intent ( inout ) :: this type ( SEMQuad ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , iEl , iVar real ( prec ) :: x real ( prec ) :: y do iVar = 1 , this % nVar do iEl = 1 , this % nElem do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , iEl , 1 , 2 ) this % interior ( i , j , iEl , iVar ) = & this % eqn ( iVar )% Evaluate (( / x , y , 0.0_prec , time / )) enddo enddo enddo enddo endsubroutine SetInteriorFromEquation_MappedScalar2D_t subroutine MPIExchangeAsync_MappedScalar2D_t ( this , mesh ) implicit none class ( MappedScalar2D_t ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount msgCount = 0 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 4 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) ! create unique tag for each side and each variable tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 ) msgCount = msgCount + 1 call MPI_IRECV ( this % extBoundary (:, s1 , e1 , ivar ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( this % boundary (:, s1 , e1 , ivar ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedScalar2D_t subroutine ApplyFlip_MappedScalar2D_t ( this , mesh ) ! Apply side flips to sides where MPI exchanges took place. implicit none class ( MappedScalar2D_t ), intent ( inout ) :: this type ( Mesh2D ), intent ( in ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 integer :: i , i2 integer :: r2 , flip , ivar integer :: globalSideId real ( prec ) :: extBuff ( 1 : this % interp % N + 1 ) do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 4 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element (global id) if ( e2 > 0 ) then ! Interior Element r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 ! Need to update extBoundary with flip applied if ( flip == 1 ) then do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i extBuff ( i ) = this % extBoundary ( i2 , s1 , e1 , ivar ) enddo do i = 1 , this % interp % N + 1 this % extBoundary ( i , s1 , e1 , ivar ) = extBuff ( i ) enddo endif endif endif enddo enddo enddo endsubroutine ApplyFlip_MappedScalar2D_t subroutine SideExchange_MappedScalar2D_t ( this , mesh ) implicit none class ( MappedScalar2D_t ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: e1 , e2 , s1 , s2 , e2Global integer :: flip integer :: i1 , i2 , ivar integer :: r2 integer :: rankId , offset , N integer , pointer :: elemtorank (:) ! This mapping is needed to resolve a build error with ! amdflang that appears to be caused by referencing ! the elemToRank attribute within the do concurrent ! https://github.com/FluidNumerics/SELF/issues/54 elemtorank => mesh % decomp % elemToRank (:) rankId = mesh % decomp % rankId offset = mesh % decomp % offsetElem ( rankId + 1 ) N = this % interp % N if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif do concurrent ( s1 = 1 : 4 , e1 = 1 : mesh % nElem , ivar = 1 : this % nvar ) e2Global = mesh % sideInfo ( 3 , s1 , e1 ) e2 = e2Global - offset s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 if ( e2Global > 0 ) then r2 = elemToRank ( e2Global ) if ( r2 == rankId ) then if ( flip == 0 ) then do i1 = 1 , N + 1 this % extBoundary ( i1 , s1 , e1 , ivar ) = & this % boundary ( i1 , s2 , e2 , ivar ) enddo elseif ( flip == 1 ) then do i1 = 1 , N + 1 i2 = N + 2 - i1 this % extBoundary ( i1 , s1 , e1 , ivar ) = & this % boundary ( i2 , s2 , e2 , ivar ) enddo endif endif endif enddo if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call this % ApplyFlip ( mesh ) endif endsubroutine SideExchange_MappedScalar2D_t subroutine MappedGradient_MappedScalar2D_t ( this , df ) !! Calculates the gradient of a function using the strong form of the gradient !! in mapped coordinates. implicit none class ( MappedScalar2D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 2 ) ! Local integer :: iEl , iVar , i , j , ii , idir real ( prec ) :: dfdx , ja do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar , idir = 1 : 2 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ! dsdx(j,i) is contravariant vector i, component j ja = this % geometry % dsdx % interior ( ii , j , iel , 1 , idir , 1 ) dfdx = dfdx + this % interp % dMatrix ( ii , i ) * this % interior ( ii , j , iel , ivar ) * ja enddo df ( i , j , iel , ivar , idir ) = dfdx enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar , idir = 1 : 2 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ja = this % geometry % dsdx % interior ( i , ii , iel , 1 , idir , 2 ) dfdx = dfdx + this % interp % dMatrix ( ii , j ) * this % interior ( i , ii , iel , ivar ) * ja enddo df ( i , j , iel , ivar , idir ) = ( df ( i , j , iel , ivar , idir ) + dfdx ) / this % geometry % J % interior ( i , j , iEl , 1 ) enddo endsubroutine MappedGradient_MappedScalar2D_t subroutine MappedDGGradient_MappedScalar2D_t ( this , df ) !! implicit none class ( MappedScalar2D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 2 ) ! Local integer :: iEl , iVar , i , j , ii , idir real ( prec ) :: dfdx , dfdxb , ja , bfl , bfr do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar , idir = 1 : 2 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ja = this % geometry % dsdx % interior ( ii , j , iel , 1 , idir , 1 ) dfdx = dfdx + this % interp % dgMatrix ( ii , i ) * this % interior ( ii , j , iel , ivar ) * ja enddo bfl = this % avgboundary ( j , 4 , iel , ivar ) * this % geometry % dsdx % boundary ( j , 4 , iel , 1 , idir , 1 ) ! west bfr = this % avgboundary ( j , 2 , iel , ivar ) * this % geometry % dsdx % boundary ( j , 2 , iel , 1 , idir , 1 ) ! east dfdxb = ( this % interp % bMatrix ( i , 1 ) * bfl + this % interp % bMatrix ( i , 2 ) * bfr ) / this % interp % qweights ( i ) df ( i , j , iel , ivar , idir ) = dfdx + dfdxb enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , iel = 1 : this % nElem , ivar = 1 : this % nVar , idir = 1 : 2 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ja = this % geometry % dsdx % interior ( i , ii , iel , 1 , idir , 2 ) dfdx = dfdx + this % interp % dgMatrix ( ii , j ) * this % interior ( i , ii , iel , ivar ) * ja enddo bfl = this % avgboundary ( i , 1 , iel , ivar ) * this % geometry % dsdx % boundary ( i , 1 , iel , 1 , idir , 2 ) ! south bfr = this % avgboundary ( i , 3 , iel , ivar ) * this % geometry % dsdx % boundary ( i , 3 , iel , 1 , idir , 2 ) ! north dfdxb = ( this % interp % bMatrix ( j , 1 ) * bfl + this % interp % bMatrix ( j , 2 ) * bfr ) / this % interp % qweights ( j ) df ( i , j , iel , ivar , idir ) = ( df ( i , j , iel , ivar , idir ) + dfdx + dfdxb ) / this % geometry % J % interior ( i , j , iEl , 1 ) enddo endsubroutine MappedDGGradient_MappedScalar2D_t endmodule SELF_MappedScalar_2D_t","tags":"","loc":"sourcefile/self_mappedscalar_2d_t.f90.html"},{"title":"SELF_MappedScalar_3D_t.f90 – SELF","text":"Contents Modules SELF_MappedScalar_3D_t Source Code SELF_MappedScalar_3D_t.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_MappedScalar_3D_t use SELF_Constants use SELF_Lagrange use SELF_Scalar_3D use SELF_Tensor_3D use SELF_Mesh_3D use SELF_Geometry_3D use SELF_DomainDecomposition use FEQParse use iso_c_binding implicit none type , extends ( Scalar3D ), public :: MappedScalar3D_t logical :: geometry_associated = . false . type ( SEMHex ), pointer :: geometry => null () contains procedure , public :: AssociateGeometry => AssociateGeometry_MappedScalar3D_t procedure , public :: DissociateGeometry => DissociateGeometry_MappedScalar3D_t procedure , public :: SideExchange => SideExchange_MappedScalar3D_t generic , public :: MappedGradient => MappedGradient_MappedScalar3D_t procedure , private :: MappedGradient_MappedScalar3D_t generic , public :: MappedDGGradient => MappedDGGradient_MappedScalar3D_t procedure , private :: MappedDGGradient_MappedScalar3D_t procedure , private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D_t procedure , private :: ApplyFlip => ApplyFlip_MappedScalar3D_t procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar3D_t ! procedure,public :: WriteTecplot => WriteTecplot_MappedScalar3D_t endtype MappedScalar3D_t contains subroutine AssociateGeometry_MappedScalar3D_t ( this , geometry ) implicit none class ( MappedScalar3D_t ), intent ( inout ) :: this type ( SEMHex ), target , intent ( in ) :: geometry if (. not . associated ( this % geometry )) then this % geometry => geometry this % geometry_associated = . true . endif endsubroutine AssociateGeometry_MappedScalar3D_t subroutine DissociateGeometry_MappedScalar3D_t ( this ) implicit none class ( MappedScalar3D_t ), intent ( inout ) :: this if ( associated ( this % geometry )) then this % geometry => null () this % geometry_associated = . false . endif endsubroutine DissociateGeometry_MappedScalar3D_t subroutine SetInteriorFromEquation_MappedScalar3D_t ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedScalar3D_t ), intent ( inout ) :: this type ( SEMHex ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , k , iEl , iVar real ( prec ) :: x real ( prec ) :: y real ( prec ) :: z do iVar = 1 , this % nVar do iEl = 1 , this % nElem do k = 1 , this % interp % N + 1 do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , k , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , k , iEl , 1 , 2 ) z = geometry % x % interior ( i , j , k , iEl , 1 , 3 ) this % interior ( i , j , k , iEl , iVar ) = & this % eqn ( iVar )% Evaluate (( / x , y , z , time / )) enddo enddo enddo enddo enddo endsubroutine SetInteriorFromEquation_MappedScalar3D_t subroutine MPIExchangeAsync_MappedScalar3D_t ( this , mesh ) implicit none class ( MappedScalar3D_t ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount msgCount = 0 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 6 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 ) msgCount = msgCount + 1 call MPI_IRECV ( this % extBoundary (:,:, s1 , e1 , ivar ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , globalSideId , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( this % boundary (:,:, s1 , e1 , ivar ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , globalSideId , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedScalar3D_t subroutine ApplyFlip_MappedScalar3D_t ( this , mesh ) ! Apply side flips to sides where MPI exchanges took place. implicit none class ( MappedScalar3D_t ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 integer :: i , i2 , j , j2 integer :: r2 , flip , ivar integer :: bcid real ( prec ) :: extBuff ( 1 : this % interp % N + 1 , 1 : this % interp % N + 1 ) do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 6 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 bcid = mesh % sideInfo ( 5 , s1 , e1 ) if ( e2 > 0 ) then ! Interior Element r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 ! Need to update extBoundary with flip applied if ( flip == 0 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 extBuff ( i , j ) = this % extBoundary ( i , j , s1 , e1 , ivar ) enddo enddo else if ( flip == 1 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = j extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar ) enddo enddo else if ( flip == 2 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = this % interp % N + 2 - j extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar ) enddo enddo else if ( flip == 3 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = i j2 = this % interp % N + 2 - j extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar ) enddo enddo else if ( flip == 4 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 extBuff ( i , j ) = this % extBoundary ( j , i , s1 , e1 , ivar ) enddo enddo else if ( flip == 5 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = i extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar ) enddo enddo else if ( flip == 6 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = this % interp % N + 2 - i extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar ) enddo enddo else if ( flip == 7 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = j j2 = this % interp % N + 2 - i extBuff ( i , j ) = this % extBoundary ( i2 , j2 , s1 , e1 , ivar ) enddo enddo endif do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 this % extBoundary ( i , j , s1 , e1 , ivar ) = extBuff ( i , j ) enddo enddo endif endif enddo enddo enddo endsubroutine ApplyFlip_MappedScalar3D_t subroutine SideExchange_MappedScalar3D_t ( this , mesh ) implicit none class ( MappedScalar3D_t ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , e2 , s1 , s2 , e2Global integer :: flip integer :: i , i2 , j , j2 , ivar integer :: r2 integer :: rankId , offset integer , pointer :: elemtorank (:) elemtorank => mesh % decomp % elemToRank (:) rankId = mesh % decomp % rankId offset = mesh % decomp % offsetElem ( rankId + 1 ) if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif do concurrent ( s1 = 1 : 6 , e1 = 1 : mesh % nElem , ivar = 1 : this % nvar ) e2Global = mesh % sideInfo ( 3 , s1 , e1 ) s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 flip = mesh % sideInfo ( 4 , s1 , e1 ) - s2 * 10 if ( e2Global > 0 ) then r2 = elemToRank ( e2Global ) if ( r2 == rankId ) then e2 = e2Global - offset if ( flip == 0 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( i , j , s2 , e2 , ivar ) enddo enddo else if ( flip == 1 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = j this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( i2 , j2 , s2 , e2 , ivar ) enddo enddo else if ( flip == 2 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - i j2 = this % interp % N + 2 - j this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( i2 , j2 , s2 , e2 , ivar ) enddo enddo else if ( flip == 3 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = i j2 = this % interp % N + 2 - j this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( i2 , j2 , s2 , e2 , ivar ) enddo enddo else if ( flip == 4 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( j , i , s2 , e2 , ivar ) enddo enddo else if ( flip == 5 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = i this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( i2 , j2 , s2 , e2 , ivar ) enddo enddo else if ( flip == 6 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = this % interp % N + 2 - j j2 = this % interp % N + 2 - i this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( i2 , j2 , s2 , e2 , ivar ) enddo enddo else if ( flip == 7 ) then do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 i2 = j j2 = this % interp % N + 2 - i this % extBoundary ( i , j , s1 , e1 , ivar ) = this % boundary ( i2 , j2 , s2 , e2 , ivar ) enddo enddo endif endif endif enddo if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call this % ApplyFlip ( mesh ) endif endsubroutine SideExchange_MappedScalar3D_t subroutine MappedGradient_MappedScalar3D_t ( this , df ) !! Calculates the gradient of a function using the strong form of the gradient !! in mapped coordinates. implicit none class ( MappedScalar3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 3 ) ! Local integer :: iEl , iVar , i , j , k , ii , idir real ( prec ) :: dfdx , ja do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ! dsdx(j,i) is contravariant vector i, component j ja = this % geometry % dsdx % interior ( ii , j , k , iel , 1 , idir , 1 ) dfdx = dfdx + this % interp % dMatrix ( ii , i ) * & this % interior ( ii , j , k , iel , ivar ) * ja enddo df ( i , j , k , iel , ivar , idir ) = dfdx enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ja = this % geometry % dsdx % interior ( i , ii , k , iel , 1 , idir , 2 ) dfdx = dfdx + this % interp % dMatrix ( ii , j ) * & this % interior ( i , ii , k , iel , ivar ) * ja enddo df ( i , j , k , iel , ivar , idir ) = ( df ( i , j , k , iel , ivar , idir ) + dfdx ) enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ja = this % geometry % dsdx % interior ( i , j , ii , iel , 1 , idir , 3 ) dfdx = dfdx + this % interp % dMatrix ( ii , k ) * & this % interior ( i , j , ii , iel , ivar ) * ja enddo df ( i , j , k , iel , ivar , idir ) = ( df ( i , j , k , iel , ivar , idir ) + dfdx ) / & this % geometry % J % interior ( i , j , k , iEl , 1 ) enddo endsubroutine MappedGradient_MappedScalar3D_t subroutine MappedDGGradient_MappedScalar3D_t ( this , df ) !! Calculates the gradient of a function using the weak form of the gradient !! and the average boundary state. !! This method will compute the average boundary state from the !! and  attributes of implicit none class ( MappedScalar3D_t ), intent ( in ) :: this real ( prec ), intent ( out ) :: df ( 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % N + 1 , 1 : this % nelem , 1 : this % nvar , 1 : 3 ) ! Local integer :: iEl , iVar , i , j , k , ii , idir real ( prec ) :: dfdx , jaf , bfl , bfr do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 ! dsdx(j,i) is contravariant vector i, component j jaf = this % geometry % dsdx % interior ( ii , j , k , iel , 1 , idir , 1 ) * & this % interior ( ii , j , k , iel , ivar ) dfdx = dfdx + this % interp % dgMatrix ( ii , i ) * jaf enddo bfl = this % avgboundary ( j , k , 5 , iel , ivar ) * & this % geometry % dsdx % boundary ( j , k , 5 , iel , 1 , idir , 1 ) ! west bfr = this % avgboundary ( j , k , 3 , iel , ivar ) * & this % geometry % dsdx % boundary ( j , k , 3 , iel , 1 , idir , 1 ) ! east df ( i , j , k , iel , ivar , idir ) = dfdx + & ( this % interp % bMatrix ( i , 1 ) * bfl + & this % interp % bMatrix ( i , 2 ) * bfr ) / this % interp % qweights ( i ) enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 jaf = this % geometry % dsdx % interior ( i , ii , k , iel , 1 , idir , 2 ) * & this % interior ( i , ii , k , iel , ivar ) dfdx = dfdx + this % interp % dgMatrix ( ii , j ) * jaf enddo bfl = this % avgboundary ( i , k , 2 , iel , ivar ) * & this % geometry % dsdx % boundary ( i , k , 2 , iel , 1 , idir , 2 ) ! south bfr = this % avgboundary ( i , k , 4 , iel , ivar ) * & this % geometry % dsdx % boundary ( i , k , 4 , iel , 1 , idir , 2 ) ! north dfdx = dfdx + ( this % interp % bMatrix ( j , 1 ) * bfl + & this % interp % bMatrix ( j , 2 ) * bfr ) / this % interp % qweights ( j ) df ( i , j , k , iel , ivar , idir ) = ( df ( i , j , k , iel , ivar , idir ) + dfdx ) enddo do concurrent ( i = 1 : this % N + 1 , j = 1 : this % N + 1 , & k = 1 : this % N + 1 , iel = 1 : this % nelem , ivar = 1 : this % nvar , idir = 1 : 3 ) dfdx = 0.0_prec do ii = 1 , this % N + 1 jaf = this % geometry % dsdx % interior ( i , j , ii , iel , 1 , idir , 3 ) * & this % interior ( i , j , ii , iel , ivar ) dfdx = dfdx + this % interp % dgMatrix ( ii , k ) * jaf enddo bfl = this % avgboundary ( i , j , 1 , iel , ivar ) * & this % geometry % dsdx % boundary ( i , j , 1 , iel , 1 , idir , 3 ) ! bottom bfr = this % avgboundary ( i , j , 6 , iel , ivar ) * & this % geometry % dsdx % boundary ( i , j , 6 , iel , 1 , idir , 3 ) ! top dfdx = dfdx + ( this % interp % bMatrix ( k , 1 ) * bfl + & this % interp % bMatrix ( k , 2 ) * bfr ) / this % interp % qweights ( k ) df ( i , j , k , iel , ivar , idir ) = ( df ( i , j , k , iel , ivar , idir ) + dfdx ) / & this % geometry % J % interior ( i , j , k , iEl , 1 ) enddo endsubroutine MappedDGGradient_MappedScalar3D_t ! subroutine WriteTecplot_MappedScalar3D_t(this,geometry,filename) !   implicit none !   class(MappedScalar3D_t),intent(inout) :: this !   type(SEMHex),intent(in) :: geometry !   character(*),intent(in),optional :: filename !   ! Local !   character(8) :: zoneID !   integer :: fUnit !   integer :: iEl,i,j,k,iVar !   character(LEN=self_FileNameLength) :: tecFile !   character(LEN=self_TecplotHeaderLength) :: tecHeader !   character(LEN=self_FormatLength) :: fmat !   character(13) :: timeStampString !   character(5) :: rankString !   real(prec) :: f(1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar) !   real(prec) :: x(1:this%M+1,1:this%M+1,1:this%M+1,1:this%nelem,1:this%nvar,1:3) !   if(present(filename)) then !     tecFile = filename !   else !     tecFile = \"mappedscalar.tec\" !   endif !   ! Map the mesh positions to the target grid !   x = geometry%x%GridInterp() !   ! Map the solution to the target grid !   f = this%GridInterp() !   open(UNIT=NEWUNIT(fUnit), & !        FILE=trim(tecFile), & !        FORM='formatted', & !        STATUS='replace') !   tecHeader = 'VARIABLES = \"X\", \"Y\", \"Z\"' !   do iVar = 1,this%nVar !     tecHeader = trim(tecHeader)//', \"'//trim(this%meta(iVar)%name)//'\"' !   enddo !   write(fUnit,*) trim(tecHeader) !   ! Create format statement !   write(fmat,*) this%nvar+3 !   fmat = '('//trim(fmat)//'(ES16.7E3,1x))' !   do iEl = 1,this%nElem !     write(zoneID,'(I8.8)') iEl !     write(fUnit,*) 'ZONE T=\"el'//trim(zoneID)//'\", I=',this%interp%M+1, & !       ', J=',this%interp%M+1,', K=',this%interp%M+1 !     do k = 1,this%interp%M+1 !       do j = 1,this%interp%M+1 !         do i = 1,this%interp%M+1 !           write(fUnit,fmat) x(i,j,k,iEl,1,1), & !             x(i,j,k,iEl,1,2), & !             x(i,j,k,iEl,1,3), & !             f(i,j,k,iEl,1:this%nvar) !         enddo !       enddo !     enddo !   enddo !   close(UNIT=fUnit) ! endsubroutine WriteTecplot_MappedScalar3D_t endmodule SELF_MappedScalar_3D_t","tags":"","loc":"sourcefile/self_mappedscalar_3d_t.f90.html"},{"title":"SELF_NullDGModel3D.f90 – SELF","text":"Contents Modules self_NullDGModel3D Source Code SELF_NullDGModel3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_NullDGModel3D use self_NullDGModel3D_t implicit none type , extends ( NullDGModel3D_t ) :: NullDGModel3D endtype NullDGModel3D endmodule self_NullDGModel3D","tags":"","loc":"sourcefile/self_nulldgmodel3d.f90.html"},{"title":"SELF_MappedScalar_3D.f90 – SELF","text":"Contents Modules SELF_MappedScalar_3D Source Code SELF_MappedScalar_3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_MappedScalar_3D use SELF_MappedScalar_3D_t use SELF_GPU use SELF_GPUInterfaces use iso_c_binding implicit none type , extends ( MappedScalar3D_t ), public :: MappedScalar3D type ( c_ptr ) :: jas_gpu ! jacobian weighted scalar for gradient calculation contains procedure , public :: Init => Init_MappedScalar3D procedure , public :: Free => Free_MappedScalar3D procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar3D procedure , public :: SideExchange => SideExchange_MappedScalar3D procedure , private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D generic , public :: MappedGradient => MappedGradient_MappedScalar3D procedure , private :: MappedGradient_MappedScalar3D generic , public :: MappedDGGradient => MappedDGGradient_MappedScalar3D procedure , private :: MappedDGGradient_MappedScalar3D endtype MappedScalar3D interface subroutine ContravariantWeight_3D_gpu ( f , dsdx , jaf , N , nvar , nel ) & bind ( c , name = \"ContravariantWeight_3D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: f , dsdx , jaf integer ( c_int ), value :: N , nvar , nel endsubroutine ContravariantWeight_3D_gpu endinterface interface subroutine NormalWeight_3D_gpu ( fb , nhat , nscale , fbn , N , nvar , nel ) & bind ( c , name = \"NormalWeight_3D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: fb , nhat , nscale , fbn integer ( c_int ), value :: N , nvar , nel endsubroutine NormalWeight_3D_gpu endinterface contains subroutine Init_MappedScalar3D ( this , interp , nVar , nElem ) implicit none class ( MappedScalar3D ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! Local integer ( c_size_t ) :: workSize this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar ), & this % boundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : 3 * nvar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec this % boundarynormal = 0.0_prec allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( this % avgBoundary_gpu , sizeof ( this % avgBoundary ))) call gpuCheck ( hipMalloc ( this % boundarynormal_gpu , sizeof ( this % boundarynormal ))) workSize = ( interp % N + 1 ) * ( interp % N + 1 ) * ( interp % M + 1 ) * nelem * nvar * prec call gpuCheck ( hipMalloc ( this % interpWork1 , workSize )) workSize = ( interp % N + 1 ) * ( interp % M + 1 ) * ( interp % M + 1 ) * nelem * nvar * prec call gpuCheck ( hipMalloc ( this % interpWork2 , workSize )) workSize = ( interp % N + 1 ) * ( interp % N + 1 ) * ( interp % N + 1 ) * nelem * nvar * 9 * prec call gpuCheck ( hipMalloc ( this % jas_gpu , workSize )) call this % UpdateDevice () call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_MappedScalar3D subroutine Free_MappedScalar3D ( this ) implicit none class ( MappedScalar3D ), intent ( inout ) :: this this % nVar = 0 this % nElem = 0 this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % boundarynormal ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call gpuCheck ( hipFree ( this % avgBoundary_gpu )) call gpuCheck ( hipFree ( this % boundarynormal_gpu )) call gpuCheck ( hipFree ( this % interpWork1 )) call gpuCheck ( hipFree ( this % interpWork2 )) call gpuCheck ( hipFree ( this % jas_gpu )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_MappedScalar3D subroutine SetInteriorFromEquation_MappedScalar3D ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedScalar3D ), intent ( inout ) :: this type ( SEMHex ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , k , iEl , iVar real ( prec ) :: x real ( prec ) :: y real ( prec ) :: z do iVar = 1 , this % nVar do iEl = 1 , this % nElem do k = 1 , this % interp % N + 1 do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , k , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , k , iEl , 1 , 2 ) z = geometry % x % interior ( i , j , k , iEl , 1 , 3 ) this % interior ( i , j , k , iEl , iVar ) = & this % eqn ( iVar )% Evaluate (( / x , y , z , time / )) enddo enddo enddo enddo enddo call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) endsubroutine SetInteriorFromEquation_MappedScalar3D subroutine MPIExchangeAsync_MappedScalar3D ( this , mesh ) implicit none class ( MappedScalar3D ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount real ( prec ), pointer :: boundary (:,:,:,:,:) real ( prec ), pointer :: extboundary (:,:,:,:,:) msgCount = 0 call c_f_pointer ( this % boundary_gpu , boundary ,[ this % interp % N + 1 , this % interp % N + 1 , 6 , this % nelem , this % nvar ]) call c_f_pointer ( this % extboundary_gpu , extboundary ,[ this % interp % N + 1 , this % interp % N + 1 , 6 , this % nelem , this % nvar ]) do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 6 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) ! create unique tag for each side and each variable tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 ) msgCount = msgCount + 1 call MPI_IRECV ( extBoundary (:,:, s1 , e1 , ivar ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( boundary (:,:, s1 , e1 , ivar ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedScalar3D subroutine SideExchange_MappedScalar3D ( this , mesh ) implicit none class ( MappedScalar3D ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: offset offset = mesh % decomp % offsetElem ( mesh % decomp % rankId + 1 ) if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif call SideExchange_3D_gpu ( this % extboundary_gpu , & this % boundary_gpu , mesh % sideinfo_gpu , mesh % decomp % elemToRank_gpu , & mesh % decomp % rankid , offset , this % interp % N , this % nvar , this % nelem ) if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call ApplyFlip_3D_gpu ( this % extboundary_gpu , mesh % sideInfo_gpu , & mesh % decomp % elemToRank_gpu , mesh % decomp % rankId , & offset , this % interp % N , this % nVar , this % nElem ) endif endsubroutine SideExchange_MappedScalar3D subroutine MappedGradient_MappedScalar3D ( this , df ) !! Calculates the gradient of a function using the strong form of the gradient !! in mapped coordinates. implicit none class ( MappedScalar3D ), intent ( inout ) :: this type ( c_ptr ), intent ( out ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:,:) type ( c_ptr ) :: fc call ContravariantWeight_3D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % jas_gpu , & this % interp % N , this % nvar , this % nelem ) ! From Vector divergence call c_f_pointer ( this % jas_gpu , f_p , & [ this % interp % N + 1 , this % interp % N + 1 , this % interp % N + 1 , this % nelem , 3 * this % nvar , 3 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_3d ( this % interp % dMatrix_gpu , fc , df , & this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_3d ( this % interp % dMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 3 )) call self_blas_matrixop_dim3_3d ( this % interp % dMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) f_p => null () call JacobianWeight_3D_gpu ( df , this % geometry % J % interior_gpu , this % N , 3 * this % nVar , this % nelem ) endsubroutine MappedGradient_MappedScalar3D subroutine MappedDGGradient_MappedScalar3D ( this , df ) !! Calculates the gradient of a function using the weak form of the gradient !! and the average boundary state. !! This method will compute the average boundary state from the !! and  attributes of implicit none class ( MappedScalar3D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:,:) type ( c_ptr ) :: fc call ContravariantWeight_3D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % jas_gpu , & this % interp % N , this % nvar , this % nelem ) ! From Vector divergence call c_f_pointer ( this % jas_gpu , f_p , & [ this % interp % N + 1 , this % interp % N + 1 , this % interp % N + 1 , this % nelem , 3 * this % nvar , 3 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_3d ( this % interp % dgMatrix_gpu , fc , df , & this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_3d ( this % interp % dgMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 3 )) call self_blas_matrixop_dim3_3d ( this % interp % dgMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) f_p => null () ! Do the boundary terms call NormalWeight_3D_gpu ( this % avgBoundary_gpu , & this % geometry % nhat % boundary_gpu , this % geometry % nscale % boundary_gpu , & this % boundarynormal_gpu , & this % interp % N , this % nvar , this % nelem ) call DG_BoundaryContribution_3D_gpu ( this % interp % bmatrix_gpu , this % interp % qweights_gpu , & this % boundarynormal_gpu , df , this % interp % N , 3 * this % nvar , this % nelem ) call JacobianWeight_3D_gpu ( df , this % geometry % J % interior_gpu , this % N , 3 * this % nVar , this % nelem ) endsubroutine MappedDGGradient_MappedScalar3D endmodule SELF_MappedScalar_3D","tags":"","loc":"sourcefile/self_mappedscalar_3d.f90.html"},{"title":"SELF_Vector_3D.f90 – SELF","text":"Contents Modules SELF_Vector_3D Source Code SELF_Vector_3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Vector_3D use SELF_Constants use SELF_Vector_3D_t use SELF_GPU use SELF_GPUBLAS use SELF_GPUInterfaces use iso_c_binding implicit none type , extends ( Vector3D_t ), public :: Vector3D character ( 3 ) :: backend = \"gpu\" type ( c_ptr ) :: blas_handle type ( c_ptr ) :: interior_gpu type ( c_ptr ) :: boundary_gpu type ( c_ptr ) :: extBoundary_gpu type ( c_ptr ) :: avgBoundary_gpu type ( c_ptr ) :: boundaryNormal_gpu type ( c_ptr ) :: interpWork1 type ( c_ptr ) :: interpWork2 contains procedure , public :: Init => Init_Vector3D procedure , public :: Free => Free_Vector3D procedure , public :: UpdateHost => UpdateHost_Vector3D procedure , public :: UpdateDevice => UpdateDevice_Vector3D procedure , public :: BoundaryInterp => BoundaryInterp_Vector3D procedure , public :: AverageSides => AverageSides_Vector3D generic , public :: GridInterp => GridInterp_Vector3D procedure , private :: GridInterp_Vector3D generic , public :: Gradient => Gradient_Vector3D procedure , private :: Gradient_Vector3D ! generic,public :: Curl => Curl_Vector3D ! procedure,private :: Curl_Vector3D generic , public :: Divergence => Divergence_Vector3D procedure , private :: Divergence_Vector3D endtype Vector3D contains subroutine Init_Vector3D ( this , interp , nVar , nElem ) implicit none class ( Vector3D ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i integer ( c_size_t ) :: workSize this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % boundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 ), & this % boundaryNormal ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 3 * nVar )) ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 3 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo this % interior = 0.0_prec this % boundary = 0.0_prec this % boundarynormal = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( this % avgBoundary_gpu , sizeof ( this % avgBoundary ))) call gpuCheck ( hipMalloc ( this % boundaryNormal_gpu , sizeof ( this % boundaryNormal ))) workSize = ( interp % N + 1 ) * ( interp % N + 1 ) * ( interp % M + 1 ) * nelem * nvar * 3 * prec call gpuCheck ( hipMalloc ( this % interpWork1 , workSize )) workSize = ( interp % N + 1 ) * ( interp % M + 1 ) * ( interp % M + 1 ) * nelem * nvar * 3 * prec call gpuCheck ( hipMalloc ( this % interpWork2 , workSize )) call this % UpdateDevice () call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_Vector3D subroutine Free_Vector3D ( this ) implicit none class ( Vector3D ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % boundaryNormal ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call gpuCheck ( hipFree ( this % avgBoundary_gpu )) call gpuCheck ( hipFree ( this % boundaryNormal_gpu )) call gpuCheck ( hipFree ( this % interpWork1 )) call gpuCheck ( hipFree ( this % interpWork2 )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Vector3D subroutine UpdateHost_Vector3D ( this ) implicit none class ( Vector3D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), this % interior_gpu , sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), this % extboundary_gpu , sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % avgboundary ), this % avgboundary_gpu , sizeof ( this % avgboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundaryNormal ), this % boundaryNormal_gpu , sizeof ( this % boundaryNormal ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Vector3D subroutine UpdateDevice_Vector3D ( this ) implicit none class ( Vector3D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundary_gpu , c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % avgboundary_gpu , c_loc ( this % avgboundary ), sizeof ( this % avgboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundaryNormal_gpu , c_loc ( this % boundaryNormal ), sizeof ( this % boundaryNormal ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Vector3D subroutine GridInterp_Vector3D ( this , f ) implicit none class ( Vector3D ), intent ( inout ) :: this type ( c_ptr ), intent ( inout ) :: f call self_blas_matrixop_dim1_3d ( this % interp % iMatrix_gpu , this % interior_gpu , & this % interpWork1 , this % N , this % M , 3 * this % nvar , this % nelem , & this % blas_handle ) call self_blas_matrixop_dim2_3d ( this % interp % iMatrix_gpu , this % interpWork1 , this % interpWork2 , & 0.0_c_prec , this % N , this % M , 3 * this % nvar , this % nelem , & this % blas_handle ) call self_blas_matrixop_dim3_3d ( this % interp % iMatrix_gpu , this % interpWork2 , f , & 0.0_c_prec , this % N , this % M , 3 * this % nvar , this % nelem , & this % blas_handle ) endsubroutine GridInterp_Vector3D subroutine AverageSides_Vector3D ( this ) implicit none class ( Vector3D ), intent ( inout ) :: this call Average_gpu ( this % avgBoundary_gpu , this % boundary_gpu , this % extBoundary_gpu , size ( this % boundary )) endsubroutine AverageSides_Vector3D subroutine BoundaryInterp_Vector3D ( this ) implicit none class ( Vector3D ), intent ( inout ) :: this call BoundaryInterp_3D_gpu ( this % interp % bMatrix_gpu , this % interior_gpu , this % boundary_gpu , & this % interp % N , 3 * this % nvar , this % nelem ) endsubroutine BoundaryInterp_Vector3D subroutine Gradient_Vector3D ( this , df ) implicit none class ( Vector3D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df !Local real ( prec ), pointer :: df_p (:,:,:,:,:,:,:) real ( prec ), pointer :: dfloc (:,:,:,:,:) type ( c_ptr ) :: dfc call c_f_pointer ( df , df_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 2 , 2 ]) dfloc ( 1 :, 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 :, 1 , 1 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim1_3d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , & this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) dfloc ( 1 :, 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 :, 1 , 2 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim2_3d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , 0.0_c_prec , & this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) dfloc ( 1 :, 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 :, 1 , 3 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim3_3d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , 0.0_c_prec , & this % interp % N , this % interp % N , 3 * this % nvar , this % nelem , this % blas_handle ) dfloc => null () df_p => null () endsubroutine Gradient_Vector3D subroutine Divergence_Vector3D ( this , df ) implicit none class ( Vector3D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df !Local real ( prec ), pointer :: f_p (:,:,:,:,:,:) type ( c_ptr ) :: fc call c_f_pointer ( this % interior_gpu , f_p , & [ this % interp % N + 1 , this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 3 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_3d ( this % interp % dMatrix_gpu , fc , df , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_3d ( this % interp % dMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 3 )) call self_blas_matrixop_dim3_3d ( this % interp % dMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) f_p => null () endsubroutine Divergence_Vector3D endmodule SELF_Vector_3D","tags":"","loc":"sourcefile/self_vector_3d.f90.html"},{"title":"SELF_Burgers1D.f90 – SELF","text":"Contents Modules self_Burgers1D Source Code SELF_Burgers1D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_Burgers1D use self_Burgers1D_t implicit none type , extends ( Burgers1D_t ) :: Burgers1D endtype Burgers1D endmodule self_Burgers1D","tags":"","loc":"sourcefile/self_burgers1d.f90.html"},{"title":"SELF_Lagrange.f90 – SELF","text":"Contents Modules SELF_Lagrange Source Code SELF_Lagrange.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Lagrange use iso_fortran_env use iso_c_binding use SELF_Constants use SELF_Lagrange_t use SELF_GPU implicit none type , extends ( Lagrange_t ), public :: Lagrange character ( 3 ) :: backend = 'gpu' type ( c_ptr ) :: qWeights_gpu type ( c_ptr ) :: iMatrix_gpu type ( c_ptr ) :: dMatrix_gpu type ( c_ptr ) :: dgMatrix_gpu type ( c_ptr ) :: bMatrix_gpu contains procedure , public :: Init => Init_Lagrange procedure , public :: Free => Free_Lagrange endtype Lagrange contains subroutine Init_Lagrange ( this , N , controlNodeType , M , targetNodeType ) !! Initialize an instance of the Lagrange class !! On output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of !! control points, number of target points, and the types for the control and target nodes. !! If a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. implicit none class ( Lagrange ), intent ( out ) :: this !! Lagrange class instance integer , intent ( in ) :: N !! The number of control points for interpolant integer , intent ( in ) :: M !! The number of target points for the interpolant integer , intent ( in ) :: controlNodeType !! The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) integer , intent ( in ) :: targetNodeType !! The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) ! -------! ! Local real ( prec ) :: q ( 0 : M ) if (. not . GPUAvailable ()) then print * , __ FILE__ , ':' , __ LINE__ , ' : Error : Attempt to use GPU extension, but GPU is not available.' stop 1 endif this % N = N this % M = M this % controlNodeType = controlNodeType this % targetNodeType = targetNodeType allocate ( this % controlPoints ( 1 : N + 1 ), & this % targetPoints ( 1 : M + 1 ), & this % bWeights ( 1 : N + 1 ), & this % qWeights ( 1 : N + 1 ), & this % iMatrix ( 1 : N + 1 , 1 : M + 1 ), & this % dMatrix ( 1 : N + 1 , 1 : N + 1 ), & this % dgMatrix ( 1 : N + 1 , 1 : N + 1 ), & this % bMatrix ( 1 : N + 1 , 1 : 2 )) if ( controlNodeType == GAUSS . or . controlNodeType == GAUSS_LOBATTO ) then call LegendreQuadrature ( N , & this % controlPoints , & this % qWeights , & controlNodeType ) elseif ( controlNodeType == CHEBYSHEV_GAUSS . or . controlNodeType == CHEBYSHEV_GAUSS_LOBATTO ) then call ChebyshevQuadrature ( N , & this % controlPoints , & this % qWeights , & controlNodeType ) elseif ( controlNodeType == UNIFORM ) then this % controlPoints = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , N ) this % qWeights = 2.0_prec / real ( N , prec ) endif ! Target Points if ( targetNodeType == GAUSS . or . targetNodeType == GAUSS_LOBATTO ) then call LegendreQuadrature ( M , & this % targetPoints , & q , & targetNodeType ) elseif ( targetNodeType == UNIFORM ) then this % targetPoints = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , M ) endif call this % CalculateBarycentricWeights () call this % CalculateInterpolationMatrix () call this % CalculateDerivativeMatrix () this % bMatrix ( 1 : N + 1 , 1 ) = this % CalculateLagrangePolynomials ( - 1.0_prec ) this % bMatrix ( 1 : N + 1 , 2 ) = this % CalculateLagrangePolynomials ( 1.0_prec ) call gpuCheck ( hipMalloc ( this % iMatrix_gpu , sizeof ( this % iMatrix ))) call gpuCheck ( hipMalloc ( this % dMatrix_gpu , sizeof ( this % dMatrix ))) call gpuCheck ( hipMalloc ( this % dgMatrix_gpu , sizeof ( this % dgMatrix ))) call gpuCheck ( hipMalloc ( this % bMatrix_gpu , sizeof ( this % bMatrix ))) call gpuCheck ( hipMalloc ( this % qWeights_gpu , sizeof ( this % qWeights ))) call gpuCheck ( hipMemcpy ( this % iMatrix_gpu , & c_loc ( this % iMatrix ), & sizeof ( this % iMatrix ), & hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % dMatrix_gpu , & c_loc ( this % dMatrix ), & sizeof ( this % dMatrix ), & hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % dgMatrix_gpu , & c_loc ( this % dgMatrix ), & sizeof ( this % dgMatrix ), & hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % bMatrix_gpu , & c_loc ( this % bMatrix ), & sizeof ( this % bMatrix ), & hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % qWeights_gpu , & c_loc ( this % qWeights ), & sizeof ( this % qWeights ), & hipMemcpyHostToDevice )) endsubroutine Init_Lagrange subroutine Free_Lagrange ( this ) !! Frees all memory (host and device) associated with an instance of the Lagrange class implicit none class ( Lagrange ), intent ( inout ) :: this !! Lagrange class instance deallocate ( this % controlPoints ) deallocate ( this % targetPoints ) deallocate ( this % bWeights ) deallocate ( this % qWeights ) deallocate ( this % iMatrix ) deallocate ( this % dMatrix ) deallocate ( this % dgMatrix ) deallocate ( this % bMatrix ) call gpuCheck ( hipFree ( this % iMatrix_gpu )) call gpuCheck ( hipFree ( this % dMatrix_gpu )) call gpuCheck ( hipFree ( this % dgMatrix_gpu )) call gpuCheck ( hipFree ( this % bMatrix_gpu )) call gpuCheck ( hipFree ( this % qWeights_gpu )) endsubroutine Free_Lagrange endmodule SELF_Lagrange","tags":"","loc":"sourcefile/self_lagrange.f90.html"},{"title":"SELF_DomainDecomposition.f90 – SELF","text":"Contents Modules SELF_DomainDecomposition Source Code SELF_DomainDecomposition.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_DomainDecomposition use SELF_DomainDecomposition_t use mpi use iso_c_binding implicit none type , extends ( DomainDecomposition_t ) :: DomainDecomposition type ( c_ptr ) :: elemToRank_gpu contains procedure :: Free => Free_DomainDecomposition procedure :: SetElemToRank => SetElemToRank_DomainDecomposition endtype DomainDecomposition contains subroutine Free_DomainDecomposition ( this ) implicit none class ( DomainDecomposition ), intent ( inout ) :: this ! Local integer :: ierror if ( associated ( this % offSetElem )) then deallocate ( this % offSetElem ) endif if ( associated ( this % elemToRank )) then deallocate ( this % elemToRank ) call gpuCheck ( hipFree ( this % elemToRank_gpu )) endif if ( allocated ( this % requests )) deallocate ( this % requests ) if ( allocated ( this % stats )) deallocate ( this % stats ) if ( this % mpiEnabled ) then print * , __ FILE__ , \" : Rank \" , this % rankId + 1 , \"/\" , this % nRanks , \" checking out.\" call MPI_FINALIZE ( ierror ) endif endsubroutine Free_DomainDecomposition subroutine SetElemToRank_DomainDecomposition ( this , nElem ) implicit none class ( DomainDecomposition ), intent ( inout ) :: this integer , intent ( in ) :: nElem ! Local integer :: iel this % nElem = nElem allocate ( this % elemToRank ( 1 : nelem )) call gpuCheck ( hipMalloc ( this % elemToRank_gpu , sizeof ( this % elemToRank ))) call DomainDecomp ( nElem , & this % nRanks , & this % offSetElem ) do iel = 1 , nElem call ElemToRank ( this % nRanks , & this % offSetElem , & iel , & this % elemToRank ( iel )) enddo call gpuCheck ( hipMemcpy ( this % elemToRank_gpu , c_loc ( this % elemToRank ), sizeof ( this % elemToRank ), hipMemcpyHostToDevice )) endsubroutine SetElemToRank_DomainDecomposition endmodule SELF_DomainDecomposition","tags":"","loc":"sourcefile/self_domaindecomposition.f90.html"},{"title":"SELF_Mesh_2D.f90 – SELF","text":"Contents Modules SELF_Mesh_2D Source Code SELF_Mesh_2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Mesh_2D use SELF_Mesh_2D_t use SELF_GPU use iso_c_binding implicit none type , extends ( Mesh2D_t ) :: Mesh2D type ( c_ptr ) :: sideInfo_gpu contains procedure , public :: Init => Init_Mesh2D procedure , public :: Free => Free_Mesh2D procedure , public :: Read_HOPr => Read_HOPr_Mesh2D endtype Mesh2D contains subroutine Init_Mesh2D ( this , nGeo , nElem , nSides , nNodes , nBCs ) implicit none class ( Mesh2D ), intent ( inout ) :: this integer , intent ( in ) :: nGeo integer , intent ( in ) :: nElem integer , intent ( in ) :: nSides integer , intent ( in ) :: nNodes integer , intent ( in ) :: nBCs ! Local integer :: i , j , l this % nGeo = nGeo this % nElem = nElem this % nGlobalElem = nElem this % nNodes = nNodes this % nSides = nSides this % nCornerNodes = 0 this % nUniqueNodes = 0 this % nUniqueSides = 0 this % nBCs = nBCs allocate ( this % elemInfo ( 1 : 6 , 1 : nElem )) allocate ( this % sideInfo ( 1 : 5 , 1 : 4 , 1 : nElem )) allocate ( this % nodeCoords ( 1 : 2 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % globalNodeIDs ( 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % CGNSCornerMap ( 1 : 2 , 1 : 4 )) allocate ( this % CGNSSideMap ( 1 : 2 , 1 : 4 )) allocate ( this % BCType ( 1 : 4 , 1 : nBCs )) allocate ( this % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation this % CGNSCornerMap ( 1 : 2 , 1 ) = ( / 1 , 1 / ) this % CGNSCornerMap ( 1 : 2 , 2 ) = ( / nGeo + 1 , 1 / ) this % CGNSCornerMap ( 1 : 2 , 3 ) = ( / nGeo + 1 , nGeo + 1 / ) this % CGNSCornerMap ( 1 : 2 , 4 ) = ( / 1 , nGeo + 1 / ) ! Maps from local corner node id to CGNS side this % CGNSSideMap ( 1 : 2 , 1 ) = ( / 1 , 2 / ) this % CGNSSideMap ( 1 : 2 , 2 ) = ( / 2 , 3 / ) this % CGNSSideMap ( 1 : 2 , 3 ) = ( / 4 , 3 / ) this % CGNSSideMap ( 1 : 2 , 4 ) = ( / 1 , 4 / ) call gpuCheck ( hipMalloc ( this % sideInfo_gpu , sizeof ( this % sideInfo ))) endsubroutine Init_Mesh2D subroutine Free_Mesh2D ( this ) implicit none class ( Mesh2D ), intent ( inout ) :: this this % nElem = 0 this % nNodes = 0 this % nSides = 0 this % nCornerNodes = 0 this % nUniqueSides = 0 this % nUniqueNodes = 0 this % nBCs = 0 deallocate ( this % elemInfo ) deallocate ( this % sideInfo ) deallocate ( this % nodeCoords ) deallocate ( this % globalNodeIDs ) deallocate ( this % CGNSCornerMap ) deallocate ( this % CGNSSideMap ) deallocate ( this % BCType ) deallocate ( this % BCNames ) call this % decomp % Free () call gpuCheck ( hipFree ( this % sideInfo_gpu )) endsubroutine Free_Mesh2D subroutine Read_HOPr_Mesh2D ( this , meshFile , enableDomainDecomposition ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 ! Adapted for 2D Mesh : Note that HOPR does not have 2D mesh output. implicit none class ( Mesh2D ), intent ( out ) :: this character ( * ), intent ( in ) :: meshFile logical , intent ( in ), optional :: enableDomainDecomposition ! Local integer ( HID_T ) :: fileId integer ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) integer :: nGlobalElem integer :: firstElem integer :: firstNode integer :: firstSide integer :: nLocalElems integer :: nLocalNodes3D integer :: nLocalSides3D integer :: nUniqueSides3D integer :: nLocalNodes2D integer :: nLocalSides2D integer :: nUniqueSides2D integer :: nGeo , nBCs integer :: eid , lsid , iSide integer :: i , j , nid integer , dimension (:,:), allocatable :: hopr_elemInfo integer , dimension (:,:), allocatable :: hopr_sideInfo real ( prec ), dimension (:,:), allocatable :: hopr_nodeCoords integer , dimension (:), allocatable :: hopr_globalNodeIDs integer , dimension (:,:), allocatable :: bcType if ( present ( enableDomainDecomposition )) then call this % decomp % init ( enableDomainDecomposition ) else call this % decomp % init (. false .) endif print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : Reading HOPr mesh from' // trim ( meshfile ) if ( this % decomp % mpiEnabled ) then call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId , this % decomp % mpiComm ) else call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId ) endif call ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) call ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) call ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) call ReadAttribute_HDF5 ( fileId , 'nUniqueSides' , nUniqueSides3D ) print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : N Global Elements = ' , nGlobalElem print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : Mesh geometry degree = ' , nGeo print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : N Boundary conditions = ' , nBCs print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : N Unique Sides (3D) = ' , nUniqueSides3D ! Read BCType allocate ( bcType ( 1 : 4 , 1 : nBCS )) if ( this % decomp % mpiEnabled ) then offset (:) = 0 call ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) else call ReadArray_HDF5 ( fileId , 'BCType' , bcType ) endif ! Read local subarray of ElemInfo call this % decomp % GenerateDecomposition ( nGlobalElem , nUniqueSides3D ) firstElem = this % decomp % offsetElem ( this % decomp % rankId + 1 ) + 1 nLocalElems = this % decomp % offsetElem ( this % decomp % rankId + 2 ) - & this % decomp % offsetElem ( this % decomp % rankId + 1 ) print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : element offset = ' , firstElem - 1 print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : n_elements = ' , nLocalElems ! Allocate Space for hopr_elemInfo! allocate ( hopr_elemInfo ( 1 : 6 , 1 : nLocalElems )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstElem - 1 / ) call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) else call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) endif ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo ( 5 , 1 ) + 1 nLocalNodes3D = hopr_elemInfo ( 6 , nLocalElems ) - hopr_elemInfo ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! allocate ( hopr_nodeCoords ( 1 : 3 , nLocalNodes3D ), hopr_globalNodeIDs ( 1 : nLocalNodes3D )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) else call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) endif ! Read local subarray of SideInfo firstSide = hopr_elemInfo ( 3 , 1 ) + 1 nLocalSides3D = hopr_elemInfo ( 4 , nLocalElems ) - hopr_elemInfo ( 3 , 1 ) ! Allocate space for hopr_sideInfo allocate ( hopr_sideInfo ( 1 : 5 , 1 : nLocalSides3D )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstSide - 1 / ) call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) else call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) endif call Close_HDF5 ( fileID ) ! ---- Done reading 3-D Mesh information ---- ! ! Now we need to convert from 3-D to 2-D ! nLocalSides2D = nLocalSides3D - 2 * nLocalElems nUniqueSides2D = nUniqueSides3D - 2 * nGlobalElem ! Remove the \"top\" and \"bottom\" faces nLocalNodes2D = nLocalNodes2D - nLocalElems * nGeo * ( nGeo + 1 ) ** 2 ! Remove the third dimension print * , __ FILE__ // ' : Rank ' , this % decomp % rankId + 1 , ' : N local sides  : ' , nLocalSides2D call this % Init ( nGeo , nLocalElems , nLocalSides2D , nLocalNodes2D , nBCs ) this % nUniqueSides = nUniqueSides2D ! Store the number of sides in the global mesh ! Copy data from local arrays into this !  elemInfo(1:6,iEl) !    1 - Element Type !    2 - Zone !    3 - offset index for side array (not needed when all quads are assumed) !    4 - last index for side array (not needed when all quads are assumed) !    5 - offset index for node array (not needed when all quads are assumed) !    6 - last index for node array (not needed when all quads are assumed) this % elemInfo = hopr_elemInfo this % quadrature = UNIFORM ! HOPr uses uniformly spaced points ! Grab the node coordinates (x and y only) from the \"bottom\" layer of the extruded mesh do eid = 1 , this % nElem do j = 1 , nGeo + 1 do i = 1 , nGeo + 1 nid = i + ( nGeo + 1 ) * ( j - 1 + ( nGeo + 1 ) * (( nGeo + 1 ) * ( eid - 1 ))) this % nodeCoords ( 1 : 2 , i , j , eid ) = hopr_nodeCoords ( 1 : 2 , nid ) this % globalNodeIDs ( i , j , eid ) = hopr_globalNodeIDs ( nid ) enddo enddo enddo ! Grab the south, west, north, and south sides of the elements !  sideInfo(1:5,iSide,iEl) ! !    1 - Side Type (currently unused in SELF) !    2 - Global Side ID (Used for message passing. Don't need to change) !    3 - Neighbor Element ID (Can stay the same) !    4 - 10*( neighbor local side )  + flip (Need to recalculate flip) !    5 - Boundary Condition ID (Can stay the same) do eid = 1 , this % nElem do lsid = 1 , 4 ! Calculate the 3-D side ID from the 2-D local side id and element ID iSide = lsid + 1 + 6 * ( eid - 1 ) this % sideInfo ( 1 : 5 , lsid , eid ) = hopr_sideInfo ( 1 : 5 , iSide ) ! Adjust the secondary side index for 2-D this % sideInfo ( 4 , lsid , eid ) = this % sideInfo ( 4 , lsid , eid ) - 10 enddo enddo call this % RecalculateFlip () deallocate ( hopr_elemInfo , hopr_nodeCoords , hopr_globalNodeIDs , hopr_sideInfo ) call gpuCheck ( hipMemcpy ( this % sideInfo_gpu , c_loc ( this % sideInfo ), sizeof ( this % sideInfo ), hipMemcpyHostToDevice )) endsubroutine Read_HOPr_Mesh2D endmodule SELF_Mesh_2D","tags":"","loc":"sourcefile/self_mesh_2d.f90.html"},{"title":"SELF_Scalar_1D.f90 – SELF","text":"Contents Modules SELF_Scalar_1D Source Code SELF_Scalar_1D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Scalar_1D use SELF_Constants use SELF_Scalar_1D_t use SELF_GPU use SELF_GPUBLAS use SELF_GPUInterfaces use iso_c_binding implicit none ! ---------------------- Scalars ---------------------- ! type , extends ( Scalar1D_t ), public :: Scalar1D character ( 3 ) :: backend = \"gpu\" type ( c_ptr ) :: blas_handle type ( c_ptr ) :: interior_gpu type ( c_ptr ) :: boundary_gpu type ( c_ptr ) :: extBoundary_gpu type ( c_ptr ) :: avgBoundary_gpu type ( c_ptr ) :: boundarynormal_gpu contains procedure , public :: Init => Init_Scalar1D procedure , public :: Free => Free_Scalar1D procedure , public :: UpdateHost => UpdateHost_Scalar1D procedure , public :: UpdateDevice => UpdateDevice_Scalar1D procedure , public :: AverageSides => AverageSides_Scalar1D procedure , public :: BoundaryInterp => BoundaryInterp_Scalar1D generic , public :: GridInterp => GridInterp_Scalar1D procedure , private :: GridInterp_Scalar1D generic , public :: Derivative => Derivative_Scalar1D procedure , private :: Derivative_Scalar1D endtype Scalar1D contains ! -- Scalar1D -- ! subroutine Init_Scalar1D ( this , interp , nVar , nElem ) implicit none class ( Scalar1D ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem if (. not . GPUAvailable ()) then print * , __ FILE__ , ':' , __ LINE__ , ' : Error : Attempt to use GPU extension, but GPU is not available.' stop 1 endif this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : nelem , 1 : nvar ), & this % boundary ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : 2 , 1 : nelem , 1 : nvar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % boundarynormal = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % boundarynormal_gpu , sizeof ( this % boundarynormal ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( this % avgBoundary_gpu , sizeof ( this % avgBoundary ))) call this % UpdateDevice () call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_Scalar1D subroutine Free_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % boundarynormal_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call gpuCheck ( hipFree ( this % avgBoundary_gpu )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Scalar1D subroutine UpdateHost_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), this % interior_gpu , sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundarynormal ), this % boundarynormal_gpu , sizeof ( this % boundarynormal ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), this % extboundary_gpu , sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % avgboundary ), this % avgboundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Scalar1D subroutine UpdateDevice_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundary_gpu , c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundarynormal_gpu , c_loc ( this % boundarynormal ), sizeof ( this % boundarynormal ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % avgboundary_gpu , c_loc ( this % avgboundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Scalar1D subroutine AverageSides_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this call Average_gpu ( this % avgBoundary_gpu , this % boundary_gpu , this % extBoundary_gpu , size ( this % avgBoundary )) endsubroutine AverageSides_Scalar1D subroutine BoundaryInterp_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this call self_blas_matrixop_1d ( this % interp % bMatrix_gpu , & this % interior_gpu , & this % boundary_gpu , & 2 , this % N + 1 , & this % nvar * this % nelem , this % blas_handle ) endsubroutine BoundaryInterp_Scalar1D subroutine GridInterp_Scalar1D ( this , f ) implicit none class ( Scalar1D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: f call self_blas_matrixop_1d ( this % interp % iMatrix_gpu , & this % interior_gpu , & f , this % M + 1 , this % N + 1 , & this % nvar * this % nelem , this % blas_handle ) endsubroutine GridInterp_Scalar1D subroutine Derivative_Scalar1D ( this , df ) implicit none class ( Scalar1D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df call self_blas_matrixop_1d ( this % interp % dMatrix_gpu , & this % interior_gpu , & df , this % N + 1 , this % N + 1 , & this % nvar * this % nelem , this % blas_handle ) endsubroutine Derivative_Scalar1D endmodule SELF_Scalar_1D","tags":"","loc":"sourcefile/self_scalar_1d.f90.html"},{"title":"SELF_advection_diffusion_2d.f90 – SELF","text":"Contents Modules self_advection_diffusion_2d Source Code SELF_advection_diffusion_2d.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_advection_diffusion_2d use self_advection_diffusion_2d_t implicit none type , extends ( advection_diffusion_2d_t ) :: advection_diffusion_2d contains procedure :: setboundarycondition => setboundarycondition_advection_diffusion_2d procedure :: setgradientboundarycondition => setgradientboundarycondition_advection_diffusion_2d procedure :: boundaryflux => boundaryflux_advection_diffusion_2d procedure :: fluxmethod => fluxmethod_advection_diffusion_2d procedure :: CalculateEntropy => CalculateEntropy_advection_diffusion_2d endtype advection_diffusion_2d interface subroutine setboundarycondition_advection_diffusion_2d_gpu ( extboundary , boundary , sideinfo , N , nel , nvar ) & bind ( c , name = \"setboundarycondition_advection_diffusion_2d_gpu\" ) use iso_c_binding type ( c_ptr ), value :: extboundary , boundary , sideinfo integer ( c_int ), value :: N , nel , nvar endsubroutine setboundarycondition_advection_diffusion_2d_gpu endinterface interface subroutine setgradientboundarycondition_advection_diffusion_2d_gpu ( extboundary , boundary , sideinfo , N , nel , nvar ) & bind ( c , name = \"setgradientboundarycondition_advection_diffusion_2d_gpu\" ) use iso_c_binding type ( c_ptr ), value :: extboundary , boundary , sideinfo integer ( c_int ), value :: N , nel , nvar endsubroutine setgradientboundarycondition_advection_diffusion_2d_gpu endinterface interface subroutine fluxmethod_advection_diffusion_2d_gpu ( solution , solutiongradient , flux , u , v , nu , N , nel , nvar ) & bind ( c , name = \"fluxmethod_advection_diffusion_2d_gpu\" ) use iso_c_binding use SELF_Constants type ( c_ptr ), value :: solution , solutiongradient , flux real ( c_prec ), value :: u , v , nu integer ( c_int ), value :: N , nel , nvar endsubroutine fluxmethod_advection_diffusion_2d_gpu endinterface interface subroutine boundaryflux_advection_diffusion_2d_gpu ( fb , fextb , dfavg , nhat , nscale , flux , u , v , nu , N , nel , nvar ) & bind ( c , name = \"boundaryflux_advection_diffusion_2d_gpu\" ) use iso_c_binding use SELF_Constants type ( c_ptr ), value :: fb , fextb , dfavg , flux , nhat , nscale real ( c_prec ), value :: u , v , nu integer ( c_int ), value :: N , nel , nvar endsubroutine boundaryflux_advection_diffusion_2d_gpu endinterface contains subroutine CalculateEntropy_advection_diffusion_2d ( this ) implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this ! Local integer :: iel , i , j , ivar , ierror real ( prec ) :: e , s , jac call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) e = 0.0_prec do ivar = 1 , this % solution % nvar do iel = 1 , this % geometry % nelem do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 jac = this % geometry % J % interior ( i , j , iel , 1 ) s = this % solution % interior ( i , j , iel , ivar ) e = e + 0.5_prec * s * s * jac enddo enddo enddo enddo if ( this % mesh % decomp % mpiEnabled ) then call mpi_allreduce ( e , & this % entropy , & 1 , & this % mesh % decomp % mpiPrec , & MPI_SUM , & this % mesh % decomp % mpiComm , & iError ) else this % entropy = e endif endsubroutine CalculateEntropy_advection_diffusion_2d subroutine setboundarycondition_advection_diffusion_2d ( this ) !! Boundary conditions are set to periodic boundary conditions implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this call setboundarycondition_advection_diffusion_2d_gpu ( this % solution % extboundary_gpu , & this % solution % boundary_gpu , this % mesh % sideInfo_gpu , this % solution % interp % N , & this % solution % nelem , this % solution % nvar ) endsubroutine setboundarycondition_advection_diffusion_2d subroutine setgradientboundarycondition_advection_diffusion_2d ( this ) !! Gradient boundary conditions are set to periodic boundary conditions implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this call setgradientboundarycondition_advection_diffusion_2d_gpu ( & this % solutiongradient % extboundary_gpu , & this % solutiongradient % boundary_gpu , this % mesh % sideInfo_gpu , & this % solution % interp % N , this % solution % nelem , this % solution % nvar ) endsubroutine setgradientboundarycondition_advection_diffusion_2d subroutine fluxmethod_advection_diffusion_2d ( this ) implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this call fluxmethod_advection_diffusion_2d_gpu ( this % solution % interior_gpu , & this % solutiongradient % interior_gpu , this % flux % interior_gpu , & this % u , this % v , this % nu , this % solution % interp % N , this % solution % nelem , & this % solution % nvar ) endsubroutine fluxmethod_advection_diffusion_2d subroutine boundaryflux_advection_diffusion_2d ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( advection_diffusion_2d ), intent ( inout ) :: this call boundaryflux_advection_diffusion_2d_gpu ( this % solution % boundary_gpu , & this % solution % extBoundary_gpu , this % solutionGradient % avgBoundary_gpu , & this % geometry % nhat % boundary_gpu , this % geometry % nscale % boundary_gpu , & this % flux % boundarynormal_gpu , this % u , this % v , this % nu , this % solution % interp % N , & this % solution % nelem , this % solution % nvar ) endsubroutine boundaryflux_advection_diffusion_2d endmodule self_advection_diffusion_2d","tags":"","loc":"sourcefile/self_advection_diffusion_2d.f90.html"},{"title":"SELF_DGModel2D.f90 – SELF","text":"Contents Modules SELF_DGModel2D Source Code SELF_DGModel2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_DGModel2D use SELF_DGModel2D_t use SELF_GPU use SELF_GPUInterfaces implicit none type , extends ( DGModel2D_t ) :: DGModel2D contains procedure :: UpdateSolution => UpdateSolution_DGModel2D procedure :: CalculateEntropy => CalculateEntropy_DGModel2D procedure :: BoundaryFlux => BoundaryFlux_DGModel2D procedure :: FluxMethod => fluxmethod_DGModel2D procedure :: SourceMethod => sourcemethod_DGModel2D procedure :: SetBoundaryCondition => setboundarycondition_DGModel2D procedure :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel2D procedure :: UpdateGRK2 => UpdateGRK2_DGModel2D procedure :: UpdateGRK3 => UpdateGRK3_DGModel2D procedure :: UpdateGRK4 => UpdateGRK4_DGModel2D procedure :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel2D procedure :: CalculateTendency => CalculateTendency_DGModel2D endtype DGModel2D contains subroutine UpdateSolution_DGModel2D ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) implicit none class ( DGModel2D ), intent ( inout ) :: this real ( prec ), optional , intent ( in ) :: dt ! Local real ( prec ) :: dtLoc integer :: ndof if ( present ( dt )) then dtLoc = dt else dtLoc = this % dt endif ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateSolution_gpu ( this % solution % interior_gpu , this % dsdt % interior_gpu , dtLoc , ndof ) endsubroutine UpdateSolution_DGModel2D subroutine UpdateGRK2_DGModel2D ( this , m ) implicit none class ( DGModel2D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk2_a ( m ), rk2_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK2_DGModel2D subroutine UpdateGRK3_DGModel2D ( this , m ) implicit none class ( DGModel2D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk3_a ( m ), rk3_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK3_DGModel2D subroutine UpdateGRK4_DGModel2D ( this , m ) implicit none class ( DGModel2D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk4_a ( m ), rk4_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK4_DGModel2D subroutine CalculateSolutionGradient_DGModel2D ( this ) implicit none class ( DGModel2D ), intent ( inout ) :: this call this % solution % AverageSides () call this % solution % MappedDGGradient ( this % solutionGradient % interior_gpu ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp () ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh ) endsubroutine CalculateSolutionGradient_DGModel2D subroutine CalculateEntropy_DGModel2D ( this ) implicit none class ( DGModel2D ), intent ( inout ) :: this ! Local integer :: iel , i , j , ierror real ( prec ) :: e , jac real ( prec ) :: s ( 1 : this % nvar ) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) e = 0.0_prec do iel = 1 , this % geometry % nelem do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 jac = this % geometry % J % interior ( i , j , iel , 1 ) s = this % solution % interior ( i , j , iel , 1 : this % nvar ) e = e + this % entropy_func ( s ) * jac enddo enddo enddo if ( this % mesh % decomp % mpiEnabled ) then call mpi_allreduce ( e , & this % entropy , & 1 , & this % mesh % decomp % mpiPrec , & MPI_SUM , & this % mesh % decomp % mpiComm , & iError ) else this % entropy = e endif endsubroutine CalculateEntropy_DGModel2D subroutine fluxmethod_DGModel2D ( this ) implicit none class ( DGModel2D ), intent ( inout ) :: this ! Local integer :: iel integer :: i integer :: j real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 2 ) do iel = 1 , this % mesh % nelem do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , iel , 1 : this % nvar , 1 : 2 ) this % flux % interior ( i , j , iel , 1 : this % nvar , 1 : 2 ) = this % flux2d ( s , dsdx ) enddo enddo enddo call gpuCheck ( hipMemcpy ( this % flux % interior_gpu , & c_loc ( this % flux % interior ), & sizeof ( this % flux % interior ), & hipMemcpyHostToDevice )) endsubroutine fluxmethod_DGModel2D subroutine BoundaryFlux_DGModel2D ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( DGModel2D ), intent ( inout ) :: this ! Local integer :: iel integer :: j integer :: i real ( prec ) :: sL ( 1 : this % nvar ), sR ( 1 : this % nvar ) real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ) :: nhat ( 1 : 2 ), nmag call gpuCheck ( hipMemcpy ( c_loc ( this % solution % boundary ), & this % solution % boundary_gpu , sizeof ( this % solution % boundary ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % extboundary ), & this % solution % extboundary_gpu , sizeof ( this % solution % extboundary ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % avgboundary ), & this % solutiongradient % avgboundary_gpu , sizeof ( this % solutiongradient % avgboundary ), & hipMemcpyDeviceToHost )) do iEl = 1 , this % solution % nElem do j = 1 , 4 do i = 1 , this % solution % interp % N + 1 ! Get the boundary normals on cell edges from the mesh geometry nhat = this % geometry % nHat % boundary ( i , j , iEl , 1 , 1 : 2 ) sL = this % solution % boundary ( i , j , iel , 1 : this % nvar ) ! interior solution sR = this % solution % extboundary ( i , j , iel , 1 : this % nvar ) ! exterior solution dsdx = this % solutiongradient % avgboundary ( i , j , iel , 1 : this % nvar , 1 : 2 ) nmag = this % geometry % nScale % boundary ( i , j , iEl , 1 ) this % flux % boundaryNormal ( i , j , iEl , 1 : this % nvar ) = this % riemannflux2d ( sL , sR , dsdx , nhat ) * nmag enddo enddo enddo call gpuCheck ( hipMemcpy ( this % flux % boundarynormal_gpu , & c_loc ( this % flux % boundarynormal ), & sizeof ( this % flux % boundarynormal ), & hipMemcpyHostToDevice )) endsubroutine BoundaryFlux_DGModel2D subroutine sourcemethod_DGModel2D ( this ) implicit none class ( DGModel2D ), intent ( inout ) :: this ! Local integer :: iel integer :: i integer :: j real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 2 ) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % interior ), & this % solutiongradient % interior_gpu , sizeof ( this % solutiongradient % interior ), & hipMemcpyDeviceToHost )) do iel = 1 , this % mesh % nelem do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , iel , 1 : this % nvar , 1 : 2 ) this % source % interior ( i , j , iel , 1 : this % nvar ) = this % source2d ( s , dsdx ) enddo enddo enddo call gpuCheck ( hipMemcpy ( this % source % interior_gpu , & c_loc ( this % source % interior ), & sizeof ( this % source % interior ), & hipMemcpyHostToDevice )) endsubroutine sourcemethod_DGModel2D subroutine setboundarycondition_DGModel2D ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel2D ), intent ( inout ) :: this ! local integer :: i , iEl , j , e2 , bcid real ( prec ) :: nhat ( 1 : 2 ), x ( 1 : 2 ) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % boundary ), & this % solution % boundary_gpu , sizeof ( this % solution % boundary ), & hipMemcpyDeviceToHost )) do iEl = 1 , this % solution % nElem ! Loop over all elements do j = 1 , 4 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , j , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , j , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points x = this % geometry % x % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solution % extBoundary ( i , j , iEl , 1 : this % nvar ) = & this % hbc2d_Prescribed ( x , this % t ) enddo elseif ( bcid == SELF_BC_RADIATION ) then do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solution % extBoundary ( i , j , iEl , 1 : this % nvar ) = & this % hbc2d_Radiation ( this % solution % boundary ( i , j , iEl , 1 : this % nvar ), nhat ) enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solution % extBoundary ( i , j , iEl , 1 : this % nvar ) = & this % hbc2d_NoNormalFlow ( this % solution % boundary ( i , j , iEl , 1 : this % nvar ), nhat ) enddo endif endif enddo enddo call gpuCheck ( hipMemcpy ( this % solution % extBoundary_gpu , & c_loc ( this % solution % extBoundary ), & sizeof ( this % solution % extBoundary ), & hipMemcpyHostToDevice )) endsubroutine setboundarycondition_DGModel2D subroutine setgradientboundarycondition_DGModel2D ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel2D ), intent ( inout ) :: this ! local integer :: i , iEl , j , e2 , bcid real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 2 ) real ( prec ) :: nhat ( 1 : 2 ), x ( 1 : 2 ) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % boundary ), & this % solutiongradient % boundary_gpu , sizeof ( this % solutiongradient % boundary ), & hipMemcpyDeviceToHost )) do iEl = 1 , this % solution % nElem ! Loop over all elements do j = 1 , 4 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , j , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , j , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points x = this % geometry % x % boundary ( i , j , iEl , 1 , 1 : 2 ) this % solutiongradient % extBoundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) = & this % pbc2d_Prescribed ( x , this % t ) enddo elseif ( bcid == SELF_BC_RADIATION ) then do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) dsdx = this % solutiongradient % boundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) this % solutiongradient % extBoundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) = & this % pbc2d_Radiation ( dsdx , nhat ) enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , iEl , 1 , 1 : 2 ) dsdx = this % solutiongradient % boundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) this % solutiongradient % extBoundary ( i , j , iEl , 1 : this % nvar , 1 : 2 ) = & this % pbc2d_NoNormalFlow ( dsdx , nhat ) enddo endif endif enddo enddo call gpuCheck ( hipMemcpy ( this % solutiongradient % extBoundary_gpu , & c_loc ( this % solutiongradient % extBoundary ), & sizeof ( this % solutiongradient % extBoundary ), & hipMemcpyHostToDevice )) endsubroutine setgradientboundarycondition_DGModel2D subroutine CalculateTendency_DGModel2D ( this ) implicit none class ( DGModel2D ), intent ( inout ) :: this ! Local integer :: ndof call this % solution % BoundaryInterp () call this % solution % SideExchange ( this % mesh ) call this % PreTendency () ! User-supplied call this % SetBoundaryCondition () ! User-supplied if ( this % gradient_enabled ) then call this % CalculateSolutionGradient () call this % SetGradientBoundaryCondition () ! User-supplied call this % solutionGradient % AverageSides () endif call this % SourceMethod () ! User supplied call this % BoundaryFlux () ! User supplied call this % FluxMethod () ! User supplied call this % flux % MappedDGDivergence ( this % fluxDivergence % interior_gpu ) ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call CalculateDSDt_gpu ( this % fluxDivergence % interior_gpu , this % source % interior_gpu , & this % dsdt % interior_gpu , ndof ) endsubroutine CalculateTendency_DGModel2D endmodule SELF_DGModel2D","tags":"","loc":"sourcefile/self_dgmodel2d.f90.html"},{"title":"SELF_advection_diffusion_1d.f90 – SELF","text":"Contents Modules self_advection_diffusion_1d Source Code SELF_advection_diffusion_1d.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_advection_diffusion_1d use self_dgmodel1d use self_advection_diffusion_1d_t use SELF_GPU implicit none type , extends ( advection_diffusion_1d_t ) :: advection_diffusion_1d contains procedure :: setboundarycondition => setboundarycondition_advection_diffusion_1d procedure :: setgradientboundarycondition => setgradientboundarycondition_advection_diffusion_1d procedure :: boundaryflux => boundaryflux_advection_diffusion_1d procedure :: fluxmethod => fluxmethod_advection_diffusion_1d endtype advection_diffusion_1d interface subroutine setboundarycondition_advection_diffusion_1d_gpu ( extboundary , boundary , nel , nvar ) & bind ( c , name = \"setboundarycondition_advection_diffusion_1d_gpu\" ) use iso_c_binding type ( c_ptr ), value :: extboundary , boundary integer ( c_int ), value :: nel , nvar endsubroutine setboundarycondition_advection_diffusion_1d_gpu endinterface interface subroutine fluxmethod_advection_diffusion_1d_gpu ( solution , solutiongradient , flux , u , nu , ndof ) & bind ( c , name = \"fluxmethod_advection_diffusion_1d_gpu\" ) use iso_c_binding use SELF_Constants type ( c_ptr ), value :: solution , solutiongradient , flux real ( c_prec ), value :: u , nu integer ( c_int ), value :: ndof endsubroutine fluxmethod_advection_diffusion_1d_gpu endinterface interface subroutine boundaryflux_advection_diffusion_1d_gpu ( fb , fextb , dfavg , flux , u , nu , ndof ) & bind ( c , name = \"boundaryflux_advection_diffusion_1d_gpu\" ) use iso_c_binding use SELF_Constants type ( c_ptr ), value :: fb , fextb , dfavg , flux real ( c_prec ), value :: u , nu integer ( c_int ), value :: ndof endsubroutine boundaryflux_advection_diffusion_1d_gpu endinterface contains subroutine setboundarycondition_advection_diffusion_1d ( this ) !! Boundary conditions are set to periodic boundary conditions implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this call setboundarycondition_advection_diffusion_1d_gpu ( this % solution % extboundary_gpu , & this % solution % boundary_gpu , this % solution % nelem , this % solution % nvar ) endsubroutine setboundarycondition_advection_diffusion_1d subroutine setgradientboundarycondition_advection_diffusion_1d ( this ) !! Gradient boundary conditions are set to periodic boundary conditions implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this call setboundarycondition_advection_diffusion_1d_gpu ( this % solutiongradient % extboundary_gpu , & this % solutiongradient % boundary_gpu , this % solution % nelem , this % solution % nvar ) endsubroutine setgradientboundarycondition_advection_diffusion_1d subroutine fluxmethod_advection_diffusion_1d ( this ) implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this ! Local integer :: ndof ndof = this % solution % nelem * this % solution % nvar * ( this % solution % interp % N + 1 ) call fluxmethod_advection_diffusion_1d_gpu ( this % solution % interior_gpu , & this % solutiongradient % interior_gpu , this % flux % interior_gpu , & this % u , this % nu , ndof ) endsubroutine fluxmethod_advection_diffusion_1d subroutine boundaryflux_advection_diffusion_1d ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( advection_diffusion_1d ), intent ( inout ) :: this ! Local integer :: ndof ndof = this % solution % nelem * this % solution % nvar * 2 call boundaryflux_advection_diffusion_1d_gpu ( this % solution % boundary_gpu , & this % solution % extBoundary_gpu , this % solutionGradient % avgBoundary_gpu , & this % flux % boundarynormal_gpu , this % u , this % nu , ndof ) endsubroutine boundaryflux_advection_diffusion_1d endmodule self_advection_diffusion_1d","tags":"","loc":"sourcefile/self_advection_diffusion_1d.f90.html"},{"title":"SELF_advection_diffusion_3d.f90 – SELF","text":"Contents Modules self_advection_diffusion_3d Source Code SELF_advection_diffusion_3d.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_advection_diffusion_3d use self_advection_diffusion_3d_t implicit none type , extends ( advection_diffusion_3d_t ) :: advection_diffusion_3d contains procedure :: setboundarycondition => setboundarycondition_advection_diffusion_3d procedure :: setgradientboundarycondition => setgradientboundarycondition_advection_diffusion_3d procedure :: boundaryflux => boundaryflux_advection_diffusion_3d procedure :: fluxmethod => fluxmethod_advection_diffusion_3d procedure :: CalculateEntropy => CalculateEntropy_advection_diffusion_3d endtype advection_diffusion_3d interface subroutine setboundarycondition_advection_diffusion_3d_gpu ( extboundary , boundary , sideinfo , N , nel , nvar ) & bind ( c , name = \"setboundarycondition_advection_diffusion_3d_gpu\" ) use iso_c_binding type ( c_ptr ), value :: extboundary , boundary , sideinfo integer ( c_int ), value :: N , nel , nvar endsubroutine setboundarycondition_advection_diffusion_3d_gpu endinterface interface subroutine setgradientboundarycondition_advection_diffusion_3d_gpu ( extboundary , boundary , sideinfo , N , nel , nvar ) & bind ( c , name = \"setgradientboundarycondition_advection_diffusion_3d_gpu\" ) use iso_c_binding type ( c_ptr ), value :: extboundary , boundary , sideinfo integer ( c_int ), value :: N , nel , nvar endsubroutine setgradientboundarycondition_advection_diffusion_3d_gpu endinterface interface subroutine fluxmethod_advection_diffusion_3d_gpu ( solution , solutiongradient , flux , u , v , w , nu , N , nel , nvar ) & bind ( c , name = \"fluxmethod_advection_diffusion_3d_gpu\" ) use iso_c_binding use SELF_Constants type ( c_ptr ), value :: solution , solutiongradient , flux real ( c_prec ), value :: u , v , w , nu integer ( c_int ), value :: N , nel , nvar endsubroutine fluxmethod_advection_diffusion_3d_gpu endinterface interface subroutine boundaryflux_advection_diffusion_3d_gpu ( fb , fextb , dfavg , nhat , nscale , flux , u , v , w , nu , N , nel , nvar ) & bind ( c , name = \"boundaryflux_advection_diffusion_3d_gpu\" ) use iso_c_binding use SELF_Constants type ( c_ptr ), value :: fb , fextb , dfavg , flux , nhat , nscale real ( c_prec ), value :: u , v , w , nu integer ( c_int ), value :: N , nel , nvar endsubroutine boundaryflux_advection_diffusion_3d_gpu endinterface contains subroutine CalculateEntropy_advection_diffusion_3d ( this ) implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this ! Local integer :: iel , i , j , k , ivar , ierror real ( prec ) :: e , s , jac call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) e = 0.0_prec do ivar = 1 , this % solution % nvar do iel = 1 , this % geometry % nelem do k = 1 , this % solution % interp % N + 1 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 jac = this % geometry % J % interior ( i , j , k , iel , 1 ) s = this % solution % interior ( i , j , k , iel , ivar ) e = e + 0.5_prec * s * s * jac enddo enddo enddo enddo enddo if ( this % mesh % decomp % mpiEnabled ) then call mpi_allreduce ( e , & this % entropy , & 1 , & this % mesh % decomp % mpiPrec , & MPI_SUM , & this % mesh % decomp % mpiComm , & iError ) else this % entropy = e endif endsubroutine CalculateEntropy_advection_diffusion_3d subroutine setboundarycondition_advection_diffusion_3d ( this ) !! Boundary conditions are set to periodic boundary conditions implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this call setboundarycondition_advection_diffusion_3d_gpu ( this % solution % extboundary_gpu , & this % solution % boundary_gpu , this % mesh % sideInfo_gpu , this % solution % interp % N , & this % solution % nelem , this % solution % nvar ) endsubroutine setboundarycondition_advection_diffusion_3d subroutine setgradientboundarycondition_advection_diffusion_3d ( this ) !! Gradient boundary conditions are set to periodic boundary conditions implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this call setgradientboundarycondition_advection_diffusion_3d_gpu ( & this % solutiongradient % extboundary_gpu , & this % solutiongradient % boundary_gpu , this % mesh % sideInfo_gpu , & this % solution % interp % N , this % solution % nelem , this % solution % nvar ) endsubroutine setgradientboundarycondition_advection_diffusion_3d subroutine fluxmethod_advection_diffusion_3d ( this ) implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this call fluxmethod_advection_diffusion_3d_gpu ( this % solution % interior_gpu , & this % solutiongradient % interior_gpu , this % flux % interior_gpu , & this % u , this % v , this % w , this % nu , this % solution % interp % N , & this % solution % nelem , & this % solution % nvar ) endsubroutine fluxmethod_advection_diffusion_3d subroutine boundaryflux_advection_diffusion_3d ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( advection_diffusion_3d ), intent ( inout ) :: this call boundaryflux_advection_diffusion_3d_gpu ( this % solution % boundary_gpu , & this % solution % extBoundary_gpu , this % solutionGradient % avgBoundary_gpu , & this % geometry % nhat % boundary_gpu , this % geometry % nscale % boundary_gpu , & this % flux % boundarynormal_gpu , this % u , this % v , this % w , & this % nu , this % solution % interp % N , & this % solution % nelem , this % solution % nvar ) endsubroutine boundaryflux_advection_diffusion_3d endmodule self_advection_diffusion_3d","tags":"","loc":"sourcefile/self_advection_diffusion_3d.f90.html"},{"title":"SELF_GPU_enums.f90 – SELF","text":"Contents Modules SELF_GPU_enums Source Code SELF_GPU_enums.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_GPU_enums use iso_c_binding implicit none enum , bind ( c ) enumerator :: hipSuccess = 0 endenum enum , bind ( c ) enumerator :: hipMemcpyHostToHost = 0 enumerator :: hipMemcpyHostToDevice = 1 enumerator :: hipMemcpyDeviceToHost = 2 enumerator :: hipMemcpyDeviceToDevice = 3 enumerator :: hipMemcpyDefault = 4 endenum enum , bind ( c ) enumerator :: HIPBLAS_STATUS_SUCCESS = 0 enumerator :: HIPBLAS_STATUS_NOT_INITIALIZED = 1 enumerator :: HIPBLAS_STATUS_ALLOC_FAILED = 2 enumerator :: HIPBLAS_STATUS_INVALID_VALUE = 3 enumerator :: HIPBLAS_STATUS_MAPPING_ERROR = 4 enumerator :: HIPBLAS_STATUS_EXECUTION_FAILED = 5 enumerator :: HIPBLAS_STATUS_INTERNAL_ERROR = 6 enumerator :: HIPBLAS_STATUS_NOT_SUPPORTED = 7 enumerator :: HIPBLAS_STATUS_ARCH_MISMATCH = 8 enumerator :: HIPBLAS_STATUS_HANDLE_IS_NULLPTR = 9 enumerator :: HIPBLAS_STATUS_INVALID_ENUM = 10 enumerator :: HIPBLAS_STATUS_UNKNOWN = 11 endenum enum , bind ( c ) #ifdef HAVE_CUDA enumerator :: HIPBLAS_OP_N = 0 #else enumerator :: HIPBLAS_OP_N = 111 #endif #ifdef HAVE_CUDA enumerator :: HIPBLAS_OP_T = 1 #else enumerator :: HIPBLAS_OP_T = 112 #endif endenum endmodule SELF_GPU_enums","tags":"","loc":"sourcefile/self_gpu_enums.f90.html"},{"title":"SELF_NullDGModel1D.f90 – SELF","text":"Contents Modules self_NullDGModel1D Source Code SELF_NullDGModel1D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_NullDGModel1D use self_NullDGModel1D_t implicit none type , extends ( NullDGModel1D_t ) :: NullDGModel1D endtype NullDGModel1D endmodule self_NullDGModel1D","tags":"","loc":"sourcefile/self_nulldgmodel1d.f90.html"},{"title":"SELF_DGModel1D.f90 – SELF","text":"Contents Modules SELF_DGModel1D Source Code SELF_DGModel1D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_DGModel1D use SELF_SupportRoutines use SELF_Metadata use SELF_Mesh_1D use SELF_MappedScalar_1D use SELF_HDF5 use HDF5 use FEQParse use SELF_Model use SELF_DGModel1D_t use SELF_GPU use SELF_GPUInterfaces implicit none type , extends ( DGModel1D_t ) :: DGModel1D contains procedure :: UpdateSolution => UpdateSolution_DGModel1D procedure :: CalculateEntropy => CalculateEntropy_DGModel1D procedure :: BoundaryFlux => BoundaryFlux_DGModel1D procedure :: FluxMethod => fluxmethod_DGModel1D procedure :: SourceMethod => sourcemethod_DGModel1D procedure :: SetBoundaryCondition => setboundarycondition_DGModel1D procedure :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel1D procedure :: UpdateGRK2 => UpdateGRK2_DGModel1D procedure :: UpdateGRK3 => UpdateGRK3_DGModel1D procedure :: UpdateGRK4 => UpdateGRK4_DGModel1D procedure :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel1D procedure :: CalculateTendency => CalculateTendency_DGModel1D endtype DGModel1D contains subroutine UpdateSolution_DGModel1D ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) implicit none class ( DGModel1D ), intent ( inout ) :: this real ( prec ), optional , intent ( in ) :: dt ! Local real ( prec ) :: dtLoc integer :: ndof if ( present ( dt )) then dtLoc = dt else dtLoc = this % dt endif ndof = this % solution % nvar * this % solution % nelem * ( this % solution % interp % N + 1 ) call UpdateSolution_gpu ( this % solution % interior_gpu , this % dsdt % interior_gpu , dtLoc , ndof ) endsubroutine UpdateSolution_DGModel1D subroutine UpdateGRK2_DGModel1D ( this , m ) implicit none class ( DGModel1D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * this % solution % nelem * ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk2_a ( m ), rk2_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK2_DGModel1D subroutine UpdateGRK3_DGModel1D ( this , m ) implicit none class ( DGModel1D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * this % solution % nelem * ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk3_a ( m ), rk3_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK3_DGModel1D subroutine UpdateGRK4_DGModel1D ( this , m ) implicit none class ( DGModel1D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * this % solution % nelem * ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk4_a ( m ), rk4_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK4_DGModel1D subroutine CalculateSolutionGradient_DGModel1D ( this ) implicit none class ( DGModel1D ), intent ( inout ) :: this ! Local integer :: ndof call this % solution % AverageSides () ! Account for the outward pointing normal before computing dg derivative ndof = this % solution % nvar * this % solution % nelem * 2 call GradientNormal_1D_gpu ( this % solution % boundarynormal_gpu , & this % solution % avgBoundary_gpu , ndof ) call this % solution % MappedDGDerivative ( this % solutionGradient % interior_gpu ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp () ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh ) endsubroutine CalculateSolutionGradient_DGModel1D subroutine CalculateEntropy_DGModel1D ( this ) implicit none class ( DGModel1D ), intent ( inout ) :: this ! Local integer :: iel , i , ivar real ( prec ) :: e , s ( 1 : this % solution % nvar ), J call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) e = 0.0_prec do iel = 1 , this % geometry % nelem do i = 1 , this % solution % interp % N + 1 J = this % geometry % dxds % interior ( i , iel , 1 ) s ( 1 : this % solution % nvar ) = this % solution % interior ( i , iel , 1 : this % solution % nvar ) e = e + this % entropy_func ( s ) * J enddo enddo this % entropy = e endsubroutine CalculateEntropy_DGModel1D subroutine setboundarycondition_DGModel1D ( this ) ! Here, we use the pre-tendency method to calculate the ! derivative of the solution using a bassi-rebay method ! We then do a boundary interpolation and side exchange ! on the gradient field implicit none class ( DGModel1D ), intent ( inout ) :: this ! local integer :: ivar integer :: N , nelem real ( prec ) :: x call gpuCheck ( hipMemcpy ( c_loc ( this % solution % boundary ), & this % solution % boundary_gpu , sizeof ( this % solution % boundary ), & hipMemcpyDeviceToHost )) nelem = this % geometry % nelem ! number of elements in the mesh N = this % solution % interp % N ! polynomial degree ! left-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 1 , 1 , 1 ) this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % hbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % hbc1d_Radiation ( this % solution % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % hbc1d_NoNormalFlow ( this % solution % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solution % extBoundary ( 1 , 1 , 1 : this % nvar ) = this % solution % boundary ( 2 , nelem , 1 : this % nvar ) endif ! right-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 2 , nelem , 1 ) this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % hbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % hbc1d_Radiation ( this % solution % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % hbc1d_NoNormalFlow ( this % solution % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solution % extBoundary ( 2 , nelem , 1 : this % nvar ) = this % solution % boundary ( 1 , 1 , 1 : this % nvar ) endif call gpuCheck ( hipMemcpy ( this % solution % extBoundary_gpu , & c_loc ( this % solution % extBoundary ), & sizeof ( this % solution % extBoundary ), & hipMemcpyHostToDevice )) endsubroutine setboundarycondition_DGModel1D subroutine setgradientboundarycondition_DGModel1D ( this ) ! Here, we set the boundary conditions for the ! solution and the solution gradient at the left ! and right most boundaries. ! ! Here, we use periodic boundary conditions implicit none class ( DGModel1D ), intent ( inout ) :: this ! local integer :: ivar integer :: nelem real ( prec ) :: x call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % boundary ), & this % solutiongradient % boundary_gpu , sizeof ( this % solutiongradient % boundary ), & hipMemcpyDeviceToHost )) nelem = this % geometry % nelem ! number of elements in the mesh ! left-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 1 , 1 , 1 ) this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % pbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % pbc1d_Radiation ( this % solutionGradient % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = & this % pbc1d_NoNormalFlow ( this % solutionGradient % boundary ( 1 , 1 , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solutionGradient % extBoundary ( 1 , 1 , 1 : this % nvar ) = this % solutionGradient % boundary ( 2 , nelem , 1 : this % nvar ) endif ! right-most boundary if ( this % mesh % bcid ( 1 ) == SELF_BC_PRESCRIBED ) then x = this % geometry % x % boundary ( 2 , nelem , 1 ) this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % pbc1d_Prescribed ( x , this % t ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_RADIATION ) then this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % pbc1d_Radiation ( this % solutionGradient % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) elseif ( this % mesh % bcid ( 1 ) == SELF_BC_NONORMALFLOW ) then this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = & this % pbc1d_NoNormalFlow ( this % solutionGradient % boundary ( 2 , nelem , 1 : this % nvar ), - 1.0_prec ) else ! Periodic this % solutionGradient % extBoundary ( 2 , nelem , 1 : this % nvar ) = this % solutionGradient % boundary ( 1 , 1 , 1 : this % nvar ) endif call gpuCheck ( hipMemcpy ( this % solutiongradient % extBoundary_gpu , & c_loc ( this % solutiongradient % extBoundary ), & sizeof ( this % solutiongradient % extBoundary ), & hipMemcpyHostToDevice )) endsubroutine setgradientboundarycondition_DGModel1D subroutine BoundaryFlux_DGModel1D ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( DGModel1D ), intent ( inout ) :: this ! Local integer :: iel integer :: iside real ( prec ) :: fin ( 1 : this % solution % nvar ) real ( prec ) :: fout ( 1 : this % solution % nvar ) real ( prec ) :: dfdx ( 1 : this % solution % nvar ), nhat call gpuCheck ( hipMemcpy ( c_loc ( this % solution % boundary ), & this % solution % boundary_gpu , sizeof ( this % solution % boundary ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % extboundary ), & this % solution % extboundary_gpu , sizeof ( this % solution % extboundary ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % avgboundary ), & this % solutiongradient % avgboundary_gpu , sizeof ( this % solutiongradient % avgboundary ), & hipMemcpyDeviceToHost )) do iel = 1 , this % mesh % nelem do iside = 1 , 2 ! set the normal velocity if ( iside == 1 ) then nhat = - 1.0_prec else nhat = 1.0_prec endif fin = this % solution % boundary ( iside , iel , 1 : this % solution % nvar ) ! interior solution fout = this % solution % extboundary ( iside , iel , 1 : this % solution % nvar ) ! exterior solution dfdx = this % solutionGradient % avgboundary ( iside , iel , 1 : this % solution % nvar ) ! average solution gradient (with direction taken into account) this % flux % boundarynormal ( iside , iel , 1 : this % solution % nvar ) = & this % riemannflux1d ( fin , fout , dfdx , nhat ) enddo enddo call gpuCheck ( hipMemcpy ( this % flux % boundarynormal_gpu , & c_loc ( this % flux % boundarynormal ), & sizeof ( this % flux % boundarynormal ), & hipMemcpyHostToDevice )) endsubroutine BoundaryFlux_DGModel1D subroutine fluxmethod_DGModel1D ( this ) implicit none class ( DGModel1D ), intent ( inout ) :: this ! Local integer :: iel integer :: i real ( prec ) :: f ( 1 : this % solution % nvar ), dfdx ( 1 : this % solution % nvar ) do iel = 1 , this % mesh % nelem do i = 1 , this % solution % interp % N + 1 f = this % solution % interior ( i , iel , 1 : this % solution % nvar ) dfdx = this % solutionGradient % interior ( i , iel , 1 : this % solution % nvar ) this % flux % interior ( i , iel , 1 : this % solution % nvar ) = & this % flux1d ( f , dfdx ) enddo enddo call gpuCheck ( hipMemcpy ( this % flux % interior_gpu , & c_loc ( this % flux % interior ), & sizeof ( this % flux % interior ), & hipMemcpyHostToDevice )) endsubroutine fluxmethod_DGModel1D subroutine sourcemethod_DGModel1D ( this ) implicit none class ( DGModel1D ), intent ( inout ) :: this ! Local integer :: iel integer :: i real ( prec ) :: f ( 1 : this % solution % nvar ), dfdx ( 1 : this % solution % nvar ) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % interior ), & this % solutiongradient % interior_gpu , sizeof ( this % solutiongradient % interior ), & hipMemcpyDeviceToHost )) do iel = 1 , this % mesh % nelem do i = 1 , this % solution % interp % N + 1 f = this % solution % interior ( i , iel , 1 : this % solution % nvar ) dfdx = this % solutionGradient % interior ( i , iel , 1 : this % solution % nvar ) this % source % interior ( i , iel , 1 : this % solution % nvar ) = & this % source1d ( f , dfdx ) enddo enddo call gpuCheck ( hipMemcpy ( this % source % interior_gpu , & c_loc ( this % source % interior ), & sizeof ( this % source % interior ), & hipMemcpyHostToDevice )) endsubroutine sourcemethod_DGModel1D subroutine CalculateTendency_DGModel1D ( this ) implicit none class ( DGModel1D ), intent ( inout ) :: this ! Local integer :: ndof call this % solution % BoundaryInterp () call this % solution % SideExchange ( this % mesh ) call this % PreTendency () ! User-supplied call this % SetBoundaryCondition () ! User-supplied if ( this % gradient_enabled ) then call this % solution % AverageSides () call this % CalculateSolutionGradient () call this % SetGradientBoundaryCondition () ! User-supplied call this % solutionGradient % AverageSides () endif call this % SourceMethod () ! User supplied call this % BoundaryFlux () ! User supplied call this % FluxMethod () ! User supplied call this % flux % MappedDGDerivative ( this % fluxDivergence % interior_gpu ) ndof = this % solution % nvar * this % solution % nelem * ( this % solution % interp % N + 1 ) call CalculateDSDt_gpu ( this % fluxDivergence % interior_gpu , this % source % interior_gpu , & this % dsdt % interior_gpu , ndof ) endsubroutine CalculateTendency_DGModel1D endmodule SELF_DGModel1D","tags":"","loc":"sourcefile/self_dgmodel1d.f90.html"},{"title":"SELF_MappedVector_3D.f90 – SELF","text":"Contents Modules SELF_MappedVector_3D Source Code SELF_MappedVector_3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_MappedVector_3D use SELF_MappedVector_3D_t use SELF_GPU use SELF_GPUInterfaces use SELF_GPUBLAS use iso_c_binding implicit none type , extends ( MappedVector3D_t ), public :: MappedVector3D contains procedure , public :: SideExchange => SideExchange_MappedVector3D procedure , public :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D generic , public :: MappedDivergence => MappedDivergence_MappedVector3D procedure , private :: MappedDivergence_MappedVector3D generic , public :: MappedDGDivergence => MappedDGDivergence_MappedVector3D procedure , private :: MappedDGDivergence_MappedVector3D procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector3D endtype MappedVector3D interface subroutine ContravariantProjection_3D_gpu ( f , dsdx , N , nvar , nel ) & bind ( c , name = \"ContravariantProjection_3D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: f , dsdx integer ( c_int ), value :: N , nvar , nel endsubroutine ContravariantProjection_3D_gpu endinterface contains subroutine SetInteriorFromEquation_MappedVector3D ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedVector3D ), intent ( inout ) :: this type ( SEMHex ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , k , iEl , iVar real ( prec ) :: x real ( prec ) :: y real ( prec ) :: z do iVar = 1 , this % nVar do iEl = 1 , this % nElem do k = 1 , this % interp % N + 1 do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , k , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , k , iEl , 1 , 2 ) z = geometry % x % interior ( i , j , k , iEl , 1 , 3 ) this % interior ( i , j , k , iEl , iVar , 1 ) = & this % eqn ( 1 + 3 * ( iVar - 1 ))% Evaluate (( / x , y , z , time / )) this % interior ( i , j , k , iEl , iVar , 2 ) = & this % eqn ( 2 + 3 * ( iVar - 1 ))% Evaluate (( / x , y , z , time / )) this % interior ( i , j , k , iEl , iVar , 3 ) = & this % eqn ( 3 + 3 * ( iVar - 1 ))% Evaluate (( / x , y , z , time / )) enddo enddo enddo enddo enddo call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) endsubroutine SetInteriorFromEquation_MappedVector3D subroutine MPIExchangeAsync_MappedVector3D ( this , mesh ) implicit none class ( MappedVector3D ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar , idir integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount real ( prec ), pointer :: boundary (:,:,:,:,:,:) real ( prec ), pointer :: extboundary (:,:,:,:,:,:) msgCount = 0 call c_f_pointer ( this % boundary_gpu , boundary ,[ this % interp % N + 1 , this % interp % N + 1 , 6 , this % nelem , this % nvar , 3 ]) call c_f_pointer ( this % extboundary_gpu , extboundary ,[ this % interp % N + 1 , this % interp % N + 1 , 6 , this % nelem , this % nvar , 3 ]) do idir = 1 , 3 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 6 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) ! create unique tag for each side and each variable tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 + this % nvar * ( idir - 1 )) msgCount = msgCount + 1 call MPI_IRECV ( extBoundary (:,:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( boundary (:,:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ) * ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedVector3D subroutine SideExchange_MappedVector3D ( this , mesh ) implicit none class ( MappedVector3D ), intent ( inout ) :: this type ( Mesh3D ), intent ( inout ) :: mesh ! Local integer :: offset offset = mesh % decomp % offsetElem ( mesh % decomp % rankId + 1 ) if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif call SideExchange_3D_gpu ( this % extboundary_gpu , & this % boundary_gpu , mesh % sideinfo_gpu , mesh % decomp % elemToRank_gpu , & mesh % decomp % rankid , offset , this % interp % N , 3 * this % nvar , this % nelem ) if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call ApplyFlip_3D_gpu ( this % extboundary_gpu , mesh % sideInfo_gpu , & mesh % decomp % elemToRank_gpu , mesh % decomp % rankId , & offset , this % interp % N , 3 * this % nVar , this % nElem ) endif endsubroutine SideExchange_MappedVector3D subroutine MappedDivergence_MappedVector3D ( this , df ) ! Strong Form Operator !    ! implicit none class ( MappedVector3D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:,:) type ( c_ptr ) :: fc ! Contravariant projection call ContravariantProjection_3D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % interp % N , this % nvar , this % nelem ) call c_f_pointer ( this % interior_gpu , f_p , & [ this % interp % N + 1 , this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 3 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_3d ( this % interp % dMatrix_gpu , fc , df , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_3d ( this % interp % dMatrix_gpu , fc , df , 1.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 3 )) call self_blas_matrixop_dim3_3d ( this % interp % dMatrix_gpu , fc , df , 1.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) f_p => null () call JacobianWeight_3D_gpu ( df , this % geometry % J % interior_gpu , this % interp % N , this % nVar , this % nelem ) endsubroutine MappedDivergence_MappedVector3D subroutine MappedDGDivergence_MappedVector3D ( this , df ) !! Computes the divergence of a 3-D vector using the weak form !! On input, the  attribute of the vector !! is assigned and the  attribute is set to the physical !! directions of the vector. This method will project the vector !! onto the contravariant basis vectors. implicit none class ( MappedVector3D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:,:) type ( c_ptr ) :: fc ! Contravariant projection call ContravariantProjection_3D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % interp % N , this % nvar , this % nelem ) call c_f_pointer ( this % interior_gpu , f_p , & [ this % interp % N + 1 , this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 3 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_3d ( this % interp % dgMatrix_gpu , fc , df , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_3d ( this % interp % dgMatrix_gpu , fc , df , 1.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 , 3 )) call self_blas_matrixop_dim3_3d ( this % interp % dgMatrix_gpu , fc , df , 1.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) f_p => null () ! Boundary terms call DG_BoundaryContribution_3D_gpu ( this % interp % bmatrix_gpu , this % interp % qweights_gpu , & this % boundarynormal_gpu , df , this % interp % N , this % nvar , this % nelem ) call JacobianWeight_3D_gpu ( df , this % geometry % J % interior_gpu , this % interp % N , this % nVar , this % nelem ) endsubroutine MappedDGDivergence_MappedVector3D endmodule SELF_MappedVector_3D","tags":"","loc":"sourcefile/self_mappedvector_3d.f90.html"},{"title":"SELF_GPU.f90 – SELF","text":"Contents Modules SELF_GPU Source Code SELF_GPU.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_GPU use iso_c_binding use SELF_GPU_enums implicit none interface hipGetDeviceCount #ifdef HAVE_HIP function hipGetDeviceCount_ ( count ) bind ( c , name = \"hipGetDeviceCount\" ) #elif HAVE_CUDA function hipGetDeviceCount_ ( count ) bind ( c , name = \"cudaGetDeviceCount\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( hipSuccess )) :: hipGetDeviceCount_ integer ( c_int ) :: count endfunction endinterface interface hipMalloc #ifdef HAVE_HIP function hipMalloc_ ( ptr , mySize ) bind ( c , name = \"hipMalloc\" ) #elif HAVE_CUDA function hipMalloc_ ( ptr , mySize ) bind ( c , name = \"cudaMalloc\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( hipSuccess )) :: hipMalloc_ type ( c_ptr ) :: ptr integer ( c_size_t ), value :: mySize endfunction endinterface hipMalloc interface hipFree #ifdef HAVE_HIP function hipFree_ ( ptr ) bind ( c , name = \"hipFree\" ) #elif HAVE_CUDA function hipFree_ ( ptr ) bind ( c , name = \"cudaFree\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( hipSuccess )) :: hipFree_ type ( c_ptr ), value :: ptr endfunction endinterface hipFree interface hipMemcpy #ifdef HAVE_HIP function hipMemcpy_ ( dest , src , sizeBytes , myKind ) bind ( c , name = \"hipMemcpy\" ) #elif HAVE_CUDA function hipMemcpy_ ( dest , src , sizeBytes , myKind ) bind ( c , name = \"cudaMemcpy\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( hipSuccess )) :: hipMemcpy_ type ( c_ptr ), value :: dest type ( c_ptr ), value :: src integer ( c_size_t ), value :: sizeBytes integer ( kind ( hipMemcpyHostToHost )), value :: myKind endfunction hipMemcpy_ endinterface hipMemcpy contains subroutine gpuCheck ( gpuError_t ) implicit none integer ( kind ( hipSuccess )) :: gpuError_t if ( gpuError_t /= hipSuccess ) then write ( * , * ) \"GPU ERROR: Error code = \" , gpuError_t call exit ( gpuError_t ) endif endsubroutine gpuCheck function GPUAvailable () result ( avail ) implicit none logical :: avail ! Local integer ( c_int ) :: gpuCount integer ( kind ( hipSuccess )) :: err err = hipGetDeviceCount ( gpuCount ) if ( gpuCount > 0 . and . err == hipSuccess ) then avail = . true . else avail = . false . endif endfunction GPUAvailable ! subroutine HostToDevice(fsource,fdest) !   implicit none !   type(c_ptr), intent(inout) :: fsource !   type(c_ptr), intent(inout) :: fdest !   call gpuCheck(hipMemcpy(fdest,fsource,sizeof(fsource),hipMemcpyHostToDevice)) ! endsubroutine HostToDevice ! subroutine DeviceToHost(fsource,fdest) !   implicit none !   type(c_ptr), intent(inout)    :: fsource !   type(c_ptr), intent(inout) :: fdest !   call gpuCheck(hipMemcpy(fdest,fsource,sizeof(fsource),hipMemcpyDeviceToHost)) ! endsubroutine DeviceToHost endmodule SELF_GPU","tags":"","loc":"sourcefile/self_gpu.f90.html"},{"title":"SELF_Mesh_3D.f90 – SELF","text":"Contents Modules SELF_Mesh_3D Source Code SELF_Mesh_3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Mesh_3D use SELF_Mesh_3D_t use SELF_GPU use iso_c_binding implicit none type , extends ( Mesh3D_t ) :: Mesh3D type ( c_ptr ) :: sideInfo_gpu contains procedure , public :: Init => Init_Mesh3D procedure , public :: Free => Free_Mesh3D procedure , public :: Read_HOPr => Read_HOPr_Mesh3D endtype Mesh3D contains subroutine Init_Mesh3D ( this , nGeo , nElem , nSides , nNodes , nBCs ) implicit none class ( Mesh3D ), intent ( inout ) :: this integer , intent ( in ) :: nGeo integer , intent ( in ) :: nElem integer , intent ( in ) :: nSides integer , intent ( in ) :: nNodes integer , intent ( in ) :: nBCs ! Local integer :: i , j , k , l this % nElem = nElem this % nGlobalElem = nElem this % nGeo = nGeo this % nSides = nSides this % nNodes = nNodes this % nCornerNodes = 0 this % nUniqueSides = 0 this % nUniqueNodes = 0 this % nBCs = nBCs allocate ( this % elemInfo ( 1 : 6 , 1 : nElem )) allocate ( this % sideInfo ( 1 : 5 , 1 : 6 , 1 : nElem )) allocate ( this % nodeCoords ( 1 : 3 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % globalNodeIDs ( 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nGeo + 1 , 1 : nElem )) allocate ( this % CGNSCornerMap ( 1 : 3 , 1 : 8 )) allocate ( this % CGNSSideMap ( 1 : 4 , 1 : 6 )) allocate ( this % sideMap ( 1 : 4 , 1 : 6 )) allocate ( this % BCType ( 1 : 4 , 1 : nBCs )) allocate ( this % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation this % CGNSCornerMap ( 1 : 3 , 1 ) = ( / 1 , 1 , 1 / ) ! Bottom-South-West this % CGNSCornerMap ( 1 : 3 , 2 ) = ( / nGeo + 1 , 1 , 1 / ) ! Bottom-South-East this % CGNSCornerMap ( 1 : 3 , 3 ) = ( / nGeo + 1 , nGeo + 1 , 1 / ) ! Bottom-North-East this % CGNSCornerMap ( 1 : 3 , 4 ) = ( / 1 , nGeo + 1 , 1 / ) ! Bottom-North-West this % CGNSCornerMap ( 1 : 3 , 5 ) = ( / 1 , 1 , nGeo + 1 / ) ! Top-South-West this % CGNSCornerMap ( 1 : 3 , 6 ) = ( / nGeo + 1 , 1 , nGeo + 1 / ) ! Top-South-East this % CGNSCornerMap ( 1 : 3 , 7 ) = ( / nGeo + 1 , nGeo + 1 , nGeo + 1 / ) ! Top-North-East this % CGNSCornerMap ( 1 : 3 , 8 ) = ( / 1 , nGeo + 1 , nGeo + 1 / ) ! Top-North-West ! Maps from local corner node id to CGNS side this % CGNSSideMap ( 1 : 4 , 1 ) = ( / 1 , 4 , 3 , 2 / ) this % CGNSSideMap ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) this % CGNSSideMap ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) this % CGNSSideMap ( 1 : 4 , 4 ) = ( / 3 , 4 , 8 , 7 / ) this % CGNSSideMap ( 1 : 4 , 5 ) = ( / 1 , 5 , 8 , 4 / ) this % CGNSSideMap ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) ! Sidemap traverses each face so that the normal ! formed by the right hand rule is the coordinate ! positive pointing normal. For east,north,and top ! this is an outward facing normal. ! For bottom, south, and west, the normal is inward ! facing. this % sideMap ( 1 : 4 , 1 ) = ( / 1 , 2 , 3 , 4 / ) ! Bottom this % sideMap ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) ! South this % sideMap ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) ! East this % sideMap ( 1 : 4 , 4 ) = ( / 4 , 3 , 7 , 8 / ) ! North this % sideMap ( 1 : 4 , 5 ) = ( / 1 , 4 , 8 , 5 / ) ! West this % sideMap ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) ! Top call gpuCheck ( hipMalloc ( this % sideInfo_gpu , sizeof ( this % sideInfo ))) endsubroutine Init_Mesh3D subroutine Free_Mesh3D ( this ) implicit none class ( Mesh3D ), intent ( inout ) :: this this % nElem = 0 this % nSides = 0 this % nNodes = 0 this % nCornerNodes = 0 this % nUniqueSides = 0 this % nUniqueNodes = 0 this % nBCs = 0 deallocate ( this % elemInfo ) deallocate ( this % sideInfo ) deallocate ( this % nodeCoords ) deallocate ( this % globalNodeIDs ) deallocate ( this % CGNSCornerMap ) deallocate ( this % sideMap ) deallocate ( this % CGNSSideMap ) deallocate ( this % BCType ) deallocate ( this % BCNames ) call this % decomp % Free () call gpuCheck ( hipFree ( this % sideInfo_gpu )) endsubroutine Free_Mesh3D subroutine Read_HOPr_Mesh3D ( this , meshFile , enableDomainDecomposition ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 implicit none class ( Mesh3D ), intent ( out ) :: this character ( * ), intent ( in ) :: meshFile logical , intent ( in ), optional :: enableDomainDecomposition ! Local integer ( HID_T ) :: fileId integer ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) integer :: nGlobalElem integer :: firstElem integer :: firstNode integer :: firstSide integer :: nLocalElems integer :: nLocalNodes integer :: nLocalSides integer :: nUniqueSides integer :: nGeo , nBCs integer :: eid , lsid , iSide integer :: i , j , k , nid integer , dimension (:,:), allocatable :: hopr_elemInfo integer , dimension (:,:), allocatable :: hopr_sideInfo real ( prec ), dimension (:,:), allocatable :: hopr_nodeCoords integer , dimension (:), allocatable :: hopr_globalNodeIDs integer , dimension (:,:), allocatable :: bcType if ( present ( enableDomainDecomposition )) then call this % decomp % init ( enableDomainDecomposition ) else call this % decomp % init (. false .) endif if ( this % decomp % mpiEnabled ) then call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId , this % decomp % mpiComm ) else call Open_HDF5 ( meshFile , H5F_ACC_RDONLY_F , fileId ) endif call ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) call ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) call ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) call ReadAttribute_HDF5 ( fileId , 'nUniqueSides' , nUniqueSides ) ! Read BCType allocate ( bcType ( 1 : 4 , 1 : nBCs )) if ( this % decomp % mpiEnabled ) then offset (:) = 0 call ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) else call ReadArray_HDF5 ( fileId , 'BCType' , bcType ) endif ! Read local subarray of ElemInfo call this % decomp % GenerateDecomposition ( nGlobalElem , nUniqueSides ) firstElem = this % decomp % offsetElem ( this % decomp % rankId + 1 ) + 1 nLocalElems = this % decomp % offsetElem ( this % decomp % rankId + 2 ) - & this % decomp % offsetElem ( this % decomp % rankId + 1 ) ! Allocate Space for hopr_elemInfo! allocate ( hopr_elemInfo ( 1 : 6 , 1 : nLocalElems )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstElem - 1 / ) call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) else call ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) endif ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo ( 5 , 1 ) + 1 nLocalNodes = hopr_elemInfo ( 6 , nLocalElems ) - hopr_elemInfo ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! allocate ( hopr_nodeCoords ( 1 : 3 , 1 : nLocalNodes ), hopr_globalNodeIDs ( 1 : nLocalNodes )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) else call ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) call ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) endif ! Read local subarray of SideInfo firstSide = hopr_elemInfo ( 3 , 1 ) + 1 nLocalSides = hopr_elemInfo ( 4 , nLocalElems ) - hopr_elemInfo ( 3 , 1 ) ! Allocate space for hopr_sideInfo allocate ( hopr_sideInfo ( 1 : 5 , 1 : nLocalSides )) if ( this % decomp % mpiEnabled ) then offset = ( / 0 , firstSide - 1 / ) call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) else call ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) endif call Close_HDF5 ( fileID ) ! ---- Done reading 3-D Mesh information ---- ! ! Load hopr data into mesh data structure call this % Init ( nGeo , nLocalElems , nLocalSides , nLocalNodes , nBCs ) ! Copy data from local arrays into this this % elemInfo = hopr_elemInfo this % nUniqueSides = nUniqueSides this % quadrature = UNIFORM ! Grab the node coordinates do eid = 1 , this % nElem do k = 1 , nGeo + 1 do j = 1 , nGeo + 1 do i = 1 , nGeo + 1 nid = i + ( nGeo + 1 ) * ( j - 1 + ( nGeo + 1 ) * ( k - 1 + ( nGeo + 1 ) * ( eid - 1 ))) this % nodeCoords ( 1 : 3 , i , j , k , eid ) = hopr_nodeCoords ( 1 : 3 , nid ) this % globalNodeIDs ( i , j , k , eid ) = hopr_globalNodeIDs ( nid ) enddo enddo enddo enddo iSide = 0 do eid = 1 , this % nElem do lsid = 1 , 6 iSide = iSide + 1 this % sideInfo ( 1 : 5 , lsid , eid ) = hopr_sideInfo ( 1 : 5 , iSide ) enddo enddo call this % RecalculateFlip () deallocate ( hopr_elemInfo , hopr_nodeCoords , hopr_globalNodeIDs , hopr_sideInfo ) call gpuCheck ( hipMemcpy ( this % sideInfo_gpu , c_loc ( this % sideInfo ), sizeof ( this % sideInfo ), hipMemcpyHostToDevice )) endsubroutine Read_HOPr_Mesh3D endmodule SELF_Mesh_3D","tags":"","loc":"sourcefile/self_mesh_3d.f90.html"},{"title":"SELF_MappedScalar_1D.f90 – SELF","text":"Contents Modules SELF_MappedScalar_1D Source Code SELF_MappedScalar_1D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_MappedScalar_1D use SELF_MappedScalar_1D_t use SELF_GPU use iso_c_binding implicit none type , extends ( MappedScalar1D_t ), public :: MappedScalar1D contains procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar1D procedure , public :: SideExchange => SideExchange_MappedScalar1D generic , public :: MappedDerivative => MappedDerivative_MappedScalar1D procedure , private :: MappedDerivative_MappedScalar1D generic , public :: MappedDGDerivative => MappedDGDerivative_MappedScalar1D procedure , private :: MappedDGDerivative_MappedScalar1D endtype MappedScalar1D interface subroutine JacobianWeight_1D_gpu ( scalar , dxds , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_1D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: scalar , dxds integer ( c_int ), value :: N , nVar , nEl endsubroutine JacobianWeight_1D_gpu endinterface interface subroutine DGDerivative_BoundaryContribution_1D_gpu ( bMatrix , qWeights , bf , df , N , nVar , nEl ) & bind ( c , name = \"DGDerivative_BoundaryContribution_1D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: bMatrix , qWeights , bf , df integer ( c_int ), value :: N , nVar , nEl endsubroutine DGDerivative_BoundaryContribution_1D_gpu endinterface contains subroutine SetInteriorFromEquation_MappedScalar1D ( this , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedScalar1D ), intent ( inout ) :: this real ( prec ), intent ( in ) :: time ! Local integer :: iVar do ivar = 1 , this % nvar this % interior (:,:, ivar ) = this % eqn ( ivar )% evaluate ( this % geometry % x % interior ) enddo call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) endsubroutine SetInteriorFromEquation_MappedScalar1D subroutine SideExchange_MappedScalar1D ( this , mesh ) implicit none class ( MappedScalar1D ), intent ( inout ) :: this type ( Mesh1D ), intent ( inout ) :: mesh ! Local integer :: e1 , e2 , s1 , s2 integer :: ivar call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) do ivar = 1 , this % nvar do e1 = 1 , mesh % nElem if ( e1 == 1 ) then s1 = 2 e2 = e1 + 1 s2 = 1 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) elseif ( e1 == mesh % nElem ) then s1 = 1 e2 = e1 - 1 s2 = 2 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) else s1 = 1 e2 = e1 - 1 s2 = 2 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) s1 = 2 e2 = e1 + 1 s2 = 1 this % extBoundary ( s1 , e1 , ivar ) = this % boundary ( s2 , e2 , ivar ) endif enddo enddo call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) endsubroutine SideExchange_MappedScalar1D subroutine MappedDerivative_MappedScalar1D ( this , dF ) implicit none class ( MappedScalar1D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df ! Local integer :: iEl , iVar , i , ii real ( prec ) :: dfloc call this % Derivative ( df ) call JacobianWeight_1D_gpu ( df , this % geometry % dxds % interior_gpu , this % N , this % nVar , this % nelem ) endsubroutine MappedDerivative_MappedScalar1D subroutine MappedDGDerivative_MappedScalar1D ( this , dF ) implicit none class ( MappedScalar1D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df ! Local integer :: iEl , iVar , i , ii real ( prec ) :: dfloc call self_blas_matrixop_1d ( this % interp % dgMatrix_gpu , & this % interior_gpu , & df , this % N + 1 , this % N + 1 , & this % nvar * this % nelem , this % blas_handle ) call DGDerivative_BoundaryContribution_1D_gpu ( this % interp % bMatrix_gpu , & this % interp % qWeights_gpu , & this % boundarynormal_gpu , df , & this % N , this % nVar , this % nelem ) call JacobianWeight_1D_gpu ( df , this % geometry % dxds % interior_gpu , this % N , this % nVar , this % nelem ) endsubroutine MappedDGDerivative_MappedScalar1D endmodule SELF_MappedScalar_1D","tags":"","loc":"sourcefile/self_mappedscalar_1d.f90.html"},{"title":"SELF_Tensor_3D.f90 – SELF","text":"Contents Modules SELF_Tensor_3D Source Code SELF_Tensor_3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Tensor_3D use SELF_Constants use SELF_Tensor_3D_t use SELF_GPU use SELF_GPUBLAS use iso_c_binding use iso_fortran_env implicit none type , extends ( Tensor3D_t ), public :: Tensor3D character ( 3 ) :: backend = \"gpu\" type ( c_ptr ) :: blas_handle type ( c_ptr ) :: interior_gpu type ( c_ptr ) :: boundary_gpu type ( c_ptr ) :: extBoundary_gpu contains procedure , public :: Init => Init_Tensor3D procedure , public :: Free => Free_Tensor3D procedure , public :: UpdateHost => UpdateHost_Tensor3D procedure , public :: UpdateDevice => UpdateDevice_Tensor3D endtype Tensor3D contains subroutine Init_Tensor3D ( this , interp , nVar , nElem ) implicit none class ( Tensor3D ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 3 , 1 : 3 ), & this % boundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 , 1 : 3 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar , 1 : 3 , 1 : 3 )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 9 * nVar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 4 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call hipblasCheck ( hipblasCreate ( this % blas_handle )) call this % UpdateDevice () endsubroutine Init_Tensor3D subroutine Free_Tensor3D ( this ) implicit none class ( Tensor3D ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Tensor3D subroutine UpdateHost_Tensor3D ( this ) implicit none class ( Tensor3D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), this % interior_gpu , sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), this % extboundary_gpu , sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Tensor3D subroutine UpdateDevice_Tensor3D ( this ) implicit none class ( Tensor3D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundary_gpu , c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Tensor3D endmodule SELF_Tensor_3D","tags":"","loc":"sourcefile/self_tensor_3d.f90.html"},{"title":"SELF_NullDGModel2D.f90 – SELF","text":"Contents Modules self_NullDGModel2D Source Code SELF_NullDGModel2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_NullDGModel2D use self_NullDGModel2D_t implicit none type , extends ( NullDGModel2D_t ) :: NullDGModel2D endtype NullDGModel2D endmodule self_NullDGModel2D","tags":"","loc":"sourcefile/self_nulldgmodel2d.f90.html"},{"title":"SELF_Scalar_3D.f90 – SELF","text":"Contents Modules SELF_Scalar_3D Source Code SELF_Scalar_3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Scalar_3D use SELF_Constants use SELF_Scalar_3D_t use SELF_GPU use SELF_GPUBLAS use SELF_GPUInterfaces use iso_c_binding implicit none type , extends ( Scalar3D_t ), public :: Scalar3D character ( 3 ) :: backend = \"gpu\" type ( c_ptr ) :: blas_handle type ( c_ptr ) :: interior_gpu type ( c_ptr ) :: boundary_gpu type ( c_ptr ) :: boundarynormal_gpu type ( c_ptr ) :: extBoundary_gpu type ( c_ptr ) :: avgBoundary_gpu type ( c_ptr ) :: interpWork1 type ( c_ptr ) :: interpWork2 contains procedure , public :: Init => Init_Scalar3D procedure , public :: Free => Free_Scalar3D procedure , public :: UpdateHost => UpdateHost_Scalar3D procedure , public :: UpdateDevice => UpdateDevice_Scalar3D procedure , public :: BoundaryInterp => BoundaryInterp_Scalar3D procedure , public :: AverageSides => AverageSides_Scalar3D generic , public :: GridInterp => GridInterp_Scalar3D procedure , private :: GridInterp_Scalar3D generic , public :: Gradient => Gradient_Scalar3D procedure , private :: Gradient_Scalar3D endtype Scalar3D contains subroutine Init_Scalar3D ( this , interp , nVar , nElem ) implicit none class ( Scalar3D ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! Local integer ( c_size_t ) :: workSize this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar ), & this % boundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : 6 , 1 : nelem , 1 : 3 * nvar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec this % boundarynormal = 0.0_prec allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( this % avgBoundary_gpu , sizeof ( this % avgBoundary ))) call gpuCheck ( hipMalloc ( this % boundarynormal_gpu , sizeof ( this % boundarynormal ))) workSize = ( interp % N + 1 ) * ( interp % N + 1 ) * ( interp % M + 1 ) * nelem * nvar * prec call gpuCheck ( hipMalloc ( this % interpWork1 , workSize )) workSize = ( interp % N + 1 ) * ( interp % M + 1 ) * ( interp % M + 1 ) * nelem * nvar * prec call gpuCheck ( hipMalloc ( this % interpWork2 , workSize )) call this % UpdateDevice () call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_Scalar3D subroutine Free_Scalar3D ( this ) implicit none class ( Scalar3D ), intent ( inout ) :: this this % nVar = 0 this % nElem = 0 this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % boundarynormal ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call gpuCheck ( hipFree ( this % avgBoundary_gpu )) call gpuCheck ( hipFree ( this % boundarynormal_gpu )) call gpuCheck ( hipFree ( this % interpWork1 )) call gpuCheck ( hipFree ( this % interpWork2 )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Scalar3D subroutine UpdateHost_Scalar3D ( this ) implicit none class ( Scalar3D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), this % interior_gpu , sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), this % extboundary_gpu , sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % avgboundary ), this % avgboundary_gpu , sizeof ( this % avgboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundarynormal ), this % boundarynormal_gpu , sizeof ( this % boundarynormal ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Scalar3D subroutine UpdateDevice_Scalar3D ( this ) implicit none class ( Scalar3D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundary_gpu , c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % avgboundary_gpu , c_loc ( this % avgboundary ), sizeof ( this % avgboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundarynormal_gpu , c_loc ( this % boundarynormal ), sizeof ( this % boundarynormal ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Scalar3D subroutine BoundaryInterp_Scalar3D ( this ) implicit none class ( Scalar3D ), intent ( inout ) :: this call BoundaryInterp_3D_gpu ( this % interp % bMatrix_gpu , this % interior_gpu , this % boundary_gpu , & this % interp % N , this % nvar , this % nelem ) endsubroutine BoundaryInterp_Scalar3D subroutine AverageSides_Scalar3D ( this ) implicit none class ( Scalar3D ), intent ( inout ) :: this call Average_gpu ( this % avgBoundary_gpu , this % boundary_gpu , this % extBoundary_gpu , size ( this % boundary )) endsubroutine AverageSides_Scalar3D subroutine GridInterp_Scalar3D ( this , f ) implicit none class ( Scalar3D ), intent ( inout ) :: this type ( c_ptr ), intent ( inout ) :: f call self_blas_matrixop_dim1_3d ( this % interp % iMatrix_gpu , this % interior_gpu , & this % interpWork1 , this % N , this % M , this % nvar , this % nelem , & this % blas_handle ) call self_blas_matrixop_dim2_3d ( this % interp % iMatrix_gpu , this % interpWork1 , this % interpWork2 , & 0.0_c_prec , this % N , this % M , this % nvar , this % nelem , & this % blas_handle ) call self_blas_matrixop_dim3_3d ( this % interp % iMatrix_gpu , this % interpWork2 , f , & 0.0_c_prec , this % N , this % M , this % nvar , this % nelem , & this % blas_handle ) endsubroutine GridInterp_Scalar3D subroutine Gradient_Scalar3D ( this , df ) implicit none class ( Scalar3D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df !Local real ( prec ), pointer :: df_p (:,:,:,:,:,:) real ( prec ), pointer :: dfloc (:,:,:,:,:) type ( c_ptr ) :: dfc call c_f_pointer ( df , df_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 3 ]) dfloc ( 1 :, 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 :, 1 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim1_3d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) dfloc ( 1 :, 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 :, 2 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim2_3d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , 0.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) dfloc ( 1 :, 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 :, 3 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim3_3d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , 0.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) dfloc => null () df_p => null () endsubroutine Gradient_Scalar3D endmodule SELF_Scalar_3D","tags":"","loc":"sourcefile/self_scalar_3d.f90.html"},{"title":"SELF_Scalar_2D.f90 – SELF","text":"Contents Modules SELF_Scalar_2D Source Code SELF_Scalar_2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Scalar_2D use SELF_Constants use SELF_Scalar_2D_t use SELF_GPU use SELF_GPUBLAS use SELF_GPUInterfaces use iso_c_binding implicit none type , extends ( Scalar2D_t ), public :: Scalar2D character ( 3 ) :: backend = \"gpu\" type ( c_ptr ) :: blas_handle type ( c_ptr ) :: interior_gpu type ( c_ptr ) :: boundary_gpu type ( c_ptr ) :: boundarynormal_gpu type ( c_ptr ) :: extBoundary_gpu type ( c_ptr ) :: avgBoundary_gpu type ( c_ptr ) :: interpWork contains procedure , public :: Init => Init_Scalar2D procedure , public :: Free => Free_Scalar2D procedure , public :: UpdateHost => UpdateHost_Scalar2D procedure , public :: UpdateDevice => UpdateDevice_Scalar2D procedure , public :: BoundaryInterp => BoundaryInterp_Scalar2D procedure , public :: AverageSides => AverageSides_Scalar2D generic , public :: GridInterp => GridInterp_Scalar2D procedure , private :: GridInterp_Scalar2D generic , public :: Gradient => Gradient_Scalar2D procedure , private :: Gradient_Scalar2D endtype Scalar2D contains subroutine Init_Scalar2D ( this , interp , nVar , nElem ) implicit none class ( Scalar2D ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! Local integer ( c_size_t ) :: workSize this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , interp % N + 1 , nelem , nvar ), & this % boundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : 2 * nvar )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec this % boundarynormal = 0.0_prec call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( this % avgBoundary_gpu , sizeof ( this % avgBoundary ))) call gpuCheck ( hipMalloc ( this % boundarynormal_gpu , sizeof ( this % boundarynormal ))) workSize = ( interp % N + 1 ) * ( interp % M + 1 ) * nelem * nvar * prec call gpuCheck ( hipMalloc ( this % interpWork , workSize )) call this % UpdateDevice () call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_Scalar2D subroutine Free_Scalar2D ( this ) implicit none class ( Scalar2D ), intent ( inout ) :: this this % nVar = 0 this % nElem = 0 this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % boundarynormal ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call gpuCheck ( hipFree ( this % avgBoundary_gpu )) call gpuCheck ( hipFree ( this % boundarynormal_gpu )) call gpuCheck ( hipFree ( this % interpWork )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Scalar2D subroutine UpdateHost_Scalar2D ( this ) implicit none class ( Scalar2D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), this % interior_gpu , sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), this % extboundary_gpu , sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % avgboundary ), this % avgboundary_gpu , sizeof ( this % avgboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundarynormal ), this % boundarynormal_gpu , sizeof ( this % boundarynormal ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Scalar2D subroutine UpdateDevice_Scalar2D ( this ) implicit none class ( Scalar2D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundary_gpu , c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % avgboundary_gpu , c_loc ( this % avgboundary ), sizeof ( this % avgboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundarynormal_gpu , c_loc ( this % boundarynormal ), sizeof ( this % boundarynormal ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Scalar2D subroutine BoundaryInterp_Scalar2D ( this ) implicit none class ( Scalar2D ), intent ( inout ) :: this call BoundaryInterp_2D_gpu ( this % interp % bMatrix_gpu , this % interior_gpu , this % boundary_gpu , & this % interp % N , this % nvar , this % nelem ) endsubroutine BoundaryInterp_Scalar2D subroutine AverageSides_Scalar2D ( this ) implicit none class ( Scalar2D ), intent ( inout ) :: this call Average_gpu ( this % avgBoundary_gpu , this % boundary_gpu , this % extBoundary_gpu , size ( this % boundary )) endsubroutine AverageSides_Scalar2D subroutine GridInterp_Scalar2D ( this , f ) implicit none class ( Scalar2D ), intent ( inout ) :: this type ( c_ptr ), intent ( inout ) :: f call self_blas_matrixop_dim1_2d ( this % interp % iMatrix_gpu , this % interior_gpu , & this % interpWork , this % N , this % M , this % nvar , this % nelem , & this % blas_handle ) call self_blas_matrixop_dim2_2d ( this % interp % iMatrix_gpu , this % interpWork , f , & 0.0_c_prec , this % N , this % M , this % nvar , this % nelem , & this % blas_handle ) endsubroutine GridInterp_Scalar2D subroutine Gradient_Scalar2D ( this , df ) implicit none class ( Scalar2D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df !Local real ( prec ), pointer :: df_p (:,:,:,:,:) real ( prec ), pointer :: dfloc (:,:,:,:) type ( c_ptr ) :: dfc call c_f_pointer ( df , df_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 2 ]) dfloc ( 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim1_2d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) dfloc ( 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 2 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim2_2d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , 0.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) dfloc => null () df_p => null () endsubroutine Gradient_Scalar2D endmodule SELF_Scalar_2D","tags":"","loc":"sourcefile/self_scalar_2d.f90.html"},{"title":"SELF_GPUInterfaces.f90 – SELF","text":"Contents Modules SELF_GPUInterfaces Source Code SELF_GPUInterfaces.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_GPUInterfaces use iso_c_binding use SELF_GPU ! Data interface subroutine Average_gpu ( favg , f1 , f2 , ndof ) bind ( c , name = \"Average_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: favg , f1 , f2 integer ( c_int ), value :: ndof endsubroutine Average_gpu endinterface interface subroutine BoundaryInterp_2D_gpu ( bMatrix_dev , f_dev , bf_dev , N , nVar , nEl ) & bind ( c , name = \"BoundaryInterp_2D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: bMatrix_dev , f_dev , bf_dev integer ( c_int ), value :: N , nVar , nEl endsubroutine BoundaryInterp_2D_gpu endinterface interface subroutine BoundaryInterp_3D_gpu ( bMatrix_dev , f_dev , bf_dev , N , nVar , nEl ) & bind ( c , name = \"BoundaryInterp_3D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: bMatrix_dev , f_dev , bf_dev integer ( c_int ), value :: N , nVar , nEl endsubroutine BoundaryInterp_3D_gpu endinterface ! MappedData ! Model interface subroutine UpdateSolution_gpu ( solution , dsdt , dt , ndof ) bind ( c , name = \"UpdateSolution_gpu\" ) use iso_c_binding use SELF_Constants type ( c_ptr ), value :: solution , dsdt real ( c_prec ), value :: dt integer ( c_int ), value :: ndof endsubroutine UpdateSolution_gpu endinterface interface subroutine UpdateGRK_gpu ( grk , solution , dsdt , rk_a , rk_g , dt , ndof ) bind ( c , name = \"UpdateGRK_gpu\" ) use iso_c_binding use SELF_Constants type ( c_ptr ), value :: grk , solution , dsdt real ( c_prec ), value :: rk_a , rk_g , dt integer ( c_int ), value :: ndof endsubroutine UpdateGRK_gpu endinterface interface subroutine CalculateDSDt_gpu ( fluxDivergence , source , dsdt , ndof ) bind ( c , name = \"CalculateDSDt_gpu\" ) use iso_c_binding use SELF_Constants type ( c_ptr ), value :: fluxDivergence , source , dsdt integer ( c_int ), value :: ndof endsubroutine CalculateDSDt_gpu endinterface interface subroutine GradientNormal_1D_gpu ( fbn , fbavg , ndof ) bind ( c , name = \"GradientNormal_1d_gpu\" ) use iso_c_binding type ( c_ptr ), value :: fbn , fbavg integer ( c_int ), value :: ndof endsubroutine GradientNormal_1D_gpu endinterface interface subroutine SideExchange_2D_gpu ( extboundary , boundary , sideinfo , elemToRank , rankid , offset , n , nvar , nel ) & bind ( c , name = \"SideExchange_2D_gpu\" ) use iso_c_binding type ( c_ptr ), value :: extboundary , boundary , sideinfo , elemToRank integer ( c_int ), value :: rankId , offset , N , nVar , nEl endsubroutine SideExchange_2D_gpu endinterface interface subroutine ApplyFlip_2D_gpu ( extBoundary , sideInfo , elemToRank , rankId , offset , N , nVar , nEl ) & bind ( c , name = \"ApplyFlip_2D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: extBoundary , sideInfo , elemToRank integer ( c_int ), value :: rankId , offset , N , nVar , nEl endsubroutine ApplyFlip_2D_gpu endinterface interface subroutine DG_BoundaryContribution_2D_gpu ( bmatrix , qweights , bf , df , N , nvar , nel ) & bind ( c , name = \"DG_BoundaryContribution_2D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: bmatrix , qweights , bf , df integer ( c_int ), value :: N , nvar , nel endsubroutine DG_BoundaryContribution_2D_gpu endinterface interface subroutine JacobianWeight_2D_gpu ( scalar , J , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_2D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: scalar , J integer ( c_int ), value :: N , nVar , nEl endsubroutine JacobianWeight_2D_gpu endinterface interface subroutine SideExchange_3D_gpu ( extboundary , boundary , sideinfo , elemToRank , rankid , offset , n , nvar , nel ) & bind ( c , name = \"SideExchange_3D_gpu\" ) use iso_c_binding type ( c_ptr ), value :: extboundary , boundary , sideinfo , elemToRank integer ( c_int ), value :: rankId , offset , N , nVar , nEl endsubroutine SideExchange_3D_gpu endinterface interface subroutine ApplyFlip_3D_gpu ( extBoundary , sideInfo , elemToRank , rankId , offset , N , nVar , nEl ) & bind ( c , name = \"ApplyFlip_3D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: extBoundary , sideInfo , elemToRank integer ( c_int ), value :: rankId , offset , N , nVar , nEl endsubroutine ApplyFlip_3D_gpu endinterface interface subroutine DG_BoundaryContribution_3D_gpu ( bmatrix , qweights , bf , df , N , nvar , nel ) & bind ( c , name = \"DG_BoundaryContribution_3D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: bmatrix , qweights , bf , df integer ( c_int ), value :: N , nvar , nel endsubroutine DG_BoundaryContribution_3D_gpu endinterface interface subroutine JacobianWeight_3D_gpu ( scalar , J , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_3D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: scalar , J integer ( c_int ), value :: N , nVar , nEl endsubroutine JacobianWeight_3D_gpu endinterface endmodule SELF_GPUInterfaces","tags":"","loc":"sourcefile/self_gpuinterfaces.f90.html"},{"title":"SELF_Vector_2D.f90 – SELF","text":"Contents Modules SELF_Vector_2D Source Code SELF_Vector_2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Vector_2D use SELF_Constants use SELF_Vector_2D_t use SELF_GPU use SELF_GPUBLAS use SELF_GPUInterfaces use iso_c_binding implicit none type , extends ( Vector2D_t ), public :: Vector2D character ( 3 ) :: backend = \"gpu\" type ( c_ptr ) :: blas_handle type ( c_ptr ) :: interior_gpu type ( c_ptr ) :: boundary_gpu type ( c_ptr ) :: extBoundary_gpu type ( c_ptr ) :: avgBoundary_gpu type ( c_ptr ) :: boundaryNormal_gpu type ( c_ptr ) :: interpWork contains procedure , public :: Init => Init_Vector2D procedure , public :: Free => Free_Vector2D procedure , public :: UpdateHost => UpdateHost_Vector2D procedure , public :: UpdateDevice => UpdateDevice_Vector2D procedure , public :: BoundaryInterp => BoundaryInterp_Vector2D procedure , public :: AverageSides => AverageSides_Vector2D generic , public :: GridInterp => GridInterp_Vector2D procedure , private :: GridInterp_Vector2D generic , public :: Gradient => Gradient_Vector2D procedure , private :: Gradient_Vector2D generic , public :: Divergence => Divergence_Vector2D procedure , private :: Divergence_Vector2D endtype Vector2D contains subroutine Init_Vector2D ( this , interp , nVar , nElem ) implicit none class ( Vector2D ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i integer ( c_size_t ) :: workSize this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % boundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 ), & this % boundaryNormal ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 2 * nVar )) ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 2 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo this % interior = 0.0_prec this % boundary = 0.0_prec this % boundarynormal = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( this % avgBoundary_gpu , sizeof ( this % avgBoundary ))) call gpuCheck ( hipMalloc ( this % boundaryNormal_gpu , sizeof ( this % boundaryNormal ))) workSize = ( interp % N + 1 ) * ( interp % M + 1 ) * nelem * nvar * 2 * prec call gpuCheck ( hipMalloc ( this % interpWork , workSize )) call this % UpdateDevice () call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_Vector2D subroutine Free_Vector2D ( this ) implicit none class ( Vector2D ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % boundaryNormal ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call gpuCheck ( hipFree ( this % avgBoundary_gpu )) call gpuCheck ( hipFree ( this % boundaryNormal_gpu )) call gpuCheck ( hipFree ( this % interpWork )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Vector2D subroutine UpdateHost_Vector2D ( this ) implicit none class ( Vector2D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), this % interior_gpu , sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), this % extboundary_gpu , sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % avgboundary ), this % avgboundary_gpu , sizeof ( this % avgboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundaryNormal ), this % boundaryNormal_gpu , sizeof ( this % boundaryNormal ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Vector2D subroutine UpdateDevice_Vector2D ( this ) implicit none class ( Vector2D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundary_gpu , c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % avgboundary_gpu , c_loc ( this % avgboundary ), sizeof ( this % avgboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundaryNormal_gpu , c_loc ( this % boundaryNormal ), sizeof ( this % boundaryNormal ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Vector2D subroutine GridInterp_Vector2D ( this , f ) implicit none class ( Vector2D ), intent ( inout ) :: this type ( c_ptr ), intent ( inout ) :: f call self_blas_matrixop_dim1_2d ( this % interp % iMatrix_gpu , this % interior_gpu , & this % interpWork , this % N , this % M , 2 * this % nvar , this % nelem , & this % blas_handle ) call self_blas_matrixop_dim2_2d ( this % interp % iMatrix_gpu , this % interpWork , f , & 0.0_c_prec , this % N , this % M , 2 * this % nvar , this % nelem , & this % blas_handle ) endsubroutine GridInterp_Vector2D subroutine AverageSides_Vector2D ( this ) implicit none class ( Vector2D ), intent ( inout ) :: this call Average_gpu ( this % avgBoundary_gpu , this % boundary_gpu , this % extBoundary_gpu , size ( this % boundary )) endsubroutine AverageSides_Vector2D subroutine BoundaryInterp_Vector2D ( this ) implicit none class ( Vector2D ), intent ( inout ) :: this call BoundaryInterp_2D_gpu ( this % interp % bMatrix_gpu , this % interior_gpu , this % boundary_gpu , & this % interp % N , 2 * this % nvar , this % nelem ) endsubroutine BoundaryInterp_Vector2D subroutine Gradient_Vector2D ( this , df ) implicit none class ( Vector2D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df !Local real ( prec ), pointer :: df_p (:,:,:,:,:,:) real ( prec ), pointer :: dfloc (:,:,:,:) type ( c_ptr ) :: dfc call c_f_pointer ( df , df_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 2 , 2 ]) dfloc ( 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 , 1 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim1_2d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , & this % interp % N , this % interp % N , 2 * this % nvar , this % nelem , this % blas_handle ) dfloc ( 1 :, 1 :, 1 :, 1 :) => df_p ( 1 :, 1 :, 1 :, 1 :, 1 , 2 ) dfc = c_loc ( dfloc ) call self_blas_matrixop_dim2_2d ( this % interp % dMatrix_gpu , this % interior_gpu , dfc , 0.0_c_prec , & this % interp % N , this % interp % N , 2 * this % nvar , this % nelem , this % blas_handle ) dfloc => null () df_p => null () endsubroutine Gradient_Vector2D subroutine Divergence_Vector2D ( this , df ) implicit none class ( Vector2D ), intent ( in ) :: this type ( c_ptr ), intent ( inout ) :: df !Local real ( prec ), pointer :: f_p (:,:,:,:,:) type ( c_ptr ) :: fc call c_f_pointer ( this % interior_gpu , f_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 2 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_2d ( this % interp % dMatrix_gpu , fc , df , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_2d ( this % interp % dMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) f_p => null () endsubroutine Divergence_Vector2D endmodule SELF_Vector_2D","tags":"","loc":"sourcefile/self_vector_2d.f90.html"},{"title":"SELF_MappedScalar_2D.f90 – SELF","text":"Contents Modules SELF_MappedScalar_2D Source Code SELF_MappedScalar_2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_MappedScalar_2D use SELF_MappedScalar_2D_t use SELF_GPU use SELF_GPUInterfaces use iso_c_binding implicit none type , extends ( MappedScalar2D_t ), public :: MappedScalar2D type ( c_ptr ) :: jas_gpu ! jacobian weighted scalar for gradient calculation contains procedure , public :: Init => Init_MappedScalar2D procedure , public :: Free => Free_MappedScalar2D procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedScalar2D procedure , public :: SideExchange => SideExchange_MappedScalar2D procedure , private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D generic , public :: MappedGradient => MappedGradient_MappedScalar2D procedure , private :: MappedGradient_MappedScalar2D generic , public :: MappedDGGradient => MappedDGGradient_MappedScalar2D procedure , private :: MappedDGGradient_MappedScalar2D endtype MappedScalar2D interface subroutine ContravariantWeight_2D_gpu ( f , dsdx , jaf , N , nvar , nel ) & bind ( c , name = \"ContravariantWeight_2D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: f , dsdx , jaf integer ( c_int ), value :: N , nvar , nel endsubroutine ContravariantWeight_2D_gpu endinterface interface subroutine NormalWeight_2D_gpu ( fb , nhat , nscale , fbn , N , nvar , nel ) & bind ( c , name = \"NormalWeight_2D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: fb , nhat , nscale , fbn integer ( c_int ), value :: N , nvar , nel endsubroutine NormalWeight_2D_gpu endinterface contains subroutine Init_MappedScalar2D ( this , interp , nVar , nElem ) implicit none class ( MappedScalar2D ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! Local integer ( c_size_t ) :: workSize this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , interp % N + 1 , nelem , nvar ), & this % boundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar ), & this % boundarynormal ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : 2 * nvar )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec this % avgBoundary = 0.0_prec this % boundarynormal = 0.0_prec call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( this % avgBoundary_gpu , sizeof ( this % avgBoundary ))) call gpuCheck ( hipMalloc ( this % boundarynormal_gpu , sizeof ( this % boundarynormal ))) workSize = ( interp % N + 1 ) * ( interp % M + 1 ) * nelem * nvar * prec call gpuCheck ( hipMalloc ( this % interpWork , workSize )) workSize = ( interp % N + 1 ) * ( interp % N + 1 ) * nelem * nvar * 4 * prec call gpuCheck ( hipMalloc ( this % jas_gpu , workSize )) call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_MappedScalar2D subroutine Free_MappedScalar2D ( this ) implicit none class ( MappedScalar2D ), intent ( inout ) :: this this % nVar = 0 this % nElem = 0 this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % avgBoundary ) deallocate ( this % boundarynormal ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call gpuCheck ( hipFree ( this % avgBoundary_gpu )) call gpuCheck ( hipFree ( this % interpWork )) call gpuCheck ( hipFree ( this % jas_gpu )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_MappedScalar2D subroutine SetInteriorFromEquation_MappedScalar2D ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedScalar2D ), intent ( inout ) :: this type ( SEMQuad ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , iEl , iVar real ( prec ) :: x real ( prec ) :: y do iVar = 1 , this % nVar do iEl = 1 , this % nElem do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , iEl , 1 , 2 ) this % interior ( i , j , iEl , iVar ) = & this % eqn ( iVar )% Evaluate (( / x , y , 0.0_prec , time / )) enddo enddo enddo enddo call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) endsubroutine SetInteriorFromEquation_MappedScalar2D subroutine MPIExchangeAsync_MappedScalar2D ( this , mesh ) implicit none class ( MappedScalar2D ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount real ( prec ), pointer :: boundary (:,:,:,:) real ( prec ), pointer :: extboundary (:,:,:,:) msgCount = 0 call c_f_pointer ( this % boundary_gpu , boundary ,[ this % interp % N + 1 , 4 , this % nelem , this % nvar ]) call c_f_pointer ( this % extboundary_gpu , extboundary ,[ this % interp % N + 1 , 4 , this % nelem , this % nvar ]) do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 4 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) ! create unique tag for each side and each variable tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 ) msgCount = msgCount + 1 call MPI_IRECV ( extBoundary (:, s1 , e1 , ivar ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( boundary (:, s1 , e1 , ivar ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedScalar2D subroutine SideExchange_MappedScalar2D ( this , mesh ) implicit none class ( MappedScalar2D ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: offset offset = mesh % decomp % offsetElem ( mesh % decomp % rankId + 1 ) if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif ! Do the side exchange internal to this mpi process call SideExchange_2D_gpu ( this % extboundary_gpu , & this % boundary_gpu , mesh % sideinfo_gpu , mesh % decomp % elemToRank_gpu , & mesh % decomp % rankid , offset , this % interp % N , this % nvar , this % nelem ) if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call ApplyFlip_2D_gpu ( this % extboundary_gpu , mesh % sideInfo_gpu , & mesh % decomp % elemToRank_gpu , mesh % decomp % rankId , & offset , this % interp % N , this % nVar , this % nElem ) endif endsubroutine SideExchange_MappedScalar2D subroutine MappedGradient_MappedScalar2D ( this , df ) !! Calculates the gradient of a function using the strong form of the gradient !! in mapped coordinates. implicit none class ( MappedScalar2D ), intent ( inout ) :: this type ( c_ptr ), intent ( out ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:) type ( c_ptr ) :: fc call ContravariantWeight_2D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % jas_gpu , & this % interp % N , this % nvar , this % nelem ) ! From Vector divergence call c_f_pointer ( this % jas_gpu , f_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % nelem , 2 * this % nvar , 2 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_2d ( this % interp % dMatrix_gpu , fc , df , & this % interp % N , this % interp % N , 2 * this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_2d ( this % interp % dMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , 2 * this % nvar , this % nelem , this % blas_handle ) f_p => null () call JacobianWeight_2D_gpu ( df , this % geometry % J % interior_gpu , this % N , 2 * this % nVar , this % nelem ) endsubroutine MappedGradient_MappedScalar2D subroutine MappedDGGradient_MappedScalar2D ( this , df ) !! implicit none class ( MappedScalar2D ), intent ( inout ) :: this type ( c_ptr ), intent ( inout ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:) type ( c_ptr ) :: fc call ContravariantWeight_2D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % jas_gpu , & this % interp % N , this % nvar , this % nelem ) ! From Vector divergence call c_f_pointer ( this % jas_gpu , f_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % nelem , 2 * this % nvar , 2 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_2d ( this % interp % dgMatrix_gpu , fc , df , & this % interp % N , this % interp % N , 2 * this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_2d ( this % interp % dgMatrix_gpu , fc , df , & 1.0_c_prec , this % interp % N , this % interp % N , 2 * this % nvar , this % nelem , this % blas_handle ) f_p => null () ! Do the boundary terms call NormalWeight_2D_gpu ( this % avgBoundary_gpu , & this % geometry % nhat % boundary_gpu , this % geometry % nscale % boundary_gpu , & this % boundarynormal_gpu , & this % interp % N , this % nvar , this % nelem ) call DG_BoundaryContribution_2D_gpu ( this % interp % bmatrix_gpu , this % interp % qweights_gpu , & this % boundarynormal_gpu , df , this % interp % N , 2 * this % nvar , this % nelem ) call JacobianWeight_2D_gpu ( df , this % geometry % J % interior_gpu , this % N , 2 * this % nVar , this % nelem ) endsubroutine MappedDGGradient_MappedScalar2D endmodule SELF_MappedScalar_2D","tags":"","loc":"sourcefile/self_mappedscalar_2d.f90.html"},{"title":"SELF_DGModel3D.f90 – SELF","text":"Contents Modules SELF_DGModel3D Source Code SELF_DGModel3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_DGModel3D use SELF_DGModel3D_t use SELF_GPU use SELF_GPUInterfaces implicit none type , extends ( DGModel3D_t ) :: DGModel3D contains procedure :: UpdateSolution => UpdateSolution_DGModel3D procedure :: CalculateEntropy => CalculateEntropy_DGModel3D procedure :: BoundaryFlux => BoundaryFlux_DGModel3D procedure :: FluxMethod => fluxmethod_DGModel3D procedure :: SourceMethod => sourcemethod_DGModel3D procedure :: SetBoundaryCondition => setboundarycondition_DGModel3D procedure :: SetGradientBoundaryCondition => setgradientboundarycondition_DGModel3D procedure :: UpdateGRK2 => UpdateGRK2_DGModel3D procedure :: UpdateGRK3 => UpdateGRK3_DGModel3D procedure :: UpdateGRK4 => UpdateGRK4_DGModel3D procedure :: CalculateSolutionGradient => CalculateSolutionGradient_DGModel3D procedure :: CalculateTendency => CalculateTendency_DGModel3D endtype DGModel3D contains subroutine UpdateSolution_DGModel3D ( this , dt ) !! Computes a solution update as , where dt is either provided through the interface !! or taken as the Model's stored time step size (model % dt) implicit none class ( DGModel3D ), intent ( inout ) :: this real ( prec ), optional , intent ( in ) :: dt ! Local real ( prec ) :: dtLoc integer :: ndof if ( present ( dt )) then dtLoc = dt else dtLoc = this % dt endif ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateSolution_gpu ( this % solution % interior_gpu , this % dsdt % interior_gpu , dtLoc , ndof ) endsubroutine UpdateSolution_DGModel3D subroutine UpdateGRK2_DGModel3D ( this , m ) implicit none class ( DGModel3D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk2_a ( m ), rk2_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK2_DGModel3D subroutine UpdateGRK3_DGModel3D ( this , m ) implicit none class ( DGModel3D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk3_a ( m ), rk3_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK3_DGModel3D subroutine UpdateGRK4_DGModel3D ( this , m ) implicit none class ( DGModel3D ), intent ( inout ) :: this integer , intent ( in ) :: m ! Local integer :: ndof ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call UpdateGRK_gpu ( this % worksol % interior_gpu , this % solution % interior_gpu , this % dsdt % interior_gpu , & rk4_a ( m ), rk4_g ( m ), this % dt , ndof ) endsubroutine UpdateGRK4_DGModel3D subroutine CalculateSolutionGradient_DGModel3D ( this ) implicit none class ( DGModel3D ), intent ( inout ) :: this call this % solution % AverageSides () call this % solution % MappedDGGradient ( this % solutionGradient % interior_gpu ) ! interpolate the solutiongradient to the element boundaries call this % solutionGradient % BoundaryInterp () ! perform the side exchange to populate the ! solutionGradient % extBoundary attribute call this % solutionGradient % SideExchange ( this % mesh ) endsubroutine CalculateSolutionGradient_DGModel3D subroutine CalculateEntropy_DGModel3D ( this ) implicit none class ( DGModel3D ), intent ( inout ) :: this ! Local integer :: iel , i , j , k , ierror real ( prec ) :: e , jac real ( prec ) :: s ( 1 : this % nvar ) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) e = 0.0_prec do iel = 1 , this % geometry % nelem do k = 1 , this % solution % interp % N + 1 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 jac = this % geometry % J % interior ( i , j , k , iel , 1 ) s = this % solution % interior ( i , j , k , iel , 1 : this % nvar ) e = e + this % entropy_func ( s ) * jac enddo enddo enddo enddo if ( this % mesh % decomp % mpiEnabled ) then call mpi_allreduce ( e , & this % entropy , & 1 , & this % mesh % decomp % mpiPrec , & MPI_SUM , & this % mesh % decomp % mpiComm , & iError ) else this % entropy = e endif endsubroutine CalculateEntropy_DGModel3D subroutine fluxmethod_DGModel3D ( this ) implicit none class ( DGModel3D ), intent ( inout ) :: this ! Local integer :: iel integer :: i , j , k real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 3 ) do iel = 1 , this % mesh % nelem do k = 1 , this % solution % interp % N + 1 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , k , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) this % flux % interior ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) = this % flux3d ( s , dsdx ) enddo enddo enddo enddo call gpuCheck ( hipMemcpy ( this % flux % interior_gpu , & c_loc ( this % flux % interior ), & sizeof ( this % flux % interior ), & hipMemcpyHostToDevice )) endsubroutine fluxmethod_DGModel3D subroutine BoundaryFlux_DGModel3D ( this ) ! this method uses an linear upwind solver for the ! advective flux and the bassi-rebay method for the ! diffusive fluxes implicit none class ( DGModel3D ), intent ( inout ) :: this ! Local integer :: i , j , k , iel real ( prec ) :: sL ( 1 : this % nvar ), sR ( 1 : this % nvar ) real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ) :: nhat ( 1 : 3 ), nmag call gpuCheck ( hipMemcpy ( c_loc ( this % solution % boundary ), & this % solution % boundary_gpu , sizeof ( this % solution % boundary ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % extboundary ), & this % solution % extboundary_gpu , sizeof ( this % solution % extboundary ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % avgboundary ), & this % solutiongradient % avgboundary_gpu , sizeof ( this % solutiongradient % avgboundary ), & hipMemcpyDeviceToHost )) do iEl = 1 , this % solution % nElem do k = 1 , 6 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 ! Get the boundary normals on cell edges from the mesh geometry nhat = this % geometry % nHat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) sL = this % solution % boundary ( i , j , k , iel , 1 : this % nvar ) ! interior solution sR = this % solution % extboundary ( i , j , k , iel , 1 : this % nvar ) ! exterior solution dsdx = this % solutiongradient % avgboundary ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) nmag = this % geometry % nScale % boundary ( i , j , k , iEl , 1 ) this % flux % boundaryNormal ( i , j , k , iEl , 1 : this % nvar ) = this % riemannflux3d ( sL , sR , dsdx , nhat ) * nmag enddo enddo enddo enddo call gpuCheck ( hipMemcpy ( this % flux % boundarynormal_gpu , & c_loc ( this % flux % boundarynormal ), & sizeof ( this % flux % boundarynormal ), & hipMemcpyHostToDevice )) endsubroutine BoundaryFlux_DGModel3D subroutine sourcemethod_DGModel3D ( this ) implicit none class ( DGModel3D ), intent ( inout ) :: this ! Local integer :: i , j , k , iel real ( prec ) :: s ( 1 : this % nvar ), dsdx ( 1 : this % nvar , 1 : 3 ) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % interior ), & this % solution % interior_gpu , sizeof ( this % solution % interior ), & hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % interior ), & this % solutiongradient % interior_gpu , sizeof ( this % solutiongradient % interior ), & hipMemcpyDeviceToHost )) do iel = 1 , this % mesh % nelem do k = 1 , this % solution % interp % N + 1 do j = 1 , this % solution % interp % N + 1 do i = 1 , this % solution % interp % N + 1 s = this % solution % interior ( i , j , k , iel , 1 : this % nvar ) dsdx = this % solutionGradient % interior ( i , j , k , iel , 1 : this % nvar , 1 : 3 ) this % source % interior ( i , j , k , iel , 1 : this % nvar ) = this % source3d ( s , dsdx ) enddo enddo enddo enddo call gpuCheck ( hipMemcpy ( this % source % interior_gpu , & c_loc ( this % source % interior ), & sizeof ( this % source % interior ), & hipMemcpyHostToDevice )) endsubroutine sourcemethod_DGModel3D subroutine setboundarycondition_DGModel3D ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel3D ), intent ( inout ) :: this ! local integer :: i , iEl , j , k , e2 , bcid real ( prec ) :: nhat ( 1 : 3 ), x ( 1 : 3 ) call gpuCheck ( hipMemcpy ( c_loc ( this % solution % boundary ), & this % solution % boundary_gpu , sizeof ( this % solution % boundary ), & hipMemcpyDeviceToHost )) do iEl = 1 , this % solution % nElem ! Loop over all elements do k = 1 , 6 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , k , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , k , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do j = 1 , this % solution % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points x = this % geometry % x % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solution % extBoundary ( i , j , k , iEl , 1 : this % nvar ) = & this % hbc3d_Prescribed ( x , this % t ) enddo enddo elseif ( bcid == SELF_BC_RADIATION ) then do j = 1 , this % solution % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solution % extBoundary ( i , j , k , iEl , 1 : this % nvar ) = & this % hbc3d_Radiation ( this % solution % boundary ( i , j , k , iEl , 1 : this % nvar ), nhat ) enddo enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do j = 1 , this % solution % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solution % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solution % extBoundary ( i , j , k , iEl , 1 : this % nvar ) = & this % hbc3d_NoNormalFlow ( this % solution % boundary ( i , j , k , iEl , 1 : this % nvar ), nhat ) enddo enddo endif endif enddo enddo call gpuCheck ( hipMemcpy ( this % solution % extBoundary_gpu , & c_loc ( this % solution % extBoundary ), & sizeof ( this % solution % extBoundary ), & hipMemcpyHostToDevice )) endsubroutine setboundarycondition_DGModel3D subroutine setgradientboundarycondition_DGModel3D ( this ) !! Boundary conditions for the solution are set to !! 0 for the external state to provide radiation type !! boundary conditions. implicit none class ( DGModel3D ), intent ( inout ) :: this ! local integer :: i , iEl , j , k , e2 , bcid real ( prec ) :: dsdx ( 1 : this % nvar , 1 : 3 ) real ( prec ) :: nhat ( 1 : 3 ), x ( 1 : 3 ) call gpuCheck ( hipMemcpy ( c_loc ( this % solutiongradient % boundary ), & this % solutiongradient % boundary_gpu , sizeof ( this % solutiongradient % boundary ), & hipMemcpyDeviceToHost )) do iEl = 1 , this % solution % nElem ! Loop over all elements do k = 1 , 6 ! Loop over all sides bcid = this % mesh % sideInfo ( 5 , k , iEl ) ! Boundary Condition ID e2 = this % mesh % sideInfo ( 3 , k , iEl ) ! Neighboring Element ID if ( e2 == 0 ) then if ( bcid == SELF_BC_PRESCRIBED ) then do j = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points x = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) this % solutiongradient % extBoundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) = & this % pbc3d_Prescribed ( x , this % t ) enddo enddo elseif ( bcid == SELF_BC_RADIATION ) then do j = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) dsdx = this % solutiongradient % boundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) this % solutiongradient % extBoundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) = & this % pbc3d_Radiation ( dsdx , nhat ) enddo enddo elseif ( bcid == SELF_BC_NONORMALFLOW ) then do j = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points do i = 1 , this % solutiongradient % interp % N + 1 ! Loop over quadrature points nhat = this % geometry % nhat % boundary ( i , j , k , iEl , 1 , 1 : 3 ) dsdx = this % solutiongradient % boundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) this % solutiongradient % extBoundary ( i , j , k , iEl , 1 : this % nvar , 1 : 3 ) = & this % pbc3d_NoNormalFlow ( dsdx , nhat ) enddo enddo endif endif enddo enddo call gpuCheck ( hipMemcpy ( this % solutiongradient % extBoundary_gpu , & c_loc ( this % solutiongradient % extBoundary ), & sizeof ( this % solutiongradient % extBoundary ), & hipMemcpyHostToDevice )) endsubroutine setgradientboundarycondition_DGModel3D subroutine CalculateTendency_DGModel3D ( this ) implicit none class ( DGModel3D ), intent ( inout ) :: this ! Local integer :: ndof call this % solution % BoundaryInterp () call this % solution % SideExchange ( this % mesh ) call this % PreTendency () ! User-supplied call this % SetBoundaryCondition () ! User-supplied if ( this % gradient_enabled ) then call this % solution % AverageSides () call this % CalculateSolutionGradient () call this % SetGradientBoundaryCondition () ! User-supplied call this % solutionGradient % AverageSides () endif call this % SourceMethod () ! User supplied call this % BoundaryFlux () ! User supplied call this % FluxMethod () ! User supplied call this % flux % MappedDGDivergence ( this % fluxDivergence % interior_gpu ) ndof = this % solution % nvar * & this % solution % nelem * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) * & ( this % solution % interp % N + 1 ) call CalculateDSDt_gpu ( this % fluxDivergence % interior_gpu , this % source % interior_gpu , & this % dsdt % interior_gpu , ndof ) endsubroutine CalculateTendency_DGModel3D endmodule SELF_DGModel3D","tags":"","loc":"sourcefile/self_dgmodel3d.f90.html"},{"title":"SELF_MappedVector_2D.f90 – SELF","text":"Contents Modules SELF_MappedVector_2D Source Code SELF_MappedVector_2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_MappedVector_2D use SELF_MappedVector_2D_t use SELF_GPU use SELF_GPUInterfaces use SELF_GPUBLAS use iso_c_binding implicit none type , extends ( MappedVector2D_t ), public :: MappedVector2D contains procedure , public :: SetInteriorFromEquation => SetInteriorFromEquation_MappedVector2D procedure , public :: SideExchange => SideExchange_MappedVector2D procedure , private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D generic , public :: MappedDivergence => MappedDivergence_MappedVector2D procedure , private :: MappedDivergence_MappedVector2D generic , public :: MappedDGDivergence => MappedDGDivergence_MappedVector2D procedure , private :: MappedDGDivergence_MappedVector2D endtype MappedVector2D interface subroutine ContravariantProjection_2D_gpu ( f , dsdx , N , nvar , nel ) & bind ( c , name = \"ContravariantProjection_2D_gpu\" ) use iso_c_binding implicit none type ( c_ptr ), value :: f , dsdx integer ( c_int ), value :: N , nvar , nel endsubroutine ContravariantProjection_2D_gpu endinterface contains subroutine SetInteriorFromEquation_MappedVector2D ( this , geometry , time ) !!  Sets the this % interior attribute using the eqn attribute, !!  geometry (for physical positions), and provided simulation time. implicit none class ( MappedVector2D ), intent ( inout ) :: this type ( SEMQuad ), intent ( in ) :: geometry real ( prec ), intent ( in ) :: time ! Local integer :: i , j , iEl , iVar real ( prec ) :: x real ( prec ) :: y do iVar = 1 , this % nVar do iEl = 1 , this % nElem do j = 1 , this % interp % N + 1 do i = 1 , this % interp % N + 1 ! Get the mesh positions x = geometry % x % interior ( i , j , iEl , 1 , 1 ) y = geometry % x % interior ( i , j , iEl , 1 , 2 ) this % interior ( i , j , iEl , iVar , 1 ) = & this % eqn ( 1 + 2 * ( iVar - 1 ))% Evaluate (( / x , y , 0.0_prec , time / )) this % interior ( i , j , iEl , iVar , 2 ) = & this % eqn ( 2 + 2 * ( iVar - 1 ))% Evaluate (( / x , y , 0.0_prec , time / )) enddo enddo enddo enddo call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) endsubroutine SetInteriorFromEquation_MappedVector2D subroutine MPIExchangeAsync_MappedVector2D ( this , mesh ) implicit none class ( MappedVector2D ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: e1 , s1 , e2 , s2 , ivar , idir integer :: globalSideId , r2 , tag integer :: iError integer :: msgCount real ( prec ), pointer :: boundary (:,:,:,:,:) real ( prec ), pointer :: extboundary (:,:,:,:,:) msgCount = 0 call c_f_pointer ( this % boundary_gpu , boundary ,[ this % interp % N + 1 , 4 , this % nelem , this % nvar , 2 ]) call c_f_pointer ( this % extboundary_gpu , extboundary ,[ this % interp % N + 1 , 4 , this % nelem , this % nvar , 2 ]) do idir = 1 , 2 do ivar = 1 , this % nvar do e1 = 1 , this % nElem do s1 = 1 , 4 e2 = mesh % sideInfo ( 3 , s1 , e1 ) ! Neighbor Element if ( e2 > 0 ) then r2 = mesh % decomp % elemToRank ( e2 ) ! Neighbor Rank if ( r2 /= mesh % decomp % rankId ) then s2 = mesh % sideInfo ( 4 , s1 , e1 ) / 10 globalSideId = abs ( mesh % sideInfo ( 2 , s1 , e1 )) ! create unique tag for each side and each variable tag = globalsideid + mesh % nUniqueSides * ( ivar - 1 + this % nvar * ( idir - 1 )) msgCount = msgCount + 1 call MPI_IRECV ( extBoundary (:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) msgCount = msgCount + 1 call MPI_ISEND ( boundary (:, s1 , e1 , ivar , idir ), & ( this % interp % N + 1 ), & mesh % decomp % mpiPrec , & r2 , tag , & mesh % decomp % mpiComm , & mesh % decomp % requests ( msgCount ), iError ) endif endif enddo enddo enddo enddo mesh % decomp % msgCount = msgCount endsubroutine MPIExchangeAsync_MappedVector2D subroutine SideExchange_MappedVector2D ( this , mesh ) implicit none class ( MappedVector2D ), intent ( inout ) :: this type ( Mesh2D ), intent ( inout ) :: mesh ! Local integer :: e1 , e2 , s1 , s2 , e2Global integer :: flip , bcid integer :: i1 , i2 , ivar , idir integer :: neighborRank integer :: offset offset = mesh % decomp % offsetElem ( mesh % decomp % rankid + 1 ) if ( mesh % decomp % mpiEnabled ) then call this % MPIExchangeAsync ( mesh ) endif ! Do the side exchange internal to this mpi process call SideExchange_2D_gpu ( this % extboundary_gpu , & this % boundary_gpu , mesh % sideinfo_gpu , mesh % decomp % elemToRank_gpu , & mesh % decomp % rankid , offset , this % interp % N , 2 * this % nvar , this % nelem ) if ( mesh % decomp % mpiEnabled ) then call mesh % decomp % FinalizeMPIExchangeAsync () ! Apply side flips for data exchanged with MPI call ApplyFlip_2D_gpu ( this % extboundary_gpu , mesh % sideInfo_gpu , & mesh % decomp % elemToRank_gpu , mesh % decomp % rankId , & offset , this % interp % N , 2 * this % nVar , this % nElem ) endif endsubroutine SideExchange_MappedVector2D subroutine MappedDivergence_MappedVector2D ( this , df ) implicit none class ( MappedVector2D ), intent ( inout ) :: this type ( c_ptr ), intent ( out ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:) type ( c_ptr ) :: fc ! Contravariant projection call ContravariantProjection_2D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % interp % N , this % nvar , this % nelem ) call c_f_pointer ( this % interior_gpu , f_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 2 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_2d ( this % interp % dMatrix_gpu , fc , df , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_2d ( this % interp % dMatrix_gpu , fc , df , 1.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) f_p => null () call JacobianWeight_2D_gpu ( df , this % geometry % J % interior_gpu , this % interp % N , this % nVar , this % nelem ) endsubroutine MappedDivergence_MappedVector2D subroutine MappedDGDivergence_MappedVector2D ( this , df ) implicit none class ( MappedVector2D ), intent ( inout ) :: this type ( c_ptr ), intent ( out ) :: df ! Local real ( prec ), pointer :: f_p (:,:,:,:,:) type ( c_ptr ) :: fc ! Contravariant projection call ContravariantProjection_2D_gpu ( this % interior_gpu , & this % geometry % dsdx % interior_gpu , this % interp % N , this % nvar , this % nelem ) call c_f_pointer ( this % interior_gpu , f_p ,[ this % interp % N + 1 , this % interp % N + 1 , this % nelem , this % nvar , 2 ]) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 1 )) call self_blas_matrixop_dim1_2d ( this % interp % dgMatrix_gpu , fc , df , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) fc = c_loc ( f_p ( 1 , 1 , 1 , 1 , 2 )) call self_blas_matrixop_dim2_2d ( this % interp % dgMatrix_gpu , fc , df , 1.0_c_prec , & this % interp % N , this % interp % N , this % nvar , this % nelem , this % blas_handle ) f_p => null () ! Boundary terms call DG_BoundaryContribution_2D_gpu ( this % interp % bmatrix_gpu , this % interp % qweights_gpu , & this % boundarynormal_gpu , df , this % interp % N , this % nvar , this % nelem ) call JacobianWeight_2D_gpu ( df , this % geometry % J % interior_gpu , this % interp % N , this % nVar , this % nelem ) endsubroutine MappedDGDivergence_MappedVector2D endmodule SELF_MappedVector_2D","tags":"","loc":"sourcefile/self_mappedvector_2d.f90.html"},{"title":"SELF_GPUBLAS.f90 – SELF","text":"Contents Modules SELF_GPUBLAS Source Code SELF_GPUBLAS.f90 Source Code module SELF_GPUBLAS use SELF_GPU_enums use SELF_Constants use iso_c_binding use iso_fortran_env implicit none interface hipblasCreate #ifdef HAVE_CUDA function hipblasCreate_ ( handle ) bind ( c , name = \"cublasCreate_v2\" ) #else function hipblasCreate_ ( handle ) bind ( c , name = \"hipblasCreate\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasCreate_ type ( c_ptr ) :: handle endfunction endinterface interface hipblasDestroy #ifdef HAVE_CUDA function hipblasDestroy_ ( handle ) bind ( c , name = \"cublasDestroy_v2\" ) #else function hipblasDestroy_ ( handle ) bind ( c , name = \"hipblasDestroy\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasDestroy_ type ( c_ptr ), value :: handle endfunction endinterface interface hipblasSgemm #ifdef HAVE_CUDA function hipblasSgemm_ ( handle , transa , transb , m , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) bind ( c , name = \"cublasSgemm_v2\" ) #else function hipblasSgemm_ ( handle , transa , transb , m , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) bind ( c , name = \"hipblasSgemm\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasSgemm_ type ( c_ptr ), value :: handle integer ( kind ( HIPBLAS_OP_N )), value :: transa integer ( kind ( HIPBLAS_OP_N )), value :: transb integer ( c_int ), value :: m integer ( c_int ), value :: n integer ( c_int ), value :: k real ( c_float ) :: alpha type ( c_ptr ), value :: A integer ( c_int ), value :: lda type ( c_ptr ), value :: B integer ( c_int ), value :: ldb real ( c_float ) :: beta type ( c_ptr ), value :: C integer ( c_int ), value :: ldc endfunction endinterface interface hipblasDgemm #ifdef HAVE_CUDA function hipblasDgemm_ ( handle , transa , transb , m , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) bind ( c , name = \"cublasDgemm_v2\" ) #else function hipblasDgemm_ ( handle , transa , transb , m , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) bind ( c , name = \"hipblasDgemm\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasDgemm_ type ( c_ptr ), value :: handle integer ( kind ( HIPBLAS_OP_N )), value :: transa integer ( kind ( HIPBLAS_OP_N )), value :: transb integer ( c_int ), value :: m integer ( c_int ), value :: n integer ( c_int ), value :: k real ( c_double ) :: alpha type ( c_ptr ), value :: A integer ( c_int ), value :: lda type ( c_ptr ), value :: B integer ( c_int ), value :: ldb real ( c_double ) :: beta type ( c_ptr ), value :: C integer ( c_int ), value :: ldc endfunction endinterface interface hipblasSgemvStridedBatched #ifdef HAVE_CUDA function hipblasSgemvStridedBatched_ ( handle , trans , m , n , alpha , A , lda , strideA , x , & incx , stridex , beta , y , incy , stridey , batchCount ) & bind ( c , name = \"cublasSgemvStridedBatched\" ) #else function hipblasSgemvStridedBatched_ ( handle , trans , m , n , alpha , A , lda , strideA , x , & incx , stridex , beta , y , incy , stridey , batchCount ) & bind ( c , name = \"hipblasSgemvStridedBatched\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasSgemvStridedBatched_ type ( c_ptr ), value :: handle integer ( kind ( HIPBLAS_OP_N )), value :: trans integer ( c_int ), value :: m integer ( c_int ), value :: n real ( c_float ) :: alpha type ( c_ptr ), value :: A integer ( c_int ), value :: lda integer ( c_int64_t ), value :: strideA type ( c_ptr ), value :: x integer ( c_int ), value :: incx integer ( c_int64_t ), value :: stridex real ( c_float ) :: beta type ( c_ptr ), value :: y integer ( c_int ), value :: incy integer ( c_int64_t ), value :: stridey integer ( c_int ), value :: batchCount endfunction endinterface interface hipblasDgemvStridedBatched #ifdef HAVE_CUDA function hipblasDgemvStridedBatched_ ( handle , trans , m , n , alpha , A , lda , strideA , x , & incx , stridex , beta , y , incy , stridey , batchCount ) & bind ( c , name = \"cublasDgemvStridedBatched\" ) #else function hipblasDgemvStridedBatched_ ( handle , trans , m , n , alpha , A , lda , strideA , x , & incx , stridex , beta , y , incy , stridey , batchCount ) & bind ( c , name = \"hipblasDgemvStridedBatched\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasDgemvStridedBatched_ type ( c_ptr ), value :: handle integer ( kind ( HIPBLAS_OP_N )), value :: trans integer ( c_int ), value :: m integer ( c_int ), value :: n real ( c_double ) :: alpha type ( c_ptr ), value :: A integer ( c_int ), value :: lda integer ( c_int64_t ), value :: strideA type ( c_ptr ), value :: x integer ( c_int ), value :: incx integer ( c_int64_t ), value :: stridex real ( c_double ) :: beta type ( c_ptr ), value :: y integer ( c_int ), value :: incy integer ( c_int64_t ), value :: stridey integer ( c_int ), value :: batchCount endfunction endinterface contains #ifdef DOUBLE_PRECISION #define hipblasgemm hipblasDgemm #define hipblasgemvStridedBatched hipblasDgemvStridedBatched #else #define hipblasgemm hipblasSgemm #define hipblasgemvStridedBatched hipblasSgemvStridedBatched #endif subroutine hipblasCheck ( hipblasError_t ) use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasError_t if ( hipblasError_t /= HIPBLAS_STATUS_SUCCESS ) then write ( * , * ) \"GPUBLAS ERROR: Error code = \" , hipblasError_t call exit ( hipblasError_t ) endif endsubroutine hipblasCheck subroutine self_blas_matrixop_1d ( A , f , Af , opArows , opAcols , bcols , handle ) type ( c_ptr ), intent ( in ) :: A type ( c_ptr ), intent ( in ) :: f type ( c_ptr ), intent ( inout ) :: Af integer , intent ( in ) :: opArows , opAcols , bcols type ( c_ptr ), intent ( in ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n integer ( c_int ) :: k real ( c_prec ) :: alpha integer ( c_int ) :: lda integer ( c_int ) :: ldb integer ( c_int ) :: ldc real ( c_prec ) :: beta m = opArows ! number of rows of A&#94;T n = bcols ! number of columns of B k = opAcols ! number of columns of A&#94;T alpha = 1.0_c_prec lda = k ! leading dimension of A (matrix) ldb = k ! leading dimension of B (f) ldc = m ! leading dimension of C (Af) beta = 0.0_c_prec call hipblasCheck ( hipblasgemm ( handle , & HIPBLAS_OP_T , HIPBLAS_OP_N , & m , n , k , alpha , & A , lda , & f , ldb , & beta , & Af , ldc )) endsubroutine self_blas_matrixop_1d subroutine self_blas_matrixop_dim1_2d ( A , f , Af , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A type ( c_ptr ), intent ( in ) :: f type ( c_ptr ), intent ( inout ) :: Af integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( in ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n integer ( c_int ) :: k real ( c_prec ) :: alpha integer ( c_int ) :: lda integer ( c_int ) :: ldb integer ( c_int ) :: ldc real ( c_prec ) :: beta m = targetdegree + 1 ! number of rows of A&#94;T n = nvars * nelems * ( controldegree + 1 ) ! number of columns of B k = controldegree + 1 ! number of columns of A&#94;T alpha = 1.0_c_prec lda = k ! leading dimension of A (interpolation/derivative matrix) ldb = k ! leading dimension of B (f) ldc = m ! leading dimension of C (fTarget) beta = 0.0_c_prec ! First pass interpolates in the first quadrature dimension call hipblasCheck ( hipblasgemm ( handle , & HIPBLAS_OP_T , HIPBLAS_OP_N , & m , n , k , alpha , & A , lda , & f , ldb , beta , & Af , ldc )) endsubroutine self_blas_matrixop_dim1_2d subroutine self_blas_matrixop_dim2_2d ( A , f , Af , beta , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A type ( c_ptr ), intent ( in ) :: f type ( c_ptr ), intent ( inout ) :: Af real ( c_prec ), intent ( in ) :: beta integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( in ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n real ( c_prec ) :: alpha integer ( c_int ) :: lda integer :: i integer ( c_int64_t ) :: strideA integer ( c_int ) :: incx integer ( c_int64_t ) :: stridex integer ( c_int ) :: incy integer ( c_int64_t ) :: stridey integer ( c_int ) :: batchCount real ( prec ), pointer :: f_p (:,:,:,:) real ( prec ), pointer :: Af_p (:,:,:,:) m = controldegree + 1 ! number of rows of A n = targetdegree + 1 ! number of columns of A alpha = 1.0_c_prec lda = m ! leading dimension of A strideA = 0 ! stride for the batches of A (no stride) incx = targetdegree + 1 ! stridex = ( controldegree + 1 ) * ( targetdegree + 1 ) incy = targetdegree + 1 stridey = ( targetdegree + 1 ) * ( targetdegree + 1 ) batchCount = nvars * nelems call c_f_pointer ( f , f_p ,[ targetdegree + 1 , controldegree + 1 , nelems , nvars ]) call c_f_pointer ( Af , Af_p ,[ targetdegree + 1 , targetdegree + 1 , nelems , nvars ]) do i = 0 , targetdegree call hipblasCheck ( hipblasgemvStridedBatched ( handle , & HIPBLAS_OP_T , & m , n , alpha , & A , lda , strideA , & c_loc ( f_p ( 1 + i , 1 , 1 , 1 )), incx , stridex , beta , & c_loc ( Af_p ( 1 + i , 1 , 1 , 1 )), incy , stridey , batchCount )) enddo endsubroutine self_blas_matrixop_dim2_2d subroutine self_blas_matrixop_dim1_3d ( A , f , Af , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A type ( c_ptr ), intent ( in ) :: f type ( c_ptr ), intent ( inout ) :: Af integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( in ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n integer ( c_int ) :: k real ( c_prec ) :: alpha integer ( c_int ) :: lda integer ( c_int ) :: ldb integer ( c_int ) :: ldc real ( c_prec ) :: beta m = targetdegree + 1 ! number of rows of A&#94;T n = nvars * nelems * ( controldegree + 1 ) * ( controldegree + 1 ) ! nreal(prec),pointerumber of columns of B k = controldegree + 1 ! number of columns of A&#94;T alpha = 1.0_c_prec lda = k ! leading dimension of A (interoplation matrix) ldb = k ! leading dimension of B (f) ldc = m ! leading dimension of C (fTarget) beta = 0.0_c_prec ! First pass interpolates in the first quadrature dimension call hipblasCheck ( hipblasgemm ( handle , & HIPBLAS_OP_T , HIPBLAS_OP_N , & m , n , k , alpha , & A , lda , & f , ldb , beta , & Af , ldc )) endsubroutine self_blas_matrixop_dim1_3d subroutine self_blas_matrixop_dim2_3d ( A , f , Af , beta , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A type ( c_ptr ), intent ( in ) :: f type ( c_ptr ), intent ( inout ) :: Af real ( c_prec ), intent ( in ) :: beta integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( in ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n real ( c_prec ) :: alpha integer ( c_int ) :: lda integer :: i integer ( c_int64_t ) :: strideA integer ( c_int ) :: incx integer ( c_int64_t ) :: stridex integer ( c_int ) :: incy integer ( c_int64_t ) :: stridey integer ( c_int ) :: batchCount real ( prec ), pointer :: f_p (:,:,:,:,:) real ( prec ), pointer :: Af_p (:,:,:,:,:) m = controldegree + 1 ! number of rows of A n = targetdegree + 1 ! number of columns of A alpha = 1.0_c_prec lda = m ! leading dimension of A strideA = 0 ! stride for the batches of A (no stride) incx = targetdegree + 1 ! stridex = ( controldegree + 1 ) * ( targetdegree + 1 ) !beta = 0.0_c_prec incy = targetdegree + 1 stridey = ( targetdegree + 1 ) * ( targetdegree + 1 ) batchCount = ( controldegree + 1 ) * nvars * nelems call c_f_pointer ( f , f_p ,[ targetdegree + 1 , controldegree + 1 , controldegree + 1 , nelems , nvars ]) call c_f_pointer ( Af , Af_p ,[ targetdegree + 1 , targetdegree + 1 , controldegree + 1 , nelems , nvars ]) do i = 0 , targetdegree call hipblasCheck ( hipblasgemvStridedBatched ( handle , & HIPBLAS_OP_T , & m , n , alpha , & A , lda , strideA , & c_loc ( f_p ( 1 + i , 1 , 1 , 1 , 1 )), incx , stridex , beta , & c_loc ( Af_p ( 1 + i , 1 , 1 , 1 , 1 )), incy , stridey , batchCount )) enddo endsubroutine self_blas_matrixop_dim2_3d subroutine self_blas_matrixop_dim3_3d ( A , f , Af , beta , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A type ( c_ptr ), intent ( in ) :: f type ( c_ptr ), intent ( inout ) :: Af real ( c_prec ), intent ( in ) :: beta integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( in ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n real ( c_prec ) :: alpha integer ( c_int ) :: lda integer :: i , j integer ( c_int64_t ) :: strideA integer ( c_int ) :: incx integer ( c_int64_t ) :: stridex integer ( c_int ) :: incy integer ( c_int64_t ) :: stridey integer ( c_int ) :: batchCount real ( prec ), pointer :: f_p (:,:,:,:,:) real ( prec ), pointer :: Af_p (:,:,:,:,:) m = controldegree + 1 ! number of rows of A n = targetdegree + 1 ! number of columns of A alpha = 1.0_c_prec lda = m ! leading dimension of A strideA = 0 ! stride for the batches of A (no stride) incx = ( targetdegree + 1 ) * ( targetdegree + 1 ) ! stridex = ( controldegree + 1 ) * ( targetdegree + 1 ) * ( targetdegree + 1 ) incy = ( targetdegree + 1 ) * ( targetdegree + 1 ) stridey = ( targetdegree + 1 ) * ( targetdegree + 1 ) * ( targetdegree + 1 ) batchCount = nvars * nelems call c_f_pointer ( f , f_p ,[ targetdegree + 1 , targetdegree + 1 , controldegree + 1 , nelems , nvars ]) call c_f_pointer ( Af , Af_p ,[ targetdegree + 1 , targetdegree + 1 , targetdegree + 1 , nelems , nvars ]) do j = 0 , targetdegree do i = 0 , targetdegree call hipblasCheck ( hipblasgemvStridedBatched ( handle , & HIPBLAS_OP_T , & m , n , alpha , & A , lda , strideA , & c_loc ( f_p ( 1 + i , 1 + j , 1 , 1 , 1 )), incx , stridex , beta , & c_loc ( Af_p ( 1 + i , 1 + j , 1 , 1 , 1 )), incy , stridey , batchCount )) enddo enddo endsubroutine self_blas_matrixop_dim3_3d endmodule SELF_GPUBLAS","tags":"","loc":"sourcefile/self_gpublas.f90.html"},{"title":"SELF_Tensor_2D.f90 – SELF","text":"Contents Modules SELF_Tensor_2D Source Code SELF_Tensor_2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Tensor_2D use SELF_Constants use SELF_Tensor_2D_t use SELF_GPU use SELF_GPUBLAS use iso_c_binding use iso_fortran_env implicit none type , extends ( Tensor2D_t ), public :: Tensor2D character ( 3 ) :: backend = \"gpu\" type ( c_ptr ) :: blas_handle type ( c_ptr ) :: interior_gpu type ( c_ptr ) :: boundary_gpu type ( c_ptr ) :: extBoundary_gpu contains procedure , public :: Init => Init_Tensor2D procedure , public :: Free => Free_Tensor2D procedure , public :: UpdateHost => UpdateHost_Tensor2D procedure , public :: UpdateDevice => UpdateDevice_Tensor2D endtype Tensor2D contains subroutine Init_Tensor2D ( this , interp , nVar , nElem ) implicit none class ( Tensor2D ), intent ( out ) :: this type ( Lagrange ), target , intent ( in ) :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem ! local integer :: i this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : interp % N + 1 , 1 : nelem , 1 : nvar , 1 : 2 , 1 : 2 ), & this % boundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 , 1 : 2 ), & this % extBoundary ( 1 : interp % N + 1 , 1 : 4 , 1 : nelem , 1 : nvar , 1 : 2 , 1 : 2 )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : 4 * nVar )) this % interior = 0.0_prec this % boundary = 0.0_prec this % extBoundary = 0.0_prec ! Initialize equation parser ! This is done to prevent segmentation faults that arise ! when building with amdflang that are traced back to ! feqparse_functions.f90 : finalize routine ! When the equation parser is not initialized, the ! functions are not allocated, which I think are the ! source of the segfault - joe@fluidnumerics.com do i = 1 , 4 * nvar this % eqn ( i ) = EquationParser ( 'f=0' ,( / 'x' , 'y' , 'z' , 't' / )) enddo call gpuCheck ( hipMalloc ( this % interior_gpu , sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( this % boundary_gpu , sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( this % extBoundary_gpu , sizeof ( this % extBoundary ))) call hipblasCheck ( hipblasCreate ( this % blas_handle )) call this % UpdateDevice () endsubroutine Init_Tensor2D subroutine Free_Tensor2D ( this ) implicit none class ( Tensor2D ), intent ( inout ) :: this this % interp => null () this % nVar = 0 this % nElem = 0 deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( this % interior_gpu )) call gpuCheck ( hipFree ( this % boundary_gpu )) call gpuCheck ( hipFree ( this % extBoundary_gpu )) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Tensor2D subroutine UpdateHost_Tensor2D ( this ) implicit none class ( Tensor2D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), this % interior_gpu , sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), this % boundary_gpu , sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), this % extboundary_gpu , sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Tensor2D subroutine UpdateDevice_Tensor2D ( this ) implicit none class ( Tensor2D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( this % interior_gpu , c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % boundary_gpu , c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( this % extboundary_gpu , c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Tensor2D endmodule SELF_Tensor_2D","tags":"","loc":"sourcefile/self_tensor_2d.f90.html"},{"title":"SELF_Lagrange.f90 – SELF","text":"Contents Modules SELF_Lagrange Source Code SELF_Lagrange.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Lagrange use iso_fortran_env use iso_c_binding use SELF_Constants use SELF_Lagrange_t use SELF_GPU implicit none type , extends ( Lagrange_t ), public :: Lagrange character ( 3 ) :: backend = 'gpu' type ( c_ptr ) :: qWeights_gpu type ( c_ptr ) :: iMatrix_gpu type ( c_ptr ) :: dMatrix_gpu type ( c_ptr ) :: dgMatrix_gpu type ( c_ptr ) :: bMatrix_gpu contains procedure , public :: Init => Init_Lagrange procedure , public :: Free => Free_Lagrange endtype Lagrange contains subroutine Init_Lagrange ( this , N , controlNodeType , M , targetNodeType ) !! Initialize an instance of the Lagrange class !! On output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of !! control points, number of target points, and the types for the control and target nodes. !! If a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. implicit none class ( Lagrange ), intent ( out ) :: this !! Lagrange class instance integer , intent ( in ) :: N !! The number of control points for interpolant integer , intent ( in ) :: M !! The number of target points for the interpolant integer , intent ( in ) :: controlNodeType !! The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) integer , intent ( in ) :: targetNodeType !! The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) ! -------! ! Local real ( prec ) :: q ( 0 : M ) if (. not . GPUAvailable ()) then print * , __ FILE__ , ':' , __ LINE__ , ' : Error : Attempt to use GPU extension, but GPU is not available.' stop 1 endif this % N = N this % M = M this % controlNodeType = controlNodeType this % targetNodeType = targetNodeType allocate ( this % controlPoints ( 1 : N + 1 ), & this % targetPoints ( 1 : M + 1 ), & this % bWeights ( 1 : N + 1 ), & this % qWeights ( 1 : N + 1 ), & this % iMatrix ( 1 : N + 1 , 1 : M + 1 ), & this % dMatrix ( 1 : N + 1 , 1 : N + 1 ), & this % dgMatrix ( 1 : N + 1 , 1 : N + 1 ), & this % bMatrix ( 1 : N + 1 , 1 : 2 )) if ( controlNodeType == GAUSS . or . controlNodeType == GAUSS_LOBATTO ) then call LegendreQuadrature ( N , & this % controlPoints , & this % qWeights , & controlNodeType ) elseif ( controlNodeType == CHEBYSHEV_GAUSS . or . controlNodeType == CHEBYSHEV_GAUSS_LOBATTO ) then call ChebyshevQuadrature ( N , & this % controlPoints , & this % qWeights , & controlNodeType ) elseif ( controlNodeType == UNIFORM ) then this % controlPoints = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , N ) this % qWeights = 2.0_prec / real ( N , prec ) endif ! Target Points if ( targetNodeType == GAUSS . or . targetNodeType == GAUSS_LOBATTO ) then call LegendreQuadrature ( M , & this % targetPoints , & q , & targetNodeType ) elseif ( targetNodeType == UNIFORM ) then this % targetPoints = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , M ) endif call this % CalculateBarycentricWeights () call this % CalculateInterpolationMatrix () call this % CalculateDerivativeMatrix () this % bMatrix ( 1 : N + 1 , 1 ) = this % CalculateLagrangePolynomials ( - 1.0_prec ) this % bMatrix ( 1 : N + 1 , 2 ) = this % CalculateLagrangePolynomials ( 1.0_prec ) print * , \"Lagrange malloc\" call gpuCheck ( hipMalloc ( this % iMatrix_gpu , sizeof ( this % iMatrix ))) call gpuCheck ( hipMalloc ( this % dMatrix_gpu , sizeof ( this % dMatrix ))) call gpuCheck ( hipMalloc ( this % dgMatrix_gpu , sizeof ( this % dgMatrix ))) call gpuCheck ( hipMalloc ( this % bMatrix_gpu , sizeof ( this % bMatrix ))) call gpuCheck ( hipMalloc ( this % qWeights_gpu , sizeof ( this % qWeights ))) print * , \"Lagrange memcpy\" print * , c_loc ( this % iMatrix ) call gpuCheck ( hipMemcpy ( this % iMatrix_gpu , & c_loc ( this % iMatrix ), & sizeof ( this % iMatrix ), & hipMemcpyHostToDevice )) print * , \"Lagrange memcpy\" call gpuCheck ( hipMemcpy ( this % dMatrix_gpu , & c_loc ( this % dMatrix ), & sizeof ( this % dMatrix ), & hipMemcpyHostToDevice )) print * , \"Lagrange memcpy\" call gpuCheck ( hipMemcpy ( this % dgMatrix_gpu , & c_loc ( this % dgMatrix ), & sizeof ( this % dgMatrix ), & hipMemcpyHostToDevice )) print * , \"Lagrange memcpy\" call gpuCheck ( hipMemcpy ( this % bMatrix_gpu , & c_loc ( this % bMatrix ), & sizeof ( this % bMatrix ), & hipMemcpyHostToDevice )) print * , \"Lagrange memcpy\" call gpuCheck ( hipMemcpy ( this % qWeights_gpu , & c_loc ( this % qWeights ), & sizeof ( this % qWeights ), & hipMemcpyHostToDevice )) endsubroutine Init_Lagrange subroutine Free_Lagrange ( this ) !! Frees all memory (host and device) associated with an instance of the Lagrange class implicit none class ( Lagrange ), intent ( inout ) :: this !! Lagrange class instance deallocate ( this % controlPoints ) deallocate ( this % targetPoints ) deallocate ( this % bWeights ) deallocate ( this % qWeights ) deallocate ( this % iMatrix ) deallocate ( this % dMatrix ) deallocate ( this % dgMatrix ) deallocate ( this % bMatrix ) call gpuCheck ( hipFree ( this % iMatrix_gpu )) call gpuCheck ( hipFree ( this % dMatrix_gpu )) call gpuCheck ( hipFree ( this % dgMatrix_gpu )) call gpuCheck ( hipFree ( this % bMatrix_gpu )) call gpuCheck ( hipFree ( this % qWeights_gpu )) endsubroutine Free_Lagrange endmodule SELF_Lagrange","tags":"","loc":"sourcefile/self_lagrange.f90~2.html"},{"title":"SELF_Scalar_1D.f90 – SELF","text":"Contents Modules SELF_Scalar_1D Source Code SELF_Scalar_1D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Scalar_1D use SELF_Constants use SELF_Scalar_1D_t use SELF_GPU use SELF_GPUBLAS use iso_c_binding implicit none ! ---------------------- Scalars ---------------------- ! type , extends ( Scalar1D_t ), public :: Scalar1D character ( 3 ) :: backend = \"apu\" type ( c_ptr ) :: blas_handle contains procedure , public :: Init => Init_Scalar1D procedure , public :: Free => Free_Scalar1D procedure , public :: BoundaryInterp => BoundaryInterp_Scalar1D !procedure,public :: GridInterp => GridInterp_Scalar1D !procedure,public :: Derivative => Derivative_Scalar1D endtype Scalar1D contains ! -- Scalar1D -- ! subroutine Init_Scalar1D ( this , interp , nVar , nElem ) implicit none class ( Scalar1D ), intent ( out ) :: this type ( Lagrange ), intent ( in ), target :: interp integer , intent ( in ) :: nVar integer , intent ( in ) :: nElem if (. not . GPUAvailable ()) then print * , __ FILE__ , ':' , __ LINE__ , ' : Error : Attempt to use GPU extension, but GPU is not available.' stop 1 endif this % interp => interp this % nVar = nVar this % nElem = nElem this % N = interp % N this % M = interp % M allocate ( this % interior ( 1 : interp % N + 1 , 1 : nelem , 1 : nvar ), & this % boundary ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % extBoundary ( 1 : 2 , 1 : nelem , 1 : nvar ), & this % avgBoundary ( 1 : 2 , 1 : nelem , 1 : nvar )) allocate ( this % meta ( 1 : nVar )) allocate ( this % eqn ( 1 : nVar )) call gpuCheck ( hipMalloc ( c_loc ( this % interior_gpu ), sizeof ( this % interior ))) call gpuCheck ( hipMalloc ( c_loc ( this % boundary_gpu ), sizeof ( this % boundary ))) call gpuCheck ( hipMalloc ( c_loc ( this % extBoundary_gpu ), sizeof ( this % extBoundary ))) call gpuCheck ( hipMalloc ( c_loc ( this % avgBoundary_gpu ), sizeof ( this % avgBoundary ))) call hipblasCheck ( hipblasCreate ( this % blas_handle )) endsubroutine Init_Scalar1D subroutine Free_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this this % interp => null () deallocate ( this % interior ) deallocate ( this % boundary ) deallocate ( this % extBoundary ) deallocate ( this % meta ) deallocate ( this % eqn ) call gpuCheck ( hipFree ( c_loc ( this % interior_gpu ))) call gpuCheck ( hipFree ( c_loc ( this % boundary_gpu ))) call gpuCheck ( hipFree ( c_loc ( this % extBoundary_gpu ))) call gpuCheck ( hipFree ( c_loc ( this % avgBoundary_gpu ))) call hipblasCheck ( hipblasDestroy ( this % blas_handle )) endsubroutine Free_Scalar1D subroutine UpdateHost_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior ), c_loc ( this % interior_gpu ), sizeof ( this % interior ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary ), c_loc ( this % boundary_gpu ), sizeof ( this % boundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary ), c_loc ( this % extboundary_gpu ), sizeof ( this % extboundary ), hipMemcpyDeviceToHost )) call gpuCheck ( hipMemcpy ( c_loc ( this % avgboundary ), c_loc ( this % avgboundary_gpu ), sizeof ( this % boundary ), hipMemcpyDeviceToHost )) endsubroutine UpdateHost_Scalar1D subroutine UpdateDevice_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this call gpuCheck ( hipMemcpy ( c_loc ( this % interior_gpu ), c_loc ( this % interior ), sizeof ( this % interior ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( c_loc ( this % boundary_gpu ), c_loc ( this % boundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( c_loc ( this % extboundary_gpu ), c_loc ( this % extboundary ), sizeof ( this % extboundary ), hipMemcpyHostToDevice )) call gpuCheck ( hipMemcpy ( c_loc ( this % avgboundary_gpu ), c_loc ( this % avgboundary ), sizeof ( this % boundary ), hipMemcpyHostToDevice )) endsubroutine UpdateDevice_Scalar1D subroutine BoundaryInterp_Scalar1D ( this ) implicit none class ( Scalar1D ), intent ( inout ) :: this call self_blas_matrixop_1d ( this % interp % bMatrix_gpu , & this % interior_gpu , & this % boundary_gpu , & 2 , this % N + 1 , & this % nvar * this % nelem , this % blas_handle ) endsubroutine BoundaryInterp_Scalar1D ! function GridInterp_Scalar1D(this) result(f) !   implicit none !   class(Scalar1D),intent(in) :: this !   real(prec) :: f(1:this%M+1,1:this%nelem,1:this%nvar) !   ! Local !   integer :: iel,ivar,i,ii !   real(prec) :: floc !   !$omp target !   !$omp teams loop bind(teams) collapse(3) !   do ivar = 1,this%nvar !     do iel = 1,this%nelem !       do i = 1,this%M+1 !         floc = 0.0_prec !         !$omp loop bind(thread) !         do ii = 1,this%N+1 !           floc = floc+this%interp%iMatrix(ii,i)*this%interior(ii,iel,ivar) !         enddo !         f(i,iel,ivar) = floc !       enddo !     enddo !   enddo !   !$omp end target ! endfunction GridInterp_Scalar1D ! function Derivative_Scalar1D(this) result(df) !   implicit none !   class(Scalar1D),intent(in) :: this !   real(prec) :: df(1:this%N+1,1:this%nelem,1:this%nvar) !   ! Local !   integer :: i,ii,iel,ivar !   real(prec) :: dfloc !   !$omp target !   !$omp teams loop bind(teams) collapse(3) !   do ivar = 1,this%nvar !     do iel = 1,this%nelem !       do i = 1,this%N+1 !         dfloc = 0.0_prec !         !$omp loop bind(thread) !         do ii = 1,this%N+1 !           dfloc = dfloc+this%interp%dMatrix(ii,i)*this%interior(ii,iel,ivar) !         enddo !         df(i,iel,ivar) = dfloc !       enddo !     enddo !   enddo !   !$omp end target !   !call self_hipblas_matrixop_1d(this % dMatrix,f,df,this % N + 1,this % N + 1,nvars*nelems,handle) ! endfunction Derivative_Scalar1D endmodule SELF_Scalar_1D","tags":"","loc":"sourcefile/self_scalar_1d.f90~2.html"},{"title":"SELF_GPU_enums.f90 – SELF","text":"Contents Modules SELF_GPU_enums Source Code SELF_GPU_enums.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_GPU_enums use iso_c_binding implicit none enum , bind ( c ) enumerator :: hipSuccess = 0 endenum enum , bind ( c ) enumerator :: hipMemcpyHostToHost = 0 enumerator :: hipMemcpyHostToDevice = 1 enumerator :: hipMemcpyDeviceToHost = 2 enumerator :: hipMemcpyDeviceToDevice = 3 enumerator :: hipMemcpyDefault = 4 endenum enum , bind ( c ) enumerator :: HIPBLAS_STATUS_SUCCESS = 0 enumerator :: HIPBLAS_STATUS_NOT_INITIALIZED = 1 enumerator :: HIPBLAS_STATUS_ALLOC_FAILED = 2 enumerator :: HIPBLAS_STATUS_INVALID_VALUE = 3 enumerator :: HIPBLAS_STATUS_MAPPING_ERROR = 4 enumerator :: HIPBLAS_STATUS_EXECUTION_FAILED = 5 enumerator :: HIPBLAS_STATUS_INTERNAL_ERROR = 6 enumerator :: HIPBLAS_STATUS_NOT_SUPPORTED = 7 enumerator :: HIPBLAS_STATUS_ARCH_MISMATCH = 8 enumerator :: HIPBLAS_STATUS_HANDLE_IS_NULLPTR = 9 enumerator :: HIPBLAS_STATUS_INVALID_ENUM = 10 enumerator :: HIPBLAS_STATUS_UNKNOWN = 11 endenum enum , bind ( c ) #ifdef HAVE_CUDA enumerator :: HIPBLAS_OP_N = 0 #else enumerator :: HIPBLAS_OP_N = 111 #endif #ifdef HAVE_CUDA enumerator :: HIPBLAS_OP_T = 1 #else enumerator :: HIPBLAS_OP_T = 112 #endif endenum endmodule SELF_GPU_enums","tags":"","loc":"sourcefile/self_gpu_enums.f90~2.html"},{"title":"SELF_GPU.f90 – SELF","text":"Contents Modules SELF_GPU Source Code SELF_GPU.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_GPU use iso_c_binding use SELF_GPU_enums implicit none interface hipGetDeviceCount #ifdef HAVE_HIP function hipGetDeviceCount_ ( count ) bind ( c , name = \"hipGetDeviceCount\" ) #elif HAVE_CUDA function hipGetDeviceCount_ ( count ) bind ( c , name = \"cudaGetDeviceCount\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( hipSuccess )) :: hipGetDeviceCount_ integer ( c_int ) :: count endfunction endinterface interface hipMalloc #ifdef HAVE_HIP function hipMalloc_ ( ptr , mySize ) bind ( c , name = \"hipMalloc\" ) #elif HAVE_CUDA function hipMalloc_ ( ptr , mySize ) bind ( c , name = \"cudaMalloc\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( hipSuccess )) :: hipMalloc_ type ( c_ptr ) :: ptr integer ( c_size_t ), value :: mySize endfunction endinterface hipMalloc interface hipFree #ifdef HAVE_HIP function hipFree_ ( ptr ) bind ( c , name = \"hipFree\" ) #elif HAVE_CUDA function hipFree_ ( ptr ) bind ( c , name = \"cudaFree\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( hipSuccess )) :: hipFree_ type ( c_ptr ), value :: ptr endfunction endinterface hipFree interface hipMemcpy #ifdef HAVE_HIP function hipMemcpy_ ( dest , src , sizeBytes , myKind ) bind ( c , name = \"hipMemcpy\" ) #elif HAVE_CUDA function hipMemcpy_ ( dest , src , sizeBytes , myKind ) bind ( c , name = \"cudaMemcpy\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( hipSuccess )) :: hipMemcpy_ type ( c_ptr ), value :: dest type ( c_ptr ), value :: src integer ( c_size_t ), value :: sizeBytes integer ( kind ( hipMemcpyHostToHost )), value :: myKind endfunction hipMemcpy_ endinterface hipMemcpy contains subroutine gpuCheck ( gpuError_t ) implicit none integer ( kind ( hipSuccess )) :: gpuError_t if ( gpuError_t /= hipSuccess ) then write ( * , * ) \"GPU ERROR: Error code = \" , gpuError_t call exit ( gpuError_t ) endif endsubroutine gpuCheck function GPUAvailable () result ( avail ) implicit none logical :: avail ! Local integer ( c_int ) :: gpuCount integer ( kind ( hipSuccess )) :: err err = hipGetDeviceCount ( gpuCount ) if ( gpuCount > 0 . and . err == hipSuccess ) then avail = . true . else avail = . false . endif endfunction GPUAvailable ! subroutine HostToDevice(fsource,fdest) !   implicit none !   type(c_ptr), intent(inout) :: fsource !   type(c_ptr), intent(inout) :: fdest !   call gpuCheck(hipMemcpy(fdest,fsource,sizeof(fsource),hipMemcpyHostToDevice)) ! endsubroutine HostToDevice ! subroutine DeviceToHost(fsource,fdest) !   implicit none !   type(c_ptr), intent(inout)    :: fsource !   type(c_ptr), intent(inout) :: fdest !   call gpuCheck(hipMemcpy(fdest,fsource,sizeof(fsource),hipMemcpyDeviceToHost)) ! endsubroutine DeviceToHost endmodule SELF_GPU","tags":"","loc":"sourcefile/self_gpu.f90~2.html"},{"title":"SELF_GPUBLAS.f90 – SELF","text":"Contents Modules SELF_GPUBLAS Source Code SELF_GPUBLAS.f90 Source Code module SELF_GPUBLAS use SELF_GPU_enums use SELF_Constants use iso_c_binding use iso_fortran_env implicit none interface hipblasCreate #ifdef HAVE_CUDA function hipblasCreate_ ( handle ) bind ( c , name = \"cublasCreate_v2\" ) #else function hipblasCreate_ ( handle ) bind ( c , name = \"hipblasCreate\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasCreate_ type ( c_ptr ) :: handle endfunction endinterface interface hipblasDestroy #ifdef HAVE_CUDA function hipblasDestroy_ ( handle ) bind ( c , name = \"cublasDestroy_v2\" ) #else function hipblasDestroy_ ( handle ) bind ( c , name = \"hipblasDestroy\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasDestroy_ type ( c_ptr ), value :: handle endfunction endinterface interface hipblasSgemm #ifdef HAVE_CUDA function hipblasSgemm_ ( handle , transa , transb , m , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) bind ( c , name = \"cublasSgemm_v2\" ) #else function hipblasSgemm_ ( handle , transa , transb , m , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) bind ( c , name = \"hipblasSgemm\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasSgemm_ type ( c_ptr ), value :: handle integer ( kind ( HIPBLAS_OP_N )), value :: transa integer ( kind ( HIPBLAS_OP_N )), value :: transb integer ( c_int ), value :: m integer ( c_int ), value :: n integer ( c_int ), value :: k real ( c_float ) :: alpha type ( c_ptr ), value :: A integer ( c_int ), value :: lda type ( c_ptr ), value :: B integer ( c_int ), value :: ldb real ( c_float ) :: beta type ( c_ptr ), value :: C integer ( c_int ), value :: ldc endfunction endinterface interface hipblasDgemm #ifdef HAVE_CUDA function hipblasDgemm_ ( handle , transa , transb , m , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) bind ( c , name = \"cublasDgemm_v2\" ) #else function hipblasDgemm_ ( handle , transa , transb , m , n , k , alpha , A , lda , B , ldb , beta , C , ldc ) bind ( c , name = \"hipblasDgemm\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasDgemm_ type ( c_ptr ), value :: handle integer ( kind ( HIPBLAS_OP_N )), value :: transa integer ( kind ( HIPBLAS_OP_N )), value :: transb integer ( c_int ), value :: m integer ( c_int ), value :: n integer ( c_int ), value :: k real ( c_double ) :: alpha type ( c_ptr ), value :: A integer ( c_int ), value :: lda type ( c_ptr ), value :: B integer ( c_int ), value :: ldb real ( c_double ) :: beta type ( c_ptr ), value :: C integer ( c_int ), value :: ldc endfunction endinterface interface hipblasSgemvStridedBatched #ifdef HAVE_CUDA function hipblasSgemvStridedBatched_ ( handle , trans , m , n , alpha , A , lda , strideA , x , & incx , stridex , beta , y , incy , stridey , batchCount ) & bind ( c , name = \"cublasSgemvStridedBatched\" ) #else function hipblasSgemvStridedBatched_ ( handle , trans , m , n , alpha , A , lda , strideA , x , & incx , stridex , beta , y , incy , stridey , batchCount ) & bind ( c , name = \"hipblasSgemvStridedBatched\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasSgemvStridedBatched_ type ( c_ptr ), value :: handle integer ( kind ( HIPBLAS_OP_N )), value :: trans integer ( c_int ), value :: m integer ( c_int ), value :: n real ( c_float ) :: alpha type ( c_ptr ), value :: A integer ( c_int ), value :: lda integer ( c_int64_t ), value :: strideA type ( c_ptr ), value :: x integer ( c_int ), value :: incx integer ( c_int64_t ), value :: stridex real ( c_float ) :: beta type ( c_ptr ), value :: y integer ( c_int ), value :: incy integer ( c_int64_t ), value :: stridey integer ( c_int ), value :: batchCount endfunction endinterface interface hipblasDgemvStridedBatched #ifdef HAVE_CUDA function hipblasDgemvStridedBatched_ ( handle , trans , m , n , alpha , A , lda , strideA , x , & incx , stridex , beta , y , incy , stridey , batchCount ) & bind ( c , name = \"cublasDgemvStridedBatched\" ) #else function hipblasDgemvStridedBatched_ ( handle , trans , m , n , alpha , A , lda , strideA , x , & incx , stridex , beta , y , incy , stridey , batchCount ) & bind ( c , name = \"hipblasDgemvStridedBatched\" ) #endif use iso_c_binding use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasDgemvStridedBatched_ type ( c_ptr ), value :: handle integer ( kind ( HIPBLAS_OP_N )), value :: trans integer ( c_int ), value :: m integer ( c_int ), value :: n real ( c_double ) :: alpha type ( c_ptr ), value :: A integer ( c_int ), value :: lda integer ( c_int64_t ), value :: strideA type ( c_ptr ), value :: x integer ( c_int ), value :: incx integer ( c_int64_t ), value :: stridex real ( c_double ) :: beta type ( c_ptr ), value :: y integer ( c_int ), value :: incy integer ( c_int64_t ), value :: stridey integer ( c_int ), value :: batchCount endfunction endinterface contains #ifdef DOUBLE_PRECISION #define hipblasgemm hipblasDgemm #define hipblasgemvStridedBatched hipblasDgemvStridedBatched #else #define hipblasgemm hipblasSgemm #define hipblasgemvStridedBatched hipblasSgemvStridedBatched #endif subroutine hipblasCheck ( hipblasError_t ) use SELF_GPU_enums implicit none integer ( kind ( HIPBLAS_STATUS_SUCCESS )) :: hipblasError_t if ( hipblasError_t /= HIPBLAS_STATUS_SUCCESS ) then write ( * , * ) \"GPUBLAS ERROR: Error code = \" , hipblasError_t call exit ( hipblasError_t ) endif endsubroutine hipblasCheck subroutine self_blas_matrixop_1d ( A , f , Af , opArows , opAcols , bcols , handle ) type ( c_ptr ), intent ( in ) :: A real ( prec ), pointer , intent ( in ) :: f (:,:,:) real ( prec ), pointer , intent ( inout ) :: Af (:,:,:) integer , intent ( in ) :: opArows , opAcols , bcols type ( c_ptr ), intent ( inout ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n integer ( c_int ) :: k real ( c_prec ) :: alpha integer ( c_int ) :: lda integer ( c_int ) :: ldb integer ( c_int ) :: ldc real ( c_prec ) :: beta m = opArows ! number of rows of A&#94;T n = bcols ! number of columns of B k = opAcols ! number of columns of A&#94;T alpha = 1.0_c_prec lda = k ! leading dimension of A (matrix) ldb = k ! leading dimension of B (f) ldc = m ! leading dimension of C (Af) beta = 0.0_c_prec call hipblasCheck ( hipblasgemm ( handle , & HIPBLAS_OP_T , HIPBLAS_OP_N , & m , n , k , alpha , & A , lda , & c_loc ( f ), ldb , & beta , & c_loc ( Af ), ldc )) endsubroutine self_blas_matrixop_1d subroutine self_blas_matrixop_dim1_2d ( A , f , Af , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A real ( prec ), pointer , intent ( in ) :: f (:,:,:,:) real ( prec ), pointer , intent ( inout ) :: Af (:,:,:,:) integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( inout ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n integer ( c_int ) :: k real ( c_prec ) :: alpha integer ( c_int ) :: lda integer ( c_int ) :: ldb integer ( c_int ) :: ldc real ( c_prec ) :: beta m = targetdegree + 1 ! number of rows of A&#94;T n = nvars * nelems * ( controldegree + 1 ) ! number of columns of B k = controldegree + 1 ! number of columns of A&#94;T alpha = 1.0_c_prec lda = k ! leading dimension of A (interpolation/derivative matrix) ldb = k ! leading dimension of B (f) ldc = m ! leading dimension of C (fTarget) beta = 0.0_c_prec ! First pass interpolates in the first quadrature dimension call hipblasCheck ( hipblasgemm ( handle , & HIPBLAS_OP_T , HIPBLAS_OP_N , & m , n , k , alpha , & A , lda , & c_loc ( f ), ldb , beta , & c_loc ( Af ), ldc )) endsubroutine self_blas_matrixop_dim1_2d subroutine self_blas_matrixop_dim2_2d ( A , f , Af , beta , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A real ( prec ), pointer , intent ( in ) :: f (:,:,:,:) real ( prec ), pointer , intent ( inout ) :: Af (:,:,:,:) real ( c_prec ), intent ( in ) :: beta integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( inout ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n real ( c_prec ) :: alpha integer ( c_int ) :: lda integer :: i integer ( c_int64_t ) :: strideA integer ( c_int ) :: incx integer ( c_int64_t ) :: stridex integer ( c_int ) :: incy integer ( c_int64_t ) :: stridey integer ( c_int ) :: batchCount m = controldegree + 1 ! number of rows of A n = targetdegree + 1 ! number of columns of A alpha = 1.0_c_prec lda = m ! leading dimension of A strideA = 0 ! stride for the batches of A (no stride) incx = targetdegree + 1 ! stridex = ( controldegree + 1 ) * ( targetdegree + 1 ) incy = targetdegree + 1 stridey = ( targetdegree + 1 ) * ( targetdegree + 1 ) batchCount = nvars * nelems do i = 0 , targetdegree call hipblasCheck ( hipblasgemvStridedBatched ( handle , & HIPBLAS_OP_T , & m , n , alpha , & A , lda , strideA , & c_loc ( f ( 1 + i , 1 , 1 , 1 )), incx , stridex , beta , & c_loc ( Af ( 1 + i , 1 , 1 , 1 )), incy , stridey , batchCount )) enddo endsubroutine self_blas_matrixop_dim2_2d subroutine self_blas_matrixop_dim1_3d ( A , f , Af , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A real ( prec ), pointer , intent ( in ) :: f (:,:,:,:,:) real ( prec ), pointer , intent ( inout ) :: Af (:,:,:,:,:) integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( inout ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n integer ( c_int ) :: k real ( c_prec ) :: alpha integer ( c_int ) :: lda integer ( c_int ) :: ldb integer ( c_int ) :: ldc real ( c_prec ) :: beta m = targetdegree + 1 ! number of rows of A&#94;T n = nvars * nelems * ( controldegree + 1 ) * ( controldegree + 1 ) ! number of columns of B k = controldegree + 1 ! number of columns of A&#94;T alpha = 1.0_c_prec lda = k ! leading dimension of A (interoplation matrix) ldb = k ! leading dimension of B (f) ldc = m ! leading dimension of C (fTarget) beta = 0.0_c_prec ! First pass interpolates in the first quadrature dimension call hipblasCheck ( hipblasgemm ( handle , & HIPBLAS_OP_T , HIPBLAS_OP_N , & m , n , k , alpha , & A , lda , & c_loc ( f ), ldb , beta , & c_loc ( Af ), ldc )) endsubroutine self_blas_matrixop_dim1_3d subroutine self_blas_matrixop_dim2_3d ( A , f , Af , beta , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A real ( prec ), pointer , intent ( in ) :: f (:,:,:,:,:) real ( prec ), pointer , intent ( inout ) :: Af (:,:,:,:,:) real ( c_prec ), intent ( in ) :: beta integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( inout ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n real ( c_prec ) :: alpha integer ( c_int ) :: lda integer :: i integer ( c_int64_t ) :: strideA integer ( c_int ) :: incx integer ( c_int64_t ) :: stridex integer ( c_int ) :: incy integer ( c_int64_t ) :: stridey integer ( c_int ) :: batchCount m = controldegree + 1 ! number of rows of A n = targetdegree + 1 ! number of columns of A alpha = 1.0_c_prec lda = m ! leading dimension of A strideA = 0 ! stride for the batches of A (no stride) incx = targetdegree + 1 ! stridex = ( controldegree + 1 ) * ( targetdegree + 1 ) !beta = 0.0_c_prec incy = targetdegree + 1 stridey = ( targetdegree + 1 ) * ( targetdegree + 1 ) batchCount = ( controldegree + 1 ) * nvars * nelems do i = 0 , targetdegree call hipblasCheck ( hipblasgemvStridedBatched ( handle , & HIPBLAS_OP_T , & m , n , alpha , & A , lda , strideA , & c_loc ( f ( 1 + i , 1 , 1 , 1 , 1 )), incx , stridex , beta , & c_loc ( Af ( 1 + i , 1 , 1 , 1 , 1 )), incy , stridey , batchCount )) enddo endsubroutine self_blas_matrixop_dim2_3d subroutine self_blas_matrixop_dim3_3d ( A , f , Af , beta , controldegree , targetdegree , nvars , nelems , handle ) type ( c_ptr ), intent ( in ) :: A real ( prec ), pointer , intent ( in ) :: f (:,:,:,:,:) real ( prec ), pointer , intent ( inout ) :: Af (:,:,:,:,:) real ( c_prec ), intent ( in ) :: beta integer , intent ( in ) :: controldegree , targetdegree , nvars , nelems type ( c_ptr ), intent ( inout ) :: handle ! Local integer ( c_int ) :: m integer ( c_int ) :: n real ( c_prec ) :: alpha integer ( c_int ) :: lda integer :: i , j integer ( c_int64_t ) :: strideA integer ( c_int ) :: incx integer ( c_int64_t ) :: stridex integer ( c_int ) :: incy integer ( c_int64_t ) :: stridey integer ( c_int ) :: batchCount m = controldegree + 1 ! number of rows of A n = targetdegree + 1 ! number of columns of A alpha = 1.0_c_prec lda = m ! leading dimension of A strideA = 0 ! stride for the batches of A (no stride) incx = ( targetdegree + 1 ) * ( targetdegree + 1 ) ! stridex = ( controldegree + 1 ) * ( targetdegree + 1 ) * ( targetdegree + 1 ) incy = ( targetdegree + 1 ) * ( targetdegree + 1 ) stridey = ( targetdegree + 1 ) * ( targetdegree + 1 ) * ( targetdegree + 1 ) batchCount = nvars * nelems do j = 0 , targetdegree do i = 0 , targetdegree call hipblasCheck ( hipblasgemvStridedBatched ( handle , & HIPBLAS_OP_T , & m , n , alpha , & A , lda , strideA , & c_loc ( f ( 1 + i , 1 + j , 1 , 1 , 1 )), incx , stridex , beta , & c_loc ( Af ( 1 + i , 1 + j , 1 , 1 , 1 )), incy , stridey , batchCount )) enddo enddo endsubroutine self_blas_matrixop_dim3_3d endmodule SELF_GPUBLAS","tags":"","loc":"sourcefile/self_gpublas.f90~2.html"},{"title":"SELF_NullDGModel3D.f90 – SELF","text":"Contents Modules self_NullDGModel3D Source Code SELF_NullDGModel3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_NullDGModel3D use self_NullDGModel3D_t implicit none type , extends ( NullDGModel3D_t ) :: NullDGModel3D endtype NullDGModel3D endmodule self_NullDGModel3D","tags":"","loc":"sourcefile/self_nulldgmodel3d.f90~2.html"},{"title":"SELF_MappedScalar_3D.f90 – SELF","text":"Contents Modules SELF_MappedScalar_3D Source Code SELF_MappedScalar_3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_MappedScalar_3D use SELF_MappedScalar_3D_t implicit none type , extends ( MappedScalar3D_t ), public :: MappedScalar3D endtype MappedScalar3D endmodule SELF_MappedScalar_3D","tags":"","loc":"sourcefile/self_mappedscalar_3d.f90~2.html"},{"title":"SELF_Vector_3D.f90 – SELF","text":"Contents Modules SELF_Vector_3D Source Code SELF_Vector_3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Vector_3D use SELF_Vector_3D_t implicit none type , extends ( Vector3D_t ), public :: Vector3D character ( 3 ) :: backend = \"cpu\" endtype Vector3D endmodule SELF_Vector_3D","tags":"","loc":"sourcefile/self_vector_3d.f90~2.html"},{"title":"SELF_Burgers1D.f90 – SELF","text":"Contents Modules self_Burgers1D Source Code SELF_Burgers1D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_Burgers1D use self_Burgers1D_t implicit none type , extends ( Burgers1D_t ) :: Burgers1D endtype Burgers1D endmodule self_Burgers1D","tags":"","loc":"sourcefile/self_burgers1d.f90~2.html"},{"title":"SELF_Lagrange.f90 – SELF","text":"Contents Modules SELF_Lagrange Source Code SELF_Lagrange.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Lagrange use iso_fortran_env use iso_c_binding use SELF_Constants use SELF_Lagrange_t implicit none type , extends ( Lagrange_t ), public :: Lagrange character ( 3 ) :: backend = 'cpu' endtype Lagrange endmodule SELF_Lagrange","tags":"","loc":"sourcefile/self_lagrange.f90~3.html"},{"title":"SELF_DomainDecomposition.f90 – SELF","text":"Contents Modules SELF_DomainDecomposition Source Code SELF_DomainDecomposition.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_DomainDecomposition use SELF_DomainDecomposition_t implicit none type , extends ( DomainDecomposition_t ) :: DomainDecomposition endtype DomainDecomposition endmodule SELF_DomainDecomposition","tags":"","loc":"sourcefile/self_domaindecomposition.f90~2.html"},{"title":"SELF_Mesh_2D.f90 – SELF","text":"Contents Modules SELF_Mesh_2D Source Code SELF_Mesh_2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Mesh_2D use SELF_Mesh_2D_t implicit none type , extends ( Mesh2D_t ) :: Mesh2D endtype Mesh2D endmodule SELF_Mesh_2D","tags":"","loc":"sourcefile/self_mesh_2d.f90~2.html"},{"title":"SELF_Scalar_1D.f90 – SELF","text":"Contents Modules SELF_Scalar_1D Source Code SELF_Scalar_1D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Scalar_1D use SELF_Scalar_1D_t implicit none type , extends ( Scalar1D_t ), public :: Scalar1D character ( 3 ) :: backend = \"cpu\" endtype Scalar1D endmodule SELF_Scalar_1D","tags":"","loc":"sourcefile/self_scalar_1d.f90~3.html"},{"title":"SELF_advection_diffusion_2d.f90 – SELF","text":"Contents Modules self_advection_diffusion_2d Source Code SELF_advection_diffusion_2d.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_advection_diffusion_2d use self_advection_diffusion_2d_t implicit none type , extends ( advection_diffusion_2d_t ) :: advection_diffusion_2d endtype advection_diffusion_2d endmodule self_advection_diffusion_2d","tags":"","loc":"sourcefile/self_advection_diffusion_2d.f90~2.html"},{"title":"SELF_DGModel2D.f90 – SELF","text":"Contents Modules SELF_DGModel2D Source Code SELF_DGModel2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_DGModel2D use SELF_DGModel2D_t implicit none type , extends ( DGModel2D_t ) :: DGModel2D endtype DGModel2D endmodule SELF_DGModel2D","tags":"","loc":"sourcefile/self_dgmodel2d.f90~2.html"},{"title":"SELF_advection_diffusion_1d.f90 – SELF","text":"Contents Modules self_advection_diffusion_1d Source Code SELF_advection_diffusion_1d.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_advection_diffusion_1d use self_advection_diffusion_1d_t implicit none type , extends ( advection_diffusion_1d_t ) :: advection_diffusion_1d endtype advection_diffusion_1d endmodule self_advection_diffusion_1d","tags":"","loc":"sourcefile/self_advection_diffusion_1d.f90~2.html"},{"title":"SELF_advection_diffusion_3d.f90 – SELF","text":"Contents Modules self_advection_diffusion_3d Source Code SELF_advection_diffusion_3d.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_advection_diffusion_3d use self_advection_diffusion_3d_t implicit none type , extends ( advection_diffusion_3d_t ) :: advection_diffusion_3d endtype advection_diffusion_3d endmodule self_advection_diffusion_3d","tags":"","loc":"sourcefile/self_advection_diffusion_3d.f90~2.html"},{"title":"SELF_NullDGModel1D.f90 – SELF","text":"Contents Modules self_NullDGModel1D Source Code SELF_NullDGModel1D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_NullDGModel1D use self_NullDGModel1D_t implicit none type , extends ( NullDGModel1D_t ) :: NullDGModel1D endtype NullDGModel1D endmodule self_NullDGModel1D","tags":"","loc":"sourcefile/self_nulldgmodel1d.f90~2.html"},{"title":"SELF_DGModel1D.f90 – SELF","text":"Contents Modules SELF_DGModel1D Source Code SELF_DGModel1D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_DGModel1D use SELF_DGModel1D_t implicit none type , extends ( DGModel1D_t ) :: DGModel1D endtype DGModel1D endmodule SELF_DGModel1D","tags":"","loc":"sourcefile/self_dgmodel1d.f90~2.html"},{"title":"SELF_MappedVector_3D.f90 – SELF","text":"Contents Modules SELF_MappedVector_3D Source Code SELF_MappedVector_3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_MappedVector_3D use SELF_MappedVector_3D_t implicit none type , extends ( MappedVector3D_t ), public :: MappedVector3D endtype MappedVector3D endmodule SELF_MappedVector_3D","tags":"","loc":"sourcefile/self_mappedvector_3d.f90~2.html"},{"title":"SELF_Mesh_3D.f90 – SELF","text":"Contents Modules SELF_Mesh_3D Source Code SELF_Mesh_3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Mesh_3D use SELF_Mesh_3D_t implicit none type , extends ( Mesh3D_t ) :: Mesh3D endtype Mesh3D endmodule SELF_Mesh_3D","tags":"","loc":"sourcefile/self_mesh_3d.f90~2.html"},{"title":"SELF_MappedScalar_1D.f90 – SELF","text":"Contents Modules SELF_MappedScalar_1D Source Code SELF_MappedScalar_1D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_MappedScalar_1D use SELF_MappedScalar_1D_t implicit none type , extends ( MappedScalar1D_t ), public :: MappedScalar1D endtype MappedScalar1D endmodule SELF_MappedScalar_1D","tags":"","loc":"sourcefile/self_mappedscalar_1d.f90~2.html"},{"title":"SELF_Tensor_3D.f90 – SELF","text":"Contents Modules SELF_Tensor_3D Source Code SELF_Tensor_3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Tensor_3D use SELF_Tensor_3D_t implicit none type , extends ( Tensor3D_t ), public :: Tensor3D character ( 3 ) :: backend = \"cpu\" endtype Tensor3D endmodule SELF_Tensor_3D","tags":"","loc":"sourcefile/self_tensor_3d.f90~2.html"},{"title":"SELF_NullDGModel2D.f90 – SELF","text":"Contents Modules self_NullDGModel2D Source Code SELF_NullDGModel2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module self_NullDGModel2D use self_NullDGModel2D_t implicit none type , extends ( NullDGModel2D_t ) :: NullDGModel2D endtype NullDGModel2D endmodule self_NullDGModel2D","tags":"","loc":"sourcefile/self_nulldgmodel2d.f90~2.html"},{"title":"SELF_Scalar_3D.f90 – SELF","text":"Contents Modules SELF_Scalar_3D Source Code SELF_Scalar_3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Scalar_3D use SELF_Constants use SELF_Scalar_3D_t use iso_c_binding implicit none type , extends ( Scalar3D_t ), public :: Scalar3D character ( 3 ) :: backend = \"cpu\" endtype Scalar3D endmodule SELF_Scalar_3D","tags":"","loc":"sourcefile/self_scalar_3d.f90~2.html"},{"title":"SELF_Scalar_2D.f90 – SELF","text":"Contents Modules SELF_Scalar_2D Source Code SELF_Scalar_2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Scalar_2D use SELF_Constants use SELF_Scalar_2D_t use iso_c_binding implicit none type , extends ( Scalar2D_t ), public :: Scalar2D character ( 3 ) :: backend = \"cpu\" endtype Scalar2D endmodule SELF_Scalar_2D","tags":"","loc":"sourcefile/self_scalar_2d.f90~2.html"},{"title":"SELF_Vector_2D.f90 – SELF","text":"Contents Modules SELF_Vector_2D Source Code SELF_Vector_2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Vector_2D use SELF_Vector_2D_t implicit none type , extends ( Vector2D_t ), public :: Vector2D character ( 3 ) :: backend = \"cpu\" endtype Vector2D endmodule SELF_Vector_2D","tags":"","loc":"sourcefile/self_vector_2d.f90~2.html"},{"title":"SELF_MappedScalar_2D.f90 – SELF","text":"Contents Modules SELF_MappedScalar_2D Source Code SELF_MappedScalar_2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_MappedScalar_2D use SELF_MappedScalar_2D_t implicit none type , extends ( MappedScalar2D_t ), public :: MappedScalar2D endtype MappedScalar2D endmodule SELF_MappedScalar_2D","tags":"","loc":"sourcefile/self_mappedscalar_2d.f90~2.html"},{"title":"SELF_DGModel3D.f90 – SELF","text":"Contents Modules SELF_DGModel3D Source Code SELF_DGModel3D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_DGModel3D use SELF_DGModel3D_t implicit none type , extends ( DGModel3D_t ) :: DGModel3D endtype DGModel3D endmodule SELF_DGModel3D","tags":"","loc":"sourcefile/self_dgmodel3d.f90~2.html"},{"title":"SELF_MappedVector_2D.f90 – SELF","text":"Contents Modules SELF_MappedVector_2D Source Code SELF_MappedVector_2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_MappedVector_2D use SELF_MappedVector_2D_t implicit none type , extends ( MappedVector2D_t ), public :: MappedVector2D endtype MappedVector2D endmodule SELF_MappedVector_2D","tags":"","loc":"sourcefile/self_mappedvector_2d.f90~2.html"},{"title":"SELF_Tensor_2D.f90 – SELF","text":"Contents Modules SELF_Tensor_2D Source Code SELF_Tensor_2D.f90 Source Code ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Maintainers : support@fluidnumerics.com ! Official Repository : https://github.com/FluidNumerics/self/ ! ! Copyright © 2024 Fluid Numerics LLC ! ! Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in !    the documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ! HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ! THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// ! module SELF_Tensor_2D use SELF_Tensor_2D_t implicit none type , extends ( Tensor2D_t ), public :: Tensor2D character ( 3 ) :: backend = \"cpu\" endtype Tensor2D endmodule SELF_Tensor_2D","tags":"","loc":"sourcefile/self_tensor_2d.f90~2.html"},{"title":"SELF_DomainDecomposition.cpp – SELF","text":"Contents Source Code SELF_DomainDecomposition.cpp Source Code #include <stdio.h> #include <mpi.h> #include <mpi-ext.h> /* Needed for ROCm-aware check */ extern \"C\" { int check_gpu_aware_support () { int gpuaware = 0 ; #if defined(OMPI_HAVE_MPI_EXT_ROCM) && OMPI_HAVE_MPI_EXT_ROCM gpuaware = ( int ) MPIX_Query_rocm_support (); printf ( \"Query rocm support\" ); #endif #if defined(OMPI_HAVE_MPI_EXT_CUDA) && OMPI_HAVE_MPI_EXT_CUDA gpuaware = ( int ) MPIX_Query_cuda_support (); #endif return gpuaware ; } }","tags":"","loc":"sourcefile/self_domaindecomposition.cpp.html"},{"title":"SELF_MappedData.cpp – SELF","text":"Contents Source Code SELF_MappedData.cpp Source Code #include \"SELF_GPU_Macros.h\" // JacobianWeight functions // The functions take in an array of data and divide by the jacobian. __global__ void JacobianWeight ( real * f , real * jacobian , int ndof ){ uint32_t ivar = blockIdx . y ; uint32_t idof = threadIdx . x + blockIdx . x * blockDim . x ; if ( idof < ndof ){ f [ idof + ndof * ivar ] = f [ idof + ndof * ivar ] / jacobian [ idof ]; } } extern \"C\" { void JacobianWeight_1D_gpu ( real * f , real * jacobian , int N , int nVar , int nEl ) { int ndof = ( N + 1 ) * ( nEl ); int threads_per_block = 256 ; int nblocksx = ndof / threads_per_block + 1 ; JacobianWeight <<< dim3 ( nblocksx , nVar , 1 ), dim3 ( threads_per_block , 1 , 1 ), 0 , 0 >>> ( f , jacobian , ndof ); } } extern \"C\" { void JacobianWeight_2D_gpu ( real * f , real * jacobian , int N , int nVar , int nEl ) { int ndof = ( N + 1 ) * ( N + 1 ) * ( nEl ); int threads_per_block = 256 ; int nblocksx = ndof / threads_per_block + 1 ; JacobianWeight <<< dim3 ( nblocksx , nVar , 1 ), dim3 ( threads_per_block , 1 , 1 ), 0 , 0 >>> ( f , jacobian , ndof ); } } extern \"C\" { void JacobianWeight_3D_gpu ( real * f , real * jacobian , int N , int nVar , int nEl ) { int ndof = ( N + 1 ) * ( N + 1 ) * ( N + 1 ) * ( nEl ); int threads_per_block = 256 ; int nblocksx = ndof / threads_per_block + 1 ; JacobianWeight <<< dim3 ( nblocksx , nVar , 1 ), dim3 ( threads_per_block , 1 , 1 ), 0 , 0 >>> ( f , jacobian , ndof ); } } __global__ void DGDerivative_BoundaryContribution_1D ( real * bMatrix , real * qWeight , real * bf , real * df , int N , int nEl ){ uint32_t ivar = blockIdx . y ; uint32_t idof = threadIdx . x + blockIdx . x * blockDim . x ; uint32_t ndof = ( N + 1 ) * nEl ; if ( idof < ndof ){ uint32_t iel = idof / ( N + 1 ); // Calculate the element ID uint32_t i = idof - iel * ( N + 1 ); // Calculate the quadrature point node id df [ idof + ndof * ivar ] += ( bMatrix [ i + ( N + 1 )] * bf [ SCB_1D_INDEX ( 1 , iel , ivar , nEl )] + bMatrix [ i ] * bf [ SCB_1D_INDEX ( 0 , iel , ivar , nEl )]) / qWeight [ i ]; } } extern \"C\" { void DGDerivative_BoundaryContribution_1D_gpu ( real * bMatrix , real * qWeight , real * bf , real * df , int N , int nVar , int nEl ) { int ndof = ( N + 1 ) * nEl ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; DGDerivative_BoundaryContribution_1D <<< dim3 ( nblocks_x , nVar , 1 ), dim3 ( threads_per_block , 1 , 1 ), 0 , 0 >>> ( bMatrix , qWeight , bf , df , N , nEl ); } } __global__ void SideExchange_2D ( real * extBoundary , real * boundary , int * sideInfo , int * elemToRank , int rankId , int offset , int N , int nEl ){ uint32_t idof = threadIdx . x + blockIdx . x * blockDim . x ; uint32_t ndof = ( N + 1 ) * nEl * 4 ; uint32_t i1 = idof % ( N + 1 ); uint32_t s1 = ( idof / ( N + 1 )) % 4 ; uint32_t e1 = idof / ( N + 1 ) / 4 ; uint32_t ivar = blockIdx . y ; if ( idof < ndof ){ int e2Global = sideInfo [ INDEX3 ( 2 , s1 , e1 , 5 , 4 )]; int e2 = e2Global - offset ; int s2 = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] - s2 * 10 ; if ( e2Global != 0 ){ int neighborRank = elemToRank [ e2Global -1 ]; if ( neighborRank == rankId ){ if ( flip == 0 ){ extBoundary [ idof + ndof * ivar ] = boundary [ SCB_2D_INDEX ( i1 , s2 -1 , e2 -1 , ivar , N , nEl )]; } else if ( flip == 1 ){ int i2 = N - i1 ; extBoundary [ idof + ndof * ivar ] = boundary [ SCB_2D_INDEX ( i2 , s2 -1 , e2 -1 , ivar , N , nEl )]; } } } } } extern \"C\" { void SideExchange_2D_gpu ( real * extBoundary , real * boundary , int * sideInfo , int * elemToRank , int rankId , int offset , int N , int nVar , int nEl ) { int ndof = ( N + 1 ) * 4 * nEl ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nVar , 1 ); dim3 nthreads ( threads_per_block , 1 , 1 ); SideExchange_2D <<< nblocks , nthreads >>> ( extBoundary , boundary , sideInfo , elemToRank , rankId , offset , N , nEl ); } } __global__ void ApplyFlip_2D ( real * extBoundary , int * sideInfo , int * elemToRank , int rankId , int offset , int N , int nVar , int nEl ){ uint32_t idof = threadIdx . x + blockIdx . x * blockDim . x ; uint32_t ndof = nVar * nEl * 4 ; uint32_t s1 = ( idof ) % 4 ; uint32_t e1 = ( idof / 4 ) % nEl ; uint32_t ivar = idof / 4 / nEl ; if ( idof < ndof ){ int e2Global = sideInfo [ INDEX3 ( 2 , s1 , e1 , 5 , 4 )]; int e2 = e2Global - offset ; int s2 = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] - s2 * 10 ; real buff [ 24 ]; // warning : set fixed buffer size for applying flip. This limits the polynomial degree to 23 if ( e2Global != 0 ){ int neighborRank = elemToRank [ e2Global -1 ]; if ( neighborRank != rankId ){ if ( flip == 1 ){ for ( int i1 = 0 ; i1 < N + 1 ; i1 ++ ){ int i2 = N - i1 ; buff [ i1 ] = extBoundary [ SCB_2D_INDEX ( i2 , s1 , e1 , ivar , N , nEl )]; } for ( int i1 = 0 ; i1 < N + 1 ; i1 ++ ){ extBoundary [ SCB_2D_INDEX ( i1 , s1 , e1 , ivar , N , nEl )] = buff [ i1 ]; } } } } } } extern \"C\" { void ApplyFlip_2D_gpu ( real * extBoundary , int * sideInfo , int * elemToRank , int rankId , int offset , int N , int nVar , int nEl ) { int ndof = 4 * nEl * nVar ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , 1 , 1 ); dim3 nthreads ( threads_per_block , 1 , 1 ); ApplyFlip_2D <<< nblocks , nthreads >>> ( extBoundary , sideInfo , elemToRank , rankId , offset , N , nVar , nEl ); } } __global__ void SideExchange_3D ( real * extBoundary , real * boundary , int * sideInfo , int * elemToRank , int rankId , int offset , int N , int nEl ){ uint32_t idof = threadIdx . x + blockIdx . x * blockDim . x ; uint32_t ndof = ( N + 1 ) * ( N + 1 ) * nEl * 6 ; if ( idof < ndof ){ uint32_t s1 = ( idof / ( N + 1 ) / ( N + 1 )) % 6 ; uint32_t e1 = idof / ( N + 1 ) / ( N + 1 ) / 6 ; int e2Global = sideInfo [ INDEX3 ( 2 , s1 , e1 , 5 , 6 )]; if ( e2Global != 0 ){ int neighborRank = elemToRank [ e2Global -1 ]; if ( neighborRank == rankId ){ uint32_t i1 = idof % ( N + 1 ); uint32_t j1 = ( idof / ( N + 1 )) % ( N + 1 ); int e2 = e2Global - offset ; int s2 = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 6 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 6 )] - s2 * 10 ; uint32_t ivar = blockIdx . y ; if ( flip == 0 ){ extBoundary [ idof + ndof * ivar ] = boundary [ SCB_3D_INDEX ( i1 , j1 , s2 -1 , e2 -1 , ivar , N , nEl )]; } else if ( flip == 1 ){ int i2 = N - i1 ; int j2 = j1 ; extBoundary [ idof + ndof * ivar ] = boundary [ SCB_3D_INDEX ( i2 , j2 , s2 -1 , e2 -1 , ivar , N , nEl )]; } else if ( flip == 2 ){ int i2 = N - i1 ; int j2 = N - j1 ; extBoundary [ idof + ndof * ivar ] = boundary [ SCB_3D_INDEX ( i2 , j2 , s2 -1 , e2 -1 , ivar , N , nEl )]; } else if ( flip == 3 ){ int i2 = i1 ; int j2 = N - j1 ; extBoundary [ idof + ndof * ivar ] = boundary [ SCB_3D_INDEX ( i2 , j2 , s2 -1 , e2 -1 , ivar , N , nEl )]; } else if ( flip == 4 ){ int i2 = j1 ; int j2 = i1 ; extBoundary [ idof + ndof * ivar ] = boundary [ SCB_3D_INDEX ( i2 , j2 , s2 -1 , e2 -1 , ivar , N , nEl )]; } else if ( flip == 5 ){ int i2 = N - j1 ; int j2 = i1 ; extBoundary [ idof + ndof * ivar ] = boundary [ SCB_3D_INDEX ( i2 , j2 , s2 -1 , e2 -1 , ivar , N , nEl )]; } else if ( flip == 6 ){ int i2 = N - j1 ; int j2 = N - i1 ; extBoundary [ idof + ndof * ivar ] = boundary [ SCB_3D_INDEX ( i2 , j2 , s2 -1 , e2 -1 , ivar , N , nEl )]; } else if ( flip == 7 ){ int i2 = j1 ; int j2 = N - i1 ; extBoundary [ idof + ndof * ivar ] = boundary [ SCB_3D_INDEX ( i2 , j2 , s2 -1 , e2 -1 , ivar , N , nEl )]; } } } } } extern \"C\" { void SideExchange_3D_gpu ( real * extBoundary , real * boundary , int * sideInfo , int * elemToRank , int rankId , int offset , int N , int nVar , int nEl ) { int ndof = ( N + 1 ) * ( N + 1 ) * 6 * nEl ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nVar , 1 ); dim3 nthreads ( threads_per_block , 1 , 1 ); SideExchange_3D <<< nblocks , nthreads >>> ( extBoundary , boundary , sideInfo , elemToRank , rankId , offset , N , nEl ); } } __global__ void ApplyFlip_3D ( real * extBoundary , int * sideInfo , int * elemToRank , int rankId , int offset , int N , int nVar , int nEl ){ uint32_t s1 = blockIdx . x ; uint32_t e1 = blockIdx . y ; uint32_t ivar = blockIdx . z ; uint32_t i = threadIdx . x ; uint32_t j = threadIdx . y ; __shared__ real extBuff [ 256 ]; extBuff [ i + ( N + 1 ) * j ] = extBoundary [ SCB_3D_INDEX ( i , j , s1 , e1 , ivar , N , nEl )]; __syncthreads (); int e2Global = sideInfo [ INDEX3 ( 2 , s1 , e1 , 5 , 4 )]; int e2 = e2Global - offset ; int s2 = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] - s2 * 10 ; if ( e2Global != 0 ){ int neighborRank = elemToRank [ e2Global -1 ]; if ( neighborRank != rankId ){ if ( flip == 1 ){ int i2 = N - i ; int j2 = j ; extBoundary [ SCB_3D_INDEX ( i , j , s1 , e1 , ivar , N , nEl )] = extBuff [ i2 + ( N + 1 ) * j2 ]; } else if ( flip == 2 ){ int i2 = N - i ; int j2 = N - j ; extBoundary [ SCB_3D_INDEX ( i , j , s1 , e1 , ivar , N , nEl )] = extBuff [ i2 + ( N + 1 ) * j2 ]; } else if ( flip == 3 ){ int i2 = i ; int j2 = N - j ; extBoundary [ SCB_3D_INDEX ( i , j , s1 , e1 , ivar , N , nEl )] = extBuff [ i2 + ( N + 1 ) * j2 ]; } else if ( flip == 4 ){ int i2 = j ; int j2 = i ; extBoundary [ SCB_3D_INDEX ( i , j , s1 , e1 , ivar , N , nEl )] = extBuff [ i2 + ( N + 1 ) * j2 ]; } else if ( flip == 5 ){ int i2 = N - j ; int j2 = i ; extBoundary [ SCB_3D_INDEX ( i , j , s1 , e1 , ivar , N , nEl )] = extBuff [ i2 + ( N + 1 ) * j2 ]; } else if ( flip == 6 ){ int i2 = N - j ; int j2 = N - i ; extBoundary [ SCB_3D_INDEX ( i , j , s1 , e1 , ivar , N , nEl )] = extBuff [ i2 + ( N + 1 ) * j2 ]; } else if ( flip == 7 ){ int i2 = j ; int j2 = N - i ; extBoundary [ SCB_3D_INDEX ( i , j , s1 , e1 , ivar , N , nEl )] = extBuff [ i2 + ( N + 1 ) * j2 ]; } } } } extern \"C\" { void ApplyFlip_3D_gpu ( real * extBoundary , int * sideInfo , int * elemToRank , int rankId , int offset , int N , int nVar , int nEl ) { dim3 nblocks ( 6 , nEl , nVar ); dim3 nthreads ( N + 1 , N + 1 , 1 ); ApplyFlip_3D <<< nblocks , nthreads >>> ( extBoundary , sideInfo , elemToRank , rankId , offset , N , nVar , nEl ); } } __global__ void ContravariantWeight_gpukernel ( real * scalar , real * dsdx , real * tensor , int ndof ){ uint32_t ivar = blockIdx . y ; // variable dimension uint32_t nvar = gridDim . y ; // number of variables uint32_t tdim = blockIdx . z ; // tensor dimension (flattened index for the rows and columns of the tensor) uint32_t i = threadIdx . x + blockIdx . x * blockDim . x ; if ( i < ndof ){ tensor [ i + ndof * ( ivar + nvar * tdim )] = dsdx [ i + ndof * tdim ] * scalar [ i + ndof * ivar ]; } } extern \"C\" { void ContravariantWeight_2D_gpu ( real * scalar , real * dsdx , real * tensor , int N , int nvar , int nel ) { int ndof = ( N + 1 ) * ( N + 1 ) * nel ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nvar , 4 ); dim3 nthreads ( threads_per_block , 1 , 1 ); ContravariantWeight_gpukernel <<< nblocks , nthreads , 0 , 0 >>> ( scalar , dsdx , tensor , ndof ); } } extern \"C\" { void ContravariantWeight_3D_gpu ( real * scalar , real * dsdx , real * tensor , int N , int nvar , int nel ) { int ndof = ( N + 1 ) * ( N + 1 ) * ( N + 1 ) * nel ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nvar , 9 ); dim3 nthreads ( threads_per_block , 1 , 1 ); ContravariantWeight_gpukernel <<< nblocks , nthreads , 0 , 0 >>> ( scalar , dsdx , tensor , ndof ); } } __global__ void NormalWeight_2D_gpukernel ( real * fb , real * nhat , real * nscale , real * fbn , int N , int nvar , int nel ){ uint32_t i = threadIdx . x + blockIdx . x * blockDim . x ; uint32_t ndof = ( N + 1 ) * 4 * nel ; if ( i < ndof ){ uint32_t ivar = blockIdx . y ; real f = fb [ i + ndof * ivar ]; real nmag = nscale [ i ]; fbn [ i + ndof * ivar ] = f * nhat [ i ] * nmag ; // x-direction fbn [ i + ndof * ( ivar + nvar )] = f * nhat [ i + ndof ] * nmag ; // y-direction } } extern \"C\" { void NormalWeight_2D_gpu ( real * fb , real * nhat , real * nscale , real * fbn , int N , int nvar , int nel ) { int ndof = ( N + 1 ) * 4 * nel ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nvar , 1 ); dim3 nthreads ( threads_per_block , 1 , 1 ); NormalWeight_2D_gpukernel <<< nblocks , nthreads , 0 , 0 >>> ( fb , nhat , nscale , fbn , N , nvar , nel ); } } __global__ void NormalWeight_3D_gpukernel ( real * fb , real * nhat , real * nscale , real * fbn , int N , int nvar , int nel ){ uint32_t i = threadIdx . x + blockIdx . x * blockDim . x ; uint32_t ndof = ( N + 1 ) * ( N + 1 ) * 6 * nel ; if ( i < ndof ){ uint32_t ivar = blockIdx . y ; real f = fb [ i + ndof * ivar ]; real nmag = nscale [ i ]; fbn [ i + ndof * ivar ] = f * nhat [ i ] * nmag ; // x-direction fbn [ i + ndof * ( ivar + nvar )] = f * nhat [ i + ndof ] * nmag ; // y-direction fbn [ i + ndof * ( ivar + 2 * nvar )] = f * nhat [ i + 2 * ndof ] * nmag ; // z-direction } } extern \"C\" { void NormalWeight_3D_gpu ( real * fb , real * nhat , real * nscale , real * fbn , int N , int nvar , int nel ) { int ndof = ( N + 1 ) * ( N + 1 ) * 6 * nel ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nvar , 1 ); dim3 nthreads ( threads_per_block , 1 , 1 ); NormalWeight_3D_gpukernel <<< nblocks , nthreads , 0 , 0 >>> ( fb , nhat , nscale , fbn , N , nvar , nel ); } } __global__ void DG_BoundaryContribution_2D_gpukernel ( real * bMatrix , real * qWeights , real * bf , real * df , int N , int nel ){ uint32_t idof = threadIdx . x + blockIdx . x * blockDim . x ; uint32_t ivar = blockIdx . y ; uint32_t ndof = nel * ( N + 1 ) * ( N + 1 ); if ( idof < ndof ){ uint32_t i = idof % ( N + 1 ); uint32_t j = ( idof / ( N + 1 )) % ( N + 1 ); uint32_t iel = ( idof / ( N + 1 ) / ( N + 1 )); df [ SC_2D_INDEX ( i , j , iel , ivar , N , nel )] += ( bf [ SCB_2D_INDEX ( j , 1 , iel , ivar , N , nel )] * bMatrix [ i + ( N + 1 )] + // east bf [ SCB_2D_INDEX ( j , 3 , iel , ivar , N , nel )] * bMatrix [ i ]) / // west qWeights [ i ] + ( bf [ SCB_2D_INDEX ( i , 2 , iel , ivar , N , nel )] * bMatrix [ j + ( N + 1 )] + // north bf [ SCB_2D_INDEX ( i , 0 , iel , ivar , N , nel )] * bMatrix [ j ]) / // south qWeights [ j ]; } } extern \"C\" { void DG_BoundaryContribution_2D_gpu ( real * bMatrix , real * qWeights , real * bf , real * df , int N , int nVar , int nEl ) { int ndof = ( N + 1 ) * ( N + 1 ) * nEl ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nVar , 1 ); dim3 nthreads ( threads_per_block , 1 , 1 ); DG_BoundaryContribution_2D_gpukernel <<< nblocks , nthreads , 0 , 0 >>> ( bMatrix , qWeights , bf , df , N , nEl ); } } __global__ void DG_BoundaryContribution_3D_gpukernel ( real * bMatrix , real * qWeights , real * bf , real * df , int N , int nel ){ uint32_t idof = threadIdx . x + blockIdx . x * blockDim . x ; uint32_t ndof = nel * ( N + 1 ) * ( N + 1 ) * ( N + 1 ); if ( idof < ndof ){ uint32_t i = idof % ( N + 1 ); uint32_t j = ( idof / ( N + 1 )) % ( N + 1 ); uint32_t k = ( idof / ( N + 1 ) / ( N + 1 )) % ( N + 1 ); uint32_t iel = ( idof / ( N + 1 ) / ( N + 1 ) / ( N + 1 )); uint32_t ivar = blockIdx . y ; df [ SC_3D_INDEX ( i , j , k , iel , ivar , N , nel )] += ( bf [ SCB_3D_INDEX ( i , j , 5 , iel , ivar , N , nel )] * bMatrix [ k + ( N + 1 )] + // top bf [ SCB_3D_INDEX ( i , j , 0 , iel , ivar , N , nel )] * bMatrix [ k ]) / // bottom qWeights [ k ] + ( bf [ SCB_3D_INDEX ( j , k , 2 , iel , ivar , N , nel )] * bMatrix [ i + ( N + 1 )] + // east bf [ SCB_3D_INDEX ( j , k , 4 , iel , ivar , N , nel )] * bMatrix [ i ]) / // west qWeights [ i ] + ( bf [ SCB_3D_INDEX ( i , k , 3 , iel , ivar , N , nel )] * bMatrix [ j + ( N + 1 )] + // north bf [ SCB_3D_INDEX ( i , k , 1 , iel , ivar , N , nel )] * bMatrix [ j ]) / // south qWeights [ j ]; } } extern \"C\" { void DG_BoundaryContribution_3D_gpu ( real * bMatrix , real * qWeights , real * bf , real * df , int N , int nVar , int nEl ) { int ndof = ( N + 1 ) * ( N + 1 ) * ( N + 1 ) * nEl ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nVar , 1 ); dim3 nthreads ( threads_per_block , 1 , 1 ); DG_BoundaryContribution_3D_gpukernel <<< nblocks , nthreads , 0 , 0 >>> ( bMatrix , qWeights , bf , df , N , nEl ); } } __global__ void ContravariantProjection_2D_gpukernel ( real * vector , real * dsdx , int N , int ndof ){ uint32_t i = threadIdx . x + blockIdx . x * blockDim . x ; if ( i < ndof ){ uint32_t ivar = blockIdx . y ; uint32_t nvar = blockDim . y ; real Fx = vector [ i + ndof * ivar ]; real Fy = vector [ i + ndof * ( ivar + nvar )]; vector [ i + ndof * ivar ] = dsdx [ i ] * Fx + dsdx [ i + ndof ] * Fy ; vector [ i + ndof * ( ivar + nvar )] = dsdx [ i + 2 * ndof ] * Fx + dsdx [ i + 3 * ndof ] * Fy ; } } extern \"C\" { void ContravariantProjection_2D_gpu ( real * vector , real * dsdx , int N , int nVar , int nEl ) { int ndof = ( N + 1 ) * ( N + 1 ) * nEl ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nVar , 1 ); dim3 nthreads ( threads_per_block , 1 , 1 ); ContravariantProjection_2D_gpukernel <<< nblocks , nthreads , 0 , 0 >>> ( vector , dsdx , N , ndof ); } } __global__ void ContravariantProjection_3D_gpukernel ( real * vector , real * dsdx , int N , int ndof ){ uint32_t i = threadIdx . x + blockIdx . x * blockDim . x ; if ( i < ndof ){ uint32_t ivar = blockIdx . y ; uint32_t nvar = blockDim . y ; real Fx = vector [ i + ndof * ivar ]; real Fy = vector [ i + ndof * ( ivar + nvar )]; real Fz = vector [ i + ndof * ( ivar + 2 * nvar )]; vector [ i + ndof * ivar ] = dsdx [ i ] * Fx + dsdx [ i + ndof ] * Fy + dsdx [ i + 2 * ndof ] * Fz ; vector [ i + ndof * ( ivar + nvar )] = dsdx [ i + 3 * ndof ] * Fx + dsdx [ i + 4 * ndof ] * Fy + + dsdx [ i + 5 * ndof ] * Fz ; vector [ i + ndof * ( ivar + 2 * nvar )] = dsdx [ i + 6 * ndof ] * Fx + dsdx [ i + 7 * ndof ] * Fy + + dsdx [ i + 8 * ndof ] * Fz ; } } extern \"C\" { void ContravariantProjection_3D_gpu ( real * vector , real * dsdx , int N , int nVar , int nEl ) { int ndof = ( N + 1 ) * ( N + 1 ) * ( N + 1 ) * nEl ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nVar , 1 ); dim3 nthreads ( threads_per_block , 1 , 1 ); ContravariantProjection_3D_gpukernel <<< nblocks , nthreads , 0 , 0 >>> ( vector , dsdx , N , ndof ); } }","tags":"","loc":"sourcefile/self_mappeddata.cpp.html"},{"title":"SELF_Data.cpp – SELF","text":"Contents Source Code SELF_Data.cpp Source Code #include \"SELF_GPU_Macros.h\" __global__ void Average ( real * avgf , real * f1 , real * f2 , int ndof ){ uint32_t i = threadIdx . x + blockIdx . x * blockDim . x ; if ( i < ndof ){ avgf [ i ] = 0.5 * ( f1 [ i ] + f2 [ i ]); } } extern \"C\" { void Average_gpu ( real * f , real * f1 , real * f2 , int ndof ) { int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , 1 , 1 ); dim3 nthreads ( threads_per_block , 1 , 1 ); Average <<< nblocks , nthreads , 0 , 0 >>> ( f , f1 , f2 , ndof ); } } __global__ void BoundaryInterp_2D_gpukernel ( real * bMatrix , real * f , real * fBound , int N , int nEl ){ int iq = threadIdx . x + blockIdx . x * blockDim . x ; int i = iq % ( N + 1 ); int iEl = ( iq / ( N + 1 )) % ( nEl ); int iVar = iq / ( N + 1 ) / ( nEl ); real fbl = 0.0 ; real fbr = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fbl += f [ SC_2D_INDEX ( i , ii , iEl , iVar , N , nEl )] * bMatrix [ ii ]; // South fbr += f [ SC_2D_INDEX ( i , ii , iEl , iVar , N , nEl )] * bMatrix [ ii + ( N + 1 )]; // North } fBound [ SCB_2D_INDEX ( i , 0 , iEl , iVar , N , nEl )] = fbl ; // South fBound [ SCB_2D_INDEX ( i , 2 , iEl , iVar , N , nEl )] = fbr ; // North fbl = 0.0 ; fbr = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fbl += f [ SC_2D_INDEX ( ii , i , iEl , iVar , N , nEl )] * bMatrix [ ii ]; // West fbr += f [ SC_2D_INDEX ( ii , i , iEl , iVar , N , nEl )] * bMatrix [ ii + ( N + 1 )]; // East } fBound [ SCB_2D_INDEX ( i , 3 , iEl , iVar , N , nEl )] = fbl ; // West fBound [ SCB_2D_INDEX ( i , 1 , iEl , iVar , N , nEl )] = fbr ; // East } extern \"C\" { void BoundaryInterp_2D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar , int nEl ) { int ndof = ( N + 1 ) * nEl * nVar ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; BoundaryInterp_2D_gpukernel <<< dim3 ( nblocks_x , 1 , 1 ), dim3 ( threads_per_block , 1 , 1 ), 0 , 0 >>> ( bMatrix , f , fBound , N , nEl ); } } __global__ void BoundaryInterp_3D_gpukernel ( real * bMatrix , real * f , real * fBound , int N , int nEl ){ int iq = threadIdx . x + blockIdx . x * blockDim . x ; int i = iq % ( N + 1 ); int j = ( iq / ( N + 1 )) % ( N + 1 ); int iEl = ( iq / ( N + 1 ) / ( N + 1 )) % ( nEl ); int iVar = iq / ( N + 1 ) / ( N + 1 ) / ( nEl ); real fb [ 6 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fb [ 0 ] += f [ SC_3D_INDEX ( i , j , ii , iEl , iVar , N , nEl )] * bMatrix [ ii ]; // Bottom fb [ 1 ] += f [ SC_3D_INDEX ( i , ii , j , iEl , iVar , N , nEl )] * bMatrix [ ii ]; // South fb [ 2 ] += f [ SC_3D_INDEX ( ii , i , j , iEl , iVar , N , nEl )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 3 ] += f [ SC_3D_INDEX ( i , ii , j , iEl , iVar , N , nEl )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 4 ] += f [ SC_3D_INDEX ( ii , i , j , iEl , iVar , N , nEl )] * bMatrix [ ii ]; // West fb [ 5 ] += f [ SC_3D_INDEX ( i , j , ii , iEl , iVar , N , nEl )] * bMatrix [ ii + ( N + 1 )]; // Top } fBound [ SCB_3D_INDEX ( i , j , 0 , iEl , iVar , N , nEl )] = fb [ 0 ]; fBound [ SCB_3D_INDEX ( i , j , 1 , iEl , iVar , N , nEl )] = fb [ 1 ]; fBound [ SCB_3D_INDEX ( i , j , 2 , iEl , iVar , N , nEl )] = fb [ 2 ]; fBound [ SCB_3D_INDEX ( i , j , 3 , iEl , iVar , N , nEl )] = fb [ 3 ]; fBound [ SCB_3D_INDEX ( i , j , 4 , iEl , iVar , N , nEl )] = fb [ 4 ]; fBound [ SCB_3D_INDEX ( i , j , 5 , iEl , iVar , N , nEl )] = fb [ 5 ]; } extern \"C\" { void BoundaryInterp_3D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar , int nEl ) { int ndof = ( N + 1 ) * ( N + 1 ) * nEl * nVar ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; BoundaryInterp_3D_gpukernel <<< dim3 ( nblocks_x , 1 , 1 ), dim3 ( threads_per_block , 1 , 1 ), 0 , 0 >>> ( bMatrix , f , fBound , N , nEl ); } }","tags":"","loc":"sourcefile/self_data.cpp.html"},{"title":"SELF_Model.cpp – SELF","text":"Contents Source Code SELF_Model.cpp Source Code #include \"SELF_GPU_Macros.h\" __global__ void UpdateSolution_Model ( real * solution , real * dSdt , real dt , uint32_t ndof ){ size_t i = threadIdx . x + blockIdx . x * blockDim . x ; if ( i < ndof ){ solution [ i ] += dt * dSdt [ i ]; } } __global__ void UpdateGAB2_Model ( real * prevsol , real * solution , int m , uint32_t ndof ){ size_t i = threadIdx . x + blockIdx . x * blockDim . x ; if ( i < ndof ){ if ( m == 0 ){ prevsol [ i ] = solution [ i ]; } else if ( m == 1 ) { solution [ i ] = prevsol [ i ]; } else if ( m == 2 ) { prevsol [ i + ndof ] = prevsol [ i ]; prevsol [ i ] = solution [ i ]; solution [ i ] = 1.5 * prevsol [ i ] -0.5 * prevsol [ i + ndof ]; } } } __global__ void UpdateGAB3_Model ( real * prevsol , real * solution , int m , uint32_t ndof ){ size_t i = threadIdx . x + blockIdx . x * blockDim . x ; if ( i < ndof ){ if ( m == 0 ){ prevsol [ i + ndof ] = solution [ i ]; } else if ( m == 1 ){ prevsol [ i ] = solution [ i ]; } else if ( m == 2 ) { solution [ i ] = prevsol [ i ]; } else { prevsol [ i + 2 * ndof ] = prevsol [ i + ndof ]; prevsol [ i + ndof ] = prevsol [ i ]; solution [ i ] = ( 23.0 * prevsol [ i ] -16.0 * prevsol [ i + ndof ] + 5.0 * prevsol [ i + 2 * ndof ]) / 12.0 ; } } } __global__ void UpdateGAB4_Model ( real * prevsol , real * solution , int m , uint32_t ndof ){ size_t i = threadIdx . x + blockIdx . x * blockDim . x ; if ( i < ndof ){ if ( m == 0 ){ prevsol [ i + 2 * ndof ] = solution [ i ]; } else if ( m == 1 ){ prevsol [ i + ndof ] = solution [ i ]; } else if ( m == 2 ){ prevsol [ i ] = solution [ i ]; } else if ( m == 3 ) { solution [ i ] = prevsol [ i ]; } else { prevsol [ i + 3 * ndof ] = prevsol [ i + 2 * ndof ]; prevsol [ i + 2 * ndof ] = prevsol [ i + ndof ]; prevsol [ i + ndof ] = prevsol [ i ]; solution [ i ] = ( 55.0 * prevsol [ i ] -59.0 * prevsol [ i + ndof ] + 37.0 * prevsol [ i + 2 * ndof ] -9.0 * prevsol [ i + 3 * ndof ]) / 24.0 ; } } } __global__ void UpdateGRK_Model ( real * grk , real * solution , real * dSdt , real rk_a , real rk_g , real dt , uint32_t ndof ){ size_t i = threadIdx . x + blockIdx . x * blockDim . x ; if ( i < ndof ){ grk [ i ] = rk_a * grk [ i ] + dSdt [ i ]; solution [ i ] += rk_g * dt * grk [ i ]; } } __global__ void CalculateDSDt_Model ( real * fluxDivergence , real * source , real * dSdt , uint32_t ndof ){ size_t i = threadIdx . x + blockIdx . x * blockDim . x ; if ( i < ndof ){ dSdt [ i ] = source [ i ] - fluxDivergence [ i ]; } } extern \"C\" { void UpdateSolution_gpu ( real * solution , real * dSdt , real dt , int ndof ) { uint32_t nthreads = 256 ; uint32_t nblocks_x = ndof / nthreads + 1 ; UpdateSolution_Model <<< dim3 ( nblocks_x , 1 ), dim3 ( nthreads , 1 , 1 ), 0 , 0 >>> ( solution , dSdt , dt , ndof ); } } extern \"C\" { void UpdateGRK_gpu ( real * grk , real * solution , real * dSdt , real rk_a , real rk_g , real dt , int ndof ) { uint32_t nthreads = 256 ; uint32_t nblocks_x = ndof / nthreads + 1 ; UpdateGRK_Model <<< dim3 ( nblocks_x , 1 ), dim3 ( nthreads , 1 , 1 ), 0 , 0 >>> ( grk , solution , dSdt , rk_a , rk_g , dt , ndof ); } } extern \"C\" { void CalculateDSDt_gpu ( real * fluxDivergence , real * source , real * dSdt , int ndof ) { uint32_t nthreads = 256 ; uint32_t nblocks_x = ndof / nthreads + 1 ; CalculateDSDt_Model <<< dim3 ( nblocks_x , 1 ), dim3 ( nthreads , 1 , 1 ), 0 , 0 >>> ( fluxDivergence , source , dSdt , ndof ); } } __global__ void GradientNormal_1d_gpukernel ( real * fbn , real * fbavg , int ndof ){ uint32_t i = threadIdx . x + blockIdx . x * blockDim . x ; // when i is even, we are looking at the left side of the element and the boundary normal is negative // when i is odd, we are looking at the right side of the element and boundary normal is positive // //   i%2 is 0 when i is even //          1 when i is odd // //   2*(i%2) is 0 when i is even //              2 when i is odd // //   2*(i%2)-1 is -1 when i is even //                 1 when i is odd real nhat = 2.0 * ( i % 2 ) -1.0 ; if ( i < ndof ){ fbn [ i ] = nhat * fbavg [ i ]; } } extern \"C\" { void GradientNormal_1d_gpu ( real * fbn , real * fbavg , int ndof ){ int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; GradientNormal_1d_gpukernel <<< dim3 ( nblocks_x , 1 , 1 ), dim3 ( threads_per_block , 1 , 1 ), 0 , 0 >>> ( fbn , fbavg , ndof ); } }","tags":"","loc":"sourcefile/self_model.cpp.html"},{"title":"SELF_advection_diffusion_1d.cpp – SELF","text":"Contents Source Code SELF_advection_diffusion_1d.cpp Source Code #include \"SELF_GPU_Macros.h\" __global__ void setboundarycondition_advection_diffusion_1d_gpukernel ( real * extBoundary , real * boundary , int nel , int nvar ){ uint32_t ivar = threadIdx . x + blockIdx . x * blockDim . x ; if ( ivar < nvar ){ extBoundary [ SCB_1D_INDEX ( 0 , 0 , ivar , nel )] = boundary [ SCB_1D_INDEX ( 1 , nel -1 , ivar , nel )]; extBoundary [ SCB_1D_INDEX ( 1 , nel -1 , ivar , nel )] = boundary [ SCB_1D_INDEX ( 0 , 0 , ivar , nel )]; } } extern \"C\" { void setboundarycondition_advection_diffusion_1d_gpu ( real * extBoundary , real * boundary , int nel , int nvar ){ int threads_per_block = 64 ; int nblocks_x = nvar / threads_per_block + 1 ; setboundarycondition_advection_diffusion_1d_gpukernel <<< dim3 ( nblocks_x , 1 , 1 ), dim3 ( threads_per_block , 1 , 1 ), 0 , 0 >>> ( extBoundary , boundary , nel , nvar ); } } __global__ void fluxmethod_advection_diffusion_1d_gpukernel ( real * solution , real * solutiongradient , real * flux , real u , real nu , int ndof ){ uint32_t i = threadIdx . x + blockIdx . x * blockDim . x ; if ( i < ndof ){ flux [ i ] = u * solution [ i ] - nu * solutiongradient [ i ]; } } extern \"C\" { void fluxmethod_advection_diffusion_1d_gpu ( real * solution , real * solutiongradient , real * flux , real u , real nu , int ndof ){ int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; fluxmethod_advection_diffusion_1d_gpukernel <<< dim3 ( nblocks_x , 1 , 1 ), dim3 ( threads_per_block , 1 , 1 ), 0 , 0 >>> ( solution , solutiongradient , flux , u , nu , ndof ); } } __global__ void boundaryflux_advection_diffusion_1d_gpukernel ( real * fb , real * fextb , real * dfavg , real * flux , real u , real nu , int ndof ){ uint32_t i = threadIdx . x + blockIdx . x * blockDim . x ; // when i is even, we are looking at the left side of the element and the boundary normal is negative // when i is odd, we are looking at the right side of the element and boundary normal is positive // //   i%2 is 0 when i is even //          1 when i is odd // //   2*(i%2) is 0 when i is even //              2 when i is odd // //   2*(i%2)-1 is -1 when i is even //                 1 when i is odd real nhat = 2.0 * ( i % 2 ) -1.0 ; if ( i < ndof ){ flux [ i ] = 0.5 * ( u * nhat * ( fb [ i ] + fextb [ i ]) + fabsf ( u * nhat ) * ( fb [ i ] - fextb [ i ])) - nu * dfavg [ i ] * nhat ; } } extern \"C\" { void boundaryflux_advection_diffusion_1d_gpu ( real * fb , real * fextb , real * dfavg , real * flux , real u , real nu , int ndof ){ int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; boundaryflux_advection_diffusion_1d_gpukernel <<< dim3 ( nblocks_x , 1 , 1 ), dim3 ( threads_per_block , 1 , 1 ), 0 , 0 >>> ( fb , fextb , dfavg , flux , u , nu , ndof ); } }","tags":"","loc":"sourcefile/self_advection_diffusion_1d.cpp.html"},{"title":"SELF_advection_diffusion_2d.cpp – SELF","text":"Contents Source Code SELF_advection_diffusion_2d.cpp Source Code #include \"SELF_GPU_Macros.h\" __global__ void setboundarycondition_advection_diffusion_2d_gpukernel ( real * extBoundary , real * boundary , int * sideInfo , int N , int nel , int nvar ){ uint32_t idof = threadIdx . x + blockIdx . x * blockDim . x ; uint32_t ndof = ( N + 1 ) * 4 * nel ; if ( idof < ndof ){ uint32_t i = idof % ( N + 1 ); uint32_t s1 = ( idof / ( N + 1 )) % 4 ; uint32_t e1 = idof / ( N + 1 ) / 4 ; uint32_t e2 = sideInfo [ INDEX3 ( 2 , s1 , e1 , 5 , 4 )]; if ( e2 == 0 ){ uint32_t ivar = blockIdx . y ; extBoundary [ SCB_2D_INDEX ( i , s1 , e1 , ivar , N , nel )] = 0.0 ; } } } extern \"C\" { void setboundarycondition_advection_diffusion_2d_gpu ( real * extBoundary , real * boundary , int * sideInfo , int N , int nel , int nvar ){ int threads_per_block = 256 ; int ndof = ( N + 1 ) * 4 * nel ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nvar , 1 ); dim3 nthreads ( threads_per_block , 1 , 1 ); setboundarycondition_advection_diffusion_2d_gpukernel <<< nblocks , nthreads , 0 , 0 >>> ( extBoundary , boundary , sideInfo , N , nel , nvar ); } } __global__ void setgradientboundarycondition_advection_diffusion_2d_gpukernel ( real * extBoundary , real * boundary , int * sideInfo , int N , int nel , int nvar ){ uint32_t idof = threadIdx . x + blockIdx . x * blockDim . x ; uint32_t ndof = ( N + 1 ) * 4 * nel ; if ( idof < ndof ){ uint32_t i = idof % ( N + 1 ); uint32_t s1 = ( idof / ( N + 1 )) % 4 ; uint32_t e1 = idof / ( N + 1 ) / 4 ; uint32_t e2 = sideInfo [ INDEX3 ( 2 , s1 , e1 , 5 , 4 )]; if ( e2 == 0 ){ uint32_t ivar = blockIdx . y ; uint32_t idir = blockIdx . z ; extBoundary [ VEB_2D_INDEX ( i , s1 , e1 , ivar , idir , N , nel , nvar )] = boundary [ VEB_2D_INDEX ( i , s1 , e1 , ivar , idir , N , nel , nvar )]; } } } extern \"C\" { void setgradientboundarycondition_advection_diffusion_2d_gpu ( real * extBoundary , real * boundary , int * sideInfo , int N , int nel , int nvar ){ int threads_per_block = 256 ; int ndof = ( N + 1 ) * 4 * nel ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nvar , 2 ); dim3 nthreads ( threads_per_block , 1 , 1 ); setgradientboundarycondition_advection_diffusion_2d_gpukernel <<< nblocks , nthreads , 0 , 0 >>> ( extBoundary , boundary , sideInfo , N , nel , nvar ); } } __global__ void fluxmethod_advection_diffusion_2d_gpukernel ( real * solution , real * solutiongradient , real * flux , real u , real v , real nu , int ndof ){ uint32_t i = threadIdx . x + blockIdx . x * blockDim . x ; if ( i < ndof ){ flux [ i ] = u * solution [ i ] - nu * solutiongradient [ i ]; flux [ i + ndof ] = v * solution [ i ] - nu * solutiongradient [ i + ndof ]; } } extern \"C\" { void fluxmethod_advection_diffusion_2d_gpu ( real * solution , real * solutiongradient , real * flux , real u , real v , real nu , int N , int nel , int nvar ){ int ndof = ( N + 1 ) * ( N + 1 ) * nel * nvar ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; fluxmethod_advection_diffusion_2d_gpukernel <<< dim3 ( nblocks_x , 1 , 1 ), dim3 ( threads_per_block , 1 , 1 ), 0 , 0 >>> ( solution , solutiongradient , flux , u , v , nu , ndof ); } } __global__ void boundaryflux_advection_diffusion_2d_gpukernel ( real * fb , real * fextb , real * dfavg , real * nhat , real * nscale , real * flux , real u , real v , real nu , int N , int nel , int nvar ){ uint32_t idof = threadIdx . x + blockIdx . x * blockDim . x ; uint32_t ndof = ( N + 1 ) * 4 * nel ; if ( idof < ndof ){ uint32_t i = idof % ( N + 1 ); uint32_t j = ( idof / ( N + 1 )) % 4 ; uint32_t iel = idof / ( N + 1 ) / 4 ; uint32_t ivar = blockIdx . y ; real nx = nhat [ VEB_2D_INDEX ( i , j , iel , 0 , 0 , N , nel , 1 )]; real ny = nhat [ VEB_2D_INDEX ( i , j , iel , 0 , 1 , N , nel , 1 )]; real un = u * nx + v * ny ; real dfdn = dfavg [ VEB_2D_INDEX ( i , j , iel , ivar , 0 , N , nel , nvar )] * nx + dfavg [ VEB_2D_INDEX ( i , j , iel , ivar , 1 , N , nel , nvar )] * ny ; real nmag = nscale [ SCB_2D_INDEX ( i , j , iel , 0 , N , nel )]; flux [ idof + ivar * ndof ] = ( 0.5 * ( un * ( fb [ idof + ivar * ndof ] + fextb [ idof + ivar * ndof ]) + fabsf ( un ) * ( fb [ idof + ivar * ndof ] - fextb [ idof + ivar * ndof ])) - nu * dfdn ) * nmag ; } } extern \"C\" { void boundaryflux_advection_diffusion_2d_gpu ( real * fb , real * fextb , real * dfavg , real * nhat , real * nscale , real * flux , real u , real v , real nu , int N , int nel , int nvar ){ int threads_per_block = 256 ; uint32_t ndof = ( N + 1 ) * 4 * nel ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nvar , 1 ); dim3 nthreads ( threads_per_block , 1 , 1 ); boundaryflux_advection_diffusion_2d_gpukernel <<< nblocks , nthreads >>> ( fb , fextb , dfavg , nhat , nscale , flux , u , v , nu , N , nel , nvar ); } }","tags":"","loc":"sourcefile/self_advection_diffusion_2d.cpp.html"},{"title":"SELF_advection_diffusion_3d.cpp – SELF","text":"Contents Source Code SELF_advection_diffusion_3d.cpp Source Code #include \"SELF_GPU_Macros.h\" __global__ void setboundarycondition_advection_diffusion_3d_gpukernel ( real * extBoundary , real * boundary , int * sideInfo , int N , int nel , int nvar ){ uint32_t idof = threadIdx . x + blockIdx . x * blockDim . x ; uint32_t ndof = ( N + 1 ) * ( N + 1 ) * 6 * nel ; if ( idof < ndof ){ uint32_t i = idof % ( N + 1 ); uint32_t j = ( idof / ( N + 1 )) % ( N + 1 ); uint32_t s1 = ( idof / ( N + 1 ) / ( N + 1 )) % 6 ; uint32_t e1 = idof / ( N + 1 ) / ( N + 1 ) / 6 ; uint32_t e2 = sideInfo [ INDEX3 ( 2 , s1 , e1 , 5 , 6 )]; if ( e2 == 0 ){ uint32_t ivar = blockIdx . y ; extBoundary [ SCB_3D_INDEX ( i , j , s1 , e1 , ivar , N , nel )] = 0.0 ; } } } extern \"C\" { void setboundarycondition_advection_diffusion_3d_gpu ( real * extBoundary , real * boundary , int * sideInfo , int N , int nel , int nvar ){ int threads_per_block = 256 ; int ndof = ( N + 1 ) * ( N + 1 ) * 6 * nel ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nvar , 1 ); dim3 nthreads ( threads_per_block , 1 , 1 ); setboundarycondition_advection_diffusion_3d_gpukernel <<< nblocks , nthreads , 0 , 0 >>> ( extBoundary , boundary , sideInfo , N , nel , nvar ); } } __global__ void setgradientboundarycondition_advection_diffusion_3d_gpukernel ( real * extBoundary , real * boundary , int * sideInfo , int N , int nel , int nvar ){ uint32_t idof = threadIdx . x + blockIdx . x * blockDim . x ; uint32_t ndof = ( N + 1 ) * ( N + 1 ) * 6 * nel ; if ( idof < ndof ){ uint32_t i = idof % ( N + 1 ); uint32_t j = ( idof / ( N + 1 )) % ( N + 1 ); uint32_t s1 = ( idof / ( N + 1 ) / ( N + 1 )) % 6 ; uint32_t e1 = idof / ( N + 1 ) / ( N + 1 ) / 6 ; uint32_t e2 = sideInfo [ INDEX3 ( 2 , s1 , e1 , 5 , 6 )]; if ( e2 == 0 ){ uint32_t ivar = blockIdx . y ; uint32_t idir = blockIdx . z ; extBoundary [ VEB_3D_INDEX ( i , j , s1 , e1 , ivar , idir , N , nel , nvar )] = boundary [ VEB_3D_INDEX ( i , j , s1 , e1 , ivar , idir , N , nel , nvar )]; } } } extern \"C\" { void setgradientboundarycondition_advection_diffusion_3d_gpu ( real * extBoundary , real * boundary , int * sideInfo , int N , int nel , int nvar ){ int threads_per_block = 256 ; int ndof = ( N + 1 ) * ( N + 1 ) * 6 * nel ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nvar , 3 ); dim3 nthreads ( threads_per_block , 1 , 1 ); setgradientboundarycondition_advection_diffusion_3d_gpukernel <<< nblocks , nthreads , 0 , 0 >>> ( extBoundary , boundary , sideInfo , N , nel , nvar ); } } __global__ void fluxmethod_advection_diffusion_3d_gpukernel ( real * solution , real * solutiongradient , real * flux , real u , real v , real w , real nu , int ndof ){ uint32_t i = threadIdx . x + blockIdx . x * blockDim . x ; if ( i < ndof ){ flux [ i ] = u * solution [ i ] - nu * solutiongradient [ i ]; flux [ i + ndof ] = v * solution [ i ] - nu * solutiongradient [ i + ndof ]; flux [ i + 2 * ndof ] = w * solution [ i ] - nu * solutiongradient [ i + 2 * ndof ]; } } extern \"C\" { void fluxmethod_advection_diffusion_3d_gpu ( real * solution , real * solutiongradient , real * flux , real u , real v , real w , real nu , int N , int nel , int nvar ){ int ndof = ( N + 1 ) * ( N + 1 ) * ( N + 1 ) * nel * nvar ; int threads_per_block = 256 ; int nblocks_x = ndof / threads_per_block + 1 ; fluxmethod_advection_diffusion_3d_gpukernel <<< dim3 ( nblocks_x , 1 , 1 ), dim3 ( threads_per_block , 1 , 1 ), 0 , 0 >>> ( solution , solutiongradient , flux , u , v , w , nu , ndof ); } } __global__ void boundaryflux_advection_diffusion_3d_gpukernel ( real * fb , real * fextb , real * dfavg , real * nhat , real * nscale , real * flux , real u , real v , real w , real nu , int N , int nel , int nvar ){ uint32_t idof = threadIdx . x + blockIdx . x * blockDim . x ; uint32_t ndof = ( N + 1 ) * ( N + 1 ) * 6 * nel ; if ( idof < ndof ){ uint32_t i = idof % ( N + 1 ); uint32_t j = ( idof / ( N + 1 )) % ( N + 1 ); uint32_t k = ( idof / ( N + 1 ) / ( N + 1 )) % 6 ; uint32_t iel = idof / ( N + 1 ) / ( N + 1 ) / 6 ; uint32_t ivar = blockIdx . y ; real nx = nhat [ VEB_3D_INDEX ( i , j , k , iel , 0 , 0 , N , nel , 1 )]; real ny = nhat [ VEB_3D_INDEX ( i , j , k , iel , 0 , 1 , N , nel , 1 )]; real nz = nhat [ VEB_3D_INDEX ( i , j , k , iel , 0 , 2 , N , nel , 1 )]; real un = u * nx + v * ny + w * nz ; real dfdn = dfavg [ VEB_3D_INDEX ( i , j , k , iel , ivar , 0 , N , nel , nvar )] * nx + dfavg [ VEB_3D_INDEX ( i , j , k , iel , ivar , 1 , N , nel , nvar )] * ny + dfavg [ VEB_3D_INDEX ( i , j , k , iel , ivar , 2 , N , nel , nvar )] * nz ; real nmag = nscale [ SCB_3D_INDEX ( i , j , k , iel , 0 , N , nel )]; flux [ idof + ivar * ndof ] = ( 0.5 * ( un * ( fb [ idof + ivar * ndof ] + fextb [ idof + ivar * ndof ]) + fabsf ( un ) * ( fb [ idof + ivar * ndof ] - fextb [ idof + ivar * ndof ])) - nu * dfdn ) * nmag ; } } extern \"C\" { void boundaryflux_advection_diffusion_3d_gpu ( real * fb , real * fextb , real * dfavg , real * nhat , real * nscale , real * flux , real u , real v , real w , real nu , int N , int nel , int nvar ){ int threads_per_block = 256 ; uint32_t ndof = ( N + 1 ) * ( N + 1 ) * 6 * nel ; int nblocks_x = ndof / threads_per_block + 1 ; dim3 nblocks ( nblocks_x , nvar , 1 ); dim3 nthreads ( threads_per_block , 1 , 1 ); boundaryflux_advection_diffusion_3d_gpukernel <<< nblocks , nthreads >>> ( fb , fextb , dfavg , nhat , nscale , flux , u , v , w , nu , N , nel , nvar ); } }","tags":"","loc":"sourcefile/self_advection_diffusion_3d.cpp.html"}]}