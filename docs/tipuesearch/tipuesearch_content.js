var tipuesearch = {"pages":[{"title":" SELF ","text":"SELF Developer Info Joe Schoonover Committed to service for science","tags":"home","loc":"index.html"},{"title":"SELF_SupportRoutines.f90 – SELF","text":"This file depends on sourcefile~~self_supportroutines.f90~~EfferentGraph sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_supportroutines.f90~~AfferentGraph sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~self_advection2d.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_advection2d.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~self_advection3d.f90->sourcefile~self_supportroutines.f90 sourcefile~self_advection3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~sadv3d.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 sourcefile~sadv2d.f90->sourcefile~self_mesh.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_SupportRoutines Source Code SELF_SupportRoutines.f90 Source Code ! SELF_SupportRoutines.f90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! !> \\file SELF_SupportRoutines.f90 !! Contains the \\ref SELF_SupportRoutines module !> \\defgroup SELF_SupportRoutines SELF_SupportRoutines !! This module defines a set of general purpose routines. MODULE SELF_SupportRoutines USE ISO_FORTRAN_ENV USE SELF_Constants IMPLICIT NONE CONTAINS FUNCTION Int2Str ( aNumber ) RESULT ( aString ) IMPLICIT NONE INTEGER :: aNumber CHARACTER ( 12 ) :: aString WRITE ( aString , '(I9)' ) aNumber END FUNCTION Int2Str FUNCTION Float2Str ( aNumber ) RESULT ( aString ) IMPLICIT NONE REAL ( prec ) :: aNumber CHARACTER ( 12 ) :: aString WRITE ( aString , '(E12.4)' ) aNumber END FUNCTION Float2Str !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! Function AlmostEqual ! !> \\fn AlmostEqual !! Compares two floating point numbers and determines if they are equal (to machine precision). !! !!   This function is from Alg. 139 on pg. 359 of D.A. Kopriva, 2009, \"Implementing Spectral Element !!    Methods for Scientists and Engineers\" !! !! <H2> Usage : </H2> !! <B>Logical</B> :: AisB <BR> !! <B>REAL</B>(prec) :: a, b <BR> !!         .... <BR> !!     AisB = AlmostEqual( a, b ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> a <td> REAL(prec) <td> scalar !!   <tr> <td> in <th> b <td> REAL(prec) <td> scalar !!   <tr> <td> in <th> AisB <td> Logical <td> !!                     <B>.TRUE.</B> IF a=b to machine precision <BR> !!                     <B>.FALSE.</B> otherwise !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION AlmostEqual ( a , b ) RESULT ( AisB ) IMPLICIT NONE REAL ( real64 ) :: a , b LOGICAL :: AisB IF ( a == 0.0_real64 . OR . b == 0.0_real64 ) THEN IF ( ABS ( a - b ) <= EPSILON ( 1.0_real64 )) THEN AisB = . TRUE . ELSE AisB = . FALSE . END IF ELSE IF (( abs ( a - b ) <= EPSILON ( 1.0_real64 ) * abs ( a )) . OR . ( abs ( a - b ) <= EPSILON ( 1.0_real64 ) * abs ( b ))) THEN AisB = . TRUE . ELSE AisB = . FALSE . END IF END IF END FUNCTION AlmostEqual ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R InsertionSort ! !> \\fn InsertionSort !! Sorts an array of integers from smallest to largest using the insertion-sort algorithm. !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: N <BR> !! <B>INTEGER</B> :: inArray(1:N) <BR> !! <B>INTEGER</B> :: outArray(1:N) <BR> !!         .... <BR> !!     <B>CALL</B> InsertionSort( inArray, outArray, N ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> N <td> INTEGER <td> !!                     The number of elements in the input and output arrays !!   <tr> <td> in <th> inArray(1:N) <td> INTEGER <td> !!                     Array of unsorted integers. !!   <tr> <td> out <th> outArray <td> INTEGER <td> !!                      Array of integers, sorted from most negative to most positive numbers. !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE InsertionSort ( inArray , outArray , N ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: inArray ( 1 : N ) INTEGER , INTENT ( out ) :: outArray ( 1 : N ) ! LOCAL INTEGER :: i , j INTEGER :: temp outArray = inArray DO i = 2 , N j = i DO WHILE ( j > 1 ) IF ( outArray ( j - 1 ) > outArray ( j )) THEN !Swap outArray(j) outArray(j-1) temp = outArray ( j ) outArray ( j ) = outArray ( j - 1 ) outArray ( j - 1 ) = temp j = j - 1 ELSE EXIT END IF END DO END DO END SUBROUTINE InsertionSort ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R SortArray ! !> \\fn SortArray !! Sorts a REAL(prec) array from smallest absolute value to largest absolute value. !! !! <H2> Usage : </H2> !! <B>REAL</B>(prec) :: myArray(low:high) <BR> !! <B>INTEGER</B>    :: low, high <BR> !!         .... <BR> !!     <B>CALL</B> SortArray( myArray, low, high ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myArray(low:high) <td> REAL(prec) <td> !!                         On <B>input</B> Unsorted array of floating point values <BR> !!                         On <B>output</B> Sorted array of floating point values, arranged in order !!                         of increasing absolute value. !!   <tr> <td> in <th> low <td> INTEGER <td> !!                     Lower bound of the input and output arrays !!   <tr> <td> in <th> high <td> INTEGER <td> !!                     Upper bound of the input and output arrays !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE SortArray ( myArray , low , high ) IMPLICIT NONE INTEGER , INTENT ( in ) :: low , high REAL ( prec ), INTENT ( inout ) :: myArray ( low : high ) ! LOCAL INTEGER :: locOfMin INTEGER :: ind REAL ( prec ) :: temp DO ind = low , high - 1 locOfMin = MINLOC ( abs ( myArray ( ind : high )), 1 ) + low - 1 + ind temp = myArray ( ind ) myArray ( ind ) = myArray ( locOfMin ) myArray ( locOfMin ) = temp END DO END SUBROUTINE SortArray ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R SortAndSum ! !> \\fn SortAndSum !! Computes the sum of an array by first sorting the array from smallest absolute value to largest !! absolute value. !! !! When computing the sum of an array of floating point values, round-off errors can be reduced !! by adding from the smallest to largest values. <BR> !! !! This subroutine depends on <BR> !!    Subroutine \\ref sortarray !! !! <H2> Usage : </H2> !! <B>REAL</B>(prec) :: myArray(low:high) <BR> !! <B>REAL</B>(prec) :: arraySum <BR> !! <B>INTEGER</B>    :: low, high <BR> !!         .... <BR> !!     <B>CALL</B> SortAndSum( myArray, low, high, arraySum ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myArray(low:high) <td> REAL(prec) <td> !!                         On <B>input</B> Unsorted array of floating point values <BR> !!                         On <B>output</B> Sorted array of floating point values, arranged in order !!                         of increasing absolute value. !!   <tr> <td> in <th> low <td> INTEGER <td> !!                     Lower bound of the input and output arrays !!   <tr> <td> in <th> high <td> INTEGER <td> !!                     Upper bound of the input and output arrays !!   <tr> <td> out <th> arraySum <td> REAL(prec) <td> !!                     Sum of the array components. !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE SortAndSum ( myArray , low , high , arraysum ) IMPLICIT NONE INTEGER , INTENT ( in ) :: low , high REAL ( prec ), INTENT ( inout ) :: myArray ( low : high ) REAL ( prec ), INTENT ( out ) :: arraysum ! LOCAL INTEGER :: ind CALL SortArray ( myArray , low , high ) arraysum = 0.0_prec DO ind = low , high arraysum = arraysum + myArray ( ind ) END DO END SUBROUTINE SortAndSum ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R ReverseArray ! !> \\fn ReverseArray !! Reverses the order of a REAL(prec) array. !! !! <H2> Usage : </H2> !! <B>REAL</B>(prec) :: myArray(low:high) <BR> !! <B>INTEGER</B>    :: low, high <BR> !!         .... <BR> !!     <B>CALL</B> ReverseArray( myArray, low, high ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myArray(low:high) <td> REAL(prec) <td> !!                         On <B>output</B>, the input array in reverse order . !!   <tr> <td> in <th> low <td> INTEGER <td> !!                     Lower bound of the input and output arrays !!   <tr> <td> in <th> high <td> INTEGER <td> !!                     Upper bound of the input and output arrays !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE ReverseArray ( myArray , low , high ) IMPLICIT NONE INTEGER , INTENT ( in ) :: low , high REAL ( prec ), INTENT ( inout ) :: myArray ( low : high ) ! LOCAL REAL ( prec ) :: temp ( low : high ) INTEGER :: i , j temp = myArray j = high DO i = low , high myArray ( i ) = temp ( j ) j = j - 1 END DO END SUBROUTINE ReverseArray ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R ForwardShift ! !> \\fn ForwardShift !! Shift an array integers by one index forward, moving the last index to the first. !! !! Shifts the array entries as follows : <BR> !!  myArray(1) <-- myArray(N) <BR> !!  myArray(2) <-- myArray(1) <BR> !!  myArray(3) <-- myArray(2) <BR> !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: N !! <B>INTEGER</B> :: myArray(1:N) <BR> !!         .... <BR> !!     <B>CALL</B> ForwardShift( myArray, N ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myArray(1:N) <td> INTEGER <td> !!                         On <B>output</B>, the input array with elements shifted forward by !!                         one index. !!   <tr> <td> in <th> N <td> INTEGER <td> !!                     The number of elements in the array !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE ForwardShift ( myArray , N ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( inout ) :: myArray ( 1 : N ) ! LOCAL INTEGER :: temp ( 1 : N ) temp = myArray myArray ( 1 ) = temp ( N ) myArray ( 2 : N ) = temp ( 1 : N - 1 ) END SUBROUTINE ForwardShift ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R CompareArray ! !> \\fn CompareArray !! Compares to INTEGER arrays and determines if they are identical. !! !! A logical is returned that specifies whether or not two arrays are identical. To determine !! if the two arrays are identical, the sum of the difference between each element in the input !! array is calculated. If the arrays are identical, each contribution to the sum is zero and hence !! the sum is zero. If the sum is non-zero, the arrays are distinct. !! !! This routine is used in the \\ref HexMeshClass module. A face of an element in an unstructured !! mesh is identified by its four corner nodes. When identifying unique faces in an unstructured !! mesh, we need to determine if two elements share a face. This can be accomplished by comparing !! the four corner nodes (from each element) that define each face. !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: N <BR> !! <B>INTEGER</B> :: arrayOne(1:N) <BR> !! <B>INTEGER</B> :: arrayTwo(1:N) <BR> !! <B>LOGICAL</B> :: arraysMatch <BR> !!         .... <BR> !!     arraysMatch = CompareArray( arrayOne, arrayTwo, N ) <BR> !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> arrayOne(1:N) <td> INTEGER <td> !!   <tr> <td> in <th> arrayTwo(1:N) <td> INTEGER <td> !!   <tr> <td> in <th> N <td> INTEGER <td> !!   <tr> <td> out <th> arraysMatch <td> INTEGER <td> !! !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION CompareArray ( arrayOne , arrayTwo , N ) RESULT ( arraysMatch ) IMPLICIT NONE INTEGER :: N INTEGER :: arrayOne ( 1 : N ), arrayTwo ( 1 : N ) LOGICAL :: arraysMatch ! LOCAL INTEGER :: i , theSumOfDiffs theSumOfDiffs = 0 DO i = 1 , N theSumOfDiffs = theSumOfDiffs + arrayOne ( i ) - arrayTwo ( i ) END DO IF ( theSumOfDiffs == 0 ) THEN arraysMatch = . TRUE . ELSE arraysMatch = . FALSE . END IF END FUNCTION CompareArray ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R NewUnit ! !> \\fn NewUnit !! Returns a file unit identifier that is currently not in use. !! !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: thisUnit <BR> !!         .... <BR> !!     <B>OPEN</B>( UNIT=NewUnit(thisUnit), FILE=filename) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> out <th> thisunit <td> INTEGER <td> File unit that is not in use !!  </table> !! ! ================================================================================================ ! !>@} INTEGER FUNCTION NewUnit ( thisunit ) IMPLICIT NONE INTEGER , INTENT ( out ), OPTIONAL :: thisunit ! Local INTEGER , PARAMETER :: unitMin = 100 , unitMax = 1000 LOGICAL :: isopened INTEGER :: iUnit newunit = - 1 DO iUnit = unitMin , unitMax ! Check to see IF this UNIT is opened INQUIRE ( UNIT = iUnit , opened = isopened ) IF (. not . isopened ) THEN newunit = iUnit EXIT END IF END DO IF ( PRESENT ( thisunit )) thisunit = newunit END FUNCTION NewUnit ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R UniformPoints ! !> \\fn UniformPoints !! Generates a REAL(prec) array of N points evenly spaced between two points. !! !! !! <H2> Usage : </H2> !! <B>REAL</B>(prec) :: a <BR> !! <B>REAL</B>(prec) :: b <BR> !! <B>REAL</B>(prec) :: xU(0:N) <BR> !! <B>INTEGER</B> :: N <BR> !!         .... <BR> !!     xU = UniformPoints( a, b, N ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> a <td> REAL(prec) <td> Starting point of the interval !!   <tr> <td> in <th> b <td> REAL(prec) <td> Ending point of the interval !!   <tr> <td> in <th> N <td> INTEGER <td> The number of points in the interval \\f$[a,b]\\f$ !!   <tr> <td> in <th> xU(0:N) <td> REAL(prec) <td> !!                     Array of evenly spaced points in the interval \\f$[a,b]\\f$ !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION UniformPoints ( a , b , firstInd , lastInd ) RESULT ( xU ) IMPLICIT NONE REAL ( prec ) :: a , b INTEGER :: firstInd , lastInd REAL ( prec ) :: xU ( firstInd : lastInd ) ! LOCAL REAL ( prec ) :: dx INTEGER :: i dx = ( b - a ) / REAL (( lastInd - firstInd ), prec ) DO i = firstInd , lastInd xU ( i ) = a + dx * REAL ( i - firstInd , prec ) END DO END FUNCTION UniformPoints ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R Determinant ! !> \\fn Determinant !! A recursive function that calculates the determinant of an \\f$ N\\times N \\f$ matrix. !! !! This function is used in the functions \\ref invert_2x2 and \\ref invert_3x3 <BR> !! !! This function depends on <BR> !!    Function \\ref getminor !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: N !! <B>REAL</B>(prec) :: A(1:N,1:N), D <BR> !!         .... <BR> !!     D = Determinant( A, N ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> A(1:N,1:N) <td> REAL(prec) <td> Square matrix !!   <tr> <td> in <th> N <td> INTEGER <td> Dimension of the matrix !!   <tr> <td> out <th> detA <td> REAL(prec) <td> The determinant of the matrix !!  </table> !! ! ================================================================================================ ! !>@} RECURSIVE FUNCTION Determinant ( A , N ) RESULT ( D ) IMPLICIT NONE INTEGER :: N REAL ( prec ) :: A ( 1 : N , 1 : N ) REAL ( prec ) :: D ! LOCAL REAL ( prec ) :: M ( 1 : N - 1 , 1 : N - 1 ) INTEGER :: j IF ( N == 2 ) THEN D = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) RETURN ELSE D = 0.0_prec DO j = 1 , N M = GetMinor ( A , 1 , j , N ) D = D + ( - 1.0_prec ) ** ( j + 1 ) * A ( 1 , j ) * Determinant ( M , N - 1 ) END DO END IF END FUNCTION Determinant ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! Function GetMinor ! !> \\fn GetMinor !! Returns the submatrix obtained by removing a given row and column of the input matrix. !! !! The minor of a matrix is used in calculating the determinant of a matrix. !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: i, j, N <BR> !! <B>REAL</B>(prec) :: A(1:N,1:N), M(1:N-1,1:N-1) <BR> !!         .... <BR> !!     M = GetMinor( A, i, j, N ) <BR> !! !! <H2> Usage : </H2> !! <B>TYPE</B>(DataType) :: this <BR> !!         .... <BR> !!     <B>CALL</B> this % RoutineName( Inputs/Outputs ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> A(1:N,1:N) <td> REAL(prec) <td> Square matrix !!   <tr> <td> in <th> i <td> INTEGER <td> The row that is removed from A to form the minor of A !!   <tr> <td> in <th> j <td> INTEGER <td> The column that is removed from A to form the minor of A !!   <tr> <td> in <th> N <td> INTEGER <td> The dimension of A !!   <tr> <td> in <th> M(1:N-1,1:N-1) <td> REAL(prec) <td> The (i,j) minor of A !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION GetMinor ( A , i , j , N ) RESULT ( M ) IMPLICIT NONE INTEGER :: i , j , N REAL ( prec ) :: A ( 1 : N , 1 : N ) REAL ( prec ) :: M ( 1 : N - 1 , 1 : N - 1 ) ! LOCAL INTEGER :: row , col INTEGER :: thisRow , thisCol thisRow = 0 DO row = 1 , N ! loop over the rows of A IF ( row /= i ) THEN thisRow = thisRow + 1 thisCol = 0 DO col = 1 , N ! loop over the columns of A IF ( col /= j ) THEN thisCol = thisCol + 1 M ( thisRow , thisCol ) = A ( row , col ) END IF END DO ! col, loop over the columns of A END IF END DO ! row, loop over the rows of A END FUNCTION GetMinor ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! Function Invert_2x2 ! !> \\fn Invert_2x2 !!  Computes the inverse of a 2x2 matrix using Kramer's rule. !! !! This Function depends on <BR> !! \\ref determinant !! !! <H2> Usage : </H2> !! <B>REAL</B>(prec) :: A(1:2,1:2), Ainv(1:2,1:2) <BR> !!         .... <BR> !!     Ainv = Invert_2x2( A ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> A(1:2,1:2) <td> REAL(prec) <td> Real 2x2 matrix !!   <tr> <td> in <th> Ainv(1:2,1:2) <td> REAL(prec) <td> Real 2x2 matrix, inverse of A !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION Invert_2x2 ( A ) RESULT ( Ainv ) IMPLICIT NONE REAL ( prec ) :: A ( 1 : 2 , 1 : 2 ) REAL ( prec ) :: Ainv ( 1 : 2 , 1 : 2 ) ! LOCAL REAL ( prec ) :: detA detA = Determinant ( A , 2 ) Ainv ( 1 , 1 ) = A ( 2 , 2 ) / detA Ainv ( 2 , 2 ) = A ( 1 , 1 ) / detA Ainv ( 1 , 2 ) = - A ( 1 , 2 ) / detA Ainv ( 2 , 1 ) = - A ( 2 , 1 ) / detA END FUNCTION Invert_2x2 ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! Function Invert_3x3 ! !> \\fn Invert_3x3 !!  Computes the inverse of a 3x3 matrix using Kramer's rule. !! !! This Function depends on <BR> !! \\ref determinant !! !! <H3> Usage : </H3> !! <B>REAL</B>(prec) :: A(1:3,1:3), Ainv(1:3,1:3) <BR> !!         .... <BR> !!     Ainv = Invert_3x3( A ) <BR> !! !!  <H3> Parameters : </H3> !!  <table> !!   <tr> <td> in <th> A(1:3,1:3) <td> REAL(prec) <td> Real 3x3 matrix !!   <tr> <td> in <th> Ainv(1:3,1:3) <td> REAL(prec) <td> Real 3x3 matrix, inverse of A !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION Invert_3x3 ( A ) RESULT ( Ainv ) ! ! =============================================================================================== ! IMPLICIT NONE REAL ( prec ) :: A ( 1 : 3 , 1 : 3 ) REAL ( prec ) :: Ainv ( 1 : 3 , 1 : 3 ) ! LOCAL REAL ( prec ) :: detA REAL ( prec ) :: submat ( 1 : 2 , 1 : 2 ) REAL ( prec ) :: detSubmat detA = Determinant ( A , 3 ) ! Row 1 column 1 of inverse (use submatrix neglecting row 1 and column 1 of A) submat = A ( 2 : 3 , 2 : 3 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 1 , 1 ) = detSubmat / detA ! Row 1 column 2 of inverse (use submatrix neglecting row 2 and column 1 of A) submat = A ( 1 : 3 : 2 , 2 : 3 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 1 , 2 ) = - detSubmat / detA ! Row 1 column 3 of inverse (use submatrix neglecting row 3 and column 1 of A) submat = A ( 1 : 2 , 2 : 3 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 1 , 3 ) = detSubmat / detA ! Row 2 column 1 of inverse (use submatrix neglecting row 1 and column 2 of A) submat = A ( 2 : 3 , 1 : 3 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 2 , 1 ) = - detSubmat / detA ! Row 2 column 2 of inverse (use submatrix neglecting row 2 and column 2 of A) submat = A ( 1 : 3 : 2 , 1 : 3 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 2 , 2 ) = detSubmat / detA ! Row 2 column 3 of inverse (use submatrix neglecting row 3 and column 2 of A) submat = A ( 1 : 2 , 1 : 3 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 2 , 3 ) = - detSubmat / detA ! Row 3 column 1 of inverse (use submatrix neglecting row 1 and column 3 of A) submat = A ( 2 : 3 , 1 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 3 , 1 ) = detSubmat / detA ! Row 3 column 2 of inverse (use submatrix neglecting row 2 and column 3 of A) submat = A ( 1 : 3 : 2 , 1 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 3 , 2 ) = - detSubmat / detA ! Row 3 column 3 of inverse (use submatrix neglecting row 3 and column 3 of A) submat = A ( 1 : 2 , 1 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 3 , 3 ) = detSubmat / detA END FUNCTION Invert_3x3 ! FUNCTION InvertSpectralOpMatrix ( A , N ) RESULT ( Ainv ) ! Inverts an (N+1)x(N+1) matrix using a polynomial representation of the ! inverse IMPLICIT NONE INTEGER :: N REAL ( prec ) :: A ( 0 : N , 0 : N ) REAL ( prec ) :: Ainv ( 0 : N , 0 : N ) ! Local INTEGER :: row , col , j , iter REAL ( prec ) :: I ( 0 : N , 0 : N ) REAL ( prec ) :: Ainv_ij , maxChange Ainv = 0.0_prec I = 0.0_prec DO row = 0 , N Ainv ( row , row ) = 1.0_prec I ( row , row ) = 1.0_prec END DO DO iter = 1 , maxInverseIters maxChange = 0.0_prec DO col = 0 , N DO row = 0 , N Ainv_ij = 0.0_prec DO j = 0 , N Ainv_ij = Ainv_ij + Ainv ( j , col ) * ( I ( row , j ) - A ( row , j )) END DO maxChange = MAX ( ABS ( Ainv ( row , col ) - Ainv_ij ), maxChange ) Ainv ( row , col ) = Ainv_ij END DO END DO IF ( maxChange <= tolerance ) THEN PRINT * , ' InvertSpectralOpMatrix : Converged in ' , iter , ' iterations.' EXIT END IF END DO IF ( maxChange > tolerance ) THEN PRINT * , 'InvertSpectralOpMatrix : Did not converge.' , maxChange END IF END FUNCTION InvertSpectralOpMatrix ! FUNCTION UpperCase ( str ) RESULT ( upper ) Implicit None CHARACTER ( * ), INTENT ( In ) :: str CHARACTER ( LEN ( str )) :: Upper INTEGER :: ic , i CHARACTER ( 27 ), PARAMETER :: cap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ ' CHARACTER ( 27 ), PARAMETER :: low = 'abcdefghijklmnopqrstuvwxyz ' DO i = 1 , LEN ( str ) ic = INDEX ( low , str ( i : i )) IF ( ic > 0 ) THEN Upper ( i : i ) = cap ( ic : ic ) ELSE Upper ( i : i ) = str ( i : i ) END IF END DO END FUNCTION UpperCase ! FUNCTION TimeStamp ( time , units ) RESULT ( timeStampString ) IMPLICIT NONE REAL ( prec ) :: time CHARACTER ( 1 ) :: units CHARACTER ( 13 ) :: timeStampString ! Local INTEGER :: day , minute , hour , second , millisecond CHARACTER ( 4 ) :: dayStamp CHARACTER ( 2 ) :: hourStamp , minuteStamp , secondStamp CHARACTER ( 3 ) :: milliSecondStamp REAL ( real64 ) :: time_real64 time_real64 = REAL ( time , real64 ) ! Units in \"seconds\" IF ( units ( 1 : 1 ) == 's' ) THEN ! Obtain the day day = INT ( time_real64 / 8640 0.0_real64 ) hour = INT (( time_real64 & - 8640 0.0_real64 * day ) / 360 0.0_real64 ) minute = INT (( time_real64 & - 360 0.0_real64 * hour & - 8640 0.0_real64 * day ) / 6 0.0_real64 ) second = INT (( time_real64 & - 6 0.0_real64 * minute & - 360 0.0_real64 * hour & - 8640 0.0_real64 * day )) milliSecond = NINT ((( time_real64 & - 6 0.0_real64 * minute & - 360 0.0_real64 * hour & - 8640 0.0_real64 * day ) & - REAL ( second , real64 )) * 100 0.0_real64 ) IF ( milliSecond >= 1000 ) THEN milliSecond = milliSecond - 1000 second = second + 1 ENDIF IF ( second >= 60 ) THEN second = second - 60 minute = minute + 1 ENDIF IF ( minute >= 60 ) THEN minute = minute - 60 hour = hour + 1 ENDIF IF ( hour >= 24 ) THEN hour = hour - 24 day = day + 1 ENDIF WRITE ( dayStamp , '(I4.4)' ) day WRITE ( hourStamp , '(I2.2)' ) hour WRITE ( minuteStamp , '(I2.2)' ) minute WRITE ( secondStamp , '(I2.2)' ) second WRITE ( milliSecondStamp , '(I3.3)' ) millisecond timeStampString = dayStamp // hourStamp // minuteStamp // secondStamp // milliSecondStamp ! minutes ELSEIF ( units ( 1 : 1 ) == 'm' ) THEN ! hours ELSEIF ( units ( 1 : 1 ) == 'h' ) THEN END IF END FUNCTION TimeStamp LOGICAL FUNCTION IsInf ( a ) IMPLICIT NONE REAL ( prec ) :: a IF ( a > HUGE ( prec )) THEN IsInf = . TRUE . ELSE IsInf = . FALSE . END IF RETURN END FUNCTION IsInf FUNCTION FloorSQRT ( x ) RESULT ( sqrtX ) INTEGER :: x , sqrtX ! Local INTEGER :: i , res IF ( x == 0 . OR . x == 1 ) THEN sqrtX = x ELSE res = 1 i = 1 DO WHILE ( res <= x ) i = i + 1 res = i * i END DO sqrtX = i - 1 END IF END FUNCTION FloorSQRT FUNCTION FloorCURT ( x ) RESULT ( curtX ) INTEGER :: x , curtX ! Local INTEGER :: i , res IF ( x == 0 . OR . x == 1 ) THEN curtX = x ELSE res = 1 i = 1 DO WHILE ( res <= x ) i = i + 1 res = i * i * i END DO curtX = i - 1 END IF END FUNCTION FloorCURT END MODULE SELF_SupportRoutines","tags":"","loc":"sourcefile/self_supportroutines.f90.html"},{"title":"SELF_Metadata.f90 – SELF","text":"This file depends on sourcefile~~self_metadata.f90~~EfferentGraph sourcefile~self_metadata.f90 SELF_Metadata.f90 sourcefile~self_hdf5.f90 SELF_HDF5.f90 sourcefile~self_metadata.f90->sourcefile~self_hdf5.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_hdf5.f90->sourcefile~self_memory.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_hdf5.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_metadata.f90~~AfferentGraph sourcefile~self_metadata.f90 SELF_Metadata.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_dg.f90->sourcefile~self_metadata.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Metadata Source Code SELF_Metadata.f90 Source Code ! SELF_Metadata.F90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Metadata USE SELF_HDF5 INTEGER , PARAMETER , PUBLIC :: SELF_MTD_NameLength = 250 INTEGER , PARAMETER , PUBLIC :: SELF_MTD_DescriptionLength = 1000 INTEGER , PARAMETER , PUBLIC :: SELF_MTD_UnitsLength = 20 ! A class for storing metadata information, intended for file IO TYPE Metadata CHARACTER ( SELF_MTD_NameLength ) :: name CHARACTER ( SELF_MTD_DescriptionLength ) :: description CHARACTER ( SELF_MTD_UnitsLength ) :: units CONTAINS PROCEDURE , PUBLIC :: Set_Name => Set_Name_Metadata PROCEDURE , PUBLIC :: Set_Description => Set_Description_Metadata PROCEDURE , PUBLIC :: Set_Units => Set_Units_Metadata ! PROCEDURE,PUBLIC :: Write_HDF5 => Write_HDF5_Metadata END TYPE Metadata CONTAINS SUBROUTINE Set_Name_Metadata ( mtd , name ) IMPLICIT NONE CLASS ( Metadata ), INTENT ( inout ) :: mtd CHARACTER ( * ), INTENT ( in ) :: name mtd % name = name END SUBROUTINE Set_Name_Metadata SUBROUTINE Set_Description_Metadata ( mtd , description ) IMPLICIT NONE CLASS ( Metadata ), INTENT ( inout ) :: mtd CHARACTER ( * ), INTENT ( in ) :: description mtd % description = description END SUBROUTINE Set_Description_Metadata SUBROUTINE Set_Units_Metadata ( mtd , units ) IMPLICIT NONE CLASS ( Metadata ), INTENT ( inout ) :: mtd CHARACTER ( * ), INTENT ( in ) :: units mtd % units = units END SUBROUTINE Set_Units_Metadata END MODULE SELF_Metadata","tags":"","loc":"sourcefile/self_metadata.f90.html"},{"title":"SELF_Memory.f90 – SELF","text":"This file depends on sourcefile~~self_memory.f90~~EfferentGraph sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_memory.f90~~AfferentGraph sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_hdf5.f90 SELF_HDF5.f90 sourcefile~self_hdf5.f90->sourcefile~self_memory.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_mpi.f90 SELF_MPI.f90 sourcefile~self_mpi.f90->sourcefile~self_memory.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_metadata.f90 SELF_Metadata.f90 sourcefile~self_metadata.f90->sourcefile~self_hdf5.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mpi.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_dg.f90->sourcefile~self_hdf5.f90 sourcefile~self_dg.f90->sourcefile~self_mpi.f90 sourcefile~self_dg.f90->sourcefile~self_metadata.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_mesh.f90->sourcefile~self_hdf5.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_mpi.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~self_advection3d.f90->sourcefile~self_mesh.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~self_advection2d.f90->sourcefile~self_mesh.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Memory Source Code SELF_Memory.f90 Source Code ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Memory USE SELF_Constants USE hipfort USE hipfort_check USE ISO_FORTRAN_ENV USE ISO_C_BINDING IMPLICIT NONE TYPE hfReal_r1 !! Data type for storing one-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r1 PROCEDURE , PUBLIC :: Free => Free_hfReal_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r1 END TYPE hfReal_r1 TYPE hfReal_r2 !! Data type for storing two-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r2 PROCEDURE , PUBLIC :: Free => Free_hfReal_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r2 END TYPE hfReal_r2 TYPE hfReal_r3 !! Data type for storing three-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r3 PROCEDURE , PUBLIC :: Free => Free_hfReal_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r3 END TYPE hfReal_r3 TYPE hfReal_r4 !! Data type for storing four-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r4 PROCEDURE , PUBLIC :: Free => Free_hfReal_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r4 END TYPE hfReal_r4 TYPE hfReal_r5 !! Data type for storing five-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r5 PROCEDURE , PUBLIC :: Free => Free_hfReal_r5 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r5 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r5 END TYPE hfReal_r5 TYPE hfReal_r6 !! Data type for storing one-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r6 PROCEDURE , PUBLIC :: Free => Free_hfReal_r6 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r6 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r6 END TYPE hfReal_r6 TYPE hfReal_r7 !! Data type for storing seven-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r7 PROCEDURE , PUBLIC :: Free => Free_hfReal_r7 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r7 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r7 END TYPE hfReal_r7 TYPE hfInt32_r1 !! Data type for storing one-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r1 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r1 END TYPE hfInt32_r1 TYPE hfInt32_r2 !! Data type for storing two-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r2 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r2 END TYPE hfInt32_r2 TYPE hfInt32_r3 !! Data type for storing three-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r3 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r3 END TYPE hfInt32_r3 TYPE hfInt32_r4 !! Data type for storing four-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r4 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r4 END TYPE hfInt32_r4 TYPE hfInt32_r5 !! Data type for storing five-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r5 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r5 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r5 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r5 END TYPE hfInt32_r5 TYPE hfInt32_r6 !! Data type for storing six-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r6 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r6 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r6 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r6 END TYPE hfInt32_r6 TYPE hfInt32_r7 !! Data type for storing seven-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r7 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r7 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r7 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r7 END TYPE hfInt32_r7 TYPE hfInt64_r1 !! Data type for storing one-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r1 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r1 END TYPE hfInt64_r1 TYPE hfInt64_r2 !! Data type for storing two-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r2 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r2 END TYPE hfInt64_r2 TYPE hfInt64_r3 !! Data type for storing three-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r3 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r3 END TYPE hfInt64_r3 TYPE hfInt64_r4 !! Data type for storing four-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r4 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r4 END TYPE hfInt64_r4 TYPE hfInt64_r5 !! Data type for storing five-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r5 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r5 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r5 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r5 END TYPE hfInt64_r5 TYPE hfInt64_r6 !! Data type for storing six-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r6 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r6 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r6 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r6 END TYPE hfInt64_r6 TYPE hfInt64_r7 !! Data type for storing seven-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r7 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r7 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r7 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r7 END TYPE hfInt64_r7 CONTAINS FUNCTION GPUAvailable () RESULT ( avail ) IMPLICIT NONE LOGICAL :: avail ! Local INTEGER :: gpuCount INTEGER ( KIND ( hipSuccess )) :: err err = hipGetDeviceCount ( gpuCount ) IF ( gpuCount > 0 . AND . err == hipSuccess ) THEN avail = . TRUE . ELSE avail = . FALSE . END IF END FUNCTION GPUAvailable SUBROUTINE Alloc_hfReal_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r1 SUBROUTINE Alloc_hfReal_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r2 SUBROUTINE Alloc_hfReal_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r3 SUBROUTINE Alloc_hfReal_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r4 SUBROUTINE Alloc_hfReal_r5 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 5 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 5 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r5 SUBROUTINE Alloc_hfReal_r6 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 6 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 6 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r6 SUBROUTINE Alloc_hfReal_r7 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 7 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 7 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ), & loBound ( 7 ): upBound ( 7 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r7 SUBROUTINE Alloc_hfInt32_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r1 SUBROUTINE Alloc_hfInt32_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r2 SUBROUTINE Alloc_hfInt32_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r3 SUBROUTINE Alloc_hfInt32_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r4 SUBROUTINE Alloc_hfInt32_r5 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 5 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 5 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r5 SUBROUTINE Alloc_hfInt32_r6 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 6 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 6 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r6 SUBROUTINE Alloc_hfInt32_r7 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 7 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 7 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ), & loBound ( 7 ): upBound ( 7 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r7 SUBROUTINE Alloc_hfInt64_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt64_r1 SUBROUTINE Alloc_hfInt64_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt64_r2 SUBROUTINE Alloc_hfInt64_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt64_r3 SUBROUTINE Alloc_hfInt64_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt64_r4 SUBROUTINE Alloc_hfInt64_r5 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 5 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 5 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt64_r5 SUBROUTINE Alloc_hfInt64_r6 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 6 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 6 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt64_r6 SUBROUTINE Alloc_hfInt64_r7 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 7 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 7 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ), & loBound ( 7 ): upBound ( 7 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt64_r7 SUBROUTINE Free_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r1 SUBROUTINE Free_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r2 SUBROUTINE Free_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r3 SUBROUTINE Free_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r4 SUBROUTINE Free_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r5 SUBROUTINE Free_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r6 SUBROUTINE Free_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r7 SUBROUTINE Free_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r1 SUBROUTINE Free_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r2 SUBROUTINE Free_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r3 SUBROUTINE Free_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r4 SUBROUTINE Free_hfInt32_r5 ( this ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r5 SUBROUTINE Free_hfInt32_r6 ( this ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r6 SUBROUTINE Free_hfInt32_r7 ( this ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r7 SUBROUTINE Free_hfInt64_r1 ( this ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt64_r1 SUBROUTINE Free_hfInt64_r2 ( this ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt64_r2 SUBROUTINE Free_hfInt64_r3 ( this ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt64_r3 SUBROUTINE Free_hfInt64_r4 ( this ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt64_r4 SUBROUTINE Free_hfInt64_r5 ( this ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt64_r5 SUBROUTINE Free_hfInt64_r6 ( this ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt64_r6 SUBROUTINE Free_hfInt64_r7 ( this ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt64_r7 SUBROUTINE UpdateHost_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r1 SUBROUTINE UpdateHost_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r2 SUBROUTINE UpdateHost_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r3 SUBROUTINE UpdateHost_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r4 SUBROUTINE UpdateHost_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r5 SUBROUTINE UpdateHost_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r6 SUBROUTINE UpdateHost_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r7 SUBROUTINE UpdateHost_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r1 SUBROUTINE UpdateHost_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r2 SUBROUTINE UpdateHost_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r3 SUBROUTINE UpdateHost_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r4 SUBROUTINE UpdateHost_hfInt32_r5 ( this ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r5 SUBROUTINE UpdateHost_hfInt32_r6 ( this ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r6 SUBROUTINE UpdateHost_hfInt32_r7 ( this ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r7 SUBROUTINE UpdateHost_hfInt64_r1 ( this ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt64_r1 SUBROUTINE UpdateHost_hfInt64_r2 ( this ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt64_r2 SUBROUTINE UpdateHost_hfInt64_r3 ( this ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt64_r3 SUBROUTINE UpdateHost_hfInt64_r4 ( this ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt64_r4 SUBROUTINE UpdateHost_hfInt64_r5 ( this ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt64_r5 SUBROUTINE UpdateHost_hfInt64_r6 ( this ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt64_r6 SUBROUTINE UpdateHost_hfInt64_r7 ( this ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt64_r7 SUBROUTINE UpdateDevice_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r1 SUBROUTINE UpdateDevice_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r2 SUBROUTINE UpdateDevice_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r3 SUBROUTINE UpdateDevice_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r4 SUBROUTINE UpdateDevice_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r5 SUBROUTINE UpdateDevice_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r6 SUBROUTINE UpdateDevice_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r7 SUBROUTINE UpdateDevice_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r1 SUBROUTINE UpdateDevice_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r2 SUBROUTINE UpdateDevice_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r3 SUBROUTINE UpdateDevice_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r4 SUBROUTINE UpdateDevice_hfInt32_r5 ( this ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r5 SUBROUTINE UpdateDevice_hfInt32_r6 ( this ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r6 SUBROUTINE UpdateDevice_hfInt32_r7 ( this ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r7 SUBROUTINE UpdateDevice_hfInt64_r1 ( this ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt64_r1 SUBROUTINE UpdateDevice_hfInt64_r2 ( this ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt64_r2 SUBROUTINE UpdateDevice_hfInt64_r3 ( this ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt64_r3 SUBROUTINE UpdateDevice_hfInt64_r4 ( this ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt64_r4 SUBROUTINE UpdateDevice_hfInt64_r5 ( this ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt64_r5 SUBROUTINE UpdateDevice_hfInt64_r6 ( this ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt64_r6 SUBROUTINE UpdateDevice_hfInt64_r7 ( this ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt64_r7 END MODULE SELF_Memory","tags":"","loc":"sourcefile/self_memory.f90.html"},{"title":"SELF_Constants.f90 – SELF","text":"Files dependent on this one sourcefile~~self_constants.f90~~AfferentGraph sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_hdf5.f90 SELF_HDF5.f90 sourcefile~self_hdf5.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_hdf5.f90->sourcefile~self_memory.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_constants.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~sadv3d.f90->sourcefile~self_mesh.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~self_advection2d.f90->sourcefile~self_constants.f90 sourcefile~self_advection2d.f90->sourcefile~self_supportroutines.f90 sourcefile~self_advection2d.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~self_hashtable.f90 SELF_HashTable.f90 sourcefile~self_hashtable.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_mappeddata.f90->sourcefile~self_constants.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mpi.f90 SELF_MPI.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mpi.f90 sourcefile~self_geometry.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_advection3d.f90->sourcefile~self_constants.f90 sourcefile~self_advection3d.f90->sourcefile~self_supportroutines.f90 sourcefile~self_advection3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90->sourcefile~self_hdf5.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90->sourcefile~self_hashtable.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_mpi.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_constants.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 sourcefile~sadv2d.f90->sourcefile~self_mesh.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_mpi.f90->sourcefile~self_constants.f90 sourcefile~self_mpi.f90->sourcefile~self_memory.f90 sourcefile~self_metadata.f90 SELF_Metadata.f90 sourcefile~self_metadata.f90->sourcefile~self_hdf5.f90 sourcefile~self_dg.f90->sourcefile~self_hdf5.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_mpi.f90 sourcefile~self_dg.f90->sourcefile~self_metadata.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Constants Source Code SELF_Constants.f90 Source Code ! SELF_Constants.f90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Constants USE ISO_C_BINDING USE ISO_FORTRAN_ENV IMPLICIT NONE INCLUDE 'mpif.h' #ifdef DOUBLE_PRECISION INTEGER , PARAMETER :: prec = real64 INTEGER , PARAMETER :: c_prec = C_DOUBLE #else INTEGER , PARAMETER :: prec = real32 INTEGER , PARAMETER :: c_prec = C_FLOAT #endif !*************************************************************! ! ------------------ CHARACTER LENGTHS----- ------------------! ! ************************************************************! !                                                             ! INTEGER , PARAMETER :: SELF_EQN_DEFAULT_LENGTH = 100 ! ------------------------------------------------------------! !*************************************************************! ! ------------------ MATHEMATICAL CONSTANTS ------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! REAL ( prec ), PARAMETER :: pi = 4.0_prec * atan ( 1.0_prec ) REAL ( prec ), PARAMETER :: TOL = epsilon ( 1.0_prec ) REAL ( prec ), PARAMETER :: fillValue = - 999 9.99_prec INTEGER , PARAMETER :: fillValueInt = - 99999 !*************************************************************! ! ----------------- ROOT FINDER CONSTANTS --------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! REAL ( prec ), PARAMETER :: tolerance = 1 0.0 ** ( - 10 ) INTEGER , PARAMETER :: maxInverseIters = 1000 REAL ( prec ), PARAMETER :: newtonTolerance = 1 0.0 ** ( - 8 ) INTEGER , PARAMETER :: newtonMax = 500 !*************************************************************! ! ----------------- TIME STEPPING CONSTANTS ------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! ! Runge-Kutta 3rd Order, low storage constants REAL ( prec ), PARAMETER :: rk3_a ( 1 : 3 ) = ( / 0.0_prec , - 5.0_prec / 9.0_prec , - 15 3.0_prec / 12 8.0_prec / ) REAL ( prec ), PARAMETER :: rk3_b ( 1 : 3 ) = ( / 0.0_prec , 1.0_prec / 3.0_prec , 3.0_prec / 4.0_prec / ) REAL ( prec ), PARAMETER :: rk3_g ( 1 : 3 ) = ( / 1.0_prec / 3.0_prec , 1 5.0_prec / 1 6.0_prec , 8.0_prec / 1 5.0_prec / ) INTEGER , PARAMETER :: EULER = 100 INTEGER , PARAMETER :: RK3 = 203 !*************************************************************! ! ------------------- PHYSICAL CONSTANTS ---------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! ! Time conversion factors REAL ( prec ), PARAMETER :: secondsToMinutes = 1.0_prec / 6 0.0_prec ! conversion for seconds to minutes REAL ( prec ), PARAMETER :: minutesToHours = 1.0_prec / 6 0.0_prec ! conversion for minutes to hours REAL ( prec ), PARAMETER :: hoursToDays = 1.0_prec / 2 4.0_prec ! conversion for hours to days REAL ( prec ), PARAMETER :: daysToMonths = 1 2.0_prec / 36 5.25_prec ! conversion for days to months REAL ( prec ), PARAMETER :: monthsToYears = 1.0_prec / 1 2.0_prec ! conversion for months to years REAL ( prec ), PARAMETER :: daysToSeconds = 8640 0.0_prec !==============================================! ! --------------- Quadrature------------------ ! !==============================================! INTEGER , PARAMETER :: GAUSS = 1 INTEGER , PARAMETER :: GAUSS_LOBATTO = 2 INTEGER , PARAMETER :: CHEBYSHEV_GAUSS = 3 INTEGER , PARAMETER :: CHEBYSHEV_GAUSS_LOBATTO = 4 INTEGER , PARAMETER :: UNIFORM = 3 INTEGER , PARAMETER :: DG = 2000 INTEGER , PARAMETER :: CG = 2001 ! Misc. INTEGER and CHARACTER flag definitions CHARACTER ( 1 ), PARAMETER :: nada = ' ' CHARACTER ( 6 ), PARAMETER :: MsgFmt = '(2x,A)' INTEGER , PARAMETER :: self_FileNameLength = 500 INTEGER , PARAMETER :: self_EquationLength = 210 INTEGER , PARAMETER :: self_QuadratureTypeCharLength = 50 INTEGER , PARAMETER :: self_IntegratorTypeCharLength = 50 END MODULE SELF_Constants","tags":"","loc":"sourcefile/self_constants.f90.html"},{"title":"SELF_Advection3D.f90 – SELF","text":"This file depends on sourcefile~~self_advection3d.f90~~EfferentGraph sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_advection3d.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_advection3d.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_advection3d.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_hdf5.f90 SELF_HDF5.f90 sourcefile~self_mesh.f90->sourcefile~self_hdf5.f90 sourcefile~self_hashtable.f90 SELF_HashTable.f90 sourcefile~self_mesh.f90->sourcefile~self_hashtable.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mpi.f90 SELF_MPI.f90 sourcefile~self_mesh.f90->sourcefile~self_mpi.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_hdf5.f90 sourcefile~self_metadata.f90 SELF_Metadata.f90 sourcefile~self_dg.f90->sourcefile~self_metadata.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~self_dg.f90->sourcefile~self_mpi.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_hdf5.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_hdf5.f90->sourcefile~self_memory.f90 sourcefile~self_metadata.f90->sourcefile~self_hdf5.f90 sourcefile~self_hashtable.f90->sourcefile~self_constants.f90 sourcefile~self_linkedlist.f90 SELF_LinkedList.f90 sourcefile~self_hashtable.f90->sourcefile~self_linkedlist.f90 sourcefile~self_mappeddata.f90->sourcefile~self_constants.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mpi.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_mpi.f90->sourcefile~self_constants.f90 sourcefile~self_mpi.f90->sourcefile~self_memory.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_advection3d.f90~~AfferentGraph sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Advection3D Source Code SELF_Advection3D.f90 Source Code MODULE SELF_Advection3D USE SELF_Constants USE SELF_SupportRoutines USE SELF_Mesh USE SELF_DG USE FEQParse USE FLAP ! Needed for Fortran-C interoperability ! Helps expose HIP kernels to Fortran USE ISO_C_BINDING TYPE , EXTENDS ( DG3D ), PUBLIC :: Advection3D TYPE ( MappedVector3D ), PUBLIC :: velocity TYPE ( Vector3D ), PUBLIC :: plotVelocity TYPE ( Vector3D ), PUBLIC :: plotX TYPE ( EquationParser ), ALLOCATABLE :: boundaryConditionEqn (:) TYPE ( EquationParser ), ALLOCATABLE :: solutionEqn (:) TYPE ( EquationParser ), ALLOCATABLE :: sourceEqn (:) REAL ( prec ) :: simulationTime ! Model Settings ! REAL ( prec ) :: Lx , Ly , Lz ! Domain lengths REAL ( prec ) :: dt ! Default time step size REAL ( prec ) :: outputInterval REAL ( prec ) :: initialTime REAL ( prec ) :: endTime REAL ( prec ) :: diffusivity LOGICAL :: diffusiveFlux INTEGER :: controlDegree INTEGER :: targetDegree INTEGER :: controlQuadrature ! ENUMS in SELF_Constants.f90 INTEGER :: targetQuadrature ! ENUMS in SELF_Constants.f90 CHARACTER ( LEN = self_FileNameLength ) :: icFile CHARACTER ( LEN = self_FileNameLength ) :: meshFile INTEGER :: nxElements INTEGER :: nyElements INTEGER :: nzElements INTEGER :: integrator ! ENUMS needed in SELF_Constants.f90 !! TO DO !! CHARACTER ( LEN = self_EquationLength ) :: velEqnX ! Velocity Equation (x-direction) CHARACTER ( LEN = self_EquationLength ) :: velEqnY ! Velocity Equation (y-direction) CHARACTER ( LEN = self_EquationLength ) :: velEqnZ ! Velocity Equation (z-direction) CHARACTER ( LEN = self_EquationLength ) :: icEqn ! Initial condition Equation CHARACTER ( LEN = self_EquationLength ) :: bcEqn ! Boundary condition Equation LOGICAL :: enableMPI LOGICAL :: gpuAccel CONTAINS PROCEDURE , PUBLIC :: Init => Init_Advection3D PROCEDURE , PUBLIC :: InitFromCLI => InitFromCLI_Advection3D PROCEDURE , PUBLIC :: Free => Free_Advection3D GENERIC , PUBLIC :: SetSolution => SetSolutionFromEquation_Advection3D PROCEDURE , PRIVATE :: SetSolutionFromEquation_Advection3D GENERIC , PUBLIC :: SetSource => SetSourceFromEquation_Advection3D PROCEDURE , PRIVATE :: SetSourceFromEquation_Advection3D GENERIC , PUBLIC :: SetVelocity => SetVelocityFromEquation_Advection3D PROCEDURE , PRIVATE :: SetVelocityFromEquation_Advection3D GENERIC , PUBLIC :: SetBoundaryCondition => SetBoundaryConditionFromEquation_Advection3D PROCEDURE , PRIVATE :: SetBoundaryConditionFromEquation_Advection3D PROCEDURE , PUBLIC :: WriteTecplot => WriteTecplot_Advection3D PROCEDURE , PUBLIC :: ForwardStep => ForwardStep_Advection3D PROCEDURE , PUBLIC :: TimeStepRK3 => TimeStepRK3_Advection3D PROCEDURE , PUBLIC :: Tendency => Tendency_Advection3D PROCEDURE , PUBLIC :: InternalFlux => InternalFlux_Advection3D PROCEDURE , PUBLIC :: SideFlux => SideFlux_Advection3D END TYPE Advection3D PRIVATE :: GetCLIParameters ! Interfaces to GPU kernels ! INTERFACE SUBROUTINE InternalFlux_Advection3D_gpu_wrapper ( flux , solution , velocity , dsdx , N , nVar , nEl ) & BIND ( c , name = \"InternalFlux_Advection3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: flux , solution , velocity , dsdx INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE InternalFlux_Advection3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE InternalDiffusiveFlux_Advection3D_gpu_wrapper ( flux , solutionGradient , dsdx , diffusivity , N , nVar , nEl ) & BIND ( c , name = \"InternalDiffusiveFlux_Advection3D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( c_ptr ) :: flux , solutionGradient , dsdx REAL ( c_prec ), VALUE :: diffusivity INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE InternalDiffusiveFlux_Advection3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE SideFlux_Advection3D_gpu_wrapper ( flux , boundarySol , extSol , velocity , nHat , nScale , N , nVar , nEl ) & BIND ( c , name = \"SideFlux_Advection3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: flux , boundarySol , extSol , velocity , nHat , nScale INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE SideFlux_Advection3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE SideDiffusiveFlux_Advection3D_gpu_wrapper ( flux , boundarySolGradient , extSolGradient , & nHat , nScale , diffusivity , N , nVar , nEl ) & BIND ( c , name = \"SideDiffusiveFlux_Advection3D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( c_ptr ) :: flux , boundarySolGradient , extSolGradient , nHat , nScale REAL ( c_prec ), VALUE :: diffusivity INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE SideDiffusiveFlux_Advection3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE UpdateGRK3_Advection3D_gpu_wrapper ( gRK3 , solution , dSdt , rk3A , rk3G , dt , N , nVar , nEl ) & BIND ( c , name = \"UpdateGRK3_Advection3D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( c_ptr ) :: gRK3 , solution , dSdt REAL ( c_prec ), VALUE :: rk3A , rk3G , dt INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE UpdateGRK3_Advection3D_gpu_wrapper END INTERFACE CONTAINS SUBROUTINE Init_Advection3D ( this , cqType , tqType , cqDegree , tqDegree , nvar , enableMPI , spec ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nvar LOGICAL , INTENT ( in ) :: enableMPI TYPE ( MeshSpec ), INTENT ( in ) :: spec CALL this % decomp % Init ( enableMPI ) ! Load Mesh IF ( enableMPI ) THEN CALL this % mesh % Load ( spec , this % decomp ) ELSE CALL this % mesh % Load ( spec ) ENDIF CALL this % decomp % SetMaxMsg ( this % mesh % nUniqueSides ) CALL this % decomp % setElemToRank ( this % mesh % nElem ) ! Create geometry from mesh CALL this % geometry % GenerateFromMesh (& this % mesh , cqType , tqType , cqDegree , tqDegree ) CALL this % plotSolution % Init (& tqDegree , tqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % dSdt % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % solution % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % solutionGradient % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % flux % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % velocity % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % plotVelocity % Init (& tqDegree , tqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % plotX % Init (& tqDegree , tqType , tqDegree , tqType , 1 ,& this % mesh % nElem ) CALL this % source % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % fluxDivergence % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % workScalar % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % workVector % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % workTensor % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % compFlux % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) ALLOCATE ( this % solutionMetaData ( 1 : nvar )) ALLOCATE ( this % boundaryConditionEqn ( 1 : nvar )) ALLOCATE ( this % solutionEqn ( 1 : nvar )) ALLOCATE ( this % sourceEqn ( 1 : nvar )) END SUBROUTINE Init_Advection3D SUBROUTINE InitFromCLI_Advection3D ( this ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this ! Local TYPE ( COMMAND_LINE_INTERFACE ) :: cli TYPE ( MeshSpec ) :: spec CHARACTER ( self_QuadratureTypeCharLength ) :: cqTypeChar CHARACTER ( self_QuadratureTypeCharLength ) :: tqTypeChar CHARACTER ( self_IntegratorTypeCharLength ) :: integratorChar REAL ( prec ) :: Lx , Ly , Lz ! Domain lengths REAL ( prec ) :: dt ! Default time step size REAL ( prec ) :: diffusivity INTEGER :: controlDegree INTEGER :: targetDegree INTEGER :: controlQuadrature ! ENUMS in SELF_Constants.f90 INTEGER :: targetQuadrature ! ENUMS in SELF_Constants.f90 CHARACTER ( LEN = self_FileNameLength ) :: meshFile INTEGER :: nxElements INTEGER :: nyElements INTEGER :: nzElements INTEGER :: integrator ! ENUMS needed in SELF_Constants.f90 !! TO DO !! CHARACTER ( LEN = self_EquationLength ) :: velEqnX ! Velocity Equation (x-direction) CHARACTER ( LEN = self_EquationLength ) :: velEqnY ! Velocity Equation (y-direction) CHARACTER ( LEN = self_EquationLength ) :: velEqnZ ! Velocity Equation (z-direction) CHARACTER ( LEN = self_EquationLength ) :: icEqn ! Initial condition Equation CHARACTER ( LEN = self_EquationLength ) :: bcEqn ! Boundary condition Equation CHARACTER ( LEN = self_EquationLength ) :: sourceEqn ! Boundary condition Equation LOGICAL :: enableMPI LOGICAL :: enableGPU LOGICAL :: diffusiveFlux REAL ( prec ) :: outputInterval REAL ( prec ) :: initialTime REAL ( prec ) :: endTime TYPE ( EquationParser ) :: eqn ( 1 ) TYPE ( EquationParser ) :: velEqn ( 1 : 3 ) ! Get the CLI parameters ! CALL GetCLIParameters ( cli ) ! Set the CLI parameters ! CALL cli % get ( val = enableMPI , switch = '--mpi' ) CALL cli % get ( val = enableGPU , switch = '--gpu' ) CALL cli % get ( val = meshfile , switch = '--mesh' ) CALL cli % get ( val = dt , switch = \"--time-step\" ) CALL cli % get ( val = outputInterval , switch = \"--output-interval\" ) CALL cli % get ( val = initialTime , switch = \"--initial-time\" ) CALL cli % get ( val = endTime , switch = \"--end-time\" ) CALL cli % get ( val = controlDegree , switch = \"--control-degree\" ) CALL cli % get ( val = targetDegree , switch = \"--target-degree\" ) CALL cli % get ( val = cqTypeChar , switch = \"--control-quadrature\" ) CALL cli % get ( val = tqTypeChar , switch = \"--target-quadrature\" ) CALL cli % get ( val = meshFile , switch = \"--mesh\" ) CALL cli % get ( val = nxElements , switch = \"--nxelements\" ) CALL cli % get ( val = nyElements , switch = \"--nyelements\" ) CALL cli % get ( val = nzElements , switch = \"--nzelements\" ) CALL cli % get ( val = Lx , switch = \"--xlength\" ) CALL cli % get ( val = Ly , switch = \"--ylength\" ) CALL cli % get ( val = Lz , switch = \"--zlength\" ) CALL cli % get ( val = velEqnX , switch = \"--velocity-x\" ) CALL cli % get ( val = velEqnY , switch = \"--velocity-y\" ) CALL cli % get ( val = velEqnY , switch = \"--velocity-z\" ) CALL cli % get ( val = icEqn , switch = \"--initial-condition\" ) CALL cli % get ( val = bcEqn , switch = \"--boundary-condition\" ) CALL cli % get ( val = sourceEqn , switch = \"--source\" ) CALL cli % get ( val = integratorChar , switch = \"--integrator\" ) CALL cli % get ( val = diffusivity , switch = \"--diffusivity\" ) diffusiveFlux = . TRUE . IF ( diffusivity == 0.0_prec ) THEN diffusiveFlux = . FALSE . ELSEIF ( diffusivity < 0.0_prec ) THEN IF ( dt > 0.0_prec ) THEN PRINT * , 'Negative diffusivity provably unstable for forward stepping' PRINT * , 'Invalid diffusivity value. Stopping' STOP ENDIF ENDIF IF ( TRIM ( UpperCase ( cqTypeChar )) == 'GAUSS' ) THEN controlQuadrature = GAUSS ELSEIF ( TRIM ( UpperCase ( cqTypeChar )) == 'GAUSS-LOBATTO' ) THEN controlQuadrature = GAUSS_LOBATTO ELSEIF ( TRIM ( UpperCase ( cqTypeChar )) == 'CHEBYSHEV-GAUSS' ) THEN controlQuadrature = CHEBYSHEV_GAUSS ELSEIF ( TRIM ( UpperCase ( cqTypeChar )) == 'CHEBYSHEV-GAUSS-LOBATTO' ) THEN controlQuadrature = CHEBYSHEV_GAUSS_LOBATTO ELSE PRINT * , 'Invalid Control Quadrature' STOP - 1 END IF IF ( TRIM ( UpperCase ( tqTypeChar )) == 'UNIFORM' ) THEN targetQuadrature = UNIFORM ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'GAUSS' ) THEN targetQuadrature = GAUSS ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'GAUSS-LOBATTO' ) THEN targetQuadrature = GAUSS_LOBATTO ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'CHEBYSHEV-GAUSS' ) THEN targetQuadrature = CHEBYSHEV_GAUSS ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'CHEBYSHEV-GAUSS-LOBATTO' ) THEN targetQuadrature = CHEBYSHEV_GAUSS_LOBATTO ELSE PRINT * , 'Invalid Target Quadrature' STOP - 1 END IF IF ( TRIM ( UpperCase ( integratorChar )) == 'EULER' ) THEN integrator = EULER ELSEIF ( TRIM ( UpperCase ( integratorChar )) == 'WILLIAMSON_RK3' ) THEN integrator = RK3 ELSE PRINT * , 'Invalid time integrator' STOP - 1 END IF IF ( TRIM ( meshfile ) == \"\" ) THEN spec % blockMesh = . TRUE . ELSE spec % blockMesh = . FALSE . ENDIF spec % filename = meshfile spec % filetype = SELF_MESH_ISM_V2_3D spec % blockMesh_nGeo = 1 spec % blockMesh_x0 = 0.0_prec spec % blockMesh_x1 = Lx spec % blockMesh_y0 = 0.0_prec spec % blockMesh_y1 = Ly spec % blockMesh_z0 = 0.0_prec spec % blockMesh_z1 = Lz spec % blockMesh_nElemX = nxElements spec % blockMesh_nElemY = nyElements spec % blockMesh_nElemZ = nzElements CALL this % Init ( controlQuadrature , & targetQuadrature , & controlDegree , & targetDegree , & 1 , enableMPI , & spec ) this % simulationTime = 0.0_prec this % Lx = Lx this % Ly = Ly ! Domain lengths this % Lz = Lz ! Domain lengths this % dt = dt ! Default time step size this % initialTime = initialTime this % simulationTime = initialTime this % endTime = endTime this % outputInterval = outputInterval this % controlDegree = controlDegree this % targetDegree = targetDegree this % controlQuadrature = controlQuadrature ! ENUMS in SELF_Constants.f90 this % targetQuadrature = targetQuadrature ! ENUMS in SELF_Constants.f90 this % meshFile = meshFile this % nxElements = nxElements this % nyElements = nyElements this % nzElements = nzElements this % integrator = integrator ! ENUMS needed in SELF_Constants.f90 !! TO DO !! this % velEqnX = velEqnX ! Velocity Equation (x-direction) this % velEqnY = velEqnY ! Velocity Equation (y-direction) this % velEqnZ = velEqnZ ! Velocity Equation (y-direction) this % icEqn = icEqn ! Initial condition Equation this % bcEqn = bcEqn ! Boundary condition Equation this % enableMPI = enableMPI this % gpuAccel = enableGPU this % diffusivity = diffusivity this % diffusiveFlux = diffusiveFlux eqn ( 1 ) = EquationParser ( icEqn , ( / 'x' , 'y' , 'z' , 't' / )) CALL this % SetSolution ( eqn ) this % solutionEqn ( 1 ) = EquationParser ( icEqn , ( / 'x' , 'y' , 'z' , 't' / )) velEqn ( 1 ) = EquationParser ( velEqnX , ( / 'x' , 'y' , 'z' / )) velEqn ( 2 ) = EquationParser ( velEqnY , ( / 'x' , 'y' , 'z' / )) velEqn ( 3 ) = EquationParser ( velEqnZ , ( / 'x' , 'y' , 'z' / )) CALL this % SetVelocity ( velEqn ) this % boundaryConditionEqn ( 1 ) = EquationParser ( bcEqn , ( / 'x' , 'y' , 'z' , 't' / )) CALL this % SetBoundaryCondition ( this % boundaryConditionEqn ) this % sourceEqn ( 1 ) = EquationParser ( sourceEqn , ( / 'x' , 'y' , 'z' , 't' / )) END SUBROUTINE InitFromCLI_Advection3D SUBROUTINE GetCLIParameters ( cli ) TYPE ( COMMAND_LINE_INTERFACE ), INTENT ( inout ) :: cli CALL cli % init ( progname = \"sadv3d\" , & version = \"v0.0.0\" , & description = \"SELF Advection in 3-D\" , & license = \"ANTI-CAPITALIST SOFTWARE LICENSE (v 1.4)\" , & authors = \"Joseph Schoonover (Fluid Numerics LLC)\" ) CALL cli % add ( switch = \"--mpi\" , & help = \"Enable MPI\" , & act = \"store_true\" , & def = \"false\" , & required = . FALSE .) CALL cli % add ( switch = \"--gpu\" , & help = \"Enable GPU acceleration\" , & act = \"store_true\" , & def = \"false\" , & required = . FALSE .) CALL cli % add ( switch = \"--time-step\" , & switch_ab = \"-dt\" , & help = \"The time step size for the time integrator\" , & def = \"0.001\" , & required = . FALSE .) CALL cli % add ( switch = \"--initial-time\" , & switch_ab = \"-t0\" , & help = \"The initial time level\" , & def = \"0.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--output-interval\" , & switch_ab = \"-oi\" , & help = \"The time between file output\" , & def = \"0.5\" , & required = . FALSE .) CALL cli % add ( switch = \"--end-time\" , & switch_ab = \"-tn\" , & help = \"The final time level\" , & def = \"1.0\" , & required = . FALSE .) ! Get the control degree CALL cli % add ( switch = \"--control-degree\" , & switch_ab = \"-c\" , & help = \"The polynomial degree of the control points.\" // NEW_LINE ( \"A\" ), & def = \"7\" , & required = . FALSE .) ! Get the target degree (assumed for plotting) CALL cli % add ( switch = \"--target-degree\" , & switch_ab = \"-t\" , & help = \"The polynomial degree for the\" // & & \" target points for interpolation.\" // & & \" Typically used for plotting\" // NEW_LINE ( \"A\" ), & def = \"14\" , & required = . FALSE .) ! Get the control quadrature ! Everyone know Legendre-Gauss Quadrature is the best... CALL cli % add ( switch = \"--control-quadrature\" , & switch_ab = \"-cq\" , & def = \"gauss\" , & help = \"The quadrature type for control points.\" // NEW_LINE ( \"A\" ), & choices = \"gauss,gauss-lobatto,chebyshev-gauss,chebyshev-gauss-lobatto\" , & required = . FALSE .) ! Set the target grid quadrature ! Default to uniform (assumed for plotting) CALL cli % add ( switch = \"--target-quadrature\" , & switch_ab = \"-tq\" , & def = \"uniform\" , & help = \"The quadrature type for target points.\" // NEW_LINE ( \"A\" ), & choices = \"gauss,gauss-lobatto,uniform\" , & required = . FALSE .) ! (Optional) Provide a file for a mesh ! Assumed in HOPR or ISM-v2 format CALL cli % add ( switch = \"--mesh\" , & switch_ab = \"-m\" , & help = \"Path to a mesh file for control mesh.\" // NEW_LINE ( \"A\" ), & def = \"\" , & required = . FALSE .) ! (Optional) If a mesh is not provided, you ! can request a structured grid to be generated ! just set the nxelement, nyelements.. CALL cli % add ( switch = \"--nxelements\" , & switch_ab = \"-nx\" , & help = \"The number of elements in the x-direction for structured mesh generation.\" , & def = \"5\" , & required = . FALSE .) CALL cli % add ( switch = \"--nyelements\" , & switch_ab = \"-ny\" , & help = \"The number of elements in the y-direction for structured mesh generation.\" , & def = \"5\" , & required = . FALSE .) CALL cli % add ( switch = \"--nzelements\" , & switch_ab = \"-nz\" , & help = \"The number of elements in the z-direction for structured mesh generation.\" , & def = \"5\" , & required = . FALSE .) ! Alright... now tell me some physical mesh dimensions CALL cli % add ( switch = \"--xlength\" , & switch_ab = \"-lx\" , & help = \"The physical x-scale for structured mesh generation.\" // & \" Ignored if a mesh file is provided\" , & def = \"1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--ylength\" , & switch_ab = \"-ly\" , & help = \"The physical y-scale for structured mesh generation.\" // & \" Ignored if a mesh file is provided\" , & def = \"1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--zlength\" , & switch_ab = \"-lz\" , & help = \"The physical z-scale for structured mesh generation.\" // & \" Ignored if a mesh file is provided\" , & def = \"1.0\" , & required = . FALSE .) ! Set the velocity field CALL cli % add ( switch = \"--velocity-x\" , & switch_ab = \"-vx\" , & help = \"Equation for the x-component of the velocity field\" ,& def = \"vx=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--velocity-y\" , & switch_ab = \"-vy\" , & help = \"Equation for the y-component of the velocity field\" ,& def = \"vy=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--velocity-z\" , & switch_ab = \"-vz\" , & help = \"Equation for the z-component of the velocity field\" ,& def = \"vz=1.0\" , & required = . FALSE .) ! Tracer diffusivity CALL cli % add ( switch = \"--diffusivity\" , & switch_ab = \"-nu\" , & help = \"Tracer diffusivity (applied to all tracers)\" , & def = \"0.0\" , & required = . FALSE .) ! Set the initial conditions ! .. TO DO .. !  > How to handle multiple tracer fields ?? CALL cli % add ( switch = \"--initial-condition\" , & switch_ab = \"-ic\" , & help = \"Equation for the initial tracer distributions\" ,& def = \"f = exp( -( ((x-t)-0.5)&#94;2 + ((y-t)-0.5)&#94;2 + ((z-t)-0.5)&#94;2)/0.01 )\" , & required = . FALSE .) CALL cli % add ( switch = \"--boundary-condition\" , & switch_ab = \"-bc\" , & help = \"Equation for the boundary tracer distributions (can be time dependent!)\" , & def = \"f = exp( -( ((x-t)-0.5)&#94;2 + ((y-t)-0.5)&#94;2 + ((z-t)-0.5)&#94;2)/0.01 )\" , & required = . FALSE .) CALL cli % add ( switch = \"--source\" , & switch_ab = \"-s\" , & help = \"Equation for the source term (can be time dependent!)\" , & def = \"s = 0.0\" , & required = . FALSE .) ! Give me a time integrator CALL cli % add ( switch = \"--integrator\" , & switch_ab = \"-int\" , & help = \"Sets the time integration method. Only 'euler' or 'williamson_rk3'\" , & def = \"williamson_rk3\" , & required = . FALSE .) END SUBROUTINE GetCLIParameters SUBROUTINE Free_Advection3D ( this ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this CALL this % mesh % Free () CALL this % geometry % Free () CALL this % solution % Free () CALL this % dSdt % Free () CALL this % plotSolution % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () CALL this % workScalar % Free () CALL this % workVector % Free () CALL this % workTensor % Free () CALL this % compFlux % Free () CALL this % velocity % Free () CALL this % plotVelocity % Free () CALL this % plotX % Free () DEALLOCATE ( this % solutionMetaData ) DEALLOCATE ( this % boundaryConditionEqn ) DEALLOCATE ( this % solutionEqn ) DEALLOCATE ( this % sourceEqn ) END SUBROUTINE Free_Advection3D SUBROUTINE SetSolutionFromEquation_Advection3D ( this , eqn ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: i , j , k , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: z REAL ( prec ) :: t DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % N DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Get the mesh positions x = this % geometry % x % interior % hostData ( 1 , i , j , k , 1 , iEl ) y = this % geometry % x % interior % hostData ( 2 , i , j , k , 1 , iEl ) z = this % geometry % x % interior % hostData ( 3 , i , j , k , 1 , iEl ) t = this % simulationTime this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & eqn ( iVar ) % Evaluate (( / x , y , z , t / )) ENDDO ENDDO ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN CALL this % solution % interior % UpdateDevice () ENDIF END SUBROUTINE SetSolutionFromEquation_Advection3D SUBROUTINE SetSourceFromEquation_Advection3D ( this , eqn ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: i , j , k , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: z REAL ( prec ) :: t DO iEl = 1 , this % source % nElem DO iVar = 1 , this % source % nVar DO k = 0 , this % source % N DO j = 0 , this % source % N DO i = 0 , this % source % N ! Get the mesh positions x = this % geometry % x % interior % hostData ( 1 , i , j , k , 1 , iEl ) y = this % geometry % x % interior % hostData ( 2 , i , j , k , 1 , iEl ) z = this % geometry % x % interior % hostData ( 3 , i , j , k , 1 , iEl ) t = this % simulationTime this % source % interior % hostData ( i , j , k , iVar , iEl ) = & eqn ( iVar ) % Evaluate (( / x , y , z , t / )) ENDDO ENDDO ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN CALL this % source % interior % UpdateDevice () ENDIF END SUBROUTINE SetSourceFromEquation_Advection3D SUBROUTINE SetVelocityFromEquation_Advection3D ( this , eqn ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : 3 ) ! Local INTEGER :: i , j , k , iEl , iVar , iSide REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: z DO iEl = 1 , this % solution % nElem ! Set the velocity at the element interiors DO k = 0 , this % solution % N DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Get the mesh positions x = this % geometry % x % interior % hostData ( 1 , i , j , k , 1 , iEl ) y = this % geometry % x % interior % hostData ( 2 , i , j , k , 1 , iEl ) z = this % geometry % x % interior % hostData ( 3 , i , j , k , 1 , iEl ) ! Set the velocity in the x-direction this % velocity % interior % hostData ( 1 , i , j , k , 1 , iEl ) = & eqn ( 1 ) % Evaluate (( / x , y , z / )) ! Set the velocity in the y-direction this % velocity % interior % hostData ( 2 , i , j , k , 1 , iEl ) = & eqn ( 2 ) % Evaluate (( / x , y , z / )) ! Set the velocity in the z-direction this % velocity % interior % hostData ( 3 , i , j , k , 1 , iEl ) = & eqn ( 3 ) % Evaluate (( / x , y , z / )) ENDDO ENDDO ENDDO ! Set the velocity at element faces DO iSide = 1 , 6 DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Get the mesh positions x = this % geometry % x % boundary % hostData ( 1 , i , j , 1 , iSide , iEl ) y = this % geometry % x % boundary % hostData ( 2 , i , j , 1 , iSide , iEl ) z = this % geometry % x % boundary % hostData ( 3 , i , j , 1 , iSide , iEl ) ! Set the velocity in the x-direction this % velocity % boundary % hostData ( 1 , i , j , 1 , iSide , iEl ) = & eqn ( 1 ) % Evaluate (( / x , y , z / )) ! Set the velocity in the y-direction this % velocity % boundary % hostData ( 2 , i , j , 1 , iSide , iEl ) = & eqn ( 2 ) % Evaluate (( / x , y , z / )) ! Set the velocity in the z-direction this % velocity % boundary % hostData ( 3 , i , j , 1 , iSide , iEl ) = & eqn ( 3 ) % Evaluate (( / x , y , z / )) ENDDO ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN CALL this % velocity % interior % UpdateDevice () CALL this % velocity % boundary % UpdateDevice () ENDIF END SUBROUTINE SetVelocityFromEquation_Advection3D SUBROUTINE SetBoundaryConditionFromEquation_Advection3D ( this , eqn ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: i , j , iEl , iVar , iSide REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: z DO iEl = 1 , this % solution % nElem DO iSide = 1 , 6 DO iVar = 1 , this % solution % nvar DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! If this element's side has no neighbor assigned ! it is assumed to be a physical boundary. ! In this case, we want to assign the external boundary ! condition. IF ( this % mesh % self_sideInfo % hostData ( 3 , iSide , iEl ) == 0 ) THEN ! Get the mesh positions x = this % geometry % x % boundary % hostData ( 1 , i , j , 1 , iSide , iEl ) y = this % geometry % x % boundary % hostData ( 2 , i , j , 1 , iSide , iEl ) z = this % geometry % x % boundary % hostData ( 3 , i , j , 1 , iSide , iEl ) ! Set the external boundary condition this % solution % extBoundary % hostData ( i , j , iVar , iSide , iEl ) = & eqn ( iVar ) % Evaluate (( / x , y , z , this % simulationTime / )) ENDIF ENDDO ENDDO ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN ! Copy data to the GPU CALL this % solution % extBoundary % UpdateDevice () ENDIF END SUBROUTINE SetBoundaryConditionFromEquation_Advection3D SUBROUTINE ForwardStep_Advection3D ( this , endTime ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: endTime ! Local INTEGER :: nSteps REAL ( prec ) :: dt IF ( this % integrator == RK3 ) THEN ! Step forward dt = this % dt nSteps = INT (( endTime - this % simulationTime ) / dt ) CALL this % TimeStepRK3 ( nSteps ) ! Take any additional steps to reach desired endTime this % dt = endTime - this % simulationTime IF ( this % dt > 0 ) THEN nSteps = 1 CALL this % TimeStepRK3 ( nSteps ) ENDIF ! Reset the time step this % dt = dt ENDIF END SUBROUTINE ForwardStep_Advection3D SUBROUTINE TimeStepRK3_Advection3D ( this , nSteps ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: nSteps ! Local INTEGER :: m , iStep INTEGER :: iEl INTEGER :: iVar INTEGER :: i , j , k TYPE ( hfReal_r5 ) :: gRK3 REAL ( prec ) :: t0 REAL ( prec ) :: dt REAL ( prec ) :: rk3A REAL ( prec ) :: rk3G CALL gRK3 % Alloc ( loBound = ( / 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / this % solution % N ,& this % solution % N ,& this % solution % N ,& this % solution % nVar , & this % solution % nElem / )) dt = this % dt DO iStep = 1 , nSteps t0 = this % simulationTime gRK3 % hostData = 0.0_prec DO m = 1 , 3 ! Loop over RK3 steps CALL this % Tendency ( ) IF ( this % gpuAccel ) THEN rk3A = rk3_a ( m ) rk3G = rk3_g ( m ) CALL UpdateGRK3_Advection3D_gpu_wrapper ( gRK3 % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk3A , rk3G , dt , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % N DO j = 0 , this % solution % N DO i = 0 , this % solution % N gRK3 % hostData ( i , j , k , iVar , iEl ) = rk3_a ( m ) * gRK3 % hostData ( i , j , k , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , k , iVar , iEl ) this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & this % solution % interior % hostData ( i , j , k , iVar , iEl ) + & rk3_g ( m ) * dt * gRK3 % hostData ( i , j , k , iVar , iEl ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF this % simulationTime = this % simulationTime + rk3_b ( m ) * dt ENDDO this % simulationTime = t0 + dt ENDDO CALL gRK3 % Free () END SUBROUTINE TimeStepRK3_Advection3D SUBROUTINE Tendency_Advection3D ( this ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this CALL this % solution % BoundaryInterp ( this % gpuAccel ) IF ( this % diffusiveFlux ) THEN CALL this % CalculateSolutionGradient ( this % gpuAccel ) ENDIF ! Internal Flux calculates both the advective and diffusive flux -- need diffusivity CALL this % InternalFlux ( ) ! Exchange side information between neighboring cells CALL this % solution % SideExchange ( this % mesh , & this % decomp , & this % gpuAccel ) IF ( this % diffusiveFlux ) THEN CALL this % solutionGradient % SideExchange ( this % mesh , & this % decomp , & this % gpuAccel ) ENDIF CALL this % SideFlux ( ) CALL this % CalculateFluxDivergence ( this % gpuAccel ) CALL this % CalculatedSdt ( this % gpuAccel ) END SUBROUTINE Tendency_Advection3D SUBROUTINE SideFlux_Advection3D ( this ) !! Calculates the Advective Flux on element sides using a Lax-Friedrich's upwind Riemann Solver IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this ! Local INTEGER :: i , j , iSide , iVar , iEl REAL ( prec ) :: nhat ( 1 : 3 ) REAL ( prec ) :: nmag REAL ( prec ) :: un REAL ( prec ) :: extState REAL ( prec ) :: intState IF ( this % gpuAccel ) THEN CALL SideFlux_Advection3D_gpu_wrapper ( this % flux % boundaryNormal % deviceData , & this % solution % boundary % deviceData , & this % solution % extBoundary % deviceData , & this % velocity % boundary % deviceData , & this % geometry % nHat % boundary % deviceData , & this % geometry % nScale % boundary % deviceData , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) IF ( this % diffusiveFlux ) THEN CALL SideDiffusiveFlux_Advection3D_gpu_wrapper ( this % flux % boundaryNormal % deviceData , & this % solutionGradient % boundary % deviceData , & this % solutionGradient % extBoundary % deviceData , & this % geometry % nHat % boundary % deviceData , & this % geometry % nScale % boundary % deviceData , & this % diffusivity , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ENDIF ELSE DO iEl = 1 , this % solution % nElem DO iSide = 1 , 6 DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Get the boundary normals on cell edges from the mesh geometry nhat ( 1 : 3 ) = this % geometry % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , iSide , iEl ) ! Calculate the normal velocity at the cell edges un = this % velocity % boundary % hostData ( 1 , i , j , 1 , iSide , iEl ) * nHat ( 1 ) + & this % velocity % boundary % hostData ( 2 , i , j , 1 , iSide , iEl ) * nHat ( 2 ) + & this % velocity % boundary % hostData ( 3 , i , j , 1 , iSide , iEl ) * nHat ( 3 ) ! Pull external and internal state for the Riemann Solver (Lax-Friedrichs) extState = this % solution % extBoundary % hostData ( i , j , iVar , iSide , iEl ) intState = this % solution % boundary % hostData ( i , j , iVar , iSide , iEl ) nmag = this % geometry % nScale % boundary % hostData ( i , j , 1 , iSide , iEl ) ! Calculate the flux this % flux % boundaryNormal % hostData ( i , j , iVar , iSide , iEl ) = 0.5_prec * & ( un * ( intState + extState ) - abs ( un ) * ( extState - intState ) ) * nmag ENDDO ENDDO ENDDO ENDDO ENDDO IF ( this % diffusiveFlux ) THEN DO iEl = 1 , this % solution % nElem DO iSide = 1 , 6 DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % N DO i = 0 , this % solution % N nhat ( 1 : 3 ) = this % geometry % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , iSide , iEl ) nmag = this % geometry % nScale % boundary % hostData ( i , j , 1 , iSide , iEl ) !  Calculate \\nabla{f} \\cdot \\hat{n} on the cell sides extState = this % solutionGradient % extBoundary % hostData ( 1 , i , j , iVar , iSide , iEl ) * nHat ( 1 ) + & this % solutionGradient % extBoundary % hostData ( 2 , i , j , iVar , iSide , iEl ) * nHat ( 2 ) + & this % solutionGradient % extBoundary % hostData ( 3 , i , j , iVar , iSide , iEl ) * nHat ( 3 ) intState = this % solutionGradient % boundary % hostData ( 1 , i , j , iVar , iSide , iEl ) * nHat ( 1 ) + & this % solutionGradient % boundary % hostData ( 2 , i , j , iVar , iSide , iEl ) * nHat ( 2 ) + & this % solutionGradient % boundary % hostData ( 3 , i , j , iVar , iSide , iEl ) * nHat ( 3 ) ! Bassi-Rebay flux is the average of the internal and external diffusive flux vectors. this % flux % boundaryNormal % hostData ( i , j , iVar , iSide , iEl ) = & this % flux % boundaryNormal % hostData ( i , j , iVar , iSide , iEl ) - & 0.5_prec * this % diffusivity * ( extState + intState ) * nmag ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF ! Diffusivity ENDIF ! GPU Acceleration END SUBROUTINE SideFlux_Advection3D SUBROUTINE InternalFlux_Advection3D ( this ) !! Calculates the advective flux using the provided velocity IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this ! Local INTEGER :: i , j , k , iVar , iEl REAL ( prec ) :: Fx , Fy , Fz IF ( this % gpuAccel ) THEN ! When GPU acceleration is enabled (requested by the user) ! we call the gpu wrapper interface, which will call the ! HIP kernel \"under the hood\" ! ! TO DO : Pass the contravariant basis vector to GPU kernel CALL InternalFlux_Advection3D_gpu_wrapper ( this % flux % interior % deviceData ,& this % solution % interior % deviceData , & this % velocity % interior % deviceData , & this % geometry % dsdx % interior % deviceData , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) IF ( this % diffusiveFlux ) THEN CALL InternalDiffusiveFlux_Advection3D_gpu_wrapper ( this % flux % interior % deviceData ,& this % solutionGradient % interior % deviceData , & this % geometry % dsdx % interior % deviceData , & this % diffusivity , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ENDIF ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % N DO j = 0 , this % solution % N DO i = 0 , this % solution % N Fx = this % velocity % interior % hostData ( 1 , i , j , k , 1 , iEl ) * & this % solution % interior % hostData ( i , j , k , iVar , iEl ) Fy = this % velocity % interior % hostData ( 2 , i , j , k , 1 , iEl ) * & this % solution % interior % hostData ( i , j , k , iVar , iEl ) Fz = this % velocity % interior % hostData ( 3 , i , j , k , 1 , iEl ) * & this % solution % interior % hostData ( i , j , k , iVar , iEl ) this % flux % interior % hostData ( 1 , i , j , k , iVar , iEl ) = & this % geometry % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iel ) * Fy + & this % geometry % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iel ) * Fz this % flux % interior % hostData ( 2 , i , j , k , iVar , iEl ) = & this % geometry % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iel ) * Fy + & this % geometry % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iel ) * Fz this % flux % interior % hostData ( 3 , i , j , k , iVar , iEl ) = & this % geometry % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iel ) * Fy + & this % geometry % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iel ) * Fz ENDDO ENDDO ENDDO ENDDO ENDDO ! When diffusivity == 0, then we don't bother calculating the diffusive flux IF ( this % diffusiveFlux ) THEN ! Otherwise, we add the diffusive flux to to the flux vector DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % N DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Diffusive flux is diffusivity coefficient mulitplied by ! solution gradient Fx = this % solutionGradient % interior % hostData ( 1 , i , j , k , iVar , iEl ) * & this % diffusivity Fy = this % solutionGradient % interior % hostData ( 2 , i , j , k , iVar , iEl ) * & this % diffusivity Fz = this % solutionGradient % interior % hostData ( 3 , i , j , k , iVar , iEl ) * & this % diffusivity ! Project the diffusive flux vector onto computational coordinates this % flux % interior % hostData ( 1 , i , j , k , iVar , iEl ) = & this % flux % interior % hostData ( 1 , i , j , k , iVar , iEl ) - & ( this % geometry % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iel ) * Fy + & this % geometry % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iel ) * Fz ) this % flux % interior % hostData ( 2 , i , j , k , iVar , iEl ) = & this % flux % interior % hostData ( 2 , i , j , k , iVar , iEl ) - & ( this % geometry % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iel ) * Fy + & this % geometry % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iel ) * Fz ) this % flux % interior % hostData ( 3 , i , j , k , iVar , iEl ) = & this % flux % interior % hostData ( 3 , i , j , k , iVar , iEl ) - & ( this % geometry % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iel ) * Fy + & this % geometry % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iel ) * Fz ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF ! DiffusiveFlux ENDIF ! GPU Acceleration END SUBROUTINE InternalFlux_Advection3D SUBROUTINE WriteTecplot_Advection3D ( self , filename ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: self CHARACTER ( * ), INTENT ( in ), OPTIONAL :: filename ! Local CHARACTER ( 8 ) :: zoneID INTEGER :: fUnit INTEGER :: iEl , i , j , k CHARACTER ( LEN = self_FileNameLength ) :: tecFile CHARACTER ( 13 ) :: timeStampString IF ( PRESENT ( filename ) ) THEN tecFile = filename ELSE timeStampString = TimeStamp ( self % simulationTime , 's' ) tecFile = 'solution.' // timeStampString // '.tec' ENDIF IF ( self % gpuAccel ) THEN ! Copy data to the CPU CALL self % solution % interior % UpdateHost () ENDIF ! Map the mesh positions to the target grid CALL self % geometry % x % GridInterp ( self % plotX , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL self % solution % GridInterp ( self % plotSolution , gpuAccel = . FALSE .) ! Map the velocity to the target grid CALL self % velocity % GridInterp ( self % plotVelocity , gpuAccel = . FALSE .) ! Let's write some tecplot!! OPEN ( UNIT = NEWUNIT ( fUnit ), & FILE = TRIM ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) ! TO DO :: Adjust for multiple tracer fields WRITE ( fUnit , * ) 'VARIABLES = \"X\", \"Y\", \"Z\", \"tracer\",\"u\",\"v\",\"w\"' DO iEl = 1 , self % solution % nElem ! TO DO :: Get the global element ID WRITE ( zoneID , '(I8.8)' ) iEl WRITE ( fUnit , * ) 'ZONE T=\"el' // trim ( zoneID ) // '\", I=' , self % solution % M + 1 ,& ', J=' , self % solution % M + 1 ,& ', K=' , self % solution % M + 1 , ',F=POINT' DO k = 0 , self % solution % M DO j = 0 , self % solution % M DO i = 0 , self % solution % M WRITE ( fUnit , '(7(E15.7,1x))' ) self % plotX % interior % hostData ( 1 , i , j , k , 1 , iEl ), & self % plotX % interior % hostData ( 2 , i , j , k , 1 , iEl ), & self % plotX % interior % hostData ( 3 , i , j , k , 1 , iEl ), & self % plotSolution % interior % hostData ( i , j , k , 1 , iEl ),& self % plotVelocity % interior % hostData ( 1 , i , j , k , 1 , iEl ),& self % plotVelocity % interior % hostData ( 2 , i , j , k , 1 , iEl ),& self % plotVelocity % interior % hostData ( 3 , i , j , k , 1 , iEl ) ENDDO ENDDO ENDDO ENDDO CLOSE ( UNIT = fUnit ) END SUBROUTINE WriteTecplot_Advection3D END MODULE SELF_Advection3D","tags":"","loc":"sourcefile/self_advection3d.f90.html"},{"title":"SELF_Data.f90 – SELF","text":"This file depends on sourcefile~~self_data.f90~~EfferentGraph sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_data.f90~~AfferentGraph sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~self_advection2d.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~self_advection3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_mesh.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Data Source Code SELF_Data.f90 Source Code ! SELF_Data.F90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self-fluids@fluidnumerics.com ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Data USE SELF_Constants USE SELF_Lagrange USE ISO_C_BINDING IMPLICIT NONE #include \"SELF_Macros.h\" ! ---------------------- Scalars ---------------------- ! TYPE , PUBLIC :: Scalar1D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r3 ) :: interior TYPE ( hfReal_r3 ) :: boundary TYPE ( hfReal_r3 ) :: extBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar1D PROCEDURE , PUBLIC :: Free => Free_Scalar1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar1D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar1D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar1D GENERIC , PUBLIC :: Derivative => Derivative_Scalar1D PROCEDURE , PRIVATE :: Derivative_Scalar1D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar1D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar1D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Scalar1D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Scalar1D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Scalar1D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Scalar1D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Scalar1D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Scalar1D END TYPE Scalar1D TYPE , PUBLIC :: Scalar2D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r4 ) :: interior TYPE ( hfReal_r4 ) :: boundary TYPE ( hfReal_r4 ) :: extBoundary TYPE ( hfReal_r4 ) :: avgBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar2D PROCEDURE , PUBLIC :: Free => Free_Scalar2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar2D GENERIC , PUBLIC :: Gradient => Gradient_Scalar2D PROCEDURE , PRIVATE :: Gradient_Scalar2D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar2D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar2D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Scalar2D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Scalar2D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Scalar2D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Scalar2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Scalar2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Scalar2D END TYPE Scalar2D TYPE , PUBLIC :: Scalar3D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r5 ) :: interior TYPE ( hfReal_r5 ) :: boundary TYPE ( hfReal_r5 ) :: extBoundary TYPE ( hfReal_r5 ) :: avgBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar3D PROCEDURE , PUBLIC :: Free => Free_Scalar3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar3D GENERIC , PUBLIC :: Gradient => Gradient_Scalar3D PROCEDURE , PRIVATE :: Gradient_Scalar3D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar3D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar3D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Scalar3D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Scalar3D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Scalar3D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Scalar3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Scalar3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Scalar3D END TYPE Scalar3D ! ---------------------- Vectors ---------------------- ! TYPE , PUBLIC :: Vector2D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r5 ) :: interior TYPE ( hfReal_r5 ) :: boundary TYPE ( hfReal_r5 ) :: extBoundary TYPE ( hfReal_r4 ) :: boundaryNormal CONTAINS PROCEDURE , PUBLIC :: Init => Init_Vector2D PROCEDURE , PUBLIC :: Free => Free_Vector2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Vector2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Vector2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Vector2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Vector2D GENERIC , PUBLIC :: Gradient => Gradient_Vector2D PROCEDURE , PRIVATE :: Gradient_Vector2D GENERIC , PUBLIC :: Divergence => Divergence_Vector2D PROCEDURE , PRIVATE :: Divergence_Vector2D GENERIC , PUBLIC :: Curl => Curl_Vector2D PROCEDURE , PRIVATE :: Curl_Vector2D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Vector2D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Vector2D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Vector2D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Vector2D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Vector2D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Vector2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Vector2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Vector2D END TYPE Vector2D TYPE , PUBLIC :: Vector3D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r6 ) :: interior TYPE ( hfReal_r6 ) :: boundary TYPE ( hfReal_r6 ) :: extBoundary TYPE ( hfReal_r5 ) :: boundaryNormal CONTAINS PROCEDURE , PUBLIC :: Init => Init_Vector3D PROCEDURE , PUBLIC :: Free => Free_Vector3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Vector3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Vector3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Vector3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Vector3D GENERIC , PUBLIC :: Gradient => Gradient_Vector3D PROCEDURE , PRIVATE :: Gradient_Vector3D GENERIC , PUBLIC :: Divergence => Divergence_Vector3D PROCEDURE , PRIVATE :: Divergence_Vector3D GENERIC , PUBLIC :: Curl => Curl_Vector3D PROCEDURE , PRIVATE :: Curl_Vector3D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Vector3D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Vector3D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Vector3D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Vector3D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Vector3D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Vector3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Vector3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Vector3D END TYPE Vector3D ! ---------------------- Tensors ---------------------- ! TYPE , PUBLIC :: Tensor2D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r6 ) :: interior TYPE ( hfReal_r6 ) :: boundary TYPE ( hfReal_r6 ) :: extBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Tensor2D PROCEDURE , PUBLIC :: Free => Free_Tensor2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Tensor2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Tensor2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Tensor2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Tensor2D PROCEDURE , PUBLIC :: Determinant => Determinant_Tensor2D GENERIC , PUBLIC :: Divergence => Divergence_Tensor2D PROCEDURE , PRIVATE :: Divergence_Tensor2D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Tensor2D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Tensor2D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Tensor2D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Tensor2D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Tensor2D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Tensor2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Tensor2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Tensor2D END TYPE Tensor2D TYPE , PUBLIC :: Tensor3D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r7 ) :: interior TYPE ( hfReal_r7 ) :: boundary TYPE ( hfReal_r7 ) :: extBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Tensor3D PROCEDURE , PUBLIC :: Free => Free_Tensor3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Tensor3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Tensor3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Tensor3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Tensor3D PROCEDURE , PUBLIC :: Determinant => Determinant_Tensor3D GENERIC , PUBLIC :: Divergence => Divergence_Tensor3D PROCEDURE , PRIVATE :: Divergence_Tensor3D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Tensor3D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Tensor3D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Tensor3D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Tensor3D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Tensor3D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Tensor3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Tensor3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Tensor3D END TYPE Tensor3D INTEGER , PARAMETER :: selfStrongForm = 0 INTEGER , PARAMETER :: selfWeakDGForm = 1 INTEGER , PARAMETER :: selfWeakCGForm = 2 INTERFACE SUBROUTINE Determinant_Tensor2D_gpu_wrapper ( tensor_dev , detTensor_dev , N , nVar , nEl ) & bind ( c , name = \"Determinant_Tensor2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: tensor_dev , detTensor_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE Determinant_Tensor2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE Determinant_Tensor3D_gpu_wrapper ( tensor_dev , detTensor_dev , N , nVar , nEl ) & bind ( c , name = \"Determinant_Tensor3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: tensor_dev , detTensor_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE Determinant_Tensor3D_gpu_wrapper END INTERFACE CONTAINS ! -- Scalar1D -- ! SUBROUTINE Init_Scalar1D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 1 , 1 / ), & upBound = ( / N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / nVar , 2 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / nVar , 2 , nElem / )) END SUBROUTINE Init_Scalar1D SUBROUTINE Free_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () END SUBROUTINE Free_Scalar1D SUBROUTINE UpdateHost_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Scalar1D SUBROUTINE UpdateDevice_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Scalar1D SUBROUTINE BoundaryInterp_Scalar1D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_1D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_1D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar1D SUBROUTINE GridInterp_Scalar1D ( SELFStorage , SELFout , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar1D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_1D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_1D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar1D SUBROUTINE Derivative_Scalar1D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar1D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % Derivative_1D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % Derivative_1D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Derivative_Scalar1D FUNCTION AbsMaxInterior_Scalar1D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar1D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar ) ! Local INTEGER :: iEl , iVar , i absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO i = 0 , scalar % N absMax ( iVar ) = MAX ( ABS ( scalar % interior % hostData ( i , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END FUNCTION AbsMaxInterior_Scalar1D FUNCTION AbsMaxBoundary_Scalar1D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar1D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar , 1 : 2 ) ! Local INTEGER :: iEl , iVar , iSide absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iSide = 1 , 2 DO iVar = 1 , scalar % nVar absMax ( iVar , iSide ) = MAX ( ABS ( scalar % boundary % hostData ( iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END FUNCTION AbsMaxBoundary_Scalar1D SUBROUTINE Equals_Scalar1D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFOut TYPE ( Scalar1D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Scalar1D FUNCTION Add_Scalar1D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar1D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Scalar1D FUNCTION Subtract_Scalar1D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar1D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Scalar1D ! -- Scalar2D -- ! SUBROUTINE Init_Scalar2D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 0 , 1 , 1 / ), & upBound = ( / N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / N , nVar , 4 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / N , nVar , 4 , nElem / )) CALL SELFStorage % avgBoundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / N , nVar , 4 , nElem / )) END SUBROUTINE Init_Scalar2D SUBROUTINE Free_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () CALL SELFStorage % avgBoundary % Free () END SUBROUTINE Free_Scalar2D SUBROUTINE UpdateHost_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () CALL SELFStorage % avgBoundary % UpdateHost () END SUBROUTINE UpdateHost_Scalar2D SUBROUTINE UpdateDevice_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () CALL SELFStorage % avgBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Scalar2D SUBROUTINE BoundaryInterp_Scalar2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar2D SUBROUTINE GridInterp_Scalar2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar2D SUBROUTINE Gradient_Scalar2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGradient_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGradient_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Scalar2D FUNCTION AbsMaxInterior_Scalar2D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar2D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar ) ! Local INTEGER :: iEl , iVar , i , j absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N absMax ( iVar ) = MAX ( ABS ( scalar % interior % hostData ( i , j , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Scalar2D FUNCTION AbsMaxBoundary_Scalar2D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar2D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar , 1 : 4 ) ! Local INTEGER :: iEl , iVar , i , iSide absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iSide = 1 , 4 DO iVar = 1 , scalar % nVar DO i = 0 , scalar % N absMax ( iVar , iSide ) = MAX ( ABS ( scalar % boundary % hostData ( i , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Scalar2D SUBROUTINE Equals_Scalar2D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFOut TYPE ( Scalar2D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Scalar2D FUNCTION Add_Scalar2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Scalar2D FUNCTION Subtract_Scalar2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Scalar2D ! -- Scalar3D -- ! SUBROUTINE Init_Scalar3D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) CALL SELFStorage % avgBoundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) END SUBROUTINE Init_Scalar3D SUBROUTINE Free_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () CALL SELFStorage % avgBoundary % Free () END SUBROUTINE Free_Scalar3D SUBROUTINE UpdateHost_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () CALL SELFStorage % avgBoundary % UpdateHost () END SUBROUTINE UpdateHost_Scalar3D SUBROUTINE UpdateDevice_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () CALL SELFStorage % avgBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Scalar3D SUBROUTINE BoundaryInterp_Scalar3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar3D SUBROUTINE GridInterp_Scalar3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar3D SUBROUTINE Gradient_Scalar3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGradient_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGradient_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Scalar3D SUBROUTINE Equals_Scalar3D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFOut TYPE ( Scalar3D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Scalar3D FUNCTION AbsMaxInterior_Scalar3D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar3D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar ) ! Local INTEGER :: iEl , iVar , i , j , k absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N DO i = 0 , scalar % N absMax ( iVar ) = MAX ( ABS ( scalar % interior % hostData ( i , j , k , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Scalar3D FUNCTION AbsMaxBoundary_Scalar3D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar3D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar , 1 : 6 ) ! Local INTEGER :: iEl , iVar , i , j , iSide absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iSide = 1 , 6 DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N absMax ( iVar , iSide ) = MAX ( ABS ( scalar % boundary % hostData ( i , j , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Scalar3D FUNCTION Add_Scalar3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Scalar3D FUNCTION Subtract_Scalar3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Scalar3D ! -- Vector2D -- ! SUBROUTINE Init_Vector2D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 / ), & upBound = ( / 2 , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , N , nVar , 4 , nElem / )) CALL SELFStorage % boundaryNormal % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / N , nVar , 4 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , N , nVar , 4 , nElem / )) END SUBROUTINE Init_Vector2D SUBROUTINE Free_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % boundaryNormal % Free () CALL SELFStorage % extBoundary % Free () END SUBROUTINE Free_Vector2D SUBROUTINE UpdateHost_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % boundaryNormal % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Vector2D SUBROUTINE UpdateDevice_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % boundaryNormal % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Vector2D SUBROUTINE BoundaryInterp_Vector2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Vector2D SUBROUTINE GridInterp_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Vector2D SUBROUTINE Gradient_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGradient_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGradient_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Vector2D SUBROUTINE Divergence_Vector2D ( SELFStorage , SELFOut , dForm , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDGDivergence_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundaryNormal % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDGDivergence_2D ( SELFStorage % interior % hostData , & SELFStorage % boundaryNormal % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDivergence_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDivergence_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END IF END SUBROUTINE Divergence_Vector2D SUBROUTINE Curl_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorCurl_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorCurl_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Curl_Vector2D SUBROUTINE Equals_Vector2D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFOut TYPE ( Vector2D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Vector2D FUNCTION AbsMaxInterior_Vector2D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector2D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar ) ! Local INTEGER :: iEl , iVar , i , j , iDir absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO j = 0 , vector % N DO i = 0 , vector % N DO iDir = 1 , 2 absMax ( iVar ) = MAX ( ABS ( vector % interior % hostData ( iDir , i , j , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Vector2D FUNCTION AbsMaxBoundary_Vector2D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector2D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar , 1 : 4 ) ! Local INTEGER :: iEl , iVar , i , iDir , iSide absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iSide = 1 , 4 DO iVar = 1 , vector % nVar DO i = 0 , vector % N DO iDir = 1 , 2 absMax ( iVar , iSide ) = MAX ( ABS ( vector % boundary % hostData ( iDir , i , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Vector2D FUNCTION Add_Vector2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Vector2D FUNCTION Subtract_Vector2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Vector2D ! -- Vector3D -- ! SUBROUTINE Init_Vector3D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / 3 , N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , N , N , nVar , 6 , nElem / )) CALL SELFStorage % boundaryNormal % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , N , N , nVar , 6 , nElem / )) END SUBROUTINE Init_Vector3D SUBROUTINE Free_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % boundaryNormal % Free () CALL SELFStorage % extBoundary % Free () END SUBROUTINE Free_Vector3D SUBROUTINE UpdateHost_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % boundaryNormal % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Vector3D SUBROUTINE UpdateDevice_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % boundaryNormal % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Vector3D SUBROUTINE BoundaryInterp_Vector3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Vector3D SUBROUTINE GridInterp_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Vector3D SUBROUTINE Gradient_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGradient_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGradient_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Vector3D SUBROUTINE Divergence_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDivergence_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDivergence_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Divergence_Vector3D SUBROUTINE Curl_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorCurl_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorCurl_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Curl_Vector3D FUNCTION AbsMaxInterior_Vector3D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector3D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar ) ! Local INTEGER :: iEl , iVar , i , j , k , iDir absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO k = 0 , vector % N DO j = 0 , vector % N DO i = 0 , vector % N DO iDir = 1 , 3 absMax ( iVar ) = MAX ( ABS ( vector % interior % hostData ( iDir , i , j , k , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Vector3D FUNCTION AbsMaxBoundary_Vector3D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector3D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar , 1 : 6 ) ! Local INTEGER :: iEl , iVar , i , j , iSide , iDir absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iSide = 1 , 6 DO iVar = 1 , vector % nVar DO j = 0 , vector % N DO i = 0 , vector % N DO iDir = 1 , 3 absMax ( iVar , iSide ) = MAX ( ABS ( vector % boundary % hostData ( iDir , i , j , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Vector3D SUBROUTINE Equals_Vector3D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFOut TYPE ( Vector3D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Vector3D FUNCTION Add_Vector3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Vector3D FUNCTION Subtract_Vector3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Vector3D ! -- Tensor2D -- ! SUBROUTINE Init_Tensor2D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , nVar , 4 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , nVar , 4 , nElem / )) END SUBROUTINE Init_Tensor2D SUBROUTINE Free_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () END SUBROUTINE Free_Tensor2D SUBROUTINE UpdateHost_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Tensor2D SUBROUTINE UpdateDevice_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Tensor2D SUBROUTINE BoundaryInterp_Tensor2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Tensor2D SUBROUTINE GridInterp_Tensor2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Tensor2D SUBROUTINE Divergence_Tensor2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorDivergence_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorDivergence_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Divergence_Tensor2D SUBROUTINE Determinant_Tensor2D ( SELFStorage , SELFout , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"Determinant_Tensor2D\" IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j IF ( gpuAccel ) THEN CALL Determinant_Tensor2D_gpu_wrapper ( SELFStorage % interior % deviceData , & SELFOut % interior % deviceData , & SELFStorage % N , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE DO iEl = 1 , SELFStorage % nElem DO iVar = 1 , SELFStorage % nVar DO j = 0 , SELFStorage % N DO i = 0 , SELFStorage % N SELFOut % interior % hostData ( i , j , iVar , iEl ) = SELFStorage % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE Determinant_Tensor2D FUNCTION AbsMaxInterior_Tensor2D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor2D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar ) ! Local INTEGER :: iEl , iVar , i , j , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 absMax ( iVar ) = MAX ( ABS ( tensor % interior % hostData ( row , col , i , j , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Tensor2D FUNCTION AbsMaxBoundary_Tensor2D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor2D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar , 1 : 4 ) ! Local INTEGER :: iEl , iVar , i , iSide , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iSide = 1 , 4 DO iVar = 1 , tensor % nVar DO i = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 absMax ( iVar , iSide ) = MAX ( ABS ( tensor % boundary % hostData ( row , col , i , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Tensor2D SUBROUTINE Equals_Tensor2D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFOut TYPE ( Tensor2D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Tensor2D FUNCTION Add_Tensor2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Tensor2D FUNCTION Subtract_Tensor2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Tensor2D ! -- Tensor3D -- ! SUBROUTINE Init_Tensor3D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , nVar , 6 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , nVar , 6 , nElem / )) END SUBROUTINE Init_Tensor3D SUBROUTINE Free_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () END SUBROUTINE Free_Tensor3D SUBROUTINE UpdateHost_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Tensor3D SUBROUTINE UpdateDevice_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateDevice_Tensor3D SUBROUTINE BoundaryInterp_Tensor3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Tensor3D SUBROUTINE GridInterp_Tensor3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Tensor3D SUBROUTINE Divergence_Tensor3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorDivergence_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorDivergence_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Divergence_Tensor3D SUBROUTINE Determinant_Tensor3D ( SELFStorage , SELFOut , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"Determinant_Tensor3D\" IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k IF ( gpuAccel ) THEN CALL Determinant_Tensor3D_gpu_wrapper ( SELFStorage % interior % deviceData , & SELFOut % interior % deviceData , & SELFStorage % N , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE DO iEl = 1 , SELFStorage % nElem DO iVar = 1 , SELFStorage % nVar DO k = 0 , SELFStorage % N DO j = 0 , SELFStorage % N DO i = 0 , SELFStorage % N SELFOut % interior % hostData ( i , j , k , iVar , iEl ) = & SELFStorage % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl )) - & SELFStorage % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl )) + & SELFStorage % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl )) END DO END DO END DO END DO END DO END IF END SUBROUTINE Determinant_Tensor3D FUNCTION AbsMaxInterior_Tensor3D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor3D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar ) ! Local INTEGER :: iEl , iVar , i , j , k , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO k = 0 , tensor % N DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 absMax ( iVar ) = MAX ( ABS ( tensor % interior % hostData ( row , col , i , j , k , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Tensor3D FUNCTION AbsMaxBoundary_Tensor3D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor3D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar , 1 : 6 ) ! Local INTEGER :: iEl , iVar , i , j , iSide , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iSide = 1 , 6 DO iVar = 1 , tensor % nVar DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 absMax ( iVar , iSide ) = MAX ( ABS ( tensor % boundary % hostData ( row , col , i , j , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Tensor3D SUBROUTINE Equals_Tensor3D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFOut TYPE ( Tensor3D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Tensor3D FUNCTION Add_Tensor3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Tensor3D FUNCTION Subtract_Tensor3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Tensor3D END MODULE SELF_Data","tags":"","loc":"sourcefile/self_data.f90.html"},{"title":"SELF_Mesh.f90 – SELF","text":"This file depends on sourcefile~~self_mesh.f90~~EfferentGraph sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_hdf5.f90 SELF_HDF5.f90 sourcefile~self_mesh.f90->sourcefile~self_hdf5.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_hashtable.f90 SELF_HashTable.f90 sourcefile~self_mesh.f90->sourcefile~self_hashtable.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mpi.f90 SELF_MPI.f90 sourcefile~self_mesh.f90->sourcefile~self_mpi.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_hdf5.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_hdf5.f90->sourcefile~self_memory.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 sourcefile~self_hashtable.f90->sourcefile~self_constants.f90 sourcefile~self_linkedlist.f90 SELF_LinkedList.f90 sourcefile~self_hashtable.f90->sourcefile~self_linkedlist.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_mpi.f90->sourcefile~self_constants.f90 sourcefile~self_mpi.f90->sourcefile~self_memory.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_mesh.f90~~AfferentGraph sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~self_advection2d.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~self_advection3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_mesh.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Mesh Source Code SELF_Mesh.f90 Source Code ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Mesh USE SELF_Constants USE SELF_HashTable USE SELF_Lagrange USE SELF_MPI USE SELF_Data USE SELF_SupportRoutines USE SELF_HDF5 USE HDF5 USE ISO_C_BINDING IMPLICIT NONE #include \"SELF_Macros.h\" ! ========================================================================= ! ! Node, Edge, Face, Element and Connectivity Standard ! ========================================================================= ! ! ! To define the element corner nodes, the side order and side connectivity, ! we follow the standard from CGNS SIDS (CFD General Notation System, ! Standard Interface Data Structures, http: //cgns.sourceforge.net/ ). ! ! Computational coordinate directions are defined as follows ! ! xi1 direction points from \"West\" (xi1=-1) to \"East\" (xi1=1) ! xi2 direction points from \"South\" (xi2=-1) to \"North\" (xi2=1) ! xi3 direction points from \"Bottom\" (xi3=-1) to \"Top\" (xi3=1) ! ! 2-D Hexahedreal Element sides are defined as ! ! Side 1 = South  (xi2 = -1) = [CN1, CN2] ! Side 2 = East   (xi1 = 1) = [CN2, CN3] ! Side 3 = North  (xi2 = 1) = [CN4, CN3] ! Side 4 = West   (xi1 = -1) = [CN1, CN4] ! ! 3-D Hexahedreal Element sides are defined as ! ! Side 1 = Bottom (xi3 = -1) = [CN1, CN4, CN3, CN2] ! Side 2 = South  (xi2 = -1) = [CN1, CN2, CN6, CN5] ! Side 3 = East   (xi1 = 1) = [CN2, CN3, CN7, CN6] ! Side 4 = North  (xi2 = 1) = [CN3, CN4, CN8, CN7] ! Side 5 = West   (xi1 = -1) = [CN1, CN5, CN8, CN4] ! Side 6 = Top    (xi3 = 1) = [CN5, CN6, CN7, CN8] ! ! In 2-D, corner nodes are order counter-clockwise (looking in the -xi3 direction). ! ! CornerNode 1 = South-West = (-1,-1) ! CornerNode 2 = South-East = ( 1,-1) ! CornerNode 3 = North-East = ( 1, 1) ! CornerNode 4 = North-West = (-1, 1) ! ! In 3-D, corner nodes are order counter-clockwise (looking in the -xi3 direction) from ! bottom to top. ! ! CornerNode 1 = Bottom-South-West = (-1,-1,-1) ! CornerNode 2 = Bottom-South-East = ( 1,-1,-1) ! CornerNode 3 = Bottom-North-East = ( 1, 1,-1) ! CornerNode 4 = Bottom-North-West = (-1, 1,-1) ! CornerNode 5 = Top-South-West = (-1,-1, 1) ! CornerNode 6 = Top-South-East = ( 1,-1, 1) ! CornerNode 7 = Top-North-East = ( 1, 1, 1) ! CornerNode 8 = Top-North-West = (-1, 1, 1) ! ! ! Notes: !  * cornerNode attributes have not been implemented yet ! !  * For line segments, quads, and hexes, SELF uses Legendre-Gauss-Lobatto quadrature ! ! ========================================================================= ! ! Element Types - From Table 4.1 of https://www.hopr-project.org/externals/Meshformat.pdf INTEGER , PARAMETER :: selfLineLinear = 1 INTEGER , PARAMETER :: selfLineNonlinear = 2 INTEGER , PARAMETER :: selfTriangleLinear = 3 INTEGER , PARAMETER :: selfQuadLinear = 4 INTEGER , PARAMETER :: selfQuadBilinear = 14 INTEGER , PARAMETER :: selfTriangleNonlinear = 23 INTEGER , PARAMETER :: selfQuadNonlinear = 24 INTEGER , PARAMETER :: selfTetrahedronLinear = 104 INTEGER , PARAMETER :: selfPyramidLinear = 105 INTEGER , PARAMETER :: selfPrismLinear = 106 INTEGER , PARAMETER :: selfHexahedronLinear = 108 INTEGER , PARAMETER :: selfPyramidBilinear = 115 INTEGER , PARAMETER :: selfPrismBilinear = 116 INTEGER , PARAMETER :: selfHexahedronBilinear = 118 INTEGER , PARAMETER :: selfTetrahedronNonlinear = 204 INTEGER , PARAMETER :: selfPyramidNonlinear = 205 INTEGER , PARAMETER :: selfPrismNonlinear = 206 INTEGER , PARAMETER :: selfHexahedronNonlinear = 208 ! INTEGER , PARAMETER :: selfMinNodalValence2D = 4 INTEGER , PARAMETER :: selfMinNodalValence3D = 8 INTEGER , PARAMETER :: selfMaxNodalValence2D = 6 INTEGER , PARAMETER :: selfMaxNodalValence3D = 10 ! Side Ordering INTEGER , PARAMETER :: selfSide2D_South = 1 INTEGER , PARAMETER :: selfSide2D_East = 2 INTEGER , PARAMETER :: selfSide2D_North = 3 INTEGER , PARAMETER :: selfSide2D_West = 4 INTEGER , PARAMETER :: selfSide3D_Bottom = 1 INTEGER , PARAMETER :: selfSide3D_South = 2 INTEGER , PARAMETER :: selfSide3D_East = 3 INTEGER , PARAMETER :: selfSide3D_North = 4 INTEGER , PARAMETER :: selfSide3D_West = 5 INTEGER , PARAMETER :: selfSide3D_Top = 6 ! INTEGER , PARAMETER :: self_BCDefault = 1 INTEGER , PARAMETER :: self_nBCsDefault = 5 !==============================================! ! --------------- File Types------------------ ! !==============================================! INTEGER , PARAMETER :: SELF_MESH_ISM_V2_2D = 1 INTEGER , PARAMETER :: SELF_MESH_ISM_V2_3D = 2 INTEGER , PARAMETER :: SELF_MESH_HOPR_2D = 3 INTEGER , PARAMETER :: SELF_MESH_HOPR_3D = 4 TYPE MeshSpec CHARACTER ( self_FileNameLength ) :: filename INTEGER :: fileType LOGICAL :: blockMesh INTEGER :: blockMesh_nGeo INTEGER :: blockMesh_nElemX INTEGER :: blockMesh_nElemY INTEGER :: blockMesh_nElemZ REAL ( prec ) :: blockMesh_x0 , blockMesh_x1 REAL ( prec ) :: blockMesh_y0 , blockMesh_y1 REAL ( prec ) :: blockMesh_z0 , blockMesh_z1 END TYPE MeshSpec TYPE , PUBLIC :: Mesh1D INTEGER :: nGeo INTEGER :: nElem INTEGER :: nNodes INTEGER :: nCornerNodes INTEGER :: nUniqueNodes INTEGER :: nBCs TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfReal_r1 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh1D PROCEDURE , PUBLIC :: Free => Free_Mesh1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh1D PROCEDURE , PUBLIC :: UniformBlockMesh => UniformBlockMesh_Mesh1D GENERIC , PUBLIC :: Read_HOPr => Read_HOPr_Mesh1D_serial , Read_HOPr_Mesh1D_parallel PROCEDURE , PRIVATE :: Read_HOPr_Mesh1D_serial , Read_HOPr_Mesh1D_parallel PROCEDURE , PUBLIC :: Write_HOPr => Write_HOPr_Mesh1D END TYPE Mesh1D ! Mesh format is set up as the HOPr format ! See https://hopr-project.org/externals/MeshFormat.pdf TYPE , PUBLIC :: Mesh2D INTEGER :: nGeo INTEGER :: nElem INTEGER :: nNodes INTEGER :: nSides INTEGER :: nCornerNodes INTEGER :: nUniqueNodes INTEGER :: nUniqueSides INTEGER :: nBCs TYPE ( hfInt32_r3 ) :: self_sideInfo TYPE ( hfReal_r3 ) :: self_nodeCoords TYPE ( hfReal_r2 ) :: hohq_cornerNodes TYPE ( hfInt32_r2 ) :: hohq_elemInfo TYPE ( hfInt32_r2 ) :: hohq_sideInfo TYPE ( hfReal_r4 ) :: hohq_sideCurves TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r1 ) :: hopr_CGNSCornerMap TYPE ( hfInt32_r2 ) :: hopr_CGNSSideMap TYPE ( hfInt32_r2 ) :: hopr_curveNodeMap TYPE ( hfInt32_r2 ) :: hopr_curveNodeMapInv TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh2D PROCEDURE , PUBLIC :: Free => Free_Mesh2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh2D PROCEDURE , PUBLIC :: UniformBlockMesh => UniformBlockMesh_Mesh2D GENERIC , PUBLIC :: Load => Load_Mesh2D_serial , Load_Mesh2D_parallel PROCEDURE , PRIVATE :: Load_Mesh2D_serial , Load_Mesh2D_parallel GENERIC , PUBLIC :: Read_HOPr => Read_HOPr_Mesh2D_serial , Read_HOPr_Mesh2D_parallel PROCEDURE , PRIVATE :: Read_HOPr_Mesh2D_serial , Read_HOPr_Mesh2D_parallel PROCEDURE , PUBLIC :: Write_HOPr => Write_HOPr_Mesh2D PROCEDURE , PUBLIC :: Read_ISMv2 => Read_ISMv2_Mesh2D PROCEDURE , PRIVATE :: GenerateConnectivity => GenerateConnectivity_Mesh2D END TYPE Mesh2D TYPE , PUBLIC :: Mesh3D INTEGER :: nGeo INTEGER :: nElem INTEGER :: nNodes INTEGER :: nSides INTEGER :: nCornerNodes INTEGER :: nUniqueNodes INTEGER :: nUniqueSides INTEGER :: nBCs TYPE ( hfInt32_r3 ) :: self_sideInfo TYPE ( hfReal_r3 ) :: self_nodeCoords TYPE ( hfReal_r2 ) :: hohq_cornerNodes TYPE ( hfInt32_r2 ) :: hohq_elemInfo TYPE ( hfInt32_r2 ) :: hohq_sideInfo TYPE ( hfReal_r5 ) :: hohq_sideSurfaces TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r1 ) :: hopr_CGNSCornerMap TYPE ( hfInt32_r2 ) :: hopr_CGNSSideMap TYPE ( hfInt32_r2 ) :: hopr_curveNodeMap TYPE ( hfInt32_r3 ) :: hopr_curveNodeMapInv TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh3D PROCEDURE , PUBLIC :: Free => Free_Mesh3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh3D PROCEDURE , PUBLIC :: UniformBlockMesh => UniformBlockMesh_Mesh3D GENERIC , PUBLIC :: Load => Load_Mesh3D_serial , Load_Mesh3D_parallel PROCEDURE , PRIVATE :: Load_Mesh3D_serial , Load_Mesh3D_parallel GENERIC , PUBLIC :: Read_HOPr => Read_HOPr_Mesh3D_serial , Read_HOPr_Mesh3D_parallel PROCEDURE , PRIVATE :: Read_HOPr_Mesh3D_serial , Read_HOPr_Mesh3D_parallel PROCEDURE , PUBLIC :: Write_HOPr => Write_HOPr_Mesh3D END TYPE Mesh3D CONTAINS SUBROUTINE Init_Mesh1D ( myMesh , nGeo , nElem , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs myMesh % nGeo = nGeo myMesh % nElem = nElem myMesh % nNodes = nNodes myMesh % nCornerNodes = nElem * 2 myMesh % nUniqueNodes = 0 myMesh % nBCs = nBCs CALL myMesh % hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nElem / )) CALL myMesh % hopr_nodeCoords % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) END SUBROUTINE Init_Mesh1D SUBROUTINE Free_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nNodes = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % hopr_elemInfo % Free () CALL myMesh % hopr_nodeCoords % Free () CALL myMesh % hopr_globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh1D SUBROUTINE UpdateHost_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh CALL myMesh % hopr_elemInfo % UpdateHost () CALL myMesh % hopr_nodeCoords % UpdateHost () CALL myMesh % hopr_globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () END SUBROUTINE UpdateHost_Mesh1D SUBROUTINE UpdateDevice_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh CALL myMesh % hopr_elemInfo % UpdateDevice () CALL myMesh % hopr_nodeCoords % UpdateDevice () CALL myMesh % hopr_globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () END SUBROUTINE UpdateDevice_Mesh1D SUBROUTINE UniformBlockMesh_Mesh1D ( myMesh , nGeo , nElem , x ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem REAL ( prec ), INTENT ( in ) :: x ( 1 : 2 ) ! Local INTEGER :: iel INTEGER :: nid , nNodes INTEGER :: i REAL ( prec ) :: xU ( 1 : nElem + 1 ) TYPE ( Scalar1D ) :: xLinear TYPE ( Scalar1D ) :: xGeo nNodes = nElem * ( nGeo + 1 ) CALL myMesh % Init ( nGeo , nElem , nNodes , 2 ) ! Set the hopr_nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem + 1 ) ! Create a linear interpolant to interpolate to nGeo grid CALL xLinear % Init ( 1 , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nElem ) CALL xGeo % Init ( nGeo , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nElem ) DO iel = 1 , nElem xLinear % interior % hostData ( 0 : 1 , 1 , iel ) = xU ( iel : iel + 1 ) END DO CALL xLinear % GridInterp ( xGeo ,. FALSE .) ! Set the element information nid = 1 DO iel = 1 , nElem myMesh % hopr_elemInfo % hostData ( 1 , iel ) = selfLineLinear ! Element Type myMesh % hopr_elemInfo % hostData ( 2 , iel ) = 1 ! Element Zone myMesh % hopr_elemInfo % hostData ( 3 , iel ) = nid ! Node Index Start DO i = 0 , nGeo myMesh % hopr_nodeCoords % hostData ( nid ) = xGeo % interior % hostData ( i , 1 , iel ) nid = nid + 1 END DO myMesh % hopr_elemInfo % hostData ( 4 , iel ) = nid - 1 ! Node Index End END DO CALL myMesh % UpdateDevice () CALL xLinear % Free () CALL xGeo % Free () END SUBROUTINE UniformBlockMesh_Mesh1D SUBROUTINE Read_HOPr_Mesh1D_serial ( myMesh , meshFile ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 ! Adapted for 1D Mesh : Note that HOPR does not have 1D mesh output. IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId INTEGER :: nGlobalElem INTEGER :: nLocalNodes INTEGER :: nGeo , nBCs TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfReal_r1 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType ) ! Read local subarray of ElemInfo ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nGlobalElem / )) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs nLocalNodes = hopr_elemInfo % hostData ( 6 , nGlobalElem ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = 1 , & upBound = nLocalNodes ) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) CALL Close_HDF5 ( fileID ) CALL myMesh % Init ( nGeo , nGlobalElem , nLocalNodes , nBCs ) ! Copy data from local arrays into myMesh myMesh % hopr_elemInfo = hopr_elemInfo myMesh % hopr_nodeCoords = hopr_nodeCoords myMesh % hopr_globalNodeIDs = hopr_globalNodeIDs CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () END SUBROUTINE Read_HOPr_Mesh1D_serial SUBROUTINE Read_HOPr_Mesh1D_parallel ( myMesh , meshFile , decomp ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 ! Adapted for 1D Mesh : Note that HOPR does not have 1D mesh output. IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile TYPE ( MPILayer ), INTENT ( inout ) :: decomp ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) INTEGER :: nGlobalElem INTEGER :: firstElem , nLocalElems INTEGER :: firstNode , nLocalNodes INTEGER :: nGeo , nBCs TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfReal_r1 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId , decomp % mpiComm ) CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) CALL decomp % SetElemToRank ( nGlobalElem ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) offset (:) = 0 CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) ! Read local subarray of ElemInfo firstElem = decomp % offsetElem % hostData ( decomp % rankId ) + 1 nLocalElems = decomp % offsetElem % hostData ( decomp % rankId + 1 ) - & decomp % offsetElem % hostData ( decomp % rankId ) ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nLocalElems / )) offset = ( / 0 , firstElem - 1 / ) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo % hostData ( 5 , 1 ) + 1 nLocalNodes = hopr_elemInfo % hostData ( 6 , nLocalElems ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = 1 , & upBound = nLocalNodes ) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes ) gOffset = ( / firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , gOffset ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) CALL Close_HDF5 ( fileID ) CALL myMesh % Init ( nGeo , nLocalElems , nLocalNodes , nBCs ) ! Copy data from local arrays into myMesh myMesh % hopr_elemInfo = hopr_elemInfo myMesh % hopr_nodeCoords = hopr_nodeCoords myMesh % hopr_globalNodeIDs = hopr_globalNodeIDs CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () END SUBROUTINE Read_HOPr_Mesh1D_parallel SUBROUTINE Write_HOPr_Mesh1D ( myMesh , meshFile ) ! Writes mesh output in HOPR format (serial IO only) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL WriteAttribute_HDF5 ( fileId , 'nElems' , myMesh % nElem ) CALL WriteAttribute_HDF5 ( fileId , 'Ngeo' , myMesh % nGeo ) CALL WriteAttribute_HDF5 ( fileId , 'nBCs' , myMesh % nBCs ) CALL WriteArray_HDF5 ( fileId , 'BCType' , myMesh % bcType ) ! Read local subarray of ElemInfo CALL WriteArray_HDF5 ( fileId , 'ElemInfo' , myMesh % hopr_elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs CALL WriteArray_HDF5 ( fileId , 'NodeCoords' , myMesh % hopr_nodeCoords ) CALL WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , myMesh % hopr_globalNodeIDs ) CALL Close_HDF5 ( fileID ) END SUBROUTINE Write_HOPr_Mesh1D SUBROUTINE Init_Mesh2D ( myMesh , nGeo , nElem , nSides , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nSides INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs ! Local INTEGER :: i , j , l myMesh % nGeo = nGeo myMesh % nElem = nElem myMesh % nNodes = nNodes myMesh % nSides = nSides myMesh % nCornerNodes = 0 myMesh % nUniqueNodes = 0 myMesh % nUniqueSides = 0 myMesh % nBCs = nBCs CALL myMesh % hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nElem / )) CALL myMesh % self_sideInfo % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / 5 , 4 , nElem / )) CALL myMesh % hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nSides / )) CALL myMesh % hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , nNodes / )) CALL myMesh % self_nodeCoords % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / 2 , ( nGeo + 1 ) ** 2 , nElem / )) CALL myMesh % hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % hopr_CGNSCornerMap % Alloc ( loBound = 1 , & upBound = 4 ) CALL myMesh % hopr_CGNSSideMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , 4 / )) CALL myMesh % hopr_curveNodeMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , ( nGeo + 1 ) ** 2 / )) CALL myMesh % hopr_curveNodeMapInv % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / nGeo , nGeo / )) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation myMesh % hopr_CGNSCornerMap % hostData ( 1 ) = 1 myMesh % hopr_CGNSCornerMap % hostData ( 2 ) = nGeo + 1 myMesh % hopr_CGNSCornerMap % hostData ( 3 ) = ( nGeo + 1 ) ** 2 myMesh % hopr_CGNSCornerMap % hostData ( 4 ) = nGeo * ( nGeo + 1 ) + 1 l = 0 DO j = 0 , nGeo DO i = 0 , nGeo l = l + 1 myMesh % hopr_curveNodeMap % hostData ( 1 : 2 , l ) = ( / i , j / ) myMesh % hopr_curveNodeMapInv % hostData ( i , j ) = l END DO END DO ! Maps from local corner node id to CGNS side myMesh % hopr_CGNSSideMap % hostData ( 1 : 2 , 1 ) = ( / 1 , 2 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 2 , 2 ) = ( / 2 , 3 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 2 , 3 ) = ( / 4 , 3 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 2 , 4 ) = ( / 1 , 4 / ) END SUBROUTINE Init_Mesh2D SUBROUTINE Free_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nNodes = 0 myMesh % nSides = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % hopr_elemInfo % Free () CALL myMesh % hopr_sideInfo % Free () CALL myMesh % self_sideInfo % Free () CALL myMesh % hopr_nodeCoords % Free () CALL myMesh % self_nodeCoords % Free () CALL myMesh % hopr_CGNSCornerMap % Free () CALL myMesh % hopr_globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh2D SUBROUTINE UpdateHost_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh CALL myMesh % hopr_elemInfo % UpdateHost () CALL myMesh % hopr_sideInfo % UpdateHost () CALL myMesh % self_sideInfo % UpdateHost () CALL myMesh % hopr_nodeCoords % UpdateHost () CALL myMesh % self_nodeCoords % UpdateHost () CALL myMesh % hopr_globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () END SUBROUTINE UpdateHost_Mesh2D SUBROUTINE UpdateDevice_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh CALL myMesh % hopr_elemInfo % UpdateDevice () CALL myMesh % hopr_sideInfo % UpdateDevice () CALL myMesh % self_sideInfo % UpdateDevice () CALL myMesh % hopr_nodeCoords % UpdateDevice () CALL myMesh % self_nodeCoords % UpdateDevice () CALL myMesh % hopr_globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () END SUBROUTINE UpdateDevice_Mesh2D SUBROUTINE UniformBlockMesh_Mesh2D ( myMesh , nGeo , nElem , x ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem ( 1 : 2 ) REAL ( prec ), INTENT ( in ) :: x ( 1 : 4 ) ! Local INTEGER :: iel , jel , nEl , elid INTEGER :: sid , nid , nNodes INTEGER :: nSides INTEGER :: i , j REAL ( prec ) :: xU ( 1 : nElem ( 1 ) + 1 ) REAL ( prec ) :: yU ( 1 : nElem ( 2 ) + 1 ) TYPE ( Vector2D ) :: xLinear TYPE ( Vector2D ) :: xGeo nEl = nElem ( 1 ) * nElem ( 2 ) nNodes = nEl * ( nGeo + 1 ) * ( nGeo + 1 ) nSides = nEl * 4 CALL myMesh % Init ( nGeo , nEl , nSides , nNodes , 1 ) myMesh % nUniqueSides = ( nElem ( 1 ) + 1 ) * nElem ( 2 ) + ( nElem ( 2 ) + 1 ) * nElem ( 1 ) ! Set the hopr_nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem ( 1 ) + 1 ) yU = UniformPoints ( x ( 3 ), x ( 4 ), 1 , nElem ( 2 ) + 1 ) ! Create a linear interpolant to interpolate to nGeo grid CALL xLinear % Init ( 1 , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) CALL xGeo % Init ( nGeo , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) elid = 1 DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) ! x component xLinear % interior % hostData ( 1 , 0 : 1 , 0 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 1 , 1 , elid ) = xU ( iel : iel + 1 ) ! y component xLinear % interior % hostData ( 2 , 0 , 0 : 1 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 1 , 0 : 1 , 1 , elid ) = yU ( jel : jel + 1 ) ! Incremenent the element ID elid = elid + 1 END DO END DO CALL xLinear % GridInterp ( xGeo ,. FALSE .) ! Set the element information nid = 1 sid = 0 elid = 1 DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) myMesh % hopr_elemInfo % hostData ( 1 , elid ) = selfQuadLinear ! Element Type myMesh % hopr_elemInfo % hostData ( 2 , elid ) = 1 ! Element Zone myMesh % hopr_elemInfo % hostData ( 3 , elid ) = sid ! Side Index Start sid = sid + 4 myMesh % hopr_elemInfo % hostData ( 4 , elid ) = sid ! Side Index End myMesh % hopr_elemInfo % hostData ( 5 , elid ) = nid - 1 ! Node Index Start DO j = 0 , nGeo DO i = 0 , nGeo myMesh % hopr_nodeCoords % hostData ( 1 : 2 , nid ) = xGeo % interior % hostData ( 1 : 2 , i , j , 1 , elid ) nid = nid + 1 END DO END DO myMesh % hopr_elemInfo % hostData ( 6 , elid ) = nid ! Node Index End elid = elid + 1 END DO END DO CALL myMesh % GenerateConnectivity () CALL myMesh % UpdateDevice () CALL xLinear % Free () CALL xGeo % Free () END SUBROUTINE UniformBlockMesh_Mesh2D SUBROUTINE Load_Mesh2D_serial ( myMesh , myMeshSpec ) #undef __FUNC__ #define __FUNC__ \"Load_Mesh2D\" IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh TYPE ( MeshSpec ), INTENT ( in ) :: myMeshSpec IF ( myMeshSpec % blockMesh ) THEN CALL myMesh % UniformBlockMesh ( myMeshSpec % blockMesh_nGeo , & ( / myMeshSpec % blockMesh_nElemX , myMeshSpec % blockMesh_nElemY / ), & ( / myMeshSpec % blockMesh_x0 , myMeshSpec % blockMesh_x1 , & myMeshSpec % blockMesh_y0 , myMeshSpec % blockMesh_y1 / )) ELSE IF ( myMeshSpec % fileType == SELF_MESH_ISM_V2_2D ) THEN CALL myMesh % Read_ISMv2 ( myMeshSpec % filename ) ELSEIF ( myMeshSpec % fileType == SELF_MESH_HOPR_2D ) THEN CALL myMesh % Read_HOPr ( myMeshSpec % filename ) ENDIF END IF CALL myMesh % UpdateDevice () END SUBROUTINE Load_Mesh2D_serial SUBROUTINE Load_Mesh2D_parallel ( myMesh , myMeshSpec , decomp ) #undef __FUNC__ #define __FUNC__ \"Load_Mesh2D\" IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh TYPE ( MeshSpec ), INTENT ( in ) :: myMeshSpec TYPE ( MPILayer ), INTENT ( inout ) :: decomp IF ( myMeshSpec % blockMesh ) THEN IF ( decomp % nRanks > 1 ) THEN ! Error out ERROR ( \"Block Mesh only supported in serial\" ) STOP ! TO DO : Safe exit ELSE CALL myMesh % UniformBlockMesh ( myMeshSpec % blockMesh_nGeo , & ( / myMeshSpec % blockMesh_nElemX , myMeshSpec % blockMesh_nElemY / ), & ( / myMeshSpec % blockMesh_x0 , myMeshSpec % blockMesh_x1 , & myMeshSpec % blockMesh_y0 , myMeshSpec % blockMesh_y1 / )) END IF ELSE CALL myMesh % Read_HOPr ( myMeshSpec % filename , decomp ) END IF CALL myMesh % UpdateDevice () END SUBROUTINE Load_Mesh2D_parallel SUBROUTINE Read_ISMv2_Mesh2D ( myMesh , meshFile ) #undef __FUNC__ #define __FUNC__ \"Read_ISMv2_Mesh2D\" IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER :: nNodes , nSides , nElem , nGeo INTEGER :: lnid , nid , usid , lsid , sid , eid INTEGER :: fUnit INTEGER :: i , j CHARACTER ( 100 ) :: line CHARACTER ( 500 ) :: msg REAL ( prec ) :: x ( 1 : 3 ), x0 ( 1 : 2 ), x1 ( 1 : 2 ) REAL ( prec ) :: wSurf ( 1 : 2 ), eSurf ( 1 : 2 ), nSurf ( 1 : 2 ), sSurf ( 1 : 2 ) REAL ( prec ) :: P1 ( 1 : 2 ), P2 ( 1 : 2 ) REAL ( prec ) :: l1 ( 1 : 2 ), l2 ( 1 : 2 ) REAL ( prec ) :: se ( 1 : 2 ), sw ( 1 : 2 ), ne ( 1 : 2 ), nw ( 1 : 2 ) INTEGER :: bCurveFlag ( 1 : 4 ) TYPE ( Lagrange ) :: interp OPEN ( UNIT = NEWUNIT ( fUnit ), & FILE = TRIM ( meshFile ), & FORM = 'FORMATTED' , & STATUS = 'OLD' , & ACCESS = 'SEQUENTIAL' ) READ ( fUnit , * ) line IF ( TRIM ( line ) /= 'ISM-V2' ) THEN msg = 'Unrecognized file format : ' // TRIM ( line ) ERROR ( msg ) STOP END IF ! Number of Nodes, Number of Edges (sides; unique!), number of elements, polynomial degree of elements READ ( fUnit , * ) nNodes , nSides , nElem , nGeo ! HOHQMesh reports interpolant data on Chebyshev Lobatto points ! We want data to be interpolated to Legendre Gauss Lobatto points CALL interp % Init ( nGeo , CHEBYSHEV_GAUSS_LOBATTO , nGeo , GAUSS_LOBATTO ) ! When we initialize the mesh, we set nNodes=nElem*4*(nGeo+1)**2 and ! nSides = nElem*4 since we still use `nNodes` and `nSides` ! in the input correspond to the HOPR definitions of these ! variables. ! `nSides` in HOHQMesh corresponds to nUniqueSides in HOPR and SELF ! `nNodes` in HOHQMesh corresponds to nCornerNodes (unique) in HOPR and SELF CALL myMesh % Init ( nGeo , nElem , nElem * 4 , nElem * ( nGeo + 1 ) ** 2 , self_nBCsDefault ) myMesh % nUniqueSides = nSides myMesh % nCornerNodes = nNodes CALL myMesh % hohq_cornerNodes % Alloc (( / 1 , 1 / ), & ( / 2 , nNodes / )) CALL myMesh % hohq_sideInfo % Alloc (( / 1 , 1 / ), & ( / 6 , nSides / )) CALL myMesh % hohq_elemInfo % Alloc (( / 1 , 1 / ), & ( / 4 , nElem / )) CALL myMesh % hohq_sideCurves % Alloc (( / 1 , 0 , 1 , 1 / ), & ( / 2 , nGeo , 4 , nElem / )) DO nid = 1 , myMesh % nCornerNodes READ ( fUnit , * ) x myMesh % hohq_cornerNodes % hostData ( 1 : 2 , nid ) = x ( 1 : 2 ) END DO DO usid = 1 , myMesh % nUniqueSides READ ( fUnit , * ) myMesh % hohq_sideInfo % hostData ( 1 : 6 , usid ) END DO DO eid = 1 , myMesh % nElem READ ( fUnit , * ) myMesh % hohq_elemInfo % hostData ( 1 : 4 , eid ) READ ( fUnit , * ) bCurveFlag ( 1 : 4 ) DO lsid = 1 , 4 IF ( bCurveFlag ( lsid ) == 1 ) THEN DO i = 0 , nGeo READ ( fUnit , * ) x myMesh % hohq_sideCurves % hostData ( 1 : 2 , i , lsid , eid ) = x ( 1 : 2 ) END DO ELSE ! For non-polynomial sides, create the side curve through interpolation between corner nodes lnid = myMesh % hopr_CGNSSideMap % hostData ( 1 , lsid ) nid = myMesh % hohq_elemInfo % hostData ( lnid , eid ) x0 ( 1 : 2 ) = myMesh % hohq_cornerNodes % hostData ( 1 : 2 , nid ) lnid = myMesh % hopr_CGNSSideMap % hostData ( 2 , lsid ) nid = myMesh % hohq_elemInfo % hostData ( lnid , eid ) x1 ( 1 : 2 ) = myMesh % hohq_cornerNodes % hostData ( 1 : 2 , nid ) DO i = 0 , nGeo myMesh % hohq_sideCurves % hostData ( 1 : 2 , i , lsid , eid ) = 0.5_prec * ( & x0 ( 1 : 2 ) * ( 1.0_prec - interp % controlPoints % hostData ( i )) + & x1 ( 1 : 2 ) * ( interp % controlPoints % hostData ( i ) + 1.0_prec )) END DO END IF END DO READ ( fUnit , * ) line ! TO DO : Parse line for boundary conditions END DO CLOSE ( fUnit ) ! Fill in hopr_elemInfo ! To fill in the element info, we apply the assumption of a mesh with all quadrilateral elements ! with uniform polynomial order sid = 1 nid = 1 DO eid = 1 , myMesh % nElem myMesh % hopr_elemInfo % hostData ( 1 , eid ) = selfQuadLinear ! Element Type myMesh % hopr_elemInfo % hostData ( 2 , eid ) = 1 ! Element Zone myMesh % hopr_elemInfo % hostData ( 3 , eid ) = sid ! Side Index Start sid = sid + 4 myMesh % hopr_elemInfo % hostData ( 4 , eid ) = sid ! Side Index End myMesh % hopr_elemInfo % hostData ( 5 , eid ) = nid - 1 ! Node Index Start nid = nid + ( nGeo + 1 ) ** 2 myMesh % hopr_elemInfo % hostData ( 6 , eid ) = nid ! Node Index End END DO ! Generate the self_nodeCoords through transfinite interpolation with linear blending nid = 1 DO eid = 1 , myMesh % nElem lnid = 1 ! Evaluate for corner points of mapping. This requires computational coordinates ! that include -1 and 1 in each computational direction (e.g. Gauss Lobatto) sw = myMesh % hohq_sideCurves % hostData ( 1 : 2 , 0 , 1 , eid ) se = myMesh % hohq_sideCurves % hostData ( 1 : 2 , nGeo , 1 , eid ) ne = myMesh % hohq_sideCurves % hostData ( 1 : 2 , nGeo , 3 , eid ) nw = myMesh % hohq_sideCurves % hostData ( 1 : 2 , 0 , 3 , eid ) DO j = 0 , nGeo wSurf = myMesh % hohq_sideCurves % hostData ( 1 : 2 , j , 4 , eid ) eSurf = myMesh % hohq_sideCurves % hostData ( 1 : 2 , j , 2 , eid ) l2 = LinearBlend ( interp % controlPoints % hostData ( j )) DO i = 0 , nGeo sSurf = myMesh % hohq_sideCurves % hostData ( 1 : 2 , i , 1 , eid ) nSurf = myMesh % hohq_sideCurves % hostData ( 1 : 2 , i , 3 , eid ) l1 = LinearBlend ( interp % controlPoints % hostData ( i )) P1 = l1 ( 1 ) * wSurf + l1 ( 2 ) * eSurf P2 = l2 ( 1 ) * sSurf + l2 ( 2 ) * nSurf ! Apply transfinite interpolation with linear blending myMesh % self_nodeCoords % hostData ( 1 : 2 , lnid , eid ) = P1 + P2 - & l1 ( 1 ) * ( l2 ( 1 ) * sw + l2 ( 2 ) * nw ) - l1 ( 2 ) * ( l2 ( 1 ) * se + l2 ( 2 ) * ne ) myMesh % hopr_nodeCoords % hostData ( 1 : 2 , nid ) = myMesh % self_nodeCoords % hostData ( 1 : 2 , lnid , eid ) ! Increment node ids nid = nid + 1 lnid = lnid + 1 END DO END DO END DO CALL myMesh % GenerateConnectivity () CALL interp % Free () END SUBROUTINE Read_ISMv2_Mesh2D SUBROUTINE GenerateConnectivity_Mesh2D ( myMesh ) #undef __FUNC__ #define __FUNC__ \"GenerateConnectivity_Mesh2D\" IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh ! Local INTEGER :: nid , unid , cnid , lnid , rnid INTEGER :: eid , sid , lsid , usid , gn1 , gn2 INTEGER :: key1 , key2 , e2 , s2 , e2gn1 INTEGER :: nUniqueSides , flip INTEGER :: side ( 1 : 2 , 1 : myMesh % nUniqueSides ) TYPE ( HashTable ) :: sideTable ! Set the globalNodeIDs !  > Nodes in the nodeCoords list are possibly repeated since elements may share common sides. When the sides are shared !    the nodeCoords have the same x,y values (to machine precision) myMesh % nUniqueNodes = 1 myMesh % hopr_globalNodeIDs % hostData ( 1 ) = 1 DO nid = 2 , myMesh % nNodes unid = myMesh % nUniqueNodes + 1 DO rnid = 1 , nid - 1 IF ( AlmostEqual ( myMesh % hopr_nodeCoords % hostData ( 1 , nid ), myMesh % hopr_nodeCoords % hostData ( 1 , rnid )) . AND . & AlmostEqual ( myMesh % hopr_nodeCoords % hostData ( 2 , nid ), myMesh % hopr_nodeCoords % hostData ( 2 , rnid ))) THEN unid = myMesh % hopr_globalNodeIDs % hostData ( rnid ) EXIT END IF END DO myMesh % hopr_globalNodeIDs % hostData ( nid ) = unid IF ( unid == myMesh % nUniqueNodes + 1 ) THEN myMesh % nUniqueNodes = myMesh % nUniqueNodes + 1 END IF END DO CALL sideTable % Init ( myMesh % nUniqueNodes ) ! Set the sideInfo sid = 1 nUniqueSides = 0 DO eid = 1 , myMesh % nElem DO lsid = 1 , 4 cnid = myMesh % hopr_CGNSSideMap % hostData ( 1 , lsid ) ! Local Corner ID lnid = myMesh % hopr_CGNSCornerMap % hostData ( cnid ) ! Reference to Local Node ID nid = myMesh % hopr_elemInfo % hostData ( 5 , eid ) + lnid ! Add the offSetIndNODE to get the hopr node id gn1 = myMesh % hopr_globalNodeIDs % hostData ( nid ) ! Get the global Node ID for n1 cnid = myMesh % hopr_CGNSSideMap % hostData ( 2 , lsid ) ! Local Corner ID lnid = myMesh % hopr_CGNSCornerMap % hostData ( cnid ) ! Reference to Local Node ID nid = myMesh % hopr_elemInfo % hostData ( 5 , eid ) + lnid ! Add the offSetIndNODE to get the hopr node id gn2 = myMesh % hopr_globalNodeIDs % hostData ( nid ) ! Get the global Node ID for n1 ! Fill side info for eid myMesh % self_sideInfo % hostData ( 1 , lsid , eid ) = selfLineNonlinear ! SideType myMesh % self_sideInfo % hostData ( 2 , lsid , eid ) = 0 ! Global Side ID myMesh % self_sideInfo % hostData ( 3 , lsid , eid ) = 0 ! Neighbor Element ID myMesh % self_sideInfo % hostData ( 4 , lsid , eid ) = 0 ! Encoding for neighbor side ID and flip (10*s2+flip) myMesh % self_sideInfo % hostData ( 5 , lsid , eid ) = 1 ! Boundary Condition ID key1 = MIN ( gn1 , gn2 ) key2 = MAX ( gn1 , gn2 ) IF ( sideTable % ContainsKeys ( key1 , key2 )) THEN ! Get e2, s2, and flip CALL sideTable % GetDataForKeys ( usid , key1 , key2 ) e2 = side ( 1 , usid ) s2 = side ( 2 , usid ) ! Calculate flip ! > Get the starting global node ID for the other element cnid = myMesh % hopr_CGNSSideMap % hostData ( 1 , s2 ) ! Local Corner ID lnid = myMesh % hopr_CGNSCornerMap % hostData ( cnid ) ! Reference to Local Node ID nid = myMesh % hopr_elemInfo % hostData ( 5 , e2 ) + lnid ! Add the offSetIndNODE to get the hopr node id e2gn1 = myMesh % hopr_globalNodeIDs % hostData ( nid ) ! Get the global Node ID for n1 flip = 0 IF ( e2gn1 /= gn1 ) THEN flip = 1 END IF ! Populate information for this element myMesh % self_sideInfo % hostData ( 2 , lsid , eid ) = usid ! Global Side ID myMesh % self_sideInfo % hostData ( 3 , lsid , eid ) = e2 ! Neighbor Element ID myMesh % self_sideInfo % hostData ( 4 , lsid , eid ) = 10 * s2 + flip ! Neighbor Element ID myMesh % self_sideInfo % hostData ( 5 , lsid , eid ) = 0 ! boundary condition id ! Population information for the other element myMesh % self_sideInfo % hostData ( 2 , s2 , e2 ) = usid ! Global Side ID myMesh % self_sideInfo % hostData ( 3 , s2 , e2 ) = eid ! Neighbor Element ID myMesh % self_sideInfo % hostData ( 4 , s2 , e2 ) = 10 * lsid + flip ! Neighbor Element ID myMesh % self_sideInfo % hostData ( 5 , s2 , e2 ) = 0 ! boundary condition id ELSE nUniqueSides = nUniqueSides + 1 side ( 1 , nUniqueSides ) = eid ! Store the element ID side ( 2 , nUniqueSides ) = lsid ! Store the local side ID ! Add the side to the hash table CALL sideTable % AddDataForKeys ( nUniqueSides , key1 , key2 ) END IF sid = sid + 1 END DO END DO CALL sideTable % Free () END SUBROUTINE GenerateConnectivity_Mesh2D SUBROUTINE Read_HOPr_Mesh2D_serial ( myMesh , meshFile ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 ! Adapted for 2D Mesh : Note that HOPR does not have 2D mesh output. IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId INTEGER :: nGlobalElem INTEGER :: nLocalNodes INTEGER :: nLocalSides INTEGER :: nGeo , nBCs INTEGER :: eid , lsid , iSide TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType ) ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nGlobalElem / )) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs nLocalNodes = hopr_elemInfo % hostData ( 6 , nGlobalElem ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , nLocalNodes / )) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) ! Read local subarray of SideInfo nLocalSides = hopr_elemInfo % hostData ( 4 , nGlobalElem ) - hopr_elemInfo % hostData ( 3 , 1 ) ! Allocate space for hopr_sideInfo CALL hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nLocalSides / )) CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) CALL Close_HDF5 ( fileID ) CALL myMesh % Init ( nGeo , nGlobalElem , nLocalSides , nLocalNodes , nBCs ) ! Copy data from local arrays into myMesh myMesh % hopr_elemInfo = hopr_elemInfo myMesh % hopr_nodeCoords = hopr_nodeCoords myMesh % hopr_globalNodeIDs = hopr_globalNodeIDs myMesh % hopr_sideInfo = hopr_sideInfo iSide = 0 DO eid = 1 , myMesh % nElem DO lsid = 1 , 4 iSide = iSide + 1 myMesh % self_sideInfo % hostData ( 1 : 5 , lsid , eid ) = myMesh % hopr_sideInfo % hostData ( 1 : 5 , iSide ) ENDDO ENDDO CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () CALL hopr_sideInfo % Free () END SUBROUTINE Read_HOPr_Mesh2D_serial SUBROUTINE Read_HOPr_Mesh2D_parallel ( myMesh , meshFile , decomp ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 ! Adapted for 2D Mesh : Note that HOPR does not have 2D mesh output. IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile TYPE ( MPILayer ), INTENT ( inout ) :: decomp ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) INTEGER :: nGlobalElem INTEGER :: firstElem , nLocalElems INTEGER :: firstNode , nLocalNodes INTEGER :: firstSide , nLocalSides INTEGER :: nGeo , nBCs INTEGER :: eid , lsid , iSide TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId , decomp % mpiComm ) CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) offset (:) = 0 CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) ! Read local subarray of ElemInfo CALL decomp % SetElemToRank ( nGlobalElem ) firstElem = decomp % offsetElem % hostData ( decomp % rankId ) + 1 nLocalElems = decomp % offsetElem % hostData ( decomp % rankId + 1 ) - & decomp % offsetElem % hostData ( decomp % rankId ) ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nLocalElems / )) offset = ( / 0 , firstElem - 1 / ) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo % hostData ( 5 , 1 ) + 1 nLocalNodes = hopr_elemInfo % hostData ( 6 , nLocalElems ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , nLocalNodes / )) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes ) offset = ( / 0 , firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) ! Read local subarray of SideInfo firstSide = hopr_elemInfo % hostData ( 3 , 1 ) + 1 nLocalSides = hopr_elemInfo % hostData ( 4 , nLocalElems ) - hopr_elemInfo % hostData ( 3 , 1 ) ! Allocate space for hopr_sideInfo CALL hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nLocalSides / )) offset = ( / 0 , firstSide - 1 / ) CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) CALL Close_HDF5 ( fileID ) CALL myMesh % Init ( nGeo , nLocalElems , nLocalSides , nLocalNodes , nBCs ) ! Copy data from local arrays into myMesh myMesh % hopr_elemInfo = hopr_elemInfo myMesh % hopr_nodeCoords = hopr_nodeCoords myMesh % hopr_globalNodeIDs = hopr_globalNodeIDs myMesh % hopr_sideInfo = hopr_sideInfo iSide = 0 DO eid = 1 , myMesh % nElem DO lsid = 1 , 4 iSide = iSide + 1 myMesh % self_sideInfo % hostData ( 1 : 5 , lsid , eid ) = myMesh % hopr_sideInfo % hostData ( 1 : 5 , iSide ) ENDDO ENDDO CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () CALL hopr_sideInfo % Free () END SUBROUTINE Read_HOPr_Mesh2D_parallel SUBROUTINE Write_HOPr_Mesh2D ( myMesh , meshFile ) ! Writes mesh output in HOPR format (serial only) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL WriteAttribute_HDF5 ( fileId , 'nElems' , myMesh % nElem ) CALL WriteAttribute_HDF5 ( fileId , 'Ngeo' , myMesh % nGeo ) CALL WriteAttribute_HDF5 ( fileId , 'nBCs' , myMesh % nBCs ) CALL WriteArray_HDF5 ( fileId , 'BCType' , myMesh % bcType ) ! Write local subarray of ElemInfo CALL WriteArray_HDF5 ( fileId , 'ElemInfo' , myMesh % hopr_elemInfo ) ! Write local subarray of NodeCoords and GlobalNodeIDs CALL WriteArray_HDF5 ( fileId , 'NodeCoords' , myMesh % hopr_nodeCoords ) CALL WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , myMesh % hopr_globalNodeIDs ) ! Write local subarray of SideInfo CALL WriteArray_HDF5 ( fileId , 'SideInfo' , myMesh % hopr_sideInfo ) CALL Close_HDF5 ( fileID ) END SUBROUTINE Write_HOPr_Mesh2D SUBROUTINE Init_Mesh3D ( myMesh , nGeo , nElem , nSides , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nSides INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs ! Local INTEGER :: i , j , k , l myMesh % nElem = nElem myMesh % nGeo = nGeo myMesh % nSides = nSides myMesh % nNodes = nNodes myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = nBCs CALL myMesh % hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nElem / )) CALL myMesh % hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nSides / )) CALL myMesh % self_sideInfo % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / 5 , 6 , nElem / )) CALL myMesh % hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , nNodes / )) CALL myMesh % self_nodeCoords % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / 3 , ( nGeo + 1 ) ** 3 , nElem / )) CALL myMesh % hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % hopr_CGNSCornerMap % Alloc ( loBound = 1 , & upBound = 8 ) CALL myMesh % hopr_CGNSSideMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , 6 / )) CALL myMesh % hopr_curveNodeMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , ( nGeo + 1 ) ** 3 / )) CALL myMesh % hopr_curveNodeMapInv % Alloc ( loBound = ( / 0 , 0 , 0 / ), & upBound = ( / nGeo , nGeo , nGeo / )) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation myMesh % hopr_CGNSCornerMap % hostData ( 1 ) = 1 myMesh % hopr_CGNSCornerMap % hostData ( 2 ) = nGeo + 1 myMesh % hopr_CGNSCornerMap % hostData ( 3 ) = ( nGeo + 1 ) ** 2 myMesh % hopr_CGNSCornerMap % hostData ( 4 ) = nGeo * ( nGeo + 1 ) + 1 myMesh % hopr_CGNSCornerMap % hostData ( 5 ) = nGeo * ( nGeo + 1 ) ** 2 + 1 myMesh % hopr_CGNSCornerMap % hostData ( 6 ) = nGeo * ( nGeo + 1 ) ** 2 + ( nGeo + 1 ) myMesh % hopr_CGNSCornerMap % hostData ( 7 ) = ( nGeo + 1 ) ** 3 myMesh % hopr_CGNSCornerMap % hostData ( 8 ) = nGeo * ( nGeo + 1 ) * ( nGeo + 2 ) + 1 l = 0 DO k = 0 , nGeo DO j = 0 , nGeo DO i = 0 , nGeo l = l + 1 myMesh % hopr_curveNodeMap % hostData ( 1 : 3 , l ) = ( / i , j , k / ) myMesh % hopr_curveNodeMapInv % hostData ( i , j , k ) = l END DO END DO END DO ! Maps from local corner node id to CGNS side myMesh % hopr_CGNSSideMap % hostData ( 1 : 4 , 1 ) = ( / 1 , 4 , 3 , 2 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 4 , 4 ) = ( / 3 , 4 , 8 , 7 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 4 , 5 ) = ( / 1 , 5 , 8 , 4 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) END SUBROUTINE Init_Mesh3D SUBROUTINE Free_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nSides = 0 myMesh % nNodes = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % hopr_elemInfo % Free () CALL myMesh % hopr_sideInfo % Free () CALL myMesh % self_sideInfo % Free () CALL myMesh % hopr_nodeCoords % Free () CALL myMesh % self_nodeCoords % Free () CALL myMesh % hopr_CGNSCornerMap % Free () CALL myMesh % hopr_globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh3D SUBROUTINE UpdateHost_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh CALL myMesh % hopr_elemInfo % UpdateHost () CALL myMesh % hopr_sideInfo % UpdateHost () CALL myMesh % self_sideInfo % UpdateHost () CALL myMesh % hopr_nodeCoords % UpdateHost () CALL myMesh % self_nodeCoords % UpdateHost () CALL myMesh % hopr_globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () END SUBROUTINE UpdateHost_Mesh3D SUBROUTINE UpdateDevice_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh CALL myMesh % hopr_elemInfo % UpdateDevice () CALL myMesh % hopr_sideInfo % UpdateDevice () CALL myMesh % self_sideInfo % UpdateDevice () CALL myMesh % hopr_nodeCoords % UpdateDevice () CALL myMesh % self_nodeCoords % UpdateDevice () CALL myMesh % hopr_globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () END SUBROUTINE UpdateDevice_Mesh3D SUBROUTINE UniformBlockMesh_Mesh3D ( myMesh , nGeo , nElem , x ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem ( 1 : 3 ) REAL ( prec ), INTENT ( in ) :: x ( 1 : 6 ) ! Local INTEGER :: iel , jel , kel , nEl , elid INTEGER :: sid , nid , nNodes INTEGER :: nSides INTEGER :: bcid INTEGER :: i , j , k INTEGER :: nbeid , nbsid , usid , lsid REAL ( prec ) :: xU ( 1 : nElem ( 1 ) + 1 ) REAL ( prec ) :: yU ( 1 : nElem ( 2 ) + 1 ) REAL ( prec ) :: zU ( 1 : nElem ( 3 ) + 1 ) TYPE ( Vector3D ) :: xLinear TYPE ( Vector3D ) :: xGeo nEl = nElem ( 1 ) * nElem ( 2 ) * nElem ( 3 ) nNodes = nEl * ( nGeo + 1 ) * ( nGeo + 1 ) * ( nGeo + 1 ) nSides = nEl * 6 CALL myMesh % Init ( nGeo , nEl , nSides , nNodes , 1 ) myMesh % nUniqueSides = ( nElem ( 1 ) + 1 ) * nElem ( 2 ) * nElem ( 3 ) + & ( nElem ( 2 ) + 1 ) * nElem ( 1 ) * nElem ( 3 ) + & ( nElem ( 3 ) + 1 ) * nElem ( 1 ) * nElem ( 2 ) ! Set the hopr_nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem ( 1 ) + 1 ) yU = UniformPoints ( x ( 3 ), x ( 4 ), 1 , nElem ( 2 ) + 1 ) zU = UniformPoints ( x ( 5 ), x ( 6 ), 1 , nElem ( 3 ) + 1 ) ! Create a linear interpolant to interpolate to nGeo grid CALL xLinear % Init ( 1 , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) CALL xGeo % Init ( nGeo , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) elid = 1 DO kel = 1 , nElem ( 3 ) DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) ! x component xLinear % interior % hostData ( 1 , 0 : 1 , 0 , 0 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 1 , 0 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 0 , 1 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 1 , 1 , 1 , elid ) = xU ( iel : iel + 1 ) ! y component xLinear % interior % hostData ( 2 , 0 , 0 : 1 , 0 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 1 , 0 : 1 , 0 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 0 , 0 : 1 , 1 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 1 , 0 : 1 , 1 , 1 , elid ) = yU ( jel : jel + 1 ) ! z component xLinear % interior % hostData ( 3 , 0 , 0 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) xLinear % interior % hostData ( 3 , 1 , 0 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) xLinear % interior % hostData ( 3 , 0 , 1 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) xLinear % interior % hostData ( 3 , 1 , 1 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) ! Incremenent the element ID elid = elid + 1 END DO END DO END DO CALL xLinear % GridInterp ( xGeo ,. FALSE .) ! Set the element information nid = 1 sid = 0 elid = 1 DO kel = 1 , nElem ( 3 ) DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) myMesh % hopr_elemInfo % hostData ( 1 , elid ) = selfQuadLinear ! Element Type myMesh % hopr_elemInfo % hostData ( 2 , elid ) = 1 ! Element Zone myMesh % hopr_elemInfo % hostData ( 3 , elid ) = sid ! Side Index Start sid = sid + 6 myMesh % hopr_elemInfo % hostData ( 4 , elid ) = sid ! Side Index End myMesh % hopr_elemInfo % hostData ( 5 , elid ) = nid - 1 ! Node Index Start DO k = 0 , nGeo DO j = 0 , nGeo DO i = 0 , nGeo myMesh % hopr_nodeCoords % hostData ( 1 : 3 , nid ) = xGeo % interior % hostData ( 1 : 3 , i , j , k , 1 , elid ) nid = nid + 1 END DO END DO END DO myMesh % hopr_elemInfo % hostData ( 6 , elid ) = nid ! Node Index End elid = elid + 1 END DO END DO END DO ! Set up the side info elid = 1 sid = 0 usid = 0 DO kel = 1 , nElem ( 3 ) DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) ! Bottom Face ! Local Side = 1 IF ( kel == 1 ) THEN sid = sid + 1 usid = usid + 1 ! unique side id myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = 0 ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 0 ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = self_BCDefault ! Boundary condition ID ELSE sid = sid + 1 nbeid = iel + nElem ( 1 ) * ( jel - 1 + nElem ( 2 ) * ( kel - 2 )) ! Get the element id for the element below nbsid = myMesh % hopr_elemInfo % hostData ( 3 , nbeid ) + selfSide3D_Top - 1 ! Get sid for the top face of the element below usid = myMesh % hopr_sideInfo % hostData ( 2 , nbsid ) ! Get the unique side address myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = nbeid ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 10 * selfSide3D_Top ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = 0 ! Boundary condition ID ENDIF ! South Face ! Local Side = 2 IF ( jel == 1 ) THEN sid = sid + 1 usid = usid + 1 ! unique side id myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = 0 ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 0 ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = self_BCDefault ! Boundary condition ID ELSE sid = sid + 1 nbeid = iel + nElem ( 1 ) * ( jel - 2 + nElem ( 2 ) * ( kel - 1 )) ! Get the element id for the element to the south nbsid = myMesh % hopr_elemInfo % hostData ( 3 , nbeid ) + selfSide3D_North - 1 ! Get sid for the north face of the element to  the south usid = myMesh % hopr_sideInfo % hostData ( 2 , nbsid ) ! Get the unique side address myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = nbeid ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 10 * selfSide3D_North ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = 0 ! Boundary condition ID ENDIF ! East Face ! Local Side = 3 sid = sid + 1 IF ( iel == nElem ( 1 )) THEN nbeid = 0 bcid = self_BCDefault ELSE nbeid = iel + 1 + nElem ( 1 ) * ( jel - 1 + nElem ( 2 ) * ( kel - 1 )) ! Get the element id for the element to the east bcid = 0 ENDIF usid = usid + 1 ! unique side id myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = nbeid ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 10 * selfSide3D_West ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = bcid ! Boundary condition ID ! North Face ! Local Side = 4 sid = sid + 1 IF ( jel == nElem ( 2 )) THEN nbeid = 0 bcid = self_BCDefault ELSE nbeid = iel + nElem ( 1 ) * ( jel + nElem ( 2 ) * ( kel - 1 )) ! Get the element id for the element to the north bcid = 0 ENDIF usid = usid + 1 ! unique side id myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = nbeid ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 10 * selfSide3D_South ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = bcid ! Boundary condition ID ! West Face ! Local Side = 5 IF ( iel == 1 ) THEN sid = sid + 1 usid = usid + 1 ! unique side id myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = 0 ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 0 ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = self_BCDefault ! Boundary condition ID ELSE sid = sid + 1 nbeid = iel - 1 + nElem ( 1 ) * ( jel - 1 + nElem ( 2 ) * ( kel - 1 )) ! Get the element id for the element to the west nbsid = myMesh % hopr_elemInfo % hostData ( 3 , nbeid ) + selfSide3D_East - 1 ! Get sid for the east face of the element to the west usid = myMesh % hopr_sideInfo % hostData ( 2 , nbsid ) ! Get the unique side address myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = nbeid ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 10 * selfSide3D_East ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = 0 ! Boundary condition ID ENDIF ! Top Face ! Local Side = 6 sid = sid + 1 IF ( kel == nElem ( 3 )) THEN nbeid = 0 bcid = self_BCDefault ELSE nbeid = iel + nElem ( 1 ) * ( jel - 1 + nElem ( 2 ) * ( kel )) ! Get the element id for the element above bcid = 0 ENDIF usid = usid + 1 ! unique side id myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = nbeid ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 10 * selfSide3D_Bottom ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = bcid ! Boundary condition ID ENDDO ENDDO ENDDO elid = 0 sid = 0 DO kel = 1 , nElem ( 3 ) DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) elid = elid + 1 DO lsid = 1 , 6 sid = sid + 1 myMesh % self_sideInfo % hostData ( 1 : 5 , lsid , elid ) = myMesh % hopr_sideInfo % hostData ( 1 : 5 , sid ) ENDDO ENDDO ENDDO ENDDO CALL myMesh % UpdateDevice () CALL xLinear % Free () CALL xGeo % Free () END SUBROUTINE UniformBlockMesh_Mesh3D SUBROUTINE Load_Mesh3D_serial ( myMesh , myMeshSpec ) #undef __FUNC__ #define __FUNC__ \"Load_Mesh3D\" IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh TYPE ( MeshSpec ), INTENT ( in ) :: myMeshSpec IF ( myMeshSpec % blockMesh ) THEN CALL myMesh % UniformBlockMesh ( myMeshSpec % blockMesh_nGeo , & ( / myMeshSpec % blockMesh_nElemX , myMeshSpec % blockMesh_nElemY , myMeshSpec % blockMesh_nElemZ / ), & ( / myMeshSpec % blockMesh_x0 , myMeshSpec % blockMesh_x1 , & myMeshSpec % blockMesh_y0 , myMeshSpec % blockMesh_y1 , & myMeshSpec % blockMesh_z0 , myMeshSpec % blockMesh_z1 / )) ELSE CALL myMesh % Read_HOPr ( myMeshSpec % filename ) END IF END SUBROUTINE Load_Mesh3D_serial SUBROUTINE Load_Mesh3D_parallel ( myMesh , myMeshSpec , decomp ) #undef __FUNC__ #define __FUNC__ \"Load_Mesh3D\" IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh TYPE ( MeshSpec ), INTENT ( in ) :: myMeshSpec TYPE ( MPILayer ), INTENT ( inout ) :: decomp IF ( myMeshSpec % blockMesh ) THEN IF ( decomp % nRanks > 1 ) THEN ! Error out ERROR ( \"Block Mesh only supported in serial\" ) STOP ! TO DO : Safe exit for serial and parallel ELSE CALL myMesh % UniformBlockMesh ( myMeshSpec % blockMesh_nGeo , & ( / myMeshSpec % blockMesh_nElemX , myMeshSpec % blockMesh_nElemY , myMeshSpec % blockMesh_nElemZ / ), & ( / myMeshSpec % blockMesh_x0 , myMeshSpec % blockMesh_x1 , & myMeshSpec % blockMesh_y0 , myMeshSpec % blockMesh_y1 , & myMeshSpec % blockMesh_z0 , myMeshSpec % blockMesh_z1 / )) END IF ELSE CALL myMesh % Read_HOPr ( myMeshSpec % filename , decomp ) END IF END SUBROUTINE Load_Mesh3D_parallel SUBROUTINE Read_HOPr_Mesh3D_serial ( myMesh , meshFile ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId INTEGER :: nGlobalElem INTEGER :: nLocalNodes INTEGER :: nLocalSides INTEGER :: nGeo , nBCs INTEGER :: eid , lsid , iSide TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType ) ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nGlobalElem / )) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs nLocalNodes = hopr_elemInfo % hostData ( 6 , nGlobalElem ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , nLocalNodes / )) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) ! Read local subarray of SideInfo nLocalSides = hopr_elemInfo % hostData ( 4 , nGlobalElem ) - hopr_elemInfo % hostData ( 3 , 1 ) ! Allocate space for hopr_sideInfo CALL hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nLocalSides / )) CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) CALL Close_HDF5 ( fileID ) CALL myMesh % Init ( nGeo , nGlobalElem , nLocalSides , nLocalNodes , nBCs ) ! Copy data from local arrays into myMesh myMesh % hopr_elemInfo = hopr_elemInfo myMesh % hopr_nodeCoords = hopr_nodeCoords myMesh % hopr_globalNodeIDs = hopr_globalNodeIDs myMesh % hopr_sideInfo = hopr_sideInfo iSide = 0 DO eid = 1 , myMesh % nElem DO lsid = 1 , 6 iSide = iSide + 1 myMesh % self_sideInfo % hostData ( 1 : 5 , lsid , eid ) = myMesh % hopr_sideInfo % hostData ( 1 : 5 , iSide ) ENDDO ENDDO CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () CALL hopr_sideInfo % Free () END SUBROUTINE Read_HOPr_Mesh3D_serial SUBROUTINE Read_HOPr_Mesh3D_parallel ( myMesh , meshFile , decomp ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile TYPE ( MPILayer ), INTENT ( inout ) :: decomp ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) INTEGER :: nGlobalElem INTEGER :: firstElem , nLocalElems INTEGER :: firstNode , nLocalNodes INTEGER :: firstSide , nLocalSides INTEGER :: nGeo , nBCs INTEGER :: eid , lsid , iSide TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId , decomp % mpiComm ) CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) offset (:) = 0 CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) ! Read local subarray of ElemInfo CALL decomp % SetElemToRank ( nGlobalElem ) firstElem = decomp % offsetElem % hostData ( decomp % rankId ) + 1 nLocalElems = decomp % offsetElem % hostData ( decomp % rankId + 1 ) - & decomp % offsetElem % hostData ( decomp % rankId ) ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nLocalElems / )) offset = ( / 0 , firstElem - 1 / ) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo % hostData ( 5 , 1 ) + 1 nLocalNodes = hopr_elemInfo % hostData ( 6 , nLocalElems ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , nLocalNodes / )) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes ) offset = ( / 0 , firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) ! Read local subarray of SideInfo firstSide = hopr_elemInfo % hostData ( 3 , 1 ) + 1 nLocalSides = hopr_elemInfo % hostData ( 4 , nLocalElems ) - hopr_elemInfo % hostData ( 3 , 1 ) ! Allocate space for hopr_sideInfo CALL hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nLocalSides / )) offset = ( / 0 , firstSide - 1 / ) CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) CALL Close_HDF5 ( fileID ) CALL myMesh % Init ( nGeo , nLocalElems , nLocalSides , nLocalNodes , nBCs ) ! Copy data from local arrays into myMesh myMesh % hopr_elemInfo = hopr_elemInfo myMesh % hopr_nodeCoords = hopr_nodeCoords myMesh % hopr_globalNodeIDs = hopr_globalNodeIDs myMesh % hopr_sideInfo = hopr_sideInfo iSide = 0 DO eid = 1 , myMesh % nElem DO lsid = 1 , 6 iSide = iSide + 1 myMesh % self_sideInfo % hostData ( 1 : 5 , lsid , eid ) = myMesh % hopr_sideInfo % hostData ( 1 : 5 , iSide ) ENDDO ENDDO CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () CALL hopr_sideInfo % Free () END SUBROUTINE Read_HOPr_Mesh3D_parallel SUBROUTINE Write_HOPr_Mesh3D ( myMesh , meshFile ) ! Writes mesh output in HOPR format (serial only) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL WriteAttribute_HDF5 ( fileId , 'nElems' , myMesh % nElem ) CALL WriteAttribute_HDF5 ( fileId , 'Ngeo' , myMesh % nGeo ) CALL WriteAttribute_HDF5 ( fileId , 'nBCs' , myMesh % nBCs ) CALL WriteArray_HDF5 ( fileId , 'BCType' , myMesh % bcType ) CALL WriteArray_HDF5 ( fileId , 'ElemInfo' , myMesh % hopr_elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs CALL WriteArray_HDF5 ( fileId , 'NodeCoords' , myMesh % hopr_nodeCoords ) CALL WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , myMesh % hopr_globalNodeIDs ) ! Read local subarray of SideInfo CALL WriteArray_HDF5 ( fileId , 'SideInfo' , myMesh % hopr_sideInfo ) CALL Close_HDF5 ( fileID ) END SUBROUTINE Write_HOPr_Mesh3D !  FUNCTION TransfiniteInterpolation_2D( interp, bCurves, iEl, a, b ) RESULT( P ) !    ! TransfiniteInterpolation !    !  Takes in the six surfaces (south, east, north, west, bottom, top) and evaluates the !    !  bidirectional mapping at xi&#94;1 = a, xi&#94;2 = b, xi&#94;3 = c. The boundary of the computational !    !  coordinate system is assumed to be at +/- 1 in each direction. !    ! !    ! =============================================================================================== ! !    ! DECLARATIONS !    IMPLICIT NONE !    REAL(prec) :: bCurves(1:2,1:4) !    INTEGER :: i,j !    REAL(prec) :: P(1:2) !    ! LOCAL !    REAL(prec)  :: P1(1:2), P2(1:2), P2(1:2) !    REAL(prec)  :: sSurf(1:2), nSurf(1:2), eSurf(1:2), wSurf(1:2) !    REAL(prec)  :: l1(1:2), l2(1:2), l2(1:2) !    REAL(prec)  :: ref(1:2) !    INTEGER     :: i, j, iSurf ! !    ref = (/ -1.0_prec, 1.0_prec /) ! !    ! Transfinite interpolation with linear blending USEs linear lagrange interpolating polynomials !    ! to blend the bounding surfaces. !    ! The linear blending weights in the first computational direction are calculated. ! !    l1 = LinearBlend(a) !    l2 = LinearBlend(b) !    l3 = LinearBlend(c) ! !    ! The bounding surfaces need to be evaluated at the provided computational coordinates ! !    wSurf = bCurves(1:2,4) !    eSurf = bCurves(1:2,2) !    sSurf = bCurves(1:2,1) !    nSurf = bCurves(1:2,3) ! !    ! P1 CONTAINS the interpolation in the first computational coordinate !    ! The first computational coordinate is assumed to vary between the (computational) east and !    ! west boundaries. ! !    P1 = l1(1)*wSurf + l1(2)*eSurf ! !    ! P2 CONTAINS the interpolation in the second computational coordinate !    ! The second computational coordinate is assumed to vary between the (computational) south and !    ! north boundaries. ! !    P2 = l2(1)*sSurf + l2(2)*nSurf ! !    ! P3 CONTAINS the interpolation in the first computational coordinate !    ! The first computational coordinate is assumed to vary between the (computational) bottom and !    ! top boundaries. ! !    P3 = l3(1)*bSurf + l3(2)*tSurf ! !    DO i = 1, 2 ! !      ! Now we need to compute the tensor product of the first and second computational direction !      ! interpolants and subtract from P1. ! !      wSurf = boundingsurfaces % Evaluate( (/ref(i), c/), west + (iEl-1)*6 ) !      eSurf = boundingsurfaces % Evaluate( (/ref(i), c/), east + (iEl-1)*6 ) !      P1 = P1 - l2(i)*( wSurf*l1(1) + eSurf*l1(2) ) ! !      ! Now we need to compute the tensor product of the first and third computational direction !      ! interpolants and subtract from P1. ! !      wSurf = boundingsurfaces % Evaluate( (/b, ref(i)/), west + (iEl-1)*6 ) !      eSurf = boundingsurfaces % Evaluate( (/b, ref(i)/), east + (iEl-1)*6 ) ! !      P1 = P1 - l3(i)*( wSurf*l1(1) + eSurf*l1(2) ) ! !      ! Now we need to compute the tensor product of the second and third computational direction !      ! interpolants and subtract from P2. ! !      sSurf = boundingsurfaces % Evaluate( (/a, ref(i)/), south + (iEl-1)*6 ) !      nSurf = boundingsurfaces % Evaluate( (/a, ref(i)/), north + (iEl-1)*6 ) ! !      P2 = P2 - l3(i)*( sSurf*l2(1) + nSurf*l2(2) ) ! !    ENDDO ! !    ! Next, the compounded tensor product is computed and added to P3. !    DO j = 1,2 !      DO i = 1,2 ! !        wSurf = boundingsurfaces % Evaluate( (/ref(i), ref(j)/), west + (iEl-1)*6 ) !        eSurf = boundingsurfaces % Evaluate( (/ref(i), ref(j)/), east + (iEl-1)*6 ) !        P3 = P3 + l2(i)*l3(j)*( wSurf*l1(1) + eSurf*l1(2) ) ! !      ENDDO !    ENDDO ! !    !Finally, the sum the interpolants is computed to yield the computational coordinate !    P = P1 + P2 + P3 ! !  END FUNCTION TransfiniteInterpolation_2D !  FUNCTION TransfiniteInterpolation( boundingSurfaces, iEl, a, b, c ) RESULT( P ) !    ! TransfiniteInterpolation !    !  Takes in the six surfaces (south, east, north, west, bottom, top) and evaluates the !    !  bidirectional mapping at xi&#94;1 = a, xi&#94;2 = b, xi&#94;3 = c. The boundary of the computational !    !  coordinate system is assumed to be at +/- 1 in each direction. !    ! !    ! =============================================================================================== ! !    ! DECLARATIONS !    IMPLICIT NONE !    TYPE( Surfaces )  :: boundingSurfaces !    INTEGER           :: iEl !    REAL(prec)       :: a, b, c !    REAL(prec)       :: P(1:3) !    ! LOCAL !    REAL(prec)  :: P1(1:3), P2(1:3), P3(1:3) !    REAL(prec)  :: sSurf(1:3), nSurf(1:3), eSurf(1:3), wSurf(1:3), bSurf(1:3), tSurf(1:3) !    REAL(prec)  :: l1(1:2), l2(1:2), l3(1:2) !    REAL(prec)  :: ref(1:2) !    INTEGER     :: i, j, iSurf ! !    ref = (/ -1.0_prec, 1.0_prec /) ! !    ! Transfinite interpolation with linear blending USEs linear lagrange interpolating polynomials !    ! to blend the bounding surfaces. !    ! The linear blending weights in the first computational direction are calculated. ! !    l1 = LinearBlend( a ) !    l2 = LinearBlend( b ) !    l3 = LinearBlend( c ) ! !    ! The bounding surfaces need to be evaluated at the provided computational coordinates ! !    wSurf = boundingSurfaces % Evaluate( (/b, c/), west + (iEl-1)*6 )   ! west !    eSurf = boundingSurfaces % Evaluate( (/b, c/), east + (iEl-1)*6 )   ! east !    sSurf = boundingSurfaces % Evaluate( (/a, c/), south + (iEl-1)*6 )  ! south !    nSurf = boundingSurfaces % Evaluate( (/a, c/), north + (iEl-1)*6 )  ! north !    bSurf = boundingSurfaces % Evaluate( (/a, b/), bottom + (iEl-1)*6 ) ! bottom !    tSurf = boundingSurfaces % Evaluate( (/a, b/), top + (iEl-1)*6 )    ! top ! !    ! P1 CONTAINS the interpolation in the first computational coordinate !    ! The first computational coordinate is assumed to vary between the (computational) east and !    ! west boundaries. ! !    P1 = l1(1)*wSurf + l1(2)*eSurf ! !    ! P2 CONTAINS the interpolation in the second computational coordinate !    ! The second computational coordinate is assumed to vary between the (computational) south and !    ! north boundaries. ! !    P2 = l2(1)*sSurf + l2(2)*nSurf ! !    ! P3 CONTAINS the interpolation in the first computational coordinate !    ! The first computational coordinate is assumed to vary between the (computational) bottom and !    ! top boundaries. ! !    P3 = l3(1)*bSurf + l3(2)*tSurf ! !    DO i = 1, 2 ! !      ! Now we need to compute the tensor product of the first and second computational direction !      ! interpolants and subtract from P1. ! !      wSurf = boundingsurfaces % Evaluate( (/ref(i), c/), west + (iEl-1)*6 ) !      eSurf = boundingsurfaces % Evaluate( (/ref(i), c/), east + (iEl-1)*6 ) !      P1 = P1 - l2(i)*( wSurf*l1(1) + eSurf*l1(2) ) ! !      ! Now we need to compute the tensor product of the first and third computational direction !      ! interpolants and subtract from P1. ! !      wSurf = boundingsurfaces % Evaluate( (/b, ref(i)/), west + (iEl-1)*6 ) !      eSurf = boundingsurfaces % Evaluate( (/b, ref(i)/), east + (iEl-1)*6 ) ! !      P1 = P1 - l3(i)*( wSurf*l1(1) + eSurf*l1(2) ) ! !      ! Now we need to compute the tensor product of the second and third computational direction !      ! interpolants and subtract from P2. ! !      sSurf = boundingsurfaces % Evaluate( (/a, ref(i)/), south + (iEl-1)*6 ) !      nSurf = boundingsurfaces % Evaluate( (/a, ref(i)/), north + (iEl-1)*6 ) ! !      P2 = P2 - l3(i)*( sSurf*l2(1) + nSurf*l2(2) ) ! !    ENDDO ! !    ! Next, the compounded tensor product is computed and added to P3. !    DO j = 1,2 !      DO i = 1,2 ! !        wSurf = boundingsurfaces % Evaluate( (/ref(i), ref(j)/), west + (iEl-1)*6 ) !        eSurf = boundingsurfaces % Evaluate( (/ref(i), ref(j)/), east + (iEl-1)*6 ) !        P3 = P3 + l2(i)*l3(j)*( wSurf*l1(1) + eSurf*l1(2) ) ! !      ENDDO !    ENDDO ! !    !Finally, the sum the interpolants is computed to yield the computational coordinate !    P = P1 + P2 + P3 ! !  END FUNCTION TransfiniteInterpolation FUNCTION Unidirectional ( valLeft , valRight , a ) RESULT ( P ) ! ! =============================================================================================== ! ! DECLARATIONS IMPLICIT NONE REAL ( prec ) :: valLeft ( 1 : 3 ), valRight ( 1 : 3 ) REAL ( prec ) :: a REAL ( prec ) :: P ( 1 : 3 ) P = 0.5_prec * (( 1.0_prec - a ) * valLeft + ( 1.0_prec + a ) * valRight ) END FUNCTION Unidirectional FUNCTION LinearBlend ( a ) RESULT ( weights ) IMPLICIT NONE REAL ( prec ) :: a REAL ( prec ) :: weights ( 1 : 2 ) weights ( 1 ) = 0.5_prec * ( 1.0_prec - a ) weights ( 2 ) = 0.5_prec * ( 1.0_prec + a ) END FUNCTION LinearBlend END MODULE SELF_Mesh","tags":"","loc":"sourcefile/self_mesh.f90.html"},{"title":"SELF_MPI.f90 – SELF","text":"This file depends on sourcefile~~self_mpi.f90~~EfferentGraph sourcefile~self_mpi.f90 SELF_MPI.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_mpi.f90->sourcefile~self_memory.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_mpi.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_mpi.f90~~AfferentGraph sourcefile~self_mpi.f90 SELF_MPI.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_mesh.f90->sourcefile~self_mpi.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mpi.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_dg.f90->sourcefile~self_mpi.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~self_advection2d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_mesh.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_MPI Source Code SELF_MPI.f90 Source Code ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_MPI USE SELF_Constants USE SELF_Memory USE ISO_C_BINDING IMPLICIT NONE #include \"SELF_Macros.h\" TYPE MPILayer LOGICAL :: mpiEnabled INTEGER :: mpiComm INTEGER :: mpiPrec INTEGER :: rankId INTEGER :: nRanks INTEGER :: nElem INTEGER :: maxMsg INTEGER :: msgCount TYPE ( hfInt32_r1 ) :: elemToRank TYPE ( hfInt32_r1 ) :: offSetElem TYPE ( hfInt32_r2 ) :: requests CONTAINS PROCEDURE :: Init => Init_MPILayer PROCEDURE :: Free => Free_MPILayer PROCEDURE :: SetElemToRank PROCEDURE :: SetMaxMsg PROCEDURE , PUBLIC :: FinalizeMPIExchangeAsync END TYPE MPILayer CONTAINS SUBROUTINE Init_MPILayer ( this , enableMPI ) #undef __FUNC__ #define __FUNC__ \"Init_MPILayer\" IMPLICIT NONE CLASS ( MPILayer ), INTENT ( out ) :: this LOGICAL , INTENT ( in ) :: enableMPI ! Local INTEGER :: ierror CHARACTER ( 30 ) :: msg this % mpiComm = 0 this % mpiPrec = prec this % rankId = 0 this % nRanks = 1 this % nElem = 0 this % mpiEnabled = enableMPI IF ( enableMPI ) THEN this % mpiComm = MPI_COMM_WORLD CALL MPI_INIT ( ierror ) CALL MPI_COMM_RANK ( this % mpiComm , this % rankId , ierror ) CALL MPI_COMM_SIZE ( this % mpiComm , this % nRanks , ierror ) END IF IF ( prec == real32 ) THEN this % mpiPrec = MPI_FLOAT ELSE this % mpiPrec = MPI_DOUBLE END IF CALL this % offSetElem % Alloc ( 0 , this % nRanks ) WRITE ( msg , '(I5)' ) this % rankId msg = \"Greetings from rank \" // TRIM ( msg ) // \".\" INFO ( TRIM ( msg )) END SUBROUTINE Init_MPILayer SUBROUTINE Free_MPILayer ( this ) IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this CALL this % offSetElem % Free () CALL this % requests % Free () CALL this % elemToRank % Free () END SUBROUTINE Free_MPILayer SUBROUTINE SetMaxMsg ( this , maxMsg ) IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: maxMsg CALL this % requests % Alloc (( / 1 , 1 / ), & ( / maxMsg , 2 / )) this % maxMsg = maxMsg END SUBROUTINE SetMaxMsg SUBROUTINE SetElemToRank ( this , nElem ) IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: nElem ! Local INTEGER :: iel this % nElem = nElem CALL this % elemToRank % Alloc ( 1 , nElem ) CALL DomainDecomp ( nElem , & this % nRanks , & this % offSetElem % hostData ) DO iel = 1 , nElem CALL ElemToRank ( this % nRanks , & this % offSetElem % hostData , & iel , & this % elemToRank % hostData ( iel )) END DO CALL this % offSetElem % UpdateDevice () CALL this % elemToRank % UpdateDevice () END SUBROUTINE SetElemToRank SUBROUTINE DomainDecomp ( nElems , nDomains , offSetElem ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 4 IMPLICIT NONE INTEGER , INTENT ( in ) :: nElems INTEGER , INTENT ( in ) :: nDomains INTEGER , INTENT ( out ) :: offsetElem ( 0 : nDomains ) ! Local INTEGER :: nLocalElems INTEGER :: remainElems INTEGER :: iDom nLocalElems = nElems / nDomains remainElems = nElems - nLocalElems * nDomains DO iDom = 0 , nDomains - 1 offSetElem ( iDom ) = iDom * nLocalElems + MIN ( iDom , remainElems ) END DO offSetElem ( nDomains ) = nElems END SUBROUTINE DomainDecomp SUBROUTINE ElemToRank ( nDomains , offsetElem , elemID , domain ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 7 !   \"Find domain containing element index\" ! IMPLICIT NONE INTEGER , INTENT ( in ) :: nDomains INTEGER , INTENT ( in ) :: offsetElem ( 0 : nDomains ) INTEGER , INTENT ( in ) :: elemID INTEGER , INTENT ( out ) :: domain ! Local INTEGER :: maxSteps INTEGER :: low , up , mid INTEGER :: i domain = 0 maxSteps = INT ( LOG10 ( REAL ( nDomains )) / LOG10 ( 2.0 )) + 1 low = 0 up = nDomains - 1 IF ( offsetElem ( low ) < elemID . AND . elemID <= offsetElem ( low + 1 )) THEN domain = low ELSEIF ( offsetElem ( up ) < elemID . AND . elemID <= offsetElem ( up + 1 )) THEN domain = up ELSE DO i = 1 , maxSteps mid = ( up - low ) / 2 + low IF ( offsetElem ( mid ) < elemID . AND . elemID <= offsetElem ( mid + 1 )) THEN domain = mid RETURN ELSEIF ( elemID > offsetElem ( mid + 1 )) THEN low = mid + 1 ELSE up = mid END IF END DO END IF END SUBROUTINE ElemToRank SUBROUTINE FinalizeMPIExchangeAsync ( mpiHandler ) CLASS ( MPILayer ), INTENT ( inout ) :: mpiHandler ! Local INTEGER :: ierror CALL MPI_WaitAll ( mpiHandler % msgCount , & mpiHandler % requests % hostData ( 1 : mpiHandler % msgCount , 1 ), & mpiHandler % requests % hostData ( 1 : mpiHandler % msgCount , 2 ), & iError ) END SUBROUTINE FinalizeMPIExchangeAsync END MODULE SELF_MPI","tags":"","loc":"sourcefile/self_mpi.f90.html"},{"title":"SELF_HDF5.f90 – SELF","text":"This file depends on sourcefile~~self_hdf5.f90~~EfferentGraph sourcefile~self_hdf5.f90 SELF_HDF5.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_hdf5.f90->sourcefile~self_memory.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_hdf5.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_hdf5.f90~~AfferentGraph sourcefile~self_hdf5.f90 SELF_HDF5.f90 sourcefile~self_metadata.f90 SELF_Metadata.f90 sourcefile~self_metadata.f90->sourcefile~self_hdf5.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_mesh.f90->sourcefile~self_hdf5.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_dg.f90->sourcefile~self_hdf5.f90 sourcefile~self_dg.f90->sourcefile~self_metadata.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~self_advection2d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_mesh.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_HDF5 Source Code SELF_HDF5.f90 Source Code ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_HDF5 USE SELF_Constants USE SELF_Memory USE ISO_FORTRAN_ENV USE HDF5 #ifdef DOUBLE_PRECISION #define HDF5_IO_PREC H5T_IEEE_F64LE #else #define HDF5_IO_PREC H5T_IEEE_F32LE #endif INTERFACE Open_HDF5 MODULE PROCEDURE :: Open_HDF5_serial MODULE PROCEDURE :: Open_HDF5_parallel END INTERFACE INTERFACE ReadAttribute_HDF5 MODULE PROCEDURE :: ReadAttribute_HDF5_int32 MODULE PROCEDURE :: ReadAttribute_HDF5_real MODULE PROCEDURE :: ReadAttribute_HDF5_character END INTERFACE INTERFACE WriteAttribute_HDF5 MODULE PROCEDURE :: WriteAttribute_HDF5_int32 MODULE PROCEDURE :: WriteAttribute_HDF5_real MODULE PROCEDURE :: WriteAttribute_HDF5_character END INTERFACE INTERFACE ReadArray_HDF5 MODULE PROCEDURE :: ReadArray_HDF5_real_r1_serial MODULE PROCEDURE :: ReadArray_HDF5_real_r2_serial MODULE PROCEDURE :: ReadArray_HDF5_real_r3_serial MODULE PROCEDURE :: ReadArray_HDF5_real_r4_serial MODULE PROCEDURE :: ReadArray_HDF5_real_r5_serial MODULE PROCEDURE :: ReadArray_HDF5_real_r6_serial MODULE PROCEDURE :: ReadArray_HDF5_real_r7_serial MODULE PROCEDURE :: ReadArray_HDF5_int32_r1_serial MODULE PROCEDURE :: ReadArray_HDF5_int32_r2_serial MODULE PROCEDURE :: ReadArray_HDF5_int32_r3_serial MODULE PROCEDURE :: ReadArray_HDF5_int32_r4_serial MODULE PROCEDURE :: ReadArray_HDF5_int32_r5_serial MODULE PROCEDURE :: ReadArray_HDF5_int32_r6_serial MODULE PROCEDURE :: ReadArray_HDF5_int32_r7_serial MODULE PROCEDURE :: ReadArray_HDF5_int64_r1_serial MODULE PROCEDURE :: ReadArray_HDF5_int64_r2_serial MODULE PROCEDURE :: ReadArray_HDF5_int64_r3_serial MODULE PROCEDURE :: ReadArray_HDF5_int64_r4_serial MODULE PROCEDURE :: ReadArray_HDF5_int64_r5_serial MODULE PROCEDURE :: ReadArray_HDF5_int64_r6_serial MODULE PROCEDURE :: ReadArray_HDF5_int64_r7_serial MODULE PROCEDURE :: ReadArray_HDF5_real_r1_parallel MODULE PROCEDURE :: ReadArray_HDF5_real_r2_parallel MODULE PROCEDURE :: ReadArray_HDF5_real_r3_parallel MODULE PROCEDURE :: ReadArray_HDF5_real_r4_parallel MODULE PROCEDURE :: ReadArray_HDF5_real_r5_parallel MODULE PROCEDURE :: ReadArray_HDF5_real_r6_parallel MODULE PROCEDURE :: ReadArray_HDF5_real_r7_parallel MODULE PROCEDURE :: ReadArray_HDF5_int32_r1_parallel MODULE PROCEDURE :: ReadArray_HDF5_int32_r2_parallel MODULE PROCEDURE :: ReadArray_HDF5_int32_r3_parallel MODULE PROCEDURE :: ReadArray_HDF5_int32_r4_parallel MODULE PROCEDURE :: ReadArray_HDF5_int32_r5_parallel MODULE PROCEDURE :: ReadArray_HDF5_int32_r6_parallel MODULE PROCEDURE :: ReadArray_HDF5_int32_r7_parallel MODULE PROCEDURE :: ReadArray_HDF5_int64_r1_parallel MODULE PROCEDURE :: ReadArray_HDF5_int64_r2_parallel MODULE PROCEDURE :: ReadArray_HDF5_int64_r3_parallel MODULE PROCEDURE :: ReadArray_HDF5_int64_r4_parallel MODULE PROCEDURE :: ReadArray_HDF5_int64_r5_parallel MODULE PROCEDURE :: ReadArray_HDF5_int64_r6_parallel MODULE PROCEDURE :: ReadArray_HDF5_int64_r7_parallel END INTERFACE INTERFACE WriteArray_HDF5 MODULE PROCEDURE :: WriteArray_HDF5_real_r1_serial MODULE PROCEDURE :: WriteArray_HDF5_real_r2_serial MODULE PROCEDURE :: WriteArray_HDF5_real_r3_serial MODULE PROCEDURE :: WriteArray_HDF5_real_r4_serial MODULE PROCEDURE :: WriteArray_HDF5_real_r5_serial MODULE PROCEDURE :: WriteArray_HDF5_real_r6_serial MODULE PROCEDURE :: WriteArray_HDF5_real_r7_serial MODULE PROCEDURE :: WriteArray_HDF5_int32_r1_serial MODULE PROCEDURE :: WriteArray_HDF5_int32_r2_serial MODULE PROCEDURE :: WriteArray_HDF5_int32_r3_serial MODULE PROCEDURE :: WriteArray_HDF5_int32_r4_serial MODULE PROCEDURE :: WriteArray_HDF5_int32_r5_serial MODULE PROCEDURE :: WriteArray_HDF5_int32_r6_serial MODULE PROCEDURE :: WriteArray_HDF5_int32_r7_serial MODULE PROCEDURE :: WriteArray_HDF5_int64_r1_serial MODULE PROCEDURE :: WriteArray_HDF5_int64_r2_serial MODULE PROCEDURE :: WriteArray_HDF5_int64_r3_serial MODULE PROCEDURE :: WriteArray_HDF5_int64_r4_serial MODULE PROCEDURE :: WriteArray_HDF5_int64_r5_serial MODULE PROCEDURE :: WriteArray_HDF5_int64_r6_serial MODULE PROCEDURE :: WriteArray_HDF5_int64_r7_serial MODULE PROCEDURE :: WriteArray_HDF5_real_r1_parallel MODULE PROCEDURE :: WriteArray_HDF5_real_r2_parallel MODULE PROCEDURE :: WriteArray_HDF5_real_r3_parallel MODULE PROCEDURE :: WriteArray_HDF5_real_r4_parallel MODULE PROCEDURE :: WriteArray_HDF5_real_r5_parallel MODULE PROCEDURE :: WriteArray_HDF5_real_r6_parallel MODULE PROCEDURE :: WriteArray_HDF5_real_r7_parallel MODULE PROCEDURE :: WriteArray_HDF5_int32_r1_parallel MODULE PROCEDURE :: WriteArray_HDF5_int32_r2_parallel MODULE PROCEDURE :: WriteArray_HDF5_int32_r3_parallel MODULE PROCEDURE :: WriteArray_HDF5_int32_r4_parallel MODULE PROCEDURE :: WriteArray_HDF5_int32_r5_parallel MODULE PROCEDURE :: WriteArray_HDF5_int32_r6_parallel MODULE PROCEDURE :: WriteArray_HDF5_int32_r7_parallel MODULE PROCEDURE :: WriteArray_HDF5_int64_r1_parallel MODULE PROCEDURE :: WriteArray_HDF5_int64_r2_parallel MODULE PROCEDURE :: WriteArray_HDF5_int64_r3_parallel MODULE PROCEDURE :: WriteArray_HDF5_int64_r4_parallel MODULE PROCEDURE :: WriteArray_HDF5_int64_r5_parallel MODULE PROCEDURE :: WriteArray_HDF5_int64_r6_parallel MODULE PROCEDURE :: WriteArray_HDF5_int64_r7_parallel END INTERFACE PRIVATE PUBLIC :: Open_HDF5 PUBLIC :: Close_HDF5 PUBLIC :: CreateGroup_HDF5 PUBLIC :: ReadAttribute_HDF5 PUBLIC :: WriteAttribute_HDF5 PUBLIC :: ReadArray_HDF5 PUBLIC :: WriteArray_HDF5 CONTAINS SUBROUTINE Open_HDF5_serial ( fileName , accessFlag , fileId ) IMPLICIT NONE CHARACTER ( * ), INTENT ( in ) :: fileName INTEGER , INTENT ( in ) :: accessFlag INTEGER ( HID_T ), INTENT ( inout ) :: fileId ! Local INTEGER :: error CALL h5open_f ( error ) IF ( accessFlag == H5F_ACC_TRUNC_F ) THEN CALL h5fcreate_f ( TRIM ( fileName ), accessFlag , fileId , error ) ELSE CALL h5fopen_f ( TRIM ( fileName ), accessFlag , fileId , error ) END IF IF ( error == - 1 ) THEN PRINT * , 'Failed to open ' // TRIM ( fileName ) // '.' STOP - 1 END IF END SUBROUTINE Open_HDF5_serial SUBROUTINE Open_HDF5_parallel ( fileName , accessFlag , fileId , mpiComm ) IMPLICIT NONE CHARACTER ( * ), INTENT ( in ) :: fileName INTEGER , INTENT ( in ) :: accessFlag INTEGER ( HID_T ), INTENT ( inout ) :: fileId INTEGER , INTENT ( in ) :: mpiComm ! Local INTEGER ( HID_T ) :: plistId INTEGER :: error CALL h5open_f ( error ) CALL h5pcreate_f ( H5P_FILE_ACCESS_F , plistId , error ) CALL h5pset_fapl_mpio_f ( plistId , mpiComm , MPI_INFO_NULL , error ) CALL h5fopen_f ( TRIM ( fileName ), accessFlag , fileId , error , plistId ) IF ( accessFlag == H5F_ACC_TRUNC_F ) THEN CALL h5fcreate_f ( TRIM ( fileName ), accessFlag , fileId , error , plistId ) ELSE CALL h5fopen_f ( TRIM ( fileName ), accessFlag , fileId , error , plistId ) END IF CALL h5pclose_f ( plistId , error ) IF ( error == - 1 ) THEN PRINT * , 'Failed to open ' // TRIM ( fileName ) // '.' STOP - 1 END IF END SUBROUTINE Open_HDF5_parallel SUBROUTINE Close_HDF5 ( fileId ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId ! Local INTEGER :: error CALL h5fclose_f ( fileId , error ) CALL h5close_f ( error ) END SUBROUTINE Close_HDF5 SUBROUTINE CreateGroup_HDF5 ( fileId , groupName ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: groupName ! Local INTEGER ( HID_T ) :: groupId INTEGER :: error ! Create groups CALL h5gcreate_f ( fileId , TRIM ( groupName ), groupId , error ) CALL h5gclose_f ( groupId , error ) END SUBROUTINE CreateGroup_HDF5 SUBROUTINE ReadAttribute_HDF5_int32 ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName INTEGER , INTENT ( out ) :: attribute ! Local INTEGER ( HID_T ) :: attrId INTEGER ( HID_T ) :: typeId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5aopen_f ( fileId , TRIM ( attributeName ), attrId , error ) CALL h5aget_type_f ( attrId , typeId , error ) CALL h5aread_f ( attrId , typeId , attribute , dims , error ) CALL h5tclose_f ( typeId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE ReadAttribute_HDF5_int32 SUBROUTINE ReadAttribute_HDF5_real ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName REAL ( prec ), INTENT ( out ) :: attribute ! Local INTEGER ( HID_T ) :: attrId INTEGER ( HID_T ) :: typeId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5aopen_f ( fileId , TRIM ( attributeName ), attrId , error ) CALL h5aget_type_f ( attrId , typeId , error ) CALL h5aread_f ( attrId , typeId , attribute , dims , error ) CALL h5tclose_f ( typeId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE ReadAttribute_HDF5_real SUBROUTINE ReadAttribute_HDF5_character ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName CHARACTER ( * ), INTENT ( out ) :: attribute ! Local INTEGER ( HID_T ) :: attrId INTEGER ( HID_T ) :: typeId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5aopen_f ( fileId , TRIM ( attributeName ), attrId , error ) CALL h5aget_type_f ( attrId , typeId , error ) CALL h5aread_f ( attrId , typeId , attribute , dims , error ) CALL h5tclose_f ( typeId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE ReadAttribute_HDF5_character SUBROUTINE WriteAttribute_HDF5_int32 ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName INTEGER , INTENT ( in ) :: attribute ! Local INTEGER ( HID_T ) :: aspaceId INTEGER ( HID_T ) :: attrId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5screate_f ( H5S_SCALAR_F , aspaceId , error ) CALL h5acreate_f ( fileId , TRIM ( attributeName ), H5T_STD_I32LE , & aspaceId , attrId , error ) CALL h5awrite_f ( attrId , H5T_STD_I32LE , attribute , dims , error ) CALL h5sclose_f ( aspaceId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE WriteAttribute_HDF5_int32 SUBROUTINE WriteAttribute_HDF5_real ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName REAL ( prec ), INTENT ( in ) :: attribute ! Local INTEGER ( HID_T ) :: aspaceId INTEGER ( HID_T ) :: attrId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5screate_f ( H5S_SCALAR_F , aspaceId , error ) CALL h5acreate_f ( fileId , TRIM ( attributeName ), HDF5_IO_PREC , & aspaceId , attrId , error ) CALL h5awrite_f ( attrId , HDF5_IO_PREC , attribute , dims , error ) CALL h5sclose_f ( aspaceId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE WriteAttribute_HDF5_real SUBROUTINE WriteAttribute_HDF5_character ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName CHARACTER ( * ), INTENT ( in ) :: attribute ! Local INTEGER ( HID_T ) :: aspaceId INTEGER ( HID_T ) :: attrId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5screate_f ( H5S_SCALAR_F , aspaceId , error ) CALL h5acreate_f ( fileId , TRIM ( attributeName ), H5T_STRING , & aspaceId , attrId , error ) CALL h5awrite_f ( attrId , H5T_STRING , TRIM ( attribute ), dims , error ) CALL h5sclose_f ( aspaceId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE WriteAttribute_HDF5_character SUBROUTINE WriteArray_HDF5_real_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r1 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r1_serial SUBROUTINE WriteArray_HDF5_real_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r2 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r2_serial SUBROUTINE WriteArray_HDF5_real_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r3 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r3_serial SUBROUTINE WriteArray_HDF5_real_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r4 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r4_serial SUBROUTINE WriteArray_HDF5_real_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r5 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r5_serial SUBROUTINE WriteArray_HDF5_real_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r6 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r6_serial SUBROUTINE WriteArray_HDF5_real_r7_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r7 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r7_serial SUBROUTINE WriteArray_HDF5_int32_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r1 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r1_serial SUBROUTINE WriteArray_HDF5_int32_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r2 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r2_serial SUBROUTINE WriteArray_HDF5_int32_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r3 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r3_serial SUBROUTINE WriteArray_HDF5_int32_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r4 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r4_serial SUBROUTINE WriteArray_HDF5_int32_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r5 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r5_serial SUBROUTINE WriteArray_HDF5_int32_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r6 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r6_serial SUBROUTINE WriteArray_HDF5_int32_r7_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r7 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r7_serial SUBROUTINE WriteArray_HDF5_int64_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint64_r1 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r1_serial SUBROUTINE WriteArray_HDF5_int64_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint64_r2 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r2_serial SUBROUTINE WriteArray_HDF5_int64_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint64_r3 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r3_serial SUBROUTINE WriteArray_HDF5_int64_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint64_r4 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r4_serial SUBROUTINE WriteArray_HDF5_int64_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint64_r5 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r5_serial SUBROUTINE WriteArray_HDF5_int64_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint64_r6 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r6_serial SUBROUTINE WriteArray_HDF5_int64_r7_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint64_r7 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r7_serial SUBROUTINE WriteArray_HDF5_real_r1_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfReal_r1 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r1_parallel SUBROUTINE WriteArray_HDF5_real_r2_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfReal_r2 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 2 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r2_parallel SUBROUTINE WriteArray_HDF5_real_r3_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfReal_r3 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 3 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r3_parallel SUBROUTINE WriteArray_HDF5_real_r4_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfReal_r4 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 4 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r4_parallel SUBROUTINE WriteArray_HDF5_real_r5_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfReal_r5 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 5 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r5_parallel SUBROUTINE WriteArray_HDF5_real_r6_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfReal_r6 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 6 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r6_parallel SUBROUTINE WriteArray_HDF5_real_r7_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 7 ) TYPE ( hfReal_r7 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 7 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r7_parallel SUBROUTINE WriteArray_HDF5_int32_r1_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfint32_r1 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r1_parallel SUBROUTINE WriteArray_HDF5_int32_r2_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfint32_r2 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 2 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r2_parallel SUBROUTINE WriteArray_HDF5_int32_r3_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfint32_r3 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 3 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r3_parallel SUBROUTINE WriteArray_HDF5_int32_r4_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfint32_r4 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 4 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r4_parallel SUBROUTINE WriteArray_HDF5_int32_r5_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfint32_r5 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 5 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r5_parallel SUBROUTINE WriteArray_HDF5_int32_r6_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfint32_r6 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 6 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r6_parallel SUBROUTINE WriteArray_HDF5_int32_r7_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 7 ) TYPE ( hfint32_r7 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 7 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r7_parallel SUBROUTINE WriteArray_HDF5_int64_r1_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfint64_r1 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r1_parallel SUBROUTINE WriteArray_HDF5_int64_r2_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfint64_r2 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 2 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r2_parallel SUBROUTINE WriteArray_HDF5_int64_r3_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfint64_r3 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 3 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r3_parallel SUBROUTINE WriteArray_HDF5_int64_r4_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfint64_r4 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 4 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r4_parallel SUBROUTINE WriteArray_HDF5_int64_r5_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfint64_r5 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 5 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r5_parallel SUBROUTINE WriteArray_HDF5_int64_r6_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfint64_r6 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 6 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r6_parallel SUBROUTINE WriteArray_HDF5_int64_r7_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 7 ) TYPE ( hfint64_r7 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 7 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r7_parallel SUBROUTINE ReadArray_HDF5_real_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r1_serial SUBROUTINE ReadArray_HDF5_real_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r2_serial SUBROUTINE ReadArray_HDF5_real_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r3_serial SUBROUTINE ReadArray_HDF5_real_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r4_serial SUBROUTINE ReadArray_HDF5_real_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r5_serial SUBROUTINE ReadArray_HDF5_real_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r6_serial SUBROUTINE ReadArray_HDF5_real_r7_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r7 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r7_serial SUBROUTINE ReadArray_HDF5_int32_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r1_serial SUBROUTINE ReadArray_HDF5_int32_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r2_serial SUBROUTINE ReadArray_HDF5_int32_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r3_serial SUBROUTINE ReadArray_HDF5_int32_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r4_serial SUBROUTINE ReadArray_HDF5_int32_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r5_serial SUBROUTINE ReadArray_HDF5_int32_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r6_serial SUBROUTINE ReadArray_HDF5_int32_r7_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r7 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r7_serial SUBROUTINE ReadArray_HDF5_int64_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt64_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int64_r1_serial SUBROUTINE ReadArray_HDF5_int64_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt64_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int64_r2_serial SUBROUTINE ReadArray_HDF5_int64_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt64_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int64_r3_serial SUBROUTINE ReadArray_HDF5_int64_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt64_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int64_r4_serial SUBROUTINE ReadArray_HDF5_int64_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt64_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int64_r5_serial SUBROUTINE ReadArray_HDF5_int64_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt64_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int64_r6_serial SUBROUTINE ReadArray_HDF5_int64_r7_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt64_r7 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int64_r7_serial SUBROUTINE ReadArray_HDF5_real_r1_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfReal_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r1_parallel SUBROUTINE ReadArray_HDF5_real_r2_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfReal_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r2_parallel SUBROUTINE ReadArray_HDF5_real_r3_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfReal_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r3_parallel SUBROUTINE ReadArray_HDF5_real_r4_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfReal_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r4_parallel SUBROUTINE ReadArray_HDF5_real_r5_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfReal_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r5_parallel SUBROUTINE ReadArray_HDF5_real_r6_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfReal_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r6_parallel SUBROUTINE ReadArray_HDF5_real_r7_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 7 ) TYPE ( hfReal_r7 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r7_parallel SUBROUTINE ReadArray_HDF5_int32_r1_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfInt32_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( 1 , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r1_parallel SUBROUTINE ReadArray_HDF5_int32_r2_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfInt32_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r2_parallel SUBROUTINE ReadArray_HDF5_int32_r3_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfInt32_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r3_parallel SUBROUTINE ReadArray_HDF5_int32_r4_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfInt32_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r4_parallel SUBROUTINE ReadArray_HDF5_int32_r5_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfInt32_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r5_parallel SUBROUTINE ReadArray_HDF5_int32_r6_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfInt32_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r6_parallel SUBROUTINE ReadArray_HDF5_int32_r7_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 7 ) TYPE ( hfInt32_r7 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r7_parallel SUBROUTINE ReadArray_HDF5_int64_r1_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfInt64_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int64_r1_parallel SUBROUTINE ReadArray_HDF5_int64_r2_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfInt64_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int64_r2_parallel SUBROUTINE ReadArray_HDF5_int64_r3_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfInt64_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int64_r3_parallel SUBROUTINE ReadArray_HDF5_int64_r4_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfInt64_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int64_r4_parallel SUBROUTINE ReadArray_HDF5_int64_r5_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfInt64_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int64_r5_parallel SUBROUTINE ReadArray_HDF5_int64_r6_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfInt64_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int64_r6_parallel SUBROUTINE ReadArray_HDF5_int64_r7_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 7 ) TYPE ( hfInt64_r7 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int64_r7_parallel END MODULE SELF_HDF5","tags":"","loc":"sourcefile/self_hdf5.f90.html"},{"title":"SELF_Geometry.f90 – SELF","text":"This file depends on sourcefile~~self_geometry.f90~~EfferentGraph sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_geometry.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_hdf5.f90 SELF_HDF5.f90 sourcefile~self_mesh.f90->sourcefile~self_hdf5.f90 sourcefile~self_hashtable.f90 SELF_HashTable.f90 sourcefile~self_mesh.f90->sourcefile~self_hashtable.f90 sourcefile~self_mpi.f90 SELF_MPI.f90 sourcefile~self_mesh.f90->sourcefile~self_mpi.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_hdf5.f90->sourcefile~self_constants.f90 sourcefile~self_hdf5.f90->sourcefile~self_memory.f90 sourcefile~self_hashtable.f90->sourcefile~self_constants.f90 sourcefile~self_linkedlist.f90 SELF_LinkedList.f90 sourcefile~self_hashtable.f90->sourcefile~self_linkedlist.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 sourcefile~self_mpi.f90->sourcefile~self_constants.f90 sourcefile~self_mpi.f90->sourcefile~self_memory.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_geometry.f90~~AfferentGraph sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Geometry Source Code SELF_Geometry.f90 Source Code ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Geometry USE SELF_Constants USE SELF_Lagrange USE SELF_Data USE SELF_SupportRoutines USE SELF_Mesh IMPLICIT NONE #include \"SELF_Macros.h\" TYPE , PUBLIC :: Geometry1D INTEGER :: cqType ! Control Quadrature Type INTEGER :: tqType ! Target Quadrature Type INTEGER :: nElem TYPE ( Scalar1D ) :: x ! Physical Positions TYPE ( Scalar1D ) :: dxds ! Conversion from computational to physical space CONTAINS PROCEDURE , PUBLIC :: Init => Init_Geometry1D PROCEDURE , PUBLIC :: Free => Free_Geometry1D PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_Geometry1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Geometry1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Geometry1D PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D END TYPE Geometry1D TYPE , PUBLIC :: SEMQuad INTEGER :: cqType ! Control Quadrature Type INTEGER :: tqType ! Target Quadrature Type INTEGER :: nElem TYPE ( Vector2D ) :: x ! Physical positions TYPE ( Tensor2D ) :: dxds ! Covariant basis vectors TYPE ( Tensor2D ) :: dsdx ! Contavariant basis vectors TYPE ( Vector2D ) :: nHat ! Normal Vectors pointing across coordinate lines TYPE ( Scalar2D ) :: nScale ! Boundary scale TYPE ( Scalar2D ) :: J ! Jacobian of the transformation CONTAINS PROCEDURE , PUBLIC :: Init => Init_SEMQuad PROCEDURE , PUBLIC :: Free => Free_SEMQuad PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_SEMQuad PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_SEMQuad PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_SEMQuad PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad PROCEDURE , PRIVATE :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad END TYPE SEMQuad TYPE , PUBLIC :: SEMHex INTEGER :: cqType ! Control Quadrature Type INTEGER :: tqType ! Target Quadrature Type INTEGER :: nElem TYPE ( Vector3D ) :: x ! Physical positions TYPE ( Tensor3D ) :: dxds ! Covariant basis vectors TYPE ( Tensor3D ) :: dsdx ! Contavariant basis vectors TYPE ( Vector3D ) :: nHat ! Normal Vectors pointing across coordinate lines TYPE ( Scalar3D ) :: nScale ! Boundary scale TYPE ( Scalar3D ) :: J ! Jacobian of the transformation CONTAINS PROCEDURE , PUBLIC :: Init => Init_SEMHex PROCEDURE , PUBLIC :: Free => Free_SEMHex PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_SEMHex PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_SEMHex PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_SEMHex PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_SEMHex PROCEDURE , PRIVATE :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex END TYPE SEMHex INTERFACE SUBROUTINE CalculateContravariantBasis_SEMQuad_gpu_wrapper ( dxds , dsdx , N , nEl ) & bind ( c , name = \"CalculateContravariantBasis_SEMQuad_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dxds , dsdx INTEGER ( C_INT ), VALUE :: N , nEl END SUBROUTINE CalculateContravariantBasis_SEMQuad_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper ( dsdx , J , N , nEl ) & bind ( c , name = \"AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dsdx , J INTEGER ( C_INT ), VALUE :: N , nEl END SUBROUTINE AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE CalculateContravariantBasis_SEMHex_gpu_wrapper ( dxds , dsdx , N , nEl ) & bind ( c , name = \"CalculateContravariantBasis_SEMHex_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dxds , dsdx INTEGER ( C_INT ), VALUE :: N , nEl END SUBROUTINE CalculateContravariantBasis_SEMHex_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper ( dsdx , J , N , nEl ) & bind ( c , name = \"AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dsdx , J INTEGER ( C_INT ), VALUE :: N , nEl END SUBROUTINE AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper END INTERFACE CONTAINS SUBROUTINE Init_Geometry1D ( myGeom , cqType , tqType , cqDegree , tqDegree , nElem ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( out ) :: myGeom INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem myGeom % cqType = cqType myGeom % tqType = tqType myGeom % nElem = nElem CALL myGeom % x % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_Geometry1D SUBROUTINE Free_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () END SUBROUTINE Free_Geometry1D SUBROUTINE UpdateHost_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () END SUBROUTINE UpdateHost_Geometry1D SUBROUTINE UpdateDevice_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () END SUBROUTINE UpdateDevice_Geometry1D SUBROUTINE GenerateFromMesh_Geometry1D ( myGeom , mesh , cqType , tqType , cqDegree , tqDegree , meshQuadrature ) ! Generates the geometry for a 1-D mesh ( set of line segments ) ! Assumes that mesh is using Gauss-Lobatto quadrature and the degree is given by mesh % nGeo IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( out ) :: myGeom TYPE ( Mesh1D ), INTENT ( in ) :: mesh INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ), OPTIONAL :: meshQuadrature ! Local INTEGER :: iel , i , nid TYPE ( Scalar1D ) :: xMesh INTEGER :: quadrature IF ( PRESENT ( meshQuadrature )) THEN quadrature = meshQuadrature ELSE quadrature = GAUSS_LOBATTO END IF CALL myGeom % Init ( cqType , tqType , cqDegree , tqDegree , mesh % nElem ) ! Create a scalar1D class to map from nGeo,Gauss-Lobatto grid to ! cqDegree, cqType grid CALL xMesh % Init ( mesh % nGeo , quadrature , & cqDegree , cqType , & 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 DO iel = 1 , mesh % nElem DO i = 0 , mesh % nGeo xMesh % interior % hostData ( i , 1 , iel ) = mesh % hopr_nodeCoords % hostData ( nid ) nid = nid + 1 END DO END DO ! Interpolate from the mesh hopr_nodeCoords to the geometry (Possibly not gauss_lobatto quadrature) CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () CALL myGeom % UpdateDevice () CALL xMesh % Free () END SUBROUTINE GenerateFromMesh_Geometry1D SUBROUTINE CalculateMetricTerms_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % Derivative ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % UpdateDevice () END SUBROUTINE CalculateMetricTerms_Geometry1D SUBROUTINE Init_SEMQuad ( myGeom , cqType , tqType , cqDegree , tqDegree , nElem ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( out ) :: myGeom INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem myGeom % cqType = cqType myGeom % tqType = tqType myGeom % nElem = nElem CALL myGeom % x % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dsdx % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % nHat % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % nScale % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % J % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_SEMQuad SUBROUTINE Free_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () CALL myGeom % dsdx % Free () CALL myGeom % nHat % Free () CALL myGeom % nScale % Free () CALL myGeom % J % Free () END SUBROUTINE Free_SEMQuad SUBROUTINE UpdateHost_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () CALL myGeom % dsdx % UpdateHost () CALL myGeom % nHat % UpdateHost () CALL myGeom % nScale % UpdateHost () CALL myGeom % J % UpdateHost () END SUBROUTINE UpdateHost_SEMQuad SUBROUTINE UpdateDevice_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () CALL myGeom % dsdx % UpdateDevice () CALL myGeom % nHat % UpdateDevice () CALL myGeom % nScale % UpdateDevice () CALL myGeom % J % UpdateDevice () END SUBROUTINE UpdateDevice_SEMQuad SUBROUTINE GenerateFromMesh_SEMQuad ( myGeom , mesh , cqType , tqType , cqDegree , tqDegree , meshQuadrature ) ! Assumes that !  * mesh is using Gauss-Lobatto quadrature !  * the degree is given by mesh % nGeo !  * mesh only has quadrilateral elements ! IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( out ) :: myGeom TYPE ( Mesh2D ), INTENT ( in ) :: mesh INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ), OPTIONAL :: meshQuadrature ! Local INTEGER :: iel INTEGER :: i , j , nid TYPE ( Vector2D ) :: xMesh INTEGER :: quadrature IF ( PRESENT ( meshQuadrature )) THEN quadrature = meshQuadrature ELSE quadrature = GAUSS_LOBATTO END IF CALL myGeom % Init ( cqType , tqType , cqDegree , tqDegree , mesh % nElem ) ! Create a scalar1D class to map from nGeo,Gauss-Lobatto grid to ! cqDegree, cqType grid CALL xMesh % Init ( mesh % nGeo , quadrature , & cqDegree , cqType , & 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 DO iel = 1 , mesh % nElem DO j = 0 , mesh % nGeo DO i = 0 , mesh % nGeo xMesh % interior % hostData ( 1 : 2 , i , j , 1 , iel ) = mesh % hopr_nodeCoords % hostData ( 1 : 2 , nid ) nid = nid + 1 END DO END DO END DO !IF (GPUAvailable()) THEN !  CALL xMesh % UpdateDevice() !  CALL xMesh % GridInterp(myGeom % x,.TRUE.) !  CALL myGeom % x % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % CalculateMetricTerms() !  CALL myGeom % UpdateHost() !ELSE CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () !END IF CALL myGeom % UpdateDevice () CALL xMesh % Free () END SUBROUTINE GenerateFromMesh_SEMQuad SUBROUTINE CalculateContravariantBasis_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom ! Local INTEGER :: iEl , i , j , k REAL ( prec ) :: fac REAL ( prec ) :: mag ! Now calculate the contravariant basis vectors ! In this convention, dsdx(j,i) is contravariant vector i, component j ! To project onto contravariant vector i, dot vector along the first dimension DO iEl = 1 , myGeom % nElem DO j = 0 , myGeom % dxds % N DO i = 0 , myGeom % dxds % N myGeom % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iEl ) = myGeom % dxds % interior % hostData ( 2 , 2 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iEl ) = - myGeom % dxds % interior % hostData ( 1 , 2 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iEl ) = - myGeom % dxds % interior % hostData ( 2 , 1 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iEl ) = myGeom % dxds % interior % hostData ( 1 , 1 , i , j , 1 , iEl ) END DO END DO END DO ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . FALSE .) ! Now, modify the sign of dsdx so that ! myGeom % dsdx % boundary is equal to the outward pointing normal vector DO iEl = 1 , myGeom % nElem DO k = 1 , 4 DO i = 0 , myGeom % J % N IF ( k == selfSide2D_East . OR . k == selfSide2D_North ) THEN fac = SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , 1 , k , iEl )) ELSE fac = - SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , 1 , k , iEl )) END IF IF ( k == 1 ) THEN ! South mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 2 , i , 1 , k , iEl ) / mag ELSEIF ( k == 2 ) THEN ! East mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 , i , 1 , k , iEl ) / mag ELSEIF ( k == 3 ) THEN ! North mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 2 , i , 1 , k , iEl ) / mag ELSEIF ( k == 4 ) THEN ! West mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 , i , 1 , k , iEl ) / mag ENDIF ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 : 2 , i , 1 , k , iEl ) = & myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 : 2 , i , 1 , k , iEl ) * fac END DO END DO END DO END SUBROUTINE CalculateContravariantBasis_SEMQuad SUBROUTINE CalculateMetricTerms_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom !    IF (GPUAvailable()) THEN !      CALL myGeom % x % Gradient(myGeom % dxds,gpuAccel=.TRUE.) !      CALL myGeom % dxds % BoundaryInterp(gpuAccel=.TRUE.) !      CALL myGeom % dxds % Determinant(myGeom % J,gpuAccel=.TRUE.) !      CALL myGeom % J % BoundaryInterp(gpuAccel=.TRUE.) !      CALL myGeom % UpdateHost() !    ELSE CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . FALSE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . FALSE .) !    END IF CALL myGeom % CalculateContravariantBasis () IF ( GPUAvailable ()) THEN CALL myGeom % dsdx % UpdateDevice () CALL myGeom % nHat % UpdateDevice () CALL myGeom % nScale % UpdateDevice () ENDIF END SUBROUTINE CalculateMetricTerms_SEMQuad SUBROUTINE Init_SEMHex ( myGeom , cqType , tqType , cqDegree , tqDegree , nElem ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( out ) :: myGeom INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem myGeom % cqType = cqType myGeom % tqType = tqType myGeom % nElem = nElem CALL myGeom % x % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dsdx % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % nHat % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % nScale % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % J % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_SEMHex SUBROUTINE Free_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () CALL myGeom % dsdx % Free () CALL myGeom % nHat % Free () CALL myGeom % nScale % Free () CALL myGeom % J % Free () END SUBROUTINE Free_SEMHex SUBROUTINE UpdateHost_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () CALL myGeom % dsdx % UpdateHost () CALL myGeom % nHat % UpdateHost () CALL myGeom % nScale % UpdateHost () CALL myGeom % J % UpdateHost () END SUBROUTINE UpdateHost_SEMHex SUBROUTINE UpdateDevice_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () CALL myGeom % dsdx % UpdateDevice () CALL myGeom % nHat % UpdateDevice () CALL myGeom % nScale % UpdateDevice () CALL myGeom % J % UpdateDevice () END SUBROUTINE UpdateDevice_SEMHex SUBROUTINE GenerateFromMesh_SEMHex ( myGeom , mesh , cqType , tqType , cqDegree , tqDegree , meshQuadrature ) ! Assumes that !  * mesh is using Gauss-Lobatto quadrature !  * the degree is given by mesh % nGeo !  * mesh only has quadrilateral elements ! IMPLICIT NONE CLASS ( SEMHex ), INTENT ( out ) :: myGeom TYPE ( Mesh3D ), INTENT ( in ) :: mesh INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ), OPTIONAL :: meshQuadrature ! Local INTEGER :: iel INTEGER :: i , j , k , nid TYPE ( Vector3D ) :: xMesh INTEGER :: quadrature IF ( PRESENT ( meshQuadrature )) THEN quadrature = meshQuadrature ELSE quadrature = GAUSS_LOBATTO END IF CALL myGeom % Init ( cqType , tqType , cqDegree , tqDegree , mesh % nElem ) ! Create a scalar1D class to map from nGeo,Gauss-Lobatto grid to ! cqDegree, cqType grid CALL xMesh % Init ( mesh % nGeo , quadrature , & cqDegree , cqType , & 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 DO iel = 1 , mesh % nElem DO k = 0 , mesh % nGeo DO j = 0 , mesh % nGeo DO i = 0 , mesh % nGeo xMesh % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) = mesh % hopr_nodeCoords % hostData ( 1 : 3 , nid ) nid = nid + 1 END DO END DO END DO END DO ! Interpolate from the mesh hopr_nodeCoords to the geometry (Possibly not gauss_lobatto quadrature) !IF (GPUAvailable()) THEN !  CALL xMesh % UpdateDevice() !  CALL xMesh % GridInterp(myGeom % x,.TRUE.) !  CALL myGeom % x % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % CalculateMetricTerms() !  CALL myGeom % UpdateHost() !ELSE CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () !END IF CALL myGeom % UpdateDevice () CALL xMesh % Free () END SUBROUTINE GenerateFromMesh_SEMHex SUBROUTINE CalculateContravariantBasis_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom ! Local INTEGER :: iEl , i , j , k REAL ( prec ) :: fac REAL ( prec ) :: mag ! Now calculate the contravariant basis vectors ! In this convention, dsdx(j,i) is contravariant vector i, component j ! To project onto contravariant vector i, dot vector along the first dimension DO iEl = 1 , myGeom % nElem DO k = 0 , myGeom % dxds % N DO j = 0 , myGeom % dxds % N DO i = 0 , myGeom % dxds % N ! Ja1 myGeom % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) ! Ja2 myGeom % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) ! Ja3 myGeom % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) END DO END DO END DO END DO ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . FALSE .) ! Now, calculate nHat (outward pointing normal) DO iEl = 1 , myGeom % nElem DO k = 1 , 6 DO j = 0 , myGeom % J % N DO i = 0 , myGeom % J % N IF ( k == selfSide3D_Top . OR . k == selfSide3D_East . OR . k == selfSide3D_North ) THEN fac = SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , j , 1 , k , iEl )) ELSE fac = - SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , j , 1 , k , iEl )) END IF IF ( k == 1 ) THEN ! Bottom mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 3 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 3 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 2 ) THEN ! South mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 2 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 2 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 3 ) THEN ! East mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 1 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 4 ) THEN ! North mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 2 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 2 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 5 ) THEN ! West mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 1 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 6 ) THEN ! Top mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 3 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 3 , i , j , 1 , k , iEl ) / mag ENDIF ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , 1 , k , iEl ) = & myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , 1 , k , iEl ) * fac END DO END DO END DO END DO END SUBROUTINE CalculateContravariantBasis_SEMHex SUBROUTINE CalculateMetricTerms_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom !IF (GPUAvailable()) THEN !  CALL myGeom % x % Gradient(myGeom % dxds,gpuAccel=.TRUE.) !  CALL myGeom % dxds % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % dxds % Determinant(myGeom % J,gpuAccel=.TRUE.) !  CALL myGeom % J % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % UpdateHost() !ELSE CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . FALSE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . FALSE .) !END IF CALL myGeom % CalculateContravariantBasis () IF ( GPUAvailable ()) THEN CALL myGeom % UpdateDevice () ENDIF END SUBROUTINE CalculateMetricTerms_SEMHex END MODULE SELF_Geometry","tags":"","loc":"sourcefile/self_geometry.f90.html"},{"title":"SELF_MappedData.f90 – SELF","text":"This file depends on sourcefile~~self_mappeddata.f90~~EfferentGraph sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_mappeddata.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mpi.f90 SELF_MPI.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mpi.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_mpi.f90 sourcefile~self_hdf5.f90 SELF_HDF5.f90 sourcefile~self_mesh.f90->sourcefile~self_hdf5.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_hashtable.f90 SELF_HashTable.f90 sourcefile~self_mesh.f90->sourcefile~self_hashtable.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_mpi.f90->sourcefile~self_constants.f90 sourcefile~self_mpi.f90->sourcefile~self_memory.f90 sourcefile~self_hdf5.f90->sourcefile~self_constants.f90 sourcefile~self_hdf5.f90->sourcefile~self_memory.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 sourcefile~self_hashtable.f90->sourcefile~self_constants.f90 sourcefile~self_linkedlist.f90 SELF_LinkedList.f90 sourcefile~self_hashtable.f90->sourcefile~self_linkedlist.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_mappeddata.f90~~AfferentGraph sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_MappedData Source Code SELF_MappedData.f90 Source Code ! SELF_MappedData.F90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_MappedData USE SELF_Constants USE SELF_Lagrange USE SELF_Data USE SELF_Mesh USE SELF_Geometry USE SELF_MPI USE ISO_C_BINDING IMPLICIT NONE #include \"SELF_Macros.h\" TYPE , EXTENDS ( Scalar1D ), PUBLIC :: MappedScalar1D CONTAINS GENERIC , PUBLIC :: Derivative => Derivative_MappedScalar1D PROCEDURE , PRIVATE :: Derivative_MappedScalar1D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedScalar1D END TYPE MappedScalar1D TYPE , EXTENDS ( Scalar2D ), PUBLIC :: MappedScalar2D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedScalar2D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedScalar2D GENERIC , PUBLIC :: Gradient => Gradient_MappedScalar2D PROCEDURE , PRIVATE :: Gradient_MappedScalar2D PROCEDURE , PRIVATE :: ContravariantWeight => ContravariantWeight_MappedScalar2D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedScalar2D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedScalar2D END TYPE MappedScalar2D TYPE , EXTENDS ( Scalar3D ), PUBLIC :: MappedScalar3D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedScalar3D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedScalar3D GENERIC , PUBLIC :: Gradient => Gradient_MappedScalar3D PROCEDURE , PRIVATE :: Gradient_MappedScalar3D PROCEDURE , PRIVATE :: ContravariantWeight => ContravariantWeight_MappedScalar3D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedScalar3D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedScalar3D END TYPE MappedScalar3D TYPE , EXTENDS ( Vector2D ), PUBLIC :: MappedVector2D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedVector2D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedVector2D GENERIC , PUBLIC :: Divergence => Divergence_MappedVector2D GENERIC , PUBLIC :: Gradient => Gradient_MappedVector2D !    GENERIC,PUBLIC :: Curl => Curl_MappedVector2D PROCEDURE , PRIVATE :: Divergence_MappedVector2D PROCEDURE , PRIVATE :: Gradient_MappedVector2D !    PROCEDURE,PRIVATE :: Curl_MappedVector2D PROCEDURE , PRIVATE :: ContravariantProjection => ContravariantProjection_MappedVector2D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedVector2D PROCEDURE , PRIVATE :: MapToScalar => MapToScalar_MappedVector2D PROCEDURE , PRIVATE :: MapToTensor => MapToTensor_MappedVector2D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedVector2D END TYPE MappedVector2D TYPE , EXTENDS ( Vector3D ), PUBLIC :: MappedVector3D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedVector3D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedVector3D GENERIC , PUBLIC :: Divergence => Divergence_MappedVector3D !    GENERIC,PUBLIC :: Curl => Curl_MappedVector3D GENERIC , PUBLIC :: Gradient => Gradient_MappedVector3D PROCEDURE , PRIVATE :: Divergence_MappedVector3D !    PROCEDURE,PRIVATE :: Curl_MappedVector3D PROCEDURE , PRIVATE :: Gradient_MappedVector3D PROCEDURE , PRIVATE :: ContravariantProjection => ContravariantProjection_MappedVector3D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedVector3D PROCEDURE , PRIVATE :: MapToScalar => MapToScalar_MappedVector3D PROCEDURE , PRIVATE :: MapToTensor => MapToTensor_MappedVector3D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedVector3D END TYPE MappedVector3D TYPE , EXTENDS ( Tensor2D ), PUBLIC :: MappedTensor2D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedTensor2D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedTensor2D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedTensor2D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedTensor2D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedTensor2D END TYPE MappedTensor2D TYPE , EXTENDS ( Tensor3D ), PUBLIC :: MappedTensor3D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedTensor3D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedTensor3D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedTensor3D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedTensor3D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedTensor3D END TYPE MappedTensor3D INTERFACE SUBROUTINE JacobianWeight_MappedScalar1D_gpu_wrapper ( scalar , dxds , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedScalar1D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , dxds INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedScalar1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedScalar2D_gpu_wrapper ( scalar , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedScalar2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , jacobian INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedScalar2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedScalar3D_gpu_wrapper ( scalar , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedScalar3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , jacobian INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedScalar3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantWeight_MappedScalar2D_gpu_wrapper ( scalar , workTensor , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantWeight_MappedScalar2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , workTensor , dsdx INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ContravariantWeight_MappedScalar2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper ( scalar , workTensor , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , workTensor , dsdx INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantWeight_MappedScalar3D_gpu_wrapper ( scalar , workTensor , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantWeight_MappedScalar3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , workTensor , dsdx INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ContravariantWeight_MappedScalar3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper ( scalar , workTensor , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , workTensor , dsdx INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantProjection_MappedVector2D_gpu_wrapper ( physVector , compVector , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantProjection_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: physVector , compVector , dsdx INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ContravariantProjection_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper ( physVector , compVector , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: physVector , compVector , dsdx INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedVector2D_gpu_wrapper ( vector , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: vector , jacobian INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantProjection_MappedVector3D_gpu_wrapper ( physVector , compVector , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantProjection_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: physVector , compVector , dsdx INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ContravariantProjection_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper ( physVector , compVector , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: physVector , compVector , dsdx INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedVector3D_gpu_wrapper ( vector , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: vector , jacobian INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedTensor2D_gpu_wrapper ( tensor , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedTensor2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: tensor , jacobian INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedTensor2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedTensor3D_gpu_wrapper ( tensor , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedTensor3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: tensor , jacobian INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedTensor3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToScalar_MappedVector2D_gpu_wrapper ( scalar , vector , N , nVar , nEl ) & bind ( c , name = \"MapToScalar_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , vector INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE MapToScalar_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToScalarBoundary_MappedVector2D_gpu_wrapper ( scalar , vector , N , nVar , nEl ) & bind ( c , name = \"MapToScalarBoundary_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , vector INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE MapToScalarBoundary_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToTensor_MappedVector2D_gpu_wrapper ( tensor , vector , N , nVar , nEl ) & bind ( c , name = \"MapToTensor_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: tensor , vector INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE MapToTensor_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToTensorBoundary_MappedVector2D_gpu_wrapper ( tensor , vector , N , nVar , nEl ) & bind ( c , name = \"MapToTensorBoundary_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: tensor , vector INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE MapToTensorBoundary_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToScalar_MappedVector3D_gpu_wrapper ( scalar , vector , N , nVar , nEl ) & bind ( c , name = \"MapToScalar_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , vector INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE MapToScalar_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToScalarBoundary_MappedVector3D_gpu_wrapper ( scalar , vector , N , nVar , nEl ) & bind ( c , name = \"MapToScalarBoundary_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , vector INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE MapToScalarBoundary_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToTensor_MappedVector3D_gpu_wrapper ( tensor , vector , N , nVar , nEl ) & bind ( c , name = \"MapToTensor_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: tensor , vector INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE MapToTensor_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToTensorBoundary_MappedVector3D_gpu_wrapper ( tensor , vector , N , nVar , nEl ) & bind ( c , name = \"MapToTensorBoundary_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: tensor , vector INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE MapToTensorBoundary_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE SideExchange_MappedScalar2D_gpu_wrapper ( extBoundary , boundary , & self_sideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"SideExchange_MappedScalar2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary , self_sideInfo , elemToRank INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE SideExchange_MappedScalar2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE SideExchange_MappedVector2D_gpu_wrapper ( extBoundary , boundary , & self_sideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"SideExchange_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary , self_sideInfo , elemToRank INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE SideExchange_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE SideExchange_MappedTensor2D_gpu_wrapper ( extBoundary , boundary , & self_sideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"SideExchange_MappedTensor2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary , self_sideInfo , elemToRank INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE SideExchange_MappedTensor2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE SideExchange_MappedScalar3D_gpu_wrapper ( extBoundary , boundary , & self_sideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"SideExchange_MappedScalar3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary , self_sideInfo , elemToRank INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE SideExchange_MappedScalar3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE SideExchange_MappedVector3D_gpu_wrapper ( extBoundary , boundary , & self_sideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"SideExchange_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary , self_sideInfo , elemToRank INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE SideExchange_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE SideExchange_MappedTensor3D_gpu_wrapper ( extBoundary , boundary , & self_sideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"SideExchange_MappedTensor3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary , self_sideInfo , elemToRank INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE SideExchange_MappedTensor3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE BassiRebaySides_MappedScalar2D_gpu_wrapper ( avgBoundary , boundary , extBoundary , N , nVar , nEl ) & bind ( c , name = \"BassiRebaySides_MappedScalar2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary , avgBoundary INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE BassiRebaySides_MappedScalar2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE BassiRebaySides_MappedVector2D_gpu_wrapper ( extBoundary , boundary , N , nVar , nEl ) & bind ( c , name = \"BassiRebaySides_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE BassiRebaySides_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE BassiRebaySides_MappedTensor2D_gpu_wrapper ( extBoundary , boundary , N , nVar , nEl ) & bind ( c , name = \"BassiRebaySides_MappedTensor2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE BassiRebaySides_MappedTensor2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE BassiRebaySides_MappedScalar3D_gpu_wrapper ( avgBoundary , boundary , extBoundary , N , nVar , nEl ) & bind ( c , name = \"BassiRebaySides_MappedScalar3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: avgBoundary , extBoundary , boundary INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE BassiRebaySides_MappedScalar3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE BassiRebaySides_MappedVector3D_gpu_wrapper ( extBoundary , boundary , N , nVar , nEl ) & bind ( c , name = \"BassiRebaySides_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE BassiRebaySides_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE BassiRebaySides_MappedTensor3D_gpu_wrapper ( extBoundary , boundary , N , nVar , nEl ) & bind ( c , name = \"BassiRebaySides_MappedTensor3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: extBoundary , boundary INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE BassiRebaySides_MappedTensor3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ApplyFlip_MappedScalar2D_gpu_wrapper ( extBoundary , selfSideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"ApplyFlip_MappedScalar2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: selfSideInfo , elemToRank , extBoundary INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE ApplyFlip_MappedScalar2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ApplyFlip_MappedVector2D_gpu_wrapper ( extBoundary , selfSideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"ApplyFlip_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: selfSideInfo , elemToRank , extBoundary INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE ApplyFlip_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ApplyFlip_MappedTensor2D_gpu_wrapper ( extBoundary , selfSideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"ApplyFlip_MappedTensor2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: selfSideInfo , elemToRank , extBoundary INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE ApplyFlip_MappedTensor2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ApplyFlip_MappedScalar3D_gpu_wrapper ( extBoundary , selfSideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"ApplyFlip_MappedScalar3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: selfSideInfo , elemToRank , extBoundary INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE ApplyFlip_MappedScalar3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ApplyFlip_MappedVector3D_gpu_wrapper ( extBoundary , selfSideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"ApplyFlip_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: selfSideInfo , elemToRank , extBoundary INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE ApplyFlip_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ApplyFlip_MappedTensor3D_gpu_wrapper ( extBoundary , selfSideInfo , elemToRank , rankId , N , nVar , nEl ) & bind ( c , name = \"ApplyFlip_MappedTensor3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: selfSideInfo , elemToRank , extBoundary INTEGER ( C_INT ), VALUE :: rankId , N , nVar , nEl END SUBROUTINE ApplyFlip_MappedTensor3D_gpu_wrapper END INTERFACE CONTAINS ! ---------------------- Scalars ---------------------- ! SUBROUTINE Derivative_MappedScalar1D ( scalar , geometry , dF , dForm , gpuAccel ) ! Strong Form Operator ! ! Calculates the gradient of a scalar 1D function using the conservative form of the ! mapped gradient operator ! ! df/dx =  d\\xi/dx( df/d\\xi ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( in ) :: scalar TYPE ( Geometry1D ), INTENT ( in ) :: geometry TYPE ( MappedScalar1D ), INTENT ( inout ) :: dF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL scalar % interp % DGDerivative_1D ( scalar % interior % deviceData , & scalar % boundary % deviceData , & df % interior % deviceData , & scalar % nVar , & scalar % nElem ) ELSE CALL scalar % interp % DGDerivative_1D ( scalar % interior % hostData , & scalar % boundary % hostData , & df % interior % hostData , & scalar % nVar , & scalar % nElem ) END IF ELSEIF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL scalar % interp % Derivative_1D ( scalar % interior % deviceData , & df % interior % deviceData , & scalar % nVar , & scalar % nElem ) ELSE CALL scalar % interp % Derivative_1D ( scalar % interior % hostData , & df % interior % hostData , & scalar % nVar , & scalar % nElem ) END IF END IF CALL df % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Derivative_MappedScalar1D SUBROUTINE JacobianWeight_MappedScalar1D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar1D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( inout ) :: scalar TYPE ( Geometry1D ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i IF ( gpuAccel ) THEN CALL JacobianWeight_MappedScalar1D_gpu_wrapper ( scalar % interior % deviceData , & geometry % dxds % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO i = 0 , scalar % N scalar % interior % hostData ( i , iVar , iEl ) = scalar % interior % hostData ( i , iVar , iEl ) / & geometry % dxds % interior % hostData ( i , 1 , iEl ) END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedScalar1D SUBROUTINE SideExchange_MappedScalar2D ( scalar , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( Mesh2D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 INTEGER :: flip , bcid INTEGER :: i1 , i2 , ivar INTEGER :: neighborRank IF ( gpuAccel ) THEN CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL SideExchange_MappedScalar2D_gpu_wrapper ( scalar % extBoundary % deviceData , & scalar % boundary % deviceData , & mesh % self_sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & scalar % N , & scalar % nvar , & scalar % nElem ) CALL decomp % FinalizeMPIExchangeAsync () ELSE CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 4 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % self_sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2 ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , scalar % nvar DO i1 = 0 , scalar % N scalar % extBoundary % hostData ( i1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i1 , ivar , s2 , e2 ) END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , scalar % nvar DO i1 = 0 , scalar % N i2 = scalar % N - i1 scalar % extBoundary % hostData ( i1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , ivar , s2 , e2 ) END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL scalar % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedScalar2D SUBROUTINE BassiRebaySides_MappedScalar2D ( scalar , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedScalar2D_gpu_wrapper ( scalar % avgBoundary % deviceData , & scalar % boundary % deviceData , & scalar % extBoundary % deviceData , & scalar % N , & scalar % nvar , & scalar % nElem ) ELSE DO iel = 1 , scalar % nElem DO iside = 1 , 4 DO ivar = 1 , scalar % nVar DO i = 0 , scalar % N scalar % avgBoundary % hostData ( i , ivar , iside , iel ) = 0.5_prec * ( & scalar % boundary % hostData ( i , ivar , iside , iel ) + & scalar % extBoundary % hostData ( i , ivar , iside , iel )) END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedScalar2D SUBROUTINE Gradient_MappedScalar2D ( scalar , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator - (Conservative Form) ! ! Calculates the gradient of a scalar 2D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( in ) :: scalar TYPE ( MappedTensor2D ), INTENT ( inout ) :: workTensor TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedVector2D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL scalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSEIF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF END IF CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedScalar2D SUBROUTINE ContravariantWeight_MappedScalar2D ( scalar , geometry , workTensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantWeight_MappedScalar2D\" IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( in ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel TYPE ( MappedTensor2D ), INTENT ( inout ) :: workTensor ! Local INTEGER :: i , j , iVar , iEl , iside IF ( gpuAccel ) THEN CALL ContravariantWeight_MappedScalar2D_gpu_wrapper ( scalar % interior % deviceData , & workTensor % interior % deviceData , & geometry % dsdx % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) CALL ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper ( scalar % avgBoundary % deviceData , & workTensor % boundary % deviceData , & geometry % dsdx % boundary % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N workTensor % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 1 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) workTensor % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 2 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) workTensor % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 1 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) workTensor % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 2 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ! Boundary Terms DO iEl = 1 , scalar % nElem DO iside = 1 , 4 DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N workTensor % boundary % hostData ( 1 , 1 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 1 , j , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 1 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 2 , j , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , iVar , iside , iEl ) workTensor % boundary % hostData ( 1 , 2 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 1 , j , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 2 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 2 , j , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , iVar , iside , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE ContravariantWeight_MappedScalar2D SUBROUTINE JacobianWeight_MappedScalar2D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j IF ( gpuAccel ) THEN CALL JacobianWeight_MappedScalar2D_gpu_wrapper ( scalar % interior % deviceData , & geometry % J % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % interior % hostData ( i , j , iVar , iEl ) = scalar % interior % hostData ( i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedScalar2D ! SideExchange_MappedScalar3D is used to populate scalar % extBoundary ! by finding neighboring elements that share a side and copying the neighboring ! elements solution % boundary data. SUBROUTINE SideExchange_MappedScalar3D ( scalar , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( Mesh3D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 INTEGER :: flip , bcid , globalSideId INTEGER :: neighborRank INTEGER :: i1 , i2 , j1 , j2 , ivar IF ( gpuAccel ) THEN CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL SideExchange_MappedScalar3D_gpu_wrapper ( scalar % extBoundary % deviceData , & scalar % boundary % deviceData , & mesh % self_sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & scalar % N , & scalar % nvar , & scalar % nElem ) CALL decomp % FinalizeMPIExchangeAsync () ELSE CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 6 globalSideId = mesh % self_sideInfo % hostData ( 2 , s1 , e1 ) e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % self_sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2 ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % N DO i1 = 0 , scalar % N scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i1 , j1 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % N DO i1 = 0 , scalar % N i2 = scalar % N - j1 j2 = i1 scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 2 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % N DO i1 = 0 , scalar % N i2 = scalar % N - i1 j2 = scalar % N - j1 scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % N DO i1 = 0 , scalar % N i2 = j1 j2 = scalar % N - i1 scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL scalar % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedScalar3D SUBROUTINE BassiRebaySides_MappedScalar3D ( scalar , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i , j IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedScalar3D_gpu_wrapper ( scalar % avgBoundary % deviceData , & scalar % boundary % deviceData , & scalar % extBoundary % deviceData , & scalar % N , & scalar % nvar , & scalar % nElem ) ELSE DO iel = 1 , scalar % nElem DO iside = 1 , 6 DO ivar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % avgBoundary % hostData ( i , j , ivar , iside , iel ) = 0.5_prec * ( & scalar % boundary % hostData ( i , j , ivar , iside , iel ) + & scalar % extBoundary % hostData ( i , j , ivar , iside , iel )) END DO END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedScalar3D SUBROUTINE Gradient_MappedScalar3D ( scalar , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator ! ! Calculates the gradient of a scalar 3D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( in ) :: scalar TYPE ( MappedTensor3D ), INTENT ( inout ) :: workTensor TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedVector3D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL scalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF END IF CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedScalar3D SUBROUTINE ContravariantWeight_MappedScalar3D ( scalar , geometry , workTensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantWeight_MappedScalar3D\" IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( in ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel TYPE ( MappedTensor3D ), INTENT ( inout ) :: workTensor ! Local INTEGER :: i , j , k , iVar , iEl , iside IF ( gpuAccel ) THEN CALL ContravariantWeight_MappedScalar3D_gpu_wrapper ( scalar % interior % deviceData , & workTensor % interior % deviceData , & geometry % dsdx % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) CALL ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper ( scalar % avgBoundary % deviceData , & workTensor % boundary % deviceData , & geometry % dsdx % boundary % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N DO i = 0 , scalar % N ! Get the x-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) ! Get the y-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) ! Get the z-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO END DO END DO END DO ! Boundary Term DO iEl = 1 , scalar % nElem DO iside = 1 , 6 DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N ! Get the x-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % boundary % hostData ( 1 , 1 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 1 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 1 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 2 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 3 , 1 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 3 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) ! Get the y-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % boundary % hostData ( 1 , 2 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 1 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 2 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 2 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 3 , 2 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 3 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) ! Get the z-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % boundary % hostData ( 1 , 3 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 3 , 1 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 3 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 3 , 2 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 3 , 3 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 3 , 3 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) END DO END DO END DO END DO END DO END IF END SUBROUTINE ContravariantWeight_MappedScalar3D SUBROUTINE JacobianWeight_MappedScalar3D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k IF ( gpuAccel ) THEN CALL JacobianWeight_MappedScalar3D_gpu_wrapper ( scalar % interior % deviceData , & geometry % J % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % interior % hostData ( i , j , k , iVar , iEl ) = scalar % interior % hostData ( i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) END DO END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedScalar3D ! ---------------------- Vectors ---------------------- ! ! SideExchange_MappedVectorvector2D is used to populate vector % extBoundary ! by finding neighboring elements that share a side and copying the neighboring ! elements solution % boundary data. SUBROUTINE SideExchange_MappedVector2D ( vector , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( Mesh2D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 INTEGER :: flip , bcid , globalSideId INTEGER :: neighborRank INTEGER :: i1 , i2 , ivar IF ( gpuAccel ) THEN CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL SideExchange_MappedVector2D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & mesh % self_sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & vector % N , & vector % nvar , & vector % nElem ) CALL decomp % FinalizeMPIExchangeAsync () ELSE CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 4 globalSideId = mesh % self_sideInfo % hostData ( 2 , s1 , e1 ) e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % self_sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2 ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , vector % nvar DO i1 = 0 , vector % N vector % extBoundary % hostData ( 1 : 2 , i1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 2 , i1 , ivar , s2 , e2 ) END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , vector % nvar DO i1 = 0 , vector % N i2 = vector % N - i1 vector % extBoundary % hostData ( 1 : 2 , i1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 2 , i2 , ivar , s2 , e2 ) END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL vector % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedVector2D SUBROUTINE BassiRebaySides_MappedVector2D ( vector , gpuAccel ) IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedVector2D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & vector % N , & vector % nvar , & vector % nElem ) ELSE DO iel = 1 , vector % nElem DO iside = 1 , 4 DO ivar = 1 , vector % nVar DO i = 0 , vector % N vector % boundary % hostData ( 1 : 2 , i , ivar , iside , iel ) = 0.5_prec * ( & vector % boundary % hostData ( 1 : 2 , i , ivar , iside , iel ) + & vector % extBoundary % hostData ( 1 : 2 , i , ivar , iside , iel )) END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedVector2D SUBROUTINE Divergence_MappedVector2D ( compVector , geometry , divVector , dForm , gpuAccel ) ! Strong Form Operator ! ! DG Weak Form Operator ! ! Assumes vector has been projected to computational coordinates ! IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: compVector TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedScalar2D ), INTENT ( inout ) :: divVector INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDGDivergence_2D ( compVector % interior % deviceData , & compVector % boundaryNormal % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDGDivergence_2D ( compVector % interior % hostData , & compVector % boundaryNormal % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDivergence_2D ( compVector % interior % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDivergence_2D ( compVector % interior % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF END IF CALL divVector % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Divergence_MappedVector2D SUBROUTINE Gradient_MappedVector2D ( vector , workScalar , workVector , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator - (Conservative Form) ! ! Calculates the gradient of a scalar 2D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: vector TYPE ( MappedScalar2D ), INTENT ( inout ) :: workScalar ! (scalar) nvar = 2*nvar TYPE ( MappedVector2D ), INTENT ( inout ) :: workVector ! (scalar) nvar = 2*nvar TYPE ( MappedTensor2D ), INTENT ( inout ) :: workTensor ! (tensor) nvar = 2*nvar TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedTensor2D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL vector % MapToScalar ( workScalar , gpuAccel ) CALL workScalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF END IF CALL workVector % MapToTensor ( gradF , gpuAccel ) CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedVector2D SUBROUTINE MapToScalar_MappedVector2D ( vector , scalar , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToScalar_MappedVector2D\" IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: vector TYPE ( MappedScalar2D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , i , j , ivar , jvar , iel , iside IF ( gpuAccel ) THEN CALL MapToScalar_MappedVector2D_gpu_wrapper ( scalar % interior % deviceData , & vector % interior % deviceData , & vector % N , & vector % nVar , & vector % nelem ) CALL MapToScalarBoundary_MappedVector2D_gpu_wrapper ( scalar % boundary % deviceData , & vector % boundary % deviceData , & vector % N , & vector % nVar , & vector % nelem ) ELSE DO iel = 1 , vector % nelem DO ivar = 1 , vector % nvar DO j = 0 , vector % N DO i = 0 , vector % N DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) scalar % interior % hostData ( i , j , jvar , iel ) = vector % interior % hostData ( row , i , j , ivar , iel ) END DO END DO END DO END DO END DO ! Boundary Terms DO iel = 1 , vector % nelem DO iside = 1 , 4 DO ivar = 1 , vector % nvar DO j = 0 , vector % N DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) scalar % boundary % hostData ( j , jvar , iside , iel ) = vector % boundary % hostData ( row , j , ivar , iside , iel ) END DO END DO END DO END DO END DO END IF END SUBROUTINE MapToScalar_MappedVector2D SUBROUTINE MapToTensor_MappedVector2D ( vector , tensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToTensor_MappedVector2D\" IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: vector TYPE ( MappedTensor2D ), INTENT ( inout ) :: tensor LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , col , i , j , ivar , jvar , iel , iside IF ( gpuAccel ) THEN CALL MapToTensor_MappedVector2D_gpu_wrapper ( tensor % interior % deviceData , & vector % interior % deviceData , & tensor % N , & tensor % nVar , & tensor % nelem ) CALL MapToTensorBoundary_MappedVector2D_gpu_wrapper ( tensor % boundary % deviceData , & vector % boundary % deviceData , & tensor % N , & tensor % nVar , & tensor % nelem ) ELSE DO iel = 1 , tensor % nelem DO ivar = 1 , tensor % nvar DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) tensor % interior % hostData ( row , col , i , j , ivar , iel ) = vector % interior % hostData ( col , i , j , jvar , iel ) END DO END DO END DO END DO END DO END DO ! Boundary Terms DO iel = 1 , tensor % nelem DO iside = 1 , 4 DO ivar = 1 , tensor % nvar DO j = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) tensor % boundary % hostData ( row , col , j , ivar , iside , iel ) = vector % boundary % hostData ( col , j , jvar , iside , iel ) END DO END DO END DO END DO END DO END DO END IF END SUBROUTINE MapToTensor_MappedVector2D SUBROUTINE ContravariantProjection_MappedVector2D ( physVector , geometry , compVector , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantProjection_MappedVector2D\" ! Takes a vector that has physical space coordinate directions (x,y,z) and projects the vector ! into the the contravariant basis vector directions. Keep in mind that the contravariant basis ! vectors are really the Jacobian weighted contravariant basis vectors IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: physVector TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel TYPE ( MappedVector2D ), INTENT ( inout ) :: compVector ! Local INTEGER :: i , j , ivar , iel , iside REAL ( prec ) :: nhat ( 1 : 2 ) REAL ( prec ) :: nmag IF ( gpuAccel ) THEN CALL ContravariantProjection_MappedVector2D_gpu_wrapper ( physVector % interior % deviceData , & compVector % interior % deviceData , & geometry % dsdx % interior % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) CALL ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper ( physVector % boundary % deviceData , & compVector % boundaryNormal % deviceData , & geometry % nHat % boundary % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) ELSE ! Assume that tensor(j,i) is vector i, component j ! => dot product is done along first dimension ! to project onto computational space DO iel = 1 , physVector % nElem DO ivar = 1 , physVector % nVar DO j = 0 , physVector % N DO i = 0 , physVector % N compVector % interior % hostData ( 1 , i , j , ivar , iel ) = & geometry % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iel ) * & physVector % interior % hostData ( 1 , i , j , ivar , iel ) + & geometry % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iel ) * & physVector % interior % hostData ( 2 , i , j , ivar , iel ) compVector % interior % hostData ( 2 , i , j , ivar , iel ) = & geometry % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iel ) * & physVector % interior % hostData ( 1 , i , j , ivar , iel ) + & geometry % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iel ) * & physVector % interior % hostData ( 2 , i , j , ivar , iel ) END DO END DO END DO END DO ! Boundary Terms DO iel = 1 , physVector % nElem DO iside = 1 , 4 DO ivar = 1 , physVector % nVar DO j = 0 , physVector % N nhat ( 1 : 2 ) = geometry % nHat % boundary % hostData ( 1 : 2 , j , 1 , iSide , iEl ) nmag = geometry % nScale % boundary % hostData ( j , 1 , iSide , iEl ) compVector % boundaryNormal % hostData ( j , ivar , iside , iel ) = & ( nhat ( 1 ) * physVector % boundary % hostData ( 1 , j , ivar , iside , iel ) + & nhat ( 2 ) * physVector % boundary % hostData ( 2 , j , ivar , iside , iel ) ) * nmag END DO END DO END DO END DO END IF END SUBROUTINE ContravariantProjection_MappedVector2D SUBROUTINE JacobianWeight_MappedVector2D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedVector2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j IF ( gpuAccel ) THEN CALL JacobianWeight_MappedVector2D_gpu_wrapper ( vector % interior % deviceData , & geometry % J % interior % deviceData , & vector % N , & vector % nVar , & vector % nElem ) ELSE DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO j = 0 , vector % N DO i = 0 , vector % N vector % interior % hostData ( 1 , i , j , iVar , iEl ) = vector % interior % hostData ( 1 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) vector % interior % hostData ( 2 , i , j , iVar , iEl ) = vector % interior % hostData ( 2 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedVector2D ! SideExchange_MappedVector3D is used to populate vector % extBoundary ! by finding neighboring elements that share a side and copying the neighboring ! elements solution % boundary data. SUBROUTINE SideExchange_MappedVector3D ( vector , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( Mesh3D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 INTEGER :: flip , bcid , globalSideId INTEGER :: neighborRank INTEGER :: i1 , i2 , j1 , j2 , ivar IF ( gpuAccel ) THEN CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL SideExchange_MappedVector3D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & mesh % self_sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & vector % N , & vector % nvar , & vector % nElem ) CALL decomp % FinalizeMPIExchangeAsync () ELSE CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 6 globalSideId = mesh % self_sideInfo % hostData ( 2 , s1 , e1 ) e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % self_sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN ! Interior neighborRank = decomp % elemToRank % hostData ( e2 ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % N DO i1 = 0 , vector % N vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i1 , j1 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % N DO i1 = 0 , vector % N i2 = vector % N - j1 j2 = i1 vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 2 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % N DO i1 = 0 , vector % N i2 = vector % N - i1 j2 = vector % N - j1 vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % N DO i1 = 0 , vector % N i2 = j1 j2 = vector % N - i1 vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL vector % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedVector3D SUBROUTINE BassiRebaySides_MappedVector3D ( vector , gpuAccel ) IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i , j IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedVector3D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & vector % N , & vector % nvar , & vector % nElem ) ELSE DO iel = 1 , vector % nElem DO iside = 1 , 6 DO ivar = 1 , vector % nVar DO j = 0 , vector % N DO i = 0 , vector % N vector % boundary % hostData ( 1 : 3 , i , j , ivar , iside , iel ) = 0.5_prec * ( & vector % boundary % hostData ( 1 : 3 , i , j , ivar , iside , iel ) + & vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , iside , iel )) END DO END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedVector3D SUBROUTINE Divergence_MappedVector3D ( compVector , geometry , divVector , dForm , gpuAccel ) ! IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: compVector TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedScalar3D ), INTENT ( inout ) :: divVector INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDGDivergence_3D ( compVector % interior % deviceData , & compVector % boundaryNormal % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDGDivergence_3D ( compVector % interior % hostData , & compVector % boundaryNormal % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDivergence_3D ( compVector % interior % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDivergence_3D ( compVector % interior % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF END IF CALL divVector % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Divergence_MappedVector3D SUBROUTINE Gradient_MappedVector3D ( vector , workScalar , workVector , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator - (Conservative Form) ! ! Calculates the gradient of a scalar 3D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: vector TYPE ( MappedScalar3D ), INTENT ( inout ) :: workScalar ! (scalar) nvar = 3*nvar TYPE ( MappedVector3D ), INTENT ( inout ) :: workVector ! (vector) nvar = 3*nvar TYPE ( MappedTensor3D ), INTENT ( inout ) :: workTensor ! (tensor) nvar = 3*nvar TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedTensor3D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL vector % MapToScalar ( workScalar , gpuAccel ) CALL workScalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF END IF CALL workVector % MapToTensor ( gradF , gpuAccel ) CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedVector3D SUBROUTINE MapToScalar_MappedVector3D ( vector , scalar , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToScalar_MappedVector3D\" IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: vector TYPE ( MappedScalar3D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , i , j , k , ivar , jvar , iel , iside IF ( gpuAccel ) THEN CALL MapToScalar_MappedVector3D_gpu_wrapper ( scalar % interior % deviceData , & vector % interior % deviceData , & vector % N , & vector % nVar , & vector % nelem ) CALL MapToScalarBoundary_MappedVector3D_gpu_wrapper ( scalar % boundary % deviceData , & vector % boundary % deviceData , & vector % N , & vector % nVar , & vector % nelem ) ELSE DO iel = 1 , vector % nelem DO ivar = 1 , vector % nvar DO k = 0 , vector % N DO j = 0 , vector % N DO i = 0 , vector % N DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) scalar % interior % hostData ( i , j , k , jvar , iel ) = vector % interior % hostData ( row , i , j , k , ivar , iel ) END DO END DO END DO END DO END DO END DO ! Boundary Terms DO iel = 1 , vector % nelem DO iside = 1 , 6 DO ivar = 1 , vector % nvar DO k = 0 , vector % N DO j = 0 , vector % N DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) scalar % boundary % hostData ( j , k , jvar , iside , iel ) = vector % boundary % hostData ( row , j , k , ivar , iside , iel ) END DO END DO END DO END DO END DO END DO END IF END SUBROUTINE MapToScalar_MappedVector3D SUBROUTINE MapToTensor_MappedVector3D ( vector , tensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToTensor_MappedVector3D\" IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: vector TYPE ( MappedTensor3D ), INTENT ( inout ) :: tensor LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , col , i , j , k , ivar , jvar , iel , iside IF ( gpuAccel ) THEN CALL MapToTensor_MappedVector3D_gpu_wrapper ( tensor % interior % deviceData , & vector % interior % deviceData , & tensor % N , & tensor % nVar , & tensor % nelem ) CALL MapToTensorBoundary_MappedVector3D_gpu_wrapper ( tensor % boundary % deviceData , & vector % boundary % deviceData , & tensor % N , & tensor % nVar , & tensor % nelem ) ELSE DO iel = 1 , tensor % nelem DO ivar = 1 , tensor % nvar DO k = 0 , tensor % N DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) tensor % interior % hostData ( row , col , i , j , k , ivar , iel ) = vector % interior % hostData ( col , i , j , k , jvar , iel ) END DO END DO END DO END DO END DO END DO END DO ! Boundary Terms DO iel = 1 , tensor % nelem DO iside = 1 , 6 DO ivar = 1 , tensor % nvar DO k = 0 , tensor % N DO j = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) tensor % boundary % hostData ( row , col , j , k , ivar , iside , iel ) = vector % boundary % hostData ( col , j , k , jvar , iside , iel ) END DO END DO END DO END DO END DO END DO END DO END IF END SUBROUTINE MapToTensor_MappedVector3D SUBROUTINE ContravariantProjection_MappedVector3D ( physVector , geometry , compVector , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantProjection_MappedVector3D\" ! Takes a vector that has physical space coordinate directions (x,y,z) and projects the vector ! into the the contravariant basis vector directions. Keep in mind that the contravariant basis ! vectors are really the Jacobian weighted contravariant basis vectors IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: physVector TYPE ( MappedVector3D ), INTENT ( inout ) :: compVector TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , k , iVar , iEl , iside REAL ( prec ) :: nHat ( 1 : 3 ) REAL ( prec ) :: nmag IF ( gpuAccel ) THEN CALL ContravariantProjection_MappedVector3D_gpu_wrapper ( physVector % interior % deviceData , & compVector % interior % deviceData , & geometry % dsdx % interior % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) CALL ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper ( physVector % boundary % deviceData , & compVector % boundaryNormal % deviceData , & geometry % nHat % boundary % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) ELSE ! Assume that tensor(j,i) is vector i, component j ! => dot product is done along first dimension to ! project onto computational space DO iEl = 1 , physVector % nElem DO iVar = 1 , physVector % nVar DO k = 0 , physVector % N DO j = 0 , physVector % N DO i = 0 , physVector % N compVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) compVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) compVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) END DO END DO END DO END DO END DO ! Boundary Terms DO iEl = 1 , physVector % nElem DO iside = 1 , 6 DO iVar = 1 , physVector % nVar DO k = 0 , physVector % N DO j = 0 , physVector % N nHat ( 1 : 3 ) = geometry % nHat % boundary % hostData ( 1 : 3 , j , k , 1 , iSide , iEl ) nmag = geometry % nScale % boundary % hostData ( j , k , 1 , iSide , iEl ) compVector % boundaryNormal % hostData ( j , k , iVar , iside , iEl ) = & ( nHat ( 1 ) * physVector % boundary % hostData ( 1 , j , k , iVar , iside , iEl ) + & nHat ( 2 ) * physVector % boundary % hostData ( 2 , j , k , iVar , iside , iEl ) + & nHat ( 3 ) * physVector % boundary % hostData ( 3 , j , k , iVar , iside , iEl ) ) * nmag END DO END DO END DO END DO END DO END IF END SUBROUTINE ContravariantProjection_MappedVector3D SUBROUTINE JacobianWeight_MappedVector3D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedVector3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k IF ( gpuAccel ) THEN CALL JacobianWeight_MappedVector3D_gpu_wrapper ( vector % interior % deviceData , & geometry % J % interior % deviceData , & vector % N , & vector % nVar , & vector % nElem ) ELSE DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO k = 0 , vector % N DO j = 0 , vector % N DO i = 0 , vector % N vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) END DO END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedVector3D ! ---------------------- Tensors ---------------------- ! ! SideExchange_MappedTensor2D is used to populate tensor % extBoundary ! by finding neighboring elements that share a side and copying the neighboring ! elements solution % boundary data. SUBROUTINE SideExchange_MappedTensor2D ( tensor , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedTensor2D ), INTENT ( inout ) :: tensor TYPE ( Mesh2D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 INTEGER :: flip , bcid , globalSideId INTEGER :: neighborRank INTEGER :: i1 , i2 , ivar IF ( gpuAccel ) THEN CALL tensor % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL SideExchange_MappedTensor2D_gpu_wrapper ( tensor % extBoundary % deviceData , & tensor % boundary % deviceData , & mesh % self_sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & tensor % N , & tensor % nvar , & tensor % nElem ) CALL decomp % FinalizeMPIExchangeAsync () ELSE CALL tensor % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 4 globalSideId = mesh % self_sideInfo % hostData ( 2 , s1 , e1 ) e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % self_sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2 ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , tensor % nvar DO i1 = 0 , tensor % N tensor % extBoundary % hostData ( 1 : 2 , 1 : 2 , i1 , ivar , s1 , e1 ) = & tensor % boundary % hostData ( 1 : 2 , 1 : 2 , i1 , ivar , s2 , e2 ) END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , tensor % nvar DO i1 = 0 , tensor % N i2 = tensor % N - i1 tensor % extBoundary % hostData ( 1 : 2 , 1 : 2 , i1 , ivar , s1 , e1 ) = & tensor % boundary % hostData ( 1 : 2 , 1 : 2 , i2 , ivar , s2 , e2 ) END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL tensor % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedTensor2D SUBROUTINE BassiRebaySides_MappedTensor2D ( tensor , gpuAccel ) IMPLICIT NONE CLASS ( MappedTensor2D ), INTENT ( inout ) :: tensor LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedTensor2D_gpu_wrapper ( tensor % extBoundary % deviceData , & tensor % boundary % deviceData , & tensor % N , & tensor % nvar , & tensor % nElem ) ELSE DO iel = 1 , tensor % nElem DO iside = 1 , 4 DO ivar = 1 , tensor % nVar DO i = 0 , tensor % N tensor % boundary % hostData ( 1 : 2 , 1 : 2 , i , ivar , iside , iel ) = 0.5_prec * ( & tensor % boundary % hostData ( 1 : 2 , 1 : 2 , i , ivar , iside , iel ) + & tensor % extBoundary % hostData ( 1 : 2 , 1 : 2 , i , ivar , iside , iel )) END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedTensor2D SUBROUTINE JacobianWeight_MappedTensor2D ( tensor , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedTensor2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedTensor2D ), INTENT ( inout ) :: tensor TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j IF ( gpuAccel ) THEN CALL JacobianWeight_MappedTensor2D_gpu_wrapper ( tensor % interior % deviceData , & geometry % J % interior % deviceData , & tensor % N , & tensor % nVar , & tensor % nElem ) ELSE DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) = tensor % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) tensor % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) = tensor % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) tensor % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) = tensor % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) tensor % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) = tensor % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedTensor2D ! SideExchange_MappedVector3D is used to populate vector % extBoundary ! by finding neighboring elements that share a side and copying the neighboring ! elements solution % boundary data. SUBROUTINE SideExchange_MappedTensor3D ( tensor , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedTensor3D ), INTENT ( inout ) :: tensor TYPE ( Mesh3D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 INTEGER :: flip , bcid , globalSideId INTEGER :: neighborRank INTEGER :: i1 , i2 , j1 , j2 , ivar IF ( gpuAccel ) THEN CALL tensor % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL SideExchange_MappedTensor3D_gpu_wrapper ( tensor % extBoundary % deviceData , & tensor % boundary % deviceData , & mesh % self_sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & tensor % N , & tensor % nvar , & tensor % nElem ) CALL decomp % FinalizeMPIExchangeAsync () ELSE CALL tensor % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 6 globalSideId = mesh % self_sideInfo % hostData ( 2 , s1 , e1 ) e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % self_sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2 ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , tensor % nvar DO j1 = 0 , tensor % N DO i1 = 0 , tensor % N tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & tensor % boundary % hostData ( 1 : 3 , 1 : 3 , i1 , j1 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , tensor % nvar DO j1 = 0 , tensor % N DO i1 = 0 , tensor % N i2 = tensor % N - j1 j2 = i1 tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & tensor % boundary % hostData ( 1 : 3 , 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 2 ) THEN DO ivar = 1 , tensor % nvar DO j1 = 0 , tensor % N DO i1 = 0 , tensor % N i2 = tensor % N - i1 j2 = tensor % N - j1 tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & tensor % boundary % hostData ( 1 : 3 , 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , tensor % nvar DO j1 = 0 , tensor % N DO i1 = 0 , tensor % N i2 = j1 j2 = tensor % N - i1 tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & tensor % boundary % hostData ( 1 : 3 , 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL tensor % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedTensor3D SUBROUTINE BassiRebaySides_MappedTensor3D ( tensor , gpuAccel ) IMPLICIT NONE CLASS ( MappedTensor3D ), INTENT ( inout ) :: tensor LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i , j IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedTensor3D_gpu_wrapper ( tensor % extBoundary % deviceData , & tensor % boundary % deviceData , & tensor % N , & tensor % nvar , & tensor % nElem ) ELSE DO iel = 1 , tensor % nElem DO iside = 1 , 6 DO ivar = 1 , tensor % nVar DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , ivar , iside , iel ) = 0.5_prec * ( & tensor % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , ivar , iside , iel ) + & tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i , j , ivar , iside , iel )) END DO END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedTensor3D SUBROUTINE JacobianWeight_MappedTensor3D ( tensor , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedTensor3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedTensor3D ), INTENT ( inout ) :: tensor TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k IF ( gpuAccel ) THEN CALL JacobianWeight_MappedTensor3D_gpu_wrapper ( tensor % interior % deviceData , & geometry % J % interior % deviceData , & tensor % N , & tensor % nVar , & tensor % nElem ) ELSE DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO k = 0 , tensor % N DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) END DO END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedTensor3D ! --- MPI Routines --- ! SUBROUTINE MPIExchangeAsync_MappedScalar2D ( scalar , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , scalar % nElem DO s1 = 1 , 4 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) msgCount = msgCount + 1 CALL MPI_IRECV ( scalar % extBoundary % hostData (:,:, s1 , e1 ), & ( scalar % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( scalar % boundary % hostData (:,:, s1 , e1 ), & ( scalar % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedScalar2D ! SUBROUTINE ApplyFlip_MappedScalar2D ( scalar , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId REAL ( prec ) :: extBuff ( 0 : scalar % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedScalar2D_gpu_wrapper ( scalar % extBoundary % deviceData , & mesh % self_sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & scalar % N , & scalar % nVar , & scalar % nElem ) ELSE DO e1 = 1 , scalar % nElem DO s1 = 1 , 4 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) ! Need to update extBoundary with flip applied IF ( flip == 1 ) THEN DO ivar = 1 , scalar % nvar DO i = 0 , scalar % N i2 = scalar % N - i extBuff ( i ) = scalar % extBoundary % hostData ( i2 , ivar , s1 , e1 ) END DO DO i = 0 , scalar % N scalar % extBoundary % hostData ( i , ivar , s1 , e1 ) = extBuff ( i ) END DO END DO END IF END IF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedScalar2D SUBROUTINE MPIExchangeAsync_MappedVector2D ( vector , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , vector % nElem DO s1 = 1 , 4 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) msgCount = msgCount + 1 CALL MPI_IRECV ( vector % extBoundary % hostData (:,:,:, s1 , e1 ), & 2 * ( vector % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( vector % boundary % hostData (:,:,:, s1 , e1 ), & 2 * ( vector % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedVector2D SUBROUTINE ApplyFlip_MappedVector2D ( vector , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId REAL ( prec ) :: extBuff ( 1 : 2 , 0 : vector % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedVector2D_gpu_wrapper ( vector % extBoundary % deviceData , & mesh % self_sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & vector % N , & vector % nVar , & vector % nElem ) ELSE DO e1 = 1 , vector % nElem DO s1 = 1 , 4 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) ! Need to update extBoundary with flip applied IF ( flip == 1 ) THEN DO ivar = 1 , vector % nvar DO i = 0 , vector % N i2 = vector % N - i extBuff ( 1 : 2 , i ) = vector % extBoundary % hostData ( 1 : 2 , i2 , ivar , s1 , e1 ) END DO DO i = 0 , vector % N vector % extBoundary % hostData ( 1 : 2 , i , ivar , s1 , e1 ) = extBuff ( 1 : 2 , i ) END DO END DO END IF END IF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedVector2D SUBROUTINE MPIExchangeAsync_MappedTensor2D ( tensor , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedTensor2D ), INTENT ( inout ) :: tensor TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , tensor % nElem DO s1 = 1 , 4 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) msgCount = msgCount + 1 CALL MPI_IRECV ( tensor % extBoundary % hostData (:,:,:,:, s1 , e1 ), & 4 * ( tensor % N + 1 ) * tensor % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( tensor % boundary % hostData (:,:,:,:, s1 , e1 ), & 4 * ( tensor % N + 1 ) * tensor % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedTensor2D SUBROUTINE ApplyFlip_MappedTensor2D ( tensor , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedTensor2D ), INTENT ( inout ) :: tensor TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId REAL ( prec ) :: extBuff ( 1 : 2 , 1 : 2 , 0 : tensor % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedTensor2D_gpu_wrapper ( tensor % extBoundary % deviceData , & mesh % self_sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & tensor % N , & tensor % nVar , & tensor % nElem ) ELSE DO e1 = 1 , tensor % nElem DO s1 = 1 , 4 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) ! Need to update extBoundary with flip applied IF ( flip == 1 ) THEN DO ivar = 1 , tensor % nvar DO i = 0 , tensor % N i2 = tensor % N - i extBuff ( 1 : 2 , 1 : 2 , i ) = tensor % extBoundary % hostData ( 1 : 2 , 1 : 2 , i2 , ivar , s1 , e1 ) END DO DO i = 0 , tensor % N tensor % extBoundary % hostData ( 1 : 2 , 1 : 2 , i , ivar , s1 , e1 ) = extBuff ( 1 : 2 , 1 : 2 , i ) END DO END DO END IF END IF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedTensor2D SUBROUTINE MPIExchangeAsync_MappedScalar3D ( scalar , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , scalar % nElem DO s1 = 1 , 6 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) msgCount = msgCount + 1 CALL MPI_IRECV ( scalar % extBoundary % hostData (:,:,:, s1 , e1 ), & ( scalar % N + 1 ) * ( scalar % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( scalar % boundary % hostData (:,:,:, s1 , e1 ), & ( scalar % N + 1 ) * ( scalar % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedScalar3D ! SUBROUTINE ApplyFlip_MappedScalar3D ( scalar , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 , j , j2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId REAL ( prec ) :: extBuff ( 0 : scalar % N , 0 : scalar % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedScalar3D_gpu_wrapper ( scalar % extBoundary % deviceData , & mesh % self_sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & scalar % N , & scalar % nVar , & scalar % nElem ) ELSE DO e1 = 1 , scalar % nElem DO s1 = 1 , 6 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) ! Need to update extBoundary with flip applied IF ( flip == 2 ) THEN DO ivar = 1 , scalar % nvar DO j = 0 , scalar % N DO i = 0 , scalar % N i2 = scalar % N - j j2 = i extBuff ( i , j ) = scalar % extBoundary % hostData ( i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % extBoundary % hostData ( i , j , ivar , s1 , e1 ) = extBuff ( i , j ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , scalar % nvar DO j = 0 , scalar % N DO i = 0 , scalar % N i2 = scalar % N - i j2 = scalar % N - j extBuff ( i , j ) = scalar % extBoundary % hostData ( i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % extBoundary % hostData ( i , j , ivar , s1 , e1 ) = extBuff ( i , j ) END DO END DO END DO ELSEIF ( flip == 4 ) THEN DO ivar = 1 , scalar % nvar DO j = 0 , scalar % N DO i = 0 , scalar % N i2 = j j2 = scalar % N - i extBuff ( i , j ) = scalar % extBoundary % hostData ( i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % extBoundary % hostData ( i , j , ivar , s1 , e1 ) = extBuff ( i , j ) END DO END DO END DO END IF END IF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedScalar3D SUBROUTINE MPIExchangeAsync_MappedVector3D ( vector , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , vector % nElem DO s1 = 1 , 6 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) msgCount = msgCount + 1 CALL MPI_IRECV ( vector % extBoundary % hostData (:,:,:,:, s1 , e1 ), & 3 * ( vector % N + 1 ) * ( vector % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( vector % boundary % hostData (:,:,:,:, s1 , e1 ), & 3 * ( vector % N + 1 ) * ( vector % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedVector3D SUBROUTINE ApplyFlip_MappedVector3D ( vector , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 , j , j2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId REAL ( prec ) :: extBuff ( 1 : 3 , 0 : vector % N , 0 : vector % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedVector3D_gpu_wrapper ( vector % extBoundary % deviceData , & mesh % self_sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & vector % N , & vector % nVar , & vector % nElem ) ELSE DO e1 = 1 , vector % nElem DO s1 = 1 , 6 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) IF ( flip == 2 ) THEN DO ivar = 1 , vector % nvar DO j = 0 , vector % N DO i = 0 , vector % N i2 = vector % N - j j2 = i extBuff ( 1 : 3 , i , j ) = vector % extBoundary % hostData ( 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , vector % N DO i = 0 , vector % N vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , i , j ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , vector % nvar DO j = 0 , vector % N DO i = 0 , vector % N i2 = vector % N - i j2 = vector % N - j extBuff ( 1 : 3 , i , j ) = vector % extBoundary % hostData ( 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , vector % N DO i = 0 , vector % N vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , i , j ) END DO END DO END DO ELSEIF ( flip == 4 ) THEN DO ivar = 1 , vector % nvar DO j = 0 , vector % N DO i = 0 , vector % N i2 = j j2 = vector % N - i extBuff ( 1 : 3 , i , j ) = vector % extBoundary % hostData ( 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , vector % N DO i = 0 , vector % N vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , i , j ) END DO END DO END DO END IF END IF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedVector3D SUBROUTINE MPIExchangeAsync_MappedTensor3D ( tensor , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedTensor3D ), INTENT ( inout ) :: tensor TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , tensor % nElem DO s1 = 1 , 6 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) msgCount = msgCount + 1 CALL MPI_IRECV ( tensor % extBoundary % hostData (:,:,:,:,:, s1 , e1 ), & 9 * ( tensor % N + 1 ) * ( tensor % N + 1 ) * tensor % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( tensor % boundary % hostData (:,:,:,:,:, s1 , e1 ), & 9 * ( tensor % N + 1 ) * ( tensor % N + 1 ) * tensor % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedTensor3D SUBROUTINE ApplyFlip_MappedTensor3D ( tensor , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedTensor3D ), INTENT ( inout ) :: tensor TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 , j , j2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId REAL ( prec ) :: extBuff ( 1 : 3 , 1 : 3 , 0 : tensor % N , 0 : tensor % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedTensor3D_gpu_wrapper ( tensor % extBoundary % deviceData , & mesh % self_sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & tensor % N , & tensor % nVar , & tensor % nElem ) ELSE DO e1 = 1 , tensor % nElem DO s1 = 1 , 6 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) IF ( flip == 2 ) THEN DO ivar = 1 , tensor % nvar DO j = 0 , tensor % N DO i = 0 , tensor % N i2 = tensor % N - j j2 = i extBuff ( 1 : 3 , 1 : 3 , i , j ) = tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , 1 : 3 , i , j ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , tensor % nvar DO j = 0 , tensor % N DO i = 0 , tensor % N i2 = tensor % N - i j2 = tensor % N - j extBuff ( 1 : 3 , 1 : 3 , i , j ) = tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , 1 : 3 , i , j ) END DO END DO END DO ELSEIF ( flip == 4 ) THEN DO ivar = 1 , tensor % nvar DO j = 0 , tensor % N DO i = 0 , tensor % N i2 = j j2 = tensor % N - i extBuff ( 1 : 3 , 1 : 3 , i , j ) = tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , 1 : 3 , i , j ) END DO END DO END DO END IF END IF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedTensor3D END MODULE SELF_MappedData","tags":"","loc":"sourcefile/self_mappeddata.f90.html"},{"title":"SELF_Advection2D.f90 – SELF","text":"This file depends on sourcefile~~self_advection2d.f90~~EfferentGraph sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_advection2d.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_advection2d.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_advection2d.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_hdf5.f90 SELF_HDF5.f90 sourcefile~self_mesh.f90->sourcefile~self_hdf5.f90 sourcefile~self_hashtable.f90 SELF_HashTable.f90 sourcefile~self_mesh.f90->sourcefile~self_hashtable.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mpi.f90 SELF_MPI.f90 sourcefile~self_mesh.f90->sourcefile~self_mpi.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_hdf5.f90 sourcefile~self_metadata.f90 SELF_Metadata.f90 sourcefile~self_dg.f90->sourcefile~self_metadata.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~self_dg.f90->sourcefile~self_mpi.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_hdf5.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_hdf5.f90->sourcefile~self_memory.f90 sourcefile~self_metadata.f90->sourcefile~self_hdf5.f90 sourcefile~self_hashtable.f90->sourcefile~self_constants.f90 sourcefile~self_linkedlist.f90 SELF_LinkedList.f90 sourcefile~self_hashtable.f90->sourcefile~self_linkedlist.f90 sourcefile~self_mappeddata.f90->sourcefile~self_constants.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mpi.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_mpi.f90->sourcefile~self_constants.f90 sourcefile~self_mpi.f90->sourcefile~self_memory.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_advection2d.f90~~AfferentGraph sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Advection2D Source Code SELF_Advection2D.f90 Source Code MODULE SELF_Advection2D USE SELF_Constants USE SELF_SupportRoutines USE SELF_Mesh USE SELF_DG USE FEQParse USE FLAP ! Needed for Fortran-C interoperability ! Helps expose HIP kernels to Fortran USE ISO_C_BINDING TYPE , EXTENDS ( DG2D ), PUBLIC :: Advection2D TYPE ( MappedVector2D ), PUBLIC :: velocity TYPE ( Vector2D ), PUBLIC :: plotVelocity TYPE ( Vector2D ), PUBLIC :: plotX TYPE ( EquationParser ), ALLOCATABLE :: boundaryConditionEqn (:) TYPE ( EquationParser ), ALLOCATABLE :: solutionEqn (:) TYPE ( EquationParser ), ALLOCATABLE :: sourceEqn (:) REAL ( prec ) :: simulationTime ! Model Settings ! REAL ( prec ) :: Lx , Ly ! Domain lengths REAL ( prec ) :: dt ! Default time step size REAL ( prec ) :: outputInterval REAL ( prec ) :: initialTime REAL ( prec ) :: endTime REAL ( prec ) :: diffusivity LOGICAL :: diffusiveFlux INTEGER :: controlDegree INTEGER :: targetDegree INTEGER :: controlQuadrature ! ENUMS in SELF_Constants.f90 INTEGER :: targetQuadrature ! ENUMS in SELF_Constants.f90 CHARACTER ( LEN = self_FileNameLength ) :: icFile CHARACTER ( LEN = self_FileNameLength ) :: meshFile INTEGER :: nxElements INTEGER :: nyElements INTEGER :: integrator ! ENUMS needed in SELF_Constants.f90 !! TO DO !! CHARACTER ( LEN = self_EquationLength ) :: velEqnX ! Velocity Equation (x-direction) CHARACTER ( LEN = self_EquationLength ) :: velEqnY ! Velocity Equation (y-direction) CHARACTER ( LEN = self_EquationLength ) :: icEqn ! Initial condition Equation CHARACTER ( LEN = self_EquationLength ) :: bcEqn ! Boundary condition Equation LOGICAL :: enableMPI LOGICAL :: gpuAccel CONTAINS PROCEDURE , PUBLIC :: Init => Init_Advection2D PROCEDURE , PUBLIC :: InitFromCLI => InitFromCLI_Advection2D PROCEDURE , PUBLIC :: Free => Free_Advection2D GENERIC , PUBLIC :: SetSolution => SetSolutionFromEquation_Advection2D PROCEDURE , PRIVATE :: SetSolutionFromEquation_Advection2D GENERIC , PUBLIC :: SetSource => SetSourceFromEquation_Advection2D PROCEDURE , PRIVATE :: SetSourceFromEquation_Advection2D GENERIC , PUBLIC :: SetVelocity => SetVelocityFromEquation_Advection2D PROCEDURE , PRIVATE :: SetVelocityFromEquation_Advection2D GENERIC , PUBLIC :: SetBoundaryCondition => SetBoundaryConditionFromEquation_Advection2D PROCEDURE , PRIVATE :: SetBoundaryConditionFromEquation_Advection2D PROCEDURE , PUBLIC :: WriteTecplot => WriteTecplot_Advection2D PROCEDURE , PUBLIC :: ForwardStep => ForwardStep_Advection2D PROCEDURE , PUBLIC :: TimeStepRK3 => TimeStepRK3_Advection2D PROCEDURE , PUBLIC :: Tendency => Tendency_Advection2D PROCEDURE , PUBLIC :: InternalFlux => InternalFlux_Advection2D PROCEDURE , PUBLIC :: SideFlux => SideFlux_Advection2D END TYPE Advection2D PRIVATE :: GetCLIParameters ! Interfaces to GPU kernels ! INTERFACE SUBROUTINE InternalFlux_Advection2D_gpu_wrapper ( flux , solution , velocity , dsdx , N , nVar , nEl ) & BIND ( c , name = \"InternalFlux_Advection2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: flux , solution , velocity , dsdx INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE InternalFlux_Advection2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE InternalDiffusiveFlux_Advection2D_gpu_wrapper ( flux , solutionGradient , dsdx , diffusivity , N , nVar , nEl ) & BIND ( c , name = \"InternalDiffusiveFlux_Advection2D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( c_ptr ) :: flux , solutionGradient , dsdx REAL ( c_prec ), VALUE :: diffusivity INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE InternalDiffusiveFlux_Advection2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE SideFlux_Advection2D_gpu_wrapper ( flux , boundarySol , extSol , velocity , nHat , nScale , N , nVar , nEl ) & BIND ( c , name = \"SideFlux_Advection2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: flux , boundarySol , extSol , velocity , nHat , nScale INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE SideFlux_Advection2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE SideDiffusiveFlux_Advection2D_gpu_wrapper ( flux , boundarySolGradient , extSolGradient , & nHat , nScale , diffusivity , N , nVar , nEl ) & BIND ( c , name = \"SideDiffusiveFlux_Advection2D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( c_ptr ) :: flux , boundarySolGradient , extSolGradient , nHat , nScale REAL ( c_prec ), VALUE :: diffusivity INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE SideDiffusiveFlux_Advection2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE UpdateGRK3_Advection2D_gpu_wrapper ( gRK3 , solution , dSdt , rk3A , rk3G , dt , N , nVar , nEl ) & BIND ( c , name = \"UpdateGRK3_Advection2D_gpu_wrapper\" ) USE ISO_C_BINDING USE SELF_Constants IMPLICIT NONE TYPE ( c_ptr ) :: gRK3 , solution , dSdt REAL ( c_prec ), VALUE :: rk3A , rk3G , dt INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE UpdateGRK3_Advection2D_gpu_wrapper END INTERFACE CONTAINS SUBROUTINE Init_Advection2D ( this , cqType , tqType , cqDegree , tqDegree , nvar , enableMPI , spec ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nvar LOGICAL , INTENT ( in ) :: enableMPI TYPE ( MeshSpec ), INTENT ( in ) :: spec CALL this % decomp % Init ( enableMPI ) ! Load Mesh IF ( enableMPI ) THEN CALL this % mesh % Load ( spec , this % decomp ) ELSE CALL this % mesh % Load ( spec ) ENDIF CALL this % decomp % SetMaxMsg ( this % mesh % nUniqueSides ) CALL this % decomp % setElemToRank ( this % mesh % nElem ) ! Create geometry from mesh CALL this % geometry % GenerateFromMesh (& this % mesh , cqType , tqType , cqDegree , tqDegree ) CALL this % plotSolution % Init (& tqDegree , tqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % dSdt % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % solution % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % solutionGradient % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % flux % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % velocity % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % plotVelocity % Init (& tqDegree , tqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % plotX % Init (& tqDegree , tqType , tqDegree , tqType , 1 ,& this % mesh % nElem ) CALL this % source % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % fluxDivergence % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % workScalar % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % workVector % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % workTensor % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % compFlux % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) ALLOCATE ( this % solutionMetaData ( 1 : nvar )) ALLOCATE ( this % boundaryConditionEqn ( 1 : nvar )) ALLOCATE ( this % solutionEqn ( 1 : nvar )) ALLOCATE ( this % sourceEqn ( 1 : nvar )) END SUBROUTINE Init_Advection2D SUBROUTINE InitFromCLI_Advection2D ( this ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this ! Local TYPE ( COMMAND_LINE_INTERFACE ) :: cli TYPE ( MeshSpec ) :: spec CHARACTER ( self_QuadratureTypeCharLength ) :: cqTypeChar CHARACTER ( self_QuadratureTypeCharLength ) :: tqTypeChar CHARACTER ( self_IntegratorTypeCharLength ) :: integratorChar REAL ( prec ) :: Lx , Ly ! Domain lengths REAL ( prec ) :: dt ! Default time step size REAL ( prec ) :: diffusivity INTEGER :: controlDegree INTEGER :: targetDegree INTEGER :: controlQuadrature ! ENUMS in SELF_Constants.f90 INTEGER :: targetQuadrature ! ENUMS in SELF_Constants.f90 CHARACTER ( LEN = self_FileNameLength ) :: meshFile INTEGER :: nxElements INTEGER :: nyElements INTEGER :: integrator ! ENUMS needed in SELF_Constants.f90 !! TO DO !! CHARACTER ( LEN = self_EquationLength ) :: velEqnX ! Velocity Equation (x-direction) CHARACTER ( LEN = self_EquationLength ) :: velEqnY ! Velocity Equation (y-direction) CHARACTER ( LEN = self_EquationLength ) :: icEqn ! Initial condition Equation CHARACTER ( LEN = self_EquationLength ) :: bcEqn ! Boundary condition Equation CHARACTER ( LEN = self_EquationLength ) :: sourceEqn ! Boundary condition Equation LOGICAL :: enableMPI LOGICAL :: enableGPU LOGICAL :: diffusiveFlux REAL ( prec ) :: outputInterval REAL ( prec ) :: initialTime REAL ( prec ) :: endTime TYPE ( EquationParser ) :: eqn ( 1 ) TYPE ( EquationParser ) :: velEqn ( 1 : 2 ) ! Get the CLI parameters ! CALL GetCLIParameters ( cli ) ! Set the CLI parameters ! CALL cli % get ( val = enableMPI , switch = '--mpi' ) CALL cli % get ( val = enableGPU , switch = '--gpu' ) CALL cli % get ( val = meshfile , switch = '--mesh' ) CALL cli % get ( val = dt , switch = \"--time-step\" ) CALL cli % get ( val = outputInterval , switch = \"--output-interval\" ) CALL cli % get ( val = initialTime , switch = \"--initial-time\" ) CALL cli % get ( val = endTime , switch = \"--end-time\" ) CALL cli % get ( val = controlDegree , switch = \"--control-degree\" ) CALL cli % get ( val = targetDegree , switch = \"--target-degree\" ) CALL cli % get ( val = cqTypeChar , switch = \"--control-quadrature\" ) CALL cli % get ( val = tqTypeChar , switch = \"--target-quadrature\" ) CALL cli % get ( val = meshFile , switch = \"--mesh\" ) CALL cli % get ( val = nxElements , switch = \"--nxelements\" ) CALL cli % get ( val = nyElements , switch = \"--nyelements\" ) CALL cli % get ( val = Lx , switch = \"--xlength\" ) CALL cli % get ( val = Ly , switch = \"--ylength\" ) CALL cli % get ( val = velEqnX , switch = \"--velocity-x\" ) CALL cli % get ( val = velEqnY , switch = \"--velocity-y\" ) CALL cli % get ( val = icEqn , switch = \"--initial-condition\" ) CALL cli % get ( val = bcEqn , switch = \"--boundary-condition\" ) CALL cli % get ( val = sourceEqn , switch = \"--source\" ) CALL cli % get ( val = integratorChar , switch = \"--integrator\" ) CALL cli % get ( val = diffusivity , switch = \"--diffusivity\" ) diffusiveFlux = . TRUE . IF ( diffusivity == 0.0_prec ) THEN diffusiveFlux = . FALSE . ELSEIF ( diffusivity < 0.0_prec ) THEN IF ( dt > 0.0_prec ) THEN PRINT * , 'Negative diffusivity provably unstable for forward stepping' PRINT * , 'Invalid diffusivity value. Stopping' STOP ENDIF ENDIF IF ( TRIM ( UpperCase ( cqTypeChar )) == 'GAUSS' ) THEN controlQuadrature = GAUSS ELSEIF ( TRIM ( UpperCase ( cqTypeChar )) == 'GAUSS-LOBATTO' ) THEN controlQuadrature = GAUSS_LOBATTO ELSEIF ( TRIM ( UpperCase ( cqTypeChar )) == 'CHEBYSHEV-GAUSS' ) THEN controlQuadrature = CHEBYSHEV_GAUSS ELSEIF ( TRIM ( UpperCase ( cqTypeChar )) == 'CHEBYSHEV-GAUSS-LOBATTO' ) THEN controlQuadrature = CHEBYSHEV_GAUSS_LOBATTO ELSE PRINT * , 'Invalid Control Quadrature' STOP - 1 END IF IF ( TRIM ( UpperCase ( tqTypeChar )) == 'UNIFORM' ) THEN targetQuadrature = UNIFORM ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'GAUSS' ) THEN targetQuadrature = GAUSS ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'GAUSS-LOBATTO' ) THEN targetQuadrature = GAUSS_LOBATTO ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'CHEBYSHEV-GAUSS' ) THEN targetQuadrature = CHEBYSHEV_GAUSS ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'CHEBYSHEV-GAUSS-LOBATTO' ) THEN targetQuadrature = CHEBYSHEV_GAUSS_LOBATTO ELSE PRINT * , 'Invalid Target Quadrature' STOP - 1 END IF IF ( TRIM ( UpperCase ( integratorChar )) == 'EULER' ) THEN integrator = EULER ELSEIF ( TRIM ( UpperCase ( integratorChar )) == 'WILLIAMSON_RK3' ) THEN integrator = RK3 ELSE PRINT * , 'Invalid time integrator' STOP - 1 END IF IF ( TRIM ( meshfile ) == \"\" ) THEN spec % blockMesh = . TRUE . ELSE spec % blockMesh = . FALSE . ENDIF spec % filename = meshfile spec % filetype = SELF_MESH_ISM_V2_2D spec % blockMesh_nGeo = 1 spec % blockMesh_x0 = 0.0_prec spec % blockMesh_x1 = Lx spec % blockMesh_y0 = 0.0_prec spec % blockMesh_y1 = Ly spec % blockMesh_z0 = 0.0_prec spec % blockMesh_z1 = 0.0_prec spec % blockMesh_nElemX = nxElements spec % blockMesh_nElemY = nyElements spec % blockMesh_nElemZ = 0 ! 2-D mesh ! CALL this % Init ( controlQuadrature , & targetQuadrature , & controlDegree , & targetDegree , & 1 , enableMPI , & spec ) this % simulationTime = 0.0_prec this % Lx = Lx this % Ly = Ly ! Domain lengths this % dt = dt ! Default time step size this % initialTime = initialTime this % simulationTime = initialTime this % endTime = endTime this % outputInterval = outputInterval this % controlDegree = controlDegree this % targetDegree = targetDegree this % controlQuadrature = controlQuadrature ! ENUMS in SELF_Constants.f90 this % targetQuadrature = targetQuadrature ! ENUMS in SELF_Constants.f90 this % meshFile = meshFile this % nxElements = nxElements this % nyElements = nyElements this % integrator = integrator ! ENUMS needed in SELF_Constants.f90 !! TO DO !! this % velEqnX = velEqnX ! Velocity Equation (x-direction) this % velEqnY = velEqnY ! Velocity Equation (y-direction) this % icEqn = icEqn ! Initial condition Equation this % bcEqn = bcEqn ! Boundary condition Equation this % enableMPI = enableMPI this % gpuAccel = enableGPU this % diffusivity = diffusivity this % diffusiveFlux = diffusiveFlux eqn ( 1 ) = EquationParser ( icEqn , ( / 'x' , 'y' , 't' / )) CALL this % SetSolution ( eqn ) this % solutionEqn ( 1 ) = EquationParser ( icEqn , ( / 'x' , 'y' , 't' / )) velEqn ( 1 ) = EquationParser ( velEqnX , ( / 'x' , 'y' / )) velEqn ( 2 ) = EquationParser ( velEqnY , ( / 'x' , 'y' / )) CALL this % SetVelocity ( velEqn ) this % boundaryConditionEqn ( 1 ) = EquationParser ( bcEqn , ( / 'x' , 'y' , 't' / )) CALL this % SetBoundaryCondition ( this % boundaryConditionEqn ) this % sourceEqn ( 1 ) = EquationParser ( sourceEqn , ( / 'x' , 'y' , 't' / )) END SUBROUTINE InitFromCLI_Advection2D SUBROUTINE GetCLIParameters ( cli ) TYPE ( COMMAND_LINE_INTERFACE ), INTENT ( inout ) :: cli CALL cli % init ( progname = \"sadv2d\" , & version = \"v0.0.0\" , & description = \"SELF Advection in 2-D\" , & license = \"ANTI-CAPITALIST SOFTWARE LICENSE (v 1.4)\" , & authors = \"Joseph Schoonover (Fluid Numerics LLC)\" ) CALL cli % add ( switch = \"--mpi\" , & help = \"Enable MPI\" , & act = \"store_true\" , & def = \"false\" , & required = . FALSE .) CALL cli % add ( switch = \"--gpu\" , & help = \"Enable GPU acceleration\" , & act = \"store_true\" , & def = \"false\" , & required = . FALSE .) CALL cli % add ( switch = \"--time-step\" , & switch_ab = \"-dt\" , & help = \"The time step size for the time integrator\" , & def = \"0.001\" , & required = . FALSE .) CALL cli % add ( switch = \"--initial-time\" , & switch_ab = \"-t0\" , & help = \"The initial time level\" , & def = \"0.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--output-interval\" , & switch_ab = \"-oi\" , & help = \"The time between file output\" , & def = \"0.5\" , & required = . FALSE .) CALL cli % add ( switch = \"--end-time\" , & switch_ab = \"-tn\" , & help = \"The final time level\" , & def = \"1.0\" , & required = . FALSE .) ! Get the control degree CALL cli % add ( switch = \"--control-degree\" , & switch_ab = \"-c\" , & help = \"The polynomial degree of the control points.\" // NEW_LINE ( \"A\" ), & def = \"7\" , & required = . FALSE .) ! Get the target degree (assumed for plotting) CALL cli % add ( switch = \"--target-degree\" , & switch_ab = \"-t\" , & help = \"The polynomial degree for the\" // & & \" target points for interpolation.\" // & & \" Typically used for plotting\" // NEW_LINE ( \"A\" ), & def = \"14\" , & required = . FALSE .) ! Get the control quadrature ! Everyone know Legendre-Gauss Quadrature is the best... CALL cli % add ( switch = \"--control-quadrature\" , & switch_ab = \"-cq\" , & def = \"gauss\" , & help = \"The quadrature type for control points.\" // NEW_LINE ( \"A\" ), & choices = \"gauss,gauss-lobatto,chebyshev-gauss,chebyshev-gauss-lobatto\" , & required = . FALSE .) ! Set the target grid quadrature ! Default to uniform (assumed for plotting) CALL cli % add ( switch = \"--target-quadrature\" , & switch_ab = \"-tq\" , & def = \"uniform\" , & help = \"The quadrature type for target points.\" // NEW_LINE ( \"A\" ), & choices = \"gauss,gauss-lobatto,uniform\" , & required = . FALSE .) ! (Optional) Provide a file for a mesh ! Assumed in HOPR or ISM-v2 format CALL cli % add ( switch = \"--mesh\" , & switch_ab = \"-m\" , & help = \"Path to a mesh file for control mesh.\" // NEW_LINE ( \"A\" ), & def = \"\" , & required = . FALSE .) ! (Optional) If a mesh is not provided, you ! can request a structured grid to be generated ! just set the nxelement, nyelements.. CALL cli % add ( switch = \"--nxelements\" , & switch_ab = \"-nx\" , & help = \"The number of elements in the x-direction for structured mesh generation.\" , & def = \"5\" , & required = . FALSE .) CALL cli % add ( switch = \"--nyelements\" , & switch_ab = \"-ny\" , & help = \"The number of elements in the y-direction for structured mesh generation.\" , & def = \"5\" , & required = . FALSE .) ! Alright... now tell me some physical mesh dimensions CALL cli % add ( switch = \"--xlength\" , & switch_ab = \"-lx\" , & help = \"The physical x-scale for structured mesh generation.\" // & \" Ignored if a mesh file is provided\" , & def = \"1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--ylength\" , & switch_ab = \"-ly\" , & help = \"The physical y-scale for structured mesh generation.\" // & \" Ignored if a mesh file is provided\" , & def = \"1.0\" , & required = . FALSE .) ! Set the velocity field CALL cli % add ( switch = \"--velocity-x\" , & switch_ab = \"-vx\" , & help = \"Equation for the x-component of the velocity field (x,y dependent only!)\" ,& def = \"vx=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--velocity-y\" , & switch_ab = \"-vy\" , & help = \"Equation for the y-component of the velocity field (x,y dependent only!)\" ,& def = \"vy=1.0\" , & required = . FALSE .) ! Tracer diffusivity CALL cli % add ( switch = \"--diffusivity\" , & switch_ab = \"-nu\" , & help = \"Tracer diffusivity (applied to all tracers)\" , & def = \"0.0\" , & required = . FALSE .) ! Set the initial conditions ! .. TO DO .. !  > How to handle multiple tracer fields ?? CALL cli % add ( switch = \"--initial-condition\" , & switch_ab = \"-ic\" , & help = \"Equation for the initial tracer distributions\" ,& def = \"f = exp( -( ((x-t)-0.5)&#94;2 + ((y-t)-0.5)&#94;2)/0.01 )\" , & required = . FALSE .) CALL cli % add ( switch = \"--boundary-condition\" , & switch_ab = \"-bc\" , & help = \"Equation for the boundary tracer distributions (can be time dependent!)\" , & def = \"f = exp( -( ((x-t)-0.5)&#94;2 + ((y-t)-0.5)&#94;2)/0.01 )\" , & required = . FALSE .) CALL cli % add ( switch = \"--source\" , & switch_ab = \"-s\" , & help = \"Equation for the source term (can be time dependent!)\" , & def = \"s = 0.0\" , & required = . FALSE .) ! Give me a time integrator CALL cli % add ( switch = \"--integrator\" , & switch_ab = \"-int\" , & help = \"Sets the time integration method. Only 'euler' or 'williamson_rk3'\" , & def = \"williamson_rk3\" , & required = . FALSE .) END SUBROUTINE GetCLIParameters SUBROUTINE Free_Advection2D ( this ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this CALL this % mesh % Free () CALL this % geometry % Free () CALL this % solution % Free () CALL this % dSdt % Free () CALL this % plotSolution % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () CALL this % workScalar % Free () CALL this % workVector % Free () CALL this % workTensor % Free () CALL this % compFlux % Free () CALL this % velocity % Free () CALL this % plotVelocity % Free () CALL this % plotX % Free () DEALLOCATE ( this % solutionMetaData ) DEALLOCATE ( this % boundaryConditionEqn ) DEALLOCATE ( this % solutionEqn ) DEALLOCATE ( this % sourceEqn ) END SUBROUTINE Free_Advection2D SUBROUTINE SetSolutionFromEquation_Advection2D ( this , eqn ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: i , j , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: t DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Get the mesh positions x = this % geometry % x % interior % hostData ( 1 , i , j , 1 , iEl ) y = this % geometry % x % interior % hostData ( 2 , i , j , 1 , iEl ) t = this % simulationTime this % solution % interior % hostData ( i , j , iVar , iEl ) = & eqn ( iVar ) % Evaluate (( / x , y , t / )) ENDDO ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN CALL this % solution % interior % UpdateDevice () ENDIF END SUBROUTINE SetSolutionFromEquation_Advection2D SUBROUTINE SetSourceFromEquation_Advection2D ( this , eqn ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: i , j , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: t DO iEl = 1 , this % source % nElem DO iVar = 1 , this % source % nVar DO j = 0 , this % source % N DO i = 0 , this % source % N ! Get the mesh positions x = this % geometry % x % interior % hostData ( 1 , i , j , 1 , iEl ) y = this % geometry % x % interior % hostData ( 2 , i , j , 1 , iEl ) t = this % simulationTime this % source % interior % hostData ( i , j , iVar , iEl ) = & eqn ( iVar ) % Evaluate (( / x , y , t / )) ENDDO ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN CALL this % source % interior % UpdateDevice () ENDIF END SUBROUTINE SetSourceFromEquation_Advection2D SUBROUTINE SetVelocityFromEquation_Advection2D ( this , eqn ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : 2 ) ! Local INTEGER :: i , j , iEl , iVar , iSide REAL ( prec ) :: x REAL ( prec ) :: y DO iEl = 1 , this % solution % nElem ! Set the velocity at the element interiors DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Get the mesh positions x = this % geometry % x % interior % hostData ( 1 , i , j , 1 , iEl ) y = this % geometry % x % interior % hostData ( 2 , i , j , 1 , iEl ) ! Set the velocity in the x-direction this % velocity % interior % hostData ( 1 , i , j , 1 , iEl ) = & eqn ( 1 ) % Evaluate (( / x , y / )) ! Set the velocity in the y-direction this % velocity % interior % hostData ( 2 , i , j , 1 , iEl ) = & eqn ( 2 ) % Evaluate (( / x , y / )) ENDDO ENDDO ! Set the velocity at element edges DO iSide = 1 , 4 DO i = 0 , this % solution % N ! Get the mesh positions x = this % geometry % x % boundary % hostData ( 1 , i , 1 , iSide , iEl ) y = this % geometry % x % boundary % hostData ( 2 , i , 1 , iSide , iEl ) ! Set the velocity in the x-direction this % velocity % boundary % hostData ( 1 , i , 1 , iSide , iEl ) = & eqn ( 1 ) % Evaluate (( / x , y / )) ! Set the velocity in the y-direction this % velocity % boundary % hostData ( 2 , i , 1 , iSide , iEl ) = & eqn ( 2 ) % Evaluate (( / x , y / )) ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN CALL this % velocity % interior % UpdateDevice () CALL this % velocity % boundary % UpdateDevice () ENDIF END SUBROUTINE SetVelocityFromEquation_Advection2D SUBROUTINE SetBoundaryConditionFromEquation_Advection2D ( this , eqn ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: i , iEl , iVar , iSide REAL ( prec ) :: x REAL ( prec ) :: y DO iEl = 1 , this % solution % nElem DO iSide = 1 , 4 DO iVar = 1 , this % solution % nvar DO i = 0 , this % solution % N ! If this element's side has no neighbor assigned ! it is assumed to be a physical boundary. ! In this case, we want to assign the external boundary ! condition. IF ( this % mesh % self_sideInfo % hostData ( 3 , iSide , iEl ) == 0 ) THEN ! Get the mesh positions x = this % geometry % x % boundary % hostData ( 1 , i , 1 , iSide , iEl ) y = this % geometry % x % boundary % hostData ( 2 , i , 1 , iSide , iEl ) ! Set the external boundary condition this % solution % extBoundary % hostData ( i , iVar , iSide , iEl ) = & eqn ( iVar ) % Evaluate (( / x , y , this % simulationTime / )) ENDIF ENDDO ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN ! Copy data to the GPU CALL this % solution % extBoundary % UpdateDevice () ENDIF END SUBROUTINE SetBoundaryConditionFromEquation_Advection2D SUBROUTINE ForwardStep_Advection2D ( this , endTime ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: endTime ! Local INTEGER :: nSteps REAL ( prec ) :: dt IF ( this % integrator == RK3 ) THEN ! Step forward dt = this % dt nSteps = INT (( endTime - this % simulationTime ) / dt ) CALL this % TimeStepRK3 ( nSteps ) ! Take any additional steps to reach desired endTime this % dt = endTime - this % simulationTime IF ( this % dt > 0 ) THEN nSteps = 1 CALL this % TimeStepRK3 ( nSteps ) ENDIF ! Reset the time step this % dt = dt ENDIF END SUBROUTINE ForwardStep_Advection2D SUBROUTINE TimeStepRK3_Advection2D ( this , nSteps ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: nSteps ! Local INTEGER :: m , iStep INTEGER :: iEl INTEGER :: iVar INTEGER :: i , j TYPE ( hfReal_r4 ) :: gRK3 REAL ( prec ) :: t0 REAL ( prec ) :: dt REAL ( prec ) :: rk3A REAL ( prec ) :: rk3G CALL gRK3 % Alloc ( loBound = ( / 0 , 0 , 1 , 1 / ), & upBound = ( / this % solution % N ,& this % solution % N ,& this % solution % nVar , & this % solution % nElem / )) dt = this % dt DO iStep = 1 , nSteps t0 = this % simulationTime gRK3 % hostData = 0.0_prec DO m = 1 , 3 ! Loop over RK3 steps CALL this % Tendency ( ) IF ( this % gpuAccel ) THEN rk3A = rk3_a ( m ) rk3G = rk3_g ( m ) CALL UpdateGRK3_Advection2D_gpu_wrapper ( gRK3 % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk3A , rk3G , dt , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % N DO i = 0 , this % solution % N gRK3 % hostData ( i , j , iVar , iEl ) = rk3_a ( m ) * gRK3 % hostData ( i , j , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & rk3_g ( m ) * dt * gRK3 % hostData ( i , j , iVar , iEl ) ENDDO ENDDO ENDDO ENDDO ENDIF this % simulationTime = this % simulationTime + rk3_b ( m ) * dt ENDDO this % simulationTime = t0 + dt ENDDO CALL gRK3 % Free () END SUBROUTINE TimeStepRK3_Advection2D SUBROUTINE Tendency_Advection2D ( this ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this CALL this % solution % BoundaryInterp ( this % gpuAccel ) IF ( this % diffusiveFlux ) THEN CALL this % CalculateSolutionGradient ( this % gpuAccel ) ENDIF ! Internal Flux calculates both the advective and diffusive flux -- need diffusivity CALL this % InternalFlux ( ) ! Exchange side information between neighboring cells CALL this % solution % SideExchange ( this % mesh , & this % decomp , & this % gpuAccel ) IF ( this % diffusiveFlux ) THEN CALL this % solutionGradient % SideExchange ( this % mesh , & this % decomp , & this % gpuAccel ) ENDIF CALL this % SideFlux ( ) CALL this % CalculateFluxDivergence ( this % gpuAccel ) CALL this % CalculatedSdt ( this % gpuAccel ) END SUBROUTINE Tendency_Advection2D SUBROUTINE SideFlux_Advection2D ( this ) !! Calculates the Advective Flux on element sides using a Lax-Friedrich's upwind Riemann Solver IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this ! Local INTEGER :: i , iSide , iVar , iEl REAL ( prec ) :: nhat ( 1 : 2 ) REAL ( prec ) :: nmag REAL ( prec ) :: un REAL ( prec ) :: extState REAL ( prec ) :: intState IF ( this % gpuAccel ) THEN CALL SideFlux_Advection2D_gpu_wrapper ( this % flux % boundaryNormal % deviceData , & this % solution % boundary % deviceData , & this % solution % extBoundary % deviceData , & this % velocity % boundary % deviceData , & this % geometry % nHat % boundary % deviceData , & this % geometry % nScale % boundary % deviceData , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) IF ( this % diffusiveFlux ) THEN CALL SideDiffusiveFlux_Advection2D_gpu_wrapper ( this % flux % boundaryNormal % deviceData , & this % solutionGradient % boundary % deviceData , & this % solutionGradient % extBoundary % deviceData , & this % geometry % nHat % boundary % deviceData , & this % geometry % nScale % boundary % deviceData , & this % diffusivity , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ENDIF ELSE DO iEl = 1 , this % solution % nElem DO iSide = 1 , 4 DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % N ! Get the boundary normals on cell edges from the mesh geometry nhat ( 1 : 2 ) = this % geometry % nHat % boundary % hostData ( 1 : 2 , i , 1 , iSide , iEl ) ! Calculate the normal velocity at the cell edges un = this % velocity % boundary % hostData ( 1 , i , 1 , iSide , iEl ) * nHat ( 1 ) + & this % velocity % boundary % hostData ( 2 , i , 1 , iSide , iEl ) * nHat ( 2 ) ! Pull external and internal state for the Riemann Solver (Lax-Friedrichs) extState = this % solution % extBoundary % hostData ( i , iVar , iSide , iEl ) intState = this % solution % boundary % hostData ( i , iVar , iSide , iEl ) nmag = this % geometry % nScale % boundary % hostData ( i , 1 , iSide , iEl ) ! Calculate the flux this % flux % boundaryNormal % hostData ( i , iVar , iSide , iEl ) = 0.5_prec * & ( un * ( intState + extState ) - abs ( un ) * ( extState - intState ) ) * nmag ENDDO ENDDO ENDDO ENDDO IF ( this % diffusiveFlux ) THEN DO iEl = 1 , this % solution % nElem DO iSide = 1 , 4 DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % N nhat ( 1 : 2 ) = this % geometry % nHat % boundary % hostData ( 1 : 2 , i , 1 , iSide , iEl ) nmag = this % geometry % nScale % boundary % hostData ( i , 1 , iSide , iEl ) !  Calculate \\nabla{f} \\cdot \\hat{n} on the cell sides extState = this % solutionGradient % extBoundary % hostData ( 1 , i , iVar , iSide , iEl ) * nHat ( 1 ) + & this % solutionGradient % extBoundary % hostData ( 2 , i , iVar , iSide , iEl ) * nHat ( 2 ) intState = this % solutionGradient % boundary % hostData ( 1 , i , iVar , iSide , iEl ) * nHat ( 1 ) + & this % solutionGradient % boundary % hostData ( 2 , i , iVar , iSide , iEl ) * nHat ( 2 ) ! Bassi-Rebay flux is the average of the internal and external diffusive flux vectors. this % flux % boundaryNormal % hostData ( i , iVar , iSide , iEl ) = & this % flux % boundaryNormal % hostData ( i , iVar , iSide , iEl ) - & 0.5_prec * this % diffusivity * ( extState + intState ) * nmag ENDDO ENDDO ENDDO ENDDO ENDIF ! Diffusivity ENDIF ! GPU Acceleration END SUBROUTINE SideFlux_Advection2D SUBROUTINE InternalFlux_Advection2D ( this ) !! Calculates the advective flux using the provided velocity IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this ! Local INTEGER :: i , j , iVar , iEl REAL ( prec ) :: Fx , Fy IF ( this % gpuAccel ) THEN ! When GPU acceleration is enabled (requested by the user) ! we call the gpu wrapper interface, which will call the ! HIP kernel \"under the hood\" ! ! TO DO : Pass the contravariant basis vector to GPU kernel CALL InternalFlux_Advection2D_gpu_wrapper ( this % flux % interior % deviceData ,& this % solution % interior % deviceData , & this % velocity % interior % deviceData , & this % geometry % dsdx % interior % deviceData , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) IF ( this % diffusiveFlux ) THEN CALL InternalDiffusiveFlux_Advection2D_gpu_wrapper ( this % flux % interior % deviceData ,& this % solutionGradient % interior % deviceData , & this % geometry % dsdx % interior % deviceData , & this % diffusivity , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ENDIF ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % N DO i = 0 , this % solution % N Fx = this % velocity % interior % hostData ( 1 , i , j , 1 , iEl ) * & this % solution % interior % hostData ( i , j , iVar , iEl ) Fy = this % velocity % interior % hostData ( 2 , i , j , 1 , iEl ) * & this % solution % interior % hostData ( i , j , iVar , iEl ) this % flux % interior % hostData ( 1 , i , j , iVar , iEl ) = & this % geometry % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iel ) * Fy this % flux % interior % hostData ( 2 , i , j , iVar , iEl ) = & this % geometry % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iel ) * Fy ENDDO ENDDO ENDDO ENDDO ! When diffusivity == 0, then we don't bother calculating the diffusive flux IF ( this % diffusiveFlux ) THEN ! Otherwise, we add the diffusive flux to to the flux vector DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Diffusive flux is diffusivity coefficient mulitplied by ! solution gradient Fx = this % solutionGradient % interior % hostData ( 1 , i , j , iVar , iEl ) * & this % diffusivity Fy = this % solutionGradient % interior % hostData ( 2 , i , j , iVar , iEl ) * & this % diffusivity ! Project the diffusive flux vector onto computational coordinates this % flux % interior % hostData ( 1 , i , j , iVar , iEl ) = & this % flux % interior % hostData ( 1 , i , j , iVar , iEl ) - & this % geometry % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iel ) * Fx - & this % geometry % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iel ) * Fy this % flux % interior % hostData ( 2 , i , j , iVar , iEl ) = & this % flux % interior % hostData ( 2 , i , j , iVar , iEl ) - & this % geometry % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iel ) * Fx - & this % geometry % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iel ) * Fy ENDDO ENDDO ENDDO ENDDO ENDIF ! DiffusiveFlux ENDIF ! GPU Acceleration END SUBROUTINE InternalFlux_Advection2D SUBROUTINE WriteTecplot_Advection2D ( self , filename ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: self CHARACTER ( * ), INTENT ( in ), OPTIONAL :: filename ! Local CHARACTER ( 8 ) :: zoneID INTEGER :: fUnit INTEGER :: iEl , i , j CHARACTER ( LEN = self_FileNameLength ) :: tecFile CHARACTER ( 13 ) :: timeStampString IF ( PRESENT ( filename ) ) THEN tecFile = filename ELSE timeStampString = TimeStamp ( self % simulationTime , 's' ) tecFile = 'solution.' // timeStampString // '.tec' ENDIF IF ( self % gpuAccel ) THEN ! Copy data to the CPU CALL self % solution % interior % UpdateHost () ENDIF ! Map the mesh positions to the target grid CALL self % geometry % x % GridInterp ( self % plotX , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL self % solution % GridInterp ( self % plotSolution , gpuAccel = . FALSE .) ! Map the velocity to the target grid CALL self % velocity % GridInterp ( self % plotVelocity , gpuAccel = . FALSE .) ! Let's write some tecplot!! OPEN ( UNIT = NEWUNIT ( fUnit ), & FILE = TRIM ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) ! TO DO :: Adjust for multiple tracer fields WRITE ( fUnit , * ) 'VARIABLES = \"X\", \"Y\", \"tracer\",\"u\",\"v\"' DO iEl = 1 , self % solution % nElem ! TO DO :: Get the global element ID WRITE ( zoneID , '(I8.8)' ) iEl WRITE ( fUnit , * ) 'ZONE T=\"el' // trim ( zoneID ) // '\", I=' , self % solution % M + 1 ,& ', J=' , self % solution % M + 1 , ',F=POINT' DO j = 0 , self % solution % M DO i = 0 , self % solution % M WRITE ( fUnit , '(5(E15.7,1x))' ) self % plotX % interior % hostData ( 1 , i , j , 1 , iEl ), & self % plotX % interior % hostData ( 2 , i , j , 1 , iEl ), & self % plotSolution % interior % hostData ( i , j , 1 , iEl ),& self % plotVelocity % interior % hostData ( 1 , i , j , 1 , iEl ),& self % plotVelocity % interior % hostData ( 2 , i , j , 1 , iEl ) ENDDO ENDDO ENDDO CLOSE ( UNIT = fUnit ) END SUBROUTINE WriteTecplot_Advection2D END MODULE SELF_Advection2D","tags":"","loc":"sourcefile/self_advection2d.f90.html"},{"title":"SELF_LinkedList.f90 – SELF","text":"Files dependent on this one sourcefile~~self_linkedlist.f90~~AfferentGraph sourcefile~self_linkedlist.f90 SELF_LinkedList.f90 sourcefile~self_hashtable.f90 SELF_HashTable.f90 sourcefile~self_hashtable.f90->sourcefile~self_linkedlist.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_mesh.f90->sourcefile~self_hashtable.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~self_advection2d.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~self_advection3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_mesh.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_LinkedList Source Code SELF_LinkedList.f90 Source Code ! SELF_LinkedList.f90 ! ! Copyright 2017-2021 Fluid Numerics LLC ! All rights reserved. ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! !> \\file SELF_LinkedList.f90 !! Contains the \\ref SELF_LinkedList module, and <BR> !! defines the \\ref Record and \\ref LinkedList data-structures. !> \\defgroup SELF_LinkedList SELF_LinkedList !! This module defines the Record and \\ref LinkedList data-structure and associated routines. MODULE SELF_LinkedList !  A linked-list data-structure with routines for construction, destruction, accession, and !  modification are provided. This provides a template for a linked list of other data-structures. !  Here, the data is taken as an integer and we also provide an integer key which can be useful !  for accessing linked-list data for other data-structures. IMPLICIT NONE !> \\addtogroup SELF_LinkedList !! @{ !> \\struct Record !! A template record entry for a Linked-List that consists of data, a key, and a pointer to the next !! record !! !! This data structure is used in the LinkedList data structure. The data in this template is an !! integer, though this template can be used to develop of Linked List of other data (e.g. see !! Timing.f90, Node_Class.f90, QuadElement_Class.f90, HexElement_Class.f90, Edge_Class.f90) !! !! <H2> Record </H2> !! <H3> Attributes </H3> !!    <table> !!       <tr> <th> listData <td> INTEGER  <td> Data for a single entry in a LinkedList !!       <tr> <th>  key <td> INTEGER  <td> A key that can be used for conditional access, as in the !!                                         HashTable_Class !!       <tr> <th> next <td> Record  <td> Pointer to the next record in a LinkedList !!    </table> !! !> @} TYPE Record INTEGER :: listData INTEGER :: key TYPE ( Record ), POINTER :: next END TYPE Record !> \\addtogroup SELF_LinkedList !! @{ !> \\struct LinkedList !! A LinkedList of Records !! !! !! <H2> LinkedList </H2> !! <H3> Attributes </H3> !!    <table> !!       <tr> <th> head <td> Record  <td> A pointer to the first entry (the head) of the LinkedList !!       <tr> <th> tail <td> Record  <td> A pointer to the last entry (the tail) of the LinkedList !!       <tr> <th> current <td> Record  <td> A pointer to the current entry of the LinkedList. This !!                                           pointer can be used to traverse the list. !!    </table> !! !! <H3> Procedures </H3> !!    See \\ref SELF_LinkedList for more information. The first column lists the \"call-name\" and the second !!    column lists the name of routine that is aliased onto the call-name. This is the list of !!    PUBLIC type-bound procedures for the LinkedList data-structure. !! !!    <table> !!       <tr> <th> Init <td> Init_LinkedList !!       <tr> <th> Free <td> Free_LinkedList !!       <tr> <th> GetData <td> GetData_LinkedList !!       <tr> <th> SetData <td> SetData_LinkedList !!       <tr> <th> GetKey <td> GetKey_LinkedList !!       <tr> <th> SetKey <td> SetKey_LinkedList !!       <tr> <th> ListIsEmpty <td> ListIsEmpty_LinkedList !!       <tr> <th> AddToList <td> AddToList_LinkedList !!       <tr> <th> RemoveCurrent <td> RemoveCurrent_LinkedList !!       <tr> <th> MoveToNext <td> MoveToNext_LinkedList !!       <tr> <th> MoveToHead <td> MoveToHead_LinkedList !!       <tr> <th> MovetoTail <td> MoveToTail_LinkedList !!       <tr> <th> PrintToScreen <td> PrintToScreen_LinkedList !!    </table> !> @} TYPE LinkedList TYPE ( Record ), POINTER :: head , tail , current CONTAINS PROCEDURE :: Init => Init_LinkedList PROCEDURE :: Free => Free_LinkedList PROCEDURE :: GetData => GetCurrentData_LinkedList PROCEDURE :: SetData => SetCurrentData_LinkedList PROCEDURE :: GetKey => GetCurrentKey_LinkedList PROCEDURE :: SetKey => SetCurrentKey_LinkedList PROCEDURE :: ListIsEmpty => ListIsEmpty_LinkedList PROCEDURE :: AddToList => AddToList_LinkedList PROCEDURE :: RemoveCurrent => RemoveCurrent_LinkedList PROCEDURE :: MoveToNext => MoveToNext_LinkedList PROCEDURE :: MoveToHead => MoveToHead_LinkedList PROCEDURE :: MoveToTail => MoveToTail_LinkedList PROCEDURE :: PrintToScreen => PrintToScreen_LinkedList END TYPE LinkedList ! Setting up some parameters pertaining to this module INTEGER , PARAMETER , PRIVATE :: keyInc = 1 ! The default increment in the Record Key INTEGER , PARAMETER , PRIVATE :: keyStart = 1 ! The default starting Record key CONTAINS ! !==================================================================================================! !---------------------------- CONSTRUCTOR/DESTRUCTOR ROUTINES -------------------------------------! !==================================================================================================! ! !> \\addtogroup SELF_LinkedList !! @{ ! ================================================================================================ ! ! S/R Init ! !> \\fn Init_LinkedList !! Initializes a LinkedList by nullifying the head, tail, and current pointers !! !! <H2> Usage : </H2> !! <B>TYPE</B>(LinkedList) :: this <BR> !!         .... <BR> !!     <B>CALL</B> this % Init(  ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myList <td> LinkedList <td> !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE Init_LinkedList ( myList ) IMPLICIT NONE CLASS ( LinkedList ) :: myList myList % head => NULL () myList % tail => NULL () myList % current => NULL () END SUBROUTINE Init_LinkedList ! !> \\addtogroup SELF_LinkedList !! @{ ! ================================================================================================ ! ! S/R Free ! !> \\fn Free_LinkedList !!  Cycles through the Linked List, deallocates associated memory, and nullifies the LinkedList !!  pointers. !! !! <H2> Usage : </H2> !! <B>TYPE</B>(LinkedList) :: this <BR> !!         .... <BR> !!     <B>CALL</B> this % Free( Inputs/Outputs ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myList <td> LinkedList <td> !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE Free_LinkedList ( myList ) IMPLICIT NONE CLASS ( LinkedList ) :: myList ! LOCAL TYPE ( Record ), POINTER :: pNext ! Set the current position of the list to the head myList % current => myList % head ! Scroll through the list until the current position is nullified DO WHILE ( ASSOCIATED ( myList % current )) pNext => myList % current % next DEALLOCATE ( myList % current ) myList % current => pNext END DO END SUBROUTINE Free_LinkedList ! !==================================================================================================! !---------------------------------------- ACCESSORS -----------------------------------------------! !==================================================================================================! ! !> \\addtogroup SELF_LinkedList !! @{ ! ================================================================================================ ! ! S/R GetCurrentData ! !> \\fn GetCurrentData_LinkedList !! Gets the current list data and returns the integer value. !! !! <H2> Usage : </H2> !! <B>TYPE</B>(LinkedList) :: this <BR> !! <B>INTEGER</B>          :: outData <BR> !!         .... <BR> !!     <B>CALL</B> this % GetCurrentData( outData ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> myList <td> LinkedList <td> !!   <tr> <td> out <th> outData <td> INTEGER <td> !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE GetCurrentData_LinkedList ( myList , outData ) IMPLICIT NONE CLASS ( LinkedList ) :: myList INTEGER :: outData outData = myList % current % listData END SUBROUTINE GetCurrentData_LinkedList ! !> \\addtogroup SELF_LinkedList !! @{ ! ================================================================================================ ! ! S/R GetCurrentKey ! !> \\fn GetCurrentKey_LinkedList !! Gets the current key and returns the integer value. !! !! <H2> Usage : </H2> !! <B>TYPE</B>(LinkedList) :: this <BR> !! <B>INTEGER</B>          :: outKey <BR> !!         .... <BR> !!     <B>CALL</B> this % GetCurrentKey( outKey ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> myList <td> LinkedList <td> !!   <tr> <td> out <th> outKey <td> INTEGER <td> !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE GetCurrentKey_LinkedList ( myList , outKey ) IMPLICIT NONE CLASS ( LinkedList ) :: myList INTEGER :: outKey outKey = myList % current % key END SUBROUTINE GetCurrentKey_LinkedList ! !> \\addtogroup SELF_LinkedList !! @{ ! ================================================================================================ ! ! S/R SetCurrentData ! !> \\fn SetCurrentData_LinkedList !! Sets the current list data to the supplied integer value. !! !! <H2> Usage : </H2> !! <B>TYPE</B>(LinkedList) :: this <BR> !! <B>INTEGER</B>          :: inData <BR> !!         .... <BR> !!     <B>CALL</B> this % SetCurrentData( inData ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myList <td> LinkedList <td> !!   <tr> <td> in <th> inData <td> INTEGER <td> !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE SetCurrentData_LinkedList ( myList , inData ) IMPLICIT NONE CLASS ( LinkedList ) :: myList INTEGER :: inData myList % current % listData = inData END SUBROUTINE SetCurrentData_LinkedList ! !> \\addtogroup SELF_LinkedList !! @{ ! ================================================================================================ ! ! S/R SetCurrentKey ! !> \\fn SetCurrentKey_LinkedList !! Sets the current list key to the supplied integer value. !! !! <H2> Usage : </H2> !! <B>TYPE</B>(LinkedList) :: this <BR> !! <B>INTEGER</B>          :: inKey <BR> !!         .... <BR> !!     <B>CALL</B> this % SetCurrentKey( inKey ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myList <td> LinkedList <td> !!   <tr> <td> in <th> inKey <td> INTEGER <td> !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE SetCurrentKey_LinkedList ( myList , inKey ) IMPLICIT NONE CLASS ( LinkedList ) :: myList INTEGER :: inKey myList % current % key = inKey END SUBROUTINE SetCurrentKey_LinkedList ! ! !==================================================================================================! !-------------------------------- Linked-List Type Operations -------------------------------------! !==================================================================================================! ! ! !> \\addtogroup SELF_LinkedList !! @{ ! ================================================================================================ ! ! S/R ListIsEmpty ! !> \\fn ListIsEmpty_LinkedList !! Checks if the LinkedList is empty and returns a logical indicating the status of the list. !! !! <H2> Usage : </H2> !! <B>TYPE</B>(LinkedList) :: this <BR> !! <B>LOGICAL</B>          :: listStatus <BR> !!         .... <BR> !!     listStatus =  this % ListIsEmpty( ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> myList <td> LinkedList <td> !!   <tr> <td> out <th> isempty<td> LOGICAL <td> !!                      If the list is empty, isempty=.TRUE., <BR> !!                      If the list has entries, isempty=.FALSE., <BR> !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION ListIsEmpty_LinkedList ( myList ) RESULT ( isempty ) IMPLICIT NONE CLASS ( LinkedList ) :: myList LOGICAL :: isempty isempty = . NOT . ( ASSOCIATED ( myList % head )) END FUNCTION ListIsEmpty_LinkedList ! !> \\addtogroup SELF_LinkedList !! @{ ! ================================================================================================ ! ! S/R AddToList ! !> \\fn AddToList_LinkedList !! Adds a new entry to the LinkedList with the provided data and key !! !! !! <H2> Usage : </H2> !! <B>TYPE</B>(LinkedList) :: this <BR> !! <B>INTEGER</B>          :: inData, inKey <BR> !!         .... <BR> !!     <B>CALL</B> this % AddToList( inData, inKey ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myList <td> LinkedList <td> !!   <tr> <td> in <th> inData <td> INTEGER <td> Data to assign to the new entry in the list !!   <tr> <td> in <th> inKey <td> INTEGER <td>  Key to assign to the new entry in the list !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE AddToList_LinkedList ( myList , inData , inKey ) IMPLICIT NONE CLASS ( LinkedList ) :: myList INTEGER :: inData INTEGER , OPTIONAL :: inKey ! LOCAL TYPE ( Record ), POINTER :: previous INTEGER :: allocationStatus ! Check to see if this list is empty IF ( myList % ListIsEmpty ()) THEN ALLOCATE ( myList % head , STAT = allocationStatus ) IF ( allocationStatus /= 0 ) THEN PRINT * , 'MODULE LinkedListClass.f90 : S/R AddToList : Memory not allocated for next entry in list.' ! An exception handler should be built to handle these problems END IF ! Point the current position to the head myList % current => myList % head ! Set the data CALL myList % SetData ( inData ) IF ( PRESENT ( inKey )) THEN CALL myList % SetKey ( inKey ) ELSE CALL myList % SetKey ( keyStart ) END IF ! Point the next to null and the tail to current myList % current % next => NULL () myList % tail => myList % current ELSE ! the list is not empty ! Then we allocate space for the next item in the list ALLOCATE ( myList % tail % next , STAT = allocationStatus ) IF ( allocationStatus /= 0 ) THEN PRINT * , 'MODULE LinkedListClass.f90 : S/R AddToList : Memory not allocated for next entry in list.' ! An exception handler should be built to handle these problems END IF !  Temporarily hold onto the tail in case we need the key (if inKey is not present) previous => myList % tail ! Reassign the tail myList % tail => myList % tail % next ! Set the current to the tail myList % current => myList % tail ! Fill in the data CALL myList % SetData ( inData ) ! Fill in the key information IF ( PRESENT ( inKey )) THEN CALL myList % SetKey ( inKey ) ELSE CALL myList % SetKey ( previous % key + keyInc ) END IF ! Point the next to null and the tail to current myList % current % next => NULL () END IF END SUBROUTINE AddToList_LinkedList ! !> \\addtogroup SELF_LinkedList !! @{ ! ================================================================================================ ! ! S/R RemoveCurrent ! !> \\fn RemoveCurrent_LinkedList !! Removes the current entry from the list and patches the previous with the next. !! !! <H2> Usage : </H2> !! <B>TYPE</B>(LinkedList) :: this <BR> !!         .... <BR> !!     <B>CALL</B> this % RemoveCurrent( ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myList <td> LinkedList <td> !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE RemoveCurrent_LinkedList ( myList ) IMPLICIT NONE CLASS ( LinkedList ) :: myList ! LOCAL TYPE ( Record ), POINTER :: previous , pNext INTEGER :: currentKey , thisKey CALL myList % GetKey ( currentKey ) ! Check to see if this list is empty IF ( myList % ListIsEmpty ()) THEN PRINT * , 'Module LinkedListClass.f90 : S/R RemoveCurrent : List is empty. Nothing to remove' RETURN ELSE ! the list is not empty CALL myList % MoveToHead () ! Rewind the list ! Get the key for this list item CALL myList % GetKey ( thisKey ) ! Check if we are trying to remove the head of the list IF ( thisKey == currentKey ) THEN ! temporarily point to the next in the list pNext => myList % current % next ! Deallocate memory pointed to by current position DEALLOCATE ( myList % current ) ! Update current position myList % head => pNext ! Reset the head of the list RETURN END IF ! If the execution of the code has arrived here, then we are not removing the head of the ! list. ! Hang on to the head as the previous previous => myList % current CALL myList % MoveToNext () DO WHILE ( ASSOCIATED ( myList % current )) ! Get the key for this list item CALL myList % GetKey ( thisKey ) ! Check if we are trying to remove the head of the list IF ( thisKey == currentKey ) THEN ! temporarily point to the next in the list pNext => myList % current % next ! Patch the previous item to the next item previous % next => pNext IF (. NOT . ASSOCIATED ( pNext )) THEN myList % tail => previous END IF ! Deallocate memory pointed to by current position DEALLOCATE ( myList % current ) EXIT ELSE previous => myList % current CALL myList % moveToNext () END IF END DO END IF END SUBROUTINE RemoveCurrent_LinkedList ! !> \\addtogroup SELF_LinkedList !! @{ ! ================================================================================================ ! ! S/R MoveToNext ! !> \\fn MoveToNext_LinkedList !! Advances the current pointer in the LinkedList to the next position !! !! <H2> Usage : </H2> !! <B>TYPE</B>(LinkedList) :: this <BR> !!         .... <BR> !!     <B>CALL</B> this % MoveToNext( ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myList <td> LinkedList <td> !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE MoveToNext_LinkedList ( myList ) IMPLICIT NONE CLASS ( LinkedList ) :: myList myList % current => myList % current % next END SUBROUTINE MoveToNext_LinkedList ! ! !> \\addtogroup SELF_LinkedList !! @{ ! ================================================================================================ ! ! S/R MoveToHead ! !> \\fn MoveToHead_LinkedList !! Advances the current pointer in the LinkedList to the start of the list  (list head) !! !! <H2> Usage : </H2> !! <B>TYPE</B>(LinkedList) :: this <BR> !!         .... <BR> !!     <B>CALL</B> this % MoveToHead( ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myList <td> LinkedList <td> !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE MoveToHead_LinkedList ( myList ) IMPLICIT NONE CLASS ( LinkedList ) :: myList myList % current => myList % head END SUBROUTINE MoveToHead_LinkedList ! !> \\addtogroup SELF_LinkedList !! @{ ! ================================================================================================ ! ! S/R MoveToTail ! !> \\fn MoveToTail_LinkedList !! Advances the current pointer in the LinkedList to the end of the list (list tail) !! !! <H2> Usage : </H2> !! <B>TYPE</B>(LinkedList) :: this <BR> !!         .... <BR> !!     <B>CALL</B> this % MoveToTail( ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myList <td> LinkedList <td> !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE MoveToTail_LinkedList ( myList ) IMPLICIT NONE CLASS ( LinkedList ) :: myList myList % current => myList % tail END SUBROUTINE MoveToTail_LinkedList ! !> \\addtogroup SELF_LinkedList !! @{ ! ================================================================================================ ! ! S/R GetCount ! !> \\fn GetCount_LinkedList !! Counts the number of associated entries in the list !! !! <H2> Usage : </H2> !! <B>TYPE</B>(LinkedList) :: this <BR> !! <B>INTEGER</B>          :: nItems <BR> !!         .... <BR> !!     <B>CALL</B> this % GetCount( nItems ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> myList <td> LinkedList <td> !!   <tr> <td> out <th> nItems <td> INTEGER <td> The number of entries in the list !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE GetCount_LinkedList ( myList , numberOfListItems ) IMPLICIT NONE CLASS ( LinkedList ) :: myList INTEGER , INTENT ( out ) :: numberOfListItems numberOfListItems = 0 ! Initialize the number of list items ! Check to see if this list is empty IF ( myList % ListIsEmpty ()) THEN PRINT * , 'Module LinkedListClass.f90 : S/R ListCount : List is empty.' RETURN ELSE ! the list is not empty CALL myList % MoveToHead () ! Rewind the list DO WHILE ( ASSOCIATED ( myList % current )) numberOfListItems = numberOfListItems + 1 CALL myList % moveToNext () END DO END IF END SUBROUTINE GetCount_LinkedList ! !> \\addtogroup SELF_LinkedList !! @{ ! ================================================================================================ ! ! S/R PrintToScreen ! !> \\fn PrintToScreen_LinkedList !! Prints the list data and keys to the screen !! !! <H2> Usage : </H2> !! <B>TYPE</B>(LinkedList) :: this <BR> !!         .... <BR> !!     <B>CALL</B> this % PrintToScreen(  ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> myList <td> LinkedList <td> !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE PrintToScreen_LinkedList ( myList ) IMPLICIT NONE CLASS ( LinkedList ) :: myList myList % current => myList % head PRINT * , '          Data        Key' DO WHILE ( ASSOCIATED ( myList % current )) PRINT * , myList % current % listData , myList % current % key CALL myList % MoveToNext () END DO END SUBROUTINE PrintToScreen_LinkedList ! END MODULE SELF_LinkedList","tags":"","loc":"sourcefile/self_linkedlist.f90.html"},{"title":"SELF_HashTable.f90 – SELF","text":"This file depends on sourcefile~~self_hashtable.f90~~EfferentGraph sourcefile~self_hashtable.f90 SELF_HashTable.f90 sourcefile~self_linkedlist.f90 SELF_LinkedList.f90 sourcefile~self_hashtable.f90->sourcefile~self_linkedlist.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_hashtable.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_hashtable.f90~~AfferentGraph sourcefile~self_hashtable.f90 SELF_HashTable.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_mesh.f90->sourcefile~self_hashtable.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~self_advection2d.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~self_advection3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_mesh.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_HashTable Source Code SELF_HashTable.f90 Source Code ! SELF_HashTable.f90 ! ! Copyright 2021 Fluid Numerics LLC ! All rights reserved. ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! !> \\file SELF_HashTable.f90 !! Contains the \\ref SELF_HashTable module, and <BR> !! defines the \\ref HashTable data-structures. !> \\defgroup SELF_HashTable SELF_HashTable !! This module defines the \\ref HashTable data-structure and associated routines. MODULE SELF_HashTable USE SELF_Constants USE SELF_LinkedList IMPLICIT NONE !> \\addtogroup SELF_HashTable !! @{ !> \\struct HashTable !! A template hash-table data structure that is comprised of an array of linked lists ( see !! SELF_LinkedList ). !! !! <H2> HashTable </H2> !! <H3> Attributes </H3> !!    <table> !!       <tr> <th> list(:) <td> LinkedList  <td> Single Linked-List !!    </table> !! !> @} TYPE HashTable TYPE ( LinkedList ), ALLOCATABLE :: list (:) CONTAINS PROCEDURE :: Init => Init_HashTable PROCEDURE :: Free => Free_HashTable PROCEDURE :: AddDataForKeys => AddDataForKeys_HashTable PROCEDURE :: ContainsKeys => ContainsKeys_HashTable PROCEDURE :: GetDataForKeys => GetDataForKeys_HashTable END TYPE HashTable CONTAINS ! ! !==================================================================================================! !------------------------------- Manual Constructors/Destructors ----------------------------------! !==================================================================================================! ! ! !> \\addtogroup SELF_HashTable !! @{ ! ================================================================================================ ! ! S/R Init ! !> \\fn Init_HashTable !! Allocates space for the hash table and initializes each linked list within the hash-table !! !! <H2> Usage : </H2> !! <B>TYPE</B>(HashTable) :: this <BR> !! <B>INTEGER</B>         :: N <BR> !!         .... <BR> !!     <B>CALL</B> this % Init( N ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> out <th> myTable <td> HashTable <td> Initialized hash-table !!   <tr> <td> in  <th> N <td> INTEGER <td> The number of linked-lists in the hash table !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE Init_HashTable ( myTable , N ) IMPLICIT NONE CLASS ( HashTable ) :: myTable INTEGER :: N ! LOCAL INTEGER :: i ALLOCATE ( myTable % list ( 1 : N )) DO i = 1 , N CALL myTable % list ( i ) % Init () END DO END SUBROUTINE Init_HashTable ! !> \\addtogroup SELF_HashTable !! @{ ! ================================================================================================ ! ! S/R Free ! !> \\fn Free_HashTable !!  Deallocates memory associated with the Hash-Table !! !! <H2> Usage : </H2> !! <B>TYPE</B>(HashTable) :: this <BR> !!         .... <BR> !!     <B>CALL</B> this % Free( ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myTable <td> HashTable <td> On input, initialized hash-table <br> !!                                                     On output, memory associated with hash-table !!                                                     has been deallocated. !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE Free_HashTable ( myTable ) IMPLICIT NONE CLASS ( HashTable ) :: myTable ! LOCAL INTEGER :: i , N N = SIZE ( myTable % list ) DO i = 1 , N CALL myTable % list ( i ) % Free () END DO DEALLOCATE ( myTable % list ) END SUBROUTINE Free_HashTable ! ! !==================================================================================================! !--------------------------------- Type Specific Routines  ----------------------------------------! !==================================================================================================! ! ! !> \\addtogroup SELF_HashTable !! @{ ! ================================================================================================ ! ! S/R AddDataForKeys ! !> \\fn AddDataForKeys_HashTable !! Adds data to the i-th linked list with a key set to \"j\" !! !! To access data in a hash-table, two keys need to be given. The first key points to the linked-list !! in the hash table. The second key gives access to a particular record in the linked-list. !! !! <H2> Usage : </H2> !! <B>TYPE</B>(HashTable) :: this <BR> !! <B>INTEGER</B>         :: data, i, j <BR> !!         .... <BR> !!     <B>CALL</B> this % AddDataForKeys( inData, i, j ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myTable <td> HashTable <td> Initialized hash-table !!   <tr> <td> in <th> inData <td> INTEGER <td> Data for the j-th record of the i-th linked-list in !!                                              the hash-table. !!   <tr> <td> in <th> i <td> INTEGER <td> Key that points to a particular linked-list in the hash-table !!   <tr> <td> in <th> j <td> INTEGER <td> Key for a particular record in the i-th linked-list. !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE AddDataForKeys_HashTable ( myTable , inData , i , j ) IMPLICIT NONE CLASS ( HashTable ) :: myTable INTEGER :: inData , i , j CALL myTable % list ( i ) % AddToList ( inData , j ) END SUBROUTINE AddDataForKeys_HashTable ! !> \\addtogroup SELF_HashTable !! @{ ! ================================================================================================ ! ! S/R ContainsKeys ! !> \\fn ContainsKeys_HashTable !! Checks to see if an entry in the hash-table exists for the keys \"i\" and \"j\". !! !! This function checks the i-th linked-list for a record with a key set to \"j\". If the keys exist, !! the function returns a logical set to \"TRUE\". Otherwise, the function returns \"FALSE\". !! !! <H2> Usage : </H2> !! <B>TYPE</B>(HashTable) :: this <BR> !! <B>INTEGER</B>         :: i,j <BR> !! <B>LOGICAL</B>         :: keysExist <BR> !!         .... <BR> !!     keysExist = this % ContainsKeys( i, j ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> myTable <td> HashTable <td> Initialized hash-table !!   <tr> <td> in <th> i <td> INTEGER <td> Key that points to a particular linked-list in the hash-table !!   <tr> <td> in <th> j <td> INTEGER <td> Key for a particular record in the i-th linked-list. !!   <tr> <td> out <th> doesContain <td> LOGICAL <td> Logical indicating if the keys exist in the hash-table !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION ContainsKeys_HashTable ( myTable , i , j ) RESULT ( doesContain ) IMPLICIT NONE CLASS ( HashTable ) :: myTable INTEGER :: i , j LOGICAL :: doesContain ! LOCAL INTEGER :: thisKey doesContain = . FALSE . IF ( myTable % list ( i ) % ListIsEmpty ()) THEN ! this list hasn't been started RETURN END IF ! Rewind the list myTable % list ( i ) % current => myTable % list ( i ) % head DO WHILE ( ASSOCIATED ( myTable % list ( i ) % current )) CALL myTable % list ( i ) % GetKey ( thisKey ) IF ( thisKey == j ) THEN ! This list already has this key doesContain = . TRUE . RETURN END IF ! other wise we move to the next element in the list CALL myTable % list ( i ) % MoveToNext () END DO END FUNCTION ContainsKeys_HashTable ! !> \\addtogroup SELF_HashTable !! @{ ! ================================================================================================ ! ! S/R GetDataForKeys ! !> \\fn GetDataForKeys_HashTable !! Returns data from the hash table associated with the keys \"i\" and \"j\". !! !! <H2> Usage : </H2> !! <B>TYPE</B>(HashTable) :: this <BR> !! <B>INTEGER</B>         :: i, j, data <BR> !!         .... <BR> !!     <B>CALL<B> this % GetDataForKeys( data, i, j ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> myTable <td> HashTable <td> Initialized hash-table !!   <tr> <td> in <th> i <td> INTEGER <td> Key that points to a particular linked-list in the hash-table !!   <tr> <td> in <th> j <td> INTEGER <td> Key for a particular record in the i-th linked-list. !!   <tr> <td> out <th> outData <td> INTEGER <td> Data associated with keys \"i\" and \"j\" !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE GetDataForKeys_HashTable ( myTable , outData , i , j ) IMPLICIT NONE CLASS ( HashTable ) :: myTable INTEGER :: outData , i , j ! LOCAL INTEGER :: thisData , thisKey IF ( myTable % list ( i ) % ListIsEmpty ()) THEN ! this table entry is not pointing to a linked list PRINT * , 'MODULE HASHTABLE_CLASS : S/R GetDataForKeys :' PRINT * , 'List ' , i , ' is empty.' outData = fillValueInt RETURN END IF myTable % list ( i ) % current => myTable % list ( i ) % head DO WHILE ( ASSOCIATED ( myTable % list ( i ) % current )) ! this table entry does not contain the keys i,j CALL myTable % list ( i ) % GetData ( thisData ) CALL myTable % list ( i ) % GetKey ( thisKey ) IF ( thisKey == j ) THEN outData = thisData RETURN END IF CALL myTable % list ( i ) % MoveToNext () END DO END SUBROUTINE GetDataForKeys_HashTable END MODULE SELF_HashTable","tags":"","loc":"sourcefile/self_hashtable.f90.html"},{"title":"SELF_DG.f90 – SELF","text":"This file depends on sourcefile~~self_dg.f90~~EfferentGraph sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_hdf5.f90 SELF_HDF5.f90 sourcefile~self_dg.f90->sourcefile~self_hdf5.f90 sourcefile~self_metadata.f90 SELF_Metadata.f90 sourcefile~self_dg.f90->sourcefile~self_metadata.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_mpi.f90 SELF_MPI.f90 sourcefile~self_dg.f90->sourcefile~self_mpi.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_hdf5.f90->sourcefile~self_memory.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_hdf5.f90->sourcefile~self_constants.f90 sourcefile~self_metadata.f90->sourcefile~self_hdf5.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mpi.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_hdf5.f90 sourcefile~self_mesh.f90->sourcefile~self_mpi.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_hashtable.f90 SELF_HashTable.f90 sourcefile~self_mesh.f90->sourcefile~self_hashtable.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mpi.f90->sourcefile~self_memory.f90 sourcefile~self_mpi.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 sourcefile~self_hashtable.f90->sourcefile~self_constants.f90 sourcefile~self_linkedlist.f90 SELF_LinkedList.f90 sourcefile~self_hashtable.f90->sourcefile~self_linkedlist.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_dg.f90~~AfferentGraph sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_DG Source Code SELF_DG.f90 Source Code ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_DG USE SELF_Metadata USE SELF_MPI USE SELF_Mesh USE SELF_MappedData USE SELF_HDF5 USE HDF5 TYPE , PUBLIC :: DG2D TYPE ( MappedScalar2D ), PUBLIC :: solution TYPE ( Scalar2D ), PUBLIC :: plotSolution TYPE ( MappedVector2D ), PUBLIC :: solutionGradient TYPE ( MappedVector2D ), PUBLIC :: flux TYPE ( MappedScalar2D ), PUBLIC :: source TYPE ( MappedScalar2D ), PUBLIC :: fluxDivergence TYPE ( MappedScalar2D ), PUBLIC :: dSdt TYPE ( MPILayer ), PUBLIC :: decomp TYPE ( Mesh2D ), PUBLIC :: mesh TYPE ( SEMQuad ), PUBLIC :: geometry TYPE ( Metadata ), ALLOCATABLE , PUBLIC :: solutionMetaData (:) ! Work arrays ! Can't be private to be accessible by type extensions ! TO DO : Really need to figure out the reuse business for the initializer... TYPE ( MappedScalar2D ) :: workScalar TYPE ( MappedVector2D ) :: workVector TYPE ( MappedVector2D ) :: compFlux TYPE ( MappedTensor2D ) :: workTensor CONTAINS PROCEDURE , PUBLIC :: Init => Init_DG2D PROCEDURE , PUBLIC :: Free => Free_DG2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_DG2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_DG2D PROCEDURE , PUBLIC :: CalculateSolutionGradient => CalculateSolutionGradient_DG2D PROCEDURE , PUBLIC :: CalculateFluxDivergence => CalculateFluxDivergence_DG2D PROCEDURE , PUBLIC :: CalculateDSDt => CalculateDSDt_DG2D PROCEDURE , PUBLIC :: Read => Read_DG2D PROCEDURE , PUBLIC :: Write => Write_DG2D END TYPE DG2D TYPE , PUBLIC :: DG3D TYPE ( MappedScalar3D ), PUBLIC :: solution TYPE ( Scalar3D ), PUBLIC :: plotSolution TYPE ( MappedVector3D ), PUBLIC :: solutionGradient TYPE ( MappedVector3D ), PUBLIC :: flux TYPE ( MappedScalar3D ), PUBLIC :: source TYPE ( MappedScalar3D ), PUBLIC :: fluxDivergence TYPE ( MappedScalar3D ), PUBLIC :: dSdt TYPE ( MPILayer ), PUBLIC :: decomp TYPE ( Mesh3D ), PUBLIC :: mesh TYPE ( SEMHex ), PUBLIC :: geometry TYPE ( Metadata ), ALLOCATABLE , PUBLIC :: solutionMetaData (:) ! Work arrays TYPE ( MappedScalar3D ) :: workScalar TYPE ( MappedVector3D ) :: workVector TYPE ( MappedVector3D ) :: compFlux TYPE ( MappedTensor3D ) :: workTensor CONTAINS PROCEDURE , PUBLIC :: Init => Init_DG3D PROCEDURE , PUBLIC :: Free => Free_DG3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_DG3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_DG3D PROCEDURE , PUBLIC :: CalculateSolutionGradient => CalculateSolutionGradient_DG3D PROCEDURE , PUBLIC :: CalculateFluxDivergence => CalculateFluxDivergence_DG3D PROCEDURE , PUBLIC :: CalculateDSDt => CalculateDSDt_DG3D PROCEDURE , PUBLIC :: Read => Read_DG3D PROCEDURE , PUBLIC :: Write => Write_DG3D END TYPE DG3D INTEGER , PARAMETER :: SELF_DG_BASSIREBAY = 100 INTERFACE SUBROUTINE CalculateDSDt_DG2D_gpu_wrapper ( fluxDivergence , source , dSdt , N , nVar , nEl ) & bind ( c , name = \"CalculateDSDt_DG2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: fluxDivergence , source , dSdt INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE CalculateDSDt_DG2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE CalculateDSDt_DG3D_gpu_wrapper ( fluxDivergence , source , dSdt , N , nVar , nEl ) & bind ( c , name = \"CalculateDSDt_DG3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: fluxDivergence , source , dSdt INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE CalculateDSDt_DG3D_gpu_wrapper END INTERFACE CONTAINS SUBROUTINE Init_DG2D ( this , cqType , tqType , cqDegree , tqDegree , nvar , enableMPI , spec ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nvar LOGICAL , INTENT ( in ) :: enableMPI TYPE ( MeshSpec ), INTENT ( in ) :: spec CALL this % decomp % Init ( enableMPI ) ! Load Mesh CALL this % mesh % Load ( spec , this % decomp ) CALL this % decomp % SetMaxMsg ( this % mesh % nUniqueSides ) CALL this % decomp % setElemToRank ( this % mesh % nElem ) ! Create geometry from mesh CALL this % geometry % GenerateFromMesh ( this % mesh , cqType , tqType , cqDegree , tqDegree ) CALL this % solution % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % plotSolution % Init ( tqDegree , tqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % dSdt % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % solutionGradient % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % flux % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % source % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % fluxDivergence % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % workScalar % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % workVector % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % workTensor % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % compFlux % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) ALLOCATE ( this % solutionMetaData ( 1 : nvar )) END SUBROUTINE Init_DG2D SUBROUTINE Free_DG2D ( this ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( inout ) :: this CALL this % mesh % Free () CALL this % geometry % Free () CALL this % solution % Free () CALL this % plotSolution % Free () CALL this % dSdt % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () CALL this % workScalar % Free () CALL this % workVector % Free () CALL this % workTensor % Free () CALL this % compFlux % Free () DEALLOCATE ( this % solutionMetaData ) END SUBROUTINE Free_DG2D SUBROUTINE UpdateHost_DG2D ( this ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( inout ) :: this CALL this % mesh % UpdateHost () CALL this % geometry % UpdateHost () CALL this % solution % UpdateHost () CALL this % plotSolution % UpdateHost () CALL this % dSdt % UpdateHost () CALL this % solutionGradient % UpdateHost () CALL this % flux % UpdateHost () CALL this % source % UpdateHost () CALL this % fluxDivergence % UpdateHost () CALL this % workScalar % UpdateHost () CALL this % workVector % UpdateHost () CALL this % workTensor % UpdateHost () CALL this % compFlux % UpdateHost () END SUBROUTINE UpdateHost_DG2D SUBROUTINE UpdateDevice_DG2D ( this ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( inout ) :: this CALL this % mesh % UpdateDevice () CALL this % geometry % UpdateDevice () CALL this % plotSolution % UpdateDevice () CALL this % dSdt % UpdateDevice () CALL this % solutionGradient % UpdateDevice () CALL this % flux % UpdateDevice () CALL this % source % UpdateDevice () CALL this % fluxDivergence % UpdateDevice () CALL this % workScalar % UpdateDevice () CALL this % workVector % UpdateDevice () CALL this % workTensor % UpdateDevice () CALL this % compFlux % UpdateDevice () END SUBROUTINE UpdateDevice_DG2D SUBROUTINE CalculateSolutionGradient_DG2D ( this , gpuAccel ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( inout ) :: this LOGICAL , INTENT ( in ) :: gpuAccel CALL this % solution % BassiRebaySides ( gpuAccel ) CALL this % solution % Gradient ( this % workTensor , & this % geometry , & this % solutionGradient , & selfWeakDGForm , gpuAccel ) END SUBROUTINE CalculateSolutionGradient_DG2D SUBROUTINE CalculateFluxDivergence_DG2D ( this , gpuAccel ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( inout ) :: this LOGICAL , INTENT ( in ) :: gpuAccel CALL this % flux % Divergence ( this % geometry , & this % fluxDivergence , & selfWeakDGForm , gpuAccel ) END SUBROUTINE CalculateFluxDivergence_DG2D SUBROUTINE CalculateDSDt_DG2D ( this , gpuAccel ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( inout ) :: this LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , k , iVar , iEl IF ( gpuAccel ) THEN CALL CalculateDSDt_DG2D_gpu_wrapper ( this % fluxDivergence % interior % deviceData , & this % source % interior % deviceData , & this % dSdt % interior % deviceData , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % N DO i = 0 , this % solution % N this % dSdt % interior % hostData ( i , j , iVar , iEl ) = & this % source % interior % hostData ( i , j , iVar , iEl ) - & this % fluxDivergence % interior % hostData ( i , j , iVar , iEl ) ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE CalculateDSDt_DG2D SUBROUTINE Write_DG2D ( this , fileName ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( in ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 4 ) INTEGER ( HID_T ) :: xOffset ( 1 : 5 ) INTEGER ( HID_T ) :: solGlobalDims ( 1 : 4 ) INTEGER ( HID_T ) :: xGlobalDims ( 1 : 5 ) INTEGER :: firstElem IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_TRUNC_F , fileId , this % decomp % mpiComm ) firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 4 ) = ( / 0 , 0 , 1 , firstElem / ) solGlobalDims ( 1 : 4 ) = ( / this % solution % N , & this % solution % N , & this % solution % nVar , & this % decomp % nElem / ) xOffset ( 1 : 5 ) = ( / 1 , 0 , 0 , 1 , firstElem / ) xGlobalDims ( 1 : 5 ) = ( / 2 , & this % solution % N , & this % solution % N , & this % solution % nVar , & this % decomp % nElem / ) CALL WriteArray_HDF5 ( fileId , '/solution' , & this % solution % interior , solOffset , solGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/fluxDivergence' , & this % fluxDivergence % interior , solOffset , solGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/flux' , & this % flux % interior , xOffset , xGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/solutionGradient' , & this % solutionGradient % interior , xOffset , xGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/x' , & this % geometry % x % interior , xOffset , xGlobalDims ) CALL Close_HDF5 ( fileId ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_TRUNC_F , fileId ) CALL WriteArray_HDF5 ( fileId , '/solution' , this % solution % interior ) CALL WriteArray_HDF5 ( fileId , '/fluxDivergence' , this % fluxDivergence % interior ) CALL WriteArray_HDF5 ( fileId , '/flux' , this % flux % interior ) CALL WriteArray_HDF5 ( fileId , '/solutionGradient' , this % solutionGradient % interior ) CALL WriteArray_HDF5 ( fileId , '/x' , this % geometry % x % interior ) CALL Close_HDF5 ( fileId ) END IF END SUBROUTINE Write_DG2D SUBROUTINE Read_DG2D ( this , fileName ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 4 ) INTEGER :: firstElem INTEGER :: N IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % decomp % mpiComm ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) END IF CALL ReadAttribute_HDF5 ( fileId , 'N' , N ) IF ( this % solution % N /= N ) THEN STOP 'Error : Solution polynomial degree does not match input file' END IF IF ( this % decomp % mpiEnabled ) THEN firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 4 ) = ( / 0 , 0 , 1 , firstElem / ) CALL ReadArray_HDF5 ( fileId , 'solution' , & this % solution % interior , solOffset ) ELSE CALL ReadArray_HDF5 ( fileId , 'solution' , this % solution % interior ) END IF CALL Close_HDF5 ( fileId ) END SUBROUTINE Read_DG2D SUBROUTINE Init_DG3D ( this , cqType , tqType , cqDegree , tqDegree , nvar , enableMPI , spec ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nvar LOGICAL , INTENT ( in ) :: enableMPI TYPE ( MeshSpec ), INTENT ( in ) :: spec CALL this % decomp % Init ( enableMPI ) ! Load Mesh CALL this % mesh % Load ( spec , this % decomp ) CALL this % decomp % SetMaxMsg ( this % mesh % nUniqueSides ) ! Create geometry from mesh CALL this % geometry % GenerateFromMesh ( this % mesh , cqType , tqType , cqDegree , tqDegree ) CALL this % solution % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % dSdt % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % solutionGradient % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % flux % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % source % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % fluxDivergence % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % workScalar % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % workVector % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % workTensor % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % compFlux % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) ALLOCATE ( this % solutionMetaData ( 1 : nvar )) END SUBROUTINE Init_DG3D SUBROUTINE Free_DG3D ( this ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( inout ) :: this CALL this % mesh % Free () CALL this % geometry % Free () CALL this % solution % Free () CALL this % dSdt % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () CALL this % workScalar % Free () CALL this % workVector % Free () CALL this % workTensor % Free () CALL this % compFlux % Free () DEALLOCATE ( this % solutionMetaData ) END SUBROUTINE Free_DG3D SUBROUTINE UpdateHost_DG3D ( this ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( inout ) :: this CALL this % mesh % UpdateHost () CALL this % geometry % UpdateHost () CALL this % solution % UpdateHost () CALL this % dSdt % UpdateHost () CALL this % solutionGradient % UpdateHost () CALL this % flux % UpdateHost () CALL this % source % UpdateHost () CALL this % fluxDivergence % UpdateHost () CALL this % workScalar % UpdateHost () CALL this % workVector % UpdateHost () CALL this % workTensor % UpdateHost () CALL this % compFlux % UpdateHost () END SUBROUTINE UpdateHost_DG3D SUBROUTINE UpdateDevice_DG3D ( this ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( inout ) :: this CALL this % mesh % UpdateDevice () CALL this % geometry % UpdateDevice () CALL this % solution % UpdateDevice () CALL this % dSdt % UpdateDevice () CALL this % solutionGradient % UpdateDevice () CALL this % flux % UpdateDevice () CALL this % source % UpdateDevice () CALL this % fluxDivergence % UpdateDevice () CALL this % workScalar % UpdateDevice () CALL this % workVector % UpdateDevice () CALL this % workTensor % UpdateDevice () CALL this % compFlux % UpdateDevice () END SUBROUTINE UpdateDevice_DG3D SUBROUTINE CalculateSolutionGradient_DG3D ( this , gpuAccel ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( inout ) :: this LOGICAL , INTENT ( in ) :: gpuAccel CALL this % solution % BassiRebaySides ( gpuAccel ) CALL this % solution % Gradient ( this % workTensor , & this % geometry , & this % solutionGradient , & selfWeakDGForm , gpuAccel ) END SUBROUTINE CalculateSolutionGradient_DG3D SUBROUTINE CalculateFluxDivergence_DG3D ( this , gpuAccel ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( inout ) :: this LOGICAL , INTENT ( in ) :: gpuAccel CALL this % flux % Divergence ( this % geometry , & this % fluxDivergence , & selfWeakDGForm , gpuAccel ) END SUBROUTINE CalculateFluxDivergence_DG3D SUBROUTINE CalculateDSDt_DG3D ( this , gpuAccel ) !! Adds the flux convergence and source terms together and assigns to dSdt IMPLICIT NONE CLASS ( DG3D ), INTENT ( inout ) :: this LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , k , iVar , iEl IF ( gpuAccel ) THEN CALL CalculateDSDt_DG3D_gpu_wrapper ( this % fluxDivergence % interior % deviceData , & this % source % interior % deviceData , & this % dSdt % interior % deviceData , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % N DO j = 0 , this % solution % N DO i = 0 , this % solution % N this % dSdt % interior % hostData ( i , j , k , iVar , iEl ) = & this % source % interior % hostData ( i , j , k , iVar , iEl ) - & this % fluxDivergence % interior % hostData ( i , j , k , iVar , iEl ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE CalculateDSDt_DG3D SUBROUTINE Write_DG3D ( this , fileName ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( in ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 5 ) INTEGER ( HID_T ) :: xOffset ( 1 : 6 ) INTEGER ( HID_T ) :: solGlobalDims ( 1 : 5 ) INTEGER ( HID_T ) :: xGlobalDims ( 1 : 6 ) INTEGER :: firstElem IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_TRUNC_F , fileId , & this % decomp % mpiComm ) firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 5 ) = ( / 0 , 0 , 0 , 1 , firstElem / ) solGlobalDims ( 1 : 5 ) = ( / this % solution % N , & this % solution % N , & this % solution % N , & this % solution % nVar , & this % decomp % nElem / ) xOffset ( 1 : 6 ) = ( / 1 , 0 , 0 , 0 , 1 , firstElem / ) xGlobalDims ( 1 : 6 ) = ( / 3 , & this % solution % N , & this % solution % N , & this % solution % N , & this % solution % nVar , & this % decomp % nElem / ) CALL WriteArray_HDF5 ( fileId , '/solution' , & this % solution % interior , solOffset , solGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/fluxDivergence' , & this % fluxDivergence % interior , solOffset , solGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/flux' , & this % flux % interior , xOffset , xGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/solutionGradient' , & this % solutionGradient % interior , xOffset , xGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/x' , & this % geometry % x % interior , xOffset , xGlobalDims ) CALL Close_HDF5 ( fileId ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_TRUNC_F , fileId ) CALL WriteArray_HDF5 ( fileId , '/solution' , this % solution % interior ) CALL WriteArray_HDF5 ( fileId , '/fluxDivergence' , this % fluxDivergence % interior ) CALL WriteArray_HDF5 ( fileId , '/flux' , this % flux % interior ) CALL WriteArray_HDF5 ( fileId , '/solutionGradient' , this % solutionGradient % interior ) CALL WriteArray_HDF5 ( fileId , '/x' , this % geometry % x % interior ) CALL Close_HDF5 ( fileId ) END IF END SUBROUTINE Write_DG3D SUBROUTINE Read_DG3D ( this , fileName ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 5 ) INTEGER :: firstElem INTEGER :: N IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % decomp % mpiComm ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) END IF CALL ReadAttribute_HDF5 ( fileId , 'N' , N ) IF ( this % solution % N /= N ) THEN STOP 'Error : Solution polynomial degree does not match input file' END IF IF ( this % decomp % mpiEnabled ) THEN firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 5 ) = ( / 0 , 0 , 0 , 1 , firstElem / ) CALL ReadArray_HDF5 ( fileId , 'solution' , this % solution % interior , solOffset ) ELSE CALL ReadArray_HDF5 ( fileId , 'solution' , this % solution % interior ) END IF CALL Close_HDF5 ( fileId ) END SUBROUTINE Read_DG3D END MODULE SELF_DG","tags":"","loc":"sourcefile/self_dg.f90.html"},{"title":"SELF_Quadrature.f90 – SELF","text":"This file depends on sourcefile~~self_quadrature.f90~~EfferentGraph sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_quadrature.f90~~AfferentGraph sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~self_advection2d.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~self_advection3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_mesh.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Quadrature Source Code SELF_Quadrature.f90 Source Code ! SELF_Quadrature.f90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Contains routines from D.A. Kopriva, 2009, \"Implementing Spectral Methods for Partial ! Differential Equations: Algorithms for Scientists and Engineers\", Springer. ! ! Routines are defined for computing Legendre and Chebyshev Gauss and Gauss-Lobatto ! quadrature nodes and weights. MODULE SELF_Quadrature USE ISO_FORTRAN_ENV USE SELF_Constants IMPLICIT NONE PUBLIC :: ChebyshevQuadrature , LegendreQuadrature PRIVATE :: ChebyshevGauss , ChebyshevGaussLobatto , & LegendreGauss , LegendreGaussLobatto , & LegendreQandL CONTAINS ! =============================================================================================== ! ! LegendreQuadrature !   Returns the specified Legendre quadrature nodes and integration weights. ! !   Given a polynomial degree, and quadrature type (Gauss or Gauss Lobatto), this subroutine manages !   the calls to underlying private routines to generate the desired Legendre quadrature. ! !   Usage : ! !     INTEGER    :: N, quadType !     REAL(real64) :: nodes(0:N), weights(0:N) ! !       CALL LegendreQuadrature( N, quadType, nodes, weights ) ! !   Parameters : ! !     N (in) !       Degree of the quadrature ! !     quadType (in) !       Flag specifying the quadrature type. Can be set to GAUSS or GAUSS_LOBATTO ! !     nodes(0:N) (out) !       Array of quadrature nodes ! !     weights(0:N) (out) !       Array of quadrature weights ! ! =============================================================================================== ! SUBROUTINE LegendreQuadrature ( N , nodes , weights , QuadType ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N REAL ( prec ), INTENT ( out ) :: nodes ( 0 : N ) REAL ( prec ), INTENT ( out ) :: weights ( 0 : N ) INTEGER , INTENT ( in ) :: QuadType ! Local REAL ( real64 ) :: nodesLocal ( 0 : N ) REAL ( real64 ) :: weightsLocal ( 0 : N ) INTEGER :: i IF ( QuadType == GAUSS_LOBATTO ) THEN CALL LegendreGaussLobatto ( N , nodesLocal , weightsLocal ) ELSEIF ( QuadType == GAUSS ) THEN CALL LegendreGauss ( N , nodesLocal , weightsLocal ) END IF DO i = 0 , N nodes ( i ) = REAL ( nodesLocal ( i ), prec ) weights ( i ) = REAL ( weightsLocal ( i ), prec ) END DO END SUBROUTINE LegendreQuadrature ! =============================================================================================== ! ! ChebyshevQuadrature ! !   Returns the specified Chebyshev quadrature nodes and integration weights. ! !   Given a polynomial degree, and quadrature type (Gauss or Gauss Lobatto), this subroutine manages !   the calls to underlying private routines to generate the desired Chebyshev quadrature. ! !   Usage : ! !     INTEGER    :: N, quadType !     REAL(real64) :: nodes(0:N), weights(0:N) ! !       CALL ChebyshevQuadrature( N, quadType, nodes, weights ) ! !   Input/Output : ! !     N (in) !       Degree of the quadrature ! !     quadType (in) !       Flag specifying the quadrature type. Can be set to GAUSS or GAUSS_LOBATTO ! !     nodes(0:N) (out) !       Array of quadrature nodes ! !     weights(0:N) (out) !       Array of quadrature weights ! ! ================================================================================================ ! SUBROUTINE ChebyshevQuadrature ( N , nodes , weights , quadType ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N REAL ( real64 ), INTENT ( out ) :: nodes ( 0 : N ) REAL ( real64 ), INTENT ( out ) :: weights ( 0 : N ) INTEGER , INTENT ( in ) :: QuadType ! Local REAL ( real64 ) :: nodesLocal ( 0 : N ) REAL ( real64 ) :: weightsLocal ( 0 : N ) INTEGER :: i IF ( QuadType == CHEBYSHEV_GAUSS_LOBATTO ) then CALL ChebyshevGaussLobatto ( N , nodesLocal , weightsLocal ) ELSEIF ( QuadType == CHEBYSHEV_GAUSS ) then CALL ChebyshevGauss ( N , nodesLocal , weightsLocal ) END IF DO i = 0 , N nodes ( i ) = REAL ( nodesLocal ( i ), prec ) weights ( i ) = REAL ( weightsLocal ( i ), prec ) END DO END SUBROUTINE ChebyshevQuadrature ! =============================================================================================== ! ! S/R ChebyshevGauss !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 67 !   Algorithm 26 ! =============================================================================================== ! SUBROUTINE ChebyshevGauss ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local INTEGER :: j DO j = 0 , N weights ( j ) = pi / ( REAL ( N , real64 ) + 1.0_real64 ) nodes ( j ) = - cos ( 0.5_real64 * ( 2.0_real64 * REAL ( j , real64 ) + 1.0_real64 ) * weights ( j )) END DO END SUBROUTINE ChebyshevGauss ! =============================================================================================== ! ! S/R ChebyshevGaussLobatto !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 68 !   Algorithm 27 ! =============================================================================================== ! SUBROUTINE ChebyshevGaussLobatto ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! LOCAL INTEGER :: j DO j = 0 , N weights ( j ) = pi / REAL ( N , real64 ) nodes ( j ) = - cos ( REAL ( j , real64 ) * weights ( j )) END DO weights ( 0 ) = weights ( 0 ) * 0.5_real64 weights ( N ) = weights ( N ) * 0.5_real64 END SUBROUTINE ChebyshevGaussLobatto ! =============================================================================================== ! ! S/R LegendreGauss !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 64 !   Algorithm 23 ! =============================================================================================== ! SUBROUTINE LegendreGauss ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local REAL ( real64 ) :: nodes_local ( 0 : N ) REAL ( real64 ) :: weights_local ( 0 : N ) REAL ( real64 ) :: lN1 , dlN1 REAL ( real64 ) :: delta INTEGER :: j , kIt IF ( N == 0 ) then nodes_local ( 0 ) = 0.0_real64 weights_local ( 0 ) = 2.0_real64 ELSEIF ( N == 1 ) then nodes_local ( 0 ) = - SQRT ( 1.0_real64 / 3.0_real64 ) weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = - nodes ( 0 ) weights_local ( 1 ) = weights ( 0 ) ELSE DO j = 0 , (( N + 1 ) / 2 ) nodes_local ( j ) = - cos (( 2.0_real64 * REAL ( j , real64 ) + 1.0_real64 ) * pi / ( 2.0_real64 * REAL ( N , real64 ) + 1.0_real64 )) DO kIt = 1 , newtonMax CALL LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) delta = - lN1 / dlN1 nodes_local ( j ) = nodes_local ( j ) + delta IF ( abs ( delta ) <= TOL * nodes_local ( j )) EXIT END DO CALL LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) weights_local ( j ) = 2.0_real64 / (( 1.0_real64 - nodes_local ( j ) * nodes_local ( j )) * dlN1 * dlN1 ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) END DO END IF IF ( MOD ( REAL ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) then CALL LegendrePolynomial ( N + 1 , 0.0_real64 , lN1 , dlN1 ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0 / ( dlN1 * dlN1 ) END IF DO j = 0 , N nodes ( j ) = REAL ( nodes_local ( j ), real64 ) weights ( j ) = REAL ( weights_local ( j ), real64 ) END DO END SUBROUTINE LegendreGauss ! =============================================================================================== ! ! S/R LegendreGaussLobatto !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 66 !   Algorithm 25 ! =============================================================================================== ! SUBROUTINE LegendreGaussLobatto ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local REAL ( real64 ) :: nodes_local ( 0 : N ) REAL ( real64 ) :: weights_local ( 0 : N ) REAL ( real64 ) :: delta , q , qprime , lN INTEGER :: j , kIt IF ( N == 1 ) then nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = 1.0_real64 weights_local ( 1 ) = 1.0_real64 ELSE nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 )) nodes_local ( N ) = 1.0_real64 weights_local ( N ) = weights_local ( 0 ) DO j = 1 , (( N + 1 ) / 2 - 1 ) nodes_local ( j ) = - COS (( REAL ( j , real64 ) + 0.25_real64 ) * pi / REAL ( N , real64 ) - & 3.0_real64 / ( 8.0_real64 * REAL ( N , real64 ) * pi * ( REAL ( j , real64 ) + 0.25_real64 ))) DO kIt = 1 , newtonMax CALL LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) delta = - q / qprime nodes_local ( j ) = nodes_local ( j ) + delta IF ( ABS ( delta ) <= TOL * nodes_local ( j )) EXIT END DO CALL LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) weights_local ( j ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 ) * lN * lN ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) END DO END IF IF ( MOD ( REAL ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) THEN CALL LegendreQandL ( N , 0.0_real64 , q , qprime , lN ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 ) * lN * lN ) END IF DO j = 0 , N nodes ( j ) = REAL ( nodes_local ( j ), real64 ) weights ( j ) = REAL ( weights_local ( j ), real64 ) END DO END SUBROUTINE LegendreGaussLobatto ! =============================================================================================== ! ! S/R LegendrePolynomial !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 63 !   Algorithm 22 ! =============================================================================================== ! SUBROUTINE LegendrePolynomial ( N , x , lAtX , dLdxAtX ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: x REAL ( real64 ) :: lAtX , dLdxAtX ! Local REAL ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 INTEGER :: i IF ( N == 0 ) then lAtX = 1.0_real64 dLdxAtX = 0.0_real64 ELSEIF ( N == 1 ) then lAtX = x dLdxAtX = 1.0_real64 ELSE lnM2 = 1.0_real64 lnM1 = x dlnM2 = 0.0_real64 dlnM1 = 1.0_real64 DO i = 2 , N lAtX = (( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * x * lnM1 - & ( REAL ( i , real64 ) - 1.0_real64 ) * lnM2 ) / ( REAL ( i , real64 )) dldxAtX = dlnM2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lnM1 lnM2 = lnM1 lnM1 = lAtX dlnM2 = dlnM1 dlnM1 = dldxAtX END DO END IF END SUBROUTINE LegendrePolynomial ! =============================================================================================== ! ! S/R LegendreQandL !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 65 !   Algorithm 24 ! =============================================================================================== ! SUBROUTINE LegendreQandL ( N , x , q , qprime , lN ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: x REAL ( real64 ) :: lN , q , qprime ! Local REAL ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 , dlN , lN1 , dlN1 INTEGER :: i lNm2 = 1.0_real64 lNm1 = x dlNm2 = 0.0_real64 dlNm1 = 1.0_real64 DO i = 2 , N lN = ( 2.0_real64 * i - 1.0_real64 ) / ( REAL ( i , real64 )) * x * lNm1 - ( REAL ( i , real64 ) - 1.0_real64 ) / ( REAL ( i , real64 )) * lNm2 dlN = dlNm2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lNm1 lNm2 = lNm1 lNm1 = lN dlNm2 = dlNm1 dlNm1 = dlN END DO i = N + 1 lN1 = ( 2.0_real64 * i - 1.0_real64 ) / ( REAL ( i , real64 )) * x * lN - ( REAL ( i , real64 ) - 1.0_real64 ) / ( REAL ( i , real64 )) * lNm2 dlN1 = dlNm2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lNm1 q = lN1 - lNm2 qprime = dlN1 - dlNm2 END SUBROUTINE LegendreQandL END MODULE SELF_Quadrature","tags":"","loc":"sourcefile/self_quadrature.f90.html"},{"title":"SELF_Lagrange.f90 – SELF","text":"This file depends on sourcefile~~self_lagrange.f90~~EfferentGraph sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_lagrange.f90~~AfferentGraph sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~sadv3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~self_advection2d.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~self_advection3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~sadv2d.f90->sourcefile~self_mesh.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Lagrange Source Code SELF_Lagrange.f90 Source Code ! SELF_Lagrange.f90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self@higherordermethods.org ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Lagrange USE ISO_FORTRAN_ENV USE SELF_Constants USE SELF_Memory USE SELF_SupportRoutines USE SELF_Quadrature USE hipfort USE hipfort_check USE ISO_C_BINDING IMPLICIT NONE TYPE , PUBLIC :: Lagrange !! A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions. !! The Lagrange data-structure stores the information necessary to interpolate between two !! sets of grid-points and to estimate the derivative of data at native grid points. Routines for !! multidimensional interpolation are based on the tensor product of 1-D interpolants. It is !! assumed that the polynomial degree (and the interpolation nodes) are the same in each direction. !! This assumption permits the storage of only one array of interpolation nodes and barycentric !! weights and is what allows this data structure to be flexible. INTEGER :: N !! The number of control points. INTEGER :: M !! The number of target points. TYPE ( hfReal_r1 ) :: controlPoints !! The set of nodes in one dimension where data is known. !! To create higher dimension interpolation and differentiation operators, structured grids in two and three !! dimensions are created by tensor products of the controlPoints. This design decision implies that all !! spectral element methods supported by the Lagrange class have the same polynomial degree in each !! computational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto, !! Legendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over !! the domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of !! these quadrature types or uniform points on [-1,1]. TYPE ( hfReal_r1 ) :: targetPoints !! The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation !! and differentiation operators, structured grids in two and three dimensions are created by tensor products of !! the targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1] !! (computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. TYPE ( hfReal_r1 ) :: bWeights !! The barycentric weights that are calculated from the controlPoints and used for interpolation. TYPE ( hfReal_r1 ) :: qWeights !! The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints !! provided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss, !! Chebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant !! dx = \\frac{2.0}{N+1}. TYPE ( hfReal_r2 ) :: iMatrix !! The interpolation matrix (transpose) for mapping data from the control grid to the target grid. TYPE ( hfReal_r2 ) :: dMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The !! dMatrix is based on a strong form of the derivative. TYPE ( hfReal_r2 ) :: dgMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based !! on a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. TYPE ( hfReal_r2 ) :: bMatrix !! The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. CONTAINS PROCEDURE , PUBLIC :: Init => Init_Lagrange PROCEDURE , PUBLIC :: Free => Free_Lagrange PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Lagrange PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Lagrange GENERIC , PUBLIC :: ScalarGridInterp_1D => ScalarGridInterp_1D_cpu , ScalarGridInterp_1D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_1D_cpu , ScalarGridInterp_1D_gpu GENERIC , PUBLIC :: ScalarGridInterp_2D => ScalarGridInterp_2D_cpu , ScalarGridInterp_2D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_2D_cpu , ScalarGridInterp_2D_gpu GENERIC , PUBLIC :: VectorGridInterp_2D => VectorGridInterp_2D_cpu , VectorGridInterp_2D_gpu PROCEDURE , PRIVATE :: VectorGridInterp_2D_cpu , VectorGridInterp_2D_gpu GENERIC , PUBLIC :: TensorGridInterp_2D => TensorGridInterp_2D_cpu , TensorGridInterp_2D_gpu PROCEDURE , PRIVATE :: TensorGridInterp_2D_cpu , TensorGridInterp_2D_gpu GENERIC , PUBLIC :: ScalarGridInterp_3D => ScalarGridInterp_3D_cpu , ScalarGridInterp_3D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_3D_cpu , ScalarGridInterp_3D_gpu GENERIC , PUBLIC :: VectorGridInterp_3D => VectorGridInterp_3D_cpu , VectorGridInterp_3D_gpu PROCEDURE , PRIVATE :: VectorGridInterp_3D_cpu , VectorGridInterp_3D_gpu GENERIC , PUBLIC :: TensorGridInterp_3D => TensorGridInterp_3D_cpu , TensorGridInterp_3D_gpu PROCEDURE , PRIVATE :: TensorGridInterp_3D_cpu , TensorGridInterp_3D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_1D => ScalarBoundaryInterp_1D_cpu , ScalarBoundaryInterp_1D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_1D_cpu , ScalarBoundaryInterp_1D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_2D => ScalarBoundaryInterp_2D_cpu , ScalarBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_2D_cpu , ScalarBoundaryInterp_2D_gpu GENERIC , PUBLIC :: VectorBoundaryInterp_2D => VectorBoundaryInterp_2D_cpu , VectorBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: VectorBoundaryInterp_2D_cpu , VectorBoundaryInterp_2D_gpu GENERIC , PUBLIC :: TensorBoundaryInterp_2D => TensorBoundaryInterp_2D_cpu , TensorBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: TensorBoundaryInterp_2D_cpu , TensorBoundaryInterp_2D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_3D => ScalarBoundaryInterp_3D_cpu , ScalarBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_3D_cpu , ScalarBoundaryInterp_3D_gpu GENERIC , PUBLIC :: VectorBoundaryInterp_3D => VectorBoundaryInterp_3D_cpu , VectorBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: VectorBoundaryInterp_3D_cpu , VectorBoundaryInterp_3D_gpu GENERIC , PUBLIC :: TensorBoundaryInterp_3D => TensorBoundaryInterp_3D_cpu , TensorBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: TensorBoundaryInterp_3D_cpu , TensorBoundaryInterp_3D_gpu GENERIC , PUBLIC :: Derivative_1D => Derivative_1D_cpu , Derivative_1D_gpu PROCEDURE , PRIVATE :: Derivative_1D_cpu , Derivative_1D_gpu GENERIC , PUBLIC :: DGDerivative_1D => DGDerivative_1D_cpu , DGDerivative_1D_gpu PROCEDURE , PRIVATE :: DGDerivative_1D_cpu , DGDerivative_1D_gpu GENERIC , PUBLIC :: ScalarGradient_2D => ScalarGradient_2D_cpu , ScalarGradient_2D_gpu PROCEDURE , PRIVATE :: ScalarGradient_2D_cpu , ScalarGradient_2D_gpu GENERIC , PUBLIC :: ScalarDGGradient_2D => ScalarDGGradient_2D_cpu , ScalarDGGradient_2D_gpu PROCEDURE , PRIVATE :: ScalarDGGradient_2D_cpu , ScalarDGGradient_2D_gpu GENERIC , PUBLIC :: VectorGradient_2D => VectorGradient_2D_cpu , VectorGradient_2D_gpu PROCEDURE , PRIVATE :: VectorGradient_2D_cpu , VectorGradient_2D_gpu GENERIC , PUBLIC :: VectorDGGradient_2D => VectorDGGradient_2D_cpu , VectorDGGradient_2D_gpu PROCEDURE , PRIVATE :: VectorDGGradient_2D_cpu , VectorDGGradient_2D_gpu GENERIC , PUBLIC :: VectorDivergence_2D => VectorDivergence_2D_cpu , VectorDivergence_2D_gpu PROCEDURE , PRIVATE :: VectorDivergence_2D_cpu , VectorDivergence_2D_gpu GENERIC , PUBLIC :: VectorDGDivergence_2D => VectorDGDivergence_2D_cpu , VectorDGDivergence_2D_gpu PROCEDURE , PRIVATE :: VectorDGDivergence_2D_cpu , VectorDGDivergence_2D_gpu GENERIC , PUBLIC :: VectorCurl_2D => VectorCurl_2D_cpu , VectorCurl_2D_gpu PROCEDURE , PRIVATE :: VectorCurl_2D_cpu , VectorCurl_2D_gpu GENERIC , PUBLIC :: TensorDivergence_2D => TensorDivergence_2D_cpu , TensorDivergence_2D_gpu PROCEDURE , PRIVATE :: TensorDivergence_2D_cpu , TensorDivergence_2D_gpu GENERIC , PUBLIC :: TensorDGDivergence_2D => TensorDGDivergence_2D_cpu , TensorDGDivergence_2D_gpu PROCEDURE , PRIVATE :: TensorDGDivergence_2D_cpu , TensorDGDivergence_2D_gpu GENERIC , PUBLIC :: ScalarGradient_3D => ScalarGradient_3D_cpu , ScalarGradient_3D_gpu PROCEDURE , PRIVATE :: ScalarGradient_3D_cpu , ScalarGradient_3D_gpu GENERIC , PUBLIC :: VectorGradient_3D => VectorGradient_3D_cpu , VectorGradient_3D_gpu PROCEDURE , PRIVATE :: VectorGradient_3D_cpu , VectorGradient_3D_gpu GENERIC , PUBLIC :: VectorDivergence_3D => VectorDivergence_3D_cpu , VectorDivergence_3D_gpu PROCEDURE , PRIVATE :: VectorDivergence_3D_cpu , VectorDivergence_3D_gpu GENERIC , PUBLIC :: VectorDGDivergence_3D => VectorDGDivergence_3D_cpu , VectorDGDivergence_3D_gpu PROCEDURE , PRIVATE :: VectorDGDivergence_3D_cpu , VectorDGDivergence_3D_gpu GENERIC , PUBLIC :: VectorCurl_3D => VectorCurl_3D_cpu , VectorCurl_3D_gpu PROCEDURE , PRIVATE :: VectorCurl_3D_cpu , VectorCurl_3D_gpu GENERIC , PUBLIC :: TensorDivergence_3D => TensorDivergence_3D_cpu , TensorDivergence_3D_gpu PROCEDURE , PRIVATE :: TensorDivergence_3D_cpu , TensorDivergence_3D_gpu GENERIC , PUBLIC :: TensorDGDivergence_3D => TensorDGDivergence_3D_cpu , TensorDGDivergence_3D_gpu PROCEDURE , PRIVATE :: TensorDGDivergence_3D_cpu , TensorDGDivergence_3D_gpu PROCEDURE , PRIVATE :: CalculateBarycentricWeights PROCEDURE , PRIVATE :: CalculateInterpolationMatrix PROCEDURE , PRIVATE :: CalculateDerivativeMatrix PROCEDURE , PRIVATE :: CalculateLagrangePolynomials END TYPE Lagrange INTERFACE SUBROUTINE ScalarGridInterp_1D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"ScalarGridInterp_1D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER ( C_INT ), VALUE :: N , M , nVar , nEl END SUBROUTINE ScalarGridInterp_1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarGridInterp_2D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"ScalarGridInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER ( C_INT ), VALUE :: N , M , nVar , nEl END SUBROUTINE ScalarGridInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorGridInterp_2D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"VectorGridInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER ( C_INT ), VALUE :: N , M , nVar , nEl END SUBROUTINE VectorGridInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorGridInterp_2D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"TensorGridInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER ( C_INT ), VALUE :: N , M , nVar , nEl END SUBROUTINE TensorGridInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarGridInterp_3D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"ScalarGridInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER ( C_INT ), VALUE :: N , M , nVar , nEl END SUBROUTINE ScalarGridInterp_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorGridInterp_3D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"VectorGridInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER ( C_INT ), VALUE :: N , M , nVar , nEl END SUBROUTINE VectorGridInterp_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorGridInterp_3D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"TensorGridInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER ( C_INT ), VALUE :: N , M , nVar , nEl END SUBROUTINE TensorGridInterp_3D_gpu_wrapper END INTERFACE ! /////////////// ! ! Boundary Interpolation Routines INTERFACE SUBROUTINE ScalarBoundaryInterp_1D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarBoundaryInterp_1D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ScalarBoundaryInterp_1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarBoundaryInterp_2D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarBoundaryInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ScalarBoundaryInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorBoundaryInterp_2D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"VectorBoundaryInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorBoundaryInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorBoundaryInterp_2D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"TensorBoundaryInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE TensorBoundaryInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarBoundaryInterp_3D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarBoundaryInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ScalarBoundaryInterp_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorBoundaryInterp_3D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"VectorBoundaryInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorBoundaryInterp_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorBoundaryInterp_3D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"TensorBoundaryInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE TensorBoundaryInterp_3D_gpu_wrapper END INTERFACE ! /////////////// ! INTERFACE SUBROUTINE Derivative_1D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"Derivative_1D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE Derivative_1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE DGDerivative_1D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"DGDerivative_1D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE DGDerivative_1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarGradient_2D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarGradient_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ScalarGradient_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarDGGradient_2D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarDGGradient_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ScalarDGGradient_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorGradient_2D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorGradient_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorGradient_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorDGGradient_2D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorDGGradient_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorDGGradient_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorDivergence_2D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorDivergence_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorDivergence_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorDGDivergence_2D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorDGDivergence_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorDGDivergence_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorCurl_2D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorCurl_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorCurl_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorDivergence_2D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"TensorDivergence_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE TensorDivergence_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorDGDivergence_2D_gpu_wrapper ( dMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"TensorDGDivergence_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE TensorDGDivergence_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarGradient_3D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarGradient_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE ScalarGradient_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorGradient_3D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorGradient_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorGradient_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorDivergence_3D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorDivergence_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorDivergence_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorDGDivergence_3D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorDGDivergence_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorDGDivergence_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorCurl_3D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorCurl_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE VectorCurl_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorDivergence_3D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"TensorDivergence_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE TensorDivergence_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorDGDivergence_3D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"TensorDGDivergence_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER ( C_INT ), VALUE :: N , nVar , nEl END SUBROUTINE TensorDGDivergence_3D_gpu_wrapper END INTERFACE CONTAINS SUBROUTINE Init_Lagrange ( myPoly , N , controlNodeType , M , targetNodeType ) !! Initialize an instance of the Lagrange class !! On output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of !! control points, number of target points, and the types for the control and target nodes. !! If a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. IMPLICIT NONE CLASS ( Lagrange ), INTENT ( out ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: N !! The number of control points for interpolant INTEGER , INTENT ( in ) :: M !! The number of target points for the interpolant INTEGER , INTENT ( in ) :: controlNodeType !! The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) INTEGER , INTENT ( in ) :: targetNodeType !! The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) ! -------! ! Local REAL ( prec ) :: q ( 0 : M ) myPoly % N = N myPoly % M = M CALL myPoly % controlPoints % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % targetPoints % Alloc ( loBound = 0 , & upBound = M ) CALL myPoly % bWeights % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % qWeights % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % iMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , M / )) CALL myPoly % dMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , N / )) CALL myPoly % dgMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , N / )) CALL myPoly % bMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , 1 / )) IF ( controlNodeType == GAUSS . OR . controlNodeType == GAUSS_LOBATTO ) THEN CALL LegendreQuadrature ( N , & myPoly % controlPoints % hostData , & myPoly % qWeights % hostData , & controlNodeType ) ELSEIF ( controlNodeType == CHEBYSHEV_GAUSS . OR . controlNodeType == CHEBYSHEV_GAUSS_LOBATTO ) THEN CALL ChebyshevQuadrature ( N , & myPoly % controlPoints % hostData , & myPoly % qWeights % hostData , & controlNodeType ) ELSEIF ( controlNodeType == UNIFORM ) THEN myPoly % controlPoints % hostData = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , N ) myPoly % qWeights % hostData = 2.0_prec / REAL ( N , prec ) END IF ! Target Points IF ( targetNodeType == GAUSS . OR . targetNodeType == GAUSS_LOBATTO ) THEN CALL LegendreQuadrature ( M , & myPoly % targetPoints % hostData , & q , & targetNodeType ) ELSEIF ( targetNodeType == UNIFORM ) THEN myPoly % targetPoints % hostData = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , M ) END IF CALL myPoly % CalculateBarycentricWeights () CALL myPoly % CalculateInterpolationMatrix () CALL myPoly % CalculateDerivativeMatrix () myPoly % bMatrix % hostData ( 0 : N , 0 ) = myPoly % CalculateLagrangePolynomials ( - 1.0_prec ) myPoly % bMatrix % hostData ( 0 : N , 1 ) = myPoly % CalculateLagrangePolynomials ( 1.0_prec ) CALL myPoly % UpdateDevice () END SUBROUTINE Init_Lagrange SUBROUTINE Free_Lagrange ( myPoly ) !! Frees all memory (host and device) associated with an instance of the Lagrange class IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly !! Lagrange class instance CALL myPoly % controlPoints % Free () CALL myPoly % targetPoints % Free () CALL myPoly % bWeights % Free () CALL myPoly % qWeights % Free () CALL myPoly % iMatrix % Free () CALL myPoly % dMatrix % Free () CALL myPoly % dgMatrix % Free () CALL myPoly % bMatrix % Free () END SUBROUTINE Free_Lagrange SUBROUTINE UpdateDevice_Lagrange ( myPoly ) !! Copy the Lagrange attributes from the host (CPU) to the device (GPU) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly !! Lagrange class instance CALL myPoly % controlPoints % UpdateDevice () CALL myPoly % targetPoints % UpdateDevice () CALL myPoly % bWeights % UpdateDevice () CALL myPoly % qWeights % UpdateDevice () CALL myPoly % iMatrix % UpdateDevice () CALL myPoly % dMatrix % UpdateDevice () CALL myPoly % dgMatrix % UpdateDevice () CALL myPoly % bMatrix % UpdateDevice () END SUBROUTINE UpdateDevice_Lagrange SUBROUTINE UpdateHost_Lagrange ( myPoly ) !! Copy the Lagrange attributes from the device (GPU) to the host (CPU) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly !! Lagrange class instance CALL myPoly % controlPoints % UpdateHost () CALL myPoly % targetPoints % UpdateHost () CALL myPoly % bWeights % UpdateHost () CALL myPoly % qWeights % UpdateHost () CALL myPoly % iMatrix % UpdateHost () CALL myPoly % dMatrix % UpdateHost () CALL myPoly % dgMatrix % UpdateHost () CALL myPoly % bMatrix % UpdateHost () END SUBROUTINE UpdateHost_Lagrange SUBROUTINE ScalarGridInterp_1D_cpu ( myPoly , f , fInterp , nVariables , nElements ) !! Host (CPU) implementation of the ScalarGridInterp_1D interface. !! In most cases, you should use the `ScalarGridInterp_1D` generic interface, !! rather than calling this routine directly. !! Interpolate a scalar-1D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,ivar,iel} = \\sum_{i=0}&#94;N f_{i,ivar,iel} I_{i,m}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) !! (Input) Array of function values, defined on the control grid REAL ( prec ), INTENT ( out ) :: fInterp ( 0 : myPoly % M , 1 : nVariables , 1 : nElements ) !! (Output) Array of function values, defined on the target grid ! Local INTEGER :: iVar , iEl , i , ii DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % M fInterp ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N fInterp ( i , iVar , iEl ) = fInterp ( i , iVar , iEl ) + myPoly % iMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_1D_cpu SUBROUTINE ScalarGridInterp_1D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) !! Device (GPU) implementation of the ScalarGridInterp_1D interface. !! In most cases, you should use the `ScalarGridInterp_1D` generic interface, !! rather than calling this routine directly. !! This routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_1D_gpu_wrapper !! Interpolate a scalar-1D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,ivar,iel} = \\sum_{i=0}&#94;N f_{i,ivar,iel} I_{i,m}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid TYPE ( c_ptr ), INTENT ( in ) :: f_dev !! (Input) Array of function values, defined on the control grid TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev !! (Output) Array of function values, defined on the target grid CALL ScalarGridInterp_1D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE ScalarGridInterp_1D_gpu SUBROUTINE ScalarGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) !! Host (CPU) implementation of the ScalarGridInterp_2D interface. !! In most cases, you should use the `ScalarGridInterp_2D` generic interface, !! rather than calling this routine directly. !! Interpolate a scalar-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) !! (Input) Array of function values, defined on the control grid REAL ( prec ), INTENT ( out ) :: fNew ( 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) !! (Output) Array of function values, defined on the target grid ! Local INTEGER :: i , j , ii , jj , iEl , iVar REAL ( prec ) :: fi , fij DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fij = 0.0_prec DO jj = 0 , myPoly % N fi = 0.0_prec DO ii = 0 , myPoly % N fi = fi + f ( ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij = fij + fi * myPoly % iMatrix % hostData ( jj , j ) END DO fNew ( i , j , iVar , iEl ) = fij END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_2D_cpu SUBROUTINE ScalarGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) !! Device (GPU) implementation of the ScalarGridInterp_2D interface. !! In most cases, you should use the `ScalarGridInterp_2D` generic interface, !! rather than calling this routine directly. !! This routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_2D_gpu_wrapper !! Interpolate a scalar-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid TYPE ( c_ptr ), INTENT ( in ) :: f_dev !! (Input) Array of function values, defined on the control grid TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev !! (Output) Array of function values, defined on the target grid CALL ScalarGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE ScalarGridInterp_2D_gpu SUBROUTINE VectorGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) !! Host (CPU) implementation of the VectorGridInterp_2D interface. !! In most cases, you should use the `VectorGridInterp_2D` generic interface, !! rather than calling this routine directly. !! Interpolate a vector-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{dir,m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{dir,i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) !! (Input) Array of function values, defined on the control grid REAL ( prec ), INTENT ( out ) :: fNew ( 1 : 2 , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) !! (Output) Array of function values, defined on the target grid ! Local INTEGER :: i , j , ii , jj , iEl , iVar REAL ( prec ) :: fi ( 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fNew ( 1 , i , j , iVar , iEl ) = 0.0_prec fNew ( 2 , i , j , iVar , iEl ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 2 ) = fi ( 1 : 2 ) + f ( 1 : 2 , ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fNew ( 1 : 2 , i , j , iVar , iEl ) = fNew ( 1 : 2 , i , j , iVar , iEl ) + fi ( 1 : 2 ) * myPoly % iMatrix % hostData ( jj , j ) END DO END DO END DO END DO END DO END SUBROUTINE VectorGridInterp_2D_cpu ! SUBROUTINE VectorGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) !! Device (GPU) implementation of the VectorGridInterp_2D interface. !! In most cases, you should use the `VectorGridInterp_2D` generic interface, !! rather than calling this routine directly. !! This routine calls hip/SELF_Lagrange.cpp:VectorGridInterp_2D_gpu_wrapper !! Interpolate a vector-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{dir,m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{dir,i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid TYPE ( c_ptr ), INTENT ( in ) :: f_dev !! (Input) Array of function values, defined on the control grid TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev !! (Output) Array of function values, defined on the target grid CALL VectorGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE VectorGridInterp_2D_gpu SUBROUTINE TensorGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) !! Host (CPU) implementation of the TensorGridInterp_2D interface. !! In most cases, you should use the `TensorGridInterp_2D` generic interface, !! rather than calling this routine directly. !! Interpolate a tensor-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-tensor multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{row,col,m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{row,col,i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) !! (Input) Array of function values, defined on the control grid REAL ( prec ), INTENT ( out ) :: fNew ( 1 : 2 , 1 : 2 , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) !! (Output) Array of function values, defined on the target grid ! Local INTEGER :: i , j , ii , jj , iEl , iVar REAL ( prec ) :: fi ( 1 : 2 , 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fNew ( 1 : 2 , 1 : 2 , i , j , iVar , iEl ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 2 , 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 2 , 1 : 2 ) = fi ( 1 : 2 , 1 : 2 ) + f ( 1 : 2 , 1 : 2 , ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fNew ( 1 : 2 , 1 : 2 , i , j , iVar , iEl ) = fNew ( 1 : 2 , 1 : 2 , i , j , iVar , iEl ) + fi ( 1 : 2 , 1 : 2 ) * myPoly % iMatrix % hostData ( jj , j ) END DO END DO END DO END DO END DO END SUBROUTINE TensorGridInterp_2D_cpu ! SUBROUTINE TensorGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) !! Device (GPU) implementation of the TensorGridInterp_2D interface. !! In most cases, you should use the `TensorGridInterp_2D` generic interface, !! rather than calling this routine directly. !! This routine calls hip/SELF_Lagrange.cpp:TensorGridInterp_2D_gpu_wrapper !! Interpolate a tensor-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{row,col,m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{row,col,i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid TYPE ( c_ptr ), INTENT ( in ) :: f_dev !! (Input) Array of function values, defined on the control grid TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev !! (Output) Array of function values, defined on the target grid CALL TensorGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE TensorGridInterp_2D_gpu SUBROUTINE ScalarGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi , fij , fijk DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fijk = 0.0_prec DO kk = 0 , myPoly % N fij = 0.0_prec DO jj = 0 , myPoly % N fi = 0.0_prec DO ii = 0 , myPoly % N fi = fi + f ( ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij = fij + fi * myPoly % iMatrix % hostData ( jj , j ) END DO fijk = fijk + fij * myPoly % iMatrix % hostData ( kk , k ) END DO fInterp ( i , j , k , iVar , iEl ) = fijk END DO END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_3D_cpu ! SUBROUTINE ScalarGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev CALL ScalarGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE ScalarGridInterp_3D_gpu SUBROUTINE VectorGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 1 : 3 , 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi ( 1 : 3 ), fij ( 1 : 3 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fInterp ( 1 : 3 , i , j , k , iVar , iEl ) = 0.0_prec DO kk = 0 , myPoly % N fij ( 1 : 3 ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 3 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 3 ) = fi ( 1 : 3 ) + f ( 1 : 3 , ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij ( 1 : 3 ) = fij ( 1 : 3 ) + fi ( 1 : 3 ) * myPoly % iMatrix % hostData ( jj , j ) END DO fInterp ( 1 : 3 , i , j , k , iVar , iEl ) = fInterp ( 1 : 3 , i , j , k , iVar , iEl ) + fij ( 1 : 3 ) * myPoly % iMatrix % hostData ( kk , k ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorGridInterp_3D_cpu ! SUBROUTINE VectorGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev CALL VectorGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE VectorGridInterp_3D_gpu SUBROUTINE TensorGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 1 : 3 , 1 : 3 , 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi ( 1 : 3 , 1 : 3 ), fij ( 1 : 3 , 1 : 3 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fInterp ( 1 : 3 , 1 : 3 , i , j , k , iVar , iEl ) = 0.0_prec DO kk = 0 , myPoly % N fij ( 1 : 3 , 1 : 3 ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 3 , 1 : 3 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 3 , 1 : 3 ) = fi ( 1 : 3 , 1 : 3 ) + f ( 1 : 3 , 1 : 3 , ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij ( 1 : 3 , 1 : 3 ) = fij ( 1 : 3 , 1 : 3 ) + fi ( 1 : 3 , 1 : 3 ) * myPoly % iMatrix % hostData ( jj , j ) END DO fInterp ( 1 : 3 , 1 : 3 , i , j , k , iVar , iEl ) = fInterp ( 1 : 3 , 1 : 3 , i , j , k , iVar , iEl ) + & fij ( 1 : 3 , 1 : 3 ) * myPoly % iMatrix % hostData ( kk , k ) END DO END DO END DO END DO END DO END DO END SUBROUTINE TensorGridInterp_3D_cpu ! SUBROUTINE TensorGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev CALL TensorGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE TensorGridInterp_3D_gpu ! ================================================================================================ ! ! ! Derivative_1D ! !   Calculates the derivative of the Lagrange interpolant given a set of nodal function values at !   the native interpolation nodes ! !   Given a set of nodal values at the interpolation nodes, the derivative of a function through !   the interpolation nodes can be estimated by ! !                       f'_a = \\sum_{i=0}&#94;N f_{i} l'_i(\\xi_a),   a=0,1,2,...,N ! !   where l_i(\\xi) are the Lagrange interpolating polynomials through the interpolation points. !   The derivative matrix is D_{a,i} = l'_i(\\xi_a) maps an array of nodal values at the interpolation !   nodes to its estimated derivative. This routine serves as a wrapper to call either the CUDA !   kernel (if CUDA is enabled) or the CPU version. ! !   Usage : ! !     TYPE(Lagrange) :: interp !     INTEGER        :: nVariables, nElements !     REAL(prec)     :: f(0:interp % N,1:nVariables,1:nElements) !     REAL(prec)     :: derF(0:interp % N,1:nVariables,1:nElements) ! !       CALL interp % Derivative_1D( f, derF, nVariables, nElements ) ! !     * If CUDA is enabled, the fnative and ftarget arrays must be CUDA device variables. ! !   Parameters : ! !     interp (in) !       A previously constructed Lagrange data-structure. ! !     f (in) !       Array of function nodal values at the native interpolation nodes. ! !     nVariables (in) ! !     nElements (in) ! !     derF (out) !      Array of derivative values at the target interpolation nodes. ! ! ================================================================================================ ! SUBROUTINE Derivative_1D_cpu ( myPoly , f , df , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: df ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N df ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO END DO END DO END DO END SUBROUTINE Derivative_1D_cpu SUBROUTINE Derivative_1D_gpu ( myPoly , f_dev , df_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: df_dev CALL Derivative_1D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , df_dev , & myPoly % N , & nVariables , nElements ) END SUBROUTINE Derivative_1D_gpu SUBROUTINE DGDerivative_1D_cpu ( myPoly , f , bf , df , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : nVariables , 1 : 2 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: df ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N ! Interior Derivative Matrix Application df ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO ! Boundary Contribution df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + ( bf ( iVar , 2 , iEl ) * myPoly % bMatrix % hostData ( i , 1 ) - & bf ( iVar , 1 , iEl ) * myPoly % bMatrix % hostData ( i , 0 )) / & myPoly % qWeights % hostData ( i ) END DO END DO END DO END SUBROUTINE DGDerivative_1D_cpu SUBROUTINE DGDerivative_1D_gpu ( myPoly , f_dev , bf_dev , df_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: df_dev CALL DGDerivative_1D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bf_dev , df_dev , & myPoly % N , & nVariables , nElements ) END SUBROUTINE DGDerivative_1D_gpu ! ================================================================================================ ! ! ! CalculateGradient_2D ! !   Calculates the gradient of a 2-D function, represented by a 2-D array of nodal values. ! !   Given a set of nodal values at the interpolation nodes, the gradient of a function through !   the interpolation nodes can be estimated by ! !                       (df/dx)_{a,b} = \\sum_{i=0}&#94;N f_{i,b} l'_i(\\xi_a),   a,b=0,1,2,...,N !                       (df/dy)_{a,b} = \\sum_{j=0}&#94;N f_{a,j} l'_j(\\xi_b),   a,b=0,1,2,...,N ! !   where l_i(\\xi) are the Lagrange interpolating polynomials through the interpolation points. !   The derivative matrix is D_{a,i} = l'_i(\\xi_a) maps an array of nodal values at the interpolation !   nodes to its estimated derivative. This routine serves as a wrapper to call either the CUDA !   kernel (if CUDA is enabled) or the CPU version. ! !   Usage : ! !     TYPE(Lagrange) :: interp !     INTEGER        :: nVariables, nElements !     REAL(prec)     :: f(0:interp % N,0:interp % N,1:nVariables,1:nElements) !     REAL(prec)     :: gradF(1:2,0:interp % N,0:interp % N,1:nVariables,1:nElements) ! !       CALL interp % CalculateGradient_2D( f, gradF, nVariables, nElements ) ! !     * If CUDA is enabled, the fnative and ftarget arrays must be CUDA device variables. ! !   Parameters : ! !     interp (in) !       A previously constructed Lagrange data-structure. ! !     f (in) !       Array of function nodal values at the native interpolation nodes. ! !     nVariables (in) ! !     nElements (in) ! !     gradF (out) !      Array of derivative values at the target interpolation nodes. ! ! ================================================================================================ ! ! SUBROUTINE ScalarGradient_2D_cpu ( myPoly , f , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = gradF ( 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , j , iVar , iEl ) gradF ( 2 , i , j , iVar , iEl ) = gradF ( 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE ScalarGradient_2D_cpu SUBROUTINE ScalarGradient_2D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL ScalarGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE ScalarGradient_2D_gpu ! ! SUBROUTINE ScalarDGGradient_2D_cpu ( myPoly , f , bf , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = gradF ( 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( ii , j , iVar , iEl ) gradF ( 2 , i , j , iVar , iEl ) = gradF ( 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , j ) * f ( i , ii , iVar , iEl ) END DO ! Boundary Contribution gradF ( 1 , i , j , iVar , iEl ) = gradF ( 1 , i , j , iVar , iEl ) + ( bf ( j , iVar , 2 , iEl ) * myPoly % bMatrix % hostData ( i , 1 ) + & bf ( j , iVar , 4 , iEl ) * myPoly % bMatrix % hostData ( i , 0 )) / & myPoly % qWeights % hostData ( i ) gradF ( 2 , i , j , iVar , iEl ) = gradF ( 2 , i , j , iVar , iEl ) + ( bf ( i , iVar , 3 , iEl ) * myPoly % bMatrix % hostData ( j , 1 ) + & bf ( i , iVar , 1 , iEl ) * myPoly % bMatrix % hostData ( j , 0 )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE ScalarDGGradient_2D_cpu SUBROUTINE ScalarDGGradient_2D_gpu ( myPoly , f_dev , bf_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL ScalarDGGradient_2D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bf_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE ScalarDGGradient_2D_gpu SUBROUTINE VectorGradient_2D_cpu ( myPoly , f , gradF , nVariables , nElements ) ! ! Input : Vector(1:2,...) ! Output : Tensor(1:2,1:2,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 1 , 2 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = gradF ( 1 , 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) gradF ( 2 , 1 , i , j , iVar , iEl ) = gradF ( 2 , 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , iVar , iEl ) gradF ( 1 , 2 , i , j , iVar , iEl ) = gradF ( 1 , 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , iVar , iEl ) gradF ( 2 , 2 , i , j , iVar , iEl ) = gradF ( 2 , 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE VectorGradient_2D_cpu SUBROUTINE VectorGradient_2D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL VectorGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorGradient_2D_gpu SUBROUTINE VectorDGGradient_2D_cpu ( myPoly , f , bf , gradF , nVariables , nElements ) ! ! Input : Vector(1:2,...) ! Output : Tensor(1:2,1:2,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 1 , 2 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = gradF ( 1 , 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) gradF ( 2 , 1 , i , j , iVar , iEl ) = gradF ( 2 , 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 2 , ii , j , iVar , iEl ) gradF ( 1 , 2 , i , j , iVar , iEl ) = gradF ( 1 , 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , j ) * f ( 1 , i , ii , iVar , iEl ) gradF ( 2 , 2 , i , j , iVar , iEl ) = gradF ( 2 , 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO gradF ( 1 , 1 , i , j , iVar , iEl ) = gradF ( 1 , 1 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 1 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 1 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) gradF ( 2 , 1 , i , j , iVar , iEl ) = gradF ( 2 , 1 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 2 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 2 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) gradF ( 1 , 2 , i , j , iVar , iEl ) = gradF ( 1 , 2 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 1 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 1 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) gradF ( 2 , 2 , i , j , iVar , iEl ) = gradF ( 2 , 2 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 2 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 2 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE VectorDGGradient_2D_cpu SUBROUTINE VectorDGGradient_2D_gpu ( myPoly , f_dev , bf_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL VectorDGGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bf_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDGGradient_2D_gpu SUBROUTINE VectorDivergence_2D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE VectorDivergence_2D_cpu SUBROUTINE VectorDivergence_2D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDivergence_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDivergence_2D_gpu SUBROUTINE VectorDGDivergence_2D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Assumes bF is the vector component in the direction normal to the boundary IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bF ( 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bF ( j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bF ( i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE VectorDGDivergence_2D_cpu SUBROUTINE VectorDGDivergence_2D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDGDivergence_2D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDGDivergence_2D_gpu SUBROUTINE VectorCurl_2D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE VectorCurl_2D_cpu SUBROUTINE VectorCurl_2D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorCurl_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorCurl_2D_gpu SUBROUTINE TensorDivergence_2D_cpu ( myPoly , f , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = dF ( 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , iVar , iEl ) dF ( 2 , i , j , iVar , iEl ) = dF ( 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE TensorDivergence_2D_cpu SUBROUTINE TensorDivergence_2D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL TensorDivergence_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE TensorDivergence_2D_gpu SUBROUTINE TensorDGDivergence_2D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = dF ( 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , iVar , iEl ) dF ( 2 , i , j , iVar , iEl ) = dF ( 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , iVar , iEl ) END DO dF ( 1 , i , j , iVar , iEl ) = dF ( 1 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 1 , 1 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 1 , 1 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 2 , 1 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 2 , 1 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) dF ( 2 , i , j , iVar , iEl ) = dF ( 2 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 1 , 2 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 1 , 2 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 2 , 2 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 2 , 2 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE TensorDGDivergence_2D_cpu SUBROUTINE TensorDGDivergence_2D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL TensorDGDivergence_2D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE TensorDGDivergence_2D_gpu SUBROUTINE ScalarGradient_3D_cpu ( myPoly , f , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , i , j , k , iVar , iEl ) = gradF ( 1 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , j , k , iVar , iEl ) gradF ( 2 , i , j , k , iVar , iEl ) = gradF ( 2 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( i , ii , k , iVar , iEl ) gradF ( 3 , i , j , k , iVar , iEl ) = gradF ( 3 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , k ) * f ( i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE ScalarGradient_3D_cpu SUBROUTINE ScalarGradient_3D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL ScalarGradient_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE ScalarGradient_3D_gpu ! SUBROUTINE VectorGradient_3D_cpu ( myPoly , f , gradF , nVariables , nElements ) ! ! Input : Vector(1:3,...) ! Output : Tensor(1:3,1:3,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(3,1) = d/ds1( Vector(3,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) !          > Tensor(3,2) = d/ds2( Vector(3,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 1 , 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 1 , 3 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , 3 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , 1 , i , j , k , iVar , iEl ) = gradF ( 1 , 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) gradF ( 2 , 1 , i , j , k , iVar , iEl ) = gradF ( 2 , 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , k , iVar , iEl ) gradF ( 3 , 1 , i , j , k , iVar , iEl ) = gradF ( 3 , 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 3 , ii , j , k , iVar , iEl ) gradF ( 1 , 2 , i , j , k , iVar , iEl ) = gradF ( 1 , 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , k , iVar , iEl ) gradF ( 2 , 2 , i , j , k , iVar , iEl ) = gradF ( 2 , 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) gradF ( 3 , 2 , i , j , k , iVar , iEl ) = gradF ( 3 , 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 3 , i , ii , k , iVar , iEl ) gradF ( 1 , 3 , i , j , k , iVar , iEl ) = gradF ( 1 , 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 1 , i , j , ii , iVar , iEl ) gradF ( 2 , 3 , i , j , k , iVar , iEl ) = gradF ( 2 , 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 2 , i , j , ii , iVar , iEl ) gradF ( 3 , 3 , i , j , k , iVar , iEl ) = gradF ( 3 , 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorGradient_3D_cpu SUBROUTINE VectorGradient_3D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL VectorGradient_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorGradient_3D_gpu SUBROUTINE VectorDivergence_3D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorDivergence_3D_cpu SUBROUTINE VectorDivergence_3D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDivergence_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDivergence_3D_gpu SUBROUTINE VectorDGDivergence_3D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Assumes bF is the vector component in the direction normal to the element boundaries IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) END DO END DO END DO END DO END DO END SUBROUTINE VectorDGDivergence_3D_cpu SUBROUTINE VectorDGDivergence_3D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDGDivergence_3D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDGDivergence_3D_gpu SUBROUTINE VectorCurl_3D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 3 , i , ii , k , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , k ) * f ( 2 , i , j , ii , iVar , iEl ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , k ) * f ( 1 , i , j , ii , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , i ) * f ( 3 , ii , j , k , iVar , iEl ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , k , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , k , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorCurl_3D_cpu SUBROUTINE VectorCurl_3D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorCurl_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorCurl_3D_gpu SUBROUTINE TensorDivergence_3D_cpu ( myPoly , f , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , 1 , i , j , ii , iVar , iEl ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , 2 , i , j , ii , iVar , iEl ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 3 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 3 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , 3 , i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE TensorDivergence_3D_cpu SUBROUTINE TensorDivergence_3D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL TensorDivergence_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE TensorDivergence_3D_gpu SUBROUTINE TensorDGDivergence_3D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bF ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , 1 , i , j , ii , iVar , iEl ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , 2 , i , j , ii , iVar , iEl ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 3 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 3 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , 3 , i , j , ii , iVar , iEl ) END DO dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , 1 , j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , 1 , j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , 1 , i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , 1 , i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( 3 , 1 , i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( 3 , 1 , i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , 2 , j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , 2 , j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , 2 , i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , 2 , i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( 3 , 2 , i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( 3 , 2 , i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , 3 , j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , 3 , j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , 3 , i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , 3 , i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( 3 , 3 , i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( 3 , 3 , i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) END DO END DO END DO END DO END DO END SUBROUTINE TensorDGDivergence_3D_cpu SUBROUTINE TensorDGDivergence_3D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL TensorDGDivergence_3D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE TensorDGDivergence_3D_gpu ! /////////////////////////////// ! ! Boundary Interpolation Routines ! SUBROUTINE ScalarBoundaryInterp_1D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : nVariables , 1 : 2 , 1 : nElements ) ! Local INTEGER :: ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables fb ( 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , iVar , iEl ) ! West fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , iVar , iEl ) ! East END DO fBound ( iVar , 1 : 2 , iEl ) = fb ( 1 : 2 ) END DO END DO END SUBROUTINE ScalarBoundaryInterp_1D_cpu SUBROUTINE ScalarBoundaryInterp_1D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL ScalarBoundaryInterp_1D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE ScalarBoundaryInterp_1D_gpu SUBROUTINE ScalarBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , ii , iVar , iEl ) ! South fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , i , iVar , iEl ) ! East fb ( 3 ) = fb ( 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , ii , iVar , iEl ) ! North fb ( 4 ) = fb ( 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , i , iVar , iEl ) ! West END DO fBound ( i , iVar , 1 : 4 , iEl ) = fb ( 1 : 4 ) END DO END DO END DO END SUBROUTINE ScalarBoundaryInterp_2D_cpu SUBROUTINE ScalarBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL ScalarBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE ScalarBoundaryInterp_2D_gpu SUBROUTINE VectorBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , ii , idir , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 , 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 2 , 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N DO idir = 1 , 2 fb ( idir , 1 ) = fb ( idir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , ii , iVar , iEl ) ! South fb ( idir , 2 ) = fb ( idir , 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , ii , i , iVar , iEl ) ! East fb ( idir , 3 ) = fb ( idir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , ii , iVar , iEl ) ! North fb ( idir , 4 ) = fb ( idir , 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , ii , i , iVar , iEl ) ! West END DO END DO DO idir = 1 , 2 fBound ( idir , i , iVar , 1 : 4 , iEl ) = fb ( idir , 1 : 4 ) END DO END DO END DO END DO END SUBROUTINE VectorBoundaryInterp_2D_cpu SUBROUTINE VectorBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL VectorBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE VectorBoundaryInterp_2D_gpu SUBROUTINE TensorBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , ii , idir , jdir , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 , 1 : 2 , 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 2 , 1 : 2 , 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N DO jdir = 1 , 2 DO idir = 1 , 2 fb ( idir , jdir , 1 ) = fb ( idir , jdir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , ii , iVar , iEl ) ! South fb ( idir , jdir , 2 ) = fb ( idir , jdir , 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , ii , i , iVar , iEl ) ! East fb ( idir , jdir , 3 ) = fb ( idir , jdir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , ii , iVar , iEl ) ! North fb ( idir , jdir , 4 ) = fb ( idir , jdir , 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , ii , i , iVar , iEl ) ! West END DO END DO END DO DO jdir = 1 , 2 DO idir = 1 , 2 fBound ( idir , jdir , i , iVar , 1 : 4 , iEl ) = fb ( idir , jdir , 1 : 4 ) END DO END DO END DO END DO END DO END SUBROUTINE TensorBoundaryInterp_2D_cpu SUBROUTINE TensorBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL TensorBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE TensorBoundaryInterp_2D_gpu SUBROUTINE ScalarBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , j , ii , iVar , iEl ) ! Bottom fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , ii , j , iVar , iEl ) ! South fb ( 3 ) = fb ( 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , i , j , iVar , iEl ) ! East fb ( 4 ) = fb ( 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , ii , j , iVar , iEl ) ! North fb ( 5 ) = fb ( 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , i , j , iVar , iEl ) ! West fb ( 6 ) = fb ( 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , j , ii , iVar , iEl ) ! Top END DO fBound ( i , j , iVar , 1 : 6 , iEl ) = fb ( 1 : 6 ) END DO END DO END DO END DO END SUBROUTINE ScalarBoundaryInterp_3D_cpu SUBROUTINE ScalarBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL ScalarBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE ScalarBoundaryInterp_3D_gpu SUBROUTINE VectorBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , iVar , iEl REAL ( prec ) :: fb ( 1 : 3 , 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 3 , 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N DO idir = 1 , 3 fb ( idir , 1 ) = fb ( idir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , j , ii , iVar , iEl ) ! Bottom fb ( idir , 2 ) = fb ( idir , 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , ii , j , iVar , iEl ) ! South fb ( idir , 3 ) = fb ( idir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , ii , i , j , iVar , iEl ) ! East fb ( idir , 4 ) = fb ( idir , 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , ii , j , iVar , iEl ) ! North fb ( idir , 5 ) = fb ( idir , 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , ii , i , j , iVar , iEl ) ! West fb ( idir , 6 ) = fb ( idir , 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , j , ii , iVar , iEl ) ! Top END DO END DO DO idir = 1 , 3 fBound ( idir , i , j , iVar , 1 : 6 , iEl ) = fb ( idir , 1 : 6 ) END DO END DO END DO END DO END DO END SUBROUTINE VectorBoundaryInterp_3D_cpu SUBROUTINE VectorBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL VectorBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE VectorBoundaryInterp_3D_gpu SUBROUTINE TensorBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , jdir , iVar , iEl REAL ( prec ) :: fb ( 1 : 3 , 1 : 3 , 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 3 , 1 : 3 , 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N DO jdir = 1 , 3 DO idir = 1 , 3 fb ( idir , jdir , 1 ) = fb ( idir , jdir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , j , ii , iVar , iEl ) ! Bottom fb ( idir , jdir , 2 ) = fb ( idir , jdir , 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , ii , j , iVar , iEl ) ! South fb ( idir , jdir , 3 ) = fb ( idir , jdir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , ii , i , j , iVar , iEl ) ! East fb ( idir , jdir , 4 ) = fb ( idir , jdir , 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , ii , j , iVar , iEl ) ! North fb ( idir , jdir , 5 ) = fb ( idir , jdir , 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , ii , i , j , iVar , iEl ) ! West fb ( idir , jdir , 6 ) = fb ( idir , jdir , 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , j , ii , iVar , iEl ) ! Top END DO END DO END DO DO jdir = 1 , 3 DO idir = 1 , 3 fBound ( idir , jdir , i , j , iVar , 1 : 6 , iEl ) = fb ( idir , jdir , 1 : 6 ) END DO END DO END DO END DO END DO END DO END SUBROUTINE TensorBoundaryInterp_3D_cpu SUBROUTINE TensorBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL TensorBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE TensorBoundaryInterp_3D_gpu ! ================================================================================================ ! ! ! CalculateBarycentricWeights (PRIVATE) ! !   A PRIVATE routine that calculates and stores the barycentric weights for the Lagrange !   data-structure. ! !   This routine is from Alg. 30 on pg. 75 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! SUBROUTINE CalculateBarycentricWeights ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: i , j REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) DO i = 0 , myPoly % N bWeights ( i ) = 1.0_real64 controlPoints ( i ) = REAL ( myPoly % controlPoints % hostData ( i ), real64 ) END DO ! Computes the product w_k = w_k*(s_k - s_j), k /= j DO j = 1 , myPoly % N DO i = 0 , j - 1 bWeights ( i ) = bWeights ( i ) * ( controlPoints ( i ) - controlPoints ( j )) bWeights ( j ) = bWeights ( j ) * ( controlPoints ( j ) - controlPoints ( i )) END DO END DO DO j = 0 , myPoly % N bWeights ( j ) = 1.0_prec / bWeights ( j ) myPoly % bWeights % hostData ( j ) = REAL ( bWeights ( j ), prec ) END DO END SUBROUTINE CalculateBarycentricWeights ! ================================================================================================ ! ! ! CalculateInterpolationMatrix (PRIVATE) ! !   A PRIVATE routine that fills in the interpolation matrix for the Lagrange data structure. ! !   This function is from Alg. 32 on pg. 76 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! SUBROUTINE CalculateInterpolationMatrix ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: row , col LOGICAL :: rowHasMatch REAL ( real64 ) :: temp1 , temp2 REAL ( real64 ) :: iMatrix ( 0 : myPoly % M , 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) REAL ( real64 ) :: targetPoints ( 0 : myPoly % M ) DO col = 0 , myPoly % N controlPoints ( col ) = REAL ( myPoly % controlPoints % hostData ( col ), real64 ) bWeights ( col ) = REAL ( myPoly % bWeights % hostData ( col ), real64 ) END DO DO row = 0 , myPoly % M targetPoints ( row ) = REAL ( myPoly % targetPoints % hostData ( row ), real64 ) END DO DO row = 0 , myPoly % M rowHasMatch = . FALSE . DO col = 0 , myPoly % N iMatrix ( row , col ) = 0.0_real64 IF ( AlmostEqual ( targetPoints ( row ), controlPoints ( col ))) THEN rowHasMatch = . TRUE . iMatrix ( row , col ) = 1.0_real64 END IF END DO IF (. NOT . ( rowHasMatch )) THEN temp1 = 0.0_real64 DO col = 0 , myPoly % N temp2 = bWeights ( col ) / & ( targetPoints ( row ) - & controlPoints ( col )) iMatrix ( row , col ) = temp2 temp1 = temp1 + temp2 END DO DO col = 0 , myPoly % N iMatrix ( row , col ) = iMatrix ( row , col ) / temp1 END DO END IF END DO DO row = 0 , myPoly % M DO col = 0 , myPoly % N myPoly % iMatrix % hostData ( col , row ) = REAL ( iMatrix ( row , col ), prec ) END DO END DO END SUBROUTINE CalculateInterpolationMatrix ! ================================================================================================ ! ! ! CalculateDerivativeMatrix (PRIVATE) ! !   Calculates and stores the derivative matrix and its transpose. !   Generates a matrix that can be used to approximate derivatives at the interpolation nodes. ! !   This function is from Alg. 37 on pg. 82 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! SUBROUTINE CalculateDerivativeMatrix ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: row , col REAL ( real64 ) :: dmat ( 0 : myPoly % N , 0 : myPoly % N ) REAL ( real64 ) :: dgmat ( 0 : myPoly % N , 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: qWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) DO row = 0 , myPoly % N bWeights ( row ) = REAL ( myPoly % bWeights % hostData ( row ), real64 ) qWeights ( row ) = REAL ( myPoly % qWeights % hostData ( row ), real64 ) controlPoints ( row ) = REAL ( myPoly % controlPoints % hostData ( row ), real64 ) END DO DO row = 0 , myPoly % N dmat ( row , row ) = 0.0_prec DO col = 0 , myPoly % N IF (. NOT . ( col == row )) THEN dmat ( row , col ) = bWeights ( col ) / & ( bWeights ( row ) * & ( controlPoints ( row ) - & controlPoints ( col ))) dmat ( row , row ) = dmat ( row , row ) - dmat ( row , col ) END IF END DO END DO DO row = 0 , myPoly % N DO col = 0 , myPoly % N dgmat ( row , col ) = - dmat ( col , row ) * & qWeights ( col ) / & qWeights ( row ) END DO END DO DO row = 0 , myPoly % N DO col = 0 , myPoly % N myPoly % dMatrix % hostData ( row , col ) = REAL ( dmat ( col , row ), prec ) myPoly % dgMatrix % hostData ( row , col ) = REAL ( dgmat ( col , row ), prec ) END DO END DO END SUBROUTINE CalculateDerivativeMatrix ! ================================================================================================ ! ! ! CalculateLagrangePolynomials ! !   Evaluates each of the 1-D Lagrange interpolating polynomials at a specified point. ! !   This function is from Alg. 34 on pg. 77 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! FUNCTION CalculateLagrangePolynomials ( myPoly , sE ) RESULT ( lAtS ) IMPLICIT NONE CLASS ( Lagrange ) :: myPoly REAL ( prec ) :: sE REAL ( prec ) :: lAtS ( 0 : myPoly % N ) ! Local INTEGER :: j LOGICAL :: xMatchesNode REAL ( real64 ) :: temp1 , temp2 REAL ( real64 ) :: sELocal REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: lS ( 0 : myPoly % N ) sELocal = REAL ( sE , real64 ) DO j = 0 , myPoly % N controlPoints ( j ) = REAL ( myPoly % controlPoints % hostData ( j ), real64 ) bWeights ( j ) = REAL ( myPoly % bWeights % hostData ( j ), real64 ) END DO xMatchesNode = . FALSE . DO j = 0 , myPoly % N lS ( j ) = 0.0_real64 IF ( AlmostEqual ( sELocal , controlPoints ( j ))) THEN lS ( j ) = 1.0_real64 xMatchesNode = . TRUE . END IF END DO IF ( xMatchesNode ) THEN RETURN END IF temp1 = 0.0_real64 DO j = 0 , myPoly % N temp2 = bWeights ( j ) / ( sE - controlPoints ( j )) lS ( j ) = temp2 temp1 = temp1 + temp2 END DO lS = lS / temp1 DO j = 0 , myPoly % N lAtS ( j ) = REAL ( lS ( j ), prec ) END DO END FUNCTION CalculateLagrangePolynomials END MODULE SELF_Lagrange","tags":"","loc":"sourcefile/self_lagrange.f90.html"},{"title":"sadv2d.f90 – SELF","text":"This file depends on sourcefile~~sadv2d.f90~~EfferentGraph sourcefile~sadv2d.f90 sadv2d.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~sadv2d.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~sadv2d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection2d.f90 SELF_Advection2D.f90 sourcefile~sadv2d.f90->sourcefile~self_advection2d.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_hdf5.f90 SELF_HDF5.f90 sourcefile~self_mesh.f90->sourcefile~self_hdf5.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_hashtable.f90 SELF_HashTable.f90 sourcefile~self_mesh.f90->sourcefile~self_hashtable.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mpi.f90 SELF_MPI.f90 sourcefile~self_mesh.f90->sourcefile~self_mpi.f90 sourcefile~self_advection2d.f90->sourcefile~self_constants.f90 sourcefile~self_advection2d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection2d.f90->sourcefile~self_supportroutines.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_advection2d.f90->sourcefile~self_dg.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_hdf5.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_hdf5.f90->sourcefile~self_memory.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 sourcefile~self_hashtable.f90->sourcefile~self_constants.f90 sourcefile~self_linkedlist.f90 SELF_LinkedList.f90 sourcefile~self_hashtable.f90->sourcefile~self_linkedlist.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_hdf5.f90 sourcefile~self_dg.f90->sourcefile~self_mpi.f90 sourcefile~self_metadata.f90 SELF_Metadata.f90 sourcefile~self_dg.f90->sourcefile~self_metadata.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_mpi.f90->sourcefile~self_constants.f90 sourcefile~self_mpi.f90->sourcefile~self_memory.f90 sourcefile~self_metadata.f90->sourcefile~self_hdf5.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_mappeddata.f90->sourcefile~self_constants.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mpi.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs sadv2d Source Code sadv2d.f90 Source Code PROGRAM sadv2d USE SELF_Advection2D USE SELF_Mesh USE FEQParse USE SELF_Constants TYPE ( Advection2D ) :: model INTEGER :: nDumps INTEGER :: i REAL ( prec ) :: endTime CALL model % InitFromCLI ( ) CALL model % WriteTecplot () nDumps = INT (( model % endTime - model % initialTime ) / ( model % outputInterval ) ) DO i = 1 , nDumps endTime = model % simulationTime + model % outputInterval CALL model % ForwardStep ( endTime ) CALL model % WriteTecplot () ENDDO CALL model % Free () END PROGRAM sadv2d","tags":"","loc":"sourcefile/sadv2d.f90.html"},{"title":"sadv3d.f90 – SELF","text":"This file depends on sourcefile~~sadv3d.f90~~EfferentGraph sourcefile~sadv3d.f90 sadv3d.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~sadv3d.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~sadv3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90 SELF_Advection3D.f90 sourcefile~sadv3d.f90->sourcefile~self_advection3d.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_hdf5.f90 SELF_HDF5.f90 sourcefile~self_mesh.f90->sourcefile~self_hdf5.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_hashtable.f90 SELF_HashTable.f90 sourcefile~self_mesh.f90->sourcefile~self_hashtable.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mpi.f90 SELF_MPI.f90 sourcefile~self_mesh.f90->sourcefile~self_mpi.f90 sourcefile~self_advection3d.f90->sourcefile~self_constants.f90 sourcefile~self_advection3d.f90->sourcefile~self_mesh.f90 sourcefile~self_advection3d.f90->sourcefile~self_supportroutines.f90 sourcefile~self_dg.f90 SELF_DG.f90 sourcefile~self_advection3d.f90->sourcefile~self_dg.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_hdf5.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_hdf5.f90->sourcefile~self_memory.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 sourcefile~self_hashtable.f90->sourcefile~self_constants.f90 sourcefile~self_linkedlist.f90 SELF_LinkedList.f90 sourcefile~self_hashtable.f90->sourcefile~self_linkedlist.f90 sourcefile~self_dg.f90->sourcefile~self_mesh.f90 sourcefile~self_dg.f90->sourcefile~self_hdf5.f90 sourcefile~self_dg.f90->sourcefile~self_mpi.f90 sourcefile~self_metadata.f90 SELF_Metadata.f90 sourcefile~self_dg.f90->sourcefile~self_metadata.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_dg.f90->sourcefile~self_mappeddata.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_mpi.f90->sourcefile~self_constants.f90 sourcefile~self_mpi.f90->sourcefile~self_memory.f90 sourcefile~self_metadata.f90->sourcefile~self_hdf5.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_mappeddata.f90->sourcefile~self_constants.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mpi.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs sadv3d Source Code sadv3d.f90 Source Code PROGRAM sadv3d USE SELF_Advection3D USE SELF_Mesh USE FEQParse USE SELF_Constants TYPE ( Advection3D ) :: model INTEGER :: nDumps INTEGER :: i REAL ( prec ) :: endTime CALL model % InitFromCLI ( ) CALL model % WriteTecplot () nDumps = INT (( model % endTime - model % initialTime ) / ( model % outputInterval ) ) DO i = 1 , nDumps endTime = model % simulationTime + model % outputInterval CALL model % ForwardStep ( endTime ) CALL model % WriteTecplot () ENDDO CALL model % Free () END PROGRAM sadv3d","tags":"","loc":"sourcefile/sadv3d.f90.html"},{"title":"SELF_Advection2D.cpp – SELF","text":"Contents Source Code SELF_Advection2D.cpp Source Code #include <hip/hip_runtime.h> #include \"SELF_HIP_Macros.h\" #include <cstdio> __global__ void UpdateGRK3_Advection2D_gpu ( real * gRK3 , real * solution , real * dSdt , real rk3A , real rk3G , real dt , int N , int nVar ){ // Get the array indices from the GPU thread IDs size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; gRK3 [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] = rk3A * gRK3 [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] + dSdt [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )]; solution [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] += rk3G * dt * gRK3 [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )]; } extern \"C\" { void UpdateGRK3_Advection2D_gpu_wrapper ( real ** gRK3 , real ** solution , real ** dSdt , real rk3A , real rk3G , real dt , int N , int nVar , int nEl ) { UpdateGRK3_Advection2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * gRK3 , * solution , * dSdt , rk3A , rk3G , dt , N , nVar ); } } __global__ void InternalFlux_Advection2D_gpu ( real * flux , real * solution , real * velocity , real * dsdx , int N , int nVar ){ // Get the array indices from the GPU thread IDs size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; real Fx = velocity [ VE_2D_INDEX ( 1 , i , j , 0 , iEl , N , 1 )] * solution [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )]; real Fy = velocity [ VE_2D_INDEX ( 2 , i , j , 0 , iEl , N , 1 )] * solution [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )]; // x-component of the advective flux flux [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] = dsdx [ TE_2D_INDEX ( 1 , 1 , i , j , 0 , iEl , N , 1 )] * Fx + dsdx [ TE_2D_INDEX ( 2 , 1 , i , j , 0 , iEl , N , 1 )] * Fy ; // y-component of the advective flux flux [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] = dsdx [ TE_2D_INDEX ( 1 , 2 , i , j , 0 , iEl , N , 1 )] * Fx + dsdx [ TE_2D_INDEX ( 2 , 2 , i , j , 0 , iEl , N , 1 )] * Fy ; } extern \"C\" { void InternalFlux_Advection2D_gpu_wrapper ( real ** flux , real ** solution , real ** velocity , real ** dsdx , int N , int nVar , int nEl ) { // Block size is set to match the size of the element exactly // Grid size is set to ( number of tracers X number of elements ) // DGSEM is beautiful InternalFlux_Advection2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * flux , * solution , * velocity , * dsdx , N , nVar ); } } __global__ void InternalDiffusiveFlux_Advection2D_gpu ( real * flux , real * solutionGradient , real * dsdx , real diffusivity , int N , int nVar ){ // Get the array indices from the GPU thread IDs size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; real Fx = diffusivity * solutionGradient [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )]; real Fy = diffusivity * solutionGradient [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )]; // xi-component of the advective flux flux [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] += - ( dsdx [ TE_2D_INDEX ( 1 , 1 , i , j , 0 , iEl , N , 1 )] * Fx + dsdx [ TE_2D_INDEX ( 2 , 1 , i , j , 0 , iEl , N , 1 )] * Fy ); // eta-component of the advective flux flux [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] += - ( dsdx [ TE_2D_INDEX ( 1 , 2 , i , j , 0 , iEl , N , 1 )] * Fx + dsdx [ TE_2D_INDEX ( 2 , 2 , i , j , 0 , iEl , N , 1 )] * Fy ); } extern \"C\" { void InternalDiffusiveFlux_Advection2D_gpu_wrapper ( real ** flux , real ** solutionGradient , real ** dsdx , real diffusivity , int N , int nVar , int nEl ) { // Block size is set to match the size of the element exactly // Grid size is set to ( number of tracers X number of elements ) // DGSEM is beautiful InternalDiffusiveFlux_Advection2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * flux , * solutionGradient , * dsdx , diffusivity , N , nVar ); } } __global__ void SideFlux_Advection2D_gpu ( real * flux , real * boundarySol , real * extSol , real * velocity , real * nhat , real * nscale , int N , int nVar ){ // Get the array indices from the GPU thread IDs size_t iVar = blockIdx . x ; size_t iSide = blockIdx . y + 1 ; size_t iEl = blockIdx . z ; size_t i = threadIdx . x ; // Calculate the normal velocity at the cell sides/edges float un = velocity [ VEB_2D_INDEX ( 1 , i , 0 , iSide , iEl , N , 1 )] * nhat [ VEB_2D_INDEX ( 1 , i , 0 , iSide , iEl , N , 1 )] + velocity [ VEB_2D_INDEX ( 2 , i , 0 , iSide , iEl , N , 1 )] * nhat [ VEB_2D_INDEX ( 2 , i , 0 , iSide , iEl , N , 1 )]; // Get the external and internal states for the Riemann solver float extState = extSol [ SCB_2D_INDEX ( i , iVar , iSide , iEl , N , nVar )]; float intState = boundarySol [ SCB_2D_INDEX ( i , iVar , iSide , iEl , N , nVar )]; float nmag = nscale [ SCB_2D_INDEX ( i , 0 , iSide , iEl , N , 1 )]; // Calculate the normal flux at the cell sides/edges flux [ SCB_2D_INDEX ( i , iVar , iSide , iEl , N , nVar )] = 0.5 * ( un * ( intState + extState ) - fabs ( un ) * ( extState - intState ) ) * nmag ; } extern \"C\" { void SideFlux_Advection2D_gpu_wrapper ( real ** flux , real ** boundarySol , real ** extSol , real ** velocity , real ** nhat , real ** nscale , int N , int nVar , int nEl ) { // Block size is set to match the size of the element exactly // Grid size is set to ( number of tracers X number of elements ) // DGSEM is beautiful SideFlux_Advection2D_gpu <<< dim3 ( nVar , 4 , nEl ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 >>> ( * flux , * boundarySol , * extSol , * velocity , * nhat , * nscale , N , nVar ); } } __global__ void SideDiffusiveFlux_Advection2D_gpu ( real * flux , real * boundarySolGrad , real * extSolGrad , real * nhat , real * nscale , real diffusivity , int N , int nVar ){ // Get the array indices from the GPU thread IDs size_t iVar = blockIdx . x ; size_t iSide = blockIdx . y + 1 ; size_t iEl = blockIdx . z ; size_t i = threadIdx . x ; float extState = extSolGrad [ VEB_2D_INDEX ( 1 , i , iVar , iSide , iEl , N , nVar )] * nhat [ VEB_2D_INDEX ( 1 , i , 0 , iSide , iEl , N , 1 )] + extSolGrad [ VEB_2D_INDEX ( 2 , i , iVar , iSide , iEl , N , nVar )] * nhat [ VEB_2D_INDEX ( 2 , i , 0 , iSide , iEl , N , 1 )]; float intState = boundarySolGrad [ VEB_2D_INDEX ( 1 , i , iVar , iSide , iEl , N , nVar )] * nhat [ VEB_2D_INDEX ( 1 , i , 0 , iSide , iEl , N , 1 )] + boundarySolGrad [ VEB_2D_INDEX ( 2 , i , iVar , iSide , iEl , N , nVar )] * nhat [ VEB_2D_INDEX ( 2 , i , 0 , iSide , iEl , N , 1 )]; float nmag = nscale [ SCB_2D_INDEX ( i , 0 , iSide , iEl , N , 1 )]; // Calculate the normal flux at the cell sides/edges flux [ SCB_2D_INDEX ( i , iVar , iSide , iEl , N , nVar )] += -0.5 * diffusivity * ( intState + extState ) * nmag ; } extern \"C\" { void SideDiffusiveFlux_Advection2D_gpu_wrapper ( real ** flux , real ** boundarySolGrad , real ** extSolGrad , real ** nhat , real ** nscale , real diffusivity , int N , int nVar , int nEl ) { SideDiffusiveFlux_Advection2D_gpu <<< dim3 ( nVar , 4 , nEl ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 >>> ( * flux , * boundarySolGrad , * extSolGrad , * nhat , * nscale , diffusivity , N , nVar ); } }","tags":"","loc":"sourcefile/self_advection2d.cpp.html"},{"title":"SELF_Data.cpp – SELF","text":"Contents Source Code SELF_Data.cpp Source Code #include <hip/hip_runtime.h> #include \"SELF_HIP_Macros.h\" /* // Template __global__ void Template_{1D|2D|3D}_gpu( , int N, int nVar){ size_t iVar = blockIdx.x; size_t iEl = blockIdx.y; size_t i = threadIdx.x; size_t j = threadIdx.y; size_t k = threadIdx.z; // How to access scalars f[SC_1D_INDEX(i,iVar,iEl,N,nVar)]; f[SC_2D_INDEX(i,j,iVar,iEl,N,nVar)]; f[SC_3D_INDEX(i,j,k,iVar,iEl,N,nVar)]; // How to access vectors (2d) f[VE_2D_INDEX(1,i,j,iVar,iEl,N,nVar)]; f[VE_2D_INDEX(2,i,j,iVar,iEl,N,nVar)]; // How to access vectors (3d) f[VE_3D_INDEX(1,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(2,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(3,i,j,k,iVar,iEl,N,nVar)]; // How to access tensors (2d) f[TE_2D_INDEX(1,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(1,2,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,2,i,j,iVar,iEl,N,nVar)]; // How to access tensors (3d) f[TE_3D_INDEX(1,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,3,i,j,k,iVar,iEl,N,nVar)]; } extern \"C\" { void Template_{1D|2D|3D}_gpu_wrapper(int N, int nVar) { hipLaunchKernelGGL((Template_{1D|2D|3D}_gpu), dim3(nVar,nEl,1), dim3(N+1,N+1,N+1), 0, 0,  N, M, nVar); } } */ __global__ void Determinant_Tensor2D_gpu ( real * tensor , real * detTensor , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; detTensor [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] = tensor [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , N , nVar )] * tensor [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , N , nVar )] - tensor [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )] * tensor [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )]; } extern \"C\" { void Determinant_Tensor2D_gpu_wrapper ( real ** tensor , real ** detTensor , int N , int nVar , int nEl ) { Determinant_Tensor2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * tensor , * detTensor , N , nVar ); } } __global__ void Determinant_Tensor3D_gpu ( real * tensor , real * detTensor , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; detTensor [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 1 , 1 , i , j , k , iVar , iEl , N , nVar )] * ( tensor [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , N , nVar )] * tensor [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , N , nVar )] - tensor [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )] * tensor [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )]) - tensor [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , N , nVar )] * ( tensor [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )] * tensor [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , N , nVar )] - tensor [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] * tensor [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )]) + tensor [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , N , nVar )] * ( tensor [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )] * tensor [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )] - tensor [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] * tensor [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , N , nVar )]); } extern \"C\" { void Determinant_Tensor3D_gpu_wrapper ( real ** tensor , real ** detTensor , int N , int nVar , int nEl ) { Determinant_Tensor3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * tensor , * detTensor , N , nVar ); } }","tags":"","loc":"sourcefile/self_data.cpp.html"},{"title":"SELF_Geometry.cpp – SELF","text":"Contents Source Code SELF_Geometry.cpp Source Code #include <hip/hip_runtime.h> #include <math.h> #include \"SELF_HIP_Macros.h\" /* // Template __global__ void Template_{1D|2D|3D}_gpu( , int N, int nVar){ size_t iVar = blockIdx.x; size_t iEl = blockIdx.y; size_t i = threadIdx.x; size_t j = threadIdx.y; size_t k = threadIdx.z; // How to access scalars f[SC_1D_INDEX(i,iVar,iEl,N,nVar)]; f[SC_2D_INDEX(i,j,iVar,iEl,N,nVar)]; f[SC_3D_INDEX(i,j,k,iVar,iEl,N,nVar)]; // How to access vectors (2d) f[VE_2D_INDEX(1,i,j,iVar,iEl,N,nVar)]; f[VE_2D_INDEX(2,i,j,iVar,iEl,N,nVar)]; // How to access vectors (3d) f[VE_3D_INDEX(1,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(2,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(3,i,j,k,iVar,iEl,N,nVar)]; // How to access tensors (2d) f[TE_2D_INDEX(1,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(1,2,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,2,i,j,iVar,iEl,N,nVar)]; // How to access tensors (3d) f[TE_3D_INDEX(1,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,3,i,j,k,iVar,iEl,N,nVar)]; } extern \"C\" { void Template_{1D|2D|3D}_gpu_wrapper(int N, int nVar) { hipLaunchKernelGGL((Template_{1D|2D|3D}_gpu), dim3(nVar,nEl,1), dim3(N+1,N+1,N+1), 0, 0,  N, M, nVar); } } */ /* __global__ void CalculateContravariantBasis_SEMQuad_gpu(real *scalar, real *dxds, int N, int nVar){ size_t iVar = blockIdx.x; size_t iEl = blockIdx.y; size_t i = threadIdx.x; size_t j = threadIdx.y; scalar[SC_1D_INDEX(i,iVar,iEl,N,nVar)] = scalar[SC_1D_INDEX(i,iVar,iEl,N,nVar)]/ dxds[SC_1D_INDEX(i,0,iEl,N,1)]; } extern \"C\" { void CalculateContravariantBasis_SEMQuad_gpu_wrapper(int N, int nVar) { hipLaunchKernelGGL((CalculateContravariantBasis_SEMQuad_gpu), dim3(nVar,nEl,1), dim3(N+1,N+1,1), 0, 0,  N); } } */ __global__ void CalculateContravariantBasis_SEMQuad_gpu ( real * dxds , real * dsdx , int N ){ size_t iEl = blockIdx . x ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; // Ja1 dsdx [ TE_2D_INDEX ( 1 , 1 , i , j , 0 , iEl , N , 1 )] = dxds [ TE_2D_INDEX ( 2 , 2 , i , j , 0 , iEl , N , 1 )]; dsdx [ TE_2D_INDEX ( 2 , 1 , i , j , 0 , iEl , N , 1 )] = - dxds [ TE_2D_INDEX ( 1 , 2 , i , j , 0 , iEl , N , 1 )]; // Ja2 dsdx [ TE_2D_INDEX ( 1 , 2 , i , j , 0 , iEl , N , 1 )] = - dxds [ TE_2D_INDEX ( 2 , 1 , i , j , 0 , iEl , N , 1 )]; dsdx [ TE_2D_INDEX ( 2 , 2 , i , j , 0 , iEl , N , 1 )] = dxds [ TE_2D_INDEX ( 1 , 1 , i , j , 0 , iEl , N , 1 )]; } extern \"C\" { void CalculateContravariantBasis_SEMQuad_gpu_wrapper ( real ** dxds , real ** dsdx , int N , int nEl ) { CalculateContravariantBasis_SEMQuad_gpu <<< dim3 ( nEl , 1 , 1 ), dim3 ( N + 1 , N + 1 ), 0 , 0 >>> ( * dxds , * dsdx , N ); } } __global__ void AdjustBoundaryContravariantBasis_SEMQuad_gpu ( real * dsdx , real * J , int N ){ size_t iSide = blockIdx . x + 1 ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; real fac = fabs ( J [ SCB_2D_INDEX ( i , iSide , 0 , iEl , N , 1 )]) / J [ SCB_2D_INDEX ( i , iSide , 0 , iEl , N , 1 )]; if ( iSide == 4 || iSide == 1 ){ fac = - fac ; } for ( int row = 1 ; row <= 2 ; row ++ ){ for ( int col = 1 ; col <= 2 ; col ++ ){ dsdx [ TEB_2D_INDEX ( row , col , i , 0 , iSide , iEl , N , 1 )] = fac * dsdx [ TEB_2D_INDEX ( row , col , i , 0 , iSide , iEl , N , 1 )]; } } } extern \"C\" { void AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper ( real ** dsdx , real ** J , int N , int nEl ) { AdjustBoundaryContravariantBasis_SEMQuad_gpu <<< dim3 ( 4 , nEl , 1 ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 >>> ( * dsdx , * J , N ); } } __global__ void CalculateContravariantBasis_SEMHex_gpu ( real * dxds , real * dsdx , int N ){ size_t iEl = blockIdx . x ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; // Ja1 dsdx [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )]; dsdx [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )]; dsdx [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )]; // Ja2 dsdx [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )]; dsdx [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )]; dsdx [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )]; // Ja3 dsdx [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )]; dsdx [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )]; dsdx [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )]; } extern \"C\" { void CalculateContravariantBasis_SEMHex_gpu_wrapper ( real ** dxds , real ** dsdx , int N , int nEl ) { CalculateContravariantBasis_SEMHex_gpu <<< dim3 ( nEl , 1 , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * dxds , * dsdx , N ); } } __global__ void AdjustBoundaryContravariantBasis_SEMHex_gpu ( real * dsdx , real * J , int N ){ size_t iSide = blockIdx . x + 1 ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; real fac = fabs ( J [ SCB_3D_INDEX ( i , j , iSide , 0 , iEl , N , 1 )]) / J [ SCB_3D_INDEX ( i , j , iSide , 0 , iEl , N , 1 )]; if ( iSide == 5 || iSide == 1 || iSide == 2 ){ fac = - fac ; } for ( int row = 1 ; row <= 3 ; row ++ ){ for ( int col = 1 ; col <= 3 ; col ++ ){ dsdx [ TEB_3D_INDEX ( row , col , i , j , 0 , iSide , iEl , N , 1 )] = fac * dsdx [ TEB_3D_INDEX ( row , col , i , j , 0 , iSide , iEl , N , 1 )]; } } } extern \"C\" { void AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper ( real ** dsdx , real ** J , int N , int nEl ) { AdjustBoundaryContravariantBasis_SEMHex_gpu <<< dim3 ( 6 , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * dsdx , * J , N ); } }","tags":"","loc":"sourcefile/self_geometry.cpp.html"},{"title":"SELF_MappedData.cpp – SELF","text":"Contents Source Code SELF_MappedData.cpp Source Code #include <hip/hip_runtime.h> #include \"SELF_HIP_Macros.h\" /* // Template __global__ void Template_{1D|2D|3D}_gpu( , int N, int nVar){ size_t iVar = blockIdx.x; size_t iEl = blockIdx.y; size_t i = threadIdx.x; size_t j = threadIdx.y; size_t k = threadIdx.z; // How to access scalars f[SC_1D_INDEX(i,iVar,iEl,N,nVar)]; f[SC_2D_INDEX(i,j,iVar,iEl,N,nVar)]; f[SC_3D_INDEX(i,j,k,iVar,iEl,N,nVar)]; // How to access vectors (2d) f[VE_2D_INDEX(1,i,j,iVar,iEl,N,nVar)]; f[VE_2D_INDEX(2,i,j,iVar,iEl,N,nVar)]; // How to access vectors (3d) f[VE_3D_INDEX(1,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(2,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(3,i,j,k,iVar,iEl,N,nVar)]; // How to access tensors (2d) f[TE_2D_INDEX(1,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(1,2,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,2,i,j,iVar,iEl,N,nVar)]; // How to access tensors (3d) f[TE_3D_INDEX(1,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,3,i,j,k,iVar,iEl,N,nVar)]; } extern \"C\" { void Template_{1D|2D|3D}_gpu_wrapper(int N, int nVar) { hipLaunchKernelGGL((Template_{1D|2D|3D}_gpu), dim3(nVar,nEl,1), dim3(N+1,N+1,N+1), 0, 0,  N, M, nVar); } } */ // JacobianWeight_MappedScalar1D_gpu __global__ void JacobianWeight_MappedScalar1D_gpu ( real * scalar , real * dxds , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; scalar [ SC_1D_INDEX ( i , iVar , iEl , N , nVar )] = scalar [ SC_1D_INDEX ( i , iVar , iEl , N , nVar )] / dxds [ SC_1D_INDEX ( i , 0 , iEl , N , 1 )]; } extern \"C\" { void JacobianWeight_MappedScalar1D_gpu_wrapper ( real ** scalar , real ** dxds , int N , int nVar , int nEl ) { JacobianWeight_MappedScalar1D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 >>> ( * scalar , * dxds , N , nVar ); } } // JacobianWeight_MappedScalar2D_gpu __global__ void JacobianWeight_MappedScalar2D_gpu ( real * scalar , real * jacobian , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; scalar [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] = scalar [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] / jacobian [ SC_2D_INDEX ( i , j , 0 , iEl , N , 1 )]; } extern \"C\" { void JacobianWeight_MappedScalar2D_gpu_wrapper ( real ** scalar , real ** jacobian , int N , int nVar , int nEl ) { JacobianWeight_MappedScalar2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * scalar , * jacobian , N , nVar ); } } // JacobianWeight_MappedScalar3D_gpu __global__ void JacobianWeight_MappedScalar3D_gpu ( real * scalar , real * jacobian , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] = scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; } extern \"C\" { void JacobianWeight_MappedScalar3D_gpu_wrapper ( real ** scalar , real ** jacobian , int N , int nVar , int nEl ) { JacobianWeight_MappedScalar3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * scalar , * jacobian , N , nVar ); } } // ContravariantWeight_MappedScalar2D_gpu __global__ void ContravariantWeight_MappedScalar2D_gpu ( real * scalar , real * workTensor , real * dsdx , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; workTensor [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , N , nVar )] = dsdx [ TE_2D_INDEX ( 1 , 1 , i , j , 0 , iEl , N , 1 )] * scalar [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )]; workTensor [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )] = dsdx [ TE_2D_INDEX ( 1 , 2 , i , j , 0 , iEl , N , 1 )] * scalar [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )]; workTensor [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )] = dsdx [ TE_2D_INDEX ( 2 , 1 , i , j , 0 , iEl , N , 1 )] * scalar [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )]; workTensor [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , N , nVar )] = dsdx [ TE_2D_INDEX ( 2 , 2 , i , j , 0 , iEl , N , 1 )] * scalar [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )]; } extern \"C\" { void ContravariantWeight_MappedScalar2D_gpu_wrapper ( real ** scalar , real ** workTensor , real ** dsdx , int N , int nVar , int nEl ) { ContravariantWeight_MappedScalar2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * scalar , * workTensor , * dsdx , N , nVar ); } } // ContravariantWeightBoundary_MappedScalar2D_gpu __global__ void ContravariantWeightBoundary_MappedScalar2D_gpu ( real * scalar , real * workTensor , real * dsdx , int N , int nVar ){ size_t iSide = blockIdx . x + 1 ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t iVar = threadIdx . y ; workTensor [ TEB_2D_INDEX ( 1 , 1 , i , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_2D_INDEX ( 1 , 1 , i , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_2D_INDEX ( i , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_2D_INDEX ( 2 , 1 , i , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_2D_INDEX ( 1 , 2 , i , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_2D_INDEX ( i , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_2D_INDEX ( 1 , 2 , i , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_2D_INDEX ( 2 , 1 , i , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_2D_INDEX ( i , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_2D_INDEX ( 2 , 2 , i , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_2D_INDEX ( 2 , 2 , i , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_2D_INDEX ( i , iVar , iSide , iEl , N , nVar )]; } extern \"C\" { void ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper ( real ** scalar , real ** workTensor , real ** dsdx , int N , int nVar , int nEl ) { ContravariantWeightBoundary_MappedScalar2D_gpu <<< dim3 ( 4 , nEl , 1 ), dim3 ( N + 1 , nVar , 1 ), 0 , 0 >>> ( * scalar , * workTensor , * dsdx , N , nVar ); } } // ContravariantWeight_MappedScalar3D_gpu __global__ void ContravariantWeight_MappedScalar3D_gpu ( real * scalar , real * workTensor , real * dsdx , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; workTensor [ TE_3D_INDEX ( 1 , 1 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; } extern \"C\" { void ContravariantWeight_MappedScalar3D_gpu_wrapper ( real ** scalar , real ** workTensor , real ** dsdx , int N , int nVar , int nEl ) { ContravariantWeight_MappedScalar3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * scalar , * workTensor , * dsdx , N , nVar ); } } // ContravariantWeightBoundary_MappedScalar3D_gpu __global__ void ContravariantWeightBoundary_MappedScalar3D_gpu ( real * scalar , real * workTensor , real * dsdx , int N , int nVar ){ size_t iSide = blockIdx . x + 1 ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t iVar = threadIdx . z ; workTensor [ TEB_3D_INDEX ( 1 , 1 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 1 , 1 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 2 , 1 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 1 , 2 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 3 , 1 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 1 , 3 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 1 , 2 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 2 , 1 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 2 , 2 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 2 , 2 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 3 , 2 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 2 , 3 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 1 , 3 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 3 , 1 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 2 , 3 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 3 , 2 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 3 , 3 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 3 , 3 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; } extern \"C\" { void ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper ( real ** scalar , real ** workTensor , real ** dsdx , int N , int nVar , int nEl ) { ContravariantWeightBoundary_MappedScalar3D_gpu <<< dim3 ( 6 , nEl , 1 ), dim3 ( N + 1 , N + 1 , nVar ), 0 , 0 >>> ( * scalar , * workTensor , * dsdx , N , nVar ); } } // ContravariantProjection_MappedVector2D_gpu __global__ void ContravariantProjection_MappedVector2D_gpu ( real * physVector , real * compVector , real * dsdx , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; compVector [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] = dsdx [ TE_2D_INDEX ( 1 , 1 , i , j , 0 , iEl , N , 1 )] * physVector [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] + dsdx [ TE_2D_INDEX ( 2 , 1 , i , j , 0 , iEl , N , 1 )] * physVector [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )]; compVector [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] = dsdx [ TE_2D_INDEX ( 1 , 2 , i , j , 0 , iEl , N , 1 )] * physVector [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] + dsdx [ TE_2D_INDEX ( 2 , 2 , i , j , 0 , iEl , N , 1 )] * physVector [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )]; } extern \"C\" { void ContravariantProjection_MappedVector2D_gpu_wrapper ( real ** physVector , real ** compVector , real ** dsdx , int N , int nVar , int nEl ) { ContravariantProjection_MappedVector2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * physVector , * compVector , * dsdx , N , nVar ); } } __global__ void ContravariantProjectionBoundary_MappedVector2D_gpu ( real * physVector , real * boundaryNormal , real * nhat , int N , int nVar ){ size_t iSide = blockIdx . x + 1 ; size_t iVar = blockIdx . y ; size_t iEl = blockIdx . z ; size_t i = threadIdx . x ; boundaryNormal [ SCB_2D_INDEX ( i , iVar , iSide , iEl , N , nVar )] = nhat [ VEB_2D_INDEX ( 1 , i , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_2D_INDEX ( 1 , i , iVar , iSide , iEl , N , nVar )] + nhat [ VEB_2D_INDEX ( 1 , i , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_2D_INDEX ( 2 , i , iVar , iSide , iEl , N , nVar )]; } extern \"C\" { void ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper ( real ** physVector , real ** boundaryNormal , real ** nhat , int N , int nVar , int nEl ) { ContravariantProjectionBoundary_MappedVector2D_gpu <<< dim3 ( 4 , nVar , nEl ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 >>> ( * physVector , * boundaryNormal , * nhat , N , nVar ); } } // JacobianWeight_MappedVector2D_gpu __global__ void JacobianWeight_MappedVector2D_gpu ( real * vector , real * jacobian , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; vector [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] = vector [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] / jacobian [ SC_2D_INDEX ( i , j , 0 , iEl , N , 1 )]; vector [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] = vector [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] / jacobian [ SC_2D_INDEX ( i , j , 0 , iEl , N , 1 )]; } extern \"C\" { void JacobianWeight_MappedVector2D_gpu_wrapper ( real ** vector , real ** jacobian , int N , int nVar , int nEl ) { JacobianWeight_MappedVector2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * vector , * jacobian , N , nVar ); } } // ContravariantProjection_MappedVector3D_gpu __global__ void ContravariantProjection_MappedVector3D_gpu ( real * physVector , real * compVector , real * dsdx , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; compVector [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] + dsdx [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] + dsdx [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )]; compVector [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] + dsdx [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] + dsdx [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )]; compVector [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] + dsdx [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] + dsdx [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )]; } extern \"C\" { void ContravariantProjection_MappedVector3D_gpu_wrapper ( real ** physVector , real ** compVector , real ** dsdx , int N , int nVar , int nEl ) { ContravariantProjection_MappedVector3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * physVector , * compVector , * dsdx , N , nVar ); } } __global__ void ContravariantProjectionBoundary_MappedVector3D_gpu ( real * physVector , real * boundaryNormal , real * nHat , int N , int nVar ){ size_t iSide = blockIdx . x + 1 ; size_t iVar = blockIdx . y ; size_t iEl = blockIdx . z ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; boundaryNormal [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )] = nHat [ VEB_3D_INDEX ( 1 , i , j , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_3D_INDEX ( 1 , i , j , iVar , iSide , iEl , N , nVar )] + nHat [ VEB_3D_INDEX ( 2 , i , j , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_3D_INDEX ( 2 , i , j , iVar , iSide , iEl , N , nVar )] + nHat [ VEB_3D_INDEX ( 3 , i , j , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_3D_INDEX ( 3 , i , j , iVar , iSide , iEl , N , nVar )]; } extern \"C\" { void ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper ( real ** physVector , real ** boundaryNormal , real ** nHat , int N , int nVar , int nEl ) { ContravariantProjectionBoundary_MappedVector3D_gpu <<< dim3 ( 6 , nVar , nEl ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * physVector , * boundaryNormal , * nHat , N , nVar ); } } // JacobianWeight_MappedVector3D_gpu __global__ void JacobianWeight_MappedVector3D_gpu ( real * vector , real * jacobian , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; vector [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; vector [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; vector [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; } extern \"C\" { void JacobianWeight_MappedVector3D_gpu_wrapper ( real ** vector , real ** jacobian , int N , int nVar , int nEl ) { JacobianWeight_MappedVector3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * vector , * jacobian , N , nVar ); } } // JacobianWeight_MappedTensor2D_gpu __global__ void JacobianWeight_MappedTensor2D_gpu ( real * tensor , real * jacobian , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; tensor [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , N , nVar )] = tensor [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , N , nVar )] / jacobian [ SC_2D_INDEX ( i , j , 0 , iEl , N , 1 )]; tensor [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )] = tensor [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )] / jacobian [ SC_2D_INDEX ( i , j , 0 , iEl , N , 1 )]; tensor [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )] = tensor [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )] / jacobian [ SC_2D_INDEX ( i , j , 0 , iEl , N , 1 )]; tensor [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , N , nVar )] = tensor [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , N , nVar )] / jacobian [ SC_2D_INDEX ( i , j , 0 , iEl , N , 1 )]; } extern \"C\" { void JacobianWeight_MappedTensor2D_gpu_wrapper ( real ** tensor , real ** jacobian , int N , int nVar , int nEl ) { JacobianWeight_MappedTensor2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * tensor , * jacobian , N , nVar ); } } // JacobianWeight_MappedTensor3D_gpu __global__ void JacobianWeight_MappedTensor3D_gpu ( real * tensor , real * jacobian , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; tensor [ TE_3D_INDEX ( 1 , 1 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 1 , 1 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; } extern \"C\" { void JacobianWeight_MappedTensor3D_gpu_wrapper ( real ** tensor , real ** jacobian , int N , int nVar , int nEl ) { JacobianWeight_MappedTensor3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * tensor , * jacobian , N , nVar ); } } // CalculateCurl_MappedTensor2D_gpu __global__ void CalculateCurl_MappedTensor2D_gpu ( real * dfdx , real * curlf , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; curlf [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] = dfdx [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )] - dfdx [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )]; } extern \"C\" { void CalculateCurl_MappedTensor2D_gpu_wrapper ( real ** dfdx , real ** curlf , int N , int nVar , int nEl ) { JacobianWeight_MappedTensor2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * dfdx , * curlf , N , nVar ); } } // CalculateCurl_MappedTensor3D_gpu __global__ void CalculateCurl_MappedTensor3D_gpu ( real * dfdx , real * curlf , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; curlf [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] = dfdx [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )] - dfdx [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )]; curlf [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] = dfdx [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] - dfdx [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , N , nVar )]; curlf [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] = dfdx [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , N , nVar )] - dfdx [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )]; } extern \"C\" { void CalculateCurl_MappedTensor3D_gpu_wrapper ( real ** dfdx , real ** curlf , int N , int nVar , int nEl ) { JacobianWeight_MappedTensor3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * dfdx , * curlf , N , nVar ); } } // MapTo support routines __global__ void MapToScalar_MappedVector2D_gpu ( real * scalar , real * vector , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t jVar = 2 * ( iVar ); scalar [ SC_2D_INDEX ( i , j , jVar , iEl , N , nVar * 2 )] = vector [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )]; jVar += 1 ; scalar [ SC_2D_INDEX ( i , j , jVar , iEl , N , nVar * 2 )] = vector [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )]; } extern \"C\" { void MapToScalar_MappedVector2D_gpu_wrapper ( real ** scalar , real ** vector , int N , int nVar , int nEl ) { MapToScalar_MappedVector2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * scalar , * vector , N , nVar ); } } __global__ void MapToScalarBoundary_MappedVector2D_gpu ( real * scalar , real * vector , int N , int nVar ){ size_t iSide = blockIdx . x + 1 ; size_t iVar = blockIdx . y ; size_t iEl = blockIdx . z ; size_t j = threadIdx . x ; size_t jVar = 2 * ( iVar ); scalar [ SCB_2D_INDEX ( j , jVar , iSide , iEl , N , nVar * 2 )] = vector [ VEB_2D_INDEX ( 1 , j , iVar , iSide , iEl , N , nVar )]; jVar += 1 ; scalar [ SCB_2D_INDEX ( j , jVar , iSide , iEl , N , nVar * 2 )] = vector [ VEB_2D_INDEX ( 2 , j , iVar , iSide , iEl , N , nVar )]; } extern \"C\" { void MapToScalarBoundary_MappedVector2D_gpu_wrapper ( real ** scalar , real ** vector , int N , int nVar , int nEl ) { MapToScalarBoundary_MappedVector2D_gpu <<< dim3 ( 4 , nVar , nEl ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 >>> ( * scalar , * vector , N , nVar ); } } __global__ void MapToTensor_MappedVector2D_gpu ( real * tensor , real * vector , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t jVar = 2 * ( iVar ); tensor [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , N , nVar )] = vector [ VE_2D_INDEX ( 1 , i , j , jVar , iEl , N , nVar * 2 )]; tensor [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )] = vector [ VE_2D_INDEX ( 2 , i , j , jVar , iEl , N , nVar * 2 )]; jVar += 1 ; tensor [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )] = vector [ VE_2D_INDEX ( 1 , i , j , jVar , iEl , N , nVar * 2 )]; tensor [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , N , nVar )] = vector [ VE_2D_INDEX ( 2 , i , j , jVar , iEl , N , nVar * 2 )]; } extern \"C\" { void MapToTensor_MappedVector2D_gpu_wrapper ( real ** tensor , real ** vector , int N , int nVar , int nEl ) { MapToTensor_MappedVector2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * tensor , * vector , N , nVar ); } } __global__ void MapToTensorBoundary_MappedVector2D_gpu ( real * tensor , real * vector , int N , int nVar ){ size_t iSide = blockIdx . x + 1 ; size_t iVar = blockIdx . y ; size_t iEl = blockIdx . z ; size_t j = threadIdx . x ; size_t jVar = 2 * ( iVar ); tensor [ TEB_2D_INDEX ( 1 , 1 , j , iVar , iSide , iEl , N , nVar )] = vector [ VEB_2D_INDEX ( 1 , j , jVar , iSide , iEl , N , nVar * 2 )]; tensor [ TEB_2D_INDEX ( 1 , 2 , j , iVar , iSide , iEl , N , nVar )] = vector [ VEB_2D_INDEX ( 2 , j , jVar , iSide , iEl , N , nVar * 2 )]; jVar += 1 ; tensor [ TEB_2D_INDEX ( 2 , 1 , j , iVar , iSide , iEl , N , nVar )] = vector [ VEB_2D_INDEX ( 1 , j , jVar , iSide , iEl , N , nVar * 2 )]; tensor [ TEB_2D_INDEX ( 2 , 2 , j , iVar , iSide , iEl , N , nVar )] = vector [ VEB_2D_INDEX ( 2 , j , jVar , iSide , iEl , N , nVar * 2 )]; } extern \"C\" { void MapToTensorBoundary_MappedVector2D_gpu_wrapper ( real ** tensor , real ** vector , int N , int nVar , int nEl ) { MapToTensorBoundary_MappedVector2D_gpu <<< dim3 ( 4 , nVar , nEl ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 >>> ( * tensor , * vector , N , nVar ); } } __global__ void MapToScalar_MappedVector3D_gpu ( real * scalar , real * vector , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; size_t jVar = 3 * ( iVar ); scalar [ SC_3D_INDEX ( i , j , k , jVar , iEl , N , nVar * 3 )] = vector [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )]; jVar += 1 ; scalar [ SC_3D_INDEX ( i , j , k , jVar , iEl , N , nVar * 3 )] = vector [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )]; jVar += 1 ; scalar [ SC_3D_INDEX ( i , j , k , jVar , iEl , N , nVar * 3 )] = vector [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )]; } extern \"C\" { void MapToScalar_MappedVector3D_gpu_wrapper ( real ** scalar , real ** vector , int N , int nVar , int nEl ) { MapToScalar_MappedVector3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * scalar , * vector , N , nVar ); } } __global__ void MapToScalarBoundary_MappedVector3D_gpu ( real * scalar , real * vector , int N , int nVar ){ size_t iSide = blockIdx . x + 1 ; size_t iEl = blockIdx . y ; size_t j = threadIdx . x ; size_t k = threadIdx . y ; size_t iVar = threadIdx . z ; size_t jVar = 3 * ( iVar ); scalar [ SCB_3D_INDEX ( j , k , jVar , iSide , iEl , N , nVar * 3 )] = vector [ VEB_3D_INDEX ( 1 , j , k , iVar , iSide , iEl , N , nVar )]; jVar += 1 ; scalar [ SCB_3D_INDEX ( j , k , jVar , iSide , iEl , N , nVar * 3 )] = vector [ VEB_3D_INDEX ( 2 , j , k , iVar , iSide , iEl , N , nVar )]; jVar += 1 ; scalar [ SCB_3D_INDEX ( j , k , jVar , iSide , iEl , N , nVar * 3 )] = vector [ VEB_3D_INDEX ( 3 , j , k , iVar , iSide , iEl , N , nVar )]; } extern \"C\" { void MapToScalarBoundary_MappedVector3D_gpu_wrapper ( real ** scalar , real ** vector , int N , int nVar , int nEl ) { MapToScalarBoundary_MappedVector3D_gpu <<< dim3 ( 6 , nEl , 1 ), dim3 ( N + 1 , N + 1 , nVar ), 0 , 0 >>> ( * scalar , * vector , N , nVar ); } } __global__ void MapToTensor_MappedVector3D_gpu ( real * tensor , real * vector , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; size_t jVar = 3 * ( iVar ); tensor [ TE_3D_INDEX ( 1 , 1 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 1 , i , j , k , jVar , iEl , N , nVar * 3 )]; tensor [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 2 , i , j , k , jVar , iEl , N , nVar * 3 )]; tensor [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 3 , i , j , k , jVar , iEl , N , nVar * 3 )]; jVar += 1 ; tensor [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 1 , i , j , k , jVar , iEl , N , nVar * 3 )]; tensor [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 2 , i , j , k , jVar , iEl , N , nVar * 3 )]; tensor [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 3 , i , j , k , jVar , iEl , N , nVar * 3 )]; jVar += 1 ; tensor [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 1 , i , j , k , jVar , iEl , N , nVar * 3 )]; tensor [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 2 , i , j , k , jVar , iEl , N , nVar * 3 )]; tensor [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 3 , i , j , k , jVar , iEl , N , nVar * 3 )]; } extern \"C\" { void MapToTensor_MappedVector3D_gpu_wrapper ( real ** tensor , real ** vector , int N , int nVar , int nEl ) { MapToTensor_MappedVector3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * tensor , * vector , N , nVar ); } } __global__ void MapToTensorBoundary_MappedVector3D_gpu ( real * tensor , real * vector , int N , int nVar ){ size_t iSide = blockIdx . x + 1 ; size_t iEl = blockIdx . y ; size_t j = threadIdx . x ; size_t k = threadIdx . x ; size_t iVar = threadIdx . z ; size_t jVar = 3 * ( iVar ); tensor [ TEB_3D_INDEX ( 1 , 1 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 1 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; tensor [ TEB_3D_INDEX ( 1 , 2 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 2 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; tensor [ TEB_3D_INDEX ( 1 , 3 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 3 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; jVar += 1 ; tensor [ TEB_3D_INDEX ( 2 , 1 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 1 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; tensor [ TEB_3D_INDEX ( 2 , 2 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 2 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; tensor [ TEB_3D_INDEX ( 2 , 3 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 3 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; jVar += 1 ; tensor [ TEB_3D_INDEX ( 3 , 1 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 1 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; tensor [ TEB_3D_INDEX ( 3 , 2 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 2 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; tensor [ TEB_3D_INDEX ( 3 , 3 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 3 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; } extern \"C\" { void MapToTensorBoundary_MappedVector3D_gpu_wrapper ( real ** tensor , real ** vector , int N , int nVar , int nEl ) { MapToTensorBoundary_MappedVector3D_gpu <<< dim3 ( 6 , nEl , 1 ), dim3 ( N + 1 , N + 1 , nVar ), 0 , 0 >>> ( * tensor , * vector , N , nVar ); } } __global__ void SideExchange_MappedScalar2D_gpu ( real * extBoundary , real * boundary , int * sideInfo , int * elemToRank , int rankId , int N , int nVar ){ size_t s1 = blockIdx . x + 1 ; size_t e1 = blockIdx . y ; size_t i1 = threadIdx . x ; size_t ivar = threadIdx . y ; int e2 = sideInfo [ INDEX3 ( 2 , s1 -1 , e1 , 5 , 4 )] -1 ; int s2 = sideInfo [ INDEX3 ( 3 , s1 -1 , e1 , 5 , 4 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 -1 , e1 , 5 , 4 )] - s2 * 10 ; int bcid = sideInfo [ INDEX3 ( 4 , s1 -1 , e1 , 5 , 4 )]; if ( bcid == 0 ){ int neighborRank = elemToRank [ e2 ]; if ( neighborRank == rankId ){ if ( flip == 0 ){ extBoundary [ SCB_2D_INDEX ( i1 , ivar , s1 , e1 , N , nVar )] = boundary [ SCB_2D_INDEX ( i1 , ivar , s2 , e2 , N , nVar )]; } else if ( flip == 1 ){ int i2 = N - i1 ; extBoundary [ SCB_2D_INDEX ( i1 , ivar , s1 , e1 , N , nVar )] = boundary [ SCB_2D_INDEX ( i2 , ivar , s2 , e2 , N , nVar )]; } } } } extern \"C\" { void SideExchange_MappedScalar2D_gpu_wrapper ( real ** extBoundary , real ** boundary , int ** sideInfo , int ** elemToRank , int rankId , int N , int nVar , int nEl ) { SideExchange_MappedScalar2D_gpu <<< dim3 ( 4 , nEl , 1 ), dim3 ( N + 1 , nVar , 1 ), 0 , 0 >>> ( * extBoundary , * boundary , * sideInfo , * elemToRank , rankId , N , nVar ); } } __global__ void SideExchange_MappedVector2D_gpu ( real * extBoundary , real * boundary , int * sideInfo , int * elemToRank , int rankId , int N , int nVar ){ size_t s1 = blockIdx . x + 1 ; size_t e1 = blockIdx . y ; size_t i1 = threadIdx . x ; size_t ivar = threadIdx . y ; int e2 = sideInfo [ INDEX3 ( 2 , s1 -1 , e1 , 5 , 4 )] -1 ; int s2 = sideInfo [ INDEX3 ( 3 , s1 -1 , e1 , 5 , 4 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 -1 , e1 , 5 , 4 )] - s2 * 10 ; int bcid = sideInfo [ INDEX3 ( 4 , s1 -1 , e1 , 5 , 4 )]; int i2 = N - i1 ; if ( bcid == 0 ){ int neighborRank = elemToRank [ e2 ]; if ( neighborRank == rankId ){ if ( flip == 0 ){ extBoundary [ VEB_2D_INDEX ( 1 , i1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_2D_INDEX ( 1 , i1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ VEB_2D_INDEX ( 2 , i1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_2D_INDEX ( 2 , i1 , ivar , s2 , e2 , N , nVar )]; } else if ( flip == 1 ){ extBoundary [ VEB_2D_INDEX ( 1 , i1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_2D_INDEX ( 1 , i2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ VEB_2D_INDEX ( 2 , i1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_2D_INDEX ( 2 , i2 , ivar , s2 , e2 , N , nVar )]; } } } } extern \"C\" { void SideExchange_MappedVector2D_gpu_wrapper ( real ** extBoundary , real ** boundary , int ** sideInfo , int ** elemToRank , int rankId , int N , int nVar , int nEl ) { SideExchange_MappedVector2D_gpu <<< dim3 ( 4 , nEl , 1 ), dim3 ( N + 1 , nVar , 1 ), 0 , 0 >>> ( * extBoundary , * boundary , * sideInfo , * elemToRank , rankId , N , nVar ); } } __global__ void SideExchange_MappedTensor2D_gpu ( real * extBoundary , real * boundary , int * sideInfo , int * elemToRank , int rankId , int N , int nVar ){ size_t s1 = blockIdx . x + 1 ; size_t e1 = blockIdx . y ; size_t i1 = threadIdx . x ; size_t ivar = threadIdx . y ; int e2 = sideInfo [ INDEX3 ( 2 , s1 -1 , e1 , 5 , 4 )] -1 ; int s2 = sideInfo [ INDEX3 ( 3 , s1 -1 , e1 , 5 , 4 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 -1 , e1 , 5 , 4 )] - s2 * 10 ; int bcid = sideInfo [ INDEX3 ( 4 , s1 -1 , e1 , 5 , 4 )]; int i2 = N - i1 ; if ( bcid == 0 ){ int neighborRank = elemToRank [ e2 ]; if ( neighborRank == rankId ){ if ( flip == 0 ){ extBoundary [ TEB_2D_INDEX ( 1 , 1 , i1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_2D_INDEX ( 1 , 1 , i1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_2D_INDEX ( 2 , 1 , i1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_2D_INDEX ( 2 , 1 , i1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_2D_INDEX ( 1 , 2 , i1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_2D_INDEX ( 1 , 2 , i1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_2D_INDEX ( 2 , 2 , i1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_2D_INDEX ( 2 , 2 , i1 , ivar , s2 , e2 , N , nVar )]; } else if ( flip == 1 ){ extBoundary [ TEB_2D_INDEX ( 1 , 1 , i1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_2D_INDEX ( 1 , 1 , i2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_2D_INDEX ( 2 , 1 , i1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_2D_INDEX ( 2 , 1 , i2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_2D_INDEX ( 1 , 2 , i1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_2D_INDEX ( 1 , 2 , i2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_2D_INDEX ( 2 , 2 , i1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_2D_INDEX ( 2 , 2 , i2 , ivar , s2 , e2 , N , nVar )]; } } } } extern \"C\" { void SideExchange_MappedTensor2D_gpu_wrapper ( real ** extBoundary , real ** boundary , int ** sideInfo , int ** elemToRank , int rankId , int N , int nVar , int nEl ) { SideExchange_MappedTensor2D_gpu <<< dim3 ( 4 , nEl , 1 ), dim3 ( N + 1 , nVar , 1 ), 0 , 0 >>> ( * extBoundary , * boundary , * sideInfo , * elemToRank , rankId , N , nVar ); } } __global__ void SideExchange_MappedScalar3D_gpu ( real * extBoundary , real * boundary , int * sideInfo , int * elemToRank , int rankId , int N , int nVar ){ size_t s1 = blockIdx . x + 1 ; size_t e1 = blockIdx . y ; size_t i1 = threadIdx . x ; size_t j1 = threadIdx . y ; size_t ivar = threadIdx . z ; int e2 = sideInfo [ INDEX3 ( 2 , s1 -1 , e1 , 5 , 6 )] -1 ; int s2 = sideInfo [ INDEX3 ( 3 , s1 -1 , e1 , 5 , 6 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 -1 , e1 , 5 , 6 )] - s2 * 10 ; int bcid = sideInfo [ INDEX3 ( 4 , s1 -1 , e1 , 5 , 6 )]; int i2 = N - i1 ; int j2 = N - j1 ; if ( bcid == 0 ){ int neighborRank = elemToRank [ e2 ]; if ( neighborRank == rankId ){ if ( flip == 0 ){ extBoundary [ SCB_3D_INDEX ( i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ SCB_3D_INDEX ( i1 , j1 , ivar , s2 , e2 , N , nVar )]; } else if ( flip == 1 ){ extBoundary [ SCB_3D_INDEX ( i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ SCB_3D_INDEX ( j2 , i1 , ivar , s2 , e2 , N , nVar )]; } else if ( flip == 2 ){ extBoundary [ SCB_3D_INDEX ( i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ SCB_3D_INDEX ( i2 , j2 , ivar , s2 , e2 , N , nVar )]; } else if ( flip == 3 ){ extBoundary [ SCB_3D_INDEX ( i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ SCB_3D_INDEX ( j1 , i2 , ivar , s2 , e2 , N , nVar )]; } } } } extern \"C\" { void SideExchange_MappedScalar3D_gpu_wrapper ( real ** extBoundary , real ** boundary , int ** sideInfo , int ** elemToRank , int rankId , int N , int nVar , int nEl ) { SideExchange_MappedScalar3D_gpu <<< dim3 ( 6 , nEl , 1 ), dim3 ( N + 1 , N + 1 , nVar ), 0 , 0 >>> ( * extBoundary , * boundary , * sideInfo , * elemToRank , rankId , N , nVar ); } } __global__ void SideExchange_MappedVector3D_gpu ( real * extBoundary , real * boundary , int * sideInfo , int * elemToRank , int rankId , int N , int nVar ){ size_t s1 = blockIdx . x + 1 ; size_t e1 = blockIdx . y ; size_t i1 = threadIdx . x ; size_t j1 = threadIdx . y ; size_t ivar = threadIdx . z ; int e2 = sideInfo [ INDEX3 ( 2 , s1 -1 , e1 , 5 , 6 )] -1 ; int s2 = sideInfo [ INDEX3 ( 3 , s1 -1 , e1 , 5 , 6 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 -1 , e1 , 5 , 6 )] - s2 * 10 ; int bcid = sideInfo [ INDEX3 ( 4 , s1 -1 , e1 , 5 , 6 )]; int i2 = N - i1 ; int j2 = N - j1 ; if ( bcid == 0 ){ int neighborRank = elemToRank [ e2 ]; if ( neighborRank == rankId ){ if ( flip == 0 ){ extBoundary [ VEB_3D_INDEX ( 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_3D_INDEX ( 1 , i1 , j1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ VEB_3D_INDEX ( 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_3D_INDEX ( 2 , i1 , j1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ VEB_3D_INDEX ( 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_3D_INDEX ( 3 , i1 , j1 , ivar , s2 , e2 , N , nVar )]; } else if ( flip == 1 ){ extBoundary [ VEB_3D_INDEX ( 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_3D_INDEX ( 1 , j2 , i1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ VEB_3D_INDEX ( 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_3D_INDEX ( 2 , j2 , i1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ VEB_3D_INDEX ( 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_3D_INDEX ( 3 , j2 , i1 , ivar , s2 , e2 , N , nVar )]; } else if ( flip == 2 ){ extBoundary [ VEB_3D_INDEX ( 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_3D_INDEX ( 1 , i2 , j2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ VEB_3D_INDEX ( 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_3D_INDEX ( 2 , i2 , j2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ VEB_3D_INDEX ( 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_3D_INDEX ( 3 , i2 , j2 , ivar , s2 , e2 , N , nVar )]; } else if ( flip == 3 ){ extBoundary [ VEB_3D_INDEX ( 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_3D_INDEX ( 1 , j1 , i2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ VEB_3D_INDEX ( 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_3D_INDEX ( 2 , j1 , i2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ VEB_3D_INDEX ( 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ VEB_3D_INDEX ( 3 , j1 , i2 , ivar , s2 , e2 , N , nVar )]; } } } } extern \"C\" { void SideExchange_MappedVector3D_gpu_wrapper ( real ** extBoundary , real ** boundary , int ** sideInfo , int ** elemToRank , int rankId , int N , int nVar , int nEl ) { SideExchange_MappedVector3D_gpu <<< dim3 ( 6 , nEl , 1 ), dim3 ( N + 1 , N + 1 , nVar ), 0 , 0 >>> ( * extBoundary , * boundary , * sideInfo , * elemToRank , rankId , N , nVar ); } } __global__ void SideExchange_MappedTensor3D_gpu ( real * extBoundary , real * boundary , int * sideInfo , int * elemToRank , int rankId , int N , int nVar ){ size_t s1 = blockIdx . x + 1 ; size_t e1 = blockIdx . y ; size_t i1 = threadIdx . x ; size_t j1 = threadIdx . y ; size_t ivar = threadIdx . z ; int e2 = sideInfo [ INDEX3 ( 2 , s1 -1 , e1 , 5 , 6 )] -1 ; int s2 = sideInfo [ INDEX3 ( 3 , s1 -1 , e1 , 5 , 6 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 -1 , e1 , 5 , 6 )] - s2 * 10 ; int bcid = sideInfo [ INDEX3 ( 4 , s1 -1 , e1 , 5 , 6 )]; int i2 = N - i1 ; int j2 = N - j1 ; if ( bcid == 0 ){ int neighborRank = elemToRank [ e2 ]; if ( neighborRank == rankId ){ if ( flip == 0 ){ extBoundary [ TEB_3D_INDEX ( 1 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 1 , 1 , i1 , j1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 2 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 2 , 1 , i1 , j1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 3 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 3 , 1 , i1 , j1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 1 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 1 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 2 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 2 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 3 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 3 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 1 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 1 , 3 , i1 , j1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 2 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 2 , 3 , i1 , j1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 3 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 3 , 3 , i1 , j1 , ivar , s2 , e2 , N , nVar )]; } else if ( flip == 1 ){ extBoundary [ TEB_3D_INDEX ( 1 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 1 , 1 , j2 , i1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 2 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 2 , 1 , j2 , i1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 3 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 3 , 1 , j2 , i1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 1 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 1 , 2 , j2 , i1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 2 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 2 , 2 , j2 , i1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 3 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 3 , 2 , j2 , i1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 1 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 1 , 3 , j2 , i1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 2 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 2 , 3 , j2 , i1 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 3 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 3 , 3 , j2 , i1 , ivar , s2 , e2 , N , nVar )]; } else if ( flip == 2 ){ extBoundary [ TEB_3D_INDEX ( 1 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 1 , 1 , i2 , j2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 2 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 2 , 1 , i2 , j2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 3 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 3 , 1 , i2 , j2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 1 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 1 , 2 , i2 , j2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 2 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 2 , 2 , i2 , j2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 3 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 3 , 2 , i2 , j2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 1 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 1 , 3 , i2 , j2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 2 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 2 , 3 , i2 , j2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 3 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 3 , 3 , i2 , j2 , ivar , s2 , e2 , N , nVar )]; } else if ( flip == 3 ){ extBoundary [ TEB_3D_INDEX ( 1 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 1 , 1 , j1 , i2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 2 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 2 , 1 , j1 , i2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 3 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 3 , 1 , j1 , i2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 1 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 1 , 2 , j1 , i2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 2 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 2 , 2 , j1 , i2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 3 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 3 , 2 , j1 , i2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 1 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 1 , 3 , j1 , i2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 2 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 2 , 3 , j1 , i2 , ivar , s2 , e2 , N , nVar )]; extBoundary [ TEB_3D_INDEX ( 3 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = boundary [ TEB_3D_INDEX ( 3 , 3 , j1 , i2 , ivar , s2 , e2 , N , nVar )]; } } } } extern \"C\" { void SideExchange_MappedTensor3D_gpu_wrapper ( real ** extBoundary , real ** boundary , int ** sideInfo , int ** elemToRank , int rankId , int N , int nVar , int nEl ) { SideExchange_MappedTensor3D_gpu <<< dim3 ( 6 , nEl , 1 ), dim3 ( N + 1 , N + 1 , nVar ), 0 , 0 >>> ( * extBoundary , * boundary , * sideInfo , * elemToRank , rankId , N , nVar ); } } __global__ void BassiRebaySides_MappedScalar2D_gpu ( real * avgBoundary , real * boundary , real * extBoundary , int N , int nVar ){ size_t s1 = blockIdx . x + 1 ; size_t e1 = blockIdx . y ; size_t i1 = threadIdx . x ; size_t ivar = threadIdx . y ; avgBoundary [ SCB_2D_INDEX ( i1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ SCB_2D_INDEX ( i1 , ivar , s1 , e1 , N , nVar )] + boundary [ SCB_2D_INDEX ( i1 , ivar , s1 , e1 , N , nVar )]); } extern \"C\" { void BassiRebaySides_MappedScalar2D_gpu_wrapper ( real ** avgBoundary , real ** boundary , real ** extBoundary , int N , int nVar , int nEl ) { BassiRebaySides_MappedScalar2D_gpu <<< dim3 ( 4 , nEl , 1 ), dim3 ( N + 1 , nVar , 1 ), 0 , 0 >>> ( * avgBoundary , * boundary , * extBoundary , N , nVar ); } } __global__ void BassiRebaySides_MappedVector2D_gpu ( real * extBoundary , real * boundary , int N , int nVar ){ size_t s1 = blockIdx . x + 1 ; size_t e1 = blockIdx . y ; size_t i1 = threadIdx . x ; size_t ivar = threadIdx . y ; boundary [ VEB_2D_INDEX ( 1 , i1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ VEB_2D_INDEX ( 1 , i1 , ivar , s1 , e1 , N , nVar )] + boundary [ VEB_2D_INDEX ( 1 , i1 , ivar , s1 , e1 , N , nVar )]); boundary [ VEB_2D_INDEX ( 2 , i1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ VEB_2D_INDEX ( 2 , i1 , ivar , s1 , e1 , N , nVar )] + boundary [ VEB_2D_INDEX ( 2 , i1 , ivar , s1 , e1 , N , nVar )]); } extern \"C\" { void BassiRebaySides_MappedVector2D_gpu_wrapper ( real ** extBoundary , real ** boundary , int N , int nVar , int nEl ) { BassiRebaySides_MappedVector2D_gpu <<< dim3 ( 4 , nEl , 1 ), dim3 ( N + 1 , nVar , 1 ), 0 , 0 >>> ( * extBoundary , * boundary , N , nVar ); } } __global__ void BassiRebaySides_MappedTensor2D_gpu ( real * extBoundary , real * boundary , int N , int nVar ){ size_t s1 = blockIdx . x + 1 ; size_t e1 = blockIdx . y ; size_t i1 = threadIdx . x ; size_t ivar = threadIdx . y ; boundary [ TEB_2D_INDEX ( 1 , 1 , i1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ TEB_2D_INDEX ( 1 , 1 , i1 , ivar , s1 , e1 , N , nVar )] + boundary [ TEB_2D_INDEX ( 1 , 1 , i1 , ivar , s1 , e1 , N , nVar )]); boundary [ TEB_2D_INDEX ( 2 , 1 , i1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ TEB_2D_INDEX ( 2 , 1 , i1 , ivar , s1 , e1 , N , nVar )] + boundary [ TEB_2D_INDEX ( 2 , 1 , i1 , ivar , s1 , e1 , N , nVar )]); boundary [ TEB_2D_INDEX ( 1 , 2 , i1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ TEB_2D_INDEX ( 1 , 2 , i1 , ivar , s1 , e1 , N , nVar )] + boundary [ TEB_2D_INDEX ( 1 , 2 , i1 , ivar , s1 , e1 , N , nVar )]); boundary [ TEB_2D_INDEX ( 2 , 2 , i1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ TEB_2D_INDEX ( 2 , 2 , i1 , ivar , s1 , e1 , N , nVar )] + boundary [ TEB_2D_INDEX ( 2 , 2 , i1 , ivar , s1 , e1 , N , nVar )]); } extern \"C\" { void BassiRebaySides_MappedTensor2D_gpu_wrapper ( real ** extBoundary , real ** boundary , int N , int nVar , int nEl ) { BassiRebaySides_MappedTensor2D_gpu <<< dim3 ( 4 , nEl , 1 ), dim3 ( N + 1 , nVar , 1 ), 0 , 0 >>> ( * extBoundary , * boundary , N , nVar ); } } __global__ void BassiRebaySides_MappedScalar3D_gpu ( real * avgBoundary , real * boundary , real * extBoundary , int N , int nVar ){ size_t s1 = blockIdx . x + 1 ; size_t e1 = blockIdx . y ; size_t i1 = threadIdx . x ; size_t j1 = threadIdx . y ; size_t ivar = threadIdx . z ; avgBoundary [ SCB_3D_INDEX ( i1 , j1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ SCB_3D_INDEX ( i1 , j1 , ivar , s1 , e1 , N , nVar )] + boundary [ SCB_3D_INDEX ( i1 , j1 , ivar , s1 , e1 , N , nVar )]); } extern \"C\" { void BassiRebaySides_MappedScalar3D_gpu_wrapper ( real ** avgBoundary , real ** boundary , real ** extBoundary , int N , int nVar , int nEl ) { BassiRebaySides_MappedScalar3D_gpu <<< dim3 ( 6 , nEl , 1 ), dim3 ( N + 1 , N + 1 , nVar ), 0 , 0 >>> ( * avgBoundary , * boundary , * extBoundary , N , nVar ); } } __global__ void BassiRebaySides_MappedVector3D_gpu ( real * extBoundary , real * boundary , int N , int nVar ){ size_t s1 = blockIdx . x + 1 ; size_t e1 = blockIdx . y ; size_t i1 = threadIdx . x ; size_t j1 = threadIdx . y ; size_t ivar = threadIdx . z ; boundary [ VEB_3D_INDEX ( 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ VEB_3D_INDEX ( 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] + boundary [ VEB_3D_INDEX ( 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )]); boundary [ VEB_3D_INDEX ( 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ VEB_3D_INDEX ( 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] + boundary [ VEB_3D_INDEX ( 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )]); boundary [ VEB_3D_INDEX ( 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ VEB_3D_INDEX ( 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] + boundary [ VEB_3D_INDEX ( 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )]); } extern \"C\" { void BassiRebaySides_MappedVector3D_gpu_wrapper ( real ** extBoundary , real ** boundary , int N , int nVar , int nEl ) { BassiRebaySides_MappedVector3D_gpu <<< dim3 ( 6 , nEl , 1 ), dim3 ( N + 1 , N + 1 , nVar ), 0 , 0 >>> ( * extBoundary , * boundary , N , nVar ); } } __global__ void BassiRebaySides_MappedTensor3D_gpu ( real * extBoundary , real * boundary , int N , int nVar ){ size_t s1 = blockIdx . x + 1 ; size_t e1 = blockIdx . y ; size_t i1 = threadIdx . x ; size_t j1 = threadIdx . y ; size_t ivar = threadIdx . z ; boundary [ TEB_3D_INDEX ( 1 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ TEB_3D_INDEX ( 1 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] + boundary [ TEB_3D_INDEX ( 1 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )]); boundary [ TEB_3D_INDEX ( 2 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ TEB_3D_INDEX ( 2 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] + boundary [ TEB_3D_INDEX ( 2 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )]); boundary [ TEB_3D_INDEX ( 3 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ TEB_3D_INDEX ( 3 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] + boundary [ TEB_3D_INDEX ( 3 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )]); boundary [ TEB_3D_INDEX ( 1 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ TEB_3D_INDEX ( 1 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] + boundary [ TEB_3D_INDEX ( 1 , 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )]); boundary [ TEB_3D_INDEX ( 2 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ TEB_3D_INDEX ( 2 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] + boundary [ TEB_3D_INDEX ( 2 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )]); boundary [ TEB_3D_INDEX ( 3 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ TEB_3D_INDEX ( 3 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )] + boundary [ TEB_3D_INDEX ( 3 , 2 , i1 , j1 , ivar , s1 , e1 , N , nVar )]); boundary [ TEB_3D_INDEX ( 1 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ TEB_3D_INDEX ( 1 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] + boundary [ TEB_3D_INDEX ( 1 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )]); boundary [ TEB_3D_INDEX ( 2 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ TEB_3D_INDEX ( 2 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] + boundary [ TEB_3D_INDEX ( 2 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )]); boundary [ TEB_3D_INDEX ( 3 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = 0.5 * ( extBoundary [ TEB_3D_INDEX ( 3 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )] + boundary [ TEB_3D_INDEX ( 3 , 3 , i1 , j1 , ivar , s1 , e1 , N , nVar )]); } extern \"C\" { void BassiRebaySides_MappedTensor3D_gpu_wrapper ( real ** extBoundary , real ** boundary , int N , int nVar , int nEl ) { BassiRebaySides_MappedTensor3D_gpu <<< dim3 ( 6 , nEl , 1 ), dim3 ( N + 1 , N + 1 , nVar ), 0 , 0 >>> ( * extBoundary , * boundary , N , nVar ); } } __global__ void ApplyFlip_MappedScalar2D_gpu ( real * extBoundary , int * sideInfo , int * elemToRank , int rankId , int N , int nVar ){ size_t ivar = blockIdx . x ; size_t s1 = blockIdx . y ; size_t e1 = blockIdx . z ; size_t i1 = threadIdx . x ; int e2 = sideInfo [ INDEX3 ( 2 , s1 , e1 , 5 , 4 )]; int s2 = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] - s2 * 10 ; int bcid = sideInfo [ INDEX3 ( 4 , s1 , e1 , 5 , 4 )]; int i2 = N - i1 ; __shared__ real extBuff [ 16 ]; extBuff [ i1 ] = extBoundary [ SCB_2D_INDEX ( i1 , ivar , s1 , e1 , N , nVar )]; __syncthreads (); if ( bcid == 0 ){ int neighborRank = elemToRank [ e2 ]; if ( neighborRank /= rankId ){ if ( flip == 1 ){ extBoundary [ SCB_2D_INDEX ( i1 , ivar , s1 , e1 , N , nVar )] = extBuff [ i2 ]; } } } } extern \"C\" { void ApplyFlip_MappedScalar2D_gpu_wrapper ( real ** extBoundary , int ** sideInfo , int ** elemToRank , int rankId , int N , int nVar , int nEl ) { ApplyFlip_MappedScalar2D_gpu <<< dim3 ( nVar , 4 , nEl ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 >>> ( * extBoundary , * sideInfo , * elemToRank , rankId , N , nVar ); } } __global__ void ApplyFlip_MappedVector2D_gpu ( real * extBoundary , int * sideInfo , int * elemToRank , int rankId , int N , int nVar ){ size_t ivar = blockIdx . x ; size_t s1 = blockIdx . y ; size_t e1 = blockIdx . z ; size_t dir = threadIdx . x ; size_t i1 = threadIdx . y ; int e2 = sideInfo [ INDEX3 ( 2 , s1 , e1 , 5 , 4 )]; int s2 = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] - s2 * 10 ; int bcid = sideInfo [ INDEX3 ( 4 , s1 , e1 , 5 , 4 )]; int i2 = N - i1 ; __shared__ real extBuff [ 32 ]; extBuff [ dir + 2 * i1 ] = extBoundary [ VEB_2D_INDEX ( dir + 1 , i1 , ivar , s1 , e1 , N , nVar )]; __syncthreads (); if ( bcid == 0 ){ int neighborRank = elemToRank [ e2 ]; if ( neighborRank /= rankId ){ if ( flip == 1 ){ extBoundary [ VEB_2D_INDEX ( dir + 1 , i1 , ivar , s1 , e1 , N , nVar )] = extBuff [ dir + 2 * i2 ]; } } } } extern \"C\" { void ApplyFlip_MappedVector2D_gpu_wrapper ( real ** extBoundary , int ** sideInfo , int ** elemToRank , int rankId , int N , int nVar , int nEl ) { ApplyFlip_MappedVector2D_gpu <<< dim3 ( nVar , 4 , nEl ), dim3 ( 2 , N + 1 , 1 ), 0 , 0 >>> ( * extBoundary , * sideInfo , * elemToRank , rankId , N , nVar ); } } __global__ void ApplyFlip_MappedTensor2D_gpu ( real * extBoundary , int * sideInfo , int * elemToRank , int rankId , int N , int nVar ){ size_t ivar = blockIdx . x ; size_t s1 = blockIdx . y ; size_t e1 = blockIdx . z ; size_t row = threadIdx . x ; size_t col = threadIdx . y ; size_t i1 = threadIdx . z ; int e2 = sideInfo [ INDEX3 ( 2 , s1 , e1 , 5 , 4 )]; int s2 = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] - s2 * 10 ; int bcid = sideInfo [ INDEX3 ( 4 , s1 , e1 , 5 , 4 )]; int i2 = N - i1 ; __shared__ real extBuff [ 64 ]; extBuff [ row + 2 * ( col + 2 * i1 )] = extBoundary [ TEB_2D_INDEX ( row + 1 , col + 1 , i1 , ivar , s1 , e1 , N , nVar )]; __syncthreads (); if ( bcid == 0 ){ int neighborRank = elemToRank [ e2 ]; if ( neighborRank /= rankId ){ if ( flip == 1 ){ extBoundary [ TEB_2D_INDEX ( row + 1 , col + 1 , i1 , ivar , s1 , e1 , N , nVar )] = extBuff [ row + 2 * ( col + 2 * i2 )]; } } } } extern \"C\" { void ApplyFlip_MappedTensor2D_gpu_wrapper ( real ** extBoundary , int ** sideInfo , int ** elemToRank , int rankId , int N , int nVar , int nEl ) { ApplyFlip_MappedTensor2D_gpu <<< dim3 ( nVar , 4 , nEl ), dim3 ( 2 , 2 , N + 1 ), 0 , 0 >>> ( * extBoundary , * sideInfo , * elemToRank , rankId , N , nVar ); } } __global__ void ApplyFlip_MappedScalar3D_gpu ( real * extBoundary , int * sideInfo , int * elemToRank , int rankId , int N , int nVar ){ size_t ivar = blockIdx . x ; size_t s1 = blockIdx . y ; size_t e1 = blockIdx . z ; size_t i1 = threadIdx . x ; size_t j1 = threadIdx . x ; int e2 = sideInfo [ INDEX3 ( 2 , s1 , e1 , 5 , 4 )]; int s2 = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] - s2 * 10 ; int bcid = sideInfo [ INDEX3 ( 4 , s1 , e1 , 5 , 4 )]; __shared__ real extBuff [ 256 ]; extBuff [ i1 + ( N + 1 ) * j1 ] = extBoundary [ SCB_3D_INDEX ( i1 , j1 , ivar , s1 , e1 , N , nVar )]; __syncthreads (); if ( bcid == 0 ){ int neighborRank = elemToRank [ e2 ]; if ( neighborRank /= rankId ){ if ( flip == 2 ){ int i2 = N - j1 ; int j2 = i1 ; extBoundary [ SCB_3D_INDEX ( i1 , j1 , ivar , s1 , e1 , N , nVar )] = extBuff [ i2 + ( N + 1 ) * j2 ]; } else if ( flip == 3 ){ int i2 = N - i1 ; int j2 = N - j1 ; extBoundary [ SCB_3D_INDEX ( i1 , j1 , ivar , s1 , e1 , N , nVar )] = extBuff [ i2 + ( N + 1 ) * j2 ]; } else if ( flip == 4 ){ int i2 = j1 ; int j2 = N - i1 ; extBoundary [ SCB_3D_INDEX ( i1 , j1 , ivar , s1 , e1 , N , nVar )] = extBuff [ i2 + ( N + 1 ) * j2 ]; } } } } extern \"C\" { void ApplyFlip_MappedScalar3D_gpu_wrapper ( real ** extBoundary , int ** sideInfo , int ** elemToRank , int rankId , int N , int nVar , int nEl ) { ApplyFlip_MappedScalar3D_gpu <<< dim3 ( nVar , 6 , nEl ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * extBoundary , * sideInfo , * elemToRank , rankId , N , nVar ); } } __global__ void ApplyFlip_MappedVector3D_gpu ( real * extBoundary , int * sideInfo , int * elemToRank , int rankId , int N , int nVar ){ size_t ivar = blockIdx . x ; size_t s1 = blockIdx . y ; size_t e1 = blockIdx . z ; size_t dir = threadIdx . x ; size_t i1 = threadIdx . y ; size_t j1 = threadIdx . z ; int e2 = sideInfo [ INDEX3 ( 2 , s1 , e1 , 5 , 4 )]; int s2 = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] - s2 * 10 ; int bcid = sideInfo [ INDEX3 ( 4 , s1 , e1 , 5 , 4 )]; __shared__ real extBuff [ 768 ]; extBuff [ dir + 3 * ( i1 + ( N + 1 ) * j1 )] = extBoundary [ VEB_3D_INDEX ( dir + 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )]; __syncthreads (); if ( bcid == 0 ){ int neighborRank = elemToRank [ e2 ]; if ( neighborRank /= rankId ){ if ( flip == 2 ){ int i2 = N - j1 ; int j2 = i1 ; extBoundary [ VEB_3D_INDEX ( dir , i1 , j1 , ivar , s1 , e1 , N , nVar )] = extBuff [ dir + 3 * ( i2 + ( N + 1 ) * j2 )]; } else if ( flip == 3 ){ int i2 = N - i1 ; int j2 = N - j1 ; extBoundary [ VEB_3D_INDEX ( dir , i1 , j1 , ivar , s1 , e1 , N , nVar )] = extBuff [ dir + 3 * ( i2 + ( N + 1 ) * j2 )]; } else if ( flip == 4 ){ int i2 = j1 ; int j2 = N - i1 ; extBoundary [ VEB_3D_INDEX ( dir , i1 , j1 , ivar , s1 , e1 , N , nVar )] = extBuff [ dir + 3 * ( i2 + ( N + 1 ) * j2 )]; } } } } extern \"C\" { void ApplyFlip_MappedVector3D_gpu_wrapper ( real ** extBoundary , int ** sideInfo , int ** elemToRank , int rankId , int N , int nVar , int nEl ) { ApplyFlip_MappedVector3D_gpu <<< dim3 ( nVar , 6 , nEl ), dim3 ( 3 , N + 1 , N + 1 ), 0 , 0 >>> ( * extBoundary , * sideInfo , * elemToRank , rankId , N , nVar ); } } __global__ void ApplyFlip_MappedTensor3D_gpu ( real * extBoundary , int * sideInfo , int * elemToRank , int rankId , int N , int nVar ){ size_t ivar = blockIdx . x ; size_t s1 = blockIdx . y ; size_t e1 = blockIdx . z ; size_t dir = threadIdx . x ; size_t i1 = threadIdx . y ; size_t j1 = threadIdx . z ; size_t row = dir / 3 ; size_t col = dir - dir * row ; int e2 = sideInfo [ INDEX3 ( 2 , s1 , e1 , 5 , 4 )]; int s2 = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] / 10 ; int flip = sideInfo [ INDEX3 ( 3 , s1 , e1 , 5 , 4 )] - s2 * 10 ; int bcid = sideInfo [ INDEX3 ( 4 , s1 , e1 , 5 , 4 )]; __shared__ real extBuff [ 2304 ]; extBuff [ row + 3 * ( col + 3 * ( i1 + ( N + 1 ) * j1 ))] = extBoundary [ TEB_3D_INDEX ( row + 1 , col + 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )]; __syncthreads (); if ( bcid == 0 ){ int neighborRank = elemToRank [ e2 ]; if ( neighborRank /= rankId ){ if ( flip == 2 ){ int i2 = N - j1 ; int j2 = i1 ; extBoundary [ TEB_3D_INDEX ( row + 1 , col + 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = extBuff [ row + 3 * ( col + 3 * ( i2 + ( N + 1 ) * j2 ))]; } else if ( flip == 3 ){ int i2 = N - i1 ; int j2 = N - j1 ; extBoundary [ TEB_3D_INDEX ( row + 1 , col + 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = extBuff [ row + 3 * ( col + 3 * ( i2 + ( N + 1 ) * j2 ))]; } else if ( flip == 4 ){ int i2 = j1 ; int j2 = N - i1 ; extBoundary [ TEB_3D_INDEX ( row + 1 , col + 1 , i1 , j1 , ivar , s1 , e1 , N , nVar )] = extBuff [ row + 3 * ( col + 3 * ( i2 + ( N + 1 ) * j2 ))]; } } } } extern \"C\" { void ApplyFlip_MappedTensor3D_gpu_wrapper ( real ** extBoundary , int ** sideInfo , int ** elemToRank , int rankId , int N , int nVar , int nEl ) { ApplyFlip_MappedTensor3D_gpu <<< dim3 ( nVar , 6 , nEl ), dim3 ( 9 , N + 1 , N + 1 ), 0 , 0 >>> ( * extBoundary , * sideInfo , * elemToRank , rankId , N , nVar ); } }","tags":"","loc":"sourcefile/self_mappeddata.cpp.html"},{"title":"SELF_Advection3D.cpp – SELF","text":"Contents Source Code SELF_Advection3D.cpp Source Code #include <hip/hip_runtime.h> #include \"SELF_HIP_Macros.h\" #include <cstdio> __global__ void UpdateGRK3_Advection3D_gpu ( real * gRK3 , real * solution , real * dSdt , real rk3A , real rk3G , real dt , int N , int nVar ){ // Get the array indices from the GPU thread IDs size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; gRK3 [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] = rk3A * gRK3 [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] + dSdt [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; solution [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] += rk3G * dt * gRK3 [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; } extern \"C\" { void UpdateGRK3_Advection3D_gpu_wrapper ( real ** gRK3 , real ** solution , real ** dSdt , real rk3A , real rk3G , real dt , int N , int nVar , int nEl ) { UpdateGRK3_Advection3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * gRK3 , * solution , * dSdt , rk3A , rk3G , dt , N , nVar ); } } __global__ void InternalFlux_Advection3D_gpu ( real * flux , real * solution , real * velocity , real * dsdx , int N , int nVar ){ // Get the array indices from the GPU thread IDs size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; real Fx = velocity [ VE_3D_INDEX ( 1 , i , j , k , 0 , iEl , N , 1 )] * solution [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; real Fy = velocity [ VE_3D_INDEX ( 2 , i , j , k , 0 , iEl , N , 1 )] * solution [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; real Fz = velocity [ VE_3D_INDEX ( 3 , i , j , k , 0 , iEl , N , 1 )] * solution [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; flux [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )] * Fx + dsdx [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )] * Fy + dsdx [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] * Fz ; flux [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )] * Fx + dsdx [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )] * Fy + dsdx [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] * Fz ; flux [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )] * Fx + dsdx [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )] * Fy + dsdx [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] * Fz ; } extern \"C\" { void InternalFlux_Advection3D_gpu_wrapper ( real ** flux , real ** solution , real ** velocity , real ** dsdx , int N , int nVar , int nEl ) { // Block size is set to match the size of the element exactly // Grid size is set to ( number of tracers X number of elements ) // DGSEM is beautiful InternalFlux_Advection3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * flux , * solution , * velocity , * dsdx , N , nVar ); } } __global__ void InternalDiffusiveFlux_Advection3D_gpu ( real * flux , real * solutionGradient , real * dsdx , real diffusivity , int N , int nVar ){ // Get the array indices from the GPU thread IDs size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; real Fx = diffusivity * solutionGradient [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )]; real Fy = diffusivity * solutionGradient [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )]; real Fz = diffusivity * solutionGradient [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )]; // xi-component of the advective flux flux [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] += - ( dsdx [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )] * Fx + dsdx [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )] * Fy + dsdx [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] * Fz ); // eta-component of the advective flux flux [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] += - ( dsdx [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )] * Fx + dsdx [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )] * Fy + dsdx [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] * Fz ); flux [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] += - ( dsdx [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )] * Fx + dsdx [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )] * Fy + dsdx [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] * Fz ); } extern \"C\" { void InternalDiffusiveFlux_Advection3D_gpu_wrapper ( real ** flux , real ** solutionGradient , real ** dsdx , real diffusivity , int N , int nVar , int nEl ) { // Block size is set to match the size of the element exactly // Grid size is set to ( number of tracers X number of elements ) // DGSEM is beautiful InternalDiffusiveFlux_Advection3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * flux , * solutionGradient , * dsdx , diffusivity , N , nVar ); } } __global__ void SideFlux_Advection3D_gpu ( real * flux , real * boundarySol , real * extSol , real * velocity , real * nhat , real * nscale , int N , int nVar ){ // Get the array indices from the GPU thread IDs size_t iVar = blockIdx . x ; size_t iSide = blockIdx . y + 1 ; size_t iEl = blockIdx . z ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; // Calculate the normal velocity at the cell sides/edges float un = velocity [ VEB_3D_INDEX ( 1 , i , j , 0 , iSide , iEl , N , 1 )] * nhat [ VEB_3D_INDEX ( 1 , i , j , 0 , iSide , iEl , N , 1 )] + velocity [ VEB_3D_INDEX ( 2 , i , j , 0 , iSide , iEl , N , 1 )] * nhat [ VEB_3D_INDEX ( 2 , i , j , 0 , iSide , iEl , N , 1 )] + velocity [ VEB_3D_INDEX ( 3 , i , j , 0 , iSide , iEl , N , 1 )] * nhat [ VEB_3D_INDEX ( 3 , i , j , 0 , iSide , iEl , N , 1 )]; // Get the external and internal states for the Riemann solver float extState = extSol [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; float intState = boundarySol [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; float nmag = nscale [ SCB_3D_INDEX ( i , j , 0 , iSide , iEl , N , 1 )]; // Calculate the normal flux at the cell sides/edges flux [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )] = 0.5 * ( un * ( intState + extState ) - fabs ( un ) * ( extState - intState ) ) * nmag ; } extern \"C\" { void SideFlux_Advection3D_gpu_wrapper ( real ** flux , real ** boundarySol , real ** extSol , real ** velocity , real ** nhat , real ** nscale , int N , int nVar , int nEl ) { // Block size is set to match the size of the element exactly // Grid size is set to ( number of tracers X number of elements ) // DGSEM is beautiful SideFlux_Advection3D_gpu <<< dim3 ( nVar , 6 , nEl ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * flux , * boundarySol , * extSol , * velocity , * nhat , * nscale , N , nVar ); } } __global__ void SideDiffusiveFlux_Advection3D_gpu ( real * flux , real * boundarySolGrad , real * extSolGrad , real * nhat , real * nscale , real diffusivity , int N , int nVar ){ // Get the array indices from the GPU thread IDs size_t iVar = blockIdx . x ; size_t iSide = blockIdx . y + 1 ; size_t iEl = blockIdx . z ; size_t i = threadIdx . x ; size_t j = threadIdx . x ; float extState = extSolGrad [ VEB_3D_INDEX ( 1 , i , j , iVar , iSide , iEl , N , nVar )] * nhat [ VEB_3D_INDEX ( 1 , i , j , 0 , iSide , iEl , N , 1 )] + extSolGrad [ VEB_3D_INDEX ( 2 , i , j , iVar , iSide , iEl , N , nVar )] * nhat [ VEB_3D_INDEX ( 2 , i , j , 0 , iSide , iEl , N , 1 )] + extSolGrad [ VEB_3D_INDEX ( 3 , i , j , iVar , iSide , iEl , N , nVar )] * nhat [ VEB_3D_INDEX ( 3 , i , j , 0 , iSide , iEl , N , 1 )]; float intState = boundarySolGrad [ VEB_3D_INDEX ( 1 , i , j , iVar , iSide , iEl , N , nVar )] * nhat [ VEB_3D_INDEX ( 1 , i , j , 0 , iSide , iEl , N , 1 )] + boundarySolGrad [ VEB_3D_INDEX ( 2 , i , j , iVar , iSide , iEl , N , nVar )] * nhat [ VEB_3D_INDEX ( 2 , i , j , 0 , iSide , iEl , N , 1 )] + boundarySolGrad [ VEB_3D_INDEX ( 2 , i , j , iVar , iSide , iEl , N , nVar )] * nhat [ VEB_3D_INDEX ( 3 , i , j , 0 , iSide , iEl , N , 1 )]; float nmag = nscale [ SCB_3D_INDEX ( i , j , 0 , iSide , iEl , N , 1 )]; // Calculate the normal flux at the cell sides/edges flux [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )] += -0.5 * diffusivity * ( intState + extState ) * nmag ; } extern \"C\" { void SideDiffusiveFlux_Advection3D_gpu_wrapper ( real ** flux , real ** boundarySolGrad , real ** extSolGrad , real ** nhat , real ** nscale , real diffusivity , int N , int nVar , int nEl ) { SideDiffusiveFlux_Advection3D_gpu <<< dim3 ( nVar , 6 , nEl ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * flux , * boundarySolGrad , * extSolGrad , * nhat , * nscale , diffusivity , N , nVar ); } }","tags":"","loc":"sourcefile/self_advection3d.cpp.html"},{"title":"SELF_Lagrange.cpp – SELF","text":"Contents Source Code SELF_Lagrange.cpp Source Code #include <hip/hip_runtime.h> #include \"SELF_HIP_Macros.h\" /* // Template __global__ void Template_{1D|2D|3D}_gpu( , int N, int nVar, int nEl){ size_t iVar = blockIdx.x; size_t iEl = blockIdx.y; size_t i = threadIdx.x; size_t j = threadIdx.y; size_t k = threadIdx.z; // How to access scalars f[SC_1D_INDEX(i,iVar,iEl,N,nVar)]; f[SC_2D_INDEX(i,j,iVar,iEl,N,nVar)]; f[SC_3D_INDEX(i,j,k,iVar,iEl,N,nVar)]; // How to access vectors (2d) f[VE_2D_INDEX(1,i,j,iVar,iEl,N,nVar)]; f[VE_2D_INDEX(2,i,j,iVar,iEl,N,nVar)]; // How to access vectors (3d) f[VE_3D_INDEX(1,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(2,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(3,i,j,k,iVar,iEl,N,nVar)]; // How to access tensors (2d) f[TE_2D_INDEX(1,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(1,2,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,2,i,j,iVar,iEl,N,nVar)]; // How to access tensors (3d) f[TE_3D_INDEX(1,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,3,i,j,k,iVar,iEl,N,nVar)]; } extern \"C\" { void Template_{1D|2D|3D}_gpu_wrapper(int N, int nVar, int nEl) { hipLaunchKernelGGL((Template_{1D|2D|3D}_gpu), dim3(nVar,nEl,1), dim3(N+1,N+1,N+1), 0, 0,  N, M, nVar); } } */ // ScalarGridInterp_1D // __global__ void ScalarGridInterp_1D_gpu ( real * iMatrix , real * f , real * fInterp , int N , int M , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; real fm = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fm += f [ SC_1D_INDEX ( ii , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; } fInterp [ SC_1D_INDEX ( i , iVar , iEl , M , nVar )] = fm ; } extern \"C\" { void ScalarGridInterp_1D_gpu_wrapper ( real ** iMatrix , real ** f , real ** fInterp , int N , int M , int nVar , int nEl ) { ScalarGridInterp_1D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( M + 1 , 1 , 1 ), 0 , 0 >>> ( * iMatrix , * f , * fInterp , N , M , nVar ); } } // ScalarGridInterp_2D // __global__ void ScalarGridInterp_2D_gpu ( real * iMatrix , real * f , real * fInterp , int N , int M , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; real fij = 0.0 ; real fi = 0.0 ; for ( int jj = 0 ; jj < N + 1 ; jj ++ ) { fi = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fi += f [ SC_2D_INDEX ( ii , jj , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; } fij += fi * iMatrix [ jj + j * ( N + 1 )]; } fInterp [ SC_2D_INDEX ( i , j , iVar , iEl , M , nVar )] = fij ; } extern \"C\" { void ScalarGridInterp_2D_gpu_wrapper ( real ** iMatrix , real ** f , real ** fInterp , int N , int M , int nVar , int nEl ) { ScalarGridInterp_2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( M + 1 , M + 1 , 1 ), 0 , 0 >>> ( * iMatrix , * f , * fInterp , N , M , nVar ); } } // VectorGridInterp_2D // __global__ void VectorGridInterp_2D_gpu ( real * iMatrix , real * f , real * fInterp , int N , int M , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; real fij [ 2 ] = { 0.0 }; real fi [ 2 ] = { 0.0 }; for ( int jj = 0 ; jj < N + 1 ; jj ++ ) { fi [ 0 ] = 0.0 ; fi [ 1 ] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fi [ 0 ] += f [ VE_2D_INDEX ( 1 , ii , jj , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 1 ] += f [ VE_2D_INDEX ( 2 , ii , jj , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; } fij [ 0 ] += fi [ 0 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 1 ] += fi [ 1 ] * iMatrix [ jj + j * ( N + 1 )]; } fInterp [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , M , nVar )] = fij [ 0 ]; fInterp [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , M , nVar )] = fij [ 1 ]; } extern \"C\" { void VectorGridInterp_2D_gpu_wrapper ( real ** iMatrix , real ** f , real ** fInterp , int N , int M , int nVar , int nEl ) { VectorGridInterp_2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( M + 1 , M + 1 , 1 ), 0 , 0 >>> ( * iMatrix , * f , * fInterp , N , M , nVar ); } } // TensorGridInterp_2D // __global__ void TensorGridInterp_2D_gpu ( real * iMatrix , real * f , real * fInterp , int N , int M , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; real fij [ 4 ] = { 0.0 }; real fi [ 4 ] = { 0.0 }; for ( int jj = 0 ; jj < N + 1 ; jj ++ ) { fi [ 0 ] = 0.0 ; fi [ 1 ] = 0.0 ; fi [ 2 ] = 0.0 ; fi [ 3 ] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fi [ 0 ] += f [ TE_2D_INDEX ( 1 , 1 , ii , jj , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 1 ] += f [ TE_2D_INDEX ( 2 , 1 , ii , jj , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 2 ] += f [ TE_2D_INDEX ( 1 , 2 , ii , jj , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 3 ] += f [ TE_2D_INDEX ( 2 , 2 , ii , jj , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; } fij [ 0 ] += fi [ 0 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 1 ] += fi [ 1 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 2 ] += fi [ 2 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 3 ] += fi [ 3 ] * iMatrix [ jj + j * ( N + 1 )]; } fInterp [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , M , nVar )] = fij [ 0 ]; fInterp [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , M , nVar )] = fij [ 1 ]; fInterp [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , M , nVar )] = fij [ 2 ]; fInterp [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , M , nVar )] = fij [ 3 ]; } extern \"C\" { void TensorGridInterp_2D_gpu_wrapper ( real ** iMatrix , real ** f , real ** fInterp , int N , int M , int nVar , int nEl ) { TensorGridInterp_2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( M + 1 , M + 1 , 1 ), 0 , 0 >>> ( * iMatrix , * f , * fInterp , N , M , nVar ); } } // ScalarGridInterp_3D // __global__ void ScalarGridInterp_3D_gpu ( real * iMatrix , real * f , real * fInterp , int N , int M , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; real fijk = 0.0 ; real fij = 0.0 ; real fi = 0.0 ; for ( int kk = 0 ; kk < N + 1 ; kk ++ ) { fij = 0.0 ; for ( int jj = 0 ; jj < N + 1 ; jj ++ ) { fi = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fi += f [ SC_3D_INDEX ( ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; } fij += fi * iMatrix [ jj + j * ( N + 1 )]; } fijk += fij * iMatrix [ kk + k * ( N + 1 )]; } fInterp [ SC_3D_INDEX ( i , j , k , iVar , iEl , M , nVar )] = fijk ; } extern \"C\" { void ScalarGridInterp_3D_gpu_wrapper ( real ** iMatrix , real ** f , real ** fInterp , int N , int M , int nVar , int nEl ) { ScalarGridInterp_3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( M + 1 , M + 1 , M + 1 ), 0 , 0 >>> ( * iMatrix , * f , * fInterp , N , M , nVar ); } } // VectorGridInterp_3D // __global__ void VectorGridInterp_3D_gpu ( real * iMatrix , real * f , real * fInterp , int N , int M , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; real fijk [ 3 ] = { 0.0 }; real fij [ 3 ] = { 0.0 }; real fi [ 3 ] = { 0.0 }; for ( int kk = 0 ; kk < N + 1 ; kk ++ ) { fij [ 0 ] = 0.0 ; fij [ 1 ] = 0.0 ; fij [ 2 ] = 0.0 ; for ( int jj = 0 ; jj < N + 1 ; jj ++ ) { fi [ 0 ] = 0.0 ; fi [ 1 ] = 0.0 ; fi [ 2 ] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fi [ 0 ] += f [ VE_3D_INDEX ( 1 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 1 ] += f [ VE_3D_INDEX ( 2 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 2 ] += f [ VE_3D_INDEX ( 3 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; } fij [ 0 ] += fi [ 0 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 1 ] += fi [ 1 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 2 ] += fi [ 2 ] * iMatrix [ jj + j * ( N + 1 )]; } fijk [ 0 ] += fij [ 0 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 1 ] += fij [ 1 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 2 ] += fij [ 2 ] * iMatrix [ kk + k * ( N + 1 )]; } fInterp [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 0 ]; fInterp [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 1 ]; fInterp [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 2 ]; } extern \"C\" { void VectorGridInterp_3D_gpu_wrapper ( real ** iMatrix , real ** f , real ** fInterp , int N , int M , int nVar , int nEl ) { VectorGridInterp_3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( M + 1 , M + 1 , M + 1 ), 0 , 0 >>> ( * iMatrix , * f , * fInterp , N , M , nVar ); } } // TensorGridInterp_3D // __global__ void TensorGridInterp_3D_gpu ( real * iMatrix , real * f , real * fInterp , int N , int M , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; real fijk [ 9 ] = { 0.0 }; real fij [ 9 ] = { 0.0 }; real fi [ 9 ] = { 0.0 }; for ( int kk = 0 ; kk < N + 1 ; kk ++ ) { fij [ 0 ] = 0.0 ; fij [ 1 ] = 0.0 ; fij [ 2 ] = 0.0 ; fij [ 3 ] = 0.0 ; fij [ 4 ] = 0.0 ; fij [ 5 ] = 0.0 ; fij [ 6 ] = 0.0 ; fij [ 7 ] = 0.0 ; fij [ 8 ] = 0.0 ; for ( int jj = 0 ; jj < N + 1 ; jj ++ ) { fi [ 0 ] = 0.0 ; fi [ 1 ] = 0.0 ; fi [ 2 ] = 0.0 ; fi [ 3 ] = 0.0 ; fi [ 4 ] = 0.0 ; fi [ 5 ] = 0.0 ; fi [ 6 ] = 0.0 ; fi [ 7 ] = 0.0 ; fi [ 8 ] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fi [ 0 ] += f [ TE_3D_INDEX ( 1 , 1 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 1 ] += f [ TE_3D_INDEX ( 2 , 1 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 2 ] += f [ TE_3D_INDEX ( 3 , 1 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 3 ] += f [ TE_3D_INDEX ( 1 , 2 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 4 ] += f [ TE_3D_INDEX ( 2 , 2 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 5 ] += f [ TE_3D_INDEX ( 3 , 2 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 6 ] += f [ TE_3D_INDEX ( 1 , 3 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 7 ] += f [ TE_3D_INDEX ( 2 , 3 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 8 ] += f [ TE_3D_INDEX ( 3 , 3 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; } fij [ 0 ] += fi [ 0 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 1 ] += fi [ 1 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 2 ] += fi [ 2 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 3 ] += fi [ 3 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 4 ] += fi [ 4 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 5 ] += fi [ 5 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 6 ] += fi [ 6 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 7 ] += fi [ 7 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 8 ] += fi [ 8 ] * iMatrix [ jj + j * ( N + 1 )]; } fijk [ 0 ] += fij [ 0 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 1 ] += fij [ 1 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 2 ] += fij [ 2 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 3 ] += fij [ 3 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 4 ] += fij [ 4 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 5 ] += fij [ 5 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 6 ] += fij [ 6 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 7 ] += fij [ 7 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 8 ] += fij [ 8 ] * iMatrix [ kk + k * ( N + 1 )]; } fInterp [ TE_3D_INDEX ( 1 , 1 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 0 ]; fInterp [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 1 ]; fInterp [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 2 ]; fInterp [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 3 ]; fInterp [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 4 ]; fInterp [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 5 ]; fInterp [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 6 ]; fInterp [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 7 ]; fInterp [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 8 ]; } extern \"C\" { void TensorGridInterp_3D_gpu_wrapper ( real ** iMatrix , real ** f , real ** fInterp , int N , int M , int nVar , int nEl ) { TensorGridInterp_3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( M + 1 , M + 1 , M + 1 ), 0 , 0 >>> ( * iMatrix , * f , * fInterp , N , M , nVar ); } } // ScalarBoundaryInterp_1D // __global__ void ScalarBoundaryInterp_1D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t bid = threadIdx . x ; real fb = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fb += f [ SC_1D_INDEX ( ii , iVar , iEl , N , nVar )] * bMatrix [ ii + bid * ( N + 1 )]; } fBound [ SCB_1D_INDEX ( iVar , bid , iEl , N , nVar )] = fb ; } extern \"C\" { void ScalarBoundaryInterp_1D_gpu_wrapper ( real ** bMatrix , real ** f , real ** fBound , int N , int nVar , int nEl ) { ScalarBoundaryInterp_1D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( 2 , 1 , 1 ), 0 , 0 >>> ( * bMatrix , * f , * fBound , N , nVar ); } } // ScalarBoundaryInterp_2D // __global__ void ScalarBoundaryInterp_2D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; real fb [ 4 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fb [ 0 ] += f [ SC_2D_INDEX ( i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 1 ] += f [ SC_2D_INDEX ( ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 2 ] += f [ SC_2D_INDEX ( i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 3 ] += f [ SC_2D_INDEX ( ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West } fBound [ SCB_2D_INDEX ( i , iVar , 1 , iEl , N , nVar )] = fb [ 0 ]; fBound [ SCB_2D_INDEX ( i , iVar , 2 , iEl , N , nVar )] = fb [ 1 ]; fBound [ SCB_2D_INDEX ( i , iVar , 3 , iEl , N , nVar )] = fb [ 2 ]; fBound [ SCB_2D_INDEX ( i , iVar , 4 , iEl , N , nVar )] = fb [ 3 ]; } extern \"C\" { void ScalarBoundaryInterp_2D_gpu_wrapper ( real ** bMatrix , real ** f , real ** fBound , int N , int nVar , int nEl ) { ScalarBoundaryInterp_2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 >>> ( * bMatrix , * f , * fBound , N , nVar ); } } // VectorBoundaryInterp_2D // __global__ void VectorBoundaryInterp_2D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t idir = threadIdx . x + 1 ; size_t i = threadIdx . y ; real fb [ 4 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fb [ 0 ] += f [ VE_2D_INDEX ( idir , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 1 ] += f [ VE_2D_INDEX ( idir , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 2 ] += f [ VE_2D_INDEX ( idir , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 3 ] += f [ VE_2D_INDEX ( idir , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West } fBound [ VEB_2D_INDEX ( idir , i , iVar , 1 , iEl , N , nVar )] = fb [ 0 ]; fBound [ VEB_2D_INDEX ( idir , i , iVar , 2 , iEl , N , nVar )] = fb [ 1 ]; fBound [ VEB_2D_INDEX ( idir , i , iVar , 3 , iEl , N , nVar )] = fb [ 2 ]; fBound [ VEB_2D_INDEX ( idir , i , iVar , 4 , iEl , N , nVar )] = fb [ 3 ]; } extern \"C\" { void VectorBoundaryInterp_2D_gpu_wrapper ( real ** bMatrix , real ** f , real ** fBound , int N , int nVar , int nEl ) { VectorBoundaryInterp_2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( 2 , N + 1 , 1 ), 0 , 0 >>> ( * bMatrix , * f , * fBound , N , nVar ); } } // TensorBoundaryInterp_2D // __global__ void TensorBoundaryInterp_2D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; real fb [ 16 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fb [ 0 ] += f [ TE_2D_INDEX ( 1 , 1 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 1 ] += f [ TE_2D_INDEX ( 1 , 1 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 2 ] += f [ TE_2D_INDEX ( 1 , 1 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 3 ] += f [ TE_2D_INDEX ( 1 , 1 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West fb [ 4 ] += f [ TE_2D_INDEX ( 2 , 1 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 5 ] += f [ TE_2D_INDEX ( 2 , 1 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 6 ] += f [ TE_2D_INDEX ( 2 , 1 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 7 ] += f [ TE_2D_INDEX ( 2 , 1 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West fb [ 8 ] += f [ TE_2D_INDEX ( 1 , 2 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 9 ] += f [ TE_2D_INDEX ( 1 , 2 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 10 ] += f [ TE_2D_INDEX ( 1 , 2 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 11 ] += f [ TE_2D_INDEX ( 1 , 2 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West fb [ 12 ] += f [ TE_2D_INDEX ( 2 , 2 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 13 ] += f [ TE_2D_INDEX ( 2 , 2 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 14 ] += f [ TE_2D_INDEX ( 2 , 2 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 15 ] += f [ TE_2D_INDEX ( 2 , 2 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West } fBound [ TEB_2D_INDEX ( 1 , 1 , i , iVar , 1 , iEl , N , nVar )] = fb [ 0 ]; fBound [ TEB_2D_INDEX ( 1 , 1 , i , iVar , 2 , iEl , N , nVar )] = fb [ 1 ]; fBound [ TEB_2D_INDEX ( 1 , 1 , i , iVar , 3 , iEl , N , nVar )] = fb [ 2 ]; fBound [ TEB_2D_INDEX ( 1 , 1 , i , iVar , 4 , iEl , N , nVar )] = fb [ 3 ]; fBound [ TEB_2D_INDEX ( 2 , 1 , i , iVar , 1 , iEl , N , nVar )] = fb [ 4 ]; fBound [ TEB_2D_INDEX ( 2 , 1 , i , iVar , 2 , iEl , N , nVar )] = fb [ 5 ]; fBound [ TEB_2D_INDEX ( 2 , 1 , i , iVar , 3 , iEl , N , nVar )] = fb [ 6 ]; fBound [ TEB_2D_INDEX ( 2 , 1 , i , iVar , 4 , iEl , N , nVar )] = fb [ 7 ]; fBound [ TEB_2D_INDEX ( 1 , 2 , i , iVar , 1 , iEl , N , nVar )] = fb [ 8 ]; fBound [ TEB_2D_INDEX ( 1 , 2 , i , iVar , 2 , iEl , N , nVar )] = fb [ 9 ]; fBound [ TEB_2D_INDEX ( 1 , 2 , i , iVar , 3 , iEl , N , nVar )] = fb [ 10 ]; fBound [ TEB_2D_INDEX ( 1 , 2 , i , iVar , 4 , iEl , N , nVar )] = fb [ 11 ]; fBound [ TEB_2D_INDEX ( 2 , 2 , i , iVar , 1 , iEl , N , nVar )] = fb [ 12 ]; fBound [ TEB_2D_INDEX ( 2 , 2 , i , iVar , 2 , iEl , N , nVar )] = fb [ 13 ]; fBound [ TEB_2D_INDEX ( 2 , 2 , i , iVar , 3 , iEl , N , nVar )] = fb [ 14 ]; fBound [ TEB_2D_INDEX ( 2 , 2 , i , iVar , 4 , iEl , N , nVar )] = fb [ 15 ]; } extern \"C\" { void TensorBoundaryInterp_2D_gpu_wrapper ( real ** bMatrix , real ** f , real ** fBound , int N , int nVar , int nEl ) { TensorBoundaryInterp_2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 >>> ( * bMatrix , * f , * fBound , N , nVar ); } } // ScalarBoundaryInterp_3D // __global__ void ScalarBoundaryInterp_3D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; real fb [ 6 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fb [ 0 ] += f [ SC_3D_INDEX ( i , j , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // Bottom fb [ 1 ] += f [ SC_3D_INDEX ( i , ii , j , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 2 ] += f [ SC_3D_INDEX ( ii , i , j , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 3 ] += f [ SC_3D_INDEX ( i , ii , j , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 4 ] += f [ SC_3D_INDEX ( ii , i , j , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West fb [ 5 ] += f [ SC_3D_INDEX ( i , j , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // Top } fBound [ SCB_3D_INDEX ( i , j , iVar , 1 , iEl , N , nVar )] = fb [ 0 ]; fBound [ SCB_3D_INDEX ( i , j , iVar , 2 , iEl , N , nVar )] = fb [ 1 ]; fBound [ SCB_3D_INDEX ( i , j , iVar , 3 , iEl , N , nVar )] = fb [ 2 ]; fBound [ SCB_3D_INDEX ( i , j , iVar , 4 , iEl , N , nVar )] = fb [ 3 ]; fBound [ SCB_3D_INDEX ( i , j , iVar , 5 , iEl , N , nVar )] = fb [ 4 ]; fBound [ SCB_3D_INDEX ( i , j , iVar , 6 , iEl , N , nVar )] = fb [ 5 ]; } extern \"C\" { void ScalarBoundaryInterp_3D_gpu_wrapper ( real ** bMatrix , real ** f , real ** fBound , int N , int nVar , int nEl ) { ScalarBoundaryInterp_3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * bMatrix , * f , * fBound , N , nVar ); } } // VectorBoundaryInterp_3D // __global__ void VectorBoundaryInterp_3D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t idir = threadIdx . x + 1 ; size_t i = threadIdx . y ; size_t j = threadIdx . z ; real fb [ 6 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fb [ 0 ] += f [ VE_3D_INDEX ( idir , i , j , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // Bottom fb [ 1 ] += f [ VE_3D_INDEX ( idir , i , ii , j , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 2 ] += f [ VE_3D_INDEX ( idir , ii , i , j , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 3 ] += f [ VE_3D_INDEX ( idir , i , ii , j , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 4 ] += f [ VE_3D_INDEX ( idir , ii , i , j , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West fb [ 5 ] += f [ VE_3D_INDEX ( idir , i , j , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // Top } fBound [ VEB_3D_INDEX ( idir , i , j , iVar , 1 , iEl , N , nVar )] = fb [ 0 ]; fBound [ VEB_3D_INDEX ( idir , i , j , iVar , 2 , iEl , N , nVar )] = fb [ 1 ]; fBound [ VEB_3D_INDEX ( idir , i , j , iVar , 3 , iEl , N , nVar )] = fb [ 2 ]; fBound [ VEB_3D_INDEX ( idir , i , j , iVar , 4 , iEl , N , nVar )] = fb [ 3 ]; fBound [ VEB_3D_INDEX ( idir , i , j , iVar , 5 , iEl , N , nVar )] = fb [ 4 ]; fBound [ VEB_3D_INDEX ( idir , i , j , iVar , 6 , iEl , N , nVar )] = fb [ 5 ]; } extern \"C\" { void VectorBoundaryInterp_3D_gpu_wrapper ( real ** bMatrix , real ** f , real ** fBound , int N , int nVar , int nEl ) { VectorBoundaryInterp_3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( 3 , N + 1 , N + 1 ), 0 , 0 >>> ( * bMatrix , * f , * fBound , N , nVar ); } } // TensorBoundaryInterp_3D // __global__ void TensorBoundaryInterp_3D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; for ( int col = 1 ; col <= 3 ; col ++ ){ for ( int row = 1 ; row <= 3 ; row ++ ){ fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 1 , iEl , N , nVar )] = 0.0 ; fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 2 , iEl , N , nVar )] = 0.0 ; fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 3 , iEl , N , nVar )] = 0.0 ; fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 4 , iEl , N , nVar )] = 0.0 ; fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 5 , iEl , N , nVar )] = 0.0 ; fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 6 , iEl , N , nVar )] = 0.0 ; } } for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { for ( int col = 1 ; col <= 3 ; col ++ ){ for ( int row = 1 ; row <= 3 ; row ++ ){ fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 1 , iEl , N , nVar )] += f [ TE_3D_INDEX ( row , col , i , j , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // Bottom fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 2 , iEl , N , nVar )] += f [ TE_3D_INDEX ( row , col , i , ii , j , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 3 , iEl , N , nVar )] += f [ TE_3D_INDEX ( row , col , ii , i , j , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 4 , iEl , N , nVar )] += f [ TE_3D_INDEX ( row , col , i , ii , j , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 5 , iEl , N , nVar )] += f [ TE_3D_INDEX ( row , col , ii , i , j , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 6 , iEl , N , nVar )] += f [ TE_3D_INDEX ( row , col , i , j , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // Top } } } } extern \"C\" { void TensorBoundaryInterp_3D_gpu_wrapper ( real ** bMatrix , real ** f , real ** fBound , int N , int nVar , int nEl ) { TensorBoundaryInterp_3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * bMatrix , * f , * fBound , N , nVar ); } } // Derivative_1D // __global__ void Derivative_1D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; real fm = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fm += f [ SC_1D_INDEX ( ii , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; } df [ SC_1D_INDEX ( i , iVar , iEl , N , nVar )] = fm ; } extern \"C\" { void Derivative_1D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { Derivative_1D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 >>> ( * dMatrix , * f , * df , N , nVar ); } } // DGDerivative_1D // __global__ void DGDerivative_1D_gpu ( real * dMatrix , real * bMatrix , real * qWeight , real * f , real * bf , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; real fm = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fm += f [ SC_1D_INDEX ( ii , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; } fm += ( bMatrix [ i + ( N + 1 )] * bf [ SCB_1D_INDEX ( iVar , 1 , iEl , N , nVar )] - bMatrix [ i ] * bf [ SCB_1D_INDEX ( iVar , 0 , iEl , N , nVar )]) / qWeight [ i ]; df [ SC_1D_INDEX ( i , iVar , iEl , N , nVar )] = fm ; } extern \"C\" { void DGDerivative_1D_gpu_wrapper ( real ** dMatrix , real ** bMatrix , real ** qWeight , real ** f , real ** bf , real ** df , int N , int nVar , int nEl ) { DGDerivative_1D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 >>> ( * dMatrix , * bMatrix , * qWeight , * f , * bf , * df , N , nVar ); } } // ScalarGradient_2D // __global__ void ScalarGradient_2D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; real fs = 0.0 ; real fp = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fs += f [ SC_2D_INDEX ( ii , j , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; fp += f [ SC_2D_INDEX ( i , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; } df [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] = fs ; df [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] = fp ; } extern \"C\" { void ScalarGradient_2D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { ScalarGradient_2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * dMatrix , * f , * df , N , nVar ); } } __global__ void ScalarDGGradient_2D_gpu ( real * dgMatrix , real * bMatrix , real * qWeights , real * f , real * bf , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; real fs = 0.0 ; real fp = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fs += f [ SC_2D_INDEX ( ii , j , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )]; fp += f [ SC_2D_INDEX ( i , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )]; } fs += ( bf [ SCB_2D_INDEX ( j , iVar , 2 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] - bf [ SCB_2D_INDEX ( j , iVar , 4 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ]; fp += ( bf [ SCB_2D_INDEX ( i , iVar , 3 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] - bf [ SCB_2D_INDEX ( i , iVar , 1 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ]; df [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] = fs ; df [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] = fp ; } extern \"C\" { void ScalarDGGradient_2D_gpu_wrapper ( real ** dgMatrix , real ** bMatrix , real ** qWeights , real ** f , real ** bf , real ** df , int N , int nVar , int nEl ) { ScalarDGGradient_2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * dgMatrix , * bMatrix , * qWeights , * f , * bf , * df , N , nVar ); } } // VectorGradient_2D // __global__ void VectorGradient_2D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; real dfloc [ 4 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { dfloc [ 0 ] += f [ VE_2D_INDEX ( 1 , ii , j , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; dfloc [ 1 ] += f [ VE_2D_INDEX ( 2 , ii , j , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; dfloc [ 2 ] += f [ VE_2D_INDEX ( 1 , i , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; dfloc [ 3 ] += f [ VE_2D_INDEX ( 2 , i , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; } df [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , N , nVar )] = dfloc [ 0 ]; df [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )] = dfloc [ 1 ]; df [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )] = dfloc [ 2 ]; df [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , N , nVar )] = dfloc [ 3 ]; } extern \"C\" { void VectorGradient_2D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { VectorGradient_2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * dMatrix , * f , * df , N , nVar ); } } // VectorDGGradient_2D // __global__ void VectorDGGradient_2D_gpu ( real * dgMatrix , real * bMatrix , real * qWeights , real * f , real * bf , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; real dfloc [ 4 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { dfloc [ 0 ] += f [ VE_2D_INDEX ( 1 , ii , j , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )]; dfloc [ 1 ] += f [ VE_2D_INDEX ( 2 , ii , j , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )]; dfloc [ 2 ] += f [ VE_2D_INDEX ( 1 , i , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )]; dfloc [ 3 ] += f [ VE_2D_INDEX ( 2 , i , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )]; } dfloc [ 0 ] += ( bf [ VEB_2D_INDEX ( 1 , j , iVar , 2 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] - bf [ VEB_2D_INDEX ( 1 , j , iVar , 4 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ]; dfloc [ 1 ] += ( bf [ VEB_2D_INDEX ( 2 , j , iVar , 2 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] - bf [ VEB_2D_INDEX ( 2 , j , iVar , 4 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ]; dfloc [ 2 ] += ( bf [ VEB_2D_INDEX ( 1 , i , iVar , 3 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] - bf [ VEB_2D_INDEX ( 1 , i , iVar , 1 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ]; dfloc [ 3 ] += ( bf [ VEB_2D_INDEX ( 2 , i , iVar , 3 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] - bf [ VEB_2D_INDEX ( 2 , i , iVar , 1 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ]; df [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , N , nVar )] = dfloc [ 0 ]; df [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )] = dfloc [ 1 ]; df [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )] = dfloc [ 2 ]; df [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , N , nVar )] = dfloc [ 3 ]; } extern \"C\" { void VectorDGGradient_2D_gpu_wrapper ( real ** dMatrix , real ** bMatrix , real ** qWeights , real ** f , real ** bf , real ** df , int N , int nVar , int nEl ) { VectorDGGradient_2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * dMatrix , * bMatrix , * qWeights , * f , * bf , * df , N , nVar ); } } // VectorDivergence_2D // __global__ void VectorDivergence_2D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; real dfloc = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { dfloc += f [ VE_2D_INDEX ( 1 , ii , j , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )] + f [ VE_2D_INDEX ( 2 , i , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; } df [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] = dfloc ; } extern \"C\" { void VectorDivergence_2D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { VectorDivergence_2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * dMatrix , * f , * df , N , nVar ); } } // VectorDGDivergence_2D // __global__ void VectorDGDivergence_2D_gpu ( real * dgMatrix , real * bMatrix , real * qWeights , real * f , real * bf , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; df [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { df [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] += f [ VE_2D_INDEX ( 1 , ii , j , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )] + f [ VE_2D_INDEX ( 2 , i , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )]; } df [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] += ( bf [ SCB_2D_INDEX ( j , iVar , 2 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] + bf [ SCB_2D_INDEX ( j , iVar , 4 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ] + ( bf [ SCB_2D_INDEX ( i , iVar , 3 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] + bf [ SCB_2D_INDEX ( i , iVar , 1 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ]; } extern \"C\" { void VectorDGDivergence_2D_gpu_wrapper ( real ** dgMatrix , real ** bMatrix , real ** qWeights , real ** f , real ** bf , real ** df , int N , int nVar , int nEl ) { VectorDGDivergence_2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * dgMatrix , * bMatrix , * qWeights , * f , * bf , * df , N , nVar ); } } // VectorCurl_2D // __global__ void VectorCurl_2D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; real dfloc = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { dfloc += f [ VE_2D_INDEX ( 2 , i , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )] - f [ VE_2D_INDEX ( 1 , ii , j , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; } df [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] = dfloc ; } extern \"C\" { void VectorCurl_2D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { VectorCurl_2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * dMatrix , * f , * df , N , nVar ); } } // TensorDivergence_2D // __global__ void TensorDivergence_2D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; real df1 = 0.0 ; real df2 = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { df1 += f [ TE_2D_INDEX ( 1 , 1 , ii , j , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )] + f [ TE_2D_INDEX ( 2 , 1 , i , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; df2 += f [ TE_2D_INDEX ( 1 , 2 , ii , j , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )] + f [ TE_2D_INDEX ( 2 , 2 , i , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; } df [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] = df1 ; df [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] = df2 ; } extern \"C\" { void TensorDivergence_2D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { TensorDivergence_2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * dMatrix , * f , * df , N , nVar ); } } // TensorDGDivergence_2D // __global__ void TensorDGDivergence_2D_gpu ( real * dgMatrix , real * bMatrix , real * qWeights , real * f , real * bf , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; df [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] = 0.0 ; df [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { df [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] += f [ TE_2D_INDEX ( 1 , 1 , ii , j , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )] + f [ TE_2D_INDEX ( 2 , 1 , i , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )]; df [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] += f [ TE_2D_INDEX ( 1 , 2 , ii , j , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )] + f [ TE_2D_INDEX ( 2 , 2 , i , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )]; } df [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] += ( bf [ TEB_2D_INDEX ( 1 , 1 , j , iVar , 2 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] + bf [ TEB_2D_INDEX ( 1 , 1 , j , iVar , 4 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ] + ( bf [ TEB_2D_INDEX ( 2 , 1 , i , iVar , 3 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] + bf [ TEB_2D_INDEX ( 2 , 1 , i , iVar , 1 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ]; df [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] += ( bf [ TEB_2D_INDEX ( 1 , 2 , j , iVar , 2 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] + bf [ TEB_2D_INDEX ( 1 , 2 , j , iVar , 4 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ] + ( bf [ TEB_2D_INDEX ( 2 , 2 , i , iVar , 3 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] + bf [ TEB_2D_INDEX ( 2 , 2 , i , iVar , 1 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ]; } extern \"C\" { void TensorDGDivergence_2D_gpu_wrapper ( real ** dgMatrix , real ** bMatrix , real ** qWeights , real ** f , real ** bf , real ** df , int N , int nVar , int nEl ) { TensorDGDivergence_2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * dgMatrix , * bMatrix , * qWeights , * f , * bf , * df , N , nVar ); } } // ScalarGradient_3D // __global__ void ScalarGradient_3D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; real dfloc [ 3 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { dfloc [ 0 ] += f [ SC_3D_INDEX ( ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; dfloc [ 1 ] += f [ SC_3D_INDEX ( i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; dfloc [ 2 ] += f [ SC_3D_INDEX ( i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; } df [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 0 ]; df [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 1 ]; df [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 2 ]; } extern \"C\" { void ScalarGradient_3D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { ScalarGradient_3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * dMatrix , * f , * df , N , nVar ); } } // VectorGradient_3D // __global__ void VectorGradient_3D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; real dfloc [ 9 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { dfloc [ 0 ] += f [ VE_3D_INDEX ( 1 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; dfloc [ 1 ] += f [ VE_3D_INDEX ( 2 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; dfloc [ 2 ] += f [ VE_3D_INDEX ( 3 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; dfloc [ 3 ] += f [ VE_3D_INDEX ( 1 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; dfloc [ 4 ] += f [ VE_3D_INDEX ( 2 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; dfloc [ 5 ] += f [ VE_3D_INDEX ( 3 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; dfloc [ 6 ] += f [ VE_3D_INDEX ( 1 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; dfloc [ 7 ] += f [ VE_3D_INDEX ( 2 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; dfloc [ 8 ] += f [ VE_3D_INDEX ( 3 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; } df [ TE_3D_INDEX ( 1 , 1 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 0 ]; df [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 1 ]; df [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 2 ]; df [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 3 ]; df [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 4 ]; df [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 5 ]; df [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 6 ]; df [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 7 ]; df [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 8 ]; } extern \"C\" { void VectorGradient_3D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { VectorGradient_3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * dMatrix , * f , * df , N , nVar ); } } // VectorDivergence_3D // __global__ void VectorDivergence_3D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; df [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { df [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] += f [ VE_3D_INDEX ( 1 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )] + f [ VE_3D_INDEX ( 2 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )] + f [ VE_3D_INDEX ( 3 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; } } extern \"C\" { void VectorDivergence_3D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { VectorDivergence_3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * dMatrix , * f , * df , N , nVar ); } } // VectorDGDivergence_3D // __global__ void VectorDGDivergence_3D_gpu ( real * dgMatrix , real * bMatrix , real * qWeights , real * f , real * bf , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; df [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { df [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] += f [ VE_3D_INDEX ( 1 , ii , j , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )] + f [ VE_3D_INDEX ( 2 , i , ii , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )] + f [ VE_3D_INDEX ( 3 , i , j , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + k * ( N + 1 )]; } df [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] += ( bf [ SCB_3D_INDEX ( j , k , iVar , 3 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] + bf [ SCB_3D_INDEX ( j , k , iVar , 5 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ] + ( bf [ SCB_3D_INDEX ( i , k , iVar , 4 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] + bf [ SCB_3D_INDEX ( i , k , iVar , 2 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ] + ( bf [ SCB_3D_INDEX ( i , j , iVar , 6 , iEl , N , nVar )] * bMatrix [ k + ( N + 1 )] + bf [ SCB_3D_INDEX ( i , j , iVar , 1 , iEl , N , nVar )] * bMatrix [ k ]) / qWeights [ k ]; } extern \"C\" { void VectorDGDivergence_3D_gpu_wrapper ( real ** dgMatrix , real ** bMatrix , real ** qWeights , real ** f , real ** bf , real ** df , int N , int nVar , int nEl ) { VectorDGDivergence_3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * dgMatrix , * bMatrix , * qWeights , * f , * bf , * df , N , nVar ); } } // VectorCurl_3D // __global__ void VectorCurl_3D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; real dfloc [ 3 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { dfloc [ 0 ] += f [ VE_3D_INDEX ( 3 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )] - f [ VE_3D_INDEX ( 2 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; dfloc [ 1 ] += f [ VE_3D_INDEX ( 1 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )] - f [ VE_3D_INDEX ( 3 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; dfloc [ 2 ] += f [ VE_3D_INDEX ( 2 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )] - f [ VE_3D_INDEX ( 1 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; } df [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 0 ]; df [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 1 ]; df [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 2 ]; } extern \"C\" { void VectorCurl_3D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { VectorCurl_3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * dMatrix , * f , * df , N , nVar ); } } // TensorDivergence_3D // __global__ void TensorDivergence_3D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; real df1 = 0.0 ; real df2 = 0.0 ; real df3 = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { df1 += f [ TE_3D_INDEX ( 1 , 1 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )] + f [ TE_3D_INDEX ( 2 , 1 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )] + f [ TE_3D_INDEX ( 3 , 1 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; df2 += f [ TE_3D_INDEX ( 1 , 2 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )] + f [ TE_3D_INDEX ( 2 , 2 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )] + f [ TE_3D_INDEX ( 3 , 2 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; df3 += f [ TE_3D_INDEX ( 1 , 3 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )] + f [ TE_3D_INDEX ( 2 , 3 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )] + f [ TE_3D_INDEX ( 3 , 3 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; } df [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] = df1 ; df [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] = df2 ; df [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] = df3 ; } extern \"C\" { void TensorDivergence_3D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { TensorDivergence_3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * dMatrix , * f , * df , N , nVar ); } } // TensorDGDivergence_3D // __global__ void TensorDGDivergence_3D_gpu ( real * dgMatrix , real * bMatrix , real * qWeights , real * f , real * bf , real * df , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; df [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] = 0.0 ; df [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] = 0.0 ; df [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { df [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] += f [ TE_3D_INDEX ( 1 , 1 , ii , j , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )] + f [ TE_3D_INDEX ( 2 , 1 , i , ii , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )] + f [ TE_3D_INDEX ( 3 , 1 , i , j , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + k * ( N + 1 )]; df [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] += f [ TE_3D_INDEX ( 1 , 2 , ii , j , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )] + f [ TE_3D_INDEX ( 2 , 2 , i , ii , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )] + f [ TE_3D_INDEX ( 3 , 2 , i , j , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + k * ( N + 1 )]; df [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] += f [ TE_3D_INDEX ( 1 , 3 , ii , j , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )] + f [ TE_3D_INDEX ( 2 , 3 , i , ii , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )] + f [ TE_3D_INDEX ( 3 , 3 , i , j , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + k * ( N + 1 )]; } df [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] += ( bf [ TEB_3D_INDEX ( 1 , 1 , j , k , iVar , 3 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] + bf [ TEB_3D_INDEX ( 1 , 1 , j , k , iVar , 5 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ] + ( bf [ TEB_3D_INDEX ( 2 , 1 , i , k , iVar , 4 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] + bf [ TEB_3D_INDEX ( 2 , 1 , i , k , iVar , 2 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ] + ( bf [ TEB_3D_INDEX ( 3 , 1 , i , j , iVar , 6 , iEl , N , nVar )] * bMatrix [ k + ( N + 1 )] + bf [ TEB_3D_INDEX ( 3 , 1 , i , j , iVar , 1 , iEl , N , nVar )] * bMatrix [ k ]) / qWeights [ k ]; df [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] += ( bf [ TEB_3D_INDEX ( 1 , 2 , j , k , iVar , 3 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] + bf [ TEB_3D_INDEX ( 1 , 2 , j , k , iVar , 5 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ] + ( bf [ TEB_3D_INDEX ( 2 , 2 , i , k , iVar , 4 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] + bf [ TEB_3D_INDEX ( 2 , 2 , i , k , iVar , 2 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ] + ( bf [ TEB_3D_INDEX ( 3 , 2 , i , j , iVar , 6 , iEl , N , nVar )] * bMatrix [ k + ( N + 1 )] + bf [ TEB_3D_INDEX ( 3 , 2 , i , j , iVar , 1 , iEl , N , nVar )] * bMatrix [ k ]) / qWeights [ k ]; df [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] += ( bf [ TEB_3D_INDEX ( 1 , 3 , j , k , iVar , 3 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] + bf [ TEB_3D_INDEX ( 1 , 3 , j , k , iVar , 5 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ] + ( bf [ TEB_3D_INDEX ( 2 , 3 , i , k , iVar , 4 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] + bf [ TEB_3D_INDEX ( 2 , 3 , i , k , iVar , 2 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ] + ( bf [ TEB_3D_INDEX ( 3 , 3 , i , j , iVar , 6 , iEl , N , nVar )] * bMatrix [ k + ( N + 1 )] + bf [ TEB_3D_INDEX ( 3 , 3 , i , j , iVar , 1 , iEl , N , nVar )] * bMatrix [ k ]) / qWeights [ k ]; } extern \"C\" { void TensorDGDivergence_3D_gpu_wrapper ( real ** dgMatrix , real ** bMatrix , real ** qWeights , real ** f , real ** bf , real ** df , int N , int nVar , int nEl ) { TensorDGDivergence_3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * dgMatrix , * bMatrix , * qWeights , * f , * bf , * df , N , nVar ); } }","tags":"","loc":"sourcefile/self_lagrange.cpp.html"},{"title":"SELF_DG.cpp – SELF","text":"Contents Source Code SELF_DG.cpp Source Code #include <hip/hip_runtime.h> #include \"SELF_HIP_Macros.h\" __global__ void CalculateDSDt_DG3D_gpu ( real * fluxDivergence , real * source , real * dSdt , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; size_t k = threadIdx . z ; dSdt [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] = source [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] - fluxDivergence [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; } extern \"C\" { void CalculateDSDt_DG3D_gpu_wrapper ( real ** fluxDivergence , real ** source , real ** dSdt , int N , int nVar , int nEl ) { CalculateDSDt_DG3D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 >>> ( * fluxDivergence , * source , * dSdt , N , nVar ); } } __global__ void CalculateDSDt_DG2D_gpu ( real * fluxDivergence , real * source , real * dSdt , int N , int nVar ){ size_t iVar = blockIdx . x ; size_t iEl = blockIdx . y ; size_t i = threadIdx . x ; size_t j = threadIdx . y ; dSdt [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] = source [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] - fluxDivergence [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )]; } extern \"C\" { void CalculateDSDt_DG2D_gpu_wrapper ( real ** fluxDivergence , real ** source , real ** dSdt , int N , int nVar , int nEl ) { CalculateDSDt_DG2D_gpu <<< dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 >>> ( * fluxDivergence , * source , * dSdt , N , nVar ); } }","tags":"","loc":"sourcefile/self_dg.cpp.html"},{"title":"Metadata – SELF ","text":"type, public :: Metadata Contents Variables description name units Type-Bound Procedures Set_Description Set_Name Set_Units Source Code Metadata Components Type Visibility Attributes Name Initial character, public :: description character, public :: name character, public :: units Type-Bound Procedures procedure, public :: Set_Description => Set_Description_Metadata public subroutine Set_Description_Metadata (mtd, description) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: description procedure, public :: Set_Name => Set_Name_Metadata public subroutine Set_Name_Metadata (mtd, name) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: name procedure, public :: Set_Units => Set_Units_Metadata public subroutine Set_Units_Metadata (mtd, units) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: units Source Code TYPE Metadata CHARACTER ( SELF_MTD_NameLength ) :: name CHARACTER ( SELF_MTD_DescriptionLength ) :: description CHARACTER ( SELF_MTD_UnitsLength ) :: units CONTAINS PROCEDURE , PUBLIC :: Set_Name => Set_Name_Metadata PROCEDURE , PUBLIC :: Set_Description => Set_Description_Metadata PROCEDURE , PUBLIC :: Set_Units => Set_Units_Metadata ! PROCEDURE,PUBLIC :: Write_HDF5 => Write_HDF5_Metadata END TYPE Metadata","tags":"","loc":"type/metadata.html"},{"title":"hfInt32_r1 – SELF ","text":"type, public :: hfInt32_r1 Data type for storing one-dimensional int32 arrays on the host and the device Inherits type~~hfint32_r1~~InheritsGraph type~hfint32_r1 hfInt32_r1 c_ptr c_ptr type~hfint32_r1->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r1 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r1 public subroutine Alloc_hfInt32_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound procedure, public :: Free => Free_hfInt32_r1 public subroutine Free_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r1 public subroutine UpdateDevice_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r1 public subroutine UpdateHost_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this Source Code TYPE hfInt32_r1 !! Data type for storing one-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r1 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r1 END TYPE hfInt32_r1","tags":"","loc":"type/hfint32_r1.html"},{"title":"hfInt32_r2 – SELF ","text":"type, public :: hfInt32_r2 Data type for storing two-dimensional int32 arrays on the host and the device Inherits type~~hfint32_r2~~InheritsGraph type~hfint32_r2 hfInt32_r2 c_ptr c_ptr type~hfint32_r2->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r2 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r2 public subroutine Alloc_hfInt32_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) procedure, public :: Free => Free_hfInt32_r2 public subroutine Free_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r2 public subroutine UpdateDevice_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r2 public subroutine UpdateHost_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this Source Code TYPE hfInt32_r2 !! Data type for storing two-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r2 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r2 END TYPE hfInt32_r2","tags":"","loc":"type/hfint32_r2.html"},{"title":"hfInt32_r3 – SELF ","text":"type, public :: hfInt32_r3 Data type for storing three-dimensional int32 arrays on the host and the device Inherits type~~hfint32_r3~~InheritsGraph type~hfint32_r3 hfInt32_r3 c_ptr c_ptr type~hfint32_r3->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r3 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r3 public subroutine Alloc_hfInt32_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) procedure, public :: Free => Free_hfInt32_r3 public subroutine Free_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r3 public subroutine UpdateDevice_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r3 public subroutine UpdateHost_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this Source Code TYPE hfInt32_r3 !! Data type for storing three-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r3 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r3 END TYPE hfInt32_r3","tags":"","loc":"type/hfint32_r3.html"},{"title":"hfInt32_r4 – SELF ","text":"type, public :: hfInt32_r4 Data type for storing four-dimensional int32 arrays on the host and the device Inherits type~~hfint32_r4~~InheritsGraph type~hfint32_r4 hfInt32_r4 c_ptr c_ptr type~hfint32_r4->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r4 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r4 public subroutine Alloc_hfInt32_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) procedure, public :: Free => Free_hfInt32_r4 public subroutine Free_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r4 public subroutine UpdateDevice_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r4 public subroutine UpdateHost_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this Source Code TYPE hfInt32_r4 !! Data type for storing four-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r4 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r4 END TYPE hfInt32_r4","tags":"","loc":"type/hfint32_r4.html"},{"title":"hfInt32_r5 – SELF ","text":"type, public :: hfInt32_r5 Data type for storing five-dimensional int32 arrays on the host and the device Inherits type~~hfint32_r5~~InheritsGraph type~hfint32_r5 hfInt32_r5 c_ptr c_ptr type~hfint32_r5->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r5 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r5 public subroutine Alloc_hfInt32_r5 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) procedure, public :: Free => Free_hfInt32_r5 public subroutine Free_hfInt32_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r5 public subroutine UpdateDevice_hfInt32_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r5 public subroutine UpdateHost_hfInt32_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this Source Code TYPE hfInt32_r5 !! Data type for storing five-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r5 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r5 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r5 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r5 END TYPE hfInt32_r5","tags":"","loc":"type/hfint32_r5.html"},{"title":"hfInt32_r6 – SELF ","text":"type, public :: hfInt32_r6 Data type for storing six-dimensional int32 arrays on the host and the device Inherits type~~hfint32_r6~~InheritsGraph type~hfint32_r6 hfInt32_r6 c_ptr c_ptr type~hfint32_r6->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r6 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r6 public subroutine Alloc_hfInt32_r6 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) procedure, public :: Free => Free_hfInt32_r6 public subroutine Free_hfInt32_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r6 public subroutine UpdateDevice_hfInt32_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r6 public subroutine UpdateHost_hfInt32_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this Source Code TYPE hfInt32_r6 !! Data type for storing six-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r6 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r6 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r6 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r6 END TYPE hfInt32_r6","tags":"","loc":"type/hfint32_r6.html"},{"title":"hfInt32_r7 – SELF ","text":"type, public :: hfInt32_r7 Data type for storing seven-dimensional int32 arrays on the host and the device Inherits type~~hfint32_r7~~InheritsGraph type~hfint32_r7 hfInt32_r7 c_ptr c_ptr type~hfint32_r7->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r7 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r7 public subroutine Alloc_hfInt32_r7 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) procedure, public :: Free => Free_hfInt32_r7 public subroutine Free_hfInt32_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r7 public subroutine UpdateDevice_hfInt32_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r7 public subroutine UpdateHost_hfInt32_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this Source Code TYPE hfInt32_r7 !! Data type for storing seven-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r7 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r7 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r7 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r7 END TYPE hfInt32_r7","tags":"","loc":"type/hfint32_r7.html"},{"title":"hfInt64_r1 – SELF ","text":"type, public :: hfInt64_r1 Data type for storing one-dimensional int64 arrays on the host and the device Inherits type~~hfint64_r1~~InheritsGraph type~hfint64_r1 hfInt64_r1 c_ptr c_ptr type~hfint64_r1->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt64_r1 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r1 public subroutine Alloc_hfInt64_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound procedure, public :: Free => Free_hfInt64_r1 public subroutine Free_hfInt64_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r1 public subroutine UpdateDevice_hfInt64_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt64_r1 public subroutine UpdateHost_hfInt64_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this Source Code TYPE hfInt64_r1 !! Data type for storing one-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r1 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r1 END TYPE hfInt64_r1","tags":"","loc":"type/hfint64_r1.html"},{"title":"hfInt64_r2 – SELF ","text":"type, public :: hfInt64_r2 Data type for storing two-dimensional int64 arrays on the host and the device Inherits type~~hfint64_r2~~InheritsGraph type~hfint64_r2 hfInt64_r2 c_ptr c_ptr type~hfint64_r2->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt64_r2 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r2 public subroutine Alloc_hfInt64_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) procedure, public :: Free => Free_hfInt64_r2 public subroutine Free_hfInt64_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r2 public subroutine UpdateDevice_hfInt64_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt64_r2 public subroutine UpdateHost_hfInt64_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this Source Code TYPE hfInt64_r2 !! Data type for storing two-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r2 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r2 END TYPE hfInt64_r2","tags":"","loc":"type/hfint64_r2.html"},{"title":"hfInt64_r3 – SELF ","text":"type, public :: hfInt64_r3 Data type for storing three-dimensional int64 arrays on the host and the device Inherits type~~hfint64_r3~~InheritsGraph type~hfint64_r3 hfInt64_r3 c_ptr c_ptr type~hfint64_r3->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt64_r3 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r3 public subroutine Alloc_hfInt64_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) procedure, public :: Free => Free_hfInt64_r3 public subroutine Free_hfInt64_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r3 public subroutine UpdateDevice_hfInt64_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt64_r3 public subroutine UpdateHost_hfInt64_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this Source Code TYPE hfInt64_r3 !! Data type for storing three-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r3 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r3 END TYPE hfInt64_r3","tags":"","loc":"type/hfint64_r3.html"},{"title":"hfInt64_r4 – SELF ","text":"type, public :: hfInt64_r4 Data type for storing four-dimensional int64 arrays on the host and the device Inherits type~~hfint64_r4~~InheritsGraph type~hfint64_r4 hfInt64_r4 c_ptr c_ptr type~hfint64_r4->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt64_r4 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r4 public subroutine Alloc_hfInt64_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) procedure, public :: Free => Free_hfInt64_r4 public subroutine Free_hfInt64_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r4 public subroutine UpdateDevice_hfInt64_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt64_r4 public subroutine UpdateHost_hfInt64_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this Source Code TYPE hfInt64_r4 !! Data type for storing four-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r4 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r4 END TYPE hfInt64_r4","tags":"","loc":"type/hfint64_r4.html"},{"title":"hfInt64_r5 – SELF ","text":"type, public :: hfInt64_r5 Data type for storing five-dimensional int64 arrays on the host and the device Inherits type~~hfint64_r5~~InheritsGraph type~hfint64_r5 hfInt64_r5 c_ptr c_ptr type~hfint64_r5->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt64_r5 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r5 public subroutine Alloc_hfInt64_r5 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) procedure, public :: Free => Free_hfInt64_r5 public subroutine Free_hfInt64_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r5 public subroutine UpdateDevice_hfInt64_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt64_r5 public subroutine UpdateHost_hfInt64_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this Source Code TYPE hfInt64_r5 !! Data type for storing five-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r5 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r5 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r5 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r5 END TYPE hfInt64_r5","tags":"","loc":"type/hfint64_r5.html"},{"title":"hfInt64_r6 – SELF ","text":"type, public :: hfInt64_r6 Data type for storing six-dimensional int64 arrays on the host and the device Inherits type~~hfint64_r6~~InheritsGraph type~hfint64_r6 hfInt64_r6 c_ptr c_ptr type~hfint64_r6->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt64_r6 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r6 public subroutine Alloc_hfInt64_r6 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) procedure, public :: Free => Free_hfInt64_r6 public subroutine Free_hfInt64_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r6 public subroutine UpdateDevice_hfInt64_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt64_r6 public subroutine UpdateHost_hfInt64_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this Source Code TYPE hfInt64_r6 !! Data type for storing six-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r6 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r6 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r6 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r6 END TYPE hfInt64_r6","tags":"","loc":"type/hfint64_r6.html"},{"title":"hfInt64_r7 – SELF ","text":"type, public :: hfInt64_r7 Data type for storing seven-dimensional int64 arrays on the host and the device Inherits type~~hfint64_r7~~InheritsGraph type~hfint64_r7 hfInt64_r7 c_ptr c_ptr type~hfint64_r7->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt64_r7 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r7 public subroutine Alloc_hfInt64_r7 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) procedure, public :: Free => Free_hfInt64_r7 public subroutine Free_hfInt64_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r7 public subroutine UpdateDevice_hfInt64_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt64_r7 public subroutine UpdateHost_hfInt64_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this Source Code TYPE hfInt64_r7 !! Data type for storing seven-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r7 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r7 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r7 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r7 END TYPE hfInt64_r7","tags":"","loc":"type/hfint64_r7.html"},{"title":"hfReal_r1 – SELF ","text":"type, public :: hfReal_r1 Data type for storing one-dimensional real arrays on the host and the device Inherits type~~hfreal_r1~~InheritsGraph type~hfreal_r1 hfReal_r1 c_ptr c_ptr type~hfreal_r1->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r1 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r1 public subroutine Alloc_hfReal_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound procedure, public :: Free => Free_hfReal_r1 public subroutine Free_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r1 public subroutine UpdateDevice_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r1 public subroutine UpdateHost_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this Source Code TYPE hfReal_r1 !! Data type for storing one-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r1 PROCEDURE , PUBLIC :: Free => Free_hfReal_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r1 END TYPE hfReal_r1","tags":"","loc":"type/hfreal_r1.html"},{"title":"hfReal_r2 – SELF ","text":"type, public :: hfReal_r2 Data type for storing two-dimensional real arrays on the host and the device Inherits type~~hfreal_r2~~InheritsGraph type~hfreal_r2 hfReal_r2 c_ptr c_ptr type~hfreal_r2->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r2 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r2 public subroutine Alloc_hfReal_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) procedure, public :: Free => Free_hfReal_r2 public subroutine Free_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r2 public subroutine UpdateDevice_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r2 public subroutine UpdateHost_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this Source Code TYPE hfReal_r2 !! Data type for storing two-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r2 PROCEDURE , PUBLIC :: Free => Free_hfReal_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r2 END TYPE hfReal_r2","tags":"","loc":"type/hfreal_r2.html"},{"title":"hfReal_r3 – SELF ","text":"type, public :: hfReal_r3 Data type for storing three-dimensional real arrays on the host and the device Inherits type~~hfreal_r3~~InheritsGraph type~hfreal_r3 hfReal_r3 c_ptr c_ptr type~hfreal_r3->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r3 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r3 public subroutine Alloc_hfReal_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) procedure, public :: Free => Free_hfReal_r3 public subroutine Free_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r3 public subroutine UpdateDevice_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r3 public subroutine UpdateHost_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this Source Code TYPE hfReal_r3 !! Data type for storing three-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r3 PROCEDURE , PUBLIC :: Free => Free_hfReal_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r3 END TYPE hfReal_r3","tags":"","loc":"type/hfreal_r3.html"},{"title":"hfReal_r4 – SELF ","text":"type, public :: hfReal_r4 Data type for storing four-dimensional real arrays on the host and the device Inherits type~~hfreal_r4~~InheritsGraph type~hfreal_r4 hfReal_r4 c_ptr c_ptr type~hfreal_r4->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r4 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r4 public subroutine Alloc_hfReal_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) procedure, public :: Free => Free_hfReal_r4 public subroutine Free_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r4 public subroutine UpdateDevice_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r4 public subroutine UpdateHost_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this Source Code TYPE hfReal_r4 !! Data type for storing four-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r4 PROCEDURE , PUBLIC :: Free => Free_hfReal_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r4 END TYPE hfReal_r4","tags":"","loc":"type/hfreal_r4.html"},{"title":"hfReal_r5 – SELF ","text":"type, public :: hfReal_r5 Data type for storing five-dimensional real arrays on the host and the device Inherits type~~hfreal_r5~~InheritsGraph type~hfreal_r5 hfReal_r5 c_ptr c_ptr type~hfreal_r5->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r5 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r5 public subroutine Alloc_hfReal_r5 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) procedure, public :: Free => Free_hfReal_r5 public subroutine Free_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r5 public subroutine UpdateDevice_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r5 public subroutine UpdateHost_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this Source Code TYPE hfReal_r5 !! Data type for storing five-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r5 PROCEDURE , PUBLIC :: Free => Free_hfReal_r5 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r5 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r5 END TYPE hfReal_r5","tags":"","loc":"type/hfreal_r5.html"},{"title":"hfReal_r6 – SELF ","text":"type, public :: hfReal_r6 Data type for storing one-dimensional real arrays on the host and the device Inherits type~~hfreal_r6~~InheritsGraph type~hfreal_r6 hfReal_r6 c_ptr c_ptr type~hfreal_r6->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r6 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r6 public subroutine Alloc_hfReal_r6 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) procedure, public :: Free => Free_hfReal_r6 public subroutine Free_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r6 public subroutine UpdateDevice_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r6 public subroutine UpdateHost_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this Source Code TYPE hfReal_r6 !! Data type for storing one-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r6 PROCEDURE , PUBLIC :: Free => Free_hfReal_r6 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r6 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r6 END TYPE hfReal_r6","tags":"","loc":"type/hfreal_r6.html"},{"title":"hfReal_r7 – SELF ","text":"type, public :: hfReal_r7 Data type for storing seven-dimensional real arrays on the host and the device Inherits type~~hfreal_r7~~InheritsGraph type~hfreal_r7 hfReal_r7 c_ptr c_ptr type~hfreal_r7->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r7 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r7 public subroutine Alloc_hfReal_r7 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) procedure, public :: Free => Free_hfReal_r7 public subroutine Free_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r7 public subroutine UpdateDevice_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r7 public subroutine UpdateHost_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this Source Code TYPE hfReal_r7 !! Data type for storing seven-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r7 PROCEDURE , PUBLIC :: Free => Free_hfReal_r7 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r7 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r7 END TYPE hfReal_r7","tags":"","loc":"type/hfreal_r7.html"},{"title":"Advection3D – SELF ","text":"type, public, extends(DG3D) :: Advection3D Inherits type~~advection3d~~InheritsGraph type~advection3d Advection3D MappedVector3D MappedVector3D type~advection3d->MappedVector3D velocity DG3D DG3D type~advection3d->DG3D EquationParser EquationParser type~advection3d->EquationParser boundaryConditionEqn, solutionEqn, sourceEqn Vector3D Vector3D type~advection3d->Vector3D plotVelocity, plotX Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Lx Ly Lz bcEqn boundaryConditionEqn controlDegree controlQuadrature diffusiveFlux diffusivity dt enableMPI endTime gpuAccel icEqn icFile initialTime integrator meshFile nxElements nyElements nzElements outputInterval plotVelocity plotX simulationTime solutionEqn sourceEqn targetDegree targetQuadrature velEqnX velEqnY velEqnZ velocity Type-Bound Procedures ForwardStep Free Init InitFromCLI InternalFlux SetBoundaryCondition SetBoundaryConditionFromEquation_Advection3D SetSolution SetSolutionFromEquation_Advection3D SetSource SetSourceFromEquation_Advection3D SetVelocity SetVelocityFromEquation_Advection3D SideFlux Tendency TimeStepRK3 WriteTecplot Source Code Advection3D Components Type Visibility Attributes Name Initial real(kind=prec), public :: Lx real(kind=prec), public :: Ly real(kind=prec), public :: Lz character(len=self_EquationLength), public :: bcEqn type(EquationParser), public, ALLOCATABLE :: boundaryConditionEqn (:) integer, public :: controlDegree integer, public :: controlQuadrature logical, public :: diffusiveFlux real(kind=prec), public :: diffusivity real(kind=prec), public :: dt logical, public :: enableMPI real(kind=prec), public :: endTime logical, public :: gpuAccel character(len=self_EquationLength), public :: icEqn character(len=self_FileNameLength), public :: icFile real(kind=prec), public :: initialTime integer, public :: integrator character(len=self_FileNameLength), public :: meshFile integer, public :: nxElements integer, public :: nyElements integer, public :: nzElements real(kind=prec), public :: outputInterval type(Vector3D), public :: plotVelocity type(Vector3D), public :: plotX real(kind=prec), public :: simulationTime type(EquationParser), public, ALLOCATABLE :: solutionEqn (:) type(EquationParser), public, ALLOCATABLE :: sourceEqn (:) integer, public :: targetDegree integer, public :: targetQuadrature character(len=self_EquationLength), public :: velEqnX character(len=self_EquationLength), public :: velEqnY character(len=self_EquationLength), public :: velEqnZ type(MappedVector3D), public :: velocity Type-Bound Procedures procedure, public :: ForwardStep => ForwardStep_Advection3D public subroutine ForwardStep_Advection3D (this, endTime) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this real(kind=prec), intent(in) :: endTime procedure, public :: Free => Free_Advection3D public subroutine Free_Advection3D (this) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this procedure, public :: Init => Init_Advection3D public subroutine Init_Advection3D (this, cqType, tqType, cqDegree, tqDegree, nvar, enableMPI, spec) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(out) :: this integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nvar logical, intent(in) :: enableMPI type(MeshSpec), intent(in) :: spec procedure, public :: InitFromCLI => InitFromCLI_Advection3D public subroutine InitFromCLI_Advection3D (this) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this procedure, public :: InternalFlux => InternalFlux_Advection3D public subroutine InternalFlux_Advection3D (this) Calculates the advective flux using the provided velocity Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this generic, public :: SetBoundaryCondition => SetBoundaryConditionFromEquation_Advection3D public subroutine SetBoundaryConditionFromEquation_Advection3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) procedure, private :: SetBoundaryConditionFromEquation_Advection3D public subroutine SetBoundaryConditionFromEquation_Advection3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetSolution => SetSolutionFromEquation_Advection3D public subroutine SetSolutionFromEquation_Advection3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) procedure, private :: SetSolutionFromEquation_Advection3D public subroutine SetSolutionFromEquation_Advection3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetSource => SetSourceFromEquation_Advection3D public subroutine SetSourceFromEquation_Advection3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) procedure, private :: SetSourceFromEquation_Advection3D public subroutine SetSourceFromEquation_Advection3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetVelocity => SetVelocityFromEquation_Advection3D public subroutine SetVelocityFromEquation_Advection3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:3) procedure, private :: SetVelocityFromEquation_Advection3D public subroutine SetVelocityFromEquation_Advection3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:3) procedure, public :: SideFlux => SideFlux_Advection3D public subroutine SideFlux_Advection3D (this) Calculates the Advective Flux on element sides using a Lax-Friedrich's upwind Riemann Solver Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this procedure, public :: Tendency => Tendency_Advection3D public subroutine Tendency_Advection3D (this) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this procedure, public :: TimeStepRK3 => TimeStepRK3_Advection3D public subroutine TimeStepRK3_Advection3D (this, nSteps) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this integer, intent(in) :: nSteps procedure, public :: WriteTecplot => WriteTecplot_Advection3D public subroutine WriteTecplot_Advection3D (self, filename) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: self character, intent(in), optional :: filename Source Code TYPE , EXTENDS ( DG3D ), PUBLIC :: Advection3D TYPE ( MappedVector3D ), PUBLIC :: velocity TYPE ( Vector3D ), PUBLIC :: plotVelocity TYPE ( Vector3D ), PUBLIC :: plotX TYPE ( EquationParser ), ALLOCATABLE :: boundaryConditionEqn (:) TYPE ( EquationParser ), ALLOCATABLE :: solutionEqn (:) TYPE ( EquationParser ), ALLOCATABLE :: sourceEqn (:) REAL ( prec ) :: simulationTime ! Model Settings ! REAL ( prec ) :: Lx , Ly , Lz ! Domain lengths REAL ( prec ) :: dt ! Default time step size REAL ( prec ) :: outputInterval REAL ( prec ) :: initialTime REAL ( prec ) :: endTime REAL ( prec ) :: diffusivity LOGICAL :: diffusiveFlux INTEGER :: controlDegree INTEGER :: targetDegree INTEGER :: controlQuadrature ! ENUMS in SELF_Constants.f90 INTEGER :: targetQuadrature ! ENUMS in SELF_Constants.f90 CHARACTER ( LEN = self_FileNameLength ) :: icFile CHARACTER ( LEN = self_FileNameLength ) :: meshFile INTEGER :: nxElements INTEGER :: nyElements INTEGER :: nzElements INTEGER :: integrator ! ENUMS needed in SELF_Constants.f90 !! TO DO !! CHARACTER ( LEN = self_EquationLength ) :: velEqnX ! Velocity Equation (x-direction) CHARACTER ( LEN = self_EquationLength ) :: velEqnY ! Velocity Equation (y-direction) CHARACTER ( LEN = self_EquationLength ) :: velEqnZ ! Velocity Equation (z-direction) CHARACTER ( LEN = self_EquationLength ) :: icEqn ! Initial condition Equation CHARACTER ( LEN = self_EquationLength ) :: bcEqn ! Boundary condition Equation LOGICAL :: enableMPI LOGICAL :: gpuAccel CONTAINS PROCEDURE , PUBLIC :: Init => Init_Advection3D PROCEDURE , PUBLIC :: InitFromCLI => InitFromCLI_Advection3D PROCEDURE , PUBLIC :: Free => Free_Advection3D GENERIC , PUBLIC :: SetSolution => SetSolutionFromEquation_Advection3D PROCEDURE , PRIVATE :: SetSolutionFromEquation_Advection3D GENERIC , PUBLIC :: SetSource => SetSourceFromEquation_Advection3D PROCEDURE , PRIVATE :: SetSourceFromEquation_Advection3D GENERIC , PUBLIC :: SetVelocity => SetVelocityFromEquation_Advection3D PROCEDURE , PRIVATE :: SetVelocityFromEquation_Advection3D GENERIC , PUBLIC :: SetBoundaryCondition => SetBoundaryConditionFromEquation_Advection3D PROCEDURE , PRIVATE :: SetBoundaryConditionFromEquation_Advection3D PROCEDURE , PUBLIC :: WriteTecplot => WriteTecplot_Advection3D PROCEDURE , PUBLIC :: ForwardStep => ForwardStep_Advection3D PROCEDURE , PUBLIC :: TimeStepRK3 => TimeStepRK3_Advection3D PROCEDURE , PUBLIC :: Tendency => Tendency_Advection3D PROCEDURE , PUBLIC :: InternalFlux => InternalFlux_Advection3D PROCEDURE , PUBLIC :: SideFlux => SideFlux_Advection3D END TYPE Advection3D","tags":"","loc":"type/advection3d.html"},{"title":"Scalar1D – SELF ","text":"type, public :: Scalar1D Inherits type~~scalar1d~~InheritsGraph type~scalar1d Scalar1D Lagrange Lagrange type~scalar1d->Lagrange interp hfReal_r3 hfReal_r3 type~scalar1d->hfReal_r3 interior, boundary, extBoundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N boundary controlType extBoundary interior interp nElem nVar targetType Type-Bound Procedures ASSIGNMENT(=) AbsMaxBoundary AbsMaxInterior Add_Scalar1D BoundaryInterp Derivative Derivative_Scalar1D Equals_Scalar1D Free GridInterp Init OPERATOR(+) OPERATOR(-) Subtract_Scalar1D UpdateDevice UpdateHost Source Code Scalar1D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r3), public :: boundary integer, public :: controlType type(hfReal_r3), public :: extBoundary type(hfReal_r3), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Scalar1D public subroutine Equals_Scalar1D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFOut type( Scalar1D ), intent(in) :: SELFin procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Scalar1D public function AbsMaxBoundary_Scalar1D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar1D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:2) procedure, public :: AbsMaxInterior => AbsMaxInterior_Scalar1D public function AbsMaxInterior_Scalar1D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar1D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) procedure, private, PASS(SELFa) :: Add_Scalar1D public function Add_Scalar1D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D public subroutine BoundaryInterp_Scalar1D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel generic, public :: Derivative => Derivative_Scalar1D public subroutine Derivative_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Derivative_Scalar1D public subroutine Derivative_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private, PASS(SELFOut) :: Equals_Scalar1D public subroutine Equals_Scalar1D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFOut type( Scalar1D ), intent(in) :: SELFin procedure, public :: Free => Free_Scalar1D public subroutine Free_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage procedure, public :: GridInterp => GridInterp_Scalar1D public subroutine GridInterp_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Scalar1D public subroutine Init_Scalar1D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: OPERATOR(+) => Add_Scalar1D public function Add_Scalar1D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) generic, public :: OPERATOR(-) => Subtract_Scalar1D public function Subtract_Scalar1D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) procedure, private, PASS(SELFa) :: Subtract_Scalar1D public function Subtract_Scalar1D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) procedure, public :: UpdateDevice => UpdateDevice_Scalar1D public subroutine UpdateDevice_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Scalar1D public subroutine UpdateHost_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage Source Code TYPE , PUBLIC :: Scalar1D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r3 ) :: interior TYPE ( hfReal_r3 ) :: boundary TYPE ( hfReal_r3 ) :: extBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar1D PROCEDURE , PUBLIC :: Free => Free_Scalar1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar1D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar1D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar1D GENERIC , PUBLIC :: Derivative => Derivative_Scalar1D PROCEDURE , PRIVATE :: Derivative_Scalar1D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar1D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar1D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Scalar1D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Scalar1D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Scalar1D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Scalar1D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Scalar1D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Scalar1D END TYPE Scalar1D","tags":"","loc":"type/scalar1d.html"},{"title":"Scalar2D – SELF ","text":"type, public :: Scalar2D Inherits type~~scalar2d~~InheritsGraph type~scalar2d Scalar2D hfReal_r4 hfReal_r4 type~scalar2d->hfReal_r4 interior, boundary, extBoundary, avgBoundary Lagrange Lagrange type~scalar2d->Lagrange interp Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N avgBoundary boundary controlType extBoundary interior interp nElem nVar targetType Type-Bound Procedures ASSIGNMENT(=) AbsMaxBoundary AbsMaxInterior Add_Scalar2D BoundaryInterp Equals_Scalar2D Free Gradient Gradient_Scalar2D GridInterp Init OPERATOR(+) OPERATOR(-) Subtract_Scalar2D UpdateDevice UpdateHost Source Code Scalar2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r4), public :: avgBoundary type(hfReal_r4), public :: boundary integer, public :: controlType type(hfReal_r4), public :: extBoundary type(hfReal_r4), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Scalar2D public subroutine Equals_Scalar2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFOut type( Scalar2D ), intent(in) :: SELFin procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Scalar2D public function AbsMaxBoundary_Scalar2D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar2D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:4) procedure, public :: AbsMaxInterior => AbsMaxInterior_Scalar2D public function AbsMaxInterior_Scalar2D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar2D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) procedure, private, PASS(SELFa) :: Add_Scalar2D public function Add_Scalar2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D public subroutine BoundaryInterp_Scalar2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, private, PASS(SELFOut) :: Equals_Scalar2D public subroutine Equals_Scalar2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFOut type( Scalar2D ), intent(in) :: SELFin procedure, public :: Free => Free_Scalar2D public subroutine Free_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Scalar2D public subroutine Gradient_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Gradient_Scalar2D public subroutine Gradient_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Scalar2D public subroutine GridInterp_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Scalar2D public subroutine Init_Scalar2D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: OPERATOR(+) => Add_Scalar2D public function Add_Scalar2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) generic, public :: OPERATOR(-) => Subtract_Scalar2D public function Subtract_Scalar2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) procedure, private, PASS(SELFa) :: Subtract_Scalar2D public function Subtract_Scalar2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) procedure, public :: UpdateDevice => UpdateDevice_Scalar2D public subroutine UpdateDevice_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Scalar2D public subroutine UpdateHost_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage Source Code TYPE , PUBLIC :: Scalar2D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r4 ) :: interior TYPE ( hfReal_r4 ) :: boundary TYPE ( hfReal_r4 ) :: extBoundary TYPE ( hfReal_r4 ) :: avgBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar2D PROCEDURE , PUBLIC :: Free => Free_Scalar2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar2D GENERIC , PUBLIC :: Gradient => Gradient_Scalar2D PROCEDURE , PRIVATE :: Gradient_Scalar2D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar2D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar2D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Scalar2D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Scalar2D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Scalar2D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Scalar2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Scalar2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Scalar2D END TYPE Scalar2D","tags":"","loc":"type/scalar2d.html"},{"title":"Scalar3D – SELF ","text":"type, public :: Scalar3D Inherits type~~scalar3d~~InheritsGraph type~scalar3d Scalar3D Lagrange Lagrange type~scalar3d->Lagrange interp hfReal_r5 hfReal_r5 type~scalar3d->hfReal_r5 interior, boundary, extBoundary, avgBoundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N avgBoundary boundary controlType extBoundary interior interp nElem nVar targetType Type-Bound Procedures ASSIGNMENT(=) AbsMaxBoundary AbsMaxInterior Add_Scalar3D BoundaryInterp Equals_Scalar3D Free Gradient Gradient_Scalar3D GridInterp Init OPERATOR(+) OPERATOR(-) Subtract_Scalar3D UpdateDevice UpdateHost Source Code Scalar3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r5), public :: avgBoundary type(hfReal_r5), public :: boundary integer, public :: controlType type(hfReal_r5), public :: extBoundary type(hfReal_r5), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Scalar3D public subroutine Equals_Scalar3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFOut type( Scalar3D ), intent(in) :: SELFin procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Scalar3D public function AbsMaxBoundary_Scalar3D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar3D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:6) procedure, public :: AbsMaxInterior => AbsMaxInterior_Scalar3D public function AbsMaxInterior_Scalar3D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar3D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) procedure, private, PASS(SELFa) :: Add_Scalar3D public function Add_Scalar3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D public subroutine BoundaryInterp_Scalar3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, private, PASS(SELFOut) :: Equals_Scalar3D public subroutine Equals_Scalar3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFOut type( Scalar3D ), intent(in) :: SELFin procedure, public :: Free => Free_Scalar3D public subroutine Free_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Scalar3D public subroutine Gradient_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Gradient_Scalar3D public subroutine Gradient_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Scalar3D public subroutine GridInterp_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Scalar3D public subroutine Init_Scalar3D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: OPERATOR(+) => Add_Scalar3D public function Add_Scalar3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) generic, public :: OPERATOR(-) => Subtract_Scalar3D public function Subtract_Scalar3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) procedure, private, PASS(SELFa) :: Subtract_Scalar3D public function Subtract_Scalar3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) procedure, public :: UpdateDevice => UpdateDevice_Scalar3D public subroutine UpdateDevice_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Scalar3D public subroutine UpdateHost_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage Source Code TYPE , PUBLIC :: Scalar3D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r5 ) :: interior TYPE ( hfReal_r5 ) :: boundary TYPE ( hfReal_r5 ) :: extBoundary TYPE ( hfReal_r5 ) :: avgBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar3D PROCEDURE , PUBLIC :: Free => Free_Scalar3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar3D GENERIC , PUBLIC :: Gradient => Gradient_Scalar3D PROCEDURE , PRIVATE :: Gradient_Scalar3D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar3D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar3D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Scalar3D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Scalar3D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Scalar3D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Scalar3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Scalar3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Scalar3D END TYPE Scalar3D","tags":"","loc":"type/scalar3d.html"},{"title":"Tensor2D – SELF ","text":"type, public :: Tensor2D Inherits type~~tensor2d~~InheritsGraph type~tensor2d Tensor2D Lagrange Lagrange type~tensor2d->Lagrange interp hfReal_r6 hfReal_r6 type~tensor2d->hfReal_r6 interior, boundary, extBoundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N boundary controlType extBoundary interior interp nElem nVar targetType Type-Bound Procedures ASSIGNMENT(=) AbsMaxBoundary AbsMaxInterior Add_Tensor2D BoundaryInterp Determinant Divergence Divergence_Tensor2D Equals_Tensor2D Free GridInterp Init OPERATOR(+) OPERATOR(-) Subtract_Tensor2D UpdateDevice UpdateHost Source Code Tensor2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r6), public :: boundary integer, public :: controlType type(hfReal_r6), public :: extBoundary type(hfReal_r6), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Tensor2D public subroutine Equals_Tensor2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFOut type( Tensor2D ), intent(in) :: SELFin procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Tensor2D public function AbsMaxBoundary_Tensor2D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor2D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar,1:4) procedure, public :: AbsMaxInterior => AbsMaxInterior_Tensor2D public function AbsMaxInterior_Tensor2D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor2D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar) procedure, private, PASS(SELFa) :: Add_Tensor2D public function Add_Tensor2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) procedure, public :: BoundaryInterp => BoundaryInterp_Tensor2D public subroutine BoundaryInterp_Tensor2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, public :: Determinant => Determinant_Tensor2D public subroutine Determinant_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_Tensor2D public subroutine Divergence_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Divergence_Tensor2D public subroutine Divergence_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private, PASS(SELFOut) :: Equals_Tensor2D public subroutine Equals_Tensor2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFOut type( Tensor2D ), intent(in) :: SELFin procedure, public :: Free => Free_Tensor2D public subroutine Free_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage procedure, public :: GridInterp => GridInterp_Tensor2D public subroutine GridInterp_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Tensor2D public subroutine Init_Tensor2D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: OPERATOR(+) => Add_Tensor2D public function Add_Tensor2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) generic, public :: OPERATOR(-) => Subtract_Tensor2D public function Subtract_Tensor2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) procedure, private, PASS(SELFa) :: Subtract_Tensor2D public function Subtract_Tensor2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) procedure, public :: UpdateDevice => UpdateDevice_Tensor2D public subroutine UpdateDevice_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Tensor2D public subroutine UpdateHost_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage Source Code TYPE , PUBLIC :: Tensor2D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r6 ) :: interior TYPE ( hfReal_r6 ) :: boundary TYPE ( hfReal_r6 ) :: extBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Tensor2D PROCEDURE , PUBLIC :: Free => Free_Tensor2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Tensor2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Tensor2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Tensor2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Tensor2D PROCEDURE , PUBLIC :: Determinant => Determinant_Tensor2D GENERIC , PUBLIC :: Divergence => Divergence_Tensor2D PROCEDURE , PRIVATE :: Divergence_Tensor2D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Tensor2D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Tensor2D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Tensor2D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Tensor2D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Tensor2D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Tensor2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Tensor2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Tensor2D END TYPE Tensor2D","tags":"","loc":"type/tensor2d.html"},{"title":"Tensor3D – SELF ","text":"type, public :: Tensor3D Inherits type~~tensor3d~~InheritsGraph type~tensor3d Tensor3D Lagrange Lagrange type~tensor3d->Lagrange interp hfReal_r7 hfReal_r7 type~tensor3d->hfReal_r7 interior, boundary, extBoundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N boundary controlType extBoundary interior interp nElem nVar targetType Type-Bound Procedures ASSIGNMENT(=) AbsMaxBoundary AbsMaxInterior Add_Tensor3D BoundaryInterp Determinant Divergence Divergence_Tensor3D Equals_Tensor3D Free GridInterp Init OPERATOR(+) OPERATOR(-) Subtract_Tensor3D UpdateDevice UpdateHost Source Code Tensor3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r7), public :: boundary integer, public :: controlType type(hfReal_r7), public :: extBoundary type(hfReal_r7), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Tensor3D public subroutine Equals_Tensor3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFOut type( Tensor3D ), intent(in) :: SELFin procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Tensor3D public function AbsMaxBoundary_Tensor3D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor3D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar,1:6) procedure, public :: AbsMaxInterior => AbsMaxInterior_Tensor3D public function AbsMaxInterior_Tensor3D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor3D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar) procedure, private, PASS(SELFa) :: Add_Tensor3D public function Add_Tensor3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) procedure, public :: BoundaryInterp => BoundaryInterp_Tensor3D public subroutine BoundaryInterp_Tensor3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, public :: Determinant => Determinant_Tensor3D public subroutine Determinant_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_Tensor3D public subroutine Divergence_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Divergence_Tensor3D public subroutine Divergence_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private, PASS(SELFOut) :: Equals_Tensor3D public subroutine Equals_Tensor3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFOut type( Tensor3D ), intent(in) :: SELFin procedure, public :: Free => Free_Tensor3D public subroutine Free_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage procedure, public :: GridInterp => GridInterp_Tensor3D public subroutine GridInterp_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Tensor3D public subroutine Init_Tensor3D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: OPERATOR(+) => Add_Tensor3D public function Add_Tensor3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) generic, public :: OPERATOR(-) => Subtract_Tensor3D public function Subtract_Tensor3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) procedure, private, PASS(SELFa) :: Subtract_Tensor3D public function Subtract_Tensor3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) procedure, public :: UpdateDevice => UpdateDevice_Tensor3D public subroutine UpdateDevice_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Tensor3D public subroutine UpdateHost_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage Source Code TYPE , PUBLIC :: Tensor3D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r7 ) :: interior TYPE ( hfReal_r7 ) :: boundary TYPE ( hfReal_r7 ) :: extBoundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Tensor3D PROCEDURE , PUBLIC :: Free => Free_Tensor3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Tensor3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Tensor3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Tensor3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Tensor3D PROCEDURE , PUBLIC :: Determinant => Determinant_Tensor3D GENERIC , PUBLIC :: Divergence => Divergence_Tensor3D PROCEDURE , PRIVATE :: Divergence_Tensor3D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Tensor3D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Tensor3D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Tensor3D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Tensor3D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Tensor3D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Tensor3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Tensor3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Tensor3D END TYPE Tensor3D","tags":"","loc":"type/tensor3d.html"},{"title":"Vector2D – SELF ","text":"type, public :: Vector2D Inherits type~~vector2d~~InheritsGraph type~vector2d Vector2D hfReal_r4 hfReal_r4 type~vector2d->hfReal_r4 boundaryNormal Lagrange Lagrange type~vector2d->Lagrange interp hfReal_r5 hfReal_r5 type~vector2d->hfReal_r5 interior, boundary, extBoundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N boundary boundaryNormal controlType extBoundary interior interp nElem nVar targetType Type-Bound Procedures ASSIGNMENT(=) AbsMaxBoundary AbsMaxInterior Add_Vector2D BoundaryInterp Curl Curl_Vector2D Divergence Divergence_Vector2D Equals_Vector2D Free Gradient Gradient_Vector2D GridInterp Init OPERATOR(+) OPERATOR(-) Subtract_Vector2D UpdateDevice UpdateHost Source Code Vector2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r5), public :: boundary type(hfReal_r4), public :: boundaryNormal integer, public :: controlType type(hfReal_r5), public :: extBoundary type(hfReal_r5), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Vector2D public subroutine Equals_Vector2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFOut type( Vector2D ), intent(in) :: SELFin procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Vector2D public function AbsMaxBoundary_Vector2D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector2D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar,1:4) procedure, public :: AbsMaxInterior => AbsMaxInterior_Vector2D public function AbsMaxInterior_Vector2D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector2D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar) procedure, private, PASS(SELFa) :: Add_Vector2D public function Add_Vector2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D public subroutine BoundaryInterp_Vector2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel generic, public :: Curl => Curl_Vector2D public subroutine Curl_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Curl_Vector2D public subroutine Curl_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_Vector2D public subroutine Divergence_Vector2D (SELFStorage, SELFOut, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Divergence_Vector2D public subroutine Divergence_Vector2D (SELFStorage, SELFOut, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private, PASS(SELFOut) :: Equals_Vector2D public subroutine Equals_Vector2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFOut type( Vector2D ), intent(in) :: SELFin procedure, public :: Free => Free_Vector2D public subroutine Free_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Vector2D public subroutine Gradient_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Gradient_Vector2D public subroutine Gradient_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Vector2D public subroutine GridInterp_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Vector2D public subroutine Init_Vector2D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: OPERATOR(+) => Add_Vector2D public function Add_Vector2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) generic, public :: OPERATOR(-) => Subtract_Vector2D public function Subtract_Vector2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) procedure, private, PASS(SELFa) :: Subtract_Vector2D public function Subtract_Vector2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) procedure, public :: UpdateDevice => UpdateDevice_Vector2D public subroutine UpdateDevice_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Vector2D public subroutine UpdateHost_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage Source Code TYPE , PUBLIC :: Vector2D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r5 ) :: interior TYPE ( hfReal_r5 ) :: boundary TYPE ( hfReal_r5 ) :: extBoundary TYPE ( hfReal_r4 ) :: boundaryNormal CONTAINS PROCEDURE , PUBLIC :: Init => Init_Vector2D PROCEDURE , PUBLIC :: Free => Free_Vector2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Vector2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Vector2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Vector2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Vector2D GENERIC , PUBLIC :: Gradient => Gradient_Vector2D PROCEDURE , PRIVATE :: Gradient_Vector2D GENERIC , PUBLIC :: Divergence => Divergence_Vector2D PROCEDURE , PRIVATE :: Divergence_Vector2D GENERIC , PUBLIC :: Curl => Curl_Vector2D PROCEDURE , PRIVATE :: Curl_Vector2D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Vector2D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Vector2D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Vector2D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Vector2D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Vector2D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Vector2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Vector2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Vector2D END TYPE Vector2D","tags":"","loc":"type/vector2d.html"},{"title":"Vector3D – SELF ","text":"type, public :: Vector3D Inherits type~~vector3d~~InheritsGraph type~vector3d Vector3D Lagrange Lagrange type~vector3d->Lagrange interp hfReal_r6 hfReal_r6 type~vector3d->hfReal_r6 interior, boundary, extBoundary hfReal_r5 hfReal_r5 type~vector3d->hfReal_r5 boundaryNormal Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N boundary boundaryNormal controlType extBoundary interior interp nElem nVar targetType Type-Bound Procedures ASSIGNMENT(=) AbsMaxBoundary AbsMaxInterior Add_Vector3D BoundaryInterp Curl Curl_Vector3D Divergence Divergence_Vector3D Equals_Vector3D Free Gradient Gradient_Vector3D GridInterp Init OPERATOR(+) OPERATOR(-) Subtract_Vector3D UpdateDevice UpdateHost Source Code Vector3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r6), public :: boundary type(hfReal_r5), public :: boundaryNormal integer, public :: controlType type(hfReal_r6), public :: extBoundary type(hfReal_r6), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Vector3D public subroutine Equals_Vector3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFOut type( Vector3D ), intent(in) :: SELFin procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Vector3D public function AbsMaxBoundary_Vector3D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector3D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar,1:6) procedure, public :: AbsMaxInterior => AbsMaxInterior_Vector3D public function AbsMaxInterior_Vector3D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector3D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar) procedure, private, PASS(SELFa) :: Add_Vector3D public function Add_Vector3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D public subroutine BoundaryInterp_Vector3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel generic, public :: Curl => Curl_Vector3D public subroutine Curl_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Curl_Vector3D public subroutine Curl_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_Vector3D public subroutine Divergence_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Divergence_Vector3D public subroutine Divergence_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private, PASS(SELFOut) :: Equals_Vector3D public subroutine Equals_Vector3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFOut type( Vector3D ), intent(in) :: SELFin procedure, public :: Free => Free_Vector3D public subroutine Free_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Vector3D public subroutine Gradient_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Gradient_Vector3D public subroutine Gradient_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Vector3D public subroutine GridInterp_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Vector3D public subroutine Init_Vector3D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: OPERATOR(+) => Add_Vector3D public function Add_Vector3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) generic, public :: OPERATOR(-) => Subtract_Vector3D public function Subtract_Vector3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) procedure, private, PASS(SELFa) :: Subtract_Vector3D public function Subtract_Vector3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) procedure, public :: UpdateDevice => UpdateDevice_Vector3D public subroutine UpdateDevice_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Vector3D public subroutine UpdateHost_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage Source Code TYPE , PUBLIC :: Vector3D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r6 ) :: interior TYPE ( hfReal_r6 ) :: boundary TYPE ( hfReal_r6 ) :: extBoundary TYPE ( hfReal_r5 ) :: boundaryNormal CONTAINS PROCEDURE , PUBLIC :: Init => Init_Vector3D PROCEDURE , PUBLIC :: Free => Free_Vector3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Vector3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Vector3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Vector3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Vector3D GENERIC , PUBLIC :: Gradient => Gradient_Vector3D PROCEDURE , PRIVATE :: Gradient_Vector3D GENERIC , PUBLIC :: Divergence => Divergence_Vector3D PROCEDURE , PRIVATE :: Divergence_Vector3D GENERIC , PUBLIC :: Curl => Curl_Vector3D PROCEDURE , PRIVATE :: Curl_Vector3D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Vector3D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Vector3D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Vector3D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Vector3D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Vector3D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Vector3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Vector3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Vector3D END TYPE Vector3D","tags":"","loc":"type/vector3d.html"},{"title":"Mesh1D – SELF ","text":"type, public :: Mesh1D Inherits type~~mesh1d~~InheritsGraph type~mesh1d Mesh1D hfInt32_r1 hfInt32_r1 type~mesh1d->hfInt32_r1 hopr_globalNodeIDs hfInt32_r2 hfInt32_r2 type~mesh1d->hfInt32_r2 hopr_elemInfo, BCType hfReal_r1 hfReal_r1 type~mesh1d->hfReal_r1 hopr_nodeCoords Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables BCNames BCType hopr_elemInfo hopr_globalNodeIDs hopr_nodeCoords nBCs nCornerNodes nElem nGeo nNodes nUniqueNodes Type-Bound Procedures Free Init Read_HOPr Read_HOPr_Mesh1D_parallel Read_HOPr_Mesh1D_serial UniformBlockMesh UpdateDevice UpdateHost Write_HOPr Source Code Mesh1D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type(hfInt32_r2), public :: BCType type(hfInt32_r2), public :: hopr_elemInfo type(hfInt32_r1), public :: hopr_globalNodeIDs type(hfReal_r1), public :: hopr_nodeCoords integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nNodes integer, public :: nUniqueNodes Type-Bound Procedures procedure, public :: Free => Free_Mesh1D public subroutine Free_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh procedure, public :: Init => Init_Mesh1D public subroutine Init_Mesh1D (myMesh, nGeo, nElem, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nNodes integer, intent(in) :: nBCs generic, public :: Read_HOPr => Read_HOPr_Mesh1D_serial , Read_HOPr_Mesh1D_parallel public subroutine Read_HOPr_Mesh1D_serial (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh character, intent(in) :: meshFile public subroutine Read_HOPr_Mesh1D_parallel (myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh character, intent(in) :: meshFile type(MPILayer), intent(inout) :: decomp procedure, private :: Read_HOPr_Mesh1D_parallel public subroutine Read_HOPr_Mesh1D_parallel (myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh character, intent(in) :: meshFile type(MPILayer), intent(inout) :: decomp procedure, private :: Read_HOPr_Mesh1D_serial public subroutine Read_HOPr_Mesh1D_serial (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh character, intent(in) :: meshFile procedure, public :: UniformBlockMesh => UniformBlockMesh_Mesh1D public subroutine UniformBlockMesh_Mesh1D (myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem real(kind=prec), intent(in) :: x (1:2) procedure, public :: UpdateDevice => UpdateDevice_Mesh1D public subroutine UpdateDevice_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh procedure, public :: UpdateHost => UpdateHost_Mesh1D public subroutine UpdateHost_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh procedure, public :: Write_HOPr => Write_HOPr_Mesh1D public subroutine Write_HOPr_Mesh1D (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh character, intent(in) :: meshFile Source Code TYPE , PUBLIC :: Mesh1D INTEGER :: nGeo INTEGER :: nElem INTEGER :: nNodes INTEGER :: nCornerNodes INTEGER :: nUniqueNodes INTEGER :: nBCs TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfReal_r1 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh1D PROCEDURE , PUBLIC :: Free => Free_Mesh1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh1D PROCEDURE , PUBLIC :: UniformBlockMesh => UniformBlockMesh_Mesh1D GENERIC , PUBLIC :: Read_HOPr => Read_HOPr_Mesh1D_serial , Read_HOPr_Mesh1D_parallel PROCEDURE , PRIVATE :: Read_HOPr_Mesh1D_serial , Read_HOPr_Mesh1D_parallel PROCEDURE , PUBLIC :: Write_HOPr => Write_HOPr_Mesh1D END TYPE Mesh1D","tags":"","loc":"type/mesh1d.html"},{"title":"Mesh2D – SELF ","text":"type, public :: Mesh2D Inherits type~~mesh2d~~InheritsGraph type~mesh2d Mesh2D hfInt32_r3 hfInt32_r3 type~mesh2d->hfInt32_r3 self_sideInfo hfReal_r4 hfReal_r4 type~mesh2d->hfReal_r4 hohq_sideCurves hfInt32_r2 hfInt32_r2 type~mesh2d->hfInt32_r2 hohq_elemInfo, hohq_sideInfo, hopr_elemInfo, hopr_sideInfo, hopr_CGNSSideMap, hopr_curveNodeMap, hopr_curveNodeMapInv, BCType hfReal_r3 hfReal_r3 type~mesh2d->hfReal_r3 self_nodeCoords hfReal_r2 hfReal_r2 type~mesh2d->hfReal_r2 hohq_cornerNodes, hopr_nodeCoords hfInt32_r1 hfInt32_r1 type~mesh2d->hfInt32_r1 hopr_globalNodeIDs, hopr_CGNSCornerMap Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables BCNames BCType hohq_cornerNodes hohq_elemInfo hohq_sideCurves hohq_sideInfo hopr_CGNSCornerMap hopr_CGNSSideMap hopr_curveNodeMap hopr_curveNodeMapInv hopr_elemInfo hopr_globalNodeIDs hopr_nodeCoords hopr_sideInfo nBCs nCornerNodes nElem nGeo nNodes nSides nUniqueNodes nUniqueSides self_nodeCoords self_sideInfo Type-Bound Procedures Free GenerateConnectivity Init Load Load_Mesh2D_parallel Load_Mesh2D_serial Read_HOPr Read_HOPr_Mesh2D_parallel Read_HOPr_Mesh2D_serial Read_ISMv2 UniformBlockMesh UpdateDevice UpdateHost Write_HOPr Source Code Mesh2D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type(hfInt32_r2), public :: BCType type(hfReal_r2), public :: hohq_cornerNodes type(hfInt32_r2), public :: hohq_elemInfo type(hfReal_r4), public :: hohq_sideCurves type(hfInt32_r2), public :: hohq_sideInfo type(hfInt32_r1), public :: hopr_CGNSCornerMap type(hfInt32_r2), public :: hopr_CGNSSideMap type(hfInt32_r2), public :: hopr_curveNodeMap type(hfInt32_r2), public :: hopr_curveNodeMapInv type(hfInt32_r2), public :: hopr_elemInfo type(hfInt32_r1), public :: hopr_globalNodeIDs type(hfReal_r2), public :: hopr_nodeCoords type(hfInt32_r2), public :: hopr_sideInfo integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides type(hfReal_r3), public :: self_nodeCoords type(hfInt32_r3), public :: self_sideInfo Type-Bound Procedures procedure, public :: Free => Free_Mesh2D public subroutine Free_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh procedure, private :: GenerateConnectivity => GenerateConnectivity_Mesh2D public subroutine GenerateConnectivity_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh procedure, public :: Init => Init_Mesh2D public subroutine Init_Mesh2D (myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs generic, public :: Load => Load_Mesh2D_serial , Load_Mesh2D_parallel public subroutine Load_Mesh2D_serial (myMesh, myMeshSpec) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec public subroutine Load_Mesh2D_parallel (myMesh, myMeshSpec, decomp) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec type(MPILayer), intent(inout) :: decomp procedure, private :: Load_Mesh2D_parallel public subroutine Load_Mesh2D_parallel (myMesh, myMeshSpec, decomp) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec type(MPILayer), intent(inout) :: decomp procedure, private :: Load_Mesh2D_serial public subroutine Load_Mesh2D_serial (myMesh, myMeshSpec) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec generic, public :: Read_HOPr => Read_HOPr_Mesh2D_serial , Read_HOPr_Mesh2D_parallel public subroutine Read_HOPr_Mesh2D_serial (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh character, intent(in) :: meshFile public subroutine Read_HOPr_Mesh2D_parallel (myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh character, intent(in) :: meshFile type(MPILayer), intent(inout) :: decomp procedure, private :: Read_HOPr_Mesh2D_parallel public subroutine Read_HOPr_Mesh2D_parallel (myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh character, intent(in) :: meshFile type(MPILayer), intent(inout) :: decomp procedure, private :: Read_HOPr_Mesh2D_serial public subroutine Read_HOPr_Mesh2D_serial (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh character, intent(in) :: meshFile procedure, public :: Read_ISMv2 => Read_ISMv2_Mesh2D public subroutine Read_ISMv2_Mesh2D (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh character, intent(in) :: meshFile procedure, public :: UniformBlockMesh => UniformBlockMesh_Mesh2D public subroutine UniformBlockMesh_Mesh2D (myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem (1:2) real(kind=prec), intent(in) :: x (1:4) procedure, public :: UpdateDevice => UpdateDevice_Mesh2D public subroutine UpdateDevice_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh procedure, public :: UpdateHost => UpdateHost_Mesh2D public subroutine UpdateHost_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh procedure, public :: Write_HOPr => Write_HOPr_Mesh2D public subroutine Write_HOPr_Mesh2D (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh character, intent(in) :: meshFile Source Code TYPE , PUBLIC :: Mesh2D INTEGER :: nGeo INTEGER :: nElem INTEGER :: nNodes INTEGER :: nSides INTEGER :: nCornerNodes INTEGER :: nUniqueNodes INTEGER :: nUniqueSides INTEGER :: nBCs TYPE ( hfInt32_r3 ) :: self_sideInfo TYPE ( hfReal_r3 ) :: self_nodeCoords TYPE ( hfReal_r2 ) :: hohq_cornerNodes TYPE ( hfInt32_r2 ) :: hohq_elemInfo TYPE ( hfInt32_r2 ) :: hohq_sideInfo TYPE ( hfReal_r4 ) :: hohq_sideCurves TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r1 ) :: hopr_CGNSCornerMap TYPE ( hfInt32_r2 ) :: hopr_CGNSSideMap TYPE ( hfInt32_r2 ) :: hopr_curveNodeMap TYPE ( hfInt32_r2 ) :: hopr_curveNodeMapInv TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh2D PROCEDURE , PUBLIC :: Free => Free_Mesh2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh2D PROCEDURE , PUBLIC :: UniformBlockMesh => UniformBlockMesh_Mesh2D GENERIC , PUBLIC :: Load => Load_Mesh2D_serial , Load_Mesh2D_parallel PROCEDURE , PRIVATE :: Load_Mesh2D_serial , Load_Mesh2D_parallel GENERIC , PUBLIC :: Read_HOPr => Read_HOPr_Mesh2D_serial , Read_HOPr_Mesh2D_parallel PROCEDURE , PRIVATE :: Read_HOPr_Mesh2D_serial , Read_HOPr_Mesh2D_parallel PROCEDURE , PUBLIC :: Write_HOPr => Write_HOPr_Mesh2D PROCEDURE , PUBLIC :: Read_ISMv2 => Read_ISMv2_Mesh2D PROCEDURE , PRIVATE :: GenerateConnectivity => GenerateConnectivity_Mesh2D END TYPE Mesh2D","tags":"","loc":"type/mesh2d.html"},{"title":"Mesh3D – SELF ","text":"type, public :: Mesh3D Inherits type~~mesh3d~~InheritsGraph type~mesh3d Mesh3D hfInt32_r3 hfInt32_r3 type~mesh3d->hfInt32_r3 self_sideInfo, hopr_curveNodeMapInv hfInt32_r2 hfInt32_r2 type~mesh3d->hfInt32_r2 hohq_elemInfo, hohq_sideInfo, hopr_elemInfo, hopr_sideInfo, hopr_CGNSSideMap, hopr_curveNodeMap, BCType hfReal_r5 hfReal_r5 type~mesh3d->hfReal_r5 hohq_sideSurfaces hfReal_r3 hfReal_r3 type~mesh3d->hfReal_r3 self_nodeCoords hfReal_r2 hfReal_r2 type~mesh3d->hfReal_r2 hohq_cornerNodes, hopr_nodeCoords hfInt32_r1 hfInt32_r1 type~mesh3d->hfInt32_r1 hopr_globalNodeIDs, hopr_CGNSCornerMap Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables BCNames BCType hohq_cornerNodes hohq_elemInfo hohq_sideInfo hohq_sideSurfaces hopr_CGNSCornerMap hopr_CGNSSideMap hopr_curveNodeMap hopr_curveNodeMapInv hopr_elemInfo hopr_globalNodeIDs hopr_nodeCoords hopr_sideInfo nBCs nCornerNodes nElem nGeo nNodes nSides nUniqueNodes nUniqueSides self_nodeCoords self_sideInfo Type-Bound Procedures Free Init Load Load_Mesh3D_parallel Load_Mesh3D_serial Read_HOPr Read_HOPr_Mesh3D_parallel Read_HOPr_Mesh3D_serial UniformBlockMesh UpdateDevice UpdateHost Write_HOPr Source Code Mesh3D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type(hfInt32_r2), public :: BCType type(hfReal_r2), public :: hohq_cornerNodes type(hfInt32_r2), public :: hohq_elemInfo type(hfInt32_r2), public :: hohq_sideInfo type(hfReal_r5), public :: hohq_sideSurfaces type(hfInt32_r1), public :: hopr_CGNSCornerMap type(hfInt32_r2), public :: hopr_CGNSSideMap type(hfInt32_r2), public :: hopr_curveNodeMap type(hfInt32_r3), public :: hopr_curveNodeMapInv type(hfInt32_r2), public :: hopr_elemInfo type(hfInt32_r1), public :: hopr_globalNodeIDs type(hfReal_r2), public :: hopr_nodeCoords type(hfInt32_r2), public :: hopr_sideInfo integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides type(hfReal_r3), public :: self_nodeCoords type(hfInt32_r3), public :: self_sideInfo Type-Bound Procedures procedure, public :: Free => Free_Mesh3D public subroutine Free_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh procedure, public :: Init => Init_Mesh3D public subroutine Init_Mesh3D (myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs generic, public :: Load => Load_Mesh3D_serial , Load_Mesh3D_parallel public subroutine Load_Mesh3D_serial (myMesh, myMeshSpec) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec public subroutine Load_Mesh3D_parallel (myMesh, myMeshSpec, decomp) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec type(MPILayer), intent(inout) :: decomp procedure, private :: Load_Mesh3D_parallel public subroutine Load_Mesh3D_parallel (myMesh, myMeshSpec, decomp) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec type(MPILayer), intent(inout) :: decomp procedure, private :: Load_Mesh3D_serial public subroutine Load_Mesh3D_serial (myMesh, myMeshSpec) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec generic, public :: Read_HOPr => Read_HOPr_Mesh3D_serial , Read_HOPr_Mesh3D_parallel public subroutine Read_HOPr_Mesh3D_serial (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh character, intent(in) :: meshFile public subroutine Read_HOPr_Mesh3D_parallel (myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh character, intent(in) :: meshFile type(MPILayer), intent(inout) :: decomp procedure, private :: Read_HOPr_Mesh3D_parallel public subroutine Read_HOPr_Mesh3D_parallel (myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh character, intent(in) :: meshFile type(MPILayer), intent(inout) :: decomp procedure, private :: Read_HOPr_Mesh3D_serial public subroutine Read_HOPr_Mesh3D_serial (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh character, intent(in) :: meshFile procedure, public :: UniformBlockMesh => UniformBlockMesh_Mesh3D public subroutine UniformBlockMesh_Mesh3D (myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem (1:3) real(kind=prec), intent(in) :: x (1:6) procedure, public :: UpdateDevice => UpdateDevice_Mesh3D public subroutine UpdateDevice_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh procedure, public :: UpdateHost => UpdateHost_Mesh3D public subroutine UpdateHost_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh procedure, public :: Write_HOPr => Write_HOPr_Mesh3D public subroutine Write_HOPr_Mesh3D (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh character, intent(in) :: meshFile Source Code TYPE , PUBLIC :: Mesh3D INTEGER :: nGeo INTEGER :: nElem INTEGER :: nNodes INTEGER :: nSides INTEGER :: nCornerNodes INTEGER :: nUniqueNodes INTEGER :: nUniqueSides INTEGER :: nBCs TYPE ( hfInt32_r3 ) :: self_sideInfo TYPE ( hfReal_r3 ) :: self_nodeCoords TYPE ( hfReal_r2 ) :: hohq_cornerNodes TYPE ( hfInt32_r2 ) :: hohq_elemInfo TYPE ( hfInt32_r2 ) :: hohq_sideInfo TYPE ( hfReal_r5 ) :: hohq_sideSurfaces TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r1 ) :: hopr_CGNSCornerMap TYPE ( hfInt32_r2 ) :: hopr_CGNSSideMap TYPE ( hfInt32_r2 ) :: hopr_curveNodeMap TYPE ( hfInt32_r3 ) :: hopr_curveNodeMapInv TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh3D PROCEDURE , PUBLIC :: Free => Free_Mesh3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh3D PROCEDURE , PUBLIC :: UniformBlockMesh => UniformBlockMesh_Mesh3D GENERIC , PUBLIC :: Load => Load_Mesh3D_serial , Load_Mesh3D_parallel PROCEDURE , PRIVATE :: Load_Mesh3D_serial , Load_Mesh3D_parallel GENERIC , PUBLIC :: Read_HOPr => Read_HOPr_Mesh3D_serial , Read_HOPr_Mesh3D_parallel PROCEDURE , PRIVATE :: Read_HOPr_Mesh3D_serial , Read_HOPr_Mesh3D_parallel PROCEDURE , PUBLIC :: Write_HOPr => Write_HOPr_Mesh3D END TYPE Mesh3D","tags":"","loc":"type/mesh3d.html"},{"title":"MeshSpec – SELF ","text":"type, public :: MeshSpec Contents Variables blockMesh blockMesh_nElemX blockMesh_nElemY blockMesh_nElemZ blockMesh_nGeo blockMesh_x0 blockMesh_x1 blockMesh_y0 blockMesh_y1 blockMesh_z0 blockMesh_z1 fileType filename Source Code MeshSpec Components Type Visibility Attributes Name Initial logical, public :: blockMesh integer, public :: blockMesh_nElemX integer, public :: blockMesh_nElemY integer, public :: blockMesh_nElemZ integer, public :: blockMesh_nGeo real(kind=prec), public :: blockMesh_x0 real(kind=prec), public :: blockMesh_x1 real(kind=prec), public :: blockMesh_y0 real(kind=prec), public :: blockMesh_y1 real(kind=prec), public :: blockMesh_z0 real(kind=prec), public :: blockMesh_z1 integer, public :: fileType character, public :: filename Source Code TYPE MeshSpec CHARACTER ( self_FileNameLength ) :: filename INTEGER :: fileType LOGICAL :: blockMesh INTEGER :: blockMesh_nGeo INTEGER :: blockMesh_nElemX INTEGER :: blockMesh_nElemY INTEGER :: blockMesh_nElemZ REAL ( prec ) :: blockMesh_x0 , blockMesh_x1 REAL ( prec ) :: blockMesh_y0 , blockMesh_y1 REAL ( prec ) :: blockMesh_z0 , blockMesh_z1 END TYPE MeshSpec","tags":"","loc":"type/meshspec.html"},{"title":"MPILayer – SELF ","text":"type, public :: MPILayer Inherits type~~mpilayer~~InheritsGraph type~mpilayer MPILayer hfInt32_r1 hfInt32_r1 type~mpilayer->hfInt32_r1 elemToRank, offSetElem hfInt32_r2 hfInt32_r2 type~mpilayer->hfInt32_r2 requests Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables elemToRank maxMsg mpiComm mpiEnabled mpiPrec msgCount nElem nRanks offSetElem rankId requests Type-Bound Procedures FinalizeMPIExchangeAsync Free Init SetElemToRank SetMaxMsg Source Code MPILayer Components Type Visibility Attributes Name Initial type(hfInt32_r1), public :: elemToRank integer, public :: maxMsg integer, public :: mpiComm logical, public :: mpiEnabled integer, public :: mpiPrec integer, public :: msgCount integer, public :: nElem integer, public :: nRanks type(hfInt32_r1), public :: offSetElem integer, public :: rankId type(hfInt32_r2), public :: requests Type-Bound Procedures procedure, public :: FinalizeMPIExchangeAsync public subroutine FinalizeMPIExchangeAsync (mpiHandler) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: mpiHandler procedure, public :: Free => Free_MPILayer public subroutine Free_MPILayer (this) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this procedure, public :: Init => Init_MPILayer public subroutine Init_MPILayer (this, enableMPI) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(out) :: this logical, intent(in) :: enableMPI procedure, public :: SetElemToRank public subroutine SetElemToRank (this, nElem) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this integer, intent(in) :: nElem procedure, public :: SetMaxMsg public subroutine SetMaxMsg (this, maxMsg) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this integer, intent(in) :: maxMsg Source Code TYPE MPILayer LOGICAL :: mpiEnabled INTEGER :: mpiComm INTEGER :: mpiPrec INTEGER :: rankId INTEGER :: nRanks INTEGER :: nElem INTEGER :: maxMsg INTEGER :: msgCount TYPE ( hfInt32_r1 ) :: elemToRank TYPE ( hfInt32_r1 ) :: offSetElem TYPE ( hfInt32_r2 ) :: requests CONTAINS PROCEDURE :: Init => Init_MPILayer PROCEDURE :: Free => Free_MPILayer PROCEDURE :: SetElemToRank PROCEDURE :: SetMaxMsg PROCEDURE , PUBLIC :: FinalizeMPIExchangeAsync END TYPE MPILayer","tags":"","loc":"type/mpilayer.html"},{"title":"Geometry1D – SELF ","text":"type, public :: Geometry1D Inherits type~~geometry1d~~InheritsGraph type~geometry1d Geometry1D Scalar1D Scalar1D type~geometry1d->Scalar1D x, dxds Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cqType dxds nElem tqType x Type-Bound Procedures CalculateMetricTerms Free GenerateFromMesh Init UpdateDevice UpdateHost Source Code Geometry1D Components Type Visibility Attributes Name Initial integer, public :: cqType type(Scalar1D), public :: dxds integer, public :: nElem integer, public :: tqType type(Scalar1D), public :: x Type-Bound Procedures procedure, public :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D public subroutine CalculateMetricTerms_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom procedure, public :: Free => Free_Geometry1D public subroutine Free_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom procedure, public :: GenerateFromMesh => GenerateFromMesh_Geometry1D public subroutine GenerateFromMesh_Geometry1D (myGeom, mesh, cqType, tqType, cqDegree, tqDegree, meshQuadrature) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom type(Mesh1D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in), optional :: meshQuadrature procedure, public :: Init => Init_Geometry1D public subroutine Init_Geometry1D (myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem procedure, public :: UpdateDevice => UpdateDevice_Geometry1D public subroutine UpdateDevice_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom procedure, public :: UpdateHost => UpdateHost_Geometry1D public subroutine UpdateHost_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Source Code TYPE , PUBLIC :: Geometry1D INTEGER :: cqType ! Control Quadrature Type INTEGER :: tqType ! Target Quadrature Type INTEGER :: nElem TYPE ( Scalar1D ) :: x ! Physical Positions TYPE ( Scalar1D ) :: dxds ! Conversion from computational to physical space CONTAINS PROCEDURE , PUBLIC :: Init => Init_Geometry1D PROCEDURE , PUBLIC :: Free => Free_Geometry1D PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_Geometry1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Geometry1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Geometry1D PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D END TYPE Geometry1D","tags":"","loc":"type/geometry1d.html"},{"title":"SEMHex – SELF ","text":"type, public :: SEMHex Inherits type~~semhex~~InheritsGraph type~semhex SEMHex Tensor3D Tensor3D type~semhex->Tensor3D dxds, dsdx Scalar3D Scalar3D type~semhex->Scalar3D nScale, J Vector3D Vector3D type~semhex->Vector3D x, nHat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables J cqType dsdx dxds nElem nHat nScale tqType x Type-Bound Procedures CalculateContravariantBasis CalculateMetricTerms Free GenerateFromMesh Init UpdateDevice UpdateHost Source Code SEMHex Components Type Visibility Attributes Name Initial type(Scalar3D), public :: J integer, public :: cqType type(Tensor3D), public :: dsdx type(Tensor3D), public :: dxds integer, public :: nElem type(Vector3D), public :: nHat type(Scalar3D), public :: nScale integer, public :: tqType type(Vector3D), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex public subroutine CalculateContravariantBasis_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMHex public subroutine CalculateMetricTerms_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom procedure, public :: Free => Free_SEMHex public subroutine Free_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMHex public subroutine GenerateFromMesh_SEMHex (myGeom, mesh, cqType, tqType, cqDegree, tqDegree, meshQuadrature) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom type(Mesh3D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in), optional :: meshQuadrature procedure, public :: Init => Init_SEMHex public subroutine Init_SEMHex (myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem procedure, public :: UpdateDevice => UpdateDevice_SEMHex public subroutine UpdateDevice_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom procedure, public :: UpdateHost => UpdateHost_SEMHex public subroutine UpdateHost_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Source Code TYPE , PUBLIC :: SEMHex INTEGER :: cqType ! Control Quadrature Type INTEGER :: tqType ! Target Quadrature Type INTEGER :: nElem TYPE ( Vector3D ) :: x ! Physical positions TYPE ( Tensor3D ) :: dxds ! Covariant basis vectors TYPE ( Tensor3D ) :: dsdx ! Contavariant basis vectors TYPE ( Vector3D ) :: nHat ! Normal Vectors pointing across coordinate lines TYPE ( Scalar3D ) :: nScale ! Boundary scale TYPE ( Scalar3D ) :: J ! Jacobian of the transformation CONTAINS PROCEDURE , PUBLIC :: Init => Init_SEMHex PROCEDURE , PUBLIC :: Free => Free_SEMHex PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_SEMHex PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_SEMHex PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_SEMHex PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_SEMHex PROCEDURE , PRIVATE :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex END TYPE SEMHex","tags":"","loc":"type/semhex.html"},{"title":"SEMQuad – SELF ","text":"type, public :: SEMQuad Inherits type~~semquad~~InheritsGraph type~semquad SEMQuad Tensor2D Tensor2D type~semquad->Tensor2D dxds, dsdx Vector2D Vector2D type~semquad->Vector2D x, nHat Scalar2D Scalar2D type~semquad->Scalar2D nScale, J Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables J cqType dsdx dxds nElem nHat nScale tqType x Type-Bound Procedures CalculateContravariantBasis CalculateMetricTerms Free GenerateFromMesh Init UpdateDevice UpdateHost Source Code SEMQuad Components Type Visibility Attributes Name Initial type(Scalar2D), public :: J integer, public :: cqType type(Tensor2D), public :: dsdx type(Tensor2D), public :: dxds integer, public :: nElem type(Vector2D), public :: nHat type(Scalar2D), public :: nScale integer, public :: tqType type(Vector2D), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad public subroutine CalculateContravariantBasis_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad public subroutine CalculateMetricTerms_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom procedure, public :: Free => Free_SEMQuad public subroutine Free_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMQuad public subroutine GenerateFromMesh_SEMQuad (myGeom, mesh, cqType, tqType, cqDegree, tqDegree, meshQuadrature) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom type(Mesh2D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in), optional :: meshQuadrature procedure, public :: Init => Init_SEMQuad public subroutine Init_SEMQuad (myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem procedure, public :: UpdateDevice => UpdateDevice_SEMQuad public subroutine UpdateDevice_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom procedure, public :: UpdateHost => UpdateHost_SEMQuad public subroutine UpdateHost_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Source Code TYPE , PUBLIC :: SEMQuad INTEGER :: cqType ! Control Quadrature Type INTEGER :: tqType ! Target Quadrature Type INTEGER :: nElem TYPE ( Vector2D ) :: x ! Physical positions TYPE ( Tensor2D ) :: dxds ! Covariant basis vectors TYPE ( Tensor2D ) :: dsdx ! Contavariant basis vectors TYPE ( Vector2D ) :: nHat ! Normal Vectors pointing across coordinate lines TYPE ( Scalar2D ) :: nScale ! Boundary scale TYPE ( Scalar2D ) :: J ! Jacobian of the transformation CONTAINS PROCEDURE , PUBLIC :: Init => Init_SEMQuad PROCEDURE , PUBLIC :: Free => Free_SEMQuad PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_SEMQuad PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_SEMQuad PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_SEMQuad PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad PROCEDURE , PRIVATE :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad END TYPE SEMQuad","tags":"","loc":"type/semquad.html"},{"title":"MappedScalar1D – SELF ","text":"type, public, extends(Scalar1D) :: MappedScalar1D Inherits type~~mappedscalar1d~~InheritsGraph type~mappedscalar1d MappedScalar1D Scalar1D Scalar1D type~mappedscalar1d->Scalar1D Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures Derivative Derivative_MappedScalar1D JacobianWeight Source Code MappedScalar1D Type-Bound Procedures generic, public :: Derivative => Derivative_MappedScalar1D public subroutine Derivative_MappedScalar1D (scalar, geometry, dF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: scalar type(Geometry1D), intent(in) :: geometry type( MappedScalar1D ), intent(inout) :: dF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Derivative_MappedScalar1D public subroutine Derivative_MappedScalar1D (scalar, geometry, dF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: scalar type(Geometry1D), intent(in) :: geometry type( MappedScalar1D ), intent(inout) :: dF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, public :: JacobianWeight => JacobianWeight_MappedScalar1D public subroutine JacobianWeight_MappedScalar1D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar type(Geometry1D), intent(in) :: geometry logical, intent(in) :: gpuAccel Source Code TYPE , EXTENDS ( Scalar1D ), PUBLIC :: MappedScalar1D CONTAINS GENERIC , PUBLIC :: Derivative => Derivative_MappedScalar1D PROCEDURE , PRIVATE :: Derivative_MappedScalar1D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedScalar1D END TYPE MappedScalar1D","tags":"","loc":"type/mappedscalar1d.html"},{"title":"MappedScalar2D – SELF ","text":"type, public, extends(Scalar2D) :: MappedScalar2D Inherits type~~mappedscalar2d~~InheritsGraph type~mappedscalar2d MappedScalar2D Scalar2D Scalar2D type~mappedscalar2d->Scalar2D Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures ApplyFlip BassiRebaySides ContravariantWeight Gradient Gradient_MappedScalar2D JacobianWeight MPIExchangeAsync SideExchange Source Code MappedScalar2D Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedScalar2D public subroutine ApplyFlip_MappedScalar2D (scalar, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: gpuAccel procedure, public :: BassiRebaySides => BassiRebaySides_MappedScalar2D public subroutine BassiRebaySides_MappedScalar2D (scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel procedure, private :: ContravariantWeight => ContravariantWeight_MappedScalar2D public subroutine ContravariantWeight_MappedScalar2D (scalar, geometry, workTensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type(SEMQuad), intent(in) :: geometry type( MappedTensor2D ), intent(inout) :: workTensor logical, intent(in) :: gpuAccel generic, public :: Gradient => Gradient_MappedScalar2D public subroutine Gradient_MappedScalar2D (scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Gradient_MappedScalar2D public subroutine Gradient_MappedScalar2D (scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, public :: JacobianWeight => JacobianWeight_MappedScalar2D public subroutine JacobianWeight_MappedScalar2D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D public subroutine MPIExchangeAsync_MappedScalar2D (scalar, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: resetCount procedure, public :: SideExchange => SideExchange_MappedScalar2D public subroutine SideExchange_MappedScalar2D (scalar, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type(Mesh2D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel Source Code TYPE , EXTENDS ( Scalar2D ), PUBLIC :: MappedScalar2D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedScalar2D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedScalar2D GENERIC , PUBLIC :: Gradient => Gradient_MappedScalar2D PROCEDURE , PRIVATE :: Gradient_MappedScalar2D PROCEDURE , PRIVATE :: ContravariantWeight => ContravariantWeight_MappedScalar2D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedScalar2D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedScalar2D END TYPE MappedScalar2D","tags":"","loc":"type/mappedscalar2d.html"},{"title":"MappedScalar3D – SELF ","text":"type, public, extends(Scalar3D) :: MappedScalar3D Inherits type~~mappedscalar3d~~InheritsGraph type~mappedscalar3d MappedScalar3D Scalar3D Scalar3D type~mappedscalar3d->Scalar3D Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures ApplyFlip BassiRebaySides ContravariantWeight Gradient Gradient_MappedScalar3D JacobianWeight MPIExchangeAsync SideExchange Source Code MappedScalar3D Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedScalar3D public subroutine ApplyFlip_MappedScalar3D (scalar, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: gpuAccel procedure, public :: BassiRebaySides => BassiRebaySides_MappedScalar3D public subroutine BassiRebaySides_MappedScalar3D (scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel procedure, private :: ContravariantWeight => ContravariantWeight_MappedScalar3D public subroutine ContravariantWeight_MappedScalar3D (scalar, geometry, workTensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type(SEMHex), intent(in) :: geometry type( MappedTensor3D ), intent(inout) :: workTensor logical, intent(in) :: gpuAccel generic, public :: Gradient => Gradient_MappedScalar3D public subroutine Gradient_MappedScalar3D (scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Gradient_MappedScalar3D public subroutine Gradient_MappedScalar3D (scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, public :: JacobianWeight => JacobianWeight_MappedScalar3D public subroutine JacobianWeight_MappedScalar3D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D public subroutine MPIExchangeAsync_MappedScalar3D (scalar, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: resetCount procedure, public :: SideExchange => SideExchange_MappedScalar3D public subroutine SideExchange_MappedScalar3D (scalar, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type(Mesh3D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel Source Code TYPE , EXTENDS ( Scalar3D ), PUBLIC :: MappedScalar3D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedScalar3D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedScalar3D GENERIC , PUBLIC :: Gradient => Gradient_MappedScalar3D PROCEDURE , PRIVATE :: Gradient_MappedScalar3D PROCEDURE , PRIVATE :: ContravariantWeight => ContravariantWeight_MappedScalar3D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedScalar3D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedScalar3D END TYPE MappedScalar3D","tags":"","loc":"type/mappedscalar3d.html"},{"title":"MappedTensor2D – SELF ","text":"type, public, extends(Tensor2D) :: MappedTensor2D Inherits type~~mappedtensor2d~~InheritsGraph type~mappedtensor2d MappedTensor2D Tensor2D Tensor2D type~mappedtensor2d->Tensor2D Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures ApplyFlip BassiRebaySides JacobianWeight MPIExchangeAsync SideExchange Source Code MappedTensor2D Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedTensor2D public subroutine ApplyFlip_MappedTensor2D (tensor, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: gpuAccel procedure, public :: BassiRebaySides => BassiRebaySides_MappedTensor2D public subroutine BassiRebaySides_MappedTensor2D (tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel procedure, public :: JacobianWeight => JacobianWeight_MappedTensor2D public subroutine JacobianWeight_MappedTensor2D (tensor, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedTensor2D public subroutine MPIExchangeAsync_MappedTensor2D (tensor, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: resetCount procedure, public :: SideExchange => SideExchange_MappedTensor2D public subroutine SideExchange_MappedTensor2D (tensor, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor type(Mesh2D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel Source Code TYPE , EXTENDS ( Tensor2D ), PUBLIC :: MappedTensor2D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedTensor2D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedTensor2D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedTensor2D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedTensor2D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedTensor2D END TYPE MappedTensor2D","tags":"","loc":"type/mappedtensor2d.html"},{"title":"MappedTensor3D – SELF ","text":"type, public, extends(Tensor3D) :: MappedTensor3D Inherits type~~mappedtensor3d~~InheritsGraph type~mappedtensor3d MappedTensor3D Tensor3D Tensor3D type~mappedtensor3d->Tensor3D Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures ApplyFlip BassiRebaySides JacobianWeight MPIExchangeAsync SideExchange Source Code MappedTensor3D Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedTensor3D public subroutine ApplyFlip_MappedTensor3D (tensor, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: gpuAccel procedure, public :: BassiRebaySides => BassiRebaySides_MappedTensor3D public subroutine BassiRebaySides_MappedTensor3D (tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel procedure, public :: JacobianWeight => JacobianWeight_MappedTensor3D public subroutine JacobianWeight_MappedTensor3D (tensor, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedTensor3D public subroutine MPIExchangeAsync_MappedTensor3D (tensor, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: resetCount procedure, public :: SideExchange => SideExchange_MappedTensor3D public subroutine SideExchange_MappedTensor3D (tensor, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor type(Mesh3D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel Source Code TYPE , EXTENDS ( Tensor3D ), PUBLIC :: MappedTensor3D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedTensor3D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedTensor3D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedTensor3D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedTensor3D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedTensor3D END TYPE MappedTensor3D","tags":"","loc":"type/mappedtensor3d.html"},{"title":"MappedVector2D – SELF ","text":"type, public, extends(Vector2D) :: MappedVector2D Inherits type~~mappedvector2d~~InheritsGraph type~mappedvector2d MappedVector2D Vector2D Vector2D type~mappedvector2d->Vector2D Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures ApplyFlip BassiRebaySides ContravariantProjection Divergence Divergence_MappedVector2D Gradient Gradient_MappedVector2D JacobianWeight MPIExchangeAsync MapToScalar MapToTensor SideExchange Source Code MappedVector2D Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedVector2D public subroutine ApplyFlip_MappedVector2D (vector, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: gpuAccel procedure, public :: BassiRebaySides => BassiRebaySides_MappedVector2D public subroutine BassiRebaySides_MappedVector2D (vector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector logical, intent(in) :: gpuAccel procedure, private :: ContravariantProjection => ContravariantProjection_MappedVector2D public subroutine ContravariantProjection_MappedVector2D (physVector, geometry, compVector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: physVector type(SEMQuad), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: compVector logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_MappedVector2D public subroutine Divergence_MappedVector2D (compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: compVector type(SEMQuad), intent(in) :: geometry type( MappedScalar2D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Divergence_MappedVector2D public subroutine Divergence_MappedVector2D (compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: compVector type(SEMQuad), intent(in) :: geometry type( MappedScalar2D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel generic, public :: Gradient => Gradient_MappedVector2D public subroutine Gradient_MappedVector2D (vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedScalar2D ), intent(inout) :: workScalar type( MappedVector2D ), intent(inout) :: workVector type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedTensor2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Gradient_MappedVector2D public subroutine Gradient_MappedVector2D (vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedScalar2D ), intent(inout) :: workScalar type( MappedVector2D ), intent(inout) :: workVector type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedTensor2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, public :: JacobianWeight => JacobianWeight_MappedVector2D public subroutine JacobianWeight_MappedVector2D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D public subroutine MPIExchangeAsync_MappedVector2D (vector, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: resetCount procedure, private :: MapToScalar => MapToScalar_MappedVector2D public subroutine MapToScalar_MappedVector2D (vector, scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedScalar2D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel procedure, private :: MapToTensor => MapToTensor_MappedVector2D public subroutine MapToTensor_MappedVector2D (vector, tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedTensor2D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel procedure, public :: SideExchange => SideExchange_MappedVector2D public subroutine SideExchange_MappedVector2D (vector, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type(Mesh2D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel Source Code TYPE , EXTENDS ( Vector2D ), PUBLIC :: MappedVector2D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedVector2D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedVector2D GENERIC , PUBLIC :: Divergence => Divergence_MappedVector2D GENERIC , PUBLIC :: Gradient => Gradient_MappedVector2D !    GENERIC,PUBLIC :: Curl => Curl_MappedVector2D PROCEDURE , PRIVATE :: Divergence_MappedVector2D PROCEDURE , PRIVATE :: Gradient_MappedVector2D !    PROCEDURE,PRIVATE :: Curl_MappedVector2D PROCEDURE , PRIVATE :: ContravariantProjection => ContravariantProjection_MappedVector2D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedVector2D PROCEDURE , PRIVATE :: MapToScalar => MapToScalar_MappedVector2D PROCEDURE , PRIVATE :: MapToTensor => MapToTensor_MappedVector2D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedVector2D END TYPE MappedVector2D","tags":"","loc":"type/mappedvector2d.html"},{"title":"MappedVector3D – SELF ","text":"type, public, extends(Vector3D) :: MappedVector3D Inherits type~~mappedvector3d~~InheritsGraph type~mappedvector3d MappedVector3D Vector3D Vector3D type~mappedvector3d->Vector3D Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Type-Bound Procedures ApplyFlip BassiRebaySides ContravariantProjection Divergence Divergence_MappedVector3D Gradient Gradient_MappedVector3D JacobianWeight MPIExchangeAsync MapToScalar MapToTensor SideExchange Source Code MappedVector3D Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedVector3D public subroutine ApplyFlip_MappedVector3D (vector, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: gpuAccel procedure, public :: BassiRebaySides => BassiRebaySides_MappedVector3D public subroutine BassiRebaySides_MappedVector3D (vector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector logical, intent(in) :: gpuAccel procedure, private :: ContravariantProjection => ContravariantProjection_MappedVector3D public subroutine ContravariantProjection_MappedVector3D (physVector, geometry, compVector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: physVector type(SEMHex), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: compVector logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_MappedVector3D public subroutine Divergence_MappedVector3D (compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: compVector type(SEMHex), intent(in) :: geometry type( MappedScalar3D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Divergence_MappedVector3D public subroutine Divergence_MappedVector3D (compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: compVector type(SEMHex), intent(in) :: geometry type( MappedScalar3D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel generic, public :: Gradient => Gradient_MappedVector3D public subroutine Gradient_MappedVector3D (vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedScalar3D ), intent(inout) :: workScalar type( MappedVector3D ), intent(inout) :: workVector type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedTensor3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Gradient_MappedVector3D public subroutine Gradient_MappedVector3D (vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedScalar3D ), intent(inout) :: workScalar type( MappedVector3D ), intent(inout) :: workVector type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedTensor3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, public :: JacobianWeight => JacobianWeight_MappedVector3D public subroutine JacobianWeight_MappedVector3D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D public subroutine MPIExchangeAsync_MappedVector3D (vector, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: resetCount procedure, private :: MapToScalar => MapToScalar_MappedVector3D public subroutine MapToScalar_MappedVector3D (vector, scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedScalar3D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel procedure, private :: MapToTensor => MapToTensor_MappedVector3D public subroutine MapToTensor_MappedVector3D (vector, tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedTensor3D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel procedure, public :: SideExchange => SideExchange_MappedVector3D public subroutine SideExchange_MappedVector3D (vector, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type(Mesh3D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel Source Code TYPE , EXTENDS ( Vector3D ), PUBLIC :: MappedVector3D CONTAINS PROCEDURE , PUBLIC :: SideExchange => SideExchange_MappedVector3D PROCEDURE , PUBLIC :: BassiRebaySides => BassiRebaySides_MappedVector3D GENERIC , PUBLIC :: Divergence => Divergence_MappedVector3D !    GENERIC,PUBLIC :: Curl => Curl_MappedVector3D GENERIC , PUBLIC :: Gradient => Gradient_MappedVector3D PROCEDURE , PRIVATE :: Divergence_MappedVector3D !    PROCEDURE,PRIVATE :: Curl_MappedVector3D PROCEDURE , PRIVATE :: Gradient_MappedVector3D PROCEDURE , PRIVATE :: ContravariantProjection => ContravariantProjection_MappedVector3D PROCEDURE , PUBLIC :: JacobianWeight => JacobianWeight_MappedVector3D PROCEDURE , PRIVATE :: MapToScalar => MapToScalar_MappedVector3D PROCEDURE , PRIVATE :: MapToTensor => MapToTensor_MappedVector3D PROCEDURE , PRIVATE :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D PROCEDURE , PRIVATE :: ApplyFlip => ApplyFlip_MappedVector3D END TYPE MappedVector3D","tags":"","loc":"type/mappedvector3d.html"},{"title":"Advection2D – SELF ","text":"type, public, extends(DG2D) :: Advection2D Inherits type~~advection2d~~InheritsGraph type~advection2d Advection2D MappedVector2D MappedVector2D type~advection2d->MappedVector2D velocity Vector2D Vector2D type~advection2d->Vector2D plotVelocity, plotX EquationParser EquationParser type~advection2d->EquationParser boundaryConditionEqn, solutionEqn, sourceEqn DG2D DG2D type~advection2d->DG2D Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Lx Ly bcEqn boundaryConditionEqn controlDegree controlQuadrature diffusiveFlux diffusivity dt enableMPI endTime gpuAccel icEqn icFile initialTime integrator meshFile nxElements nyElements outputInterval plotVelocity plotX simulationTime solutionEqn sourceEqn targetDegree targetQuadrature velEqnX velEqnY velocity Type-Bound Procedures ForwardStep Free Init InitFromCLI InternalFlux SetBoundaryCondition SetBoundaryConditionFromEquation_Advection2D SetSolution SetSolutionFromEquation_Advection2D SetSource SetSourceFromEquation_Advection2D SetVelocity SetVelocityFromEquation_Advection2D SideFlux Tendency TimeStepRK3 WriteTecplot Source Code Advection2D Components Type Visibility Attributes Name Initial real(kind=prec), public :: Lx real(kind=prec), public :: Ly character(len=self_EquationLength), public :: bcEqn type(EquationParser), public, ALLOCATABLE :: boundaryConditionEqn (:) integer, public :: controlDegree integer, public :: controlQuadrature logical, public :: diffusiveFlux real(kind=prec), public :: diffusivity real(kind=prec), public :: dt logical, public :: enableMPI real(kind=prec), public :: endTime logical, public :: gpuAccel character(len=self_EquationLength), public :: icEqn character(len=self_FileNameLength), public :: icFile real(kind=prec), public :: initialTime integer, public :: integrator character(len=self_FileNameLength), public :: meshFile integer, public :: nxElements integer, public :: nyElements real(kind=prec), public :: outputInterval type(Vector2D), public :: plotVelocity type(Vector2D), public :: plotX real(kind=prec), public :: simulationTime type(EquationParser), public, ALLOCATABLE :: solutionEqn (:) type(EquationParser), public, ALLOCATABLE :: sourceEqn (:) integer, public :: targetDegree integer, public :: targetQuadrature character(len=self_EquationLength), public :: velEqnX character(len=self_EquationLength), public :: velEqnY type(MappedVector2D), public :: velocity Type-Bound Procedures procedure, public :: ForwardStep => ForwardStep_Advection2D public subroutine ForwardStep_Advection2D (this, endTime) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this real(kind=prec), intent(in) :: endTime procedure, public :: Free => Free_Advection2D public subroutine Free_Advection2D (this) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this procedure, public :: Init => Init_Advection2D public subroutine Init_Advection2D (this, cqType, tqType, cqDegree, tqDegree, nvar, enableMPI, spec) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(out) :: this integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nvar logical, intent(in) :: enableMPI type(MeshSpec), intent(in) :: spec procedure, public :: InitFromCLI => InitFromCLI_Advection2D public subroutine InitFromCLI_Advection2D (this) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this procedure, public :: InternalFlux => InternalFlux_Advection2D public subroutine InternalFlux_Advection2D (this) Calculates the advective flux using the provided velocity Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this generic, public :: SetBoundaryCondition => SetBoundaryConditionFromEquation_Advection2D public subroutine SetBoundaryConditionFromEquation_Advection2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) procedure, private :: SetBoundaryConditionFromEquation_Advection2D public subroutine SetBoundaryConditionFromEquation_Advection2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetSolution => SetSolutionFromEquation_Advection2D public subroutine SetSolutionFromEquation_Advection2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) procedure, private :: SetSolutionFromEquation_Advection2D public subroutine SetSolutionFromEquation_Advection2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetSource => SetSourceFromEquation_Advection2D public subroutine SetSourceFromEquation_Advection2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) procedure, private :: SetSourceFromEquation_Advection2D public subroutine SetSourceFromEquation_Advection2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) generic, public :: SetVelocity => SetVelocityFromEquation_Advection2D public subroutine SetVelocityFromEquation_Advection2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:2) procedure, private :: SetVelocityFromEquation_Advection2D public subroutine SetVelocityFromEquation_Advection2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:2) procedure, public :: SideFlux => SideFlux_Advection2D public subroutine SideFlux_Advection2D (this) Calculates the Advective Flux on element sides using a Lax-Friedrich's upwind Riemann Solver Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this procedure, public :: Tendency => Tendency_Advection2D public subroutine Tendency_Advection2D (this) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this procedure, public :: TimeStepRK3 => TimeStepRK3_Advection2D public subroutine TimeStepRK3_Advection2D (this, nSteps) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this integer, intent(in) :: nSteps procedure, public :: WriteTecplot => WriteTecplot_Advection2D public subroutine WriteTecplot_Advection2D (self, filename) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: self character, intent(in), optional :: filename Source Code TYPE , EXTENDS ( DG2D ), PUBLIC :: Advection2D TYPE ( MappedVector2D ), PUBLIC :: velocity TYPE ( Vector2D ), PUBLIC :: plotVelocity TYPE ( Vector2D ), PUBLIC :: plotX TYPE ( EquationParser ), ALLOCATABLE :: boundaryConditionEqn (:) TYPE ( EquationParser ), ALLOCATABLE :: solutionEqn (:) TYPE ( EquationParser ), ALLOCATABLE :: sourceEqn (:) REAL ( prec ) :: simulationTime ! Model Settings ! REAL ( prec ) :: Lx , Ly ! Domain lengths REAL ( prec ) :: dt ! Default time step size REAL ( prec ) :: outputInterval REAL ( prec ) :: initialTime REAL ( prec ) :: endTime REAL ( prec ) :: diffusivity LOGICAL :: diffusiveFlux INTEGER :: controlDegree INTEGER :: targetDegree INTEGER :: controlQuadrature ! ENUMS in SELF_Constants.f90 INTEGER :: targetQuadrature ! ENUMS in SELF_Constants.f90 CHARACTER ( LEN = self_FileNameLength ) :: icFile CHARACTER ( LEN = self_FileNameLength ) :: meshFile INTEGER :: nxElements INTEGER :: nyElements INTEGER :: integrator ! ENUMS needed in SELF_Constants.f90 !! TO DO !! CHARACTER ( LEN = self_EquationLength ) :: velEqnX ! Velocity Equation (x-direction) CHARACTER ( LEN = self_EquationLength ) :: velEqnY ! Velocity Equation (y-direction) CHARACTER ( LEN = self_EquationLength ) :: icEqn ! Initial condition Equation CHARACTER ( LEN = self_EquationLength ) :: bcEqn ! Boundary condition Equation LOGICAL :: enableMPI LOGICAL :: gpuAccel CONTAINS PROCEDURE , PUBLIC :: Init => Init_Advection2D PROCEDURE , PUBLIC :: InitFromCLI => InitFromCLI_Advection2D PROCEDURE , PUBLIC :: Free => Free_Advection2D GENERIC , PUBLIC :: SetSolution => SetSolutionFromEquation_Advection2D PROCEDURE , PRIVATE :: SetSolutionFromEquation_Advection2D GENERIC , PUBLIC :: SetSource => SetSourceFromEquation_Advection2D PROCEDURE , PRIVATE :: SetSourceFromEquation_Advection2D GENERIC , PUBLIC :: SetVelocity => SetVelocityFromEquation_Advection2D PROCEDURE , PRIVATE :: SetVelocityFromEquation_Advection2D GENERIC , PUBLIC :: SetBoundaryCondition => SetBoundaryConditionFromEquation_Advection2D PROCEDURE , PRIVATE :: SetBoundaryConditionFromEquation_Advection2D PROCEDURE , PUBLIC :: WriteTecplot => WriteTecplot_Advection2D PROCEDURE , PUBLIC :: ForwardStep => ForwardStep_Advection2D PROCEDURE , PUBLIC :: TimeStepRK3 => TimeStepRK3_Advection2D PROCEDURE , PUBLIC :: Tendency => Tendency_Advection2D PROCEDURE , PUBLIC :: InternalFlux => InternalFlux_Advection2D PROCEDURE , PUBLIC :: SideFlux => SideFlux_Advection2D END TYPE Advection2D","tags":"","loc":"type/advection2d.html"},{"title":"LinkedList – SELF ","text":"type, public :: LinkedList \\addtogroup SELF_LinkedList\n@{\n\\struct LinkedList\nA LinkedList of Records LinkedList Attributes head Record A pointer to the first entry (the head) of the LinkedList tail Record A pointer to the last entry (the tail) of the LinkedList current Record A pointer to the current entry of the LinkedList. This\n                                          pointer can be used to traverse the list. Procedures See \\ref SELF_LinkedList for more information. The first column lists the \"call-name\" and the second\n   column lists the name of routine that is aliased onto the call-name. This is the list of\n   PUBLIC type-bound procedures for the LinkedList data-structure. Init Init_LinkedList Free Free_LinkedList GetData GetData_LinkedList SetData SetData_LinkedList GetKey GetKey_LinkedList SetKey SetKey_LinkedList ListIsEmpty ListIsEmpty_LinkedList AddToList AddToList_LinkedList RemoveCurrent RemoveCurrent_LinkedList MoveToNext MoveToNext_LinkedList MoveToHead MoveToHead_LinkedList MovetoTail MoveToTail_LinkedList PrintToScreen PrintToScreen_LinkedList @} Inherits type~~linkedlist~~InheritsGraph type~linkedlist LinkedList type~record Record type~linkedlist->type~record head, tail, current type~record->type~record next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables current head tail Type-Bound Procedures AddToList Free GetData GetKey Init ListIsEmpty MoveToHead MoveToNext MoveToTail PrintToScreen RemoveCurrent SetData SetKey Source Code LinkedList Components Type Visibility Attributes Name Initial type( Record ), public, POINTER :: current type( Record ), public, POINTER :: head type( Record ), public, POINTER :: tail Type-Bound Procedures procedure, public :: AddToList => AddToList_LinkedList public subroutine AddToList_LinkedList (myList, inData, inKey) \\addtogroup SELF_LinkedList\n @{\n \\fn AddToList_LinkedList\n Adds a new entry to the LinkedList with the provided data and key Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer :: inData integer, optional :: inKey procedure, public :: Free => Free_LinkedList public subroutine Free_LinkedList (myList) \\addtogroup SELF_LinkedList\n @{\n \\fn Free_LinkedList\n  Cycles through the Linked List, deallocates associated memory, and nullifies the LinkedList\n  pointers. Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList procedure, public :: GetData => GetCurrentData_LinkedList public subroutine GetCurrentData_LinkedList (myList, outData) \\addtogroup SELF_LinkedList\n @{\n \\fn GetCurrentData_LinkedList\n Gets the current list data and returns the integer value. Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer :: outData procedure, public :: GetKey => GetCurrentKey_LinkedList public subroutine GetCurrentKey_LinkedList (myList, outKey) \\addtogroup SELF_LinkedList\n @{\n \\fn GetCurrentKey_LinkedList\n Gets the current key and returns the integer value. Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer :: outKey procedure, public :: Init => Init_LinkedList public subroutine Init_LinkedList (myList) \\addtogroup SELF_LinkedList\n @{\n \\fn Init_LinkedList\n Initializes a LinkedList by nullifying the head, tail, and current pointers Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList procedure, public :: ListIsEmpty => ListIsEmpty_LinkedList public function ListIsEmpty_LinkedList (myList) result(isempty) \\addtogroup SELF_LinkedList\n @{\n \\fn ListIsEmpty_LinkedList\n Checks if the LinkedList is empty and returns a logical indicating the status of the list. Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList Return Value logical procedure, public :: MoveToHead => MoveToHead_LinkedList public subroutine MoveToHead_LinkedList (myList) \\addtogroup SELF_LinkedList\n @{\n \\fn MoveToHead_LinkedList\n Advances the current pointer in the LinkedList to the start of the list  (list head) Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList procedure, public :: MoveToNext => MoveToNext_LinkedList public subroutine MoveToNext_LinkedList (myList) \\addtogroup SELF_LinkedList\n @{\n \\fn MoveToNext_LinkedList\n Advances the current pointer in the LinkedList to the next position Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList procedure, public :: MoveToTail => MoveToTail_LinkedList public subroutine MoveToTail_LinkedList (myList) \\addtogroup SELF_LinkedList\n @{\n \\fn MoveToTail_LinkedList\n Advances the current pointer in the LinkedList to the end of the list (list tail) Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList procedure, public :: PrintToScreen => PrintToScreen_LinkedList public subroutine PrintToScreen_LinkedList (myList) \\addtogroup SELF_LinkedList\n @{\n \\fn PrintToScreen_LinkedList\n Prints the list data and keys to the screen Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList procedure, public :: RemoveCurrent => RemoveCurrent_LinkedList public subroutine RemoveCurrent_LinkedList (myList) \\addtogroup SELF_LinkedList\n @{\n \\fn RemoveCurrent_LinkedList\n Removes the current entry from the list and patches the previous with the next. Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList procedure, public :: SetData => SetCurrentData_LinkedList public subroutine SetCurrentData_LinkedList (myList, inData) \\addtogroup SELF_LinkedList\n @{\n \\fn SetCurrentData_LinkedList\n Sets the current list data to the supplied integer value. Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer :: inData procedure, public :: SetKey => SetCurrentKey_LinkedList public subroutine SetCurrentKey_LinkedList (myList, inKey) \\addtogroup SELF_LinkedList\n @{\n \\fn SetCurrentKey_LinkedList\n Sets the current list key to the supplied integer value. Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer :: inKey Source Code TYPE LinkedList TYPE ( Record ), POINTER :: head , tail , current CONTAINS PROCEDURE :: Init => Init_LinkedList PROCEDURE :: Free => Free_LinkedList PROCEDURE :: GetData => GetCurrentData_LinkedList PROCEDURE :: SetData => SetCurrentData_LinkedList PROCEDURE :: GetKey => GetCurrentKey_LinkedList PROCEDURE :: SetKey => SetCurrentKey_LinkedList PROCEDURE :: ListIsEmpty => ListIsEmpty_LinkedList PROCEDURE :: AddToList => AddToList_LinkedList PROCEDURE :: RemoveCurrent => RemoveCurrent_LinkedList PROCEDURE :: MoveToNext => MoveToNext_LinkedList PROCEDURE :: MoveToHead => MoveToHead_LinkedList PROCEDURE :: MoveToTail => MoveToTail_LinkedList PROCEDURE :: PrintToScreen => PrintToScreen_LinkedList END TYPE LinkedList","tags":"","loc":"type/linkedlist.html"},{"title":"Record – SELF ","text":"type, public :: Record \\addtogroup SELF_LinkedList\n@{\n\\struct Record\nA template record entry for a Linked-List that consists of data, a key, and a pointer to the next\nrecord This data structure is used in the LinkedList data structure. The data in this template is an\ninteger, though this template can be used to develop of Linked List of other data (e.g. see\nTiming.f90, Node_Class.f90, QuadElement_Class.f90, HexElement_Class.f90, Edge_Class.f90) Record Attributes listData INTEGER Data for a single entry in a LinkedList key INTEGER A key that can be used for conditional access, as in the\n                                        HashTable_Class next Record Pointer to the next record in a LinkedList @} Inherited by type~~record~~InheritedByGraph type~record Record type~record->type~record next type~linkedlist LinkedList type~linkedlist->type~record head, tail, current Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables key listData next Source Code Record Components Type Visibility Attributes Name Initial integer, public :: key integer, public :: listData type( Record ), public, POINTER :: next Source Code TYPE Record INTEGER :: listData INTEGER :: key TYPE ( Record ), POINTER :: next END TYPE Record","tags":"","loc":"type/record.html"},{"title":"HashTable – SELF ","text":"type, public :: HashTable \\addtogroup SELF_HashTable\n@{\n\\struct HashTable\nA template hash-table data structure that is comprised of an array of linked lists ( see\nSELF_LinkedList ). HashTable Attributes list(:) LinkedList Single Linked-List @} Inherits type~~hashtable~~InheritsGraph type~hashtable HashTable LinkedList LinkedList type~hashtable->LinkedList list Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables list Type-Bound Procedures AddDataForKeys ContainsKeys Free GetDataForKeys Init Source Code HashTable Components Type Visibility Attributes Name Initial type(LinkedList), public, ALLOCATABLE :: list (:) Type-Bound Procedures procedure, public :: AddDataForKeys => AddDataForKeys_HashTable public subroutine AddDataForKeys_HashTable (myTable, inData, i, j) \\addtogroup SELF_HashTable\n @{\n \\fn AddDataForKeys_HashTable\n Adds data to the i-th linked list with a key set to \"j\" Read more… Arguments Type Intent Optional Attributes Name class( HashTable ) :: myTable integer :: inData integer :: i integer :: j procedure, public :: ContainsKeys => ContainsKeys_HashTable public function ContainsKeys_HashTable (myTable, i, j) result(doesContain) \\addtogroup SELF_HashTable\n @{\n \\fn ContainsKeys_HashTable\n Checks to see if an entry in the hash-table exists for the keys \"i\" and \"j\". Read more… Arguments Type Intent Optional Attributes Name class( HashTable ) :: myTable integer :: i integer :: j Return Value logical procedure, public :: Free => Free_HashTable public subroutine Free_HashTable (myTable) \\addtogroup SELF_HashTable\n @{\n \\fn Free_HashTable\n  Deallocates memory associated with the Hash-Table Read more… Arguments Type Intent Optional Attributes Name class( HashTable ) :: myTable procedure, public :: GetDataForKeys => GetDataForKeys_HashTable public subroutine GetDataForKeys_HashTable (myTable, outData, i, j) \\addtogroup SELF_HashTable\n @{\n \\fn GetDataForKeys_HashTable\n Returns data from the hash table associated with the keys \"i\" and \"j\". Read more… Arguments Type Intent Optional Attributes Name class( HashTable ) :: myTable integer :: outData integer :: i integer :: j procedure, public :: Init => Init_HashTable public subroutine Init_HashTable (myTable, N) \\addtogroup SELF_HashTable\n @{\n \\fn Init_HashTable\n Allocates space for the hash table and initializes each linked list within the hash-table Read more… Arguments Type Intent Optional Attributes Name class( HashTable ) :: myTable integer :: N Source Code TYPE HashTable TYPE ( LinkedList ), ALLOCATABLE :: list (:) CONTAINS PROCEDURE :: Init => Init_HashTable PROCEDURE :: Free => Free_HashTable PROCEDURE :: AddDataForKeys => AddDataForKeys_HashTable PROCEDURE :: ContainsKeys => ContainsKeys_HashTable PROCEDURE :: GetDataForKeys => GetDataForKeys_HashTable END TYPE HashTable","tags":"","loc":"type/hashtable.html"},{"title":"DG2D – SELF ","text":"type, public :: DG2D Inherits type~~dg2d~~InheritsGraph type~dg2d DG2D MPILayer MPILayer type~dg2d->MPILayer decomp MappedScalar2D MappedScalar2D type~dg2d->MappedScalar2D solution, source, fluxDivergence, dSdt, workScalar MappedVector2D MappedVector2D type~dg2d->MappedVector2D solutionGradient, flux, workVector, compFlux Metadata Metadata type~dg2d->Metadata solutionMetaData MappedTensor2D MappedTensor2D type~dg2d->MappedTensor2D workTensor Mesh2D Mesh2D type~dg2d->Mesh2D mesh SEMQuad SEMQuad type~dg2d->SEMQuad geometry Scalar2D Scalar2D type~dg2d->Scalar2D plotSolution Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables compFlux dSdt decomp flux fluxDivergence geometry mesh plotSolution solution solutionGradient solutionMetaData source workScalar workTensor workVector Type-Bound Procedures CalculateDSDt CalculateFluxDivergence CalculateSolutionGradient Free Init Read UpdateDevice UpdateHost Write Source Code DG2D Components Type Visibility Attributes Name Initial type(MappedVector2D), public :: compFlux type(MappedScalar2D), public :: dSdt type(MPILayer), public :: decomp type(MappedVector2D), public :: flux type(MappedScalar2D), public :: fluxDivergence type(SEMQuad), public :: geometry type(Mesh2D), public :: mesh type(Scalar2D), public :: plotSolution type(MappedScalar2D), public :: solution type(MappedVector2D), public :: solutionGradient type(Metadata), public, ALLOCATABLE :: solutionMetaData (:) type(MappedScalar2D), public :: source type(MappedScalar2D), public :: workScalar type(MappedTensor2D), public :: workTensor type(MappedVector2D), public :: workVector Type-Bound Procedures procedure, public :: CalculateDSDt => CalculateDSDt_DG2D public subroutine CalculateDSDt_DG2D (this, gpuAccel) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this logical, intent(in) :: gpuAccel procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_DG2D public subroutine CalculateFluxDivergence_DG2D (this, gpuAccel) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this logical, intent(in) :: gpuAccel procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DG2D public subroutine CalculateSolutionGradient_DG2D (this, gpuAccel) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this logical, intent(in) :: gpuAccel procedure, public :: Free => Free_DG2D public subroutine Free_DG2D (this) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this procedure, public :: Init => Init_DG2D public subroutine Init_DG2D (this, cqType, tqType, cqDegree, tqDegree, nvar, enableMPI, spec) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(out) :: this integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nvar logical, intent(in) :: enableMPI type(MeshSpec), intent(in) :: spec procedure, public :: Read => Read_DG2D public subroutine Read_DG2D (this, fileName) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: UpdateDevice => UpdateDevice_DG2D public subroutine UpdateDevice_DG2D (this) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_DG2D public subroutine UpdateHost_DG2D (this) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this procedure, public :: Write => Write_DG2D public subroutine Write_DG2D (this, fileName) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(in) :: this character, intent(in) :: fileName Source Code TYPE , PUBLIC :: DG2D TYPE ( MappedScalar2D ), PUBLIC :: solution TYPE ( Scalar2D ), PUBLIC :: plotSolution TYPE ( MappedVector2D ), PUBLIC :: solutionGradient TYPE ( MappedVector2D ), PUBLIC :: flux TYPE ( MappedScalar2D ), PUBLIC :: source TYPE ( MappedScalar2D ), PUBLIC :: fluxDivergence TYPE ( MappedScalar2D ), PUBLIC :: dSdt TYPE ( MPILayer ), PUBLIC :: decomp TYPE ( Mesh2D ), PUBLIC :: mesh TYPE ( SEMQuad ), PUBLIC :: geometry TYPE ( Metadata ), ALLOCATABLE , PUBLIC :: solutionMetaData (:) ! Work arrays ! Can't be private to be accessible by type extensions ! TO DO : Really need to figure out the reuse business for the initializer... TYPE ( MappedScalar2D ) :: workScalar TYPE ( MappedVector2D ) :: workVector TYPE ( MappedVector2D ) :: compFlux TYPE ( MappedTensor2D ) :: workTensor CONTAINS PROCEDURE , PUBLIC :: Init => Init_DG2D PROCEDURE , PUBLIC :: Free => Free_DG2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_DG2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_DG2D PROCEDURE , PUBLIC :: CalculateSolutionGradient => CalculateSolutionGradient_DG2D PROCEDURE , PUBLIC :: CalculateFluxDivergence => CalculateFluxDivergence_DG2D PROCEDURE , PUBLIC :: CalculateDSDt => CalculateDSDt_DG2D PROCEDURE , PUBLIC :: Read => Read_DG2D PROCEDURE , PUBLIC :: Write => Write_DG2D END TYPE DG2D","tags":"","loc":"type/dg2d.html"},{"title":"DG3D – SELF ","text":"type, public :: DG3D Inherits type~~dg3d~~InheritsGraph type~dg3d DG3D MPILayer MPILayer type~dg3d->MPILayer decomp SEMHex SEMHex type~dg3d->SEMHex geometry MappedVector3D MappedVector3D type~dg3d->MappedVector3D solutionGradient, flux, workVector, compFlux Metadata Metadata type~dg3d->Metadata solutionMetaData Scalar3D Scalar3D type~dg3d->Scalar3D plotSolution MappedScalar3D MappedScalar3D type~dg3d->MappedScalar3D solution, source, fluxDivergence, dSdt, workScalar MappedTensor3D MappedTensor3D type~dg3d->MappedTensor3D workTensor Mesh3D Mesh3D type~dg3d->Mesh3D mesh Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables compFlux dSdt decomp flux fluxDivergence geometry mesh plotSolution solution solutionGradient solutionMetaData source workScalar workTensor workVector Type-Bound Procedures CalculateDSDt CalculateFluxDivergence CalculateSolutionGradient Free Init Read UpdateDevice UpdateHost Write Source Code DG3D Components Type Visibility Attributes Name Initial type(MappedVector3D), public :: compFlux type(MappedScalar3D), public :: dSdt type(MPILayer), public :: decomp type(MappedVector3D), public :: flux type(MappedScalar3D), public :: fluxDivergence type(SEMHex), public :: geometry type(Mesh3D), public :: mesh type(Scalar3D), public :: plotSolution type(MappedScalar3D), public :: solution type(MappedVector3D), public :: solutionGradient type(Metadata), public, ALLOCATABLE :: solutionMetaData (:) type(MappedScalar3D), public :: source type(MappedScalar3D), public :: workScalar type(MappedTensor3D), public :: workTensor type(MappedVector3D), public :: workVector Type-Bound Procedures procedure, public :: CalculateDSDt => CalculateDSDt_DG3D public subroutine CalculateDSDt_DG3D (this, gpuAccel) Adds the flux convergence and source terms together and assigns to dSdt Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this logical, intent(in) :: gpuAccel procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_DG3D public subroutine CalculateFluxDivergence_DG3D (this, gpuAccel) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this logical, intent(in) :: gpuAccel procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DG3D public subroutine CalculateSolutionGradient_DG3D (this, gpuAccel) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this logical, intent(in) :: gpuAccel procedure, public :: Free => Free_DG3D public subroutine Free_DG3D (this) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this procedure, public :: Init => Init_DG3D public subroutine Init_DG3D (this, cqType, tqType, cqDegree, tqDegree, nvar, enableMPI, spec) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(out) :: this integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nvar logical, intent(in) :: enableMPI type(MeshSpec), intent(in) :: spec procedure, public :: Read => Read_DG3D public subroutine Read_DG3D (this, fileName) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this character, intent(in) :: fileName procedure, public :: UpdateDevice => UpdateDevice_DG3D public subroutine UpdateDevice_DG3D (this) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_DG3D public subroutine UpdateHost_DG3D (this) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this procedure, public :: Write => Write_DG3D public subroutine Write_DG3D (this, fileName) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(in) :: this character, intent(in) :: fileName Source Code TYPE , PUBLIC :: DG3D TYPE ( MappedScalar3D ), PUBLIC :: solution TYPE ( Scalar3D ), PUBLIC :: plotSolution TYPE ( MappedVector3D ), PUBLIC :: solutionGradient TYPE ( MappedVector3D ), PUBLIC :: flux TYPE ( MappedScalar3D ), PUBLIC :: source TYPE ( MappedScalar3D ), PUBLIC :: fluxDivergence TYPE ( MappedScalar3D ), PUBLIC :: dSdt TYPE ( MPILayer ), PUBLIC :: decomp TYPE ( Mesh3D ), PUBLIC :: mesh TYPE ( SEMHex ), PUBLIC :: geometry TYPE ( Metadata ), ALLOCATABLE , PUBLIC :: solutionMetaData (:) ! Work arrays TYPE ( MappedScalar3D ) :: workScalar TYPE ( MappedVector3D ) :: workVector TYPE ( MappedVector3D ) :: compFlux TYPE ( MappedTensor3D ) :: workTensor CONTAINS PROCEDURE , PUBLIC :: Init => Init_DG3D PROCEDURE , PUBLIC :: Free => Free_DG3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_DG3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_DG3D PROCEDURE , PUBLIC :: CalculateSolutionGradient => CalculateSolutionGradient_DG3D PROCEDURE , PUBLIC :: CalculateFluxDivergence => CalculateFluxDivergence_DG3D PROCEDURE , PUBLIC :: CalculateDSDt => CalculateDSDt_DG3D PROCEDURE , PUBLIC :: Read => Read_DG3D PROCEDURE , PUBLIC :: Write => Write_DG3D END TYPE DG3D","tags":"","loc":"type/dg3d.html"},{"title":"Lagrange – SELF ","text":"type, public :: Lagrange A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions.\nThe Lagrange data-structure stores the information necessary to interpolate between two\nsets of grid-points and to estimate the derivative of data at native grid points. Routines for\nmultidimensional interpolation are based on the tensor product of 1-D interpolants. It is\nassumed that the polynomial degree (and the interpolation nodes) are the same in each direction.\nThis assumption permits the storage of only one array of interpolation nodes and barycentric\nweights and is what allows this data structure to be flexible. Inherits type~~lagrange~~InheritsGraph type~lagrange Lagrange hfReal_r2 hfReal_r2 type~lagrange->hfReal_r2 iMatrix, dMatrix, dgMatrix, bMatrix hfReal_r1 hfReal_r1 type~lagrange->hfReal_r1 controlPoints, targetPoints, bWeights, qWeights Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N bMatrix bWeights controlPoints dMatrix dgMatrix iMatrix qWeights targetPoints Type-Bound Procedures CalculateBarycentricWeights CalculateDerivativeMatrix CalculateInterpolationMatrix CalculateLagrangePolynomials DGDerivative_1D DGDerivative_1D_cpu DGDerivative_1D_gpu Derivative_1D Derivative_1D_cpu Derivative_1D_gpu Free Init ScalarBoundaryInterp_1D ScalarBoundaryInterp_1D_cpu ScalarBoundaryInterp_1D_gpu ScalarBoundaryInterp_2D ScalarBoundaryInterp_2D_cpu ScalarBoundaryInterp_2D_gpu ScalarBoundaryInterp_3D ScalarBoundaryInterp_3D_cpu ScalarBoundaryInterp_3D_gpu ScalarDGGradient_2D ScalarDGGradient_2D_cpu ScalarDGGradient_2D_gpu ScalarGradient_2D ScalarGradient_2D_cpu ScalarGradient_2D_gpu ScalarGradient_3D ScalarGradient_3D_cpu ScalarGradient_3D_gpu ScalarGridInterp_1D ScalarGridInterp_1D_cpu ScalarGridInterp_1D_gpu ScalarGridInterp_2D ScalarGridInterp_2D_cpu ScalarGridInterp_2D_gpu ScalarGridInterp_3D ScalarGridInterp_3D_cpu ScalarGridInterp_3D_gpu TensorBoundaryInterp_2D TensorBoundaryInterp_2D_cpu TensorBoundaryInterp_2D_gpu TensorBoundaryInterp_3D TensorBoundaryInterp_3D_cpu TensorBoundaryInterp_3D_gpu TensorDGDivergence_2D TensorDGDivergence_2D_cpu TensorDGDivergence_2D_gpu TensorDGDivergence_3D TensorDGDivergence_3D_cpu TensorDGDivergence_3D_gpu TensorDivergence_2D TensorDivergence_2D_cpu TensorDivergence_2D_gpu TensorDivergence_3D TensorDivergence_3D_cpu TensorDivergence_3D_gpu TensorGridInterp_2D TensorGridInterp_2D_cpu TensorGridInterp_2D_gpu TensorGridInterp_3D TensorGridInterp_3D_cpu TensorGridInterp_3D_gpu UpdateDevice UpdateHost VectorBoundaryInterp_2D VectorBoundaryInterp_2D_cpu VectorBoundaryInterp_2D_gpu VectorBoundaryInterp_3D VectorBoundaryInterp_3D_cpu VectorBoundaryInterp_3D_gpu VectorCurl_2D VectorCurl_2D_cpu VectorCurl_2D_gpu VectorCurl_3D VectorCurl_3D_cpu VectorCurl_3D_gpu VectorDGDivergence_2D VectorDGDivergence_2D_cpu VectorDGDivergence_2D_gpu VectorDGDivergence_3D VectorDGDivergence_3D_cpu VectorDGDivergence_3D_gpu VectorDGGradient_2D VectorDGGradient_2D_cpu VectorDGGradient_2D_gpu VectorDivergence_2D VectorDivergence_2D_cpu VectorDivergence_2D_gpu VectorDivergence_3D VectorDivergence_3D_cpu VectorDivergence_3D_gpu VectorGradient_2D VectorGradient_2D_cpu VectorGradient_2D_gpu VectorGradient_3D VectorGradient_3D_cpu VectorGradient_3D_gpu VectorGridInterp_2D VectorGridInterp_2D_cpu VectorGridInterp_2D_gpu VectorGridInterp_3D VectorGridInterp_3D_cpu VectorGridInterp_3D_gpu Source Code Lagrange Components Type Visibility Attributes Name Initial integer, public :: M The number of target points. integer, public :: N The number of control points. type(hfReal_r2), public :: bMatrix The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. type(hfReal_r1), public :: bWeights The barycentric weights that are calculated from the controlPoints and used for interpolation. type(hfReal_r1), public :: controlPoints The set of nodes in one dimension where data is known.\nTo create higher dimension interpolation and differentiation operators, structured grids in two and three\ndimensions are created by tensor products of the controlPoints. This design decision implies that all\nspectral element methods supported by the Lagrange class have the same polynomial degree in each\ncomputational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto,\nLegendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over\nthe domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of\nthese quadrature types or uniform points on [-1,1]. type(hfReal_r2), public :: dMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The\ndMatrix is based on a strong form of the derivative. type(hfReal_r2), public :: dgMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based\non a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. type(hfReal_r2), public :: iMatrix The interpolation matrix (transpose) for mapping data from the control grid to the target grid. type(hfReal_r1), public :: qWeights The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints\nprovided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss,\nChebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant . type(hfReal_r1), public :: targetPoints The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation\nand differentiation operators, structured grids in two and three dimensions are created by tensor products of\nthe targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1]\n(computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. Type-Bound Procedures procedure, private :: CalculateBarycentricWeights public subroutine CalculateBarycentricWeights (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly procedure, private :: CalculateDerivativeMatrix public subroutine CalculateDerivativeMatrix (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly procedure, private :: CalculateInterpolationMatrix public subroutine CalculateInterpolationMatrix (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly procedure, private :: CalculateLagrangePolynomials public function CalculateLagrangePolynomials (myPoly, sE) result(lAtS) Arguments Type Intent Optional Attributes Name class( Lagrange ) :: myPoly real(kind=prec) :: sE Return Value real(kind=prec)\n  (0:myPoly%N) generic, public :: DGDerivative_1D => DGDerivative_1D_cpu , DGDerivative_1D_gpu public subroutine DGDerivative_1D_cpu (myPoly, f, bf, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:nVariables,1:2,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine DGDerivative_1D_gpu (myPoly, f_dev, bf_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: DGDerivative_1D_cpu public subroutine DGDerivative_1D_cpu (myPoly, f, bf, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:nVariables,1:2,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: DGDerivative_1D_gpu public subroutine DGDerivative_1D_gpu (myPoly, f_dev, bf_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: Derivative_1D => Derivative_1D_cpu , Derivative_1D_gpu public subroutine Derivative_1D_cpu (myPoly, f, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine Derivative_1D_gpu (myPoly, f_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: Derivative_1D_cpu public subroutine Derivative_1D_cpu (myPoly, f, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: Derivative_1D_gpu public subroutine Derivative_1D_gpu (myPoly, f_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, public :: Free => Free_Lagrange public subroutine Free_Lagrange (myPoly) Frees all memory (host and device) associated with an instance of the Lagrange class Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance procedure, public :: Init => Init_Lagrange public subroutine Init_Lagrange (myPoly, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange class\nOn output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(out) :: myPoly Lagrange class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) generic, public :: ScalarBoundaryInterp_1D => ScalarBoundaryInterp_1D_cpu , ScalarBoundaryInterp_1D_gpu public subroutine ScalarBoundaryInterp_1D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:nVariables,1:2,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_1D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_1D_cpu public subroutine ScalarBoundaryInterp_1D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:nVariables,1:2,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_1D_gpu public subroutine ScalarBoundaryInterp_1D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarBoundaryInterp_2D => ScalarBoundaryInterp_2D_cpu , ScalarBoundaryInterp_2D_gpu public subroutine ScalarBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_2D_cpu public subroutine ScalarBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_2D_gpu public subroutine ScalarBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarBoundaryInterp_3D => ScalarBoundaryInterp_3D_cpu , ScalarBoundaryInterp_3D_gpu public subroutine ScalarBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_3D_cpu public subroutine ScalarBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_3D_gpu public subroutine ScalarBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarDGGradient_2D => ScalarDGGradient_2D_cpu , ScalarDGGradient_2D_gpu public subroutine ScalarDGGradient_2D_cpu (myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarDGGradient_2D_gpu (myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarDGGradient_2D_cpu public subroutine ScalarDGGradient_2D_cpu (myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarDGGradient_2D_gpu public subroutine ScalarDGGradient_2D_gpu (myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarGradient_2D => ScalarGradient_2D_cpu , ScalarGradient_2D_gpu public subroutine ScalarGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGradient_2D_cpu public subroutine ScalarGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGradient_2D_gpu public subroutine ScalarGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarGradient_3D => ScalarGradient_3D_cpu , ScalarGradient_3D_gpu public subroutine ScalarGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGradient_3D_cpu public subroutine ScalarGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGradient_3D_gpu public subroutine ScalarGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarGridInterp_1D => ScalarGridInterp_1D_cpu , ScalarGridInterp_1D_gpu public subroutine ScalarGridInterp_1D_cpu (myPoly, f, fInterp, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fInterp (0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine ScalarGridInterp_1D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_1D_gpu_wrapper\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid procedure, private :: ScalarGridInterp_1D_cpu public subroutine ScalarGridInterp_1D_cpu (myPoly, f, fInterp, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fInterp (0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid procedure, private :: ScalarGridInterp_1D_gpu public subroutine ScalarGridInterp_1D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_1D_gpu_wrapper\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid generic, public :: ScalarGridInterp_2D => ScalarGridInterp_2D_cpu , ScalarGridInterp_2D_gpu public subroutine ScalarGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine ScalarGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_2D_gpu_wrapper\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid procedure, private :: ScalarGridInterp_2D_cpu public subroutine ScalarGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid procedure, private :: ScalarGridInterp_2D_gpu public subroutine ScalarGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_2D_gpu_wrapper\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid generic, public :: ScalarGridInterp_3D => ScalarGridInterp_3D_cpu , ScalarGridInterp_3D_gpu public subroutine ScalarGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGridInterp_3D_cpu public subroutine ScalarGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGridInterp_3D_gpu public subroutine ScalarGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorBoundaryInterp_2D => TensorBoundaryInterp_2D_cpu , TensorBoundaryInterp_2D_gpu public subroutine TensorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorBoundaryInterp_2D_cpu public subroutine TensorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorBoundaryInterp_2D_gpu public subroutine TensorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorBoundaryInterp_3D => TensorBoundaryInterp_3D_cpu , TensorBoundaryInterp_3D_gpu public subroutine TensorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorBoundaryInterp_3D_cpu public subroutine TensorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorBoundaryInterp_3D_gpu public subroutine TensorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorDGDivergence_2D => TensorDGDivergence_2D_cpu , TensorDGDivergence_2D_gpu public subroutine TensorDGDivergence_2D_cpu (myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDGDivergence_2D_gpu (myPoly, f_dev, bf_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDGDivergence_2D_cpu public subroutine TensorDGDivergence_2D_cpu (myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDGDivergence_2D_gpu public subroutine TensorDGDivergence_2D_gpu (myPoly, f_dev, bf_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorDGDivergence_3D => TensorDGDivergence_3D_cpu , TensorDGDivergence_3D_gpu public subroutine TensorDGDivergence_3D_cpu (myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDGDivergence_3D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDGDivergence_3D_cpu public subroutine TensorDGDivergence_3D_cpu (myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDGDivergence_3D_gpu public subroutine TensorDGDivergence_3D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorDivergence_2D => TensorDivergence_2D_cpu , TensorDivergence_2D_gpu public subroutine TensorDivergence_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDivergence_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDivergence_2D_cpu public subroutine TensorDivergence_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDivergence_2D_gpu public subroutine TensorDivergence_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorDivergence_3D => TensorDivergence_3D_cpu , TensorDivergence_3D_gpu public subroutine TensorDivergence_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDivergence_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDivergence_3D_cpu public subroutine TensorDivergence_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDivergence_3D_gpu public subroutine TensorDivergence_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorGridInterp_2D => TensorGridInterp_2D_cpu , TensorGridInterp_2D_gpu public subroutine TensorGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the TensorGridInterp_2D interface.\nIn most cases, you should use the TensorGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a tensor-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (1:2,1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine TensorGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the TensorGridInterp_2D interface.\nIn most cases, you should use the TensorGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:TensorGridInterp_2D_gpu_wrapper\nInterpolate a tensor-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid procedure, private :: TensorGridInterp_2D_cpu public subroutine TensorGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the TensorGridInterp_2D interface.\nIn most cases, you should use the TensorGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a tensor-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (1:2,1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid procedure, private :: TensorGridInterp_2D_gpu public subroutine TensorGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the TensorGridInterp_2D interface.\nIn most cases, you should use the TensorGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:TensorGridInterp_2D_gpu_wrapper\nInterpolate a tensor-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid generic, public :: TensorGridInterp_3D => TensorGridInterp_3D_cpu , TensorGridInterp_3D_gpu public subroutine TensorGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorGridInterp_3D_cpu public subroutine TensorGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorGridInterp_3D_gpu public subroutine TensorGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, public :: UpdateDevice => UpdateDevice_Lagrange public subroutine UpdateDevice_Lagrange (myPoly) Copy the Lagrange attributes from the host (CPU) to the device (GPU) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance procedure, public :: UpdateHost => UpdateHost_Lagrange public subroutine UpdateHost_Lagrange (myPoly) Copy the Lagrange attributes from the device (GPU) to the host (CPU) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance generic, public :: VectorBoundaryInterp_2D => VectorBoundaryInterp_2D_cpu , VectorBoundaryInterp_2D_gpu public subroutine VectorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorBoundaryInterp_2D_cpu public subroutine VectorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorBoundaryInterp_2D_gpu public subroutine VectorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorBoundaryInterp_3D => VectorBoundaryInterp_3D_cpu , VectorBoundaryInterp_3D_gpu public subroutine VectorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorBoundaryInterp_3D_cpu public subroutine VectorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorBoundaryInterp_3D_gpu public subroutine VectorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorCurl_2D => VectorCurl_2D_cpu , VectorCurl_2D_gpu public subroutine VectorCurl_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorCurl_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorCurl_2D_cpu public subroutine VectorCurl_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorCurl_2D_gpu public subroutine VectorCurl_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorCurl_3D => VectorCurl_3D_cpu , VectorCurl_3D_gpu public subroutine VectorCurl_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorCurl_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorCurl_3D_cpu public subroutine VectorCurl_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorCurl_3D_gpu public subroutine VectorCurl_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorDGDivergence_2D => VectorDGDivergence_2D_cpu , VectorDGDivergence_2D_gpu public subroutine VectorDGDivergence_2D_cpu (myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_2D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGDivergence_2D_cpu public subroutine VectorDGDivergence_2D_cpu (myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGDivergence_2D_gpu public subroutine VectorDGDivergence_2D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorDGDivergence_3D => VectorDGDivergence_3D_cpu , VectorDGDivergence_3D_gpu public subroutine VectorDGDivergence_3D_cpu (myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_3D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGDivergence_3D_cpu public subroutine VectorDGDivergence_3D_cpu (myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGDivergence_3D_gpu public subroutine VectorDGDivergence_3D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorDGGradient_2D => VectorDGGradient_2D_cpu , VectorDGGradient_2D_gpu public subroutine VectorDGGradient_2D_cpu (myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGGradient_2D_gpu (myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGGradient_2D_cpu public subroutine VectorDGGradient_2D_cpu (myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGGradient_2D_gpu public subroutine VectorDGGradient_2D_gpu (myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorDivergence_2D => VectorDivergence_2D_cpu , VectorDivergence_2D_gpu public subroutine VectorDivergence_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDivergence_2D_cpu public subroutine VectorDivergence_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDivergence_2D_gpu public subroutine VectorDivergence_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorDivergence_3D => VectorDivergence_3D_cpu , VectorDivergence_3D_gpu public subroutine VectorDivergence_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDivergence_3D_cpu public subroutine VectorDivergence_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDivergence_3D_gpu public subroutine VectorDivergence_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorGradient_2D => VectorGradient_2D_cpu , VectorGradient_2D_gpu public subroutine VectorGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGradient_2D_cpu public subroutine VectorGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGradient_2D_gpu public subroutine VectorGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorGradient_3D => VectorGradient_3D_cpu , VectorGradient_3D_gpu public subroutine VectorGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGradient_3D_cpu public subroutine VectorGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGradient_3D_gpu public subroutine VectorGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorGridInterp_2D => VectorGridInterp_2D_cpu , VectorGridInterp_2D_gpu public subroutine VectorGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine VectorGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:VectorGridInterp_2D_gpu_wrapper\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid procedure, private :: VectorGridInterp_2D_cpu public subroutine VectorGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid procedure, private :: VectorGridInterp_2D_gpu public subroutine VectorGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:VectorGridInterp_2D_gpu_wrapper\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid generic, public :: VectorGridInterp_3D => VectorGridInterp_3D_cpu , VectorGridInterp_3D_gpu public subroutine VectorGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGridInterp_3D_cpu public subroutine VectorGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGridInterp_3D_gpu public subroutine VectorGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Source Code TYPE , PUBLIC :: Lagrange !! A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions. !! The Lagrange data-structure stores the information necessary to interpolate between two !! sets of grid-points and to estimate the derivative of data at native grid points. Routines for !! multidimensional interpolation are based on the tensor product of 1-D interpolants. It is !! assumed that the polynomial degree (and the interpolation nodes) are the same in each direction. !! This assumption permits the storage of only one array of interpolation nodes and barycentric !! weights and is what allows this data structure to be flexible. INTEGER :: N !! The number of control points. INTEGER :: M !! The number of target points. TYPE ( hfReal_r1 ) :: controlPoints !! The set of nodes in one dimension where data is known. !! To create higher dimension interpolation and differentiation operators, structured grids in two and three !! dimensions are created by tensor products of the controlPoints. This design decision implies that all !! spectral element methods supported by the Lagrange class have the same polynomial degree in each !! computational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto, !! Legendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over !! the domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of !! these quadrature types or uniform points on [-1,1]. TYPE ( hfReal_r1 ) :: targetPoints !! The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation !! and differentiation operators, structured grids in two and three dimensions are created by tensor products of !! the targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1] !! (computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. TYPE ( hfReal_r1 ) :: bWeights !! The barycentric weights that are calculated from the controlPoints and used for interpolation. TYPE ( hfReal_r1 ) :: qWeights !! The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints !! provided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss, !! Chebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant !! dx = \\frac{2.0}{N+1}. TYPE ( hfReal_r2 ) :: iMatrix !! The interpolation matrix (transpose) for mapping data from the control grid to the target grid. TYPE ( hfReal_r2 ) :: dMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The !! dMatrix is based on a strong form of the derivative. TYPE ( hfReal_r2 ) :: dgMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based !! on a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. TYPE ( hfReal_r2 ) :: bMatrix !! The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. CONTAINS PROCEDURE , PUBLIC :: Init => Init_Lagrange PROCEDURE , PUBLIC :: Free => Free_Lagrange PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Lagrange PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Lagrange GENERIC , PUBLIC :: ScalarGridInterp_1D => ScalarGridInterp_1D_cpu , ScalarGridInterp_1D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_1D_cpu , ScalarGridInterp_1D_gpu GENERIC , PUBLIC :: ScalarGridInterp_2D => ScalarGridInterp_2D_cpu , ScalarGridInterp_2D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_2D_cpu , ScalarGridInterp_2D_gpu GENERIC , PUBLIC :: VectorGridInterp_2D => VectorGridInterp_2D_cpu , VectorGridInterp_2D_gpu PROCEDURE , PRIVATE :: VectorGridInterp_2D_cpu , VectorGridInterp_2D_gpu GENERIC , PUBLIC :: TensorGridInterp_2D => TensorGridInterp_2D_cpu , TensorGridInterp_2D_gpu PROCEDURE , PRIVATE :: TensorGridInterp_2D_cpu , TensorGridInterp_2D_gpu GENERIC , PUBLIC :: ScalarGridInterp_3D => ScalarGridInterp_3D_cpu , ScalarGridInterp_3D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_3D_cpu , ScalarGridInterp_3D_gpu GENERIC , PUBLIC :: VectorGridInterp_3D => VectorGridInterp_3D_cpu , VectorGridInterp_3D_gpu PROCEDURE , PRIVATE :: VectorGridInterp_3D_cpu , VectorGridInterp_3D_gpu GENERIC , PUBLIC :: TensorGridInterp_3D => TensorGridInterp_3D_cpu , TensorGridInterp_3D_gpu PROCEDURE , PRIVATE :: TensorGridInterp_3D_cpu , TensorGridInterp_3D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_1D => ScalarBoundaryInterp_1D_cpu , ScalarBoundaryInterp_1D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_1D_cpu , ScalarBoundaryInterp_1D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_2D => ScalarBoundaryInterp_2D_cpu , ScalarBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_2D_cpu , ScalarBoundaryInterp_2D_gpu GENERIC , PUBLIC :: VectorBoundaryInterp_2D => VectorBoundaryInterp_2D_cpu , VectorBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: VectorBoundaryInterp_2D_cpu , VectorBoundaryInterp_2D_gpu GENERIC , PUBLIC :: TensorBoundaryInterp_2D => TensorBoundaryInterp_2D_cpu , TensorBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: TensorBoundaryInterp_2D_cpu , TensorBoundaryInterp_2D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_3D => ScalarBoundaryInterp_3D_cpu , ScalarBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_3D_cpu , ScalarBoundaryInterp_3D_gpu GENERIC , PUBLIC :: VectorBoundaryInterp_3D => VectorBoundaryInterp_3D_cpu , VectorBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: VectorBoundaryInterp_3D_cpu , VectorBoundaryInterp_3D_gpu GENERIC , PUBLIC :: TensorBoundaryInterp_3D => TensorBoundaryInterp_3D_cpu , TensorBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: TensorBoundaryInterp_3D_cpu , TensorBoundaryInterp_3D_gpu GENERIC , PUBLIC :: Derivative_1D => Derivative_1D_cpu , Derivative_1D_gpu PROCEDURE , PRIVATE :: Derivative_1D_cpu , Derivative_1D_gpu GENERIC , PUBLIC :: DGDerivative_1D => DGDerivative_1D_cpu , DGDerivative_1D_gpu PROCEDURE , PRIVATE :: DGDerivative_1D_cpu , DGDerivative_1D_gpu GENERIC , PUBLIC :: ScalarGradient_2D => ScalarGradient_2D_cpu , ScalarGradient_2D_gpu PROCEDURE , PRIVATE :: ScalarGradient_2D_cpu , ScalarGradient_2D_gpu GENERIC , PUBLIC :: ScalarDGGradient_2D => ScalarDGGradient_2D_cpu , ScalarDGGradient_2D_gpu PROCEDURE , PRIVATE :: ScalarDGGradient_2D_cpu , ScalarDGGradient_2D_gpu GENERIC , PUBLIC :: VectorGradient_2D => VectorGradient_2D_cpu , VectorGradient_2D_gpu PROCEDURE , PRIVATE :: VectorGradient_2D_cpu , VectorGradient_2D_gpu GENERIC , PUBLIC :: VectorDGGradient_2D => VectorDGGradient_2D_cpu , VectorDGGradient_2D_gpu PROCEDURE , PRIVATE :: VectorDGGradient_2D_cpu , VectorDGGradient_2D_gpu GENERIC , PUBLIC :: VectorDivergence_2D => VectorDivergence_2D_cpu , VectorDivergence_2D_gpu PROCEDURE , PRIVATE :: VectorDivergence_2D_cpu , VectorDivergence_2D_gpu GENERIC , PUBLIC :: VectorDGDivergence_2D => VectorDGDivergence_2D_cpu , VectorDGDivergence_2D_gpu PROCEDURE , PRIVATE :: VectorDGDivergence_2D_cpu , VectorDGDivergence_2D_gpu GENERIC , PUBLIC :: VectorCurl_2D => VectorCurl_2D_cpu , VectorCurl_2D_gpu PROCEDURE , PRIVATE :: VectorCurl_2D_cpu , VectorCurl_2D_gpu GENERIC , PUBLIC :: TensorDivergence_2D => TensorDivergence_2D_cpu , TensorDivergence_2D_gpu PROCEDURE , PRIVATE :: TensorDivergence_2D_cpu , TensorDivergence_2D_gpu GENERIC , PUBLIC :: TensorDGDivergence_2D => TensorDGDivergence_2D_cpu , TensorDGDivergence_2D_gpu PROCEDURE , PRIVATE :: TensorDGDivergence_2D_cpu , TensorDGDivergence_2D_gpu GENERIC , PUBLIC :: ScalarGradient_3D => ScalarGradient_3D_cpu , ScalarGradient_3D_gpu PROCEDURE , PRIVATE :: ScalarGradient_3D_cpu , ScalarGradient_3D_gpu GENERIC , PUBLIC :: VectorGradient_3D => VectorGradient_3D_cpu , VectorGradient_3D_gpu PROCEDURE , PRIVATE :: VectorGradient_3D_cpu , VectorGradient_3D_gpu GENERIC , PUBLIC :: VectorDivergence_3D => VectorDivergence_3D_cpu , VectorDivergence_3D_gpu PROCEDURE , PRIVATE :: VectorDivergence_3D_cpu , VectorDivergence_3D_gpu GENERIC , PUBLIC :: VectorDGDivergence_3D => VectorDGDivergence_3D_cpu , VectorDGDivergence_3D_gpu PROCEDURE , PRIVATE :: VectorDGDivergence_3D_cpu , VectorDGDivergence_3D_gpu GENERIC , PUBLIC :: VectorCurl_3D => VectorCurl_3D_cpu , VectorCurl_3D_gpu PROCEDURE , PRIVATE :: VectorCurl_3D_cpu , VectorCurl_3D_gpu GENERIC , PUBLIC :: TensorDivergence_3D => TensorDivergence_3D_cpu , TensorDivergence_3D_gpu PROCEDURE , PRIVATE :: TensorDivergence_3D_cpu , TensorDivergence_3D_gpu GENERIC , PUBLIC :: TensorDGDivergence_3D => TensorDGDivergence_3D_cpu , TensorDGDivergence_3D_gpu PROCEDURE , PRIVATE :: TensorDGDivergence_3D_cpu , TensorDGDivergence_3D_gpu PROCEDURE , PRIVATE :: CalculateBarycentricWeights PROCEDURE , PRIVATE :: CalculateInterpolationMatrix PROCEDURE , PRIVATE :: CalculateDerivativeMatrix PROCEDURE , PRIVATE :: CalculateLagrangePolynomials END TYPE Lagrange","tags":"","loc":"type/lagrange.html"},{"title":"AlmostEqual – SELF","text":"public function AlmostEqual(a, b) result(AisB) \\addtogroup SELF_SupportRoutines\n @{\n \\fn AlmostEqual\n Compares two floating point numbers and determines if they are equal (to machine precision). This function is from Alg. 139 on pg. 359 of D.A. Kopriva, 2009, \"Implementing Spectral Element\n    Methods for Scientists and Engineers\" Usage : Logical :: AisB REAL (prec) :: a, b .... AisB = AlmostEqual( a, b ) Parameters : in a REAL(prec) scalar in b REAL(prec) scalar in AisB Logical .TRUE. IF a=b to machine precision .FALSE. otherwise @} Arguments Type Intent Optional Attributes Name real(kind=real64) :: a real(kind=real64) :: b Return Value logical Contents Source Code AlmostEqual Source Code FUNCTION AlmostEqual ( a , b ) RESULT ( AisB ) IMPLICIT NONE REAL ( real64 ) :: a , b LOGICAL :: AisB IF ( a == 0.0_real64 . OR . b == 0.0_real64 ) THEN IF ( ABS ( a - b ) <= EPSILON ( 1.0_real64 )) THEN AisB = . TRUE . ELSE AisB = . FALSE . END IF ELSE IF (( abs ( a - b ) <= EPSILON ( 1.0_real64 ) * abs ( a )) . OR . ( abs ( a - b ) <= EPSILON ( 1.0_real64 ) * abs ( b ))) THEN AisB = . TRUE . ELSE AisB = . FALSE . END IF END IF END FUNCTION AlmostEqual","tags":"","loc":"proc/almostequal.html"},{"title":"CompareArray – SELF","text":"public function CompareArray(arrayOne, arrayTwo, N) result(arraysMatch) \\addtogroup SELF_SupportRoutines\n @{\n \\fn CompareArray\n Compares to INTEGER arrays and determines if they are identical. A logical is returned that specifies whether or not two arrays are identical. To determine\n if the two arrays are identical, the sum of the difference between each element in the input\n array is calculated. If the arrays are identical, each contribution to the sum is zero and hence\n the sum is zero. If the sum is non-zero, the arrays are distinct. This routine is used in the \\ref HexMeshClass module. A face of an element in an unstructured\n mesh is identified by its four corner nodes. When identifying unique faces in an unstructured\n mesh, we need to determine if two elements share a face. This can be accomplished by comparing\n the four corner nodes (from each element) that define each face. Usage : INTEGER :: N INTEGER :: arrayOne(1:N) INTEGER :: arrayTwo(1:N) LOGICAL :: arraysMatch .... arraysMatch = CompareArray( arrayOne, arrayTwo, N ) Parameters : in arrayOne(1:N) INTEGER in arrayTwo(1:N) INTEGER in N INTEGER out arraysMatch INTEGER @} Arguments Type Intent Optional Attributes Name integer :: arrayOne (1:N) integer :: arrayTwo (1:N) integer :: N Return Value logical Contents Source Code CompareArray Source Code FUNCTION CompareArray ( arrayOne , arrayTwo , N ) RESULT ( arraysMatch ) IMPLICIT NONE INTEGER :: N INTEGER :: arrayOne ( 1 : N ), arrayTwo ( 1 : N ) LOGICAL :: arraysMatch ! LOCAL INTEGER :: i , theSumOfDiffs theSumOfDiffs = 0 DO i = 1 , N theSumOfDiffs = theSumOfDiffs + arrayOne ( i ) - arrayTwo ( i ) END DO IF ( theSumOfDiffs == 0 ) THEN arraysMatch = . TRUE . ELSE arraysMatch = . FALSE . END IF END FUNCTION CompareArray","tags":"","loc":"proc/comparearray.html"},{"title":"Determinant – SELF","text":"public recursive function Determinant(A, N) result(D) \\addtogroup SELF_SupportRoutines\n @{\n \\fn Determinant\n A recursive function that calculates the determinant of an \\f$ N\\times N \\f$ matrix. This function is used in the functions \\ref invert_2x2 and \\ref invert_3x3 This function depends on Function \\ref getminor Usage : INTEGER :: N REAL (prec) :: A(1:N,1:N), D .... D = Determinant( A, N ) Parameters : in A(1:N,1:N) REAL(prec) Square matrix in N INTEGER Dimension of the matrix out detA REAL(prec) The determinant of the matrix @} Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:N,1:N) integer :: N Return Value real(kind=prec) Calls proc~~determinant~~CallsGraph proc~determinant Determinant proc~determinant->proc~determinant proc~getminor GetMinor proc~determinant->proc~getminor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~determinant~~CalledByGraph proc~determinant Determinant proc~determinant->proc~determinant proc~invert_3x3 Invert_3x3 proc~invert_3x3->proc~determinant proc~invert_2x2 Invert_2x2 proc~invert_2x2->proc~determinant Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Determinant Source Code RECURSIVE FUNCTION Determinant ( A , N ) RESULT ( D ) IMPLICIT NONE INTEGER :: N REAL ( prec ) :: A ( 1 : N , 1 : N ) REAL ( prec ) :: D ! LOCAL REAL ( prec ) :: M ( 1 : N - 1 , 1 : N - 1 ) INTEGER :: j IF ( N == 2 ) THEN D = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) RETURN ELSE D = 0.0_prec DO j = 1 , N M = GetMinor ( A , 1 , j , N ) D = D + ( - 1.0_prec ) ** ( j + 1 ) * A ( 1 , j ) * Determinant ( M , N - 1 ) END DO END IF END FUNCTION Determinant","tags":"","loc":"proc/determinant.html"},{"title":"Float2Str – SELF","text":"public function Float2Str(aNumber) result(aString) Arguments Type Intent Optional Attributes Name real(kind=prec) :: aNumber Return Value character(len=12) Contents Source Code Float2Str Source Code FUNCTION Float2Str ( aNumber ) RESULT ( aString ) IMPLICIT NONE REAL ( prec ) :: aNumber CHARACTER ( 12 ) :: aString WRITE ( aString , '(E12.4)' ) aNumber END FUNCTION Float2Str","tags":"","loc":"proc/float2str.html"},{"title":"FloorCURT – SELF","text":"public function FloorCURT(x) result(curtX) Arguments Type Intent Optional Attributes Name integer :: x Return Value integer Contents Source Code FloorCURT Source Code FUNCTION FloorCURT ( x ) RESULT ( curtX ) INTEGER :: x , curtX ! Local INTEGER :: i , res IF ( x == 0 . OR . x == 1 ) THEN curtX = x ELSE res = 1 i = 1 DO WHILE ( res <= x ) i = i + 1 res = i * i * i END DO curtX = i - 1 END IF END FUNCTION FloorCURT","tags":"","loc":"proc/floorcurt.html"},{"title":"FloorSQRT – SELF","text":"public function FloorSQRT(x) result(sqrtX) Arguments Type Intent Optional Attributes Name integer :: x Return Value integer Contents Source Code FloorSQRT Source Code FUNCTION FloorSQRT ( x ) RESULT ( sqrtX ) INTEGER :: x , sqrtX ! Local INTEGER :: i , res IF ( x == 0 . OR . x == 1 ) THEN sqrtX = x ELSE res = 1 i = 1 DO WHILE ( res <= x ) i = i + 1 res = i * i END DO sqrtX = i - 1 END IF END FUNCTION FloorSQRT","tags":"","loc":"proc/floorsqrt.html"},{"title":"GetMinor – SELF","text":"public function GetMinor(A, i, j, N) result(M) \\addtogroup SELF_SupportRoutines\n @{\n \\fn GetMinor\n Returns the submatrix obtained by removing a given row and column of the input matrix. The minor of a matrix is used in calculating the determinant of a matrix. Usage : INTEGER :: i, j, N REAL (prec) :: A(1:N,1:N), M(1:N-1,1:N-1) .... M = GetMinor( A, i, j, N ) Usage : TYPE (DataType) :: this .... CALL this % RoutineName( Inputs/Outputs ) Parameters : in A(1:N,1:N) REAL(prec) Square matrix in i INTEGER The row that is removed from A to form the minor of A in j INTEGER The column that is removed from A to form the minor of A in N INTEGER The dimension of A in M(1:N-1,1:N-1) REAL(prec) The (i,j) minor of A @} Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:N,1:N) integer :: i integer :: j integer :: N Return Value real(kind=prec)\n  (1:N-1,1:N-1) Called by proc~~getminor~~CalledByGraph proc~getminor GetMinor proc~determinant Determinant proc~determinant->proc~getminor proc~determinant->proc~determinant proc~invert_3x3 Invert_3x3 proc~invert_3x3->proc~determinant proc~invert_2x2 Invert_2x2 proc~invert_2x2->proc~determinant Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code GetMinor Source Code FUNCTION GetMinor ( A , i , j , N ) RESULT ( M ) IMPLICIT NONE INTEGER :: i , j , N REAL ( prec ) :: A ( 1 : N , 1 : N ) REAL ( prec ) :: M ( 1 : N - 1 , 1 : N - 1 ) ! LOCAL INTEGER :: row , col INTEGER :: thisRow , thisCol thisRow = 0 DO row = 1 , N ! loop over the rows of A IF ( row /= i ) THEN thisRow = thisRow + 1 thisCol = 0 DO col = 1 , N ! loop over the columns of A IF ( col /= j ) THEN thisCol = thisCol + 1 M ( thisRow , thisCol ) = A ( row , col ) END IF END DO ! col, loop over the columns of A END IF END DO ! row, loop over the rows of A END FUNCTION GetMinor","tags":"","loc":"proc/getminor.html"},{"title":"Int2Str – SELF","text":"public function Int2Str(aNumber) result(aString) Arguments Type Intent Optional Attributes Name integer :: aNumber Return Value character(len=12) Contents Source Code Int2Str Source Code FUNCTION Int2Str ( aNumber ) RESULT ( aString ) IMPLICIT NONE INTEGER :: aNumber CHARACTER ( 12 ) :: aString WRITE ( aString , '(I9)' ) aNumber END FUNCTION Int2Str","tags":"","loc":"proc/int2str.html"},{"title":"InvertSpectralOpMatrix – SELF","text":"public function InvertSpectralOpMatrix(A, N) result(Ainv) Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (0:N,0:N) integer :: N Return Value real(kind=prec)\n  (0:N,0:N) Contents Source Code InvertSpectralOpMatrix Source Code FUNCTION InvertSpectralOpMatrix ( A , N ) RESULT ( Ainv ) ! Inverts an (N+1)x(N+1) matrix using a polynomial representation of the ! inverse IMPLICIT NONE INTEGER :: N REAL ( prec ) :: A ( 0 : N , 0 : N ) REAL ( prec ) :: Ainv ( 0 : N , 0 : N ) ! Local INTEGER :: row , col , j , iter REAL ( prec ) :: I ( 0 : N , 0 : N ) REAL ( prec ) :: Ainv_ij , maxChange Ainv = 0.0_prec I = 0.0_prec DO row = 0 , N Ainv ( row , row ) = 1.0_prec I ( row , row ) = 1.0_prec END DO DO iter = 1 , maxInverseIters maxChange = 0.0_prec DO col = 0 , N DO row = 0 , N Ainv_ij = 0.0_prec DO j = 0 , N Ainv_ij = Ainv_ij + Ainv ( j , col ) * ( I ( row , j ) - A ( row , j )) END DO maxChange = MAX ( ABS ( Ainv ( row , col ) - Ainv_ij ), maxChange ) Ainv ( row , col ) = Ainv_ij END DO END DO IF ( maxChange <= tolerance ) THEN PRINT * , ' InvertSpectralOpMatrix : Converged in ' , iter , ' iterations.' EXIT END IF END DO IF ( maxChange > tolerance ) THEN PRINT * , 'InvertSpectralOpMatrix : Did not converge.' , maxChange END IF END FUNCTION InvertSpectralOpMatrix","tags":"","loc":"proc/invertspectralopmatrix.html"},{"title":"Invert_2x2 – SELF","text":"public function Invert_2x2(A) result(Ainv) \\addtogroup SELF_SupportRoutines\n @{\n \\fn Invert_2x2\n  Computes the inverse of a 2x2 matrix using Kramer's rule. This Function depends on \\ref determinant Usage : REAL (prec) :: A(1:2,1:2), Ainv(1:2,1:2) .... Ainv = Invert_2x2( A ) Parameters : in A(1:2,1:2) REAL(prec) Real 2x2 matrix in Ainv(1:2,1:2) REAL(prec) Real 2x2 matrix, inverse of A @} Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:2,1:2) Return Value real(kind=prec)\n  (1:2,1:2) Calls proc~~invert_2x2~~CallsGraph proc~invert_2x2 Invert_2x2 proc~determinant Determinant proc~invert_2x2->proc~determinant proc~determinant->proc~determinant proc~getminor GetMinor proc~determinant->proc~getminor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Invert_2x2 Source Code FUNCTION Invert_2x2 ( A ) RESULT ( Ainv ) IMPLICIT NONE REAL ( prec ) :: A ( 1 : 2 , 1 : 2 ) REAL ( prec ) :: Ainv ( 1 : 2 , 1 : 2 ) ! LOCAL REAL ( prec ) :: detA detA = Determinant ( A , 2 ) Ainv ( 1 , 1 ) = A ( 2 , 2 ) / detA Ainv ( 2 , 2 ) = A ( 1 , 1 ) / detA Ainv ( 1 , 2 ) = - A ( 1 , 2 ) / detA Ainv ( 2 , 1 ) = - A ( 2 , 1 ) / detA END FUNCTION Invert_2x2","tags":"","loc":"proc/invert_2x2.html"},{"title":"Invert_3x3 – SELF","text":"public function Invert_3x3(A) result(Ainv) \\addtogroup SELF_SupportRoutines\n @{\n \\fn Invert_3x3\n  Computes the inverse of a 3x3 matrix using Kramer's rule. This Function depends on \\ref determinant Usage : REAL (prec) :: A(1:3,1:3), Ainv(1:3,1:3) .... Ainv = Invert_3x3( A ) Parameters : in A(1:3,1:3) REAL(prec) Real 3x3 matrix in Ainv(1:3,1:3) REAL(prec) Real 3x3 matrix, inverse of A @} Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:3,1:3) Return Value real(kind=prec)\n  (1:3,1:3) Calls proc~~invert_3x3~~CallsGraph proc~invert_3x3 Invert_3x3 proc~determinant Determinant proc~invert_3x3->proc~determinant proc~determinant->proc~determinant proc~getminor GetMinor proc~determinant->proc~getminor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Invert_3x3 Source Code FUNCTION Invert_3x3 ( A ) RESULT ( Ainv ) ! ! =============================================================================================== ! IMPLICIT NONE REAL ( prec ) :: A ( 1 : 3 , 1 : 3 ) REAL ( prec ) :: Ainv ( 1 : 3 , 1 : 3 ) ! LOCAL REAL ( prec ) :: detA REAL ( prec ) :: submat ( 1 : 2 , 1 : 2 ) REAL ( prec ) :: detSubmat detA = Determinant ( A , 3 ) ! Row 1 column 1 of inverse (use submatrix neglecting row 1 and column 1 of A) submat = A ( 2 : 3 , 2 : 3 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 1 , 1 ) = detSubmat / detA ! Row 1 column 2 of inverse (use submatrix neglecting row 2 and column 1 of A) submat = A ( 1 : 3 : 2 , 2 : 3 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 1 , 2 ) = - detSubmat / detA ! Row 1 column 3 of inverse (use submatrix neglecting row 3 and column 1 of A) submat = A ( 1 : 2 , 2 : 3 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 1 , 3 ) = detSubmat / detA ! Row 2 column 1 of inverse (use submatrix neglecting row 1 and column 2 of A) submat = A ( 2 : 3 , 1 : 3 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 2 , 1 ) = - detSubmat / detA ! Row 2 column 2 of inverse (use submatrix neglecting row 2 and column 2 of A) submat = A ( 1 : 3 : 2 , 1 : 3 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 2 , 2 ) = detSubmat / detA ! Row 2 column 3 of inverse (use submatrix neglecting row 3 and column 2 of A) submat = A ( 1 : 2 , 1 : 3 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 2 , 3 ) = - detSubmat / detA ! Row 3 column 1 of inverse (use submatrix neglecting row 1 and column 3 of A) submat = A ( 2 : 3 , 1 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 3 , 1 ) = detSubmat / detA ! Row 3 column 2 of inverse (use submatrix neglecting row 2 and column 3 of A) submat = A ( 1 : 3 : 2 , 1 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 3 , 2 ) = - detSubmat / detA ! Row 3 column 3 of inverse (use submatrix neglecting row 3 and column 3 of A) submat = A ( 1 : 2 , 1 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 3 , 3 ) = detSubmat / detA END FUNCTION Invert_3x3","tags":"","loc":"proc/invert_3x3.html"},{"title":"IsInf – SELF","text":"public function IsInf(a) Arguments Type Intent Optional Attributes Name real(kind=prec) :: a Return Value logical Contents Source Code IsInf Source Code LOGICAL FUNCTION IsInf ( a ) IMPLICIT NONE REAL ( prec ) :: a IF ( a > HUGE ( prec )) THEN IsInf = . TRUE . ELSE IsInf = . FALSE . END IF RETURN END FUNCTION IsInf","tags":"","loc":"proc/isinf.html"},{"title":"NewUnit – SELF","text":"public function NewUnit(thisunit) \\addtogroup SELF_SupportRoutines\n @{\n \\fn NewUnit\n Returns a file unit identifier that is currently not in use. Usage : INTEGER :: thisUnit .... OPEN ( UNIT=NewUnit(thisUnit), FILE=filename) Parameters : out thisunit INTEGER File unit that is not in use @} Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: thisunit Return Value integer Contents Source Code NewUnit Source Code INTEGER FUNCTION NewUnit ( thisunit ) IMPLICIT NONE INTEGER , INTENT ( out ), OPTIONAL :: thisunit ! Local INTEGER , PARAMETER :: unitMin = 100 , unitMax = 1000 LOGICAL :: isopened INTEGER :: iUnit newunit = - 1 DO iUnit = unitMin , unitMax ! Check to see IF this UNIT is opened INQUIRE ( UNIT = iUnit , opened = isopened ) IF (. not . isopened ) THEN newunit = iUnit EXIT END IF END DO IF ( PRESENT ( thisunit )) thisunit = newunit END FUNCTION NewUnit","tags":"","loc":"proc/newunit.html"},{"title":"TimeStamp – SELF","text":"public function TimeStamp(time, units) result(timeStampString) Arguments Type Intent Optional Attributes Name real(kind=prec) :: time character(len=1) :: units Return Value character(len=13) Contents Source Code TimeStamp Source Code FUNCTION TimeStamp ( time , units ) RESULT ( timeStampString ) IMPLICIT NONE REAL ( prec ) :: time CHARACTER ( 1 ) :: units CHARACTER ( 13 ) :: timeStampString ! Local INTEGER :: day , minute , hour , second , millisecond CHARACTER ( 4 ) :: dayStamp CHARACTER ( 2 ) :: hourStamp , minuteStamp , secondStamp CHARACTER ( 3 ) :: milliSecondStamp REAL ( real64 ) :: time_real64 time_real64 = REAL ( time , real64 ) ! Units in \"seconds\" IF ( units ( 1 : 1 ) == 's' ) THEN ! Obtain the day day = INT ( time_real64 / 8640 0.0_real64 ) hour = INT (( time_real64 & - 8640 0.0_real64 * day ) / 360 0.0_real64 ) minute = INT (( time_real64 & - 360 0.0_real64 * hour & - 8640 0.0_real64 * day ) / 6 0.0_real64 ) second = INT (( time_real64 & - 6 0.0_real64 * minute & - 360 0.0_real64 * hour & - 8640 0.0_real64 * day )) milliSecond = NINT ((( time_real64 & - 6 0.0_real64 * minute & - 360 0.0_real64 * hour & - 8640 0.0_real64 * day ) & - REAL ( second , real64 )) * 100 0.0_real64 ) IF ( milliSecond >= 1000 ) THEN milliSecond = milliSecond - 1000 second = second + 1 ENDIF IF ( second >= 60 ) THEN second = second - 60 minute = minute + 1 ENDIF IF ( minute >= 60 ) THEN minute = minute - 60 hour = hour + 1 ENDIF IF ( hour >= 24 ) THEN hour = hour - 24 day = day + 1 ENDIF WRITE ( dayStamp , '(I4.4)' ) day WRITE ( hourStamp , '(I2.2)' ) hour WRITE ( minuteStamp , '(I2.2)' ) minute WRITE ( secondStamp , '(I2.2)' ) second WRITE ( milliSecondStamp , '(I3.3)' ) millisecond timeStampString = dayStamp // hourStamp // minuteStamp // secondStamp // milliSecondStamp ! minutes ELSEIF ( units ( 1 : 1 ) == 'm' ) THEN ! hours ELSEIF ( units ( 1 : 1 ) == 'h' ) THEN END IF END FUNCTION TimeStamp","tags":"","loc":"proc/timestamp.html"},{"title":"UniformPoints – SELF","text":"public function UniformPoints(a, b, firstInd, lastInd) result(xU) \\addtogroup SELF_SupportRoutines\n @{\n \\fn UniformPoints\n Generates a REAL(prec) array of N points evenly spaced between two points. Usage : REAL (prec) :: a REAL (prec) :: b REAL (prec) :: xU(0:N) INTEGER :: N .... xU = UniformPoints( a, b, N ) Parameters : in a REAL(prec) Starting point of the interval in b REAL(prec) Ending point of the interval in N INTEGER The number of points in the interval \\f$[a,b]\\f$ in xU(0:N) REAL(prec) Array of evenly spaced points in the interval \\f$[a,b]\\f$ @} Arguments Type Intent Optional Attributes Name real(kind=prec) :: a real(kind=prec) :: b integer :: firstInd integer :: lastInd Return Value real(kind=prec)\n  (firstInd:lastInd) Contents Source Code UniformPoints Source Code FUNCTION UniformPoints ( a , b , firstInd , lastInd ) RESULT ( xU ) IMPLICIT NONE REAL ( prec ) :: a , b INTEGER :: firstInd , lastInd REAL ( prec ) :: xU ( firstInd : lastInd ) ! LOCAL REAL ( prec ) :: dx INTEGER :: i dx = ( b - a ) / REAL (( lastInd - firstInd ), prec ) DO i = firstInd , lastInd xU ( i ) = a + dx * REAL ( i - firstInd , prec ) END DO END FUNCTION UniformPoints","tags":"","loc":"proc/uniformpoints.html"},{"title":"UpperCase – SELF","text":"public function UpperCase(str) result(Upper) Arguments Type Intent Optional Attributes Name character, intent(in) :: str Return Value character Contents Source Code UpperCase Source Code FUNCTION UpperCase ( str ) RESULT ( upper ) Implicit None CHARACTER ( * ), INTENT ( In ) :: str CHARACTER ( LEN ( str )) :: Upper INTEGER :: ic , i CHARACTER ( 27 ), PARAMETER :: cap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ ' CHARACTER ( 27 ), PARAMETER :: low = 'abcdefghijklmnopqrstuvwxyz ' DO i = 1 , LEN ( str ) ic = INDEX ( low , str ( i : i )) IF ( ic > 0 ) THEN Upper ( i : i ) = cap ( ic : ic ) ELSE Upper ( i : i ) = str ( i : i ) END IF END DO END FUNCTION UpperCase","tags":"","loc":"proc/uppercase.html"},{"title":"ForwardShift – SELF","text":"public subroutine ForwardShift(myArray, N) \\addtogroup SELF_SupportRoutines\n @{\n \\fn ForwardShift\n Shift an array integers by one index forward, moving the last index to the first. Shifts the array entries as follows : myArray(1) <-- myArray(N) myArray(2) <-- myArray(1) myArray(3) <-- myArray(2) Usage : INTEGER :: N INTEGER :: myArray(1:N) .... CALL ForwardShift( myArray, N ) Parameters : in/out myArray(1:N) INTEGER On output , the input array with elements shifted forward by\n                         one index. in N INTEGER The number of elements in the array @} Arguments Type Intent Optional Attributes Name integer, intent(inout) :: myArray (1:N) integer, intent(in) :: N Contents Source Code ForwardShift Source Code SUBROUTINE ForwardShift ( myArray , N ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( inout ) :: myArray ( 1 : N ) ! LOCAL INTEGER :: temp ( 1 : N ) temp = myArray myArray ( 1 ) = temp ( N ) myArray ( 2 : N ) = temp ( 1 : N - 1 ) END SUBROUTINE ForwardShift","tags":"","loc":"proc/forwardshift.html"},{"title":"InsertionSort – SELF","text":"public subroutine InsertionSort(inArray, outArray, N) \\addtogroup SELF_SupportRoutines\n @{\n \\fn InsertionSort\n Sorts an array of integers from smallest to largest using the insertion-sort algorithm. Usage : INTEGER :: N INTEGER :: inArray(1:N) INTEGER :: outArray(1:N) .... CALL InsertionSort( inArray, outArray, N ) Parameters : in N INTEGER The number of elements in the input and output arrays in inArray(1:N) INTEGER Array of unsorted integers. out outArray INTEGER Array of integers, sorted from most negative to most positive numbers. @} Arguments Type Intent Optional Attributes Name integer, intent(in) :: inArray (1:N) integer, intent(out) :: outArray (1:N) integer, intent(in) :: N Contents Source Code InsertionSort Source Code SUBROUTINE InsertionSort ( inArray , outArray , N ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: inArray ( 1 : N ) INTEGER , INTENT ( out ) :: outArray ( 1 : N ) ! LOCAL INTEGER :: i , j INTEGER :: temp outArray = inArray DO i = 2 , N j = i DO WHILE ( j > 1 ) IF ( outArray ( j - 1 ) > outArray ( j )) THEN !Swap outArray(j) outArray(j-1) temp = outArray ( j ) outArray ( j ) = outArray ( j - 1 ) outArray ( j - 1 ) = temp j = j - 1 ELSE EXIT END IF END DO END DO END SUBROUTINE InsertionSort","tags":"","loc":"proc/insertionsort.html"},{"title":"ReverseArray – SELF","text":"public subroutine ReverseArray(myArray, low, high) \\addtogroup SELF_SupportRoutines\n @{\n \\fn ReverseArray\n Reverses the order of a REAL(prec) array. Usage : REAL (prec) :: myArray(low:high) INTEGER :: low, high .... CALL ReverseArray( myArray, low, high ) Parameters : in/out myArray(low:high) REAL(prec) On output , the input array in reverse order . in low INTEGER Lower bound of the input and output arrays in high INTEGER Upper bound of the input and output arrays @} Arguments Type Intent Optional Attributes Name real(kind=prec), intent(inout) :: myArray (low:high) integer, intent(in) :: low integer, intent(in) :: high Contents Source Code ReverseArray Source Code SUBROUTINE ReverseArray ( myArray , low , high ) IMPLICIT NONE INTEGER , INTENT ( in ) :: low , high REAL ( prec ), INTENT ( inout ) :: myArray ( low : high ) ! LOCAL REAL ( prec ) :: temp ( low : high ) INTEGER :: i , j temp = myArray j = high DO i = low , high myArray ( i ) = temp ( j ) j = j - 1 END DO END SUBROUTINE ReverseArray","tags":"","loc":"proc/reversearray.html"},{"title":"SortAndSum – SELF","text":"public subroutine SortAndSum(myArray, low, high, arraysum) \\addtogroup SELF_SupportRoutines\n @{\n \\fn SortAndSum\n Computes the sum of an array by first sorting the array from smallest absolute value to largest\n absolute value. When computing the sum of an array of floating point values, round-off errors can be reduced\n by adding from the smallest to largest values. This subroutine depends on Subroutine \\ref sortarray Usage : REAL (prec) :: myArray(low:high) REAL (prec) :: arraySum INTEGER :: low, high .... CALL SortAndSum( myArray, low, high, arraySum ) Parameters : in/out myArray(low:high) REAL(prec) On input Unsorted array of floating point values On output Sorted array of floating point values, arranged in order\n                         of increasing absolute value. in low INTEGER Lower bound of the input and output arrays in high INTEGER Upper bound of the input and output arrays out arraySum REAL(prec) Sum of the array components. @} Arguments Type Intent Optional Attributes Name real(kind=prec), intent(inout) :: myArray (low:high) integer, intent(in) :: low integer, intent(in) :: high real(kind=prec), intent(out) :: arraysum Calls proc~~sortandsum~~CallsGraph proc~sortandsum SortAndSum proc~sortarray SortArray proc~sortandsum->proc~sortarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SortAndSum Source Code SUBROUTINE SortAndSum ( myArray , low , high , arraysum ) IMPLICIT NONE INTEGER , INTENT ( in ) :: low , high REAL ( prec ), INTENT ( inout ) :: myArray ( low : high ) REAL ( prec ), INTENT ( out ) :: arraysum ! LOCAL INTEGER :: ind CALL SortArray ( myArray , low , high ) arraysum = 0.0_prec DO ind = low , high arraysum = arraysum + myArray ( ind ) END DO END SUBROUTINE SortAndSum","tags":"","loc":"proc/sortandsum.html"},{"title":"SortArray – SELF","text":"public subroutine SortArray(myArray, low, high) \\addtogroup SELF_SupportRoutines\n @{\n \\fn SortArray\n Sorts a REAL(prec) array from smallest absolute value to largest absolute value. Usage : REAL (prec) :: myArray(low:high) INTEGER :: low, high .... CALL SortArray( myArray, low, high ) Parameters : in/out myArray(low:high) REAL(prec) On input Unsorted array of floating point values On output Sorted array of floating point values, arranged in order\n                         of increasing absolute value. in low INTEGER Lower bound of the input and output arrays in high INTEGER Upper bound of the input and output arrays @} Arguments Type Intent Optional Attributes Name real(kind=prec), intent(inout) :: myArray (low:high) integer, intent(in) :: low integer, intent(in) :: high Called by proc~~sortarray~~CalledByGraph proc~sortarray SortArray proc~sortandsum SortAndSum proc~sortandsum->proc~sortarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SortArray Source Code SUBROUTINE SortArray ( myArray , low , high ) IMPLICIT NONE INTEGER , INTENT ( in ) :: low , high REAL ( prec ), INTENT ( inout ) :: myArray ( low : high ) ! LOCAL INTEGER :: locOfMin INTEGER :: ind REAL ( prec ) :: temp DO ind = low , high - 1 locOfMin = MINLOC ( abs ( myArray ( ind : high )), 1 ) + low - 1 + ind temp = myArray ( ind ) myArray ( ind ) = myArray ( locOfMin ) myArray ( locOfMin ) = temp END DO END SUBROUTINE SortArray","tags":"","loc":"proc/sortarray.html"},{"title":"Set_Description_Metadata – SELF","text":"public subroutine Set_Description_Metadata(mtd, description) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: description Contents Source Code Set_Description_Metadata Source Code SUBROUTINE Set_Description_Metadata ( mtd , description ) IMPLICIT NONE CLASS ( Metadata ), INTENT ( inout ) :: mtd CHARACTER ( * ), INTENT ( in ) :: description mtd % description = description END SUBROUTINE Set_Description_Metadata","tags":"","loc":"proc/set_description_metadata.html"},{"title":"Set_Name_Metadata – SELF","text":"public subroutine Set_Name_Metadata(mtd, name) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: name Contents Source Code Set_Name_Metadata Source Code SUBROUTINE Set_Name_Metadata ( mtd , name ) IMPLICIT NONE CLASS ( Metadata ), INTENT ( inout ) :: mtd CHARACTER ( * ), INTENT ( in ) :: name mtd % name = name END SUBROUTINE Set_Name_Metadata","tags":"","loc":"proc/set_name_metadata.html"},{"title":"Set_Units_Metadata – SELF","text":"public subroutine Set_Units_Metadata(mtd, units) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: units Contents Source Code Set_Units_Metadata Source Code SUBROUTINE Set_Units_Metadata ( mtd , units ) IMPLICIT NONE CLASS ( Metadata ), INTENT ( inout ) :: mtd CHARACTER ( * ), INTENT ( in ) :: units mtd % units = units END SUBROUTINE Set_Units_Metadata","tags":"","loc":"proc/set_units_metadata.html"},{"title":"GPUAvailable – SELF","text":"public function GPUAvailable() result(avail) Arguments None Return Value logical Calls proc~~gpuavailable~~CallsGraph proc~gpuavailable GPUAvailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~gpuavailable~~CalledByGraph proc~gpuavailable GPUAvailable proc~updatedevice_hfreal_r6 UpdateDevice_hfReal_r6 proc~updatedevice_hfreal_r6->proc~gpuavailable proc~alloc_hfreal_r2 Alloc_hfReal_r2 proc~alloc_hfreal_r2->proc~gpuavailable proc~alloc_hfint32_r5 Alloc_hfInt32_r5 proc~alloc_hfint32_r5->proc~gpuavailable proc~updatedevice_hfreal_r4 UpdateDevice_hfReal_r4 proc~updatedevice_hfreal_r4->proc~gpuavailable proc~alloc_hfreal_r5 Alloc_hfReal_r5 proc~alloc_hfreal_r5->proc~gpuavailable proc~updatedevice_hfreal_r3 UpdateDevice_hfReal_r3 proc~updatedevice_hfreal_r3->proc~gpuavailable proc~updatedevice_hfint32_r6 UpdateDevice_hfInt32_r6 proc~updatedevice_hfint32_r6->proc~gpuavailable proc~updatedevice_hfint64_r2 UpdateDevice_hfInt64_r2 proc~updatedevice_hfint64_r2->proc~gpuavailable proc~free_hfint32_r7 Free_hfInt32_r7 proc~free_hfint32_r7->proc~gpuavailable proc~free_hfint32_r5 Free_hfInt32_r5 proc~free_hfint32_r5->proc~gpuavailable proc~updatehost_hfint32_r5 UpdateHost_hfInt32_r5 proc~updatehost_hfint32_r5->proc~gpuavailable proc~updatehost_hfint64_r4 UpdateHost_hfInt64_r4 proc~updatehost_hfint64_r4->proc~gpuavailable proc~alloc_hfint64_r5 Alloc_hfInt64_r5 proc~alloc_hfint64_r5->proc~gpuavailable proc~updatehost_hfint64_r5 UpdateHost_hfInt64_r5 proc~updatehost_hfint64_r5->proc~gpuavailable proc~free_hfreal_r4 Free_hfReal_r4 proc~free_hfreal_r4->proc~gpuavailable proc~updatehost_hfint64_r3 UpdateHost_hfInt64_r3 proc~updatehost_hfint64_r3->proc~gpuavailable proc~updatedevice_hfint64_r5 UpdateDevice_hfInt64_r5 proc~updatedevice_hfint64_r5->proc~gpuavailable proc~free_hfreal_r7 Free_hfReal_r7 proc~free_hfreal_r7->proc~gpuavailable proc~alloc_hfint32_r1 Alloc_hfInt32_r1 proc~alloc_hfint32_r1->proc~gpuavailable proc~updatehost_hfint32_r3 UpdateHost_hfInt32_r3 proc~updatehost_hfint32_r3->proc~gpuavailable proc~alloc_hfint64_r6 Alloc_hfInt64_r6 proc~alloc_hfint64_r6->proc~gpuavailable proc~free_hfint32_r3 Free_hfInt32_r3 proc~free_hfint32_r3->proc~gpuavailable proc~updatedevice_hfreal_r1 UpdateDevice_hfReal_r1 proc~updatedevice_hfreal_r1->proc~gpuavailable proc~free_hfreal_r3 Free_hfReal_r3 proc~free_hfreal_r3->proc~gpuavailable proc~free_hfint64_r6 Free_hfInt64_r6 proc~free_hfint64_r6->proc~gpuavailable proc~updatehost_hfint32_r1 UpdateHost_hfInt32_r1 proc~updatehost_hfint32_r1->proc~gpuavailable proc~updatedevice_hfint64_r3 UpdateDevice_hfInt64_r3 proc~updatedevice_hfint64_r3->proc~gpuavailable proc~alloc_hfint32_r7 Alloc_hfInt32_r7 proc~alloc_hfint32_r7->proc~gpuavailable proc~free_hfint32_r2 Free_hfInt32_r2 proc~free_hfint32_r2->proc~gpuavailable proc~alloc_hfint64_r1 Alloc_hfInt64_r1 proc~alloc_hfint64_r1->proc~gpuavailable proc~updatehost_hfint32_r4 UpdateHost_hfInt32_r4 proc~updatehost_hfint32_r4->proc~gpuavailable proc~free_hfreal_r1 Free_hfReal_r1 proc~free_hfreal_r1->proc~gpuavailable proc~free_hfint32_r1 Free_hfInt32_r1 proc~free_hfint32_r1->proc~gpuavailable proc~free_hfreal_r2 Free_hfReal_r2 proc~free_hfreal_r2->proc~gpuavailable proc~updatehost_hfreal_r3 UpdateHost_hfReal_r3 proc~updatehost_hfreal_r3->proc~gpuavailable proc~free_hfint32_r6 Free_hfInt32_r6 proc~free_hfint32_r6->proc~gpuavailable proc~free_hfreal_r5 Free_hfReal_r5 proc~free_hfreal_r5->proc~gpuavailable proc~updatedevice_hfint32_r1 UpdateDevice_hfInt32_r1 proc~updatedevice_hfint32_r1->proc~gpuavailable proc~updatedevice_hfint64_r7 UpdateDevice_hfInt64_r7 proc~updatedevice_hfint64_r7->proc~gpuavailable proc~updatedevice_hfint64_r1 UpdateDevice_hfInt64_r1 proc~updatedevice_hfint64_r1->proc~gpuavailable proc~updatehost_hfreal_r1 UpdateHost_hfReal_r1 proc~updatehost_hfreal_r1->proc~gpuavailable proc~free_hfint64_r7 Free_hfInt64_r7 proc~free_hfint64_r7->proc~gpuavailable proc~alloc_hfint32_r3 Alloc_hfInt32_r3 proc~alloc_hfint32_r3->proc~gpuavailable proc~updatehost_hfreal_r2 UpdateHost_hfReal_r2 proc~updatehost_hfreal_r2->proc~gpuavailable proc~alloc_hfreal_r3 Alloc_hfReal_r3 proc~alloc_hfreal_r3->proc~gpuavailable proc~free_hfint64_r5 Free_hfInt64_r5 proc~free_hfint64_r5->proc~gpuavailable proc~updatehost_hfreal_r4 UpdateHost_hfReal_r4 proc~updatehost_hfreal_r4->proc~gpuavailable proc~free_hfint32_r4 Free_hfInt32_r4 proc~free_hfint32_r4->proc~gpuavailable proc~alloc_hfint64_r3 Alloc_hfInt64_r3 proc~alloc_hfint64_r3->proc~gpuavailable proc~alloc_hfint64_r2 Alloc_hfInt64_r2 proc~alloc_hfint64_r2->proc~gpuavailable proc~alloc_hfint32_r4 Alloc_hfInt32_r4 proc~alloc_hfint32_r4->proc~gpuavailable proc~alloc_hfreal_r7 Alloc_hfReal_r7 proc~alloc_hfreal_r7->proc~gpuavailable proc~updatedevice_hfint32_r3 UpdateDevice_hfInt32_r3 proc~updatedevice_hfint32_r3->proc~gpuavailable proc~updatedevice_hfint32_r4 UpdateDevice_hfInt32_r4 proc~updatedevice_hfint32_r4->proc~gpuavailable proc~updatehost_hfint32_r2 UpdateHost_hfInt32_r2 proc~updatehost_hfint32_r2->proc~gpuavailable proc~free_hfreal_r6 Free_hfReal_r6 proc~free_hfreal_r6->proc~gpuavailable proc~updatehost_hfreal_r6 UpdateHost_hfReal_r6 proc~updatehost_hfreal_r6->proc~gpuavailable proc~updatedevice_hfint64_r4 UpdateDevice_hfInt64_r4 proc~updatedevice_hfint64_r4->proc~gpuavailable proc~updatedevice_hfint64_r6 UpdateDevice_hfInt64_r6 proc~updatedevice_hfint64_r6->proc~gpuavailable proc~updatedevice_hfreal_r2 UpdateDevice_hfReal_r2 proc~updatedevice_hfreal_r2->proc~gpuavailable proc~free_hfint64_r1 Free_hfInt64_r1 proc~free_hfint64_r1->proc~gpuavailable proc~updatedevice_hfint32_r2 UpdateDevice_hfInt32_r2 proc~updatedevice_hfint32_r2->proc~gpuavailable proc~updatehost_hfint32_r7 UpdateHost_hfInt32_r7 proc~updatehost_hfint32_r7->proc~gpuavailable proc~updatehost_hfint64_r7 UpdateHost_hfInt64_r7 proc~updatehost_hfint64_r7->proc~gpuavailable proc~updatedevice_hfint32_r7 UpdateDevice_hfInt32_r7 proc~updatedevice_hfint32_r7->proc~gpuavailable proc~updatehost_hfint64_r2 UpdateHost_hfInt64_r2 proc~updatehost_hfint64_r2->proc~gpuavailable proc~free_hfint64_r3 Free_hfInt64_r3 proc~free_hfint64_r3->proc~gpuavailable proc~free_hfint64_r2 Free_hfInt64_r2 proc~free_hfint64_r2->proc~gpuavailable proc~alloc_hfreal_r1 Alloc_hfReal_r1 proc~alloc_hfreal_r1->proc~gpuavailable proc~updatehost_hfint64_r1 UpdateHost_hfInt64_r1 proc~updatehost_hfint64_r1->proc~gpuavailable proc~alloc_hfreal_r6 Alloc_hfReal_r6 proc~alloc_hfreal_r6->proc~gpuavailable proc~updatehost_hfreal_r5 UpdateHost_hfReal_r5 proc~updatehost_hfreal_r5->proc~gpuavailable proc~alloc_hfreal_r4 Alloc_hfReal_r4 proc~alloc_hfreal_r4->proc~gpuavailable proc~updatehost_hfint64_r6 UpdateHost_hfInt64_r6 proc~updatehost_hfint64_r6->proc~gpuavailable proc~alloc_hfint32_r2 Alloc_hfInt32_r2 proc~alloc_hfint32_r2->proc~gpuavailable proc~updatedevice_hfreal_r5 UpdateDevice_hfReal_r5 proc~updatedevice_hfreal_r5->proc~gpuavailable proc~updatedevice_hfint32_r5 UpdateDevice_hfInt32_r5 proc~updatedevice_hfint32_r5->proc~gpuavailable proc~free_hfint64_r4 Free_hfInt64_r4 proc~free_hfint64_r4->proc~gpuavailable proc~alloc_hfint64_r7 Alloc_hfInt64_r7 proc~alloc_hfint64_r7->proc~gpuavailable proc~updatehost_hfint32_r6 UpdateHost_hfInt32_r6 proc~updatehost_hfint32_r6->proc~gpuavailable proc~alloc_hfint32_r6 Alloc_hfInt32_r6 proc~alloc_hfint32_r6->proc~gpuavailable proc~updatehost_hfreal_r7 UpdateHost_hfReal_r7 proc~updatehost_hfreal_r7->proc~gpuavailable proc~updatedevice_hfreal_r7 UpdateDevice_hfReal_r7 proc~updatedevice_hfreal_r7->proc~gpuavailable proc~alloc_hfint64_r4 Alloc_hfInt64_r4 proc~alloc_hfint64_r4->proc~gpuavailable Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code GPUAvailable Source Code FUNCTION GPUAvailable () RESULT ( avail ) IMPLICIT NONE LOGICAL :: avail ! Local INTEGER :: gpuCount INTEGER ( KIND ( hipSuccess )) :: err err = hipGetDeviceCount ( gpuCount ) IF ( gpuCount > 0 . AND . err == hipSuccess ) THEN avail = . TRUE . ELSE avail = . FALSE . END IF END FUNCTION GPUAvailable","tags":"","loc":"proc/gpuavailable.html"},{"title":"Alloc_hfInt32_r1 – SELF","text":"public subroutine Alloc_hfInt32_r1(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound Calls proc~~alloc_hfint32_r1~~CallsGraph proc~alloc_hfint32_r1 Alloc_hfInt32_r1 hipmalloc hipmalloc proc~alloc_hfint32_r1->hipmalloc hipcheck hipcheck proc~alloc_hfint32_r1->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfint32_r1->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt32_r1 Source Code SUBROUTINE Alloc_hfInt32_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r1","tags":"","loc":"proc/alloc_hfint32_r1.html"},{"title":"Alloc_hfInt32_r2 – SELF","text":"public subroutine Alloc_hfInt32_r2(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) Calls proc~~alloc_hfint32_r2~~CallsGraph proc~alloc_hfint32_r2 Alloc_hfInt32_r2 hipmalloc hipmalloc proc~alloc_hfint32_r2->hipmalloc hipcheck hipcheck proc~alloc_hfint32_r2->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfint32_r2->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt32_r2 Source Code SUBROUTINE Alloc_hfInt32_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r2","tags":"","loc":"proc/alloc_hfint32_r2.html"},{"title":"Alloc_hfInt32_r3 – SELF","text":"public subroutine Alloc_hfInt32_r3(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) Calls proc~~alloc_hfint32_r3~~CallsGraph proc~alloc_hfint32_r3 Alloc_hfInt32_r3 hipmalloc hipmalloc proc~alloc_hfint32_r3->hipmalloc hipcheck hipcheck proc~alloc_hfint32_r3->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfint32_r3->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt32_r3 Source Code SUBROUTINE Alloc_hfInt32_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r3","tags":"","loc":"proc/alloc_hfint32_r3.html"},{"title":"Alloc_hfInt32_r4 – SELF","text":"public subroutine Alloc_hfInt32_r4(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) Calls proc~~alloc_hfint32_r4~~CallsGraph proc~alloc_hfint32_r4 Alloc_hfInt32_r4 hipmalloc hipmalloc proc~alloc_hfint32_r4->hipmalloc hipcheck hipcheck proc~alloc_hfint32_r4->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfint32_r4->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt32_r4 Source Code SUBROUTINE Alloc_hfInt32_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r4","tags":"","loc":"proc/alloc_hfint32_r4.html"},{"title":"Alloc_hfInt32_r5 – SELF","text":"public subroutine Alloc_hfInt32_r5(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) Calls proc~~alloc_hfint32_r5~~CallsGraph proc~alloc_hfint32_r5 Alloc_hfInt32_r5 hipmalloc hipmalloc proc~alloc_hfint32_r5->hipmalloc hipcheck hipcheck proc~alloc_hfint32_r5->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfint32_r5->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt32_r5 Source Code SUBROUTINE Alloc_hfInt32_r5 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 5 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 5 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r5","tags":"","loc":"proc/alloc_hfint32_r5.html"},{"title":"Alloc_hfInt32_r6 – SELF","text":"public subroutine Alloc_hfInt32_r6(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) Calls proc~~alloc_hfint32_r6~~CallsGraph proc~alloc_hfint32_r6 Alloc_hfInt32_r6 hipmalloc hipmalloc proc~alloc_hfint32_r6->hipmalloc hipcheck hipcheck proc~alloc_hfint32_r6->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfint32_r6->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt32_r6 Source Code SUBROUTINE Alloc_hfInt32_r6 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 6 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 6 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r6","tags":"","loc":"proc/alloc_hfint32_r6.html"},{"title":"Alloc_hfInt32_r7 – SELF","text":"public subroutine Alloc_hfInt32_r7(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) Calls proc~~alloc_hfint32_r7~~CallsGraph proc~alloc_hfint32_r7 Alloc_hfInt32_r7 hipmalloc hipmalloc proc~alloc_hfint32_r7->hipmalloc hipcheck hipcheck proc~alloc_hfint32_r7->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfint32_r7->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt32_r7 Source Code SUBROUTINE Alloc_hfInt32_r7 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 7 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 7 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ), & loBound ( 7 ): upBound ( 7 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt32_r7","tags":"","loc":"proc/alloc_hfint32_r7.html"},{"title":"Alloc_hfInt64_r1 – SELF","text":"public subroutine Alloc_hfInt64_r1(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound Calls proc~~alloc_hfint64_r1~~CallsGraph proc~alloc_hfint64_r1 Alloc_hfInt64_r1 hipmalloc hipmalloc proc~alloc_hfint64_r1->hipmalloc hipcheck hipcheck proc~alloc_hfint64_r1->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfint64_r1->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt64_r1 Source Code SUBROUTINE Alloc_hfInt64_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt64_r1","tags":"","loc":"proc/alloc_hfint64_r1.html"},{"title":"Alloc_hfInt64_r2 – SELF","text":"public subroutine Alloc_hfInt64_r2(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) Calls proc~~alloc_hfint64_r2~~CallsGraph proc~alloc_hfint64_r2 Alloc_hfInt64_r2 hipmalloc hipmalloc proc~alloc_hfint64_r2->hipmalloc hipcheck hipcheck proc~alloc_hfint64_r2->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfint64_r2->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt64_r2 Source Code SUBROUTINE Alloc_hfInt64_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt64_r2","tags":"","loc":"proc/alloc_hfint64_r2.html"},{"title":"Alloc_hfInt64_r3 – SELF","text":"public subroutine Alloc_hfInt64_r3(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) Calls proc~~alloc_hfint64_r3~~CallsGraph proc~alloc_hfint64_r3 Alloc_hfInt64_r3 hipmalloc hipmalloc proc~alloc_hfint64_r3->hipmalloc hipcheck hipcheck proc~alloc_hfint64_r3->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfint64_r3->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt64_r3 Source Code SUBROUTINE Alloc_hfInt64_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt64_r3","tags":"","loc":"proc/alloc_hfint64_r3.html"},{"title":"Alloc_hfInt64_r4 – SELF","text":"public subroutine Alloc_hfInt64_r4(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) Calls proc~~alloc_hfint64_r4~~CallsGraph proc~alloc_hfint64_r4 Alloc_hfInt64_r4 hipmalloc hipmalloc proc~alloc_hfint64_r4->hipmalloc hipcheck hipcheck proc~alloc_hfint64_r4->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfint64_r4->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt64_r4 Source Code SUBROUTINE Alloc_hfInt64_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt64_r4","tags":"","loc":"proc/alloc_hfint64_r4.html"},{"title":"Alloc_hfInt64_r5 – SELF","text":"public subroutine Alloc_hfInt64_r5(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) Calls proc~~alloc_hfint64_r5~~CallsGraph proc~alloc_hfint64_r5 Alloc_hfInt64_r5 hipmalloc hipmalloc proc~alloc_hfint64_r5->hipmalloc hipcheck hipcheck proc~alloc_hfint64_r5->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfint64_r5->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt64_r5 Source Code SUBROUTINE Alloc_hfInt64_r5 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 5 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 5 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt64_r5","tags":"","loc":"proc/alloc_hfint64_r5.html"},{"title":"Alloc_hfInt64_r6 – SELF","text":"public subroutine Alloc_hfInt64_r6(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) Calls proc~~alloc_hfint64_r6~~CallsGraph proc~alloc_hfint64_r6 Alloc_hfInt64_r6 hipmalloc hipmalloc proc~alloc_hfint64_r6->hipmalloc hipcheck hipcheck proc~alloc_hfint64_r6->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfint64_r6->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt64_r6 Source Code SUBROUTINE Alloc_hfInt64_r6 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 6 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 6 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt64_r6","tags":"","loc":"proc/alloc_hfint64_r6.html"},{"title":"Alloc_hfInt64_r7 – SELF","text":"public subroutine Alloc_hfInt64_r7(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) Calls proc~~alloc_hfint64_r7~~CallsGraph proc~alloc_hfint64_r7 Alloc_hfInt64_r7 hipmalloc hipmalloc proc~alloc_hfint64_r7->hipmalloc hipcheck hipcheck proc~alloc_hfint64_r7->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfint64_r7->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt64_r7 Source Code SUBROUTINE Alloc_hfInt64_r7 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 7 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 7 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ), & loBound ( 7 ): upBound ( 7 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfInt64_r7","tags":"","loc":"proc/alloc_hfint64_r7.html"},{"title":"Alloc_hfReal_r1 – SELF","text":"public subroutine Alloc_hfReal_r1(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound Calls proc~~alloc_hfreal_r1~~CallsGraph proc~alloc_hfreal_r1 Alloc_hfReal_r1 hipmalloc hipmalloc proc~alloc_hfreal_r1->hipmalloc hipcheck hipcheck proc~alloc_hfreal_r1->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfreal_r1->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfReal_r1 Source Code SUBROUTINE Alloc_hfReal_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r1","tags":"","loc":"proc/alloc_hfreal_r1.html"},{"title":"Alloc_hfReal_r2 – SELF","text":"public subroutine Alloc_hfReal_r2(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) Calls proc~~alloc_hfreal_r2~~CallsGraph proc~alloc_hfreal_r2 Alloc_hfReal_r2 hipmalloc hipmalloc proc~alloc_hfreal_r2->hipmalloc hipcheck hipcheck proc~alloc_hfreal_r2->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfreal_r2->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfReal_r2 Source Code SUBROUTINE Alloc_hfReal_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r2","tags":"","loc":"proc/alloc_hfreal_r2.html"},{"title":"Alloc_hfReal_r3 – SELF","text":"public subroutine Alloc_hfReal_r3(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) Calls proc~~alloc_hfreal_r3~~CallsGraph proc~alloc_hfreal_r3 Alloc_hfReal_r3 hipmalloc hipmalloc proc~alloc_hfreal_r3->hipmalloc hipcheck hipcheck proc~alloc_hfreal_r3->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfreal_r3->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfReal_r3 Source Code SUBROUTINE Alloc_hfReal_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r3","tags":"","loc":"proc/alloc_hfreal_r3.html"},{"title":"Alloc_hfReal_r4 – SELF","text":"public subroutine Alloc_hfReal_r4(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) Calls proc~~alloc_hfreal_r4~~CallsGraph proc~alloc_hfreal_r4 Alloc_hfReal_r4 hipmalloc hipmalloc proc~alloc_hfreal_r4->hipmalloc hipcheck hipcheck proc~alloc_hfreal_r4->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfreal_r4->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfReal_r4 Source Code SUBROUTINE Alloc_hfReal_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r4","tags":"","loc":"proc/alloc_hfreal_r4.html"},{"title":"Alloc_hfReal_r5 – SELF","text":"public subroutine Alloc_hfReal_r5(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) Calls proc~~alloc_hfreal_r5~~CallsGraph proc~alloc_hfreal_r5 Alloc_hfReal_r5 hipmalloc hipmalloc proc~alloc_hfreal_r5->hipmalloc hipcheck hipcheck proc~alloc_hfreal_r5->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfreal_r5->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfReal_r5 Source Code SUBROUTINE Alloc_hfReal_r5 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 5 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 5 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r5","tags":"","loc":"proc/alloc_hfreal_r5.html"},{"title":"Alloc_hfReal_r6 – SELF","text":"public subroutine Alloc_hfReal_r6(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) Calls proc~~alloc_hfreal_r6~~CallsGraph proc~alloc_hfreal_r6 Alloc_hfReal_r6 hipmalloc hipmalloc proc~alloc_hfreal_r6->hipmalloc hipcheck hipcheck proc~alloc_hfreal_r6->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfreal_r6->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfReal_r6 Source Code SUBROUTINE Alloc_hfReal_r6 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 6 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 6 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r6","tags":"","loc":"proc/alloc_hfreal_r6.html"},{"title":"Alloc_hfReal_r7 – SELF","text":"public subroutine Alloc_hfReal_r7(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) Calls proc~~alloc_hfreal_r7~~CallsGraph proc~alloc_hfreal_r7 Alloc_hfReal_r7 hipmalloc hipmalloc proc~alloc_hfreal_r7->hipmalloc hipcheck hipcheck proc~alloc_hfreal_r7->hipcheck proc~gpuavailable GPUAvailable proc~alloc_hfreal_r7->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfReal_r7 Source Code SUBROUTINE Alloc_hfReal_r7 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 7 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 7 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ), & loBound ( 7 ): upBound ( 7 ))) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) END IF END SUBROUTINE Alloc_hfReal_r7","tags":"","loc":"proc/alloc_hfreal_r7.html"},{"title":"Free_hfInt32_r1 – SELF","text":"public subroutine Free_hfInt32_r1(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this Calls proc~~free_hfint32_r1~~CallsGraph proc~free_hfint32_r1 Free_hfInt32_r1 hipfree hipfree proc~free_hfint32_r1->hipfree hipcheck hipcheck proc~free_hfint32_r1->hipcheck proc~gpuavailable GPUAvailable proc~free_hfint32_r1->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt32_r1 Source Code SUBROUTINE Free_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r1","tags":"","loc":"proc/free_hfint32_r1.html"},{"title":"Free_hfInt32_r2 – SELF","text":"public subroutine Free_hfInt32_r2(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this Calls proc~~free_hfint32_r2~~CallsGraph proc~free_hfint32_r2 Free_hfInt32_r2 hipfree hipfree proc~free_hfint32_r2->hipfree hipcheck hipcheck proc~free_hfint32_r2->hipcheck proc~gpuavailable GPUAvailable proc~free_hfint32_r2->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt32_r2 Source Code SUBROUTINE Free_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r2","tags":"","loc":"proc/free_hfint32_r2.html"},{"title":"Free_hfInt32_r3 – SELF","text":"public subroutine Free_hfInt32_r3(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this Calls proc~~free_hfint32_r3~~CallsGraph proc~free_hfint32_r3 Free_hfInt32_r3 hipfree hipfree proc~free_hfint32_r3->hipfree hipcheck hipcheck proc~free_hfint32_r3->hipcheck proc~gpuavailable GPUAvailable proc~free_hfint32_r3->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt32_r3 Source Code SUBROUTINE Free_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r3","tags":"","loc":"proc/free_hfint32_r3.html"},{"title":"Free_hfInt32_r4 – SELF","text":"public subroutine Free_hfInt32_r4(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this Calls proc~~free_hfint32_r4~~CallsGraph proc~free_hfint32_r4 Free_hfInt32_r4 hipfree hipfree proc~free_hfint32_r4->hipfree hipcheck hipcheck proc~free_hfint32_r4->hipcheck proc~gpuavailable GPUAvailable proc~free_hfint32_r4->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt32_r4 Source Code SUBROUTINE Free_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r4","tags":"","loc":"proc/free_hfint32_r4.html"},{"title":"Free_hfInt32_r5 – SELF","text":"public subroutine Free_hfInt32_r5(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this Calls proc~~free_hfint32_r5~~CallsGraph proc~free_hfint32_r5 Free_hfInt32_r5 hipfree hipfree proc~free_hfint32_r5->hipfree hipcheck hipcheck proc~free_hfint32_r5->hipcheck proc~gpuavailable GPUAvailable proc~free_hfint32_r5->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt32_r5 Source Code SUBROUTINE Free_hfInt32_r5 ( this ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r5","tags":"","loc":"proc/free_hfint32_r5.html"},{"title":"Free_hfInt32_r6 – SELF","text":"public subroutine Free_hfInt32_r6(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this Calls proc~~free_hfint32_r6~~CallsGraph proc~free_hfint32_r6 Free_hfInt32_r6 hipfree hipfree proc~free_hfint32_r6->hipfree hipcheck hipcheck proc~free_hfint32_r6->hipcheck proc~gpuavailable GPUAvailable proc~free_hfint32_r6->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt32_r6 Source Code SUBROUTINE Free_hfInt32_r6 ( this ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r6","tags":"","loc":"proc/free_hfint32_r6.html"},{"title":"Free_hfInt32_r7 – SELF","text":"public subroutine Free_hfInt32_r7(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this Calls proc~~free_hfint32_r7~~CallsGraph proc~free_hfint32_r7 Free_hfInt32_r7 hipfree hipfree proc~free_hfint32_r7->hipfree hipcheck hipcheck proc~free_hfint32_r7->hipcheck proc~gpuavailable GPUAvailable proc~free_hfint32_r7->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt32_r7 Source Code SUBROUTINE Free_hfInt32_r7 ( this ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt32_r7","tags":"","loc":"proc/free_hfint32_r7.html"},{"title":"Free_hfInt64_r1 – SELF","text":"public subroutine Free_hfInt64_r1(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this Calls proc~~free_hfint64_r1~~CallsGraph proc~free_hfint64_r1 Free_hfInt64_r1 hipfree hipfree proc~free_hfint64_r1->hipfree hipcheck hipcheck proc~free_hfint64_r1->hipcheck proc~gpuavailable GPUAvailable proc~free_hfint64_r1->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt64_r1 Source Code SUBROUTINE Free_hfInt64_r1 ( this ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt64_r1","tags":"","loc":"proc/free_hfint64_r1.html"},{"title":"Free_hfInt64_r2 – SELF","text":"public subroutine Free_hfInt64_r2(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this Calls proc~~free_hfint64_r2~~CallsGraph proc~free_hfint64_r2 Free_hfInt64_r2 hipfree hipfree proc~free_hfint64_r2->hipfree hipcheck hipcheck proc~free_hfint64_r2->hipcheck proc~gpuavailable GPUAvailable proc~free_hfint64_r2->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt64_r2 Source Code SUBROUTINE Free_hfInt64_r2 ( this ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt64_r2","tags":"","loc":"proc/free_hfint64_r2.html"},{"title":"Free_hfInt64_r3 – SELF","text":"public subroutine Free_hfInt64_r3(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this Calls proc~~free_hfint64_r3~~CallsGraph proc~free_hfint64_r3 Free_hfInt64_r3 hipfree hipfree proc~free_hfint64_r3->hipfree hipcheck hipcheck proc~free_hfint64_r3->hipcheck proc~gpuavailable GPUAvailable proc~free_hfint64_r3->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt64_r3 Source Code SUBROUTINE Free_hfInt64_r3 ( this ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt64_r3","tags":"","loc":"proc/free_hfint64_r3.html"},{"title":"Free_hfInt64_r4 – SELF","text":"public subroutine Free_hfInt64_r4(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this Calls proc~~free_hfint64_r4~~CallsGraph proc~free_hfint64_r4 Free_hfInt64_r4 hipfree hipfree proc~free_hfint64_r4->hipfree hipcheck hipcheck proc~free_hfint64_r4->hipcheck proc~gpuavailable GPUAvailable proc~free_hfint64_r4->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt64_r4 Source Code SUBROUTINE Free_hfInt64_r4 ( this ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt64_r4","tags":"","loc":"proc/free_hfint64_r4.html"},{"title":"Free_hfInt64_r5 – SELF","text":"public subroutine Free_hfInt64_r5(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this Calls proc~~free_hfint64_r5~~CallsGraph proc~free_hfint64_r5 Free_hfInt64_r5 hipfree hipfree proc~free_hfint64_r5->hipfree hipcheck hipcheck proc~free_hfint64_r5->hipcheck proc~gpuavailable GPUAvailable proc~free_hfint64_r5->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt64_r5 Source Code SUBROUTINE Free_hfInt64_r5 ( this ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt64_r5","tags":"","loc":"proc/free_hfint64_r5.html"},{"title":"Free_hfInt64_r6 – SELF","text":"public subroutine Free_hfInt64_r6(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this Calls proc~~free_hfint64_r6~~CallsGraph proc~free_hfint64_r6 Free_hfInt64_r6 hipfree hipfree proc~free_hfint64_r6->hipfree hipcheck hipcheck proc~free_hfint64_r6->hipcheck proc~gpuavailable GPUAvailable proc~free_hfint64_r6->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt64_r6 Source Code SUBROUTINE Free_hfInt64_r6 ( this ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt64_r6","tags":"","loc":"proc/free_hfint64_r6.html"},{"title":"Free_hfInt64_r7 – SELF","text":"public subroutine Free_hfInt64_r7(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this Calls proc~~free_hfint64_r7~~CallsGraph proc~free_hfint64_r7 Free_hfInt64_r7 hipfree hipfree proc~free_hfint64_r7->hipfree hipcheck hipcheck proc~free_hfint64_r7->hipcheck proc~gpuavailable GPUAvailable proc~free_hfint64_r7->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt64_r7 Source Code SUBROUTINE Free_hfInt64_r7 ( this ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfInt64_r7","tags":"","loc":"proc/free_hfint64_r7.html"},{"title":"Free_hfReal_r1 – SELF","text":"public subroutine Free_hfReal_r1(this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this Calls proc~~free_hfreal_r1~~CallsGraph proc~free_hfreal_r1 Free_hfReal_r1 hipfree hipfree proc~free_hfreal_r1->hipfree hipcheck hipcheck proc~free_hfreal_r1->hipcheck proc~gpuavailable GPUAvailable proc~free_hfreal_r1->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfReal_r1 Source Code SUBROUTINE Free_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r1","tags":"","loc":"proc/free_hfreal_r1.html"},{"title":"Free_hfReal_r2 – SELF","text":"public subroutine Free_hfReal_r2(this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this Calls proc~~free_hfreal_r2~~CallsGraph proc~free_hfreal_r2 Free_hfReal_r2 hipfree hipfree proc~free_hfreal_r2->hipfree hipcheck hipcheck proc~free_hfreal_r2->hipcheck proc~gpuavailable GPUAvailable proc~free_hfreal_r2->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfReal_r2 Source Code SUBROUTINE Free_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r2","tags":"","loc":"proc/free_hfreal_r2.html"},{"title":"Free_hfReal_r3 – SELF","text":"public subroutine Free_hfReal_r3(this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this Calls proc~~free_hfreal_r3~~CallsGraph proc~free_hfreal_r3 Free_hfReal_r3 hipfree hipfree proc~free_hfreal_r3->hipfree hipcheck hipcheck proc~free_hfreal_r3->hipcheck proc~gpuavailable GPUAvailable proc~free_hfreal_r3->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfReal_r3 Source Code SUBROUTINE Free_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r3","tags":"","loc":"proc/free_hfreal_r3.html"},{"title":"Free_hfReal_r4 – SELF","text":"public subroutine Free_hfReal_r4(this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this Calls proc~~free_hfreal_r4~~CallsGraph proc~free_hfreal_r4 Free_hfReal_r4 hipfree hipfree proc~free_hfreal_r4->hipfree hipcheck hipcheck proc~free_hfreal_r4->hipcheck proc~gpuavailable GPUAvailable proc~free_hfreal_r4->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfReal_r4 Source Code SUBROUTINE Free_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r4","tags":"","loc":"proc/free_hfreal_r4.html"},{"title":"Free_hfReal_r5 – SELF","text":"public subroutine Free_hfReal_r5(this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this Calls proc~~free_hfreal_r5~~CallsGraph proc~free_hfreal_r5 Free_hfReal_r5 hipfree hipfree proc~free_hfreal_r5->hipfree hipcheck hipcheck proc~free_hfreal_r5->hipcheck proc~gpuavailable GPUAvailable proc~free_hfreal_r5->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfReal_r5 Source Code SUBROUTINE Free_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r5","tags":"","loc":"proc/free_hfreal_r5.html"},{"title":"Free_hfReal_r6 – SELF","text":"public subroutine Free_hfReal_r6(this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this Calls proc~~free_hfreal_r6~~CallsGraph proc~free_hfreal_r6 Free_hfReal_r6 hipfree hipfree proc~free_hfreal_r6->hipfree hipcheck hipcheck proc~free_hfreal_r6->hipcheck proc~gpuavailable GPUAvailable proc~free_hfreal_r6->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfReal_r6 Source Code SUBROUTINE Free_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r6","tags":"","loc":"proc/free_hfreal_r6.html"},{"title":"Free_hfReal_r7 – SELF","text":"public subroutine Free_hfReal_r7(this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this Calls proc~~free_hfreal_r7~~CallsGraph proc~free_hfreal_r7 Free_hfReal_r7 hipfree hipfree proc~free_hfreal_r7->hipfree hipcheck hipcheck proc~free_hfreal_r7->hipcheck proc~gpuavailable GPUAvailable proc~free_hfreal_r7->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfReal_r7 Source Code SUBROUTINE Free_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) IF ( GPUAvailable ()) THEN CALL hipCheck ( hipFree ( this % deviceData )) END IF END SUBROUTINE Free_hfReal_r7","tags":"","loc":"proc/free_hfreal_r7.html"},{"title":"UpdateDevice_hfInt32_r1 – SELF","text":"public subroutine UpdateDevice_hfInt32_r1(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this Calls proc~~updatedevice_hfint32_r1~~CallsGraph proc~updatedevice_hfint32_r1 UpdateDevice_hfInt32_r1 hipmemcpy hipmemcpy proc~updatedevice_hfint32_r1->hipmemcpy hipcheck hipcheck proc~updatedevice_hfint32_r1->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfint32_r1->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt32_r1 Source Code SUBROUTINE UpdateDevice_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r1","tags":"","loc":"proc/updatedevice_hfint32_r1.html"},{"title":"UpdateDevice_hfInt32_r2 – SELF","text":"public subroutine UpdateDevice_hfInt32_r2(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this Calls proc~~updatedevice_hfint32_r2~~CallsGraph proc~updatedevice_hfint32_r2 UpdateDevice_hfInt32_r2 hipmemcpy hipmemcpy proc~updatedevice_hfint32_r2->hipmemcpy hipcheck hipcheck proc~updatedevice_hfint32_r2->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfint32_r2->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt32_r2 Source Code SUBROUTINE UpdateDevice_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r2","tags":"","loc":"proc/updatedevice_hfint32_r2.html"},{"title":"UpdateDevice_hfInt32_r3 – SELF","text":"public subroutine UpdateDevice_hfInt32_r3(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this Calls proc~~updatedevice_hfint32_r3~~CallsGraph proc~updatedevice_hfint32_r3 UpdateDevice_hfInt32_r3 hipmemcpy hipmemcpy proc~updatedevice_hfint32_r3->hipmemcpy hipcheck hipcheck proc~updatedevice_hfint32_r3->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfint32_r3->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt32_r3 Source Code SUBROUTINE UpdateDevice_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r3","tags":"","loc":"proc/updatedevice_hfint32_r3.html"},{"title":"UpdateDevice_hfInt32_r4 – SELF","text":"public subroutine UpdateDevice_hfInt32_r4(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this Calls proc~~updatedevice_hfint32_r4~~CallsGraph proc~updatedevice_hfint32_r4 UpdateDevice_hfInt32_r4 hipmemcpy hipmemcpy proc~updatedevice_hfint32_r4->hipmemcpy hipcheck hipcheck proc~updatedevice_hfint32_r4->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfint32_r4->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt32_r4 Source Code SUBROUTINE UpdateDevice_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r4","tags":"","loc":"proc/updatedevice_hfint32_r4.html"},{"title":"UpdateDevice_hfInt32_r5 – SELF","text":"public subroutine UpdateDevice_hfInt32_r5(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this Calls proc~~updatedevice_hfint32_r5~~CallsGraph proc~updatedevice_hfint32_r5 UpdateDevice_hfInt32_r5 hipmemcpy hipmemcpy proc~updatedevice_hfint32_r5->hipmemcpy hipcheck hipcheck proc~updatedevice_hfint32_r5->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfint32_r5->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt32_r5 Source Code SUBROUTINE UpdateDevice_hfInt32_r5 ( this ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r5","tags":"","loc":"proc/updatedevice_hfint32_r5.html"},{"title":"UpdateDevice_hfInt32_r6 – SELF","text":"public subroutine UpdateDevice_hfInt32_r6(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this Calls proc~~updatedevice_hfint32_r6~~CallsGraph proc~updatedevice_hfint32_r6 UpdateDevice_hfInt32_r6 hipmemcpy hipmemcpy proc~updatedevice_hfint32_r6->hipmemcpy hipcheck hipcheck proc~updatedevice_hfint32_r6->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfint32_r6->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt32_r6 Source Code SUBROUTINE UpdateDevice_hfInt32_r6 ( this ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r6","tags":"","loc":"proc/updatedevice_hfint32_r6.html"},{"title":"UpdateDevice_hfInt32_r7 – SELF","text":"public subroutine UpdateDevice_hfInt32_r7(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this Calls proc~~updatedevice_hfint32_r7~~CallsGraph proc~updatedevice_hfint32_r7 UpdateDevice_hfInt32_r7 hipmemcpy hipmemcpy proc~updatedevice_hfint32_r7->hipmemcpy hipcheck hipcheck proc~updatedevice_hfint32_r7->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfint32_r7->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt32_r7 Source Code SUBROUTINE UpdateDevice_hfInt32_r7 ( this ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt32_r7","tags":"","loc":"proc/updatedevice_hfint32_r7.html"},{"title":"UpdateDevice_hfInt64_r1 – SELF","text":"public subroutine UpdateDevice_hfInt64_r1(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this Calls proc~~updatedevice_hfint64_r1~~CallsGraph proc~updatedevice_hfint64_r1 UpdateDevice_hfInt64_r1 hipmemcpy hipmemcpy proc~updatedevice_hfint64_r1->hipmemcpy hipcheck hipcheck proc~updatedevice_hfint64_r1->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfint64_r1->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt64_r1 Source Code SUBROUTINE UpdateDevice_hfInt64_r1 ( this ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt64_r1","tags":"","loc":"proc/updatedevice_hfint64_r1.html"},{"title":"UpdateDevice_hfInt64_r2 – SELF","text":"public subroutine UpdateDevice_hfInt64_r2(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this Calls proc~~updatedevice_hfint64_r2~~CallsGraph proc~updatedevice_hfint64_r2 UpdateDevice_hfInt64_r2 hipmemcpy hipmemcpy proc~updatedevice_hfint64_r2->hipmemcpy hipcheck hipcheck proc~updatedevice_hfint64_r2->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfint64_r2->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt64_r2 Source Code SUBROUTINE UpdateDevice_hfInt64_r2 ( this ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt64_r2","tags":"","loc":"proc/updatedevice_hfint64_r2.html"},{"title":"UpdateDevice_hfInt64_r3 – SELF","text":"public subroutine UpdateDevice_hfInt64_r3(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this Calls proc~~updatedevice_hfint64_r3~~CallsGraph proc~updatedevice_hfint64_r3 UpdateDevice_hfInt64_r3 hipmemcpy hipmemcpy proc~updatedevice_hfint64_r3->hipmemcpy hipcheck hipcheck proc~updatedevice_hfint64_r3->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfint64_r3->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt64_r3 Source Code SUBROUTINE UpdateDevice_hfInt64_r3 ( this ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt64_r3","tags":"","loc":"proc/updatedevice_hfint64_r3.html"},{"title":"UpdateDevice_hfInt64_r4 – SELF","text":"public subroutine UpdateDevice_hfInt64_r4(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this Calls proc~~updatedevice_hfint64_r4~~CallsGraph proc~updatedevice_hfint64_r4 UpdateDevice_hfInt64_r4 hipmemcpy hipmemcpy proc~updatedevice_hfint64_r4->hipmemcpy hipcheck hipcheck proc~updatedevice_hfint64_r4->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfint64_r4->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt64_r4 Source Code SUBROUTINE UpdateDevice_hfInt64_r4 ( this ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt64_r4","tags":"","loc":"proc/updatedevice_hfint64_r4.html"},{"title":"UpdateDevice_hfInt64_r5 – SELF","text":"public subroutine UpdateDevice_hfInt64_r5(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this Calls proc~~updatedevice_hfint64_r5~~CallsGraph proc~updatedevice_hfint64_r5 UpdateDevice_hfInt64_r5 hipmemcpy hipmemcpy proc~updatedevice_hfint64_r5->hipmemcpy hipcheck hipcheck proc~updatedevice_hfint64_r5->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfint64_r5->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt64_r5 Source Code SUBROUTINE UpdateDevice_hfInt64_r5 ( this ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt64_r5","tags":"","loc":"proc/updatedevice_hfint64_r5.html"},{"title":"UpdateDevice_hfInt64_r6 – SELF","text":"public subroutine UpdateDevice_hfInt64_r6(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this Calls proc~~updatedevice_hfint64_r6~~CallsGraph proc~updatedevice_hfint64_r6 UpdateDevice_hfInt64_r6 hipmemcpy hipmemcpy proc~updatedevice_hfint64_r6->hipmemcpy hipcheck hipcheck proc~updatedevice_hfint64_r6->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfint64_r6->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt64_r6 Source Code SUBROUTINE UpdateDevice_hfInt64_r6 ( this ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt64_r6","tags":"","loc":"proc/updatedevice_hfint64_r6.html"},{"title":"UpdateDevice_hfInt64_r7 – SELF","text":"public subroutine UpdateDevice_hfInt64_r7(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this Calls proc~~updatedevice_hfint64_r7~~CallsGraph proc~updatedevice_hfint64_r7 UpdateDevice_hfInt64_r7 hipmemcpy hipmemcpy proc~updatedevice_hfint64_r7->hipmemcpy hipcheck hipcheck proc~updatedevice_hfint64_r7->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfint64_r7->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt64_r7 Source Code SUBROUTINE UpdateDevice_hfInt64_r7 ( this ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfInt64_r7","tags":"","loc":"proc/updatedevice_hfint64_r7.html"},{"title":"UpdateDevice_hfReal_r1 – SELF","text":"public subroutine UpdateDevice_hfReal_r1(this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this Calls proc~~updatedevice_hfreal_r1~~CallsGraph proc~updatedevice_hfreal_r1 UpdateDevice_hfReal_r1 hipmemcpy hipmemcpy proc~updatedevice_hfreal_r1->hipmemcpy hipcheck hipcheck proc~updatedevice_hfreal_r1->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfreal_r1->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfReal_r1 Source Code SUBROUTINE UpdateDevice_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r1","tags":"","loc":"proc/updatedevice_hfreal_r1.html"},{"title":"UpdateDevice_hfReal_r2 – SELF","text":"public subroutine UpdateDevice_hfReal_r2(this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this Calls proc~~updatedevice_hfreal_r2~~CallsGraph proc~updatedevice_hfreal_r2 UpdateDevice_hfReal_r2 hipmemcpy hipmemcpy proc~updatedevice_hfreal_r2->hipmemcpy hipcheck hipcheck proc~updatedevice_hfreal_r2->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfreal_r2->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfReal_r2 Source Code SUBROUTINE UpdateDevice_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r2","tags":"","loc":"proc/updatedevice_hfreal_r2.html"},{"title":"UpdateDevice_hfReal_r3 – SELF","text":"public subroutine UpdateDevice_hfReal_r3(this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this Calls proc~~updatedevice_hfreal_r3~~CallsGraph proc~updatedevice_hfreal_r3 UpdateDevice_hfReal_r3 hipmemcpy hipmemcpy proc~updatedevice_hfreal_r3->hipmemcpy hipcheck hipcheck proc~updatedevice_hfreal_r3->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfreal_r3->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfReal_r3 Source Code SUBROUTINE UpdateDevice_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r3","tags":"","loc":"proc/updatedevice_hfreal_r3.html"},{"title":"UpdateDevice_hfReal_r4 – SELF","text":"public subroutine UpdateDevice_hfReal_r4(this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this Calls proc~~updatedevice_hfreal_r4~~CallsGraph proc~updatedevice_hfreal_r4 UpdateDevice_hfReal_r4 hipmemcpy hipmemcpy proc~updatedevice_hfreal_r4->hipmemcpy hipcheck hipcheck proc~updatedevice_hfreal_r4->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfreal_r4->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfReal_r4 Source Code SUBROUTINE UpdateDevice_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r4","tags":"","loc":"proc/updatedevice_hfreal_r4.html"},{"title":"UpdateDevice_hfReal_r5 – SELF","text":"public subroutine UpdateDevice_hfReal_r5(this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this Calls proc~~updatedevice_hfreal_r5~~CallsGraph proc~updatedevice_hfreal_r5 UpdateDevice_hfReal_r5 hipmemcpy hipmemcpy proc~updatedevice_hfreal_r5->hipmemcpy hipcheck hipcheck proc~updatedevice_hfreal_r5->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfreal_r5->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfReal_r5 Source Code SUBROUTINE UpdateDevice_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r5","tags":"","loc":"proc/updatedevice_hfreal_r5.html"},{"title":"UpdateDevice_hfReal_r6 – SELF","text":"public subroutine UpdateDevice_hfReal_r6(this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this Calls proc~~updatedevice_hfreal_r6~~CallsGraph proc~updatedevice_hfreal_r6 UpdateDevice_hfReal_r6 hipmemcpy hipmemcpy proc~updatedevice_hfreal_r6->hipmemcpy hipcheck hipcheck proc~updatedevice_hfreal_r6->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfreal_r6->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfReal_r6 Source Code SUBROUTINE UpdateDevice_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r6","tags":"","loc":"proc/updatedevice_hfreal_r6.html"},{"title":"UpdateDevice_hfReal_r7 – SELF","text":"public subroutine UpdateDevice_hfReal_r7(this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this Calls proc~~updatedevice_hfreal_r7~~CallsGraph proc~updatedevice_hfreal_r7 UpdateDevice_hfReal_r7 hipmemcpy hipmemcpy proc~updatedevice_hfreal_r7->hipmemcpy hipcheck hipcheck proc~updatedevice_hfreal_r7->hipcheck proc~gpuavailable GPUAvailable proc~updatedevice_hfreal_r7->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfReal_r7 Source Code SUBROUTINE UpdateDevice_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) END IF END SUBROUTINE UpdateDevice_hfReal_r7","tags":"","loc":"proc/updatedevice_hfreal_r7.html"},{"title":"UpdateHost_hfInt32_r1 – SELF","text":"public subroutine UpdateHost_hfInt32_r1(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this Calls proc~~updatehost_hfint32_r1~~CallsGraph proc~updatehost_hfint32_r1 UpdateHost_hfInt32_r1 hipmemcpy hipmemcpy proc~updatehost_hfint32_r1->hipmemcpy hipcheck hipcheck proc~updatehost_hfint32_r1->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfint32_r1->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt32_r1 Source Code SUBROUTINE UpdateHost_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r1","tags":"","loc":"proc/updatehost_hfint32_r1.html"},{"title":"UpdateHost_hfInt32_r2 – SELF","text":"public subroutine UpdateHost_hfInt32_r2(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this Calls proc~~updatehost_hfint32_r2~~CallsGraph proc~updatehost_hfint32_r2 UpdateHost_hfInt32_r2 hipmemcpy hipmemcpy proc~updatehost_hfint32_r2->hipmemcpy hipcheck hipcheck proc~updatehost_hfint32_r2->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfint32_r2->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt32_r2 Source Code SUBROUTINE UpdateHost_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r2","tags":"","loc":"proc/updatehost_hfint32_r2.html"},{"title":"UpdateHost_hfInt32_r3 – SELF","text":"public subroutine UpdateHost_hfInt32_r3(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this Calls proc~~updatehost_hfint32_r3~~CallsGraph proc~updatehost_hfint32_r3 UpdateHost_hfInt32_r3 hipmemcpy hipmemcpy proc~updatehost_hfint32_r3->hipmemcpy hipcheck hipcheck proc~updatehost_hfint32_r3->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfint32_r3->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt32_r3 Source Code SUBROUTINE UpdateHost_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r3","tags":"","loc":"proc/updatehost_hfint32_r3.html"},{"title":"UpdateHost_hfInt32_r4 – SELF","text":"public subroutine UpdateHost_hfInt32_r4(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this Calls proc~~updatehost_hfint32_r4~~CallsGraph proc~updatehost_hfint32_r4 UpdateHost_hfInt32_r4 hipmemcpy hipmemcpy proc~updatehost_hfint32_r4->hipmemcpy hipcheck hipcheck proc~updatehost_hfint32_r4->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfint32_r4->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt32_r4 Source Code SUBROUTINE UpdateHost_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r4","tags":"","loc":"proc/updatehost_hfint32_r4.html"},{"title":"UpdateHost_hfInt32_r5 – SELF","text":"public subroutine UpdateHost_hfInt32_r5(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this Calls proc~~updatehost_hfint32_r5~~CallsGraph proc~updatehost_hfint32_r5 UpdateHost_hfInt32_r5 hipmemcpy hipmemcpy proc~updatehost_hfint32_r5->hipmemcpy hipcheck hipcheck proc~updatehost_hfint32_r5->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfint32_r5->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt32_r5 Source Code SUBROUTINE UpdateHost_hfInt32_r5 ( this ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r5","tags":"","loc":"proc/updatehost_hfint32_r5.html"},{"title":"UpdateHost_hfInt32_r6 – SELF","text":"public subroutine UpdateHost_hfInt32_r6(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this Calls proc~~updatehost_hfint32_r6~~CallsGraph proc~updatehost_hfint32_r6 UpdateHost_hfInt32_r6 hipmemcpy hipmemcpy proc~updatehost_hfint32_r6->hipmemcpy hipcheck hipcheck proc~updatehost_hfint32_r6->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfint32_r6->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt32_r6 Source Code SUBROUTINE UpdateHost_hfInt32_r6 ( this ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r6","tags":"","loc":"proc/updatehost_hfint32_r6.html"},{"title":"UpdateHost_hfInt32_r7 – SELF","text":"public subroutine UpdateHost_hfInt32_r7(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this Calls proc~~updatehost_hfint32_r7~~CallsGraph proc~updatehost_hfint32_r7 UpdateHost_hfInt32_r7 hipmemcpy hipmemcpy proc~updatehost_hfint32_r7->hipmemcpy hipcheck hipcheck proc~updatehost_hfint32_r7->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfint32_r7->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt32_r7 Source Code SUBROUTINE UpdateHost_hfInt32_r7 ( this ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt32_r7","tags":"","loc":"proc/updatehost_hfint32_r7.html"},{"title":"UpdateHost_hfInt64_r1 – SELF","text":"public subroutine UpdateHost_hfInt64_r1(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this Calls proc~~updatehost_hfint64_r1~~CallsGraph proc~updatehost_hfint64_r1 UpdateHost_hfInt64_r1 hipmemcpy hipmemcpy proc~updatehost_hfint64_r1->hipmemcpy hipcheck hipcheck proc~updatehost_hfint64_r1->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfint64_r1->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt64_r1 Source Code SUBROUTINE UpdateHost_hfInt64_r1 ( this ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt64_r1","tags":"","loc":"proc/updatehost_hfint64_r1.html"},{"title":"UpdateHost_hfInt64_r2 – SELF","text":"public subroutine UpdateHost_hfInt64_r2(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this Calls proc~~updatehost_hfint64_r2~~CallsGraph proc~updatehost_hfint64_r2 UpdateHost_hfInt64_r2 hipmemcpy hipmemcpy proc~updatehost_hfint64_r2->hipmemcpy hipcheck hipcheck proc~updatehost_hfint64_r2->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfint64_r2->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt64_r2 Source Code SUBROUTINE UpdateHost_hfInt64_r2 ( this ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt64_r2","tags":"","loc":"proc/updatehost_hfint64_r2.html"},{"title":"UpdateHost_hfInt64_r3 – SELF","text":"public subroutine UpdateHost_hfInt64_r3(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this Calls proc~~updatehost_hfint64_r3~~CallsGraph proc~updatehost_hfint64_r3 UpdateHost_hfInt64_r3 hipmemcpy hipmemcpy proc~updatehost_hfint64_r3->hipmemcpy hipcheck hipcheck proc~updatehost_hfint64_r3->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfint64_r3->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt64_r3 Source Code SUBROUTINE UpdateHost_hfInt64_r3 ( this ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt64_r3","tags":"","loc":"proc/updatehost_hfint64_r3.html"},{"title":"UpdateHost_hfInt64_r4 – SELF","text":"public subroutine UpdateHost_hfInt64_r4(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this Calls proc~~updatehost_hfint64_r4~~CallsGraph proc~updatehost_hfint64_r4 UpdateHost_hfInt64_r4 hipmemcpy hipmemcpy proc~updatehost_hfint64_r4->hipmemcpy hipcheck hipcheck proc~updatehost_hfint64_r4->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfint64_r4->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt64_r4 Source Code SUBROUTINE UpdateHost_hfInt64_r4 ( this ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt64_r4","tags":"","loc":"proc/updatehost_hfint64_r4.html"},{"title":"UpdateHost_hfInt64_r5 – SELF","text":"public subroutine UpdateHost_hfInt64_r5(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this Calls proc~~updatehost_hfint64_r5~~CallsGraph proc~updatehost_hfint64_r5 UpdateHost_hfInt64_r5 hipmemcpy hipmemcpy proc~updatehost_hfint64_r5->hipmemcpy hipcheck hipcheck proc~updatehost_hfint64_r5->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfint64_r5->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt64_r5 Source Code SUBROUTINE UpdateHost_hfInt64_r5 ( this ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt64_r5","tags":"","loc":"proc/updatehost_hfint64_r5.html"},{"title":"UpdateHost_hfInt64_r6 – SELF","text":"public subroutine UpdateHost_hfInt64_r6(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this Calls proc~~updatehost_hfint64_r6~~CallsGraph proc~updatehost_hfint64_r6 UpdateHost_hfInt64_r6 hipmemcpy hipmemcpy proc~updatehost_hfint64_r6->hipmemcpy hipcheck hipcheck proc~updatehost_hfint64_r6->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfint64_r6->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt64_r6 Source Code SUBROUTINE UpdateHost_hfInt64_r6 ( this ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt64_r6","tags":"","loc":"proc/updatehost_hfint64_r6.html"},{"title":"UpdateHost_hfInt64_r7 – SELF","text":"public subroutine UpdateHost_hfInt64_r7(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this Calls proc~~updatehost_hfint64_r7~~CallsGraph proc~updatehost_hfint64_r7 UpdateHost_hfInt64_r7 hipmemcpy hipmemcpy proc~updatehost_hfint64_r7->hipmemcpy hipcheck hipcheck proc~updatehost_hfint64_r7->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfint64_r7->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt64_r7 Source Code SUBROUTINE UpdateHost_hfInt64_r7 ( this ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfInt64_r7","tags":"","loc":"proc/updatehost_hfint64_r7.html"},{"title":"UpdateHost_hfReal_r1 – SELF","text":"public subroutine UpdateHost_hfReal_r1(this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this Calls proc~~updatehost_hfreal_r1~~CallsGraph proc~updatehost_hfreal_r1 UpdateHost_hfReal_r1 hipmemcpy hipmemcpy proc~updatehost_hfreal_r1->hipmemcpy hipcheck hipcheck proc~updatehost_hfreal_r1->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfreal_r1->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfReal_r1 Source Code SUBROUTINE UpdateHost_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r1","tags":"","loc":"proc/updatehost_hfreal_r1.html"},{"title":"UpdateHost_hfReal_r2 – SELF","text":"public subroutine UpdateHost_hfReal_r2(this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this Calls proc~~updatehost_hfreal_r2~~CallsGraph proc~updatehost_hfreal_r2 UpdateHost_hfReal_r2 hipmemcpy hipmemcpy proc~updatehost_hfreal_r2->hipmemcpy hipcheck hipcheck proc~updatehost_hfreal_r2->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfreal_r2->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfReal_r2 Source Code SUBROUTINE UpdateHost_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r2","tags":"","loc":"proc/updatehost_hfreal_r2.html"},{"title":"UpdateHost_hfReal_r3 – SELF","text":"public subroutine UpdateHost_hfReal_r3(this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this Calls proc~~updatehost_hfreal_r3~~CallsGraph proc~updatehost_hfreal_r3 UpdateHost_hfReal_r3 hipmemcpy hipmemcpy proc~updatehost_hfreal_r3->hipmemcpy hipcheck hipcheck proc~updatehost_hfreal_r3->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfreal_r3->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfReal_r3 Source Code SUBROUTINE UpdateHost_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r3","tags":"","loc":"proc/updatehost_hfreal_r3.html"},{"title":"UpdateHost_hfReal_r4 – SELF","text":"public subroutine UpdateHost_hfReal_r4(this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this Calls proc~~updatehost_hfreal_r4~~CallsGraph proc~updatehost_hfreal_r4 UpdateHost_hfReal_r4 hipmemcpy hipmemcpy proc~updatehost_hfreal_r4->hipmemcpy hipcheck hipcheck proc~updatehost_hfreal_r4->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfreal_r4->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfReal_r4 Source Code SUBROUTINE UpdateHost_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r4","tags":"","loc":"proc/updatehost_hfreal_r4.html"},{"title":"UpdateHost_hfReal_r5 – SELF","text":"public subroutine UpdateHost_hfReal_r5(this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this Calls proc~~updatehost_hfreal_r5~~CallsGraph proc~updatehost_hfreal_r5 UpdateHost_hfReal_r5 hipmemcpy hipmemcpy proc~updatehost_hfreal_r5->hipmemcpy hipcheck hipcheck proc~updatehost_hfreal_r5->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfreal_r5->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfReal_r5 Source Code SUBROUTINE UpdateHost_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r5","tags":"","loc":"proc/updatehost_hfreal_r5.html"},{"title":"UpdateHost_hfReal_r6 – SELF","text":"public subroutine UpdateHost_hfReal_r6(this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this Calls proc~~updatehost_hfreal_r6~~CallsGraph proc~updatehost_hfreal_r6 UpdateHost_hfReal_r6 hipmemcpy hipmemcpy proc~updatehost_hfreal_r6->hipmemcpy hipcheck hipcheck proc~updatehost_hfreal_r6->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfreal_r6->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfReal_r6 Source Code SUBROUTINE UpdateHost_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r6","tags":"","loc":"proc/updatehost_hfreal_r6.html"},{"title":"UpdateHost_hfReal_r7 – SELF","text":"public subroutine UpdateHost_hfReal_r7(this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this Calls proc~~updatehost_hfreal_r7~~CallsGraph proc~updatehost_hfreal_r7 UpdateHost_hfReal_r7 hipmemcpy hipmemcpy proc~updatehost_hfreal_r7->hipmemcpy hipcheck hipcheck proc~updatehost_hfreal_r7->hipcheck proc~gpuavailable GPUAvailable proc~updatehost_hfreal_r7->proc~gpuavailable hipgetdevicecount hipgetdevicecount proc~gpuavailable->hipgetdevicecount Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfReal_r7 Source Code SUBROUTINE UpdateHost_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this IF ( GPUAvailable ()) THEN CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) END IF END SUBROUTINE UpdateHost_hfReal_r7","tags":"","loc":"proc/updatehost_hfreal_r7.html"},{"title":"ForwardStep_Advection3D – SELF","text":"public subroutine ForwardStep_Advection3D(this, endTime) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this real(kind=prec), intent(in) :: endTime Contents Source Code ForwardStep_Advection3D Source Code SUBROUTINE ForwardStep_Advection3D ( this , endTime ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: endTime ! Local INTEGER :: nSteps REAL ( prec ) :: dt IF ( this % integrator == RK3 ) THEN ! Step forward dt = this % dt nSteps = INT (( endTime - this % simulationTime ) / dt ) CALL this % TimeStepRK3 ( nSteps ) ! Take any additional steps to reach desired endTime this % dt = endTime - this % simulationTime IF ( this % dt > 0 ) THEN nSteps = 1 CALL this % TimeStepRK3 ( nSteps ) ENDIF ! Reset the time step this % dt = dt ENDIF END SUBROUTINE ForwardStep_Advection3D","tags":"","loc":"proc/forwardstep_advection3d.html"},{"title":"Free_Advection3D – SELF","text":"public subroutine Free_Advection3D(this) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this Contents Source Code Free_Advection3D Source Code SUBROUTINE Free_Advection3D ( this ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this CALL this % mesh % Free () CALL this % geometry % Free () CALL this % solution % Free () CALL this % dSdt % Free () CALL this % plotSolution % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () CALL this % workScalar % Free () CALL this % workVector % Free () CALL this % workTensor % Free () CALL this % compFlux % Free () CALL this % velocity % Free () CALL this % plotVelocity % Free () CALL this % plotX % Free () DEALLOCATE ( this % solutionMetaData ) DEALLOCATE ( this % boundaryConditionEqn ) DEALLOCATE ( this % solutionEqn ) DEALLOCATE ( this % sourceEqn ) END SUBROUTINE Free_Advection3D","tags":"","loc":"proc/free_advection3d.html"},{"title":"GetCLIParameters – SELF","text":"private subroutine GetCLIParameters(cli) Arguments Type Intent Optional Attributes Name type(COMMAND_LINE_INTERFACE), intent(inout) :: cli Called by proc~~getcliparameters~~CalledByGraph proc~getcliparameters GetCLIParameters proc~initfromcli_advection3d InitFromCLI_Advection3D proc~initfromcli_advection3d->proc~getcliparameters Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code GetCLIParameters Source Code SUBROUTINE GetCLIParameters ( cli ) TYPE ( COMMAND_LINE_INTERFACE ), INTENT ( inout ) :: cli CALL cli % init ( progname = \"sadv3d\" , & version = \"v0.0.0\" , & description = \"SELF Advection in 3-D\" , & license = \"ANTI-CAPITALIST SOFTWARE LICENSE (v 1.4)\" , & authors = \"Joseph Schoonover (Fluid Numerics LLC)\" ) CALL cli % add ( switch = \"--mpi\" , & help = \"Enable MPI\" , & act = \"store_true\" , & def = \"false\" , & required = . FALSE .) CALL cli % add ( switch = \"--gpu\" , & help = \"Enable GPU acceleration\" , & act = \"store_true\" , & def = \"false\" , & required = . FALSE .) CALL cli % add ( switch = \"--time-step\" , & switch_ab = \"-dt\" , & help = \"The time step size for the time integrator\" , & def = \"0.001\" , & required = . FALSE .) CALL cli % add ( switch = \"--initial-time\" , & switch_ab = \"-t0\" , & help = \"The initial time level\" , & def = \"0.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--output-interval\" , & switch_ab = \"-oi\" , & help = \"The time between file output\" , & def = \"0.5\" , & required = . FALSE .) CALL cli % add ( switch = \"--end-time\" , & switch_ab = \"-tn\" , & help = \"The final time level\" , & def = \"1.0\" , & required = . FALSE .) ! Get the control degree CALL cli % add ( switch = \"--control-degree\" , & switch_ab = \"-c\" , & help = \"The polynomial degree of the control points.\" // NEW_LINE ( \"A\" ), & def = \"7\" , & required = . FALSE .) ! Get the target degree (assumed for plotting) CALL cli % add ( switch = \"--target-degree\" , & switch_ab = \"-t\" , & help = \"The polynomial degree for the\" // & & \" target points for interpolation.\" // & & \" Typically used for plotting\" // NEW_LINE ( \"A\" ), & def = \"14\" , & required = . FALSE .) ! Get the control quadrature ! Everyone know Legendre-Gauss Quadrature is the best... CALL cli % add ( switch = \"--control-quadrature\" , & switch_ab = \"-cq\" , & def = \"gauss\" , & help = \"The quadrature type for control points.\" // NEW_LINE ( \"A\" ), & choices = \"gauss,gauss-lobatto,chebyshev-gauss,chebyshev-gauss-lobatto\" , & required = . FALSE .) ! Set the target grid quadrature ! Default to uniform (assumed for plotting) CALL cli % add ( switch = \"--target-quadrature\" , & switch_ab = \"-tq\" , & def = \"uniform\" , & help = \"The quadrature type for target points.\" // NEW_LINE ( \"A\" ), & choices = \"gauss,gauss-lobatto,uniform\" , & required = . FALSE .) ! (Optional) Provide a file for a mesh ! Assumed in HOPR or ISM-v2 format CALL cli % add ( switch = \"--mesh\" , & switch_ab = \"-m\" , & help = \"Path to a mesh file for control mesh.\" // NEW_LINE ( \"A\" ), & def = \"\" , & required = . FALSE .) ! (Optional) If a mesh is not provided, you ! can request a structured grid to be generated ! just set the nxelement, nyelements.. CALL cli % add ( switch = \"--nxelements\" , & switch_ab = \"-nx\" , & help = \"The number of elements in the x-direction for structured mesh generation.\" , & def = \"5\" , & required = . FALSE .) CALL cli % add ( switch = \"--nyelements\" , & switch_ab = \"-ny\" , & help = \"The number of elements in the y-direction for structured mesh generation.\" , & def = \"5\" , & required = . FALSE .) CALL cli % add ( switch = \"--nzelements\" , & switch_ab = \"-nz\" , & help = \"The number of elements in the z-direction for structured mesh generation.\" , & def = \"5\" , & required = . FALSE .) ! Alright... now tell me some physical mesh dimensions CALL cli % add ( switch = \"--xlength\" , & switch_ab = \"-lx\" , & help = \"The physical x-scale for structured mesh generation.\" // & \" Ignored if a mesh file is provided\" , & def = \"1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--ylength\" , & switch_ab = \"-ly\" , & help = \"The physical y-scale for structured mesh generation.\" // & \" Ignored if a mesh file is provided\" , & def = \"1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--zlength\" , & switch_ab = \"-lz\" , & help = \"The physical z-scale for structured mesh generation.\" // & \" Ignored if a mesh file is provided\" , & def = \"1.0\" , & required = . FALSE .) ! Set the velocity field CALL cli % add ( switch = \"--velocity-x\" , & switch_ab = \"-vx\" , & help = \"Equation for the x-component of the velocity field\" ,& def = \"vx=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--velocity-y\" , & switch_ab = \"-vy\" , & help = \"Equation for the y-component of the velocity field\" ,& def = \"vy=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--velocity-z\" , & switch_ab = \"-vz\" , & help = \"Equation for the z-component of the velocity field\" ,& def = \"vz=1.0\" , & required = . FALSE .) ! Tracer diffusivity CALL cli % add ( switch = \"--diffusivity\" , & switch_ab = \"-nu\" , & help = \"Tracer diffusivity (applied to all tracers)\" , & def = \"0.0\" , & required = . FALSE .) ! Set the initial conditions ! .. TO DO .. !  > How to handle multiple tracer fields ?? CALL cli % add ( switch = \"--initial-condition\" , & switch_ab = \"-ic\" , & help = \"Equation for the initial tracer distributions\" ,& def = \"f = exp( -( ((x-t)-0.5)&#94;2 + ((y-t)-0.5)&#94;2 + ((z-t)-0.5)&#94;2)/0.01 )\" , & required = . FALSE .) CALL cli % add ( switch = \"--boundary-condition\" , & switch_ab = \"-bc\" , & help = \"Equation for the boundary tracer distributions (can be time dependent!)\" , & def = \"f = exp( -( ((x-t)-0.5)&#94;2 + ((y-t)-0.5)&#94;2 + ((z-t)-0.5)&#94;2)/0.01 )\" , & required = . FALSE .) CALL cli % add ( switch = \"--source\" , & switch_ab = \"-s\" , & help = \"Equation for the source term (can be time dependent!)\" , & def = \"s = 0.0\" , & required = . FALSE .) ! Give me a time integrator CALL cli % add ( switch = \"--integrator\" , & switch_ab = \"-int\" , & help = \"Sets the time integration method. Only 'euler' or 'williamson_rk3'\" , & def = \"williamson_rk3\" , & required = . FALSE .) END SUBROUTINE GetCLIParameters","tags":"","loc":"proc/getcliparameters.html"},{"title":"InitFromCLI_Advection3D – SELF","text":"public subroutine InitFromCLI_Advection3D(this) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this Calls proc~~initfromcli_advection3d~~CallsGraph proc~initfromcli_advection3d InitFromCLI_Advection3D equationparser equationparser proc~initfromcli_advection3d->equationparser proc~getcliparameters GetCLIParameters proc~initfromcli_advection3d->proc~getcliparameters uppercase uppercase proc~initfromcli_advection3d->uppercase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code InitFromCLI_Advection3D Source Code SUBROUTINE InitFromCLI_Advection3D ( this ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this ! Local TYPE ( COMMAND_LINE_INTERFACE ) :: cli TYPE ( MeshSpec ) :: spec CHARACTER ( self_QuadratureTypeCharLength ) :: cqTypeChar CHARACTER ( self_QuadratureTypeCharLength ) :: tqTypeChar CHARACTER ( self_IntegratorTypeCharLength ) :: integratorChar REAL ( prec ) :: Lx , Ly , Lz ! Domain lengths REAL ( prec ) :: dt ! Default time step size REAL ( prec ) :: diffusivity INTEGER :: controlDegree INTEGER :: targetDegree INTEGER :: controlQuadrature ! ENUMS in SELF_Constants.f90 INTEGER :: targetQuadrature ! ENUMS in SELF_Constants.f90 CHARACTER ( LEN = self_FileNameLength ) :: meshFile INTEGER :: nxElements INTEGER :: nyElements INTEGER :: nzElements INTEGER :: integrator ! ENUMS needed in SELF_Constants.f90 !! TO DO !! CHARACTER ( LEN = self_EquationLength ) :: velEqnX ! Velocity Equation (x-direction) CHARACTER ( LEN = self_EquationLength ) :: velEqnY ! Velocity Equation (y-direction) CHARACTER ( LEN = self_EquationLength ) :: velEqnZ ! Velocity Equation (z-direction) CHARACTER ( LEN = self_EquationLength ) :: icEqn ! Initial condition Equation CHARACTER ( LEN = self_EquationLength ) :: bcEqn ! Boundary condition Equation CHARACTER ( LEN = self_EquationLength ) :: sourceEqn ! Boundary condition Equation LOGICAL :: enableMPI LOGICAL :: enableGPU LOGICAL :: diffusiveFlux REAL ( prec ) :: outputInterval REAL ( prec ) :: initialTime REAL ( prec ) :: endTime TYPE ( EquationParser ) :: eqn ( 1 ) TYPE ( EquationParser ) :: velEqn ( 1 : 3 ) ! Get the CLI parameters ! CALL GetCLIParameters ( cli ) ! Set the CLI parameters ! CALL cli % get ( val = enableMPI , switch = '--mpi' ) CALL cli % get ( val = enableGPU , switch = '--gpu' ) CALL cli % get ( val = meshfile , switch = '--mesh' ) CALL cli % get ( val = dt , switch = \"--time-step\" ) CALL cli % get ( val = outputInterval , switch = \"--output-interval\" ) CALL cli % get ( val = initialTime , switch = \"--initial-time\" ) CALL cli % get ( val = endTime , switch = \"--end-time\" ) CALL cli % get ( val = controlDegree , switch = \"--control-degree\" ) CALL cli % get ( val = targetDegree , switch = \"--target-degree\" ) CALL cli % get ( val = cqTypeChar , switch = \"--control-quadrature\" ) CALL cli % get ( val = tqTypeChar , switch = \"--target-quadrature\" ) CALL cli % get ( val = meshFile , switch = \"--mesh\" ) CALL cli % get ( val = nxElements , switch = \"--nxelements\" ) CALL cli % get ( val = nyElements , switch = \"--nyelements\" ) CALL cli % get ( val = nzElements , switch = \"--nzelements\" ) CALL cli % get ( val = Lx , switch = \"--xlength\" ) CALL cli % get ( val = Ly , switch = \"--ylength\" ) CALL cli % get ( val = Lz , switch = \"--zlength\" ) CALL cli % get ( val = velEqnX , switch = \"--velocity-x\" ) CALL cli % get ( val = velEqnY , switch = \"--velocity-y\" ) CALL cli % get ( val = velEqnY , switch = \"--velocity-z\" ) CALL cli % get ( val = icEqn , switch = \"--initial-condition\" ) CALL cli % get ( val = bcEqn , switch = \"--boundary-condition\" ) CALL cli % get ( val = sourceEqn , switch = \"--source\" ) CALL cli % get ( val = integratorChar , switch = \"--integrator\" ) CALL cli % get ( val = diffusivity , switch = \"--diffusivity\" ) diffusiveFlux = . TRUE . IF ( diffusivity == 0.0_prec ) THEN diffusiveFlux = . FALSE . ELSEIF ( diffusivity < 0.0_prec ) THEN IF ( dt > 0.0_prec ) THEN PRINT * , 'Negative diffusivity provably unstable for forward stepping' PRINT * , 'Invalid diffusivity value. Stopping' STOP ENDIF ENDIF IF ( TRIM ( UpperCase ( cqTypeChar )) == 'GAUSS' ) THEN controlQuadrature = GAUSS ELSEIF ( TRIM ( UpperCase ( cqTypeChar )) == 'GAUSS-LOBATTO' ) THEN controlQuadrature = GAUSS_LOBATTO ELSEIF ( TRIM ( UpperCase ( cqTypeChar )) == 'CHEBYSHEV-GAUSS' ) THEN controlQuadrature = CHEBYSHEV_GAUSS ELSEIF ( TRIM ( UpperCase ( cqTypeChar )) == 'CHEBYSHEV-GAUSS-LOBATTO' ) THEN controlQuadrature = CHEBYSHEV_GAUSS_LOBATTO ELSE PRINT * , 'Invalid Control Quadrature' STOP - 1 END IF IF ( TRIM ( UpperCase ( tqTypeChar )) == 'UNIFORM' ) THEN targetQuadrature = UNIFORM ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'GAUSS' ) THEN targetQuadrature = GAUSS ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'GAUSS-LOBATTO' ) THEN targetQuadrature = GAUSS_LOBATTO ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'CHEBYSHEV-GAUSS' ) THEN targetQuadrature = CHEBYSHEV_GAUSS ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'CHEBYSHEV-GAUSS-LOBATTO' ) THEN targetQuadrature = CHEBYSHEV_GAUSS_LOBATTO ELSE PRINT * , 'Invalid Target Quadrature' STOP - 1 END IF IF ( TRIM ( UpperCase ( integratorChar )) == 'EULER' ) THEN integrator = EULER ELSEIF ( TRIM ( UpperCase ( integratorChar )) == 'WILLIAMSON_RK3' ) THEN integrator = RK3 ELSE PRINT * , 'Invalid time integrator' STOP - 1 END IF IF ( TRIM ( meshfile ) == \"\" ) THEN spec % blockMesh = . TRUE . ELSE spec % blockMesh = . FALSE . ENDIF spec % filename = meshfile spec % filetype = SELF_MESH_ISM_V2_3D spec % blockMesh_nGeo = 1 spec % blockMesh_x0 = 0.0_prec spec % blockMesh_x1 = Lx spec % blockMesh_y0 = 0.0_prec spec % blockMesh_y1 = Ly spec % blockMesh_z0 = 0.0_prec spec % blockMesh_z1 = Lz spec % blockMesh_nElemX = nxElements spec % blockMesh_nElemY = nyElements spec % blockMesh_nElemZ = nzElements CALL this % Init ( controlQuadrature , & targetQuadrature , & controlDegree , & targetDegree , & 1 , enableMPI , & spec ) this % simulationTime = 0.0_prec this % Lx = Lx this % Ly = Ly ! Domain lengths this % Lz = Lz ! Domain lengths this % dt = dt ! Default time step size this % initialTime = initialTime this % simulationTime = initialTime this % endTime = endTime this % outputInterval = outputInterval this % controlDegree = controlDegree this % targetDegree = targetDegree this % controlQuadrature = controlQuadrature ! ENUMS in SELF_Constants.f90 this % targetQuadrature = targetQuadrature ! ENUMS in SELF_Constants.f90 this % meshFile = meshFile this % nxElements = nxElements this % nyElements = nyElements this % nzElements = nzElements this % integrator = integrator ! ENUMS needed in SELF_Constants.f90 !! TO DO !! this % velEqnX = velEqnX ! Velocity Equation (x-direction) this % velEqnY = velEqnY ! Velocity Equation (y-direction) this % velEqnZ = velEqnZ ! Velocity Equation (y-direction) this % icEqn = icEqn ! Initial condition Equation this % bcEqn = bcEqn ! Boundary condition Equation this % enableMPI = enableMPI this % gpuAccel = enableGPU this % diffusivity = diffusivity this % diffusiveFlux = diffusiveFlux eqn ( 1 ) = EquationParser ( icEqn , ( / 'x' , 'y' , 'z' , 't' / )) CALL this % SetSolution ( eqn ) this % solutionEqn ( 1 ) = EquationParser ( icEqn , ( / 'x' , 'y' , 'z' , 't' / )) velEqn ( 1 ) = EquationParser ( velEqnX , ( / 'x' , 'y' , 'z' / )) velEqn ( 2 ) = EquationParser ( velEqnY , ( / 'x' , 'y' , 'z' / )) velEqn ( 3 ) = EquationParser ( velEqnZ , ( / 'x' , 'y' , 'z' / )) CALL this % SetVelocity ( velEqn ) this % boundaryConditionEqn ( 1 ) = EquationParser ( bcEqn , ( / 'x' , 'y' , 'z' , 't' / )) CALL this % SetBoundaryCondition ( this % boundaryConditionEqn ) this % sourceEqn ( 1 ) = EquationParser ( sourceEqn , ( / 'x' , 'y' , 'z' , 't' / )) END SUBROUTINE InitFromCLI_Advection3D","tags":"","loc":"proc/initfromcli_advection3d.html"},{"title":"Init_Advection3D – SELF","text":"public subroutine Init_Advection3D(this, cqType, tqType, cqDegree, tqDegree, nvar, enableMPI, spec) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(out) :: this integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nvar logical, intent(in) :: enableMPI type(MeshSpec), intent(in) :: spec Contents Source Code Init_Advection3D Source Code SUBROUTINE Init_Advection3D ( this , cqType , tqType , cqDegree , tqDegree , nvar , enableMPI , spec ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nvar LOGICAL , INTENT ( in ) :: enableMPI TYPE ( MeshSpec ), INTENT ( in ) :: spec CALL this % decomp % Init ( enableMPI ) ! Load Mesh IF ( enableMPI ) THEN CALL this % mesh % Load ( spec , this % decomp ) ELSE CALL this % mesh % Load ( spec ) ENDIF CALL this % decomp % SetMaxMsg ( this % mesh % nUniqueSides ) CALL this % decomp % setElemToRank ( this % mesh % nElem ) ! Create geometry from mesh CALL this % geometry % GenerateFromMesh (& this % mesh , cqType , tqType , cqDegree , tqDegree ) CALL this % plotSolution % Init (& tqDegree , tqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % dSdt % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % solution % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % solutionGradient % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % flux % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % velocity % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % plotVelocity % Init (& tqDegree , tqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % plotX % Init (& tqDegree , tqType , tqDegree , tqType , 1 ,& this % mesh % nElem ) CALL this % source % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % fluxDivergence % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % workScalar % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % workVector % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % workTensor % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % compFlux % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) ALLOCATE ( this % solutionMetaData ( 1 : nvar )) ALLOCATE ( this % boundaryConditionEqn ( 1 : nvar )) ALLOCATE ( this % solutionEqn ( 1 : nvar )) ALLOCATE ( this % sourceEqn ( 1 : nvar )) END SUBROUTINE Init_Advection3D","tags":"","loc":"proc/init_advection3d.html"},{"title":"InternalFlux_Advection3D – SELF","text":"public subroutine InternalFlux_Advection3D(this) Calculates the advective flux using the provided velocity Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this Calls proc~~internalflux_advection3d~~CallsGraph proc~internalflux_advection3d InternalFlux_Advection3D interface~internalflux_advection3d_gpu_wrapper InternalFlux_Advection3D_gpu_wrapper proc~internalflux_advection3d->interface~internalflux_advection3d_gpu_wrapper interface~internaldiffusiveflux_advection3d_gpu_wrapper InternalDiffusiveFlux_Advection3D_gpu_wrapper proc~internalflux_advection3d->interface~internaldiffusiveflux_advection3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code InternalFlux_Advection3D Source Code SUBROUTINE InternalFlux_Advection3D ( this ) !! Calculates the advective flux using the provided velocity IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this ! Local INTEGER :: i , j , k , iVar , iEl REAL ( prec ) :: Fx , Fy , Fz IF ( this % gpuAccel ) THEN ! When GPU acceleration is enabled (requested by the user) ! we call the gpu wrapper interface, which will call the ! HIP kernel \"under the hood\" ! ! TO DO : Pass the contravariant basis vector to GPU kernel CALL InternalFlux_Advection3D_gpu_wrapper ( this % flux % interior % deviceData ,& this % solution % interior % deviceData , & this % velocity % interior % deviceData , & this % geometry % dsdx % interior % deviceData , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) IF ( this % diffusiveFlux ) THEN CALL InternalDiffusiveFlux_Advection3D_gpu_wrapper ( this % flux % interior % deviceData ,& this % solutionGradient % interior % deviceData , & this % geometry % dsdx % interior % deviceData , & this % diffusivity , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ENDIF ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % N DO j = 0 , this % solution % N DO i = 0 , this % solution % N Fx = this % velocity % interior % hostData ( 1 , i , j , k , 1 , iEl ) * & this % solution % interior % hostData ( i , j , k , iVar , iEl ) Fy = this % velocity % interior % hostData ( 2 , i , j , k , 1 , iEl ) * & this % solution % interior % hostData ( i , j , k , iVar , iEl ) Fz = this % velocity % interior % hostData ( 3 , i , j , k , 1 , iEl ) * & this % solution % interior % hostData ( i , j , k , iVar , iEl ) this % flux % interior % hostData ( 1 , i , j , k , iVar , iEl ) = & this % geometry % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iel ) * Fy + & this % geometry % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iel ) * Fz this % flux % interior % hostData ( 2 , i , j , k , iVar , iEl ) = & this % geometry % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iel ) * Fy + & this % geometry % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iel ) * Fz this % flux % interior % hostData ( 3 , i , j , k , iVar , iEl ) = & this % geometry % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iel ) * Fy + & this % geometry % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iel ) * Fz ENDDO ENDDO ENDDO ENDDO ENDDO ! When diffusivity == 0, then we don't bother calculating the diffusive flux IF ( this % diffusiveFlux ) THEN ! Otherwise, we add the diffusive flux to to the flux vector DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % N DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Diffusive flux is diffusivity coefficient mulitplied by ! solution gradient Fx = this % solutionGradient % interior % hostData ( 1 , i , j , k , iVar , iEl ) * & this % diffusivity Fy = this % solutionGradient % interior % hostData ( 2 , i , j , k , iVar , iEl ) * & this % diffusivity Fz = this % solutionGradient % interior % hostData ( 3 , i , j , k , iVar , iEl ) * & this % diffusivity ! Project the diffusive flux vector onto computational coordinates this % flux % interior % hostData ( 1 , i , j , k , iVar , iEl ) = & this % flux % interior % hostData ( 1 , i , j , k , iVar , iEl ) - & ( this % geometry % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iel ) * Fy + & this % geometry % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iel ) * Fz ) this % flux % interior % hostData ( 2 , i , j , k , iVar , iEl ) = & this % flux % interior % hostData ( 2 , i , j , k , iVar , iEl ) - & ( this % geometry % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iel ) * Fy + & this % geometry % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iel ) * Fz ) this % flux % interior % hostData ( 3 , i , j , k , iVar , iEl ) = & this % flux % interior % hostData ( 3 , i , j , k , iVar , iEl ) - & ( this % geometry % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iel ) * Fy + & this % geometry % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iel ) * Fz ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF ! DiffusiveFlux ENDIF ! GPU Acceleration END SUBROUTINE InternalFlux_Advection3D","tags":"","loc":"proc/internalflux_advection3d.html"},{"title":"SetBoundaryConditionFromEquation_Advection3D – SELF","text":"public subroutine SetBoundaryConditionFromEquation_Advection3D(this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) Contents Source Code SetBoundaryConditionFromEquation_Advection3D Source Code SUBROUTINE SetBoundaryConditionFromEquation_Advection3D ( this , eqn ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: i , j , iEl , iVar , iSide REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: z DO iEl = 1 , this % solution % nElem DO iSide = 1 , 6 DO iVar = 1 , this % solution % nvar DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! If this element's side has no neighbor assigned ! it is assumed to be a physical boundary. ! In this case, we want to assign the external boundary ! condition. IF ( this % mesh % self_sideInfo % hostData ( 3 , iSide , iEl ) == 0 ) THEN ! Get the mesh positions x = this % geometry % x % boundary % hostData ( 1 , i , j , 1 , iSide , iEl ) y = this % geometry % x % boundary % hostData ( 2 , i , j , 1 , iSide , iEl ) z = this % geometry % x % boundary % hostData ( 3 , i , j , 1 , iSide , iEl ) ! Set the external boundary condition this % solution % extBoundary % hostData ( i , j , iVar , iSide , iEl ) = & eqn ( iVar ) % Evaluate (( / x , y , z , this % simulationTime / )) ENDIF ENDDO ENDDO ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN ! Copy data to the GPU CALL this % solution % extBoundary % UpdateDevice () ENDIF END SUBROUTINE SetBoundaryConditionFromEquation_Advection3D","tags":"","loc":"proc/setboundaryconditionfromequation_advection3d.html"},{"title":"SetSolutionFromEquation_Advection3D – SELF","text":"public subroutine SetSolutionFromEquation_Advection3D(this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) Contents Source Code SetSolutionFromEquation_Advection3D Source Code SUBROUTINE SetSolutionFromEquation_Advection3D ( this , eqn ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: i , j , k , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: z REAL ( prec ) :: t DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % N DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Get the mesh positions x = this % geometry % x % interior % hostData ( 1 , i , j , k , 1 , iEl ) y = this % geometry % x % interior % hostData ( 2 , i , j , k , 1 , iEl ) z = this % geometry % x % interior % hostData ( 3 , i , j , k , 1 , iEl ) t = this % simulationTime this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & eqn ( iVar ) % Evaluate (( / x , y , z , t / )) ENDDO ENDDO ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN CALL this % solution % interior % UpdateDevice () ENDIF END SUBROUTINE SetSolutionFromEquation_Advection3D","tags":"","loc":"proc/setsolutionfromequation_advection3d.html"},{"title":"SetSourceFromEquation_Advection3D – SELF","text":"public subroutine SetSourceFromEquation_Advection3D(this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) Contents Source Code SetSourceFromEquation_Advection3D Source Code SUBROUTINE SetSourceFromEquation_Advection3D ( this , eqn ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: i , j , k , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: z REAL ( prec ) :: t DO iEl = 1 , this % source % nElem DO iVar = 1 , this % source % nVar DO k = 0 , this % source % N DO j = 0 , this % source % N DO i = 0 , this % source % N ! Get the mesh positions x = this % geometry % x % interior % hostData ( 1 , i , j , k , 1 , iEl ) y = this % geometry % x % interior % hostData ( 2 , i , j , k , 1 , iEl ) z = this % geometry % x % interior % hostData ( 3 , i , j , k , 1 , iEl ) t = this % simulationTime this % source % interior % hostData ( i , j , k , iVar , iEl ) = & eqn ( iVar ) % Evaluate (( / x , y , z , t / )) ENDDO ENDDO ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN CALL this % source % interior % UpdateDevice () ENDIF END SUBROUTINE SetSourceFromEquation_Advection3D","tags":"","loc":"proc/setsourcefromequation_advection3d.html"},{"title":"SetVelocityFromEquation_Advection3D – SELF","text":"public subroutine SetVelocityFromEquation_Advection3D(this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:3) Contents Source Code SetVelocityFromEquation_Advection3D Source Code SUBROUTINE SetVelocityFromEquation_Advection3D ( this , eqn ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : 3 ) ! Local INTEGER :: i , j , k , iEl , iVar , iSide REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: z DO iEl = 1 , this % solution % nElem ! Set the velocity at the element interiors DO k = 0 , this % solution % N DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Get the mesh positions x = this % geometry % x % interior % hostData ( 1 , i , j , k , 1 , iEl ) y = this % geometry % x % interior % hostData ( 2 , i , j , k , 1 , iEl ) z = this % geometry % x % interior % hostData ( 3 , i , j , k , 1 , iEl ) ! Set the velocity in the x-direction this % velocity % interior % hostData ( 1 , i , j , k , 1 , iEl ) = & eqn ( 1 ) % Evaluate (( / x , y , z / )) ! Set the velocity in the y-direction this % velocity % interior % hostData ( 2 , i , j , k , 1 , iEl ) = & eqn ( 2 ) % Evaluate (( / x , y , z / )) ! Set the velocity in the z-direction this % velocity % interior % hostData ( 3 , i , j , k , 1 , iEl ) = & eqn ( 3 ) % Evaluate (( / x , y , z / )) ENDDO ENDDO ENDDO ! Set the velocity at element faces DO iSide = 1 , 6 DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Get the mesh positions x = this % geometry % x % boundary % hostData ( 1 , i , j , 1 , iSide , iEl ) y = this % geometry % x % boundary % hostData ( 2 , i , j , 1 , iSide , iEl ) z = this % geometry % x % boundary % hostData ( 3 , i , j , 1 , iSide , iEl ) ! Set the velocity in the x-direction this % velocity % boundary % hostData ( 1 , i , j , 1 , iSide , iEl ) = & eqn ( 1 ) % Evaluate (( / x , y , z / )) ! Set the velocity in the y-direction this % velocity % boundary % hostData ( 2 , i , j , 1 , iSide , iEl ) = & eqn ( 2 ) % Evaluate (( / x , y , z / )) ! Set the velocity in the z-direction this % velocity % boundary % hostData ( 3 , i , j , 1 , iSide , iEl ) = & eqn ( 3 ) % Evaluate (( / x , y , z / )) ENDDO ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN CALL this % velocity % interior % UpdateDevice () CALL this % velocity % boundary % UpdateDevice () ENDIF END SUBROUTINE SetVelocityFromEquation_Advection3D","tags":"","loc":"proc/setvelocityfromequation_advection3d.html"},{"title":"SideFlux_Advection3D – SELF","text":"public subroutine SideFlux_Advection3D(this) Calculates the Advective Flux on element sides using a Lax-Friedrich's upwind Riemann Solver Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this Calls proc~~sideflux_advection3d~~CallsGraph proc~sideflux_advection3d SideFlux_Advection3D interface~sidediffusiveflux_advection3d_gpu_wrapper SideDiffusiveFlux_Advection3D_gpu_wrapper proc~sideflux_advection3d->interface~sidediffusiveflux_advection3d_gpu_wrapper interface~sideflux_advection3d_gpu_wrapper SideFlux_Advection3D_gpu_wrapper proc~sideflux_advection3d->interface~sideflux_advection3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SideFlux_Advection3D Source Code SUBROUTINE SideFlux_Advection3D ( this ) !! Calculates the Advective Flux on element sides using a Lax-Friedrich's upwind Riemann Solver IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this ! Local INTEGER :: i , j , iSide , iVar , iEl REAL ( prec ) :: nhat ( 1 : 3 ) REAL ( prec ) :: nmag REAL ( prec ) :: un REAL ( prec ) :: extState REAL ( prec ) :: intState IF ( this % gpuAccel ) THEN CALL SideFlux_Advection3D_gpu_wrapper ( this % flux % boundaryNormal % deviceData , & this % solution % boundary % deviceData , & this % solution % extBoundary % deviceData , & this % velocity % boundary % deviceData , & this % geometry % nHat % boundary % deviceData , & this % geometry % nScale % boundary % deviceData , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) IF ( this % diffusiveFlux ) THEN CALL SideDiffusiveFlux_Advection3D_gpu_wrapper ( this % flux % boundaryNormal % deviceData , & this % solutionGradient % boundary % deviceData , & this % solutionGradient % extBoundary % deviceData , & this % geometry % nHat % boundary % deviceData , & this % geometry % nScale % boundary % deviceData , & this % diffusivity , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ENDIF ELSE DO iEl = 1 , this % solution % nElem DO iSide = 1 , 6 DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Get the boundary normals on cell edges from the mesh geometry nhat ( 1 : 3 ) = this % geometry % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , iSide , iEl ) ! Calculate the normal velocity at the cell edges un = this % velocity % boundary % hostData ( 1 , i , j , 1 , iSide , iEl ) * nHat ( 1 ) + & this % velocity % boundary % hostData ( 2 , i , j , 1 , iSide , iEl ) * nHat ( 2 ) + & this % velocity % boundary % hostData ( 3 , i , j , 1 , iSide , iEl ) * nHat ( 3 ) ! Pull external and internal state for the Riemann Solver (Lax-Friedrichs) extState = this % solution % extBoundary % hostData ( i , j , iVar , iSide , iEl ) intState = this % solution % boundary % hostData ( i , j , iVar , iSide , iEl ) nmag = this % geometry % nScale % boundary % hostData ( i , j , 1 , iSide , iEl ) ! Calculate the flux this % flux % boundaryNormal % hostData ( i , j , iVar , iSide , iEl ) = 0.5_prec * & ( un * ( intState + extState ) - abs ( un ) * ( extState - intState ) ) * nmag ENDDO ENDDO ENDDO ENDDO ENDDO IF ( this % diffusiveFlux ) THEN DO iEl = 1 , this % solution % nElem DO iSide = 1 , 6 DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % N DO i = 0 , this % solution % N nhat ( 1 : 3 ) = this % geometry % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , iSide , iEl ) nmag = this % geometry % nScale % boundary % hostData ( i , j , 1 , iSide , iEl ) !  Calculate \\nabla{f} \\cdot \\hat{n} on the cell sides extState = this % solutionGradient % extBoundary % hostData ( 1 , i , j , iVar , iSide , iEl ) * nHat ( 1 ) + & this % solutionGradient % extBoundary % hostData ( 2 , i , j , iVar , iSide , iEl ) * nHat ( 2 ) + & this % solutionGradient % extBoundary % hostData ( 3 , i , j , iVar , iSide , iEl ) * nHat ( 3 ) intState = this % solutionGradient % boundary % hostData ( 1 , i , j , iVar , iSide , iEl ) * nHat ( 1 ) + & this % solutionGradient % boundary % hostData ( 2 , i , j , iVar , iSide , iEl ) * nHat ( 2 ) + & this % solutionGradient % boundary % hostData ( 3 , i , j , iVar , iSide , iEl ) * nHat ( 3 ) ! Bassi-Rebay flux is the average of the internal and external diffusive flux vectors. this % flux % boundaryNormal % hostData ( i , j , iVar , iSide , iEl ) = & this % flux % boundaryNormal % hostData ( i , j , iVar , iSide , iEl ) - & 0.5_prec * this % diffusivity * ( extState + intState ) * nmag ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF ! Diffusivity ENDIF ! GPU Acceleration END SUBROUTINE SideFlux_Advection3D","tags":"","loc":"proc/sideflux_advection3d.html"},{"title":"Tendency_Advection3D – SELF","text":"public subroutine Tendency_Advection3D(this) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this Contents Source Code Tendency_Advection3D Source Code SUBROUTINE Tendency_Advection3D ( this ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this CALL this % solution % BoundaryInterp ( this % gpuAccel ) IF ( this % diffusiveFlux ) THEN CALL this % CalculateSolutionGradient ( this % gpuAccel ) ENDIF ! Internal Flux calculates both the advective and diffusive flux -- need diffusivity CALL this % InternalFlux ( ) ! Exchange side information between neighboring cells CALL this % solution % SideExchange ( this % mesh , & this % decomp , & this % gpuAccel ) IF ( this % diffusiveFlux ) THEN CALL this % solutionGradient % SideExchange ( this % mesh , & this % decomp , & this % gpuAccel ) ENDIF CALL this % SideFlux ( ) CALL this % CalculateFluxDivergence ( this % gpuAccel ) CALL this % CalculatedSdt ( this % gpuAccel ) END SUBROUTINE Tendency_Advection3D","tags":"","loc":"proc/tendency_advection3d.html"},{"title":"TimeStepRK3_Advection3D – SELF","text":"public subroutine TimeStepRK3_Advection3D(this, nSteps) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this integer, intent(in) :: nSteps Calls proc~~timesteprk3_advection3d~~CallsGraph proc~timesteprk3_advection3d TimeStepRK3_Advection3D interface~updategrk3_advection3d_gpu_wrapper UpdateGRK3_Advection3D_gpu_wrapper proc~timesteprk3_advection3d->interface~updategrk3_advection3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TimeStepRK3_Advection3D Source Code SUBROUTINE TimeStepRK3_Advection3D ( this , nSteps ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: nSteps ! Local INTEGER :: m , iStep INTEGER :: iEl INTEGER :: iVar INTEGER :: i , j , k TYPE ( hfReal_r5 ) :: gRK3 REAL ( prec ) :: t0 REAL ( prec ) :: dt REAL ( prec ) :: rk3A REAL ( prec ) :: rk3G CALL gRK3 % Alloc ( loBound = ( / 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / this % solution % N ,& this % solution % N ,& this % solution % N ,& this % solution % nVar , & this % solution % nElem / )) dt = this % dt DO iStep = 1 , nSteps t0 = this % simulationTime gRK3 % hostData = 0.0_prec DO m = 1 , 3 ! Loop over RK3 steps CALL this % Tendency ( ) IF ( this % gpuAccel ) THEN rk3A = rk3_a ( m ) rk3G = rk3_g ( m ) CALL UpdateGRK3_Advection3D_gpu_wrapper ( gRK3 % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk3A , rk3G , dt , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % N DO j = 0 , this % solution % N DO i = 0 , this % solution % N gRK3 % hostData ( i , j , k , iVar , iEl ) = rk3_a ( m ) * gRK3 % hostData ( i , j , k , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , k , iVar , iEl ) this % solution % interior % hostData ( i , j , k , iVar , iEl ) = & this % solution % interior % hostData ( i , j , k , iVar , iEl ) + & rk3_g ( m ) * dt * gRK3 % hostData ( i , j , k , iVar , iEl ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF this % simulationTime = this % simulationTime + rk3_b ( m ) * dt ENDDO this % simulationTime = t0 + dt ENDDO CALL gRK3 % Free () END SUBROUTINE TimeStepRK3_Advection3D","tags":"","loc":"proc/timesteprk3_advection3d.html"},{"title":"WriteTecplot_Advection3D – SELF","text":"public subroutine WriteTecplot_Advection3D(self, filename) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: self character, intent(in), optional :: filename Calls proc~~writetecplot_advection3d~~CallsGraph proc~writetecplot_advection3d WriteTecplot_Advection3D timestamp timestamp proc~writetecplot_advection3d->timestamp newunit newunit proc~writetecplot_advection3d->newunit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteTecplot_Advection3D Source Code SUBROUTINE WriteTecplot_Advection3D ( self , filename ) IMPLICIT NONE CLASS ( Advection3D ), INTENT ( inout ) :: self CHARACTER ( * ), INTENT ( in ), OPTIONAL :: filename ! Local CHARACTER ( 8 ) :: zoneID INTEGER :: fUnit INTEGER :: iEl , i , j , k CHARACTER ( LEN = self_FileNameLength ) :: tecFile CHARACTER ( 13 ) :: timeStampString IF ( PRESENT ( filename ) ) THEN tecFile = filename ELSE timeStampString = TimeStamp ( self % simulationTime , 's' ) tecFile = 'solution.' // timeStampString // '.tec' ENDIF IF ( self % gpuAccel ) THEN ! Copy data to the CPU CALL self % solution % interior % UpdateHost () ENDIF ! Map the mesh positions to the target grid CALL self % geometry % x % GridInterp ( self % plotX , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL self % solution % GridInterp ( self % plotSolution , gpuAccel = . FALSE .) ! Map the velocity to the target grid CALL self % velocity % GridInterp ( self % plotVelocity , gpuAccel = . FALSE .) ! Let's write some tecplot!! OPEN ( UNIT = NEWUNIT ( fUnit ), & FILE = TRIM ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) ! TO DO :: Adjust for multiple tracer fields WRITE ( fUnit , * ) 'VARIABLES = \"X\", \"Y\", \"Z\", \"tracer\",\"u\",\"v\",\"w\"' DO iEl = 1 , self % solution % nElem ! TO DO :: Get the global element ID WRITE ( zoneID , '(I8.8)' ) iEl WRITE ( fUnit , * ) 'ZONE T=\"el' // trim ( zoneID ) // '\", I=' , self % solution % M + 1 ,& ', J=' , self % solution % M + 1 ,& ', K=' , self % solution % M + 1 , ',F=POINT' DO k = 0 , self % solution % M DO j = 0 , self % solution % M DO i = 0 , self % solution % M WRITE ( fUnit , '(7(E15.7,1x))' ) self % plotX % interior % hostData ( 1 , i , j , k , 1 , iEl ), & self % plotX % interior % hostData ( 2 , i , j , k , 1 , iEl ), & self % plotX % interior % hostData ( 3 , i , j , k , 1 , iEl ), & self % plotSolution % interior % hostData ( i , j , k , 1 , iEl ),& self % plotVelocity % interior % hostData ( 1 , i , j , k , 1 , iEl ),& self % plotVelocity % interior % hostData ( 2 , i , j , k , 1 , iEl ),& self % plotVelocity % interior % hostData ( 3 , i , j , k , 1 , iEl ) ENDDO ENDDO ENDDO ENDDO CLOSE ( UNIT = fUnit ) END SUBROUTINE WriteTecplot_Advection3D","tags":"","loc":"proc/writetecplot_advection3d.html"},{"title":"InternalDiffusiveFlux_Advection3D_gpu_wrapper – SELF","text":"interface Called by interface~~internaldiffusiveflux_advection3d_gpu_wrapper~~CalledByGraph interface~internaldiffusiveflux_advection3d_gpu_wrapper InternalDiffusiveFlux_Advection3D_gpu_wrapper proc~internalflux_advection3d InternalFlux_Advection3D proc~internalflux_advection3d->interface~internaldiffusiveflux_advection3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine InternalDiffusiveFlux_Advection3D_gpu_wrapper(flux, solutionGradient, dsdx, diffusivity, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: solutionGradient type(c_ptr) :: dsdx real(kind=c_prec), VALUE :: diffusivity integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/internaldiffusiveflux_advection3d_gpu_wrapper.html"},{"title":"InternalFlux_Advection3D_gpu_wrapper – SELF","text":"interface Called by interface~~internalflux_advection3d_gpu_wrapper~~CalledByGraph interface~internalflux_advection3d_gpu_wrapper InternalFlux_Advection3D_gpu_wrapper proc~internalflux_advection3d InternalFlux_Advection3D proc~internalflux_advection3d->interface~internalflux_advection3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine InternalFlux_Advection3D_gpu_wrapper(flux, solution, velocity, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: solution type(c_ptr) :: velocity type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/internalflux_advection3d_gpu_wrapper.html"},{"title":"SideDiffusiveFlux_Advection3D_gpu_wrapper – SELF","text":"interface Called by interface~~sidediffusiveflux_advection3d_gpu_wrapper~~CalledByGraph interface~sidediffusiveflux_advection3d_gpu_wrapper SideDiffusiveFlux_Advection3D_gpu_wrapper proc~sideflux_advection3d SideFlux_Advection3D proc~sideflux_advection3d->interface~sidediffusiveflux_advection3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine SideDiffusiveFlux_Advection3D_gpu_wrapper(flux, boundarySolGradient, extSolGradient, nHat, nScale, diffusivity, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: boundarySolGradient type(c_ptr) :: extSolGradient type(c_ptr) :: nHat type(c_ptr) :: nScale real(kind=c_prec), VALUE :: diffusivity integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/sidediffusiveflux_advection3d_gpu_wrapper.html"},{"title":"SideFlux_Advection3D_gpu_wrapper – SELF","text":"interface Called by interface~~sideflux_advection3d_gpu_wrapper~~CalledByGraph interface~sideflux_advection3d_gpu_wrapper SideFlux_Advection3D_gpu_wrapper proc~sideflux_advection3d SideFlux_Advection3D proc~sideflux_advection3d->interface~sideflux_advection3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine SideFlux_Advection3D_gpu_wrapper(flux, boundarySol, extSol, velocity, nHat, nScale, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: boundarySol type(c_ptr) :: extSol type(c_ptr) :: velocity type(c_ptr) :: nHat type(c_ptr) :: nScale integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/sideflux_advection3d_gpu_wrapper.html"},{"title":"UpdateGRK3_Advection3D_gpu_wrapper – SELF","text":"interface Called by interface~~updategrk3_advection3d_gpu_wrapper~~CalledByGraph interface~updategrk3_advection3d_gpu_wrapper UpdateGRK3_Advection3D_gpu_wrapper proc~timesteprk3_advection3d TimeStepRK3_Advection3D proc~timesteprk3_advection3d->interface~updategrk3_advection3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine UpdateGRK3_Advection3D_gpu_wrapper(gRK3, solution, dSdt, rk3A, rk3G, dt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: gRK3 type(c_ptr) :: solution type(c_ptr) :: dSdt real(kind=c_prec), VALUE :: rk3A real(kind=c_prec), VALUE :: rk3G real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updategrk3_advection3d_gpu_wrapper.html"},{"title":"AbsMaxBoundary_Scalar1D – SELF","text":"public function AbsMaxBoundary_Scalar1D(scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar1D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:2) Contents Source Code AbsMaxBoundary_Scalar1D Source Code FUNCTION AbsMaxBoundary_Scalar1D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar1D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar , 1 : 2 ) ! Local INTEGER :: iEl , iVar , iSide absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iSide = 1 , 2 DO iVar = 1 , scalar % nVar absMax ( iVar , iSide ) = MAX ( ABS ( scalar % boundary % hostData ( iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END FUNCTION AbsMaxBoundary_Scalar1D","tags":"","loc":"proc/absmaxboundary_scalar1d.html"},{"title":"AbsMaxBoundary_Scalar2D – SELF","text":"public function AbsMaxBoundary_Scalar2D(scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar2D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:4) Contents Source Code AbsMaxBoundary_Scalar2D Source Code FUNCTION AbsMaxBoundary_Scalar2D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar2D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar , 1 : 4 ) ! Local INTEGER :: iEl , iVar , i , iSide absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iSide = 1 , 4 DO iVar = 1 , scalar % nVar DO i = 0 , scalar % N absMax ( iVar , iSide ) = MAX ( ABS ( scalar % boundary % hostData ( i , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Scalar2D","tags":"","loc":"proc/absmaxboundary_scalar2d.html"},{"title":"AbsMaxBoundary_Scalar3D – SELF","text":"public function AbsMaxBoundary_Scalar3D(scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar3D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:6) Contents Source Code AbsMaxBoundary_Scalar3D Source Code FUNCTION AbsMaxBoundary_Scalar3D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar3D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar , 1 : 6 ) ! Local INTEGER :: iEl , iVar , i , j , iSide absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iSide = 1 , 6 DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N absMax ( iVar , iSide ) = MAX ( ABS ( scalar % boundary % hostData ( i , j , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Scalar3D","tags":"","loc":"proc/absmaxboundary_scalar3d.html"},{"title":"AbsMaxBoundary_Tensor2D – SELF","text":"public function AbsMaxBoundary_Tensor2D(tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor2D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar,1:4) Contents Source Code AbsMaxBoundary_Tensor2D Source Code FUNCTION AbsMaxBoundary_Tensor2D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor2D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar , 1 : 4 ) ! Local INTEGER :: iEl , iVar , i , iSide , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iSide = 1 , 4 DO iVar = 1 , tensor % nVar DO i = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 absMax ( iVar , iSide ) = MAX ( ABS ( tensor % boundary % hostData ( row , col , i , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Tensor2D","tags":"","loc":"proc/absmaxboundary_tensor2d.html"},{"title":"AbsMaxBoundary_Tensor3D – SELF","text":"public function AbsMaxBoundary_Tensor3D(tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor3D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar,1:6) Contents Source Code AbsMaxBoundary_Tensor3D Source Code FUNCTION AbsMaxBoundary_Tensor3D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor3D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar , 1 : 6 ) ! Local INTEGER :: iEl , iVar , i , j , iSide , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iSide = 1 , 6 DO iVar = 1 , tensor % nVar DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 absMax ( iVar , iSide ) = MAX ( ABS ( tensor % boundary % hostData ( row , col , i , j , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Tensor3D","tags":"","loc":"proc/absmaxboundary_tensor3d.html"},{"title":"AbsMaxBoundary_Vector2D – SELF","text":"public function AbsMaxBoundary_Vector2D(vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector2D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar,1:4) Contents Source Code AbsMaxBoundary_Vector2D Source Code FUNCTION AbsMaxBoundary_Vector2D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector2D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar , 1 : 4 ) ! Local INTEGER :: iEl , iVar , i , iDir , iSide absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iSide = 1 , 4 DO iVar = 1 , vector % nVar DO i = 0 , vector % N DO iDir = 1 , 2 absMax ( iVar , iSide ) = MAX ( ABS ( vector % boundary % hostData ( iDir , i , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Vector2D","tags":"","loc":"proc/absmaxboundary_vector2d.html"},{"title":"AbsMaxBoundary_Vector3D – SELF","text":"public function AbsMaxBoundary_Vector3D(vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector3D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar,1:6) Contents Source Code AbsMaxBoundary_Vector3D Source Code FUNCTION AbsMaxBoundary_Vector3D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector3D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar , 1 : 6 ) ! Local INTEGER :: iEl , iVar , i , j , iSide , iDir absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iSide = 1 , 6 DO iVar = 1 , vector % nVar DO j = 0 , vector % N DO i = 0 , vector % N DO iDir = 1 , 3 absMax ( iVar , iSide ) = MAX ( ABS ( vector % boundary % hostData ( iDir , i , j , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Vector3D","tags":"","loc":"proc/absmaxboundary_vector3d.html"},{"title":"AbsMaxInterior_Scalar1D – SELF","text":"public function AbsMaxInterior_Scalar1D(scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar1D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) Contents Source Code AbsMaxInterior_Scalar1D Source Code FUNCTION AbsMaxInterior_Scalar1D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar1D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar ) ! Local INTEGER :: iEl , iVar , i absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO i = 0 , scalar % N absMax ( iVar ) = MAX ( ABS ( scalar % interior % hostData ( i , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END FUNCTION AbsMaxInterior_Scalar1D","tags":"","loc":"proc/absmaxinterior_scalar1d.html"},{"title":"AbsMaxInterior_Scalar2D – SELF","text":"public function AbsMaxInterior_Scalar2D(scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar2D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) Contents Source Code AbsMaxInterior_Scalar2D Source Code FUNCTION AbsMaxInterior_Scalar2D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar2D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar ) ! Local INTEGER :: iEl , iVar , i , j absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N absMax ( iVar ) = MAX ( ABS ( scalar % interior % hostData ( i , j , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Scalar2D","tags":"","loc":"proc/absmaxinterior_scalar2d.html"},{"title":"AbsMaxInterior_Scalar3D – SELF","text":"public function AbsMaxInterior_Scalar3D(scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar3D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) Contents Source Code AbsMaxInterior_Scalar3D Source Code FUNCTION AbsMaxInterior_Scalar3D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar3D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar ) ! Local INTEGER :: iEl , iVar , i , j , k absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N DO i = 0 , scalar % N absMax ( iVar ) = MAX ( ABS ( scalar % interior % hostData ( i , j , k , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Scalar3D","tags":"","loc":"proc/absmaxinterior_scalar3d.html"},{"title":"AbsMaxInterior_Tensor2D – SELF","text":"public function AbsMaxInterior_Tensor2D(tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor2D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar) Contents Source Code AbsMaxInterior_Tensor2D Source Code FUNCTION AbsMaxInterior_Tensor2D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor2D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar ) ! Local INTEGER :: iEl , iVar , i , j , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 absMax ( iVar ) = MAX ( ABS ( tensor % interior % hostData ( row , col , i , j , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Tensor2D","tags":"","loc":"proc/absmaxinterior_tensor2d.html"},{"title":"AbsMaxInterior_Tensor3D – SELF","text":"public function AbsMaxInterior_Tensor3D(tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor3D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar) Contents Source Code AbsMaxInterior_Tensor3D Source Code FUNCTION AbsMaxInterior_Tensor3D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor3D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar ) ! Local INTEGER :: iEl , iVar , i , j , k , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO k = 0 , tensor % N DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 absMax ( iVar ) = MAX ( ABS ( tensor % interior % hostData ( row , col , i , j , k , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Tensor3D","tags":"","loc":"proc/absmaxinterior_tensor3d.html"},{"title":"AbsMaxInterior_Vector2D – SELF","text":"public function AbsMaxInterior_Vector2D(vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector2D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar) Contents Source Code AbsMaxInterior_Vector2D Source Code FUNCTION AbsMaxInterior_Vector2D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector2D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar ) ! Local INTEGER :: iEl , iVar , i , j , iDir absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO j = 0 , vector % N DO i = 0 , vector % N DO iDir = 1 , 2 absMax ( iVar ) = MAX ( ABS ( vector % interior % hostData ( iDir , i , j , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Vector2D","tags":"","loc":"proc/absmaxinterior_vector2d.html"},{"title":"AbsMaxInterior_Vector3D – SELF","text":"public function AbsMaxInterior_Vector3D(vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector3D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar) Contents Source Code AbsMaxInterior_Vector3D Source Code FUNCTION AbsMaxInterior_Vector3D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector3D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar ) ! Local INTEGER :: iEl , iVar , i , j , k , iDir absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO k = 0 , vector % N DO j = 0 , vector % N DO i = 0 , vector % N DO iDir = 1 , 3 absMax ( iVar ) = MAX ( ABS ( vector % interior % hostData ( iDir , i , j , k , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Vector3D","tags":"","loc":"proc/absmaxinterior_vector3d.html"},{"title":"Add_Scalar1D – SELF","text":"public function Add_Scalar1D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) Contents Source Code Add_Scalar1D Source Code FUNCTION Add_Scalar1D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar1D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Scalar1D","tags":"","loc":"proc/add_scalar1d.html"},{"title":"Add_Scalar2D – SELF","text":"public function Add_Scalar2D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) Contents Source Code Add_Scalar2D Source Code FUNCTION Add_Scalar2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Scalar2D","tags":"","loc":"proc/add_scalar2d.html"},{"title":"Add_Scalar3D – SELF","text":"public function Add_Scalar3D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) Contents Source Code Add_Scalar3D Source Code FUNCTION Add_Scalar3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Scalar3D","tags":"","loc":"proc/add_scalar3d.html"},{"title":"Add_Tensor2D – SELF","text":"public function Add_Tensor2D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) Contents Source Code Add_Tensor2D Source Code FUNCTION Add_Tensor2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Tensor2D","tags":"","loc":"proc/add_tensor2d.html"},{"title":"Add_Tensor3D – SELF","text":"public function Add_Tensor3D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) Contents Source Code Add_Tensor3D Source Code FUNCTION Add_Tensor3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Tensor3D","tags":"","loc":"proc/add_tensor3d.html"},{"title":"Add_Vector2D – SELF","text":"public function Add_Vector2D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) Contents Source Code Add_Vector2D Source Code FUNCTION Add_Vector2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Vector2D","tags":"","loc":"proc/add_vector2d.html"},{"title":"Add_Vector3D – SELF","text":"public function Add_Vector3D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) Contents Source Code Add_Vector3D Source Code FUNCTION Add_Vector3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Vector3D","tags":"","loc":"proc/add_vector3d.html"},{"title":"Subtract_Scalar1D – SELF","text":"public function Subtract_Scalar1D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) Contents Source Code Subtract_Scalar1D Source Code FUNCTION Subtract_Scalar1D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar1D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Scalar1D","tags":"","loc":"proc/subtract_scalar1d.html"},{"title":"Subtract_Scalar2D – SELF","text":"public function Subtract_Scalar2D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) Contents Source Code Subtract_Scalar2D Source Code FUNCTION Subtract_Scalar2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Scalar2D","tags":"","loc":"proc/subtract_scalar2d.html"},{"title":"Subtract_Scalar3D – SELF","text":"public function Subtract_Scalar3D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) Contents Source Code Subtract_Scalar3D Source Code FUNCTION Subtract_Scalar3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Scalar3D","tags":"","loc":"proc/subtract_scalar3d.html"},{"title":"Subtract_Tensor2D – SELF","text":"public function Subtract_Tensor2D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) Contents Source Code Subtract_Tensor2D Source Code FUNCTION Subtract_Tensor2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Tensor2D","tags":"","loc":"proc/subtract_tensor2d.html"},{"title":"Subtract_Tensor3D – SELF","text":"public function Subtract_Tensor3D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) Contents Source Code Subtract_Tensor3D Source Code FUNCTION Subtract_Tensor3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Tensor3D","tags":"","loc":"proc/subtract_tensor3d.html"},{"title":"Subtract_Vector2D – SELF","text":"public function Subtract_Vector2D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) Contents Source Code Subtract_Vector2D Source Code FUNCTION Subtract_Vector2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Vector2D","tags":"","loc":"proc/subtract_vector2d.html"},{"title":"Subtract_Vector3D – SELF","text":"public function Subtract_Vector3D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) Contents Source Code Subtract_Vector3D Source Code FUNCTION Subtract_Vector3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Vector3D","tags":"","loc":"proc/subtract_vector3d.html"},{"title":"BoundaryInterp_Scalar1D – SELF","text":"public subroutine BoundaryInterp_Scalar1D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Scalar1D Source Code SUBROUTINE BoundaryInterp_Scalar1D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_1D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_1D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar1D","tags":"","loc":"proc/boundaryinterp_scalar1d.html"},{"title":"BoundaryInterp_Scalar2D – SELF","text":"public subroutine BoundaryInterp_Scalar2D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Scalar2D Source Code SUBROUTINE BoundaryInterp_Scalar2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar2D","tags":"","loc":"proc/boundaryinterp_scalar2d.html"},{"title":"BoundaryInterp_Scalar3D – SELF","text":"public subroutine BoundaryInterp_Scalar3D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Scalar3D Source Code SUBROUTINE BoundaryInterp_Scalar3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar3D","tags":"","loc":"proc/boundaryinterp_scalar3d.html"},{"title":"BoundaryInterp_Tensor2D – SELF","text":"public subroutine BoundaryInterp_Tensor2D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Tensor2D Source Code SUBROUTINE BoundaryInterp_Tensor2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Tensor2D","tags":"","loc":"proc/boundaryinterp_tensor2d.html"},{"title":"BoundaryInterp_Tensor3D – SELF","text":"public subroutine BoundaryInterp_Tensor3D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Tensor3D Source Code SUBROUTINE BoundaryInterp_Tensor3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Tensor3D","tags":"","loc":"proc/boundaryinterp_tensor3d.html"},{"title":"BoundaryInterp_Vector2D – SELF","text":"public subroutine BoundaryInterp_Vector2D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Vector2D Source Code SUBROUTINE BoundaryInterp_Vector2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Vector2D","tags":"","loc":"proc/boundaryinterp_vector2d.html"},{"title":"BoundaryInterp_Vector3D – SELF","text":"public subroutine BoundaryInterp_Vector3D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Vector3D Source Code SUBROUTINE BoundaryInterp_Vector3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Vector3D","tags":"","loc":"proc/boundaryinterp_vector3d.html"},{"title":"Curl_Vector2D – SELF","text":"public subroutine Curl_Vector2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Curl_Vector2D Source Code SUBROUTINE Curl_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorCurl_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorCurl_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Curl_Vector2D","tags":"","loc":"proc/curl_vector2d.html"},{"title":"Curl_Vector3D – SELF","text":"public subroutine Curl_Vector3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Curl_Vector3D Source Code SUBROUTINE Curl_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorCurl_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorCurl_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Curl_Vector3D","tags":"","loc":"proc/curl_vector3d.html"},{"title":"Derivative_Scalar1D – SELF","text":"public subroutine Derivative_Scalar1D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Derivative_Scalar1D Source Code SUBROUTINE Derivative_Scalar1D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar1D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % Derivative_1D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % Derivative_1D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Derivative_Scalar1D","tags":"","loc":"proc/derivative_scalar1d.html"},{"title":"Determinant_Tensor2D – SELF","text":"public subroutine Determinant_Tensor2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Calls proc~~determinant_tensor2d~~CallsGraph proc~determinant_tensor2d Determinant_Tensor2D interface~determinant_tensor2d_gpu_wrapper Determinant_Tensor2D_gpu_wrapper proc~determinant_tensor2d->interface~determinant_tensor2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Determinant_Tensor2D Source Code SUBROUTINE Determinant_Tensor2D ( SELFStorage , SELFout , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"Determinant_Tensor2D\" IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j IF ( gpuAccel ) THEN CALL Determinant_Tensor2D_gpu_wrapper ( SELFStorage % interior % deviceData , & SELFOut % interior % deviceData , & SELFStorage % N , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE DO iEl = 1 , SELFStorage % nElem DO iVar = 1 , SELFStorage % nVar DO j = 0 , SELFStorage % N DO i = 0 , SELFStorage % N SELFOut % interior % hostData ( i , j , iVar , iEl ) = SELFStorage % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE Determinant_Tensor2D","tags":"","loc":"proc/determinant_tensor2d.html"},{"title":"Determinant_Tensor3D – SELF","text":"public subroutine Determinant_Tensor3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Calls proc~~determinant_tensor3d~~CallsGraph proc~determinant_tensor3d Determinant_Tensor3D interface~determinant_tensor3d_gpu_wrapper Determinant_Tensor3D_gpu_wrapper proc~determinant_tensor3d->interface~determinant_tensor3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Determinant_Tensor3D Source Code SUBROUTINE Determinant_Tensor3D ( SELFStorage , SELFOut , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"Determinant_Tensor3D\" IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k IF ( gpuAccel ) THEN CALL Determinant_Tensor3D_gpu_wrapper ( SELFStorage % interior % deviceData , & SELFOut % interior % deviceData , & SELFStorage % N , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE DO iEl = 1 , SELFStorage % nElem DO iVar = 1 , SELFStorage % nVar DO k = 0 , SELFStorage % N DO j = 0 , SELFStorage % N DO i = 0 , SELFStorage % N SELFOut % interior % hostData ( i , j , k , iVar , iEl ) = & SELFStorage % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl )) - & SELFStorage % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl )) + & SELFStorage % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl )) END DO END DO END DO END DO END DO END IF END SUBROUTINE Determinant_Tensor3D","tags":"","loc":"proc/determinant_tensor3d.html"},{"title":"Divergence_Tensor2D – SELF","text":"public subroutine Divergence_Tensor2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Divergence_Tensor2D Source Code SUBROUTINE Divergence_Tensor2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorDivergence_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorDivergence_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Divergence_Tensor2D","tags":"","loc":"proc/divergence_tensor2d.html"},{"title":"Divergence_Tensor3D – SELF","text":"public subroutine Divergence_Tensor3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Divergence_Tensor3D Source Code SUBROUTINE Divergence_Tensor3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorDivergence_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorDivergence_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Divergence_Tensor3D","tags":"","loc":"proc/divergence_tensor3d.html"},{"title":"Divergence_Vector2D – SELF","text":"public subroutine Divergence_Vector2D(SELFStorage, SELFOut, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Divergence_Vector2D Source Code SUBROUTINE Divergence_Vector2D ( SELFStorage , SELFOut , dForm , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDGDivergence_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundaryNormal % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDGDivergence_2D ( SELFStorage % interior % hostData , & SELFStorage % boundaryNormal % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDivergence_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDivergence_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END IF END SUBROUTINE Divergence_Vector2D","tags":"","loc":"proc/divergence_vector2d.html"},{"title":"Divergence_Vector3D – SELF","text":"public subroutine Divergence_Vector3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Divergence_Vector3D Source Code SUBROUTINE Divergence_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDivergence_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDivergence_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Divergence_Vector3D","tags":"","loc":"proc/divergence_vector3d.html"},{"title":"Equals_Scalar1D – SELF","text":"public subroutine Equals_Scalar1D(SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFOut type( Scalar1D ), intent(in) :: SELFin Contents Source Code Equals_Scalar1D Source Code SUBROUTINE Equals_Scalar1D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFOut TYPE ( Scalar1D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Scalar1D","tags":"","loc":"proc/equals_scalar1d.html"},{"title":"Equals_Scalar2D – SELF","text":"public subroutine Equals_Scalar2D(SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFOut type( Scalar2D ), intent(in) :: SELFin Contents Source Code Equals_Scalar2D Source Code SUBROUTINE Equals_Scalar2D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFOut TYPE ( Scalar2D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Scalar2D","tags":"","loc":"proc/equals_scalar2d.html"},{"title":"Equals_Scalar3D – SELF","text":"public subroutine Equals_Scalar3D(SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFOut type( Scalar3D ), intent(in) :: SELFin Contents Source Code Equals_Scalar3D Source Code SUBROUTINE Equals_Scalar3D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFOut TYPE ( Scalar3D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Scalar3D","tags":"","loc":"proc/equals_scalar3d.html"},{"title":"Equals_Tensor2D – SELF","text":"public subroutine Equals_Tensor2D(SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFOut type( Tensor2D ), intent(in) :: SELFin Contents Source Code Equals_Tensor2D Source Code SUBROUTINE Equals_Tensor2D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFOut TYPE ( Tensor2D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Tensor2D","tags":"","loc":"proc/equals_tensor2d.html"},{"title":"Equals_Tensor3D – SELF","text":"public subroutine Equals_Tensor3D(SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFOut type( Tensor3D ), intent(in) :: SELFin Contents Source Code Equals_Tensor3D Source Code SUBROUTINE Equals_Tensor3D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFOut TYPE ( Tensor3D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Tensor3D","tags":"","loc":"proc/equals_tensor3d.html"},{"title":"Equals_Vector2D – SELF","text":"public subroutine Equals_Vector2D(SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFOut type( Vector2D ), intent(in) :: SELFin Contents Source Code Equals_Vector2D Source Code SUBROUTINE Equals_Vector2D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFOut TYPE ( Vector2D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Vector2D","tags":"","loc":"proc/equals_vector2d.html"},{"title":"Equals_Vector3D – SELF","text":"public subroutine Equals_Vector3D(SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFOut type( Vector3D ), intent(in) :: SELFin Contents Source Code Equals_Vector3D Source Code SUBROUTINE Equals_Vector3D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFOut TYPE ( Vector3D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Vector3D","tags":"","loc":"proc/equals_vector3d.html"},{"title":"Free_Scalar1D – SELF","text":"public subroutine Free_Scalar1D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage Contents Source Code Free_Scalar1D Source Code SUBROUTINE Free_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () END SUBROUTINE Free_Scalar1D","tags":"","loc":"proc/free_scalar1d.html"},{"title":"Free_Scalar2D – SELF","text":"public subroutine Free_Scalar2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage Contents Source Code Free_Scalar2D Source Code SUBROUTINE Free_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () CALL SELFStorage % avgBoundary % Free () END SUBROUTINE Free_Scalar2D","tags":"","loc":"proc/free_scalar2d.html"},{"title":"Free_Scalar3D – SELF","text":"public subroutine Free_Scalar3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage Contents Source Code Free_Scalar3D Source Code SUBROUTINE Free_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () CALL SELFStorage % avgBoundary % Free () END SUBROUTINE Free_Scalar3D","tags":"","loc":"proc/free_scalar3d.html"},{"title":"Free_Tensor2D – SELF","text":"public subroutine Free_Tensor2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage Contents Source Code Free_Tensor2D Source Code SUBROUTINE Free_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () END SUBROUTINE Free_Tensor2D","tags":"","loc":"proc/free_tensor2d.html"},{"title":"Free_Tensor3D – SELF","text":"public subroutine Free_Tensor3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage Contents Source Code Free_Tensor3D Source Code SUBROUTINE Free_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % extBoundary % Free () END SUBROUTINE Free_Tensor3D","tags":"","loc":"proc/free_tensor3d.html"},{"title":"Free_Vector2D – SELF","text":"public subroutine Free_Vector2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage Contents Source Code Free_Vector2D Source Code SUBROUTINE Free_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % boundaryNormal % Free () CALL SELFStorage % extBoundary % Free () END SUBROUTINE Free_Vector2D","tags":"","loc":"proc/free_vector2d.html"},{"title":"Free_Vector3D – SELF","text":"public subroutine Free_Vector3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage Contents Source Code Free_Vector3D Source Code SUBROUTINE Free_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () CALL SELFStorage % boundaryNormal % Free () CALL SELFStorage % extBoundary % Free () END SUBROUTINE Free_Vector3D","tags":"","loc":"proc/free_vector3d.html"},{"title":"Gradient_Scalar2D – SELF","text":"public subroutine Gradient_Scalar2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Gradient_Scalar2D Source Code SUBROUTINE Gradient_Scalar2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGradient_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGradient_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Scalar2D","tags":"","loc":"proc/gradient_scalar2d.html"},{"title":"Gradient_Scalar3D – SELF","text":"public subroutine Gradient_Scalar3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Gradient_Scalar3D Source Code SUBROUTINE Gradient_Scalar3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGradient_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGradient_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Scalar3D","tags":"","loc":"proc/gradient_scalar3d.html"},{"title":"Gradient_Vector2D – SELF","text":"public subroutine Gradient_Vector2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Gradient_Vector2D Source Code SUBROUTINE Gradient_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGradient_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGradient_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Vector2D","tags":"","loc":"proc/gradient_vector2d.html"},{"title":"Gradient_Vector3D – SELF","text":"public subroutine Gradient_Vector3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Gradient_Vector3D Source Code SUBROUTINE Gradient_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGradient_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGradient_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Vector3D","tags":"","loc":"proc/gradient_vector3d.html"},{"title":"GridInterp_Scalar1D – SELF","text":"public subroutine GridInterp_Scalar1D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Scalar1D Source Code SUBROUTINE GridInterp_Scalar1D ( SELFStorage , SELFout , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar1D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_1D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_1D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar1D","tags":"","loc":"proc/gridinterp_scalar1d.html"},{"title":"GridInterp_Scalar2D – SELF","text":"public subroutine GridInterp_Scalar2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Scalar2D Source Code SUBROUTINE GridInterp_Scalar2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar2D","tags":"","loc":"proc/gridinterp_scalar2d.html"},{"title":"GridInterp_Scalar3D – SELF","text":"public subroutine GridInterp_Scalar3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Scalar3D Source Code SUBROUTINE GridInterp_Scalar3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar3D","tags":"","loc":"proc/gridinterp_scalar3d.html"},{"title":"GridInterp_Tensor2D – SELF","text":"public subroutine GridInterp_Tensor2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Tensor2D Source Code SUBROUTINE GridInterp_Tensor2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Tensor2D","tags":"","loc":"proc/gridinterp_tensor2d.html"},{"title":"GridInterp_Tensor3D – SELF","text":"public subroutine GridInterp_Tensor3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Tensor3D Source Code SUBROUTINE GridInterp_Tensor3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Tensor3D","tags":"","loc":"proc/gridinterp_tensor3d.html"},{"title":"GridInterp_Vector2D – SELF","text":"public subroutine GridInterp_Vector2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Vector2D Source Code SUBROUTINE GridInterp_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Vector2D","tags":"","loc":"proc/gridinterp_vector2d.html"},{"title":"GridInterp_Vector3D – SELF","text":"public subroutine GridInterp_Vector3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Vector3D Source Code SUBROUTINE GridInterp_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Vector3D","tags":"","loc":"proc/gridinterp_vector3d.html"},{"title":"Init_Scalar1D – SELF","text":"public subroutine Init_Scalar1D(SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar1D Source Code SUBROUTINE Init_Scalar1D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 1 , 1 / ), & upBound = ( / N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / nVar , 2 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / nVar , 2 , nElem / )) END SUBROUTINE Init_Scalar1D","tags":"","loc":"proc/init_scalar1d.html"},{"title":"Init_Scalar2D – SELF","text":"public subroutine Init_Scalar2D(SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar2D Source Code SUBROUTINE Init_Scalar2D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 0 , 1 , 1 / ), & upBound = ( / N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / N , nVar , 4 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / N , nVar , 4 , nElem / )) CALL SELFStorage % avgBoundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / N , nVar , 4 , nElem / )) END SUBROUTINE Init_Scalar2D","tags":"","loc":"proc/init_scalar2d.html"},{"title":"Init_Scalar3D – SELF","text":"public subroutine Init_Scalar3D(SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar3D Source Code SUBROUTINE Init_Scalar3D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) CALL SELFStorage % avgBoundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) END SUBROUTINE Init_Scalar3D","tags":"","loc":"proc/init_scalar3d.html"},{"title":"Init_Tensor2D – SELF","text":"public subroutine Init_Tensor2D(SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Tensor2D Source Code SUBROUTINE Init_Tensor2D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , nVar , 4 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , nVar , 4 , nElem / )) END SUBROUTINE Init_Tensor2D","tags":"","loc":"proc/init_tensor2d.html"},{"title":"Init_Tensor3D – SELF","text":"public subroutine Init_Tensor3D(SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Tensor3D Source Code SUBROUTINE Init_Tensor3D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , nVar , 6 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , nVar , 6 , nElem / )) END SUBROUTINE Init_Tensor3D","tags":"","loc":"proc/init_tensor3d.html"},{"title":"Init_Vector2D – SELF","text":"public subroutine Init_Vector2D(SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Vector2D Source Code SUBROUTINE Init_Vector2D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 / ), & upBound = ( / 2 , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , N , nVar , 4 , nElem / )) CALL SELFStorage % boundaryNormal % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / N , nVar , 4 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , N , nVar , 4 , nElem / )) END SUBROUTINE Init_Vector2D","tags":"","loc":"proc/init_vector2d.html"},{"title":"Init_Vector3D – SELF","text":"public subroutine Init_Vector3D(SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Vector3D Source Code SUBROUTINE Init_Vector3D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / 3 , N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , N , N , nVar , 6 , nElem / )) CALL SELFStorage % boundaryNormal % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) CALL SELFStorage % extBoundary % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , N , N , nVar , 6 , nElem / )) END SUBROUTINE Init_Vector3D","tags":"","loc":"proc/init_vector3d.html"},{"title":"UpdateDevice_Scalar1D – SELF","text":"public subroutine UpdateDevice_Scalar1D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Scalar1D Source Code SUBROUTINE UpdateDevice_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Scalar1D","tags":"","loc":"proc/updatedevice_scalar1d.html"},{"title":"UpdateDevice_Scalar2D – SELF","text":"public subroutine UpdateDevice_Scalar2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Scalar2D Source Code SUBROUTINE UpdateDevice_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () CALL SELFStorage % avgBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Scalar2D","tags":"","loc":"proc/updatedevice_scalar2d.html"},{"title":"UpdateDevice_Scalar3D – SELF","text":"public subroutine UpdateDevice_Scalar3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Scalar3D Source Code SUBROUTINE UpdateDevice_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () CALL SELFStorage % avgBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Scalar3D","tags":"","loc":"proc/updatedevice_scalar3d.html"},{"title":"UpdateDevice_Tensor2D – SELF","text":"public subroutine UpdateDevice_Tensor2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Tensor2D Source Code SUBROUTINE UpdateDevice_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Tensor2D","tags":"","loc":"proc/updatedevice_tensor2d.html"},{"title":"UpdateDevice_Tensor3D – SELF","text":"public subroutine UpdateDevice_Tensor3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Tensor3D Source Code SUBROUTINE UpdateDevice_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateDevice_Tensor3D","tags":"","loc":"proc/updatedevice_tensor3d.html"},{"title":"UpdateDevice_Vector2D – SELF","text":"public subroutine UpdateDevice_Vector2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Vector2D Source Code SUBROUTINE UpdateDevice_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % boundaryNormal % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Vector2D","tags":"","loc":"proc/updatedevice_vector2d.html"},{"title":"UpdateDevice_Vector3D – SELF","text":"public subroutine UpdateDevice_Vector3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Vector3D Source Code SUBROUTINE UpdateDevice_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () CALL SELFStorage % boundaryNormal % UpdateDevice () CALL SELFStorage % extBoundary % UpdateDevice () END SUBROUTINE UpdateDevice_Vector3D","tags":"","loc":"proc/updatedevice_vector3d.html"},{"title":"UpdateHost_Scalar1D – SELF","text":"public subroutine UpdateHost_Scalar1D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Scalar1D Source Code SUBROUTINE UpdateHost_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Scalar1D","tags":"","loc":"proc/updatehost_scalar1d.html"},{"title":"UpdateHost_Scalar2D – SELF","text":"public subroutine UpdateHost_Scalar2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Scalar2D Source Code SUBROUTINE UpdateHost_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () CALL SELFStorage % avgBoundary % UpdateHost () END SUBROUTINE UpdateHost_Scalar2D","tags":"","loc":"proc/updatehost_scalar2d.html"},{"title":"UpdateHost_Scalar3D – SELF","text":"public subroutine UpdateHost_Scalar3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Scalar3D Source Code SUBROUTINE UpdateHost_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () CALL SELFStorage % avgBoundary % UpdateHost () END SUBROUTINE UpdateHost_Scalar3D","tags":"","loc":"proc/updatehost_scalar3d.html"},{"title":"UpdateHost_Tensor2D – SELF","text":"public subroutine UpdateHost_Tensor2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Tensor2D Source Code SUBROUTINE UpdateHost_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Tensor2D","tags":"","loc":"proc/updatehost_tensor2d.html"},{"title":"UpdateHost_Tensor3D – SELF","text":"public subroutine UpdateHost_Tensor3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Tensor3D Source Code SUBROUTINE UpdateHost_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Tensor3D","tags":"","loc":"proc/updatehost_tensor3d.html"},{"title":"UpdateHost_Vector2D – SELF","text":"public subroutine UpdateHost_Vector2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Vector2D Source Code SUBROUTINE UpdateHost_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % boundaryNormal % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Vector2D","tags":"","loc":"proc/updatehost_vector2d.html"},{"title":"UpdateHost_Vector3D – SELF","text":"public subroutine UpdateHost_Vector3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Vector3D Source Code SUBROUTINE UpdateHost_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () CALL SELFStorage % boundaryNormal % UpdateHost () CALL SELFStorage % extBoundary % UpdateHost () END SUBROUTINE UpdateHost_Vector3D","tags":"","loc":"proc/updatehost_vector3d.html"},{"title":"Determinant_Tensor2D_gpu_wrapper – SELF","text":"interface Called by interface~~determinant_tensor2d_gpu_wrapper~~CalledByGraph interface~determinant_tensor2d_gpu_wrapper Determinant_Tensor2D_gpu_wrapper proc~determinant_tensor2d Determinant_Tensor2D proc~determinant_tensor2d->interface~determinant_tensor2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine Determinant_Tensor2D_gpu_wrapper(tensor_dev, detTensor_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor_dev type(c_ptr) :: detTensor_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/determinant_tensor2d_gpu_wrapper.html"},{"title":"Determinant_Tensor3D_gpu_wrapper – SELF","text":"interface Called by interface~~determinant_tensor3d_gpu_wrapper~~CalledByGraph interface~determinant_tensor3d_gpu_wrapper Determinant_Tensor3D_gpu_wrapper proc~determinant_tensor3d Determinant_Tensor3D proc~determinant_tensor3d->interface~determinant_tensor3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine Determinant_Tensor3D_gpu_wrapper(tensor_dev, detTensor_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor_dev type(c_ptr) :: detTensor_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/determinant_tensor3d_gpu_wrapper.html"},{"title":"LinearBlend – SELF","text":"public function LinearBlend(a) result(weights) Arguments Type Intent Optional Attributes Name real(kind=prec) :: a Return Value real(kind=prec)\n  (1:2) Called by proc~~linearblend~~CalledByGraph proc~linearblend LinearBlend proc~read_ismv2_mesh2d Read_ISMv2_Mesh2D proc~read_ismv2_mesh2d->proc~linearblend Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code LinearBlend Source Code FUNCTION LinearBlend ( a ) RESULT ( weights ) IMPLICIT NONE REAL ( prec ) :: a REAL ( prec ) :: weights ( 1 : 2 ) weights ( 1 ) = 0.5_prec * ( 1.0_prec - a ) weights ( 2 ) = 0.5_prec * ( 1.0_prec + a ) END FUNCTION LinearBlend","tags":"","loc":"proc/linearblend.html"},{"title":"Unidirectional – SELF","text":"public function Unidirectional(valLeft, valRight, a) result(P) Arguments Type Intent Optional Attributes Name real(kind=prec) :: valLeft (1:3) real(kind=prec) :: valRight (1:3) real(kind=prec) :: a Return Value real(kind=prec)\n  (1:3) Contents Source Code Unidirectional Source Code FUNCTION Unidirectional ( valLeft , valRight , a ) RESULT ( P ) ! ! =============================================================================================== ! ! DECLARATIONS IMPLICIT NONE REAL ( prec ) :: valLeft ( 1 : 3 ), valRight ( 1 : 3 ) REAL ( prec ) :: a REAL ( prec ) :: P ( 1 : 3 ) P = 0.5_prec * (( 1.0_prec - a ) * valLeft + ( 1.0_prec + a ) * valRight ) END FUNCTION Unidirectional","tags":"","loc":"proc/unidirectional.html"},{"title":"Free_Mesh1D – SELF","text":"public subroutine Free_Mesh1D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh Contents Source Code Free_Mesh1D Source Code SUBROUTINE Free_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nNodes = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % hopr_elemInfo % Free () CALL myMesh % hopr_nodeCoords % Free () CALL myMesh % hopr_globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh1D","tags":"","loc":"proc/free_mesh1d.html"},{"title":"Free_Mesh2D – SELF","text":"public subroutine Free_Mesh2D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh Contents Source Code Free_Mesh2D Source Code SUBROUTINE Free_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nNodes = 0 myMesh % nSides = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % hopr_elemInfo % Free () CALL myMesh % hopr_sideInfo % Free () CALL myMesh % self_sideInfo % Free () CALL myMesh % hopr_nodeCoords % Free () CALL myMesh % self_nodeCoords % Free () CALL myMesh % hopr_CGNSCornerMap % Free () CALL myMesh % hopr_globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh2D","tags":"","loc":"proc/free_mesh2d.html"},{"title":"Free_Mesh3D – SELF","text":"public subroutine Free_Mesh3D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh Contents Source Code Free_Mesh3D Source Code SUBROUTINE Free_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nSides = 0 myMesh % nNodes = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % hopr_elemInfo % Free () CALL myMesh % hopr_sideInfo % Free () CALL myMesh % self_sideInfo % Free () CALL myMesh % hopr_nodeCoords % Free () CALL myMesh % self_nodeCoords % Free () CALL myMesh % hopr_CGNSCornerMap % Free () CALL myMesh % hopr_globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh3D","tags":"","loc":"proc/free_mesh3d.html"},{"title":"GenerateConnectivity_Mesh2D – SELF","text":"public subroutine GenerateConnectivity_Mesh2D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh Calls proc~~generateconnectivity_mesh2d~~CallsGraph proc~generateconnectivity_mesh2d GenerateConnectivity_Mesh2D almostequal almostequal proc~generateconnectivity_mesh2d->almostequal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code GenerateConnectivity_Mesh2D Source Code SUBROUTINE GenerateConnectivity_Mesh2D ( myMesh ) #undef __FUNC__ #define __FUNC__ \"GenerateConnectivity_Mesh2D\" IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh ! Local INTEGER :: nid , unid , cnid , lnid , rnid INTEGER :: eid , sid , lsid , usid , gn1 , gn2 INTEGER :: key1 , key2 , e2 , s2 , e2gn1 INTEGER :: nUniqueSides , flip INTEGER :: side ( 1 : 2 , 1 : myMesh % nUniqueSides ) TYPE ( HashTable ) :: sideTable ! Set the globalNodeIDs !  > Nodes in the nodeCoords list are possibly repeated since elements may share common sides. When the sides are shared !    the nodeCoords have the same x,y values (to machine precision) myMesh % nUniqueNodes = 1 myMesh % hopr_globalNodeIDs % hostData ( 1 ) = 1 DO nid = 2 , myMesh % nNodes unid = myMesh % nUniqueNodes + 1 DO rnid = 1 , nid - 1 IF ( AlmostEqual ( myMesh % hopr_nodeCoords % hostData ( 1 , nid ), myMesh % hopr_nodeCoords % hostData ( 1 , rnid )) . AND . & AlmostEqual ( myMesh % hopr_nodeCoords % hostData ( 2 , nid ), myMesh % hopr_nodeCoords % hostData ( 2 , rnid ))) THEN unid = myMesh % hopr_globalNodeIDs % hostData ( rnid ) EXIT END IF END DO myMesh % hopr_globalNodeIDs % hostData ( nid ) = unid IF ( unid == myMesh % nUniqueNodes + 1 ) THEN myMesh % nUniqueNodes = myMesh % nUniqueNodes + 1 END IF END DO CALL sideTable % Init ( myMesh % nUniqueNodes ) ! Set the sideInfo sid = 1 nUniqueSides = 0 DO eid = 1 , myMesh % nElem DO lsid = 1 , 4 cnid = myMesh % hopr_CGNSSideMap % hostData ( 1 , lsid ) ! Local Corner ID lnid = myMesh % hopr_CGNSCornerMap % hostData ( cnid ) ! Reference to Local Node ID nid = myMesh % hopr_elemInfo % hostData ( 5 , eid ) + lnid ! Add the offSetIndNODE to get the hopr node id gn1 = myMesh % hopr_globalNodeIDs % hostData ( nid ) ! Get the global Node ID for n1 cnid = myMesh % hopr_CGNSSideMap % hostData ( 2 , lsid ) ! Local Corner ID lnid = myMesh % hopr_CGNSCornerMap % hostData ( cnid ) ! Reference to Local Node ID nid = myMesh % hopr_elemInfo % hostData ( 5 , eid ) + lnid ! Add the offSetIndNODE to get the hopr node id gn2 = myMesh % hopr_globalNodeIDs % hostData ( nid ) ! Get the global Node ID for n1 ! Fill side info for eid myMesh % self_sideInfo % hostData ( 1 , lsid , eid ) = selfLineNonlinear ! SideType myMesh % self_sideInfo % hostData ( 2 , lsid , eid ) = 0 ! Global Side ID myMesh % self_sideInfo % hostData ( 3 , lsid , eid ) = 0 ! Neighbor Element ID myMesh % self_sideInfo % hostData ( 4 , lsid , eid ) = 0 ! Encoding for neighbor side ID and flip (10*s2+flip) myMesh % self_sideInfo % hostData ( 5 , lsid , eid ) = 1 ! Boundary Condition ID key1 = MIN ( gn1 , gn2 ) key2 = MAX ( gn1 , gn2 ) IF ( sideTable % ContainsKeys ( key1 , key2 )) THEN ! Get e2, s2, and flip CALL sideTable % GetDataForKeys ( usid , key1 , key2 ) e2 = side ( 1 , usid ) s2 = side ( 2 , usid ) ! Calculate flip ! > Get the starting global node ID for the other element cnid = myMesh % hopr_CGNSSideMap % hostData ( 1 , s2 ) ! Local Corner ID lnid = myMesh % hopr_CGNSCornerMap % hostData ( cnid ) ! Reference to Local Node ID nid = myMesh % hopr_elemInfo % hostData ( 5 , e2 ) + lnid ! Add the offSetIndNODE to get the hopr node id e2gn1 = myMesh % hopr_globalNodeIDs % hostData ( nid ) ! Get the global Node ID for n1 flip = 0 IF ( e2gn1 /= gn1 ) THEN flip = 1 END IF ! Populate information for this element myMesh % self_sideInfo % hostData ( 2 , lsid , eid ) = usid ! Global Side ID myMesh % self_sideInfo % hostData ( 3 , lsid , eid ) = e2 ! Neighbor Element ID myMesh % self_sideInfo % hostData ( 4 , lsid , eid ) = 10 * s2 + flip ! Neighbor Element ID myMesh % self_sideInfo % hostData ( 5 , lsid , eid ) = 0 ! boundary condition id ! Population information for the other element myMesh % self_sideInfo % hostData ( 2 , s2 , e2 ) = usid ! Global Side ID myMesh % self_sideInfo % hostData ( 3 , s2 , e2 ) = eid ! Neighbor Element ID myMesh % self_sideInfo % hostData ( 4 , s2 , e2 ) = 10 * lsid + flip ! Neighbor Element ID myMesh % self_sideInfo % hostData ( 5 , s2 , e2 ) = 0 ! boundary condition id ELSE nUniqueSides = nUniqueSides + 1 side ( 1 , nUniqueSides ) = eid ! Store the element ID side ( 2 , nUniqueSides ) = lsid ! Store the local side ID ! Add the side to the hash table CALL sideTable % AddDataForKeys ( nUniqueSides , key1 , key2 ) END IF sid = sid + 1 END DO END DO CALL sideTable % Free () END SUBROUTINE GenerateConnectivity_Mesh2D","tags":"","loc":"proc/generateconnectivity_mesh2d.html"},{"title":"Init_Mesh1D – SELF","text":"public subroutine Init_Mesh1D(myMesh, nGeo, nElem, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nNodes integer, intent(in) :: nBCs Contents Source Code Init_Mesh1D Source Code SUBROUTINE Init_Mesh1D ( myMesh , nGeo , nElem , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs myMesh % nGeo = nGeo myMesh % nElem = nElem myMesh % nNodes = nNodes myMesh % nCornerNodes = nElem * 2 myMesh % nUniqueNodes = 0 myMesh % nBCs = nBCs CALL myMesh % hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nElem / )) CALL myMesh % hopr_nodeCoords % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) END SUBROUTINE Init_Mesh1D","tags":"","loc":"proc/init_mesh1d.html"},{"title":"Init_Mesh2D – SELF","text":"public subroutine Init_Mesh2D(myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs Contents Source Code Init_Mesh2D Source Code SUBROUTINE Init_Mesh2D ( myMesh , nGeo , nElem , nSides , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nSides INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs ! Local INTEGER :: i , j , l myMesh % nGeo = nGeo myMesh % nElem = nElem myMesh % nNodes = nNodes myMesh % nSides = nSides myMesh % nCornerNodes = 0 myMesh % nUniqueNodes = 0 myMesh % nUniqueSides = 0 myMesh % nBCs = nBCs CALL myMesh % hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nElem / )) CALL myMesh % self_sideInfo % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / 5 , 4 , nElem / )) CALL myMesh % hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nSides / )) CALL myMesh % hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , nNodes / )) CALL myMesh % self_nodeCoords % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / 2 , ( nGeo + 1 ) ** 2 , nElem / )) CALL myMesh % hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % hopr_CGNSCornerMap % Alloc ( loBound = 1 , & upBound = 4 ) CALL myMesh % hopr_CGNSSideMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , 4 / )) CALL myMesh % hopr_curveNodeMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , ( nGeo + 1 ) ** 2 / )) CALL myMesh % hopr_curveNodeMapInv % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / nGeo , nGeo / )) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation myMesh % hopr_CGNSCornerMap % hostData ( 1 ) = 1 myMesh % hopr_CGNSCornerMap % hostData ( 2 ) = nGeo + 1 myMesh % hopr_CGNSCornerMap % hostData ( 3 ) = ( nGeo + 1 ) ** 2 myMesh % hopr_CGNSCornerMap % hostData ( 4 ) = nGeo * ( nGeo + 1 ) + 1 l = 0 DO j = 0 , nGeo DO i = 0 , nGeo l = l + 1 myMesh % hopr_curveNodeMap % hostData ( 1 : 2 , l ) = ( / i , j / ) myMesh % hopr_curveNodeMapInv % hostData ( i , j ) = l END DO END DO ! Maps from local corner node id to CGNS side myMesh % hopr_CGNSSideMap % hostData ( 1 : 2 , 1 ) = ( / 1 , 2 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 2 , 2 ) = ( / 2 , 3 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 2 , 3 ) = ( / 4 , 3 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 2 , 4 ) = ( / 1 , 4 / ) END SUBROUTINE Init_Mesh2D","tags":"","loc":"proc/init_mesh2d.html"},{"title":"Init_Mesh3D – SELF","text":"public subroutine Init_Mesh3D(myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs Contents Source Code Init_Mesh3D Source Code SUBROUTINE Init_Mesh3D ( myMesh , nGeo , nElem , nSides , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nSides INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs ! Local INTEGER :: i , j , k , l myMesh % nElem = nElem myMesh % nGeo = nGeo myMesh % nSides = nSides myMesh % nNodes = nNodes myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = nBCs CALL myMesh % hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nElem / )) CALL myMesh % hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nSides / )) CALL myMesh % self_sideInfo % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / 5 , 6 , nElem / )) CALL myMesh % hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , nNodes / )) CALL myMesh % self_nodeCoords % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / 3 , ( nGeo + 1 ) ** 3 , nElem / )) CALL myMesh % hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % hopr_CGNSCornerMap % Alloc ( loBound = 1 , & upBound = 8 ) CALL myMesh % hopr_CGNSSideMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , 6 / )) CALL myMesh % hopr_curveNodeMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , ( nGeo + 1 ) ** 3 / )) CALL myMesh % hopr_curveNodeMapInv % Alloc ( loBound = ( / 0 , 0 , 0 / ), & upBound = ( / nGeo , nGeo , nGeo / )) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation myMesh % hopr_CGNSCornerMap % hostData ( 1 ) = 1 myMesh % hopr_CGNSCornerMap % hostData ( 2 ) = nGeo + 1 myMesh % hopr_CGNSCornerMap % hostData ( 3 ) = ( nGeo + 1 ) ** 2 myMesh % hopr_CGNSCornerMap % hostData ( 4 ) = nGeo * ( nGeo + 1 ) + 1 myMesh % hopr_CGNSCornerMap % hostData ( 5 ) = nGeo * ( nGeo + 1 ) ** 2 + 1 myMesh % hopr_CGNSCornerMap % hostData ( 6 ) = nGeo * ( nGeo + 1 ) ** 2 + ( nGeo + 1 ) myMesh % hopr_CGNSCornerMap % hostData ( 7 ) = ( nGeo + 1 ) ** 3 myMesh % hopr_CGNSCornerMap % hostData ( 8 ) = nGeo * ( nGeo + 1 ) * ( nGeo + 2 ) + 1 l = 0 DO k = 0 , nGeo DO j = 0 , nGeo DO i = 0 , nGeo l = l + 1 myMesh % hopr_curveNodeMap % hostData ( 1 : 3 , l ) = ( / i , j , k / ) myMesh % hopr_curveNodeMapInv % hostData ( i , j , k ) = l END DO END DO END DO ! Maps from local corner node id to CGNS side myMesh % hopr_CGNSSideMap % hostData ( 1 : 4 , 1 ) = ( / 1 , 4 , 3 , 2 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 4 , 4 ) = ( / 3 , 4 , 8 , 7 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 4 , 5 ) = ( / 1 , 5 , 8 , 4 / ) myMesh % hopr_CGNSSideMap % hostData ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) END SUBROUTINE Init_Mesh3D","tags":"","loc":"proc/init_mesh3d.html"},{"title":"Load_Mesh2D_parallel – SELF","text":"public subroutine Load_Mesh2D_parallel(myMesh, myMeshSpec, decomp) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec type(MPILayer), intent(inout) :: decomp Calls proc~~load_mesh2d_parallel~~CallsGraph proc~load_mesh2d_parallel Load_Mesh2D_parallel error error proc~load_mesh2d_parallel->error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Load_Mesh2D_parallel Source Code SUBROUTINE Load_Mesh2D_parallel ( myMesh , myMeshSpec , decomp ) #undef __FUNC__ #define __FUNC__ \"Load_Mesh2D\" IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh TYPE ( MeshSpec ), INTENT ( in ) :: myMeshSpec TYPE ( MPILayer ), INTENT ( inout ) :: decomp IF ( myMeshSpec % blockMesh ) THEN IF ( decomp % nRanks > 1 ) THEN ! Error out ERROR ( \"Block Mesh only supported in serial\" ) STOP ! TO DO : Safe exit ELSE CALL myMesh % UniformBlockMesh ( myMeshSpec % blockMesh_nGeo , & ( / myMeshSpec % blockMesh_nElemX , myMeshSpec % blockMesh_nElemY / ), & ( / myMeshSpec % blockMesh_x0 , myMeshSpec % blockMesh_x1 , & myMeshSpec % blockMesh_y0 , myMeshSpec % blockMesh_y1 / )) END IF ELSE CALL myMesh % Read_HOPr ( myMeshSpec % filename , decomp ) END IF CALL myMesh % UpdateDevice () END SUBROUTINE Load_Mesh2D_parallel","tags":"","loc":"proc/load_mesh2d_parallel.html"},{"title":"Load_Mesh2D_serial – SELF","text":"public subroutine Load_Mesh2D_serial(myMesh, myMeshSpec) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec Contents Source Code Load_Mesh2D_serial Source Code SUBROUTINE Load_Mesh2D_serial ( myMesh , myMeshSpec ) #undef __FUNC__ #define __FUNC__ \"Load_Mesh2D\" IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh TYPE ( MeshSpec ), INTENT ( in ) :: myMeshSpec IF ( myMeshSpec % blockMesh ) THEN CALL myMesh % UniformBlockMesh ( myMeshSpec % blockMesh_nGeo , & ( / myMeshSpec % blockMesh_nElemX , myMeshSpec % blockMesh_nElemY / ), & ( / myMeshSpec % blockMesh_x0 , myMeshSpec % blockMesh_x1 , & myMeshSpec % blockMesh_y0 , myMeshSpec % blockMesh_y1 / )) ELSE IF ( myMeshSpec % fileType == SELF_MESH_ISM_V2_2D ) THEN CALL myMesh % Read_ISMv2 ( myMeshSpec % filename ) ELSEIF ( myMeshSpec % fileType == SELF_MESH_HOPR_2D ) THEN CALL myMesh % Read_HOPr ( myMeshSpec % filename ) ENDIF END IF CALL myMesh % UpdateDevice () END SUBROUTINE Load_Mesh2D_serial","tags":"","loc":"proc/load_mesh2d_serial.html"},{"title":"Load_Mesh3D_parallel – SELF","text":"public subroutine Load_Mesh3D_parallel(myMesh, myMeshSpec, decomp) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec type(MPILayer), intent(inout) :: decomp Calls proc~~load_mesh3d_parallel~~CallsGraph proc~load_mesh3d_parallel Load_Mesh3D_parallel error error proc~load_mesh3d_parallel->error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Load_Mesh3D_parallel Source Code SUBROUTINE Load_Mesh3D_parallel ( myMesh , myMeshSpec , decomp ) #undef __FUNC__ #define __FUNC__ \"Load_Mesh3D\" IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh TYPE ( MeshSpec ), INTENT ( in ) :: myMeshSpec TYPE ( MPILayer ), INTENT ( inout ) :: decomp IF ( myMeshSpec % blockMesh ) THEN IF ( decomp % nRanks > 1 ) THEN ! Error out ERROR ( \"Block Mesh only supported in serial\" ) STOP ! TO DO : Safe exit for serial and parallel ELSE CALL myMesh % UniformBlockMesh ( myMeshSpec % blockMesh_nGeo , & ( / myMeshSpec % blockMesh_nElemX , myMeshSpec % blockMesh_nElemY , myMeshSpec % blockMesh_nElemZ / ), & ( / myMeshSpec % blockMesh_x0 , myMeshSpec % blockMesh_x1 , & myMeshSpec % blockMesh_y0 , myMeshSpec % blockMesh_y1 , & myMeshSpec % blockMesh_z0 , myMeshSpec % blockMesh_z1 / )) END IF ELSE CALL myMesh % Read_HOPr ( myMeshSpec % filename , decomp ) END IF END SUBROUTINE Load_Mesh3D_parallel","tags":"","loc":"proc/load_mesh3d_parallel.html"},{"title":"Load_Mesh3D_serial – SELF","text":"public subroutine Load_Mesh3D_serial(myMesh, myMeshSpec) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec Contents Source Code Load_Mesh3D_serial Source Code SUBROUTINE Load_Mesh3D_serial ( myMesh , myMeshSpec ) #undef __FUNC__ #define __FUNC__ \"Load_Mesh3D\" IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh TYPE ( MeshSpec ), INTENT ( in ) :: myMeshSpec IF ( myMeshSpec % blockMesh ) THEN CALL myMesh % UniformBlockMesh ( myMeshSpec % blockMesh_nGeo , & ( / myMeshSpec % blockMesh_nElemX , myMeshSpec % blockMesh_nElemY , myMeshSpec % blockMesh_nElemZ / ), & ( / myMeshSpec % blockMesh_x0 , myMeshSpec % blockMesh_x1 , & myMeshSpec % blockMesh_y0 , myMeshSpec % blockMesh_y1 , & myMeshSpec % blockMesh_z0 , myMeshSpec % blockMesh_z1 / )) ELSE CALL myMesh % Read_HOPr ( myMeshSpec % filename ) END IF END SUBROUTINE Load_Mesh3D_serial","tags":"","loc":"proc/load_mesh3d_serial.html"},{"title":"Read_HOPr_Mesh1D_parallel – SELF","text":"public subroutine Read_HOPr_Mesh1D_parallel(myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh character, intent(in) :: meshFile type(MPILayer), intent(inout) :: decomp Calls proc~~read_hopr_mesh1d_parallel~~CallsGraph proc~read_hopr_mesh1d_parallel Read_HOPr_Mesh1D_parallel readattribute_hdf5 readattribute_hdf5 proc~read_hopr_mesh1d_parallel->readattribute_hdf5 readarray_hdf5 readarray_hdf5 proc~read_hopr_mesh1d_parallel->readarray_hdf5 close_hdf5 close_hdf5 proc~read_hopr_mesh1d_parallel->close_hdf5 open_hdf5 open_hdf5 proc~read_hopr_mesh1d_parallel->open_hdf5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Read_HOPr_Mesh1D_parallel Source Code SUBROUTINE Read_HOPr_Mesh1D_parallel ( myMesh , meshFile , decomp ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 ! Adapted for 1D Mesh : Note that HOPR does not have 1D mesh output. IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile TYPE ( MPILayer ), INTENT ( inout ) :: decomp ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) INTEGER :: nGlobalElem INTEGER :: firstElem , nLocalElems INTEGER :: firstNode , nLocalNodes INTEGER :: nGeo , nBCs TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfReal_r1 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId , decomp % mpiComm ) CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) CALL decomp % SetElemToRank ( nGlobalElem ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) offset (:) = 0 CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) ! Read local subarray of ElemInfo firstElem = decomp % offsetElem % hostData ( decomp % rankId ) + 1 nLocalElems = decomp % offsetElem % hostData ( decomp % rankId + 1 ) - & decomp % offsetElem % hostData ( decomp % rankId ) ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nLocalElems / )) offset = ( / 0 , firstElem - 1 / ) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo % hostData ( 5 , 1 ) + 1 nLocalNodes = hopr_elemInfo % hostData ( 6 , nLocalElems ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = 1 , & upBound = nLocalNodes ) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes ) gOffset = ( / firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , gOffset ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) CALL Close_HDF5 ( fileID ) CALL myMesh % Init ( nGeo , nLocalElems , nLocalNodes , nBCs ) ! Copy data from local arrays into myMesh myMesh % hopr_elemInfo = hopr_elemInfo myMesh % hopr_nodeCoords = hopr_nodeCoords myMesh % hopr_globalNodeIDs = hopr_globalNodeIDs CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () END SUBROUTINE Read_HOPr_Mesh1D_parallel","tags":"","loc":"proc/read_hopr_mesh1d_parallel.html"},{"title":"Read_HOPr_Mesh1D_serial – SELF","text":"public subroutine Read_HOPr_Mesh1D_serial(myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh character, intent(in) :: meshFile Calls proc~~read_hopr_mesh1d_serial~~CallsGraph proc~read_hopr_mesh1d_serial Read_HOPr_Mesh1D_serial readattribute_hdf5 readattribute_hdf5 proc~read_hopr_mesh1d_serial->readattribute_hdf5 readarray_hdf5 readarray_hdf5 proc~read_hopr_mesh1d_serial->readarray_hdf5 close_hdf5 close_hdf5 proc~read_hopr_mesh1d_serial->close_hdf5 open_hdf5 open_hdf5 proc~read_hopr_mesh1d_serial->open_hdf5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Read_HOPr_Mesh1D_serial Source Code SUBROUTINE Read_HOPr_Mesh1D_serial ( myMesh , meshFile ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 ! Adapted for 1D Mesh : Note that HOPR does not have 1D mesh output. IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId INTEGER :: nGlobalElem INTEGER :: nLocalNodes INTEGER :: nGeo , nBCs TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfReal_r1 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType ) ! Read local subarray of ElemInfo ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nGlobalElem / )) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs nLocalNodes = hopr_elemInfo % hostData ( 6 , nGlobalElem ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = 1 , & upBound = nLocalNodes ) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) CALL Close_HDF5 ( fileID ) CALL myMesh % Init ( nGeo , nGlobalElem , nLocalNodes , nBCs ) ! Copy data from local arrays into myMesh myMesh % hopr_elemInfo = hopr_elemInfo myMesh % hopr_nodeCoords = hopr_nodeCoords myMesh % hopr_globalNodeIDs = hopr_globalNodeIDs CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () END SUBROUTINE Read_HOPr_Mesh1D_serial","tags":"","loc":"proc/read_hopr_mesh1d_serial.html"},{"title":"Read_HOPr_Mesh2D_parallel – SELF","text":"public subroutine Read_HOPr_Mesh2D_parallel(myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh character, intent(in) :: meshFile type(MPILayer), intent(inout) :: decomp Calls proc~~read_hopr_mesh2d_parallel~~CallsGraph proc~read_hopr_mesh2d_parallel Read_HOPr_Mesh2D_parallel readattribute_hdf5 readattribute_hdf5 proc~read_hopr_mesh2d_parallel->readattribute_hdf5 readarray_hdf5 readarray_hdf5 proc~read_hopr_mesh2d_parallel->readarray_hdf5 close_hdf5 close_hdf5 proc~read_hopr_mesh2d_parallel->close_hdf5 open_hdf5 open_hdf5 proc~read_hopr_mesh2d_parallel->open_hdf5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Read_HOPr_Mesh2D_parallel Source Code SUBROUTINE Read_HOPr_Mesh2D_parallel ( myMesh , meshFile , decomp ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 ! Adapted for 2D Mesh : Note that HOPR does not have 2D mesh output. IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile TYPE ( MPILayer ), INTENT ( inout ) :: decomp ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) INTEGER :: nGlobalElem INTEGER :: firstElem , nLocalElems INTEGER :: firstNode , nLocalNodes INTEGER :: firstSide , nLocalSides INTEGER :: nGeo , nBCs INTEGER :: eid , lsid , iSide TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId , decomp % mpiComm ) CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) offset (:) = 0 CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) ! Read local subarray of ElemInfo CALL decomp % SetElemToRank ( nGlobalElem ) firstElem = decomp % offsetElem % hostData ( decomp % rankId ) + 1 nLocalElems = decomp % offsetElem % hostData ( decomp % rankId + 1 ) - & decomp % offsetElem % hostData ( decomp % rankId ) ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nLocalElems / )) offset = ( / 0 , firstElem - 1 / ) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo % hostData ( 5 , 1 ) + 1 nLocalNodes = hopr_elemInfo % hostData ( 6 , nLocalElems ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , nLocalNodes / )) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes ) offset = ( / 0 , firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) ! Read local subarray of SideInfo firstSide = hopr_elemInfo % hostData ( 3 , 1 ) + 1 nLocalSides = hopr_elemInfo % hostData ( 4 , nLocalElems ) - hopr_elemInfo % hostData ( 3 , 1 ) ! Allocate space for hopr_sideInfo CALL hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nLocalSides / )) offset = ( / 0 , firstSide - 1 / ) CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) CALL Close_HDF5 ( fileID ) CALL myMesh % Init ( nGeo , nLocalElems , nLocalSides , nLocalNodes , nBCs ) ! Copy data from local arrays into myMesh myMesh % hopr_elemInfo = hopr_elemInfo myMesh % hopr_nodeCoords = hopr_nodeCoords myMesh % hopr_globalNodeIDs = hopr_globalNodeIDs myMesh % hopr_sideInfo = hopr_sideInfo iSide = 0 DO eid = 1 , myMesh % nElem DO lsid = 1 , 4 iSide = iSide + 1 myMesh % self_sideInfo % hostData ( 1 : 5 , lsid , eid ) = myMesh % hopr_sideInfo % hostData ( 1 : 5 , iSide ) ENDDO ENDDO CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () CALL hopr_sideInfo % Free () END SUBROUTINE Read_HOPr_Mesh2D_parallel","tags":"","loc":"proc/read_hopr_mesh2d_parallel.html"},{"title":"Read_HOPr_Mesh2D_serial – SELF","text":"public subroutine Read_HOPr_Mesh2D_serial(myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh character, intent(in) :: meshFile Calls proc~~read_hopr_mesh2d_serial~~CallsGraph proc~read_hopr_mesh2d_serial Read_HOPr_Mesh2D_serial readattribute_hdf5 readattribute_hdf5 proc~read_hopr_mesh2d_serial->readattribute_hdf5 readarray_hdf5 readarray_hdf5 proc~read_hopr_mesh2d_serial->readarray_hdf5 close_hdf5 close_hdf5 proc~read_hopr_mesh2d_serial->close_hdf5 open_hdf5 open_hdf5 proc~read_hopr_mesh2d_serial->open_hdf5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Read_HOPr_Mesh2D_serial Source Code SUBROUTINE Read_HOPr_Mesh2D_serial ( myMesh , meshFile ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 ! Adapted for 2D Mesh : Note that HOPR does not have 2D mesh output. IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId INTEGER :: nGlobalElem INTEGER :: nLocalNodes INTEGER :: nLocalSides INTEGER :: nGeo , nBCs INTEGER :: eid , lsid , iSide TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType ) ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nGlobalElem / )) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs nLocalNodes = hopr_elemInfo % hostData ( 6 , nGlobalElem ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , nLocalNodes / )) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) ! Read local subarray of SideInfo nLocalSides = hopr_elemInfo % hostData ( 4 , nGlobalElem ) - hopr_elemInfo % hostData ( 3 , 1 ) ! Allocate space for hopr_sideInfo CALL hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nLocalSides / )) CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) CALL Close_HDF5 ( fileID ) CALL myMesh % Init ( nGeo , nGlobalElem , nLocalSides , nLocalNodes , nBCs ) ! Copy data from local arrays into myMesh myMesh % hopr_elemInfo = hopr_elemInfo myMesh % hopr_nodeCoords = hopr_nodeCoords myMesh % hopr_globalNodeIDs = hopr_globalNodeIDs myMesh % hopr_sideInfo = hopr_sideInfo iSide = 0 DO eid = 1 , myMesh % nElem DO lsid = 1 , 4 iSide = iSide + 1 myMesh % self_sideInfo % hostData ( 1 : 5 , lsid , eid ) = myMesh % hopr_sideInfo % hostData ( 1 : 5 , iSide ) ENDDO ENDDO CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () CALL hopr_sideInfo % Free () END SUBROUTINE Read_HOPr_Mesh2D_serial","tags":"","loc":"proc/read_hopr_mesh2d_serial.html"},{"title":"Read_HOPr_Mesh3D_parallel – SELF","text":"public subroutine Read_HOPr_Mesh3D_parallel(myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh character, intent(in) :: meshFile type(MPILayer), intent(inout) :: decomp Calls proc~~read_hopr_mesh3d_parallel~~CallsGraph proc~read_hopr_mesh3d_parallel Read_HOPr_Mesh3D_parallel readattribute_hdf5 readattribute_hdf5 proc~read_hopr_mesh3d_parallel->readattribute_hdf5 readarray_hdf5 readarray_hdf5 proc~read_hopr_mesh3d_parallel->readarray_hdf5 close_hdf5 close_hdf5 proc~read_hopr_mesh3d_parallel->close_hdf5 open_hdf5 open_hdf5 proc~read_hopr_mesh3d_parallel->open_hdf5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Read_HOPr_Mesh3D_parallel Source Code SUBROUTINE Read_HOPr_Mesh3D_parallel ( myMesh , meshFile , decomp ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile TYPE ( MPILayer ), INTENT ( inout ) :: decomp ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: offset ( 1 : 2 ), gOffset ( 1 ) INTEGER :: nGlobalElem INTEGER :: firstElem , nLocalElems INTEGER :: firstNode , nLocalNodes INTEGER :: firstSide , nLocalSides INTEGER :: nGeo , nBCs INTEGER :: eid , lsid , iSide TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId , decomp % mpiComm ) CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) offset (:) = 0 CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType , offset ) ! Read local subarray of ElemInfo CALL decomp % SetElemToRank ( nGlobalElem ) firstElem = decomp % offsetElem % hostData ( decomp % rankId ) + 1 nLocalElems = decomp % offsetElem % hostData ( decomp % rankId + 1 ) - & decomp % offsetElem % hostData ( decomp % rankId ) ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nLocalElems / )) offset = ( / 0 , firstElem - 1 / ) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo , offset ) ! Read local subarray of NodeCoords and GlobalNodeIDs firstNode = hopr_elemInfo % hostData ( 5 , 1 ) + 1 nLocalNodes = hopr_elemInfo % hostData ( 6 , nLocalElems ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , nLocalNodes / )) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes ) offset = ( / 0 , firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords , offset ) gOffset = ( / firstNode - 1 / ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs , gOffset ) ! Read local subarray of SideInfo firstSide = hopr_elemInfo % hostData ( 3 , 1 ) + 1 nLocalSides = hopr_elemInfo % hostData ( 4 , nLocalElems ) - hopr_elemInfo % hostData ( 3 , 1 ) ! Allocate space for hopr_sideInfo CALL hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nLocalSides / )) offset = ( / 0 , firstSide - 1 / ) CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo , offset ) CALL Close_HDF5 ( fileID ) CALL myMesh % Init ( nGeo , nLocalElems , nLocalSides , nLocalNodes , nBCs ) ! Copy data from local arrays into myMesh myMesh % hopr_elemInfo = hopr_elemInfo myMesh % hopr_nodeCoords = hopr_nodeCoords myMesh % hopr_globalNodeIDs = hopr_globalNodeIDs myMesh % hopr_sideInfo = hopr_sideInfo iSide = 0 DO eid = 1 , myMesh % nElem DO lsid = 1 , 6 iSide = iSide + 1 myMesh % self_sideInfo % hostData ( 1 : 5 , lsid , eid ) = myMesh % hopr_sideInfo % hostData ( 1 : 5 , iSide ) ENDDO ENDDO CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () CALL hopr_sideInfo % Free () END SUBROUTINE Read_HOPr_Mesh3D_parallel","tags":"","loc":"proc/read_hopr_mesh3d_parallel.html"},{"title":"Read_HOPr_Mesh3D_serial – SELF","text":"public subroutine Read_HOPr_Mesh3D_serial(myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh character, intent(in) :: meshFile Calls proc~~read_hopr_mesh3d_serial~~CallsGraph proc~read_hopr_mesh3d_serial Read_HOPr_Mesh3D_serial readattribute_hdf5 readattribute_hdf5 proc~read_hopr_mesh3d_serial->readattribute_hdf5 readarray_hdf5 readarray_hdf5 proc~read_hopr_mesh3d_serial->readarray_hdf5 close_hdf5 close_hdf5 proc~read_hopr_mesh3d_serial->close_hdf5 open_hdf5 open_hdf5 proc~read_hopr_mesh3d_serial->open_hdf5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Read_HOPr_Mesh3D_serial Source Code SUBROUTINE Read_HOPr_Mesh3D_serial ( myMesh , meshFile ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 6 IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId INTEGER :: nGlobalElem INTEGER :: nLocalNodes INTEGER :: nLocalSides INTEGER :: nGeo , nBCs INTEGER :: eid , lsid , iSide TYPE ( hfInt32_r2 ) :: hopr_elemInfo TYPE ( hfInt32_r2 ) :: hopr_sideInfo TYPE ( hfReal_r2 ) :: hopr_nodeCoords TYPE ( hfInt32_r1 ) :: hopr_globalNodeIDs TYPE ( hfInt32_r2 ) :: bcType CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL ReadAttribute_HDF5 ( fileId , 'nElems' , nGlobalElem ) CALL ReadAttribute_HDF5 ( fileId , 'Ngeo' , nGeo ) CALL ReadAttribute_HDF5 ( fileId , 'nBCs' , nBCs ) ! Read BCType CALL bcType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) CALL ReadArray_HDF5 ( fileId , 'BCType' , bcType ) ! Allocate Space for hopr_elemInfo! CALL hopr_elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nGlobalElem / )) CALL ReadArray_HDF5 ( fileId , 'ElemInfo' , hopr_elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs nLocalNodes = hopr_elemInfo % hostData ( 6 , nGlobalElem ) - hopr_elemInfo % hostData ( 5 , 1 ) ! Allocate Space for hopr_nodeCoords and hopr_globalNodeIDs ! CALL hopr_nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , nLocalNodes / )) CALL hopr_globalNodeIDs % Alloc ( loBound = 1 , & upBound = nLocalNodes ) CALL ReadArray_HDF5 ( fileId , 'NodeCoords' , hopr_nodeCoords ) CALL ReadArray_HDF5 ( fileId , 'GlobalNodeIDs' , hopr_globalNodeIDs ) ! Read local subarray of SideInfo nLocalSides = hopr_elemInfo % hostData ( 4 , nGlobalElem ) - hopr_elemInfo % hostData ( 3 , 1 ) ! Allocate space for hopr_sideInfo CALL hopr_sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nLocalSides / )) CALL ReadArray_HDF5 ( fileId , 'SideInfo' , hopr_sideInfo ) CALL Close_HDF5 ( fileID ) CALL myMesh % Init ( nGeo , nGlobalElem , nLocalSides , nLocalNodes , nBCs ) ! Copy data from local arrays into myMesh myMesh % hopr_elemInfo = hopr_elemInfo myMesh % hopr_nodeCoords = hopr_nodeCoords myMesh % hopr_globalNodeIDs = hopr_globalNodeIDs myMesh % hopr_sideInfo = hopr_sideInfo iSide = 0 DO eid = 1 , myMesh % nElem DO lsid = 1 , 6 iSide = iSide + 1 myMesh % self_sideInfo % hostData ( 1 : 5 , lsid , eid ) = myMesh % hopr_sideInfo % hostData ( 1 : 5 , iSide ) ENDDO ENDDO CALL myMesh % UpdateDevice () CALL hopr_elemInfo % Free () CALL hopr_nodeCoords % Free () CALL hopr_globalNodeIDs % Free () CALL hopr_sideInfo % Free () END SUBROUTINE Read_HOPr_Mesh3D_serial","tags":"","loc":"proc/read_hopr_mesh3d_serial.html"},{"title":"Read_ISMv2_Mesh2D – SELF","text":"public subroutine Read_ISMv2_Mesh2D(myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh character, intent(in) :: meshFile Calls proc~~read_ismv2_mesh2d~~CallsGraph proc~read_ismv2_mesh2d Read_ISMv2_Mesh2D proc~linearblend LinearBlend proc~read_ismv2_mesh2d->proc~linearblend newunit newunit proc~read_ismv2_mesh2d->newunit error error proc~read_ismv2_mesh2d->error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Read_ISMv2_Mesh2D Source Code SUBROUTINE Read_ISMv2_Mesh2D ( myMesh , meshFile ) #undef __FUNC__ #define __FUNC__ \"Read_ISMv2_Mesh2D\" IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER :: nNodes , nSides , nElem , nGeo INTEGER :: lnid , nid , usid , lsid , sid , eid INTEGER :: fUnit INTEGER :: i , j CHARACTER ( 100 ) :: line CHARACTER ( 500 ) :: msg REAL ( prec ) :: x ( 1 : 3 ), x0 ( 1 : 2 ), x1 ( 1 : 2 ) REAL ( prec ) :: wSurf ( 1 : 2 ), eSurf ( 1 : 2 ), nSurf ( 1 : 2 ), sSurf ( 1 : 2 ) REAL ( prec ) :: P1 ( 1 : 2 ), P2 ( 1 : 2 ) REAL ( prec ) :: l1 ( 1 : 2 ), l2 ( 1 : 2 ) REAL ( prec ) :: se ( 1 : 2 ), sw ( 1 : 2 ), ne ( 1 : 2 ), nw ( 1 : 2 ) INTEGER :: bCurveFlag ( 1 : 4 ) TYPE ( Lagrange ) :: interp OPEN ( UNIT = NEWUNIT ( fUnit ), & FILE = TRIM ( meshFile ), & FORM = 'FORMATTED' , & STATUS = 'OLD' , & ACCESS = 'SEQUENTIAL' ) READ ( fUnit , * ) line IF ( TRIM ( line ) /= 'ISM-V2' ) THEN msg = 'Unrecognized file format : ' // TRIM ( line ) ERROR ( msg ) STOP END IF ! Number of Nodes, Number of Edges (sides; unique!), number of elements, polynomial degree of elements READ ( fUnit , * ) nNodes , nSides , nElem , nGeo ! HOHQMesh reports interpolant data on Chebyshev Lobatto points ! We want data to be interpolated to Legendre Gauss Lobatto points CALL interp % Init ( nGeo , CHEBYSHEV_GAUSS_LOBATTO , nGeo , GAUSS_LOBATTO ) ! When we initialize the mesh, we set nNodes=nElem*4*(nGeo+1)**2 and ! nSides = nElem*4 since we still use `nNodes` and `nSides` ! in the input correspond to the HOPR definitions of these ! variables. ! `nSides` in HOHQMesh corresponds to nUniqueSides in HOPR and SELF ! `nNodes` in HOHQMesh corresponds to nCornerNodes (unique) in HOPR and SELF CALL myMesh % Init ( nGeo , nElem , nElem * 4 , nElem * ( nGeo + 1 ) ** 2 , self_nBCsDefault ) myMesh % nUniqueSides = nSides myMesh % nCornerNodes = nNodes CALL myMesh % hohq_cornerNodes % Alloc (( / 1 , 1 / ), & ( / 2 , nNodes / )) CALL myMesh % hohq_sideInfo % Alloc (( / 1 , 1 / ), & ( / 6 , nSides / )) CALL myMesh % hohq_elemInfo % Alloc (( / 1 , 1 / ), & ( / 4 , nElem / )) CALL myMesh % hohq_sideCurves % Alloc (( / 1 , 0 , 1 , 1 / ), & ( / 2 , nGeo , 4 , nElem / )) DO nid = 1 , myMesh % nCornerNodes READ ( fUnit , * ) x myMesh % hohq_cornerNodes % hostData ( 1 : 2 , nid ) = x ( 1 : 2 ) END DO DO usid = 1 , myMesh % nUniqueSides READ ( fUnit , * ) myMesh % hohq_sideInfo % hostData ( 1 : 6 , usid ) END DO DO eid = 1 , myMesh % nElem READ ( fUnit , * ) myMesh % hohq_elemInfo % hostData ( 1 : 4 , eid ) READ ( fUnit , * ) bCurveFlag ( 1 : 4 ) DO lsid = 1 , 4 IF ( bCurveFlag ( lsid ) == 1 ) THEN DO i = 0 , nGeo READ ( fUnit , * ) x myMesh % hohq_sideCurves % hostData ( 1 : 2 , i , lsid , eid ) = x ( 1 : 2 ) END DO ELSE ! For non-polynomial sides, create the side curve through interpolation between corner nodes lnid = myMesh % hopr_CGNSSideMap % hostData ( 1 , lsid ) nid = myMesh % hohq_elemInfo % hostData ( lnid , eid ) x0 ( 1 : 2 ) = myMesh % hohq_cornerNodes % hostData ( 1 : 2 , nid ) lnid = myMesh % hopr_CGNSSideMap % hostData ( 2 , lsid ) nid = myMesh % hohq_elemInfo % hostData ( lnid , eid ) x1 ( 1 : 2 ) = myMesh % hohq_cornerNodes % hostData ( 1 : 2 , nid ) DO i = 0 , nGeo myMesh % hohq_sideCurves % hostData ( 1 : 2 , i , lsid , eid ) = 0.5_prec * ( & x0 ( 1 : 2 ) * ( 1.0_prec - interp % controlPoints % hostData ( i )) + & x1 ( 1 : 2 ) * ( interp % controlPoints % hostData ( i ) + 1.0_prec )) END DO END IF END DO READ ( fUnit , * ) line ! TO DO : Parse line for boundary conditions END DO CLOSE ( fUnit ) ! Fill in hopr_elemInfo ! To fill in the element info, we apply the assumption of a mesh with all quadrilateral elements ! with uniform polynomial order sid = 1 nid = 1 DO eid = 1 , myMesh % nElem myMesh % hopr_elemInfo % hostData ( 1 , eid ) = selfQuadLinear ! Element Type myMesh % hopr_elemInfo % hostData ( 2 , eid ) = 1 ! Element Zone myMesh % hopr_elemInfo % hostData ( 3 , eid ) = sid ! Side Index Start sid = sid + 4 myMesh % hopr_elemInfo % hostData ( 4 , eid ) = sid ! Side Index End myMesh % hopr_elemInfo % hostData ( 5 , eid ) = nid - 1 ! Node Index Start nid = nid + ( nGeo + 1 ) ** 2 myMesh % hopr_elemInfo % hostData ( 6 , eid ) = nid ! Node Index End END DO ! Generate the self_nodeCoords through transfinite interpolation with linear blending nid = 1 DO eid = 1 , myMesh % nElem lnid = 1 ! Evaluate for corner points of mapping. This requires computational coordinates ! that include -1 and 1 in each computational direction (e.g. Gauss Lobatto) sw = myMesh % hohq_sideCurves % hostData ( 1 : 2 , 0 , 1 , eid ) se = myMesh % hohq_sideCurves % hostData ( 1 : 2 , nGeo , 1 , eid ) ne = myMesh % hohq_sideCurves % hostData ( 1 : 2 , nGeo , 3 , eid ) nw = myMesh % hohq_sideCurves % hostData ( 1 : 2 , 0 , 3 , eid ) DO j = 0 , nGeo wSurf = myMesh % hohq_sideCurves % hostData ( 1 : 2 , j , 4 , eid ) eSurf = myMesh % hohq_sideCurves % hostData ( 1 : 2 , j , 2 , eid ) l2 = LinearBlend ( interp % controlPoints % hostData ( j )) DO i = 0 , nGeo sSurf = myMesh % hohq_sideCurves % hostData ( 1 : 2 , i , 1 , eid ) nSurf = myMesh % hohq_sideCurves % hostData ( 1 : 2 , i , 3 , eid ) l1 = LinearBlend ( interp % controlPoints % hostData ( i )) P1 = l1 ( 1 ) * wSurf + l1 ( 2 ) * eSurf P2 = l2 ( 1 ) * sSurf + l2 ( 2 ) * nSurf ! Apply transfinite interpolation with linear blending myMesh % self_nodeCoords % hostData ( 1 : 2 , lnid , eid ) = P1 + P2 - & l1 ( 1 ) * ( l2 ( 1 ) * sw + l2 ( 2 ) * nw ) - l1 ( 2 ) * ( l2 ( 1 ) * se + l2 ( 2 ) * ne ) myMesh % hopr_nodeCoords % hostData ( 1 : 2 , nid ) = myMesh % self_nodeCoords % hostData ( 1 : 2 , lnid , eid ) ! Increment node ids nid = nid + 1 lnid = lnid + 1 END DO END DO END DO CALL myMesh % GenerateConnectivity () CALL interp % Free () END SUBROUTINE Read_ISMv2_Mesh2D","tags":"","loc":"proc/read_ismv2_mesh2d.html"},{"title":"UniformBlockMesh_Mesh1D – SELF","text":"public subroutine UniformBlockMesh_Mesh1D(myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem real(kind=prec), intent(in) :: x (1:2) Calls proc~~uniformblockmesh_mesh1d~~CallsGraph proc~uniformblockmesh_mesh1d UniformBlockMesh_Mesh1D uniformpoints uniformpoints proc~uniformblockmesh_mesh1d->uniformpoints Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UniformBlockMesh_Mesh1D Source Code SUBROUTINE UniformBlockMesh_Mesh1D ( myMesh , nGeo , nElem , x ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem REAL ( prec ), INTENT ( in ) :: x ( 1 : 2 ) ! Local INTEGER :: iel INTEGER :: nid , nNodes INTEGER :: i REAL ( prec ) :: xU ( 1 : nElem + 1 ) TYPE ( Scalar1D ) :: xLinear TYPE ( Scalar1D ) :: xGeo nNodes = nElem * ( nGeo + 1 ) CALL myMesh % Init ( nGeo , nElem , nNodes , 2 ) ! Set the hopr_nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem + 1 ) ! Create a linear interpolant to interpolate to nGeo grid CALL xLinear % Init ( 1 , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nElem ) CALL xGeo % Init ( nGeo , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nElem ) DO iel = 1 , nElem xLinear % interior % hostData ( 0 : 1 , 1 , iel ) = xU ( iel : iel + 1 ) END DO CALL xLinear % GridInterp ( xGeo ,. FALSE .) ! Set the element information nid = 1 DO iel = 1 , nElem myMesh % hopr_elemInfo % hostData ( 1 , iel ) = selfLineLinear ! Element Type myMesh % hopr_elemInfo % hostData ( 2 , iel ) = 1 ! Element Zone myMesh % hopr_elemInfo % hostData ( 3 , iel ) = nid ! Node Index Start DO i = 0 , nGeo myMesh % hopr_nodeCoords % hostData ( nid ) = xGeo % interior % hostData ( i , 1 , iel ) nid = nid + 1 END DO myMesh % hopr_elemInfo % hostData ( 4 , iel ) = nid - 1 ! Node Index End END DO CALL myMesh % UpdateDevice () CALL xLinear % Free () CALL xGeo % Free () END SUBROUTINE UniformBlockMesh_Mesh1D","tags":"","loc":"proc/uniformblockmesh_mesh1d.html"},{"title":"UniformBlockMesh_Mesh2D – SELF","text":"public subroutine UniformBlockMesh_Mesh2D(myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem (1:2) real(kind=prec), intent(in) :: x (1:4) Calls proc~~uniformblockmesh_mesh2d~~CallsGraph proc~uniformblockmesh_mesh2d UniformBlockMesh_Mesh2D uniformpoints uniformpoints proc~uniformblockmesh_mesh2d->uniformpoints Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UniformBlockMesh_Mesh2D Source Code SUBROUTINE UniformBlockMesh_Mesh2D ( myMesh , nGeo , nElem , x ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem ( 1 : 2 ) REAL ( prec ), INTENT ( in ) :: x ( 1 : 4 ) ! Local INTEGER :: iel , jel , nEl , elid INTEGER :: sid , nid , nNodes INTEGER :: nSides INTEGER :: i , j REAL ( prec ) :: xU ( 1 : nElem ( 1 ) + 1 ) REAL ( prec ) :: yU ( 1 : nElem ( 2 ) + 1 ) TYPE ( Vector2D ) :: xLinear TYPE ( Vector2D ) :: xGeo nEl = nElem ( 1 ) * nElem ( 2 ) nNodes = nEl * ( nGeo + 1 ) * ( nGeo + 1 ) nSides = nEl * 4 CALL myMesh % Init ( nGeo , nEl , nSides , nNodes , 1 ) myMesh % nUniqueSides = ( nElem ( 1 ) + 1 ) * nElem ( 2 ) + ( nElem ( 2 ) + 1 ) * nElem ( 1 ) ! Set the hopr_nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem ( 1 ) + 1 ) yU = UniformPoints ( x ( 3 ), x ( 4 ), 1 , nElem ( 2 ) + 1 ) ! Create a linear interpolant to interpolate to nGeo grid CALL xLinear % Init ( 1 , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) CALL xGeo % Init ( nGeo , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) elid = 1 DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) ! x component xLinear % interior % hostData ( 1 , 0 : 1 , 0 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 1 , 1 , elid ) = xU ( iel : iel + 1 ) ! y component xLinear % interior % hostData ( 2 , 0 , 0 : 1 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 1 , 0 : 1 , 1 , elid ) = yU ( jel : jel + 1 ) ! Incremenent the element ID elid = elid + 1 END DO END DO CALL xLinear % GridInterp ( xGeo ,. FALSE .) ! Set the element information nid = 1 sid = 0 elid = 1 DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) myMesh % hopr_elemInfo % hostData ( 1 , elid ) = selfQuadLinear ! Element Type myMesh % hopr_elemInfo % hostData ( 2 , elid ) = 1 ! Element Zone myMesh % hopr_elemInfo % hostData ( 3 , elid ) = sid ! Side Index Start sid = sid + 4 myMesh % hopr_elemInfo % hostData ( 4 , elid ) = sid ! Side Index End myMesh % hopr_elemInfo % hostData ( 5 , elid ) = nid - 1 ! Node Index Start DO j = 0 , nGeo DO i = 0 , nGeo myMesh % hopr_nodeCoords % hostData ( 1 : 2 , nid ) = xGeo % interior % hostData ( 1 : 2 , i , j , 1 , elid ) nid = nid + 1 END DO END DO myMesh % hopr_elemInfo % hostData ( 6 , elid ) = nid ! Node Index End elid = elid + 1 END DO END DO CALL myMesh % GenerateConnectivity () CALL myMesh % UpdateDevice () CALL xLinear % Free () CALL xGeo % Free () END SUBROUTINE UniformBlockMesh_Mesh2D","tags":"","loc":"proc/uniformblockmesh_mesh2d.html"},{"title":"UniformBlockMesh_Mesh3D – SELF","text":"public subroutine UniformBlockMesh_Mesh3D(myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem (1:3) real(kind=prec), intent(in) :: x (1:6) Calls proc~~uniformblockmesh_mesh3d~~CallsGraph proc~uniformblockmesh_mesh3d UniformBlockMesh_Mesh3D uniformpoints uniformpoints proc~uniformblockmesh_mesh3d->uniformpoints Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UniformBlockMesh_Mesh3D Source Code SUBROUTINE UniformBlockMesh_Mesh3D ( myMesh , nGeo , nElem , x ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem ( 1 : 3 ) REAL ( prec ), INTENT ( in ) :: x ( 1 : 6 ) ! Local INTEGER :: iel , jel , kel , nEl , elid INTEGER :: sid , nid , nNodes INTEGER :: nSides INTEGER :: bcid INTEGER :: i , j , k INTEGER :: nbeid , nbsid , usid , lsid REAL ( prec ) :: xU ( 1 : nElem ( 1 ) + 1 ) REAL ( prec ) :: yU ( 1 : nElem ( 2 ) + 1 ) REAL ( prec ) :: zU ( 1 : nElem ( 3 ) + 1 ) TYPE ( Vector3D ) :: xLinear TYPE ( Vector3D ) :: xGeo nEl = nElem ( 1 ) * nElem ( 2 ) * nElem ( 3 ) nNodes = nEl * ( nGeo + 1 ) * ( nGeo + 1 ) * ( nGeo + 1 ) nSides = nEl * 6 CALL myMesh % Init ( nGeo , nEl , nSides , nNodes , 1 ) myMesh % nUniqueSides = ( nElem ( 1 ) + 1 ) * nElem ( 2 ) * nElem ( 3 ) + & ( nElem ( 2 ) + 1 ) * nElem ( 1 ) * nElem ( 3 ) + & ( nElem ( 3 ) + 1 ) * nElem ( 1 ) * nElem ( 2 ) ! Set the hopr_nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem ( 1 ) + 1 ) yU = UniformPoints ( x ( 3 ), x ( 4 ), 1 , nElem ( 2 ) + 1 ) zU = UniformPoints ( x ( 5 ), x ( 6 ), 1 , nElem ( 3 ) + 1 ) ! Create a linear interpolant to interpolate to nGeo grid CALL xLinear % Init ( 1 , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) CALL xGeo % Init ( nGeo , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) elid = 1 DO kel = 1 , nElem ( 3 ) DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) ! x component xLinear % interior % hostData ( 1 , 0 : 1 , 0 , 0 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 1 , 0 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 0 , 1 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 1 , 1 , 1 , elid ) = xU ( iel : iel + 1 ) ! y component xLinear % interior % hostData ( 2 , 0 , 0 : 1 , 0 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 1 , 0 : 1 , 0 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 0 , 0 : 1 , 1 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 1 , 0 : 1 , 1 , 1 , elid ) = yU ( jel : jel + 1 ) ! z component xLinear % interior % hostData ( 3 , 0 , 0 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) xLinear % interior % hostData ( 3 , 1 , 0 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) xLinear % interior % hostData ( 3 , 0 , 1 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) xLinear % interior % hostData ( 3 , 1 , 1 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) ! Incremenent the element ID elid = elid + 1 END DO END DO END DO CALL xLinear % GridInterp ( xGeo ,. FALSE .) ! Set the element information nid = 1 sid = 0 elid = 1 DO kel = 1 , nElem ( 3 ) DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) myMesh % hopr_elemInfo % hostData ( 1 , elid ) = selfQuadLinear ! Element Type myMesh % hopr_elemInfo % hostData ( 2 , elid ) = 1 ! Element Zone myMesh % hopr_elemInfo % hostData ( 3 , elid ) = sid ! Side Index Start sid = sid + 6 myMesh % hopr_elemInfo % hostData ( 4 , elid ) = sid ! Side Index End myMesh % hopr_elemInfo % hostData ( 5 , elid ) = nid - 1 ! Node Index Start DO k = 0 , nGeo DO j = 0 , nGeo DO i = 0 , nGeo myMesh % hopr_nodeCoords % hostData ( 1 : 3 , nid ) = xGeo % interior % hostData ( 1 : 3 , i , j , k , 1 , elid ) nid = nid + 1 END DO END DO END DO myMesh % hopr_elemInfo % hostData ( 6 , elid ) = nid ! Node Index End elid = elid + 1 END DO END DO END DO ! Set up the side info elid = 1 sid = 0 usid = 0 DO kel = 1 , nElem ( 3 ) DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) ! Bottom Face ! Local Side = 1 IF ( kel == 1 ) THEN sid = sid + 1 usid = usid + 1 ! unique side id myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = 0 ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 0 ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = self_BCDefault ! Boundary condition ID ELSE sid = sid + 1 nbeid = iel + nElem ( 1 ) * ( jel - 1 + nElem ( 2 ) * ( kel - 2 )) ! Get the element id for the element below nbsid = myMesh % hopr_elemInfo % hostData ( 3 , nbeid ) + selfSide3D_Top - 1 ! Get sid for the top face of the element below usid = myMesh % hopr_sideInfo % hostData ( 2 , nbsid ) ! Get the unique side address myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = nbeid ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 10 * selfSide3D_Top ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = 0 ! Boundary condition ID ENDIF ! South Face ! Local Side = 2 IF ( jel == 1 ) THEN sid = sid + 1 usid = usid + 1 ! unique side id myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = 0 ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 0 ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = self_BCDefault ! Boundary condition ID ELSE sid = sid + 1 nbeid = iel + nElem ( 1 ) * ( jel - 2 + nElem ( 2 ) * ( kel - 1 )) ! Get the element id for the element to the south nbsid = myMesh % hopr_elemInfo % hostData ( 3 , nbeid ) + selfSide3D_North - 1 ! Get sid for the north face of the element to  the south usid = myMesh % hopr_sideInfo % hostData ( 2 , nbsid ) ! Get the unique side address myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = nbeid ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 10 * selfSide3D_North ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = 0 ! Boundary condition ID ENDIF ! East Face ! Local Side = 3 sid = sid + 1 IF ( iel == nElem ( 1 )) THEN nbeid = 0 bcid = self_BCDefault ELSE nbeid = iel + 1 + nElem ( 1 ) * ( jel - 1 + nElem ( 2 ) * ( kel - 1 )) ! Get the element id for the element to the east bcid = 0 ENDIF usid = usid + 1 ! unique side id myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = nbeid ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 10 * selfSide3D_West ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = bcid ! Boundary condition ID ! North Face ! Local Side = 4 sid = sid + 1 IF ( jel == nElem ( 2 )) THEN nbeid = 0 bcid = self_BCDefault ELSE nbeid = iel + nElem ( 1 ) * ( jel + nElem ( 2 ) * ( kel - 1 )) ! Get the element id for the element to the north bcid = 0 ENDIF usid = usid + 1 ! unique side id myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = nbeid ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 10 * selfSide3D_South ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = bcid ! Boundary condition ID ! West Face ! Local Side = 5 IF ( iel == 1 ) THEN sid = sid + 1 usid = usid + 1 ! unique side id myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = 0 ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 0 ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = self_BCDefault ! Boundary condition ID ELSE sid = sid + 1 nbeid = iel - 1 + nElem ( 1 ) * ( jel - 1 + nElem ( 2 ) * ( kel - 1 )) ! Get the element id for the element to the west nbsid = myMesh % hopr_elemInfo % hostData ( 3 , nbeid ) + selfSide3D_East - 1 ! Get sid for the east face of the element to the west usid = myMesh % hopr_sideInfo % hostData ( 2 , nbsid ) ! Get the unique side address myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = nbeid ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 10 * selfSide3D_East ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = 0 ! Boundary condition ID ENDIF ! Top Face ! Local Side = 6 sid = sid + 1 IF ( kel == nElem ( 3 )) THEN nbeid = 0 bcid = self_BCDefault ELSE nbeid = iel + nElem ( 1 ) * ( jel - 1 + nElem ( 2 ) * ( kel )) ! Get the element id for the element above bcid = 0 ENDIF usid = usid + 1 ! unique side id myMesh % hopr_sideInfo % hostData ( 1 , sid ) = selfQuadLinear ! Side type set to linear quad myMesh % hopr_sideInfo % hostData ( 2 , sid ) = usid ! Unique side id myMesh % hopr_sideInfo % hostData ( 3 , sid ) = nbeid ! Neighbor Element ID (0=boundary) myMesh % hopr_sideInfo % hostData ( 4 , sid ) = 10 * selfSide3D_Bottom ! 10*nbLocalSide + flip myMesh % hopr_sideInfo % hostData ( 5 , sid ) = bcid ! Boundary condition ID ENDDO ENDDO ENDDO elid = 0 sid = 0 DO kel = 1 , nElem ( 3 ) DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) elid = elid + 1 DO lsid = 1 , 6 sid = sid + 1 myMesh % self_sideInfo % hostData ( 1 : 5 , lsid , elid ) = myMesh % hopr_sideInfo % hostData ( 1 : 5 , sid ) ENDDO ENDDO ENDDO ENDDO CALL myMesh % UpdateDevice () CALL xLinear % Free () CALL xGeo % Free () END SUBROUTINE UniformBlockMesh_Mesh3D","tags":"","loc":"proc/uniformblockmesh_mesh3d.html"},{"title":"UpdateDevice_Mesh1D – SELF","text":"public subroutine UpdateDevice_Mesh1D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh Contents Source Code UpdateDevice_Mesh1D Source Code SUBROUTINE UpdateDevice_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh CALL myMesh % hopr_elemInfo % UpdateDevice () CALL myMesh % hopr_nodeCoords % UpdateDevice () CALL myMesh % hopr_globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () END SUBROUTINE UpdateDevice_Mesh1D","tags":"","loc":"proc/updatedevice_mesh1d.html"},{"title":"UpdateDevice_Mesh2D – SELF","text":"public subroutine UpdateDevice_Mesh2D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh Contents Source Code UpdateDevice_Mesh2D Source Code SUBROUTINE UpdateDevice_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh CALL myMesh % hopr_elemInfo % UpdateDevice () CALL myMesh % hopr_sideInfo % UpdateDevice () CALL myMesh % self_sideInfo % UpdateDevice () CALL myMesh % hopr_nodeCoords % UpdateDevice () CALL myMesh % self_nodeCoords % UpdateDevice () CALL myMesh % hopr_globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () END SUBROUTINE UpdateDevice_Mesh2D","tags":"","loc":"proc/updatedevice_mesh2d.html"},{"title":"UpdateDevice_Mesh3D – SELF","text":"public subroutine UpdateDevice_Mesh3D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh Contents Source Code UpdateDevice_Mesh3D Source Code SUBROUTINE UpdateDevice_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh CALL myMesh % hopr_elemInfo % UpdateDevice () CALL myMesh % hopr_sideInfo % UpdateDevice () CALL myMesh % self_sideInfo % UpdateDevice () CALL myMesh % hopr_nodeCoords % UpdateDevice () CALL myMesh % self_nodeCoords % UpdateDevice () CALL myMesh % hopr_globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () END SUBROUTINE UpdateDevice_Mesh3D","tags":"","loc":"proc/updatedevice_mesh3d.html"},{"title":"UpdateHost_Mesh1D – SELF","text":"public subroutine UpdateHost_Mesh1D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh Contents Source Code UpdateHost_Mesh1D Source Code SUBROUTINE UpdateHost_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh CALL myMesh % hopr_elemInfo % UpdateHost () CALL myMesh % hopr_nodeCoords % UpdateHost () CALL myMesh % hopr_globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () END SUBROUTINE UpdateHost_Mesh1D","tags":"","loc":"proc/updatehost_mesh1d.html"},{"title":"UpdateHost_Mesh2D – SELF","text":"public subroutine UpdateHost_Mesh2D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh Contents Source Code UpdateHost_Mesh2D Source Code SUBROUTINE UpdateHost_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh CALL myMesh % hopr_elemInfo % UpdateHost () CALL myMesh % hopr_sideInfo % UpdateHost () CALL myMesh % self_sideInfo % UpdateHost () CALL myMesh % hopr_nodeCoords % UpdateHost () CALL myMesh % self_nodeCoords % UpdateHost () CALL myMesh % hopr_globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () END SUBROUTINE UpdateHost_Mesh2D","tags":"","loc":"proc/updatehost_mesh2d.html"},{"title":"UpdateHost_Mesh3D – SELF","text":"public subroutine UpdateHost_Mesh3D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh Contents Source Code UpdateHost_Mesh3D Source Code SUBROUTINE UpdateHost_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh CALL myMesh % hopr_elemInfo % UpdateHost () CALL myMesh % hopr_sideInfo % UpdateHost () CALL myMesh % self_sideInfo % UpdateHost () CALL myMesh % hopr_nodeCoords % UpdateHost () CALL myMesh % self_nodeCoords % UpdateHost () CALL myMesh % hopr_globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () END SUBROUTINE UpdateHost_Mesh3D","tags":"","loc":"proc/updatehost_mesh3d.html"},{"title":"Write_HOPr_Mesh1D – SELF","text":"public subroutine Write_HOPr_Mesh1D(myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh character, intent(in) :: meshFile Calls proc~~write_hopr_mesh1d~~CallsGraph proc~write_hopr_mesh1d Write_HOPr_Mesh1D writeattribute_hdf5 writeattribute_hdf5 proc~write_hopr_mesh1d->writeattribute_hdf5 writearray_hdf5 writearray_hdf5 proc~write_hopr_mesh1d->writearray_hdf5 close_hdf5 close_hdf5 proc~write_hopr_mesh1d->close_hdf5 open_hdf5 open_hdf5 proc~write_hopr_mesh1d->open_hdf5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Write_HOPr_Mesh1D Source Code SUBROUTINE Write_HOPr_Mesh1D ( myMesh , meshFile ) ! Writes mesh output in HOPR format (serial IO only) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL WriteAttribute_HDF5 ( fileId , 'nElems' , myMesh % nElem ) CALL WriteAttribute_HDF5 ( fileId , 'Ngeo' , myMesh % nGeo ) CALL WriteAttribute_HDF5 ( fileId , 'nBCs' , myMesh % nBCs ) CALL WriteArray_HDF5 ( fileId , 'BCType' , myMesh % bcType ) ! Read local subarray of ElemInfo CALL WriteArray_HDF5 ( fileId , 'ElemInfo' , myMesh % hopr_elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs CALL WriteArray_HDF5 ( fileId , 'NodeCoords' , myMesh % hopr_nodeCoords ) CALL WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , myMesh % hopr_globalNodeIDs ) CALL Close_HDF5 ( fileID ) END SUBROUTINE Write_HOPr_Mesh1D","tags":"","loc":"proc/write_hopr_mesh1d.html"},{"title":"Write_HOPr_Mesh2D – SELF","text":"public subroutine Write_HOPr_Mesh2D(myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh character, intent(in) :: meshFile Calls proc~~write_hopr_mesh2d~~CallsGraph proc~write_hopr_mesh2d Write_HOPr_Mesh2D writeattribute_hdf5 writeattribute_hdf5 proc~write_hopr_mesh2d->writeattribute_hdf5 writearray_hdf5 writearray_hdf5 proc~write_hopr_mesh2d->writearray_hdf5 close_hdf5 close_hdf5 proc~write_hopr_mesh2d->close_hdf5 open_hdf5 open_hdf5 proc~write_hopr_mesh2d->open_hdf5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Write_HOPr_Mesh2D Source Code SUBROUTINE Write_HOPr_Mesh2D ( myMesh , meshFile ) ! Writes mesh output in HOPR format (serial only) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL WriteAttribute_HDF5 ( fileId , 'nElems' , myMesh % nElem ) CALL WriteAttribute_HDF5 ( fileId , 'Ngeo' , myMesh % nGeo ) CALL WriteAttribute_HDF5 ( fileId , 'nBCs' , myMesh % nBCs ) CALL WriteArray_HDF5 ( fileId , 'BCType' , myMesh % bcType ) ! Write local subarray of ElemInfo CALL WriteArray_HDF5 ( fileId , 'ElemInfo' , myMesh % hopr_elemInfo ) ! Write local subarray of NodeCoords and GlobalNodeIDs CALL WriteArray_HDF5 ( fileId , 'NodeCoords' , myMesh % hopr_nodeCoords ) CALL WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , myMesh % hopr_globalNodeIDs ) ! Write local subarray of SideInfo CALL WriteArray_HDF5 ( fileId , 'SideInfo' , myMesh % hopr_sideInfo ) CALL Close_HDF5 ( fileID ) END SUBROUTINE Write_HOPr_Mesh2D","tags":"","loc":"proc/write_hopr_mesh2d.html"},{"title":"Write_HOPr_Mesh3D – SELF","text":"public subroutine Write_HOPr_Mesh3D(myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh character, intent(in) :: meshFile Calls proc~~write_hopr_mesh3d~~CallsGraph proc~write_hopr_mesh3d Write_HOPr_Mesh3D writeattribute_hdf5 writeattribute_hdf5 proc~write_hopr_mesh3d->writeattribute_hdf5 writearray_hdf5 writearray_hdf5 proc~write_hopr_mesh3d->writearray_hdf5 close_hdf5 close_hdf5 proc~write_hopr_mesh3d->close_hdf5 open_hdf5 open_hdf5 proc~write_hopr_mesh3d->open_hdf5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Write_HOPr_Mesh3D Source Code SUBROUTINE Write_HOPr_Mesh3D ( myMesh , meshFile ) ! Writes mesh output in HOPR format (serial only) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh CHARACTER ( * ), INTENT ( in ) :: meshFile ! Local INTEGER ( HID_T ) :: fileId CALL Open_HDF5 ( meshFile , H5F_ACC_RDWR_F , fileId ) CALL WriteAttribute_HDF5 ( fileId , 'nElems' , myMesh % nElem ) CALL WriteAttribute_HDF5 ( fileId , 'Ngeo' , myMesh % nGeo ) CALL WriteAttribute_HDF5 ( fileId , 'nBCs' , myMesh % nBCs ) CALL WriteArray_HDF5 ( fileId , 'BCType' , myMesh % bcType ) CALL WriteArray_HDF5 ( fileId , 'ElemInfo' , myMesh % hopr_elemInfo ) ! Read local subarray of NodeCoords and GlobalNodeIDs CALL WriteArray_HDF5 ( fileId , 'NodeCoords' , myMesh % hopr_nodeCoords ) CALL WriteArray_HDF5 ( fileId , 'GlobalNodeIDs' , myMesh % hopr_globalNodeIDs ) ! Read local subarray of SideInfo CALL WriteArray_HDF5 ( fileId , 'SideInfo' , myMesh % hopr_sideInfo ) CALL Close_HDF5 ( fileID ) END SUBROUTINE Write_HOPr_Mesh3D","tags":"","loc":"proc/write_hopr_mesh3d.html"},{"title":"DomainDecomp – SELF","text":"public subroutine DomainDecomp(nElems, nDomains, offsetElem) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nElems integer, intent(in) :: nDomains integer, intent(out) :: offsetElem (0:nDomains) Called by proc~~domaindecomp~~CalledByGraph proc~domaindecomp DomainDecomp proc~setelemtorank SetElemToRank proc~setelemtorank->proc~domaindecomp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code DomainDecomp Source Code SUBROUTINE DomainDecomp ( nElems , nDomains , offSetElem ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 4 IMPLICIT NONE INTEGER , INTENT ( in ) :: nElems INTEGER , INTENT ( in ) :: nDomains INTEGER , INTENT ( out ) :: offsetElem ( 0 : nDomains ) ! Local INTEGER :: nLocalElems INTEGER :: remainElems INTEGER :: iDom nLocalElems = nElems / nDomains remainElems = nElems - nLocalElems * nDomains DO iDom = 0 , nDomains - 1 offSetElem ( iDom ) = iDom * nLocalElems + MIN ( iDom , remainElems ) END DO offSetElem ( nDomains ) = nElems END SUBROUTINE DomainDecomp","tags":"","loc":"proc/domaindecomp.html"},{"title":"ElemToRank – SELF","text":"public subroutine ElemToRank(nDomains, offsetElem, elemID, domain) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDomains integer, intent(in) :: offsetElem (0:nDomains) integer, intent(in) :: elemID integer, intent(out) :: domain Called by proc~~elemtorank~~CalledByGraph proc~elemtorank ElemToRank proc~setelemtorank SetElemToRank proc~setelemtorank->proc~elemtorank Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ElemToRank Source Code SUBROUTINE ElemToRank ( nDomains , offsetElem , elemID , domain ) ! From https://www.hopr-project.org/externals/Meshformat.pdf, Algorithm 7 !   \"Find domain containing element index\" ! IMPLICIT NONE INTEGER , INTENT ( in ) :: nDomains INTEGER , INTENT ( in ) :: offsetElem ( 0 : nDomains ) INTEGER , INTENT ( in ) :: elemID INTEGER , INTENT ( out ) :: domain ! Local INTEGER :: maxSteps INTEGER :: low , up , mid INTEGER :: i domain = 0 maxSteps = INT ( LOG10 ( REAL ( nDomains )) / LOG10 ( 2.0 )) + 1 low = 0 up = nDomains - 1 IF ( offsetElem ( low ) < elemID . AND . elemID <= offsetElem ( low + 1 )) THEN domain = low ELSEIF ( offsetElem ( up ) < elemID . AND . elemID <= offsetElem ( up + 1 )) THEN domain = up ELSE DO i = 1 , maxSteps mid = ( up - low ) / 2 + low IF ( offsetElem ( mid ) < elemID . AND . elemID <= offsetElem ( mid + 1 )) THEN domain = mid RETURN ELSEIF ( elemID > offsetElem ( mid + 1 )) THEN low = mid + 1 ELSE up = mid END IF END DO END IF END SUBROUTINE ElemToRank","tags":"","loc":"proc/elemtorank.html"},{"title":"FinalizeMPIExchangeAsync – SELF","text":"public subroutine FinalizeMPIExchangeAsync(mpiHandler) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: mpiHandler Calls proc~~finalizempiexchangeasync~~CallsGraph proc~finalizempiexchangeasync FinalizeMPIExchangeAsync mpi_waitall mpi_waitall proc~finalizempiexchangeasync->mpi_waitall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code FinalizeMPIExchangeAsync Source Code SUBROUTINE FinalizeMPIExchangeAsync ( mpiHandler ) CLASS ( MPILayer ), INTENT ( inout ) :: mpiHandler ! Local INTEGER :: ierror CALL MPI_WaitAll ( mpiHandler % msgCount , & mpiHandler % requests % hostData ( 1 : mpiHandler % msgCount , 1 ), & mpiHandler % requests % hostData ( 1 : mpiHandler % msgCount , 2 ), & iError ) END SUBROUTINE FinalizeMPIExchangeAsync","tags":"","loc":"proc/finalizempiexchangeasync.html"},{"title":"Free_MPILayer – SELF","text":"public subroutine Free_MPILayer(this) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this Contents Source Code Free_MPILayer Source Code SUBROUTINE Free_MPILayer ( this ) IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this CALL this % offSetElem % Free () CALL this % requests % Free () CALL this % elemToRank % Free () END SUBROUTINE Free_MPILayer","tags":"","loc":"proc/free_mpilayer.html"},{"title":"Init_MPILayer – SELF","text":"public subroutine Init_MPILayer(this, enableMPI) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(out) :: this logical, intent(in) :: enableMPI Calls proc~~init_mpilayer~~CallsGraph proc~init_mpilayer Init_MPILayer mpi_comm_size mpi_comm_size proc~init_mpilayer->mpi_comm_size info info proc~init_mpilayer->info mpi_comm_rank mpi_comm_rank proc~init_mpilayer->mpi_comm_rank mpi_init mpi_init proc~init_mpilayer->mpi_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Init_MPILayer Source Code SUBROUTINE Init_MPILayer ( this , enableMPI ) #undef __FUNC__ #define __FUNC__ \"Init_MPILayer\" IMPLICIT NONE CLASS ( MPILayer ), INTENT ( out ) :: this LOGICAL , INTENT ( in ) :: enableMPI ! Local INTEGER :: ierror CHARACTER ( 30 ) :: msg this % mpiComm = 0 this % mpiPrec = prec this % rankId = 0 this % nRanks = 1 this % nElem = 0 this % mpiEnabled = enableMPI IF ( enableMPI ) THEN this % mpiComm = MPI_COMM_WORLD CALL MPI_INIT ( ierror ) CALL MPI_COMM_RANK ( this % mpiComm , this % rankId , ierror ) CALL MPI_COMM_SIZE ( this % mpiComm , this % nRanks , ierror ) END IF IF ( prec == real32 ) THEN this % mpiPrec = MPI_FLOAT ELSE this % mpiPrec = MPI_DOUBLE END IF CALL this % offSetElem % Alloc ( 0 , this % nRanks ) WRITE ( msg , '(I5)' ) this % rankId msg = \"Greetings from rank \" // TRIM ( msg ) // \".\" INFO ( TRIM ( msg )) END SUBROUTINE Init_MPILayer","tags":"","loc":"proc/init_mpilayer.html"},{"title":"SetElemToRank – SELF","text":"public subroutine SetElemToRank(this, nElem) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this integer, intent(in) :: nElem Calls proc~~setelemtorank~~CallsGraph proc~setelemtorank SetElemToRank proc~domaindecomp DomainDecomp proc~setelemtorank->proc~domaindecomp proc~elemtorank ElemToRank proc~setelemtorank->proc~elemtorank Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SetElemToRank Source Code SUBROUTINE SetElemToRank ( this , nElem ) IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: nElem ! Local INTEGER :: iel this % nElem = nElem CALL this % elemToRank % Alloc ( 1 , nElem ) CALL DomainDecomp ( nElem , & this % nRanks , & this % offSetElem % hostData ) DO iel = 1 , nElem CALL ElemToRank ( this % nRanks , & this % offSetElem % hostData , & iel , & this % elemToRank % hostData ( iel )) END DO CALL this % offSetElem % UpdateDevice () CALL this % elemToRank % UpdateDevice () END SUBROUTINE SetElemToRank","tags":"","loc":"proc/setelemtorank.html"},{"title":"SetMaxMsg – SELF","text":"public subroutine SetMaxMsg(this, maxMsg) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this integer, intent(in) :: maxMsg Contents Source Code SetMaxMsg Source Code SUBROUTINE SetMaxMsg ( this , maxMsg ) IMPLICIT NONE CLASS ( MPILayer ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: maxMsg CALL this % requests % Alloc (( / 1 , 1 / ), & ( / maxMsg , 2 / )) this % maxMsg = maxMsg END SUBROUTINE SetMaxMsg","tags":"","loc":"proc/setmaxmsg.html"},{"title":"Close_HDF5 – SELF","text":"public subroutine Close_HDF5(fileId) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId Calls proc~~close_hdf5~~CallsGraph proc~close_hdf5 Close_HDF5 h5close_f h5close_f proc~close_hdf5->h5close_f h5fclose_f h5fclose_f proc~close_hdf5->h5fclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Close_HDF5 Source Code SUBROUTINE Close_HDF5 ( fileId ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId ! Local INTEGER :: error CALL h5fclose_f ( fileId , error ) CALL h5close_f ( error ) END SUBROUTINE Close_HDF5","tags":"","loc":"proc/close_hdf5.html"},{"title":"CreateGroup_HDF5 – SELF","text":"public subroutine CreateGroup_HDF5(fileId, groupName) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: groupName Calls proc~~creategroup_hdf5~~CallsGraph proc~creategroup_hdf5 CreateGroup_HDF5 h5gclose_f h5gclose_f proc~creategroup_hdf5->h5gclose_f h5gcreate_f h5gcreate_f proc~creategroup_hdf5->h5gcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code CreateGroup_HDF5 Source Code SUBROUTINE CreateGroup_HDF5 ( fileId , groupName ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: groupName ! Local INTEGER ( HID_T ) :: groupId INTEGER :: error ! Create groups CALL h5gcreate_f ( fileId , TRIM ( groupName ), groupId , error ) CALL h5gclose_f ( groupId , error ) END SUBROUTINE CreateGroup_HDF5","tags":"","loc":"proc/creategroup_hdf5.html"},{"title":"Open_HDF5_parallel – SELF","text":"private subroutine Open_HDF5_parallel(fileName, accessFlag, fileId, mpiComm) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId integer, intent(in) :: mpiComm Calls proc~~open_hdf5_parallel~~CallsGraph proc~open_hdf5_parallel Open_HDF5_parallel h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~open_hdf5_parallel->h5pset_fapl_mpio_f h5pcreate_f h5pcreate_f proc~open_hdf5_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~open_hdf5_parallel->h5pclose_f h5fopen_f h5fopen_f proc~open_hdf5_parallel->h5fopen_f h5open_f h5open_f proc~open_hdf5_parallel->h5open_f h5fcreate_f h5fcreate_f proc~open_hdf5_parallel->h5fcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~open_hdf5_parallel~~CalledByGraph proc~open_hdf5_parallel Open_HDF5_parallel interface~open_hdf5 Open_HDF5 interface~open_hdf5->proc~open_hdf5_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Open_HDF5_parallel Source Code SUBROUTINE Open_HDF5_parallel ( fileName , accessFlag , fileId , mpiComm ) IMPLICIT NONE CHARACTER ( * ), INTENT ( in ) :: fileName INTEGER , INTENT ( in ) :: accessFlag INTEGER ( HID_T ), INTENT ( inout ) :: fileId INTEGER , INTENT ( in ) :: mpiComm ! Local INTEGER ( HID_T ) :: plistId INTEGER :: error CALL h5open_f ( error ) CALL h5pcreate_f ( H5P_FILE_ACCESS_F , plistId , error ) CALL h5pset_fapl_mpio_f ( plistId , mpiComm , MPI_INFO_NULL , error ) CALL h5fopen_f ( TRIM ( fileName ), accessFlag , fileId , error , plistId ) IF ( accessFlag == H5F_ACC_TRUNC_F ) THEN CALL h5fcreate_f ( TRIM ( fileName ), accessFlag , fileId , error , plistId ) ELSE CALL h5fopen_f ( TRIM ( fileName ), accessFlag , fileId , error , plistId ) END IF CALL h5pclose_f ( plistId , error ) IF ( error == - 1 ) THEN PRINT * , 'Failed to open ' // TRIM ( fileName ) // '.' STOP - 1 END IF END SUBROUTINE Open_HDF5_parallel","tags":"","loc":"proc/open_hdf5_parallel.html"},{"title":"Open_HDF5_serial – SELF","text":"private subroutine Open_HDF5_serial(fileName, accessFlag, fileId) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId Calls proc~~open_hdf5_serial~~CallsGraph proc~open_hdf5_serial Open_HDF5_serial h5open_f h5open_f proc~open_hdf5_serial->h5open_f h5fcreate_f h5fcreate_f proc~open_hdf5_serial->h5fcreate_f h5fopen_f h5fopen_f proc~open_hdf5_serial->h5fopen_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~open_hdf5_serial~~CalledByGraph proc~open_hdf5_serial Open_HDF5_serial interface~open_hdf5 Open_HDF5 interface~open_hdf5->proc~open_hdf5_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Open_HDF5_serial Source Code SUBROUTINE Open_HDF5_serial ( fileName , accessFlag , fileId ) IMPLICIT NONE CHARACTER ( * ), INTENT ( in ) :: fileName INTEGER , INTENT ( in ) :: accessFlag INTEGER ( HID_T ), INTENT ( inout ) :: fileId ! Local INTEGER :: error CALL h5open_f ( error ) IF ( accessFlag == H5F_ACC_TRUNC_F ) THEN CALL h5fcreate_f ( TRIM ( fileName ), accessFlag , fileId , error ) ELSE CALL h5fopen_f ( TRIM ( fileName ), accessFlag , fileId , error ) END IF IF ( error == - 1 ) THEN PRINT * , 'Failed to open ' // TRIM ( fileName ) // '.' STOP - 1 END IF END SUBROUTINE Open_HDF5_serial","tags":"","loc":"proc/open_hdf5_serial.html"},{"title":"ReadArray_HDF5_int32_r1_parallel – SELF","text":"private subroutine ReadArray_HDF5_int32_r1_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r1), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) Calls proc~~readarray_hdf5_int32_r1_parallel~~CallsGraph proc~readarray_hdf5_int32_r1_parallel ReadArray_HDF5_int32_r1_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_int32_r1_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_int32_r1_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_int32_r1_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_int32_r1_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_int32_r1_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_int32_r1_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_int32_r1_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_int32_r1_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int32_r1_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int32_r1_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int32_r1_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_int32_r1_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int32_r1_parallel~~CalledByGraph proc~readarray_hdf5_int32_r1_parallel ReadArray_HDF5_int32_r1_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int32_r1_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int32_r1_parallel Source Code SUBROUTINE ReadArray_HDF5_int32_r1_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfInt32_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( 1 , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r1_parallel","tags":"","loc":"proc/readarray_hdf5_int32_r1_parallel.html"},{"title":"ReadArray_HDF5_int32_r1_serial – SELF","text":"private subroutine ReadArray_HDF5_int32_r1_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r1), intent(inout) :: hfArray Calls proc~~readarray_hdf5_int32_r1_serial~~CallsGraph proc~readarray_hdf5_int32_r1_serial ReadArray_HDF5_int32_r1_serial h5dopen_f h5dopen_f proc~readarray_hdf5_int32_r1_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_int32_r1_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int32_r1_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int32_r1_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int32_r1_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int32_r1_serial~~CalledByGraph proc~readarray_hdf5_int32_r1_serial ReadArray_HDF5_int32_r1_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int32_r1_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int32_r1_serial Source Code SUBROUTINE ReadArray_HDF5_int32_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r1_serial","tags":"","loc":"proc/readarray_hdf5_int32_r1_serial.html"},{"title":"ReadArray_HDF5_int32_r2_parallel – SELF","text":"private subroutine ReadArray_HDF5_int32_r2_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r2), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) Calls proc~~readarray_hdf5_int32_r2_parallel~~CallsGraph proc~readarray_hdf5_int32_r2_parallel ReadArray_HDF5_int32_r2_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_int32_r2_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_int32_r2_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_int32_r2_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_int32_r2_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_int32_r2_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_int32_r2_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_int32_r2_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_int32_r2_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int32_r2_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int32_r2_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int32_r2_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_int32_r2_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int32_r2_parallel~~CalledByGraph proc~readarray_hdf5_int32_r2_parallel ReadArray_HDF5_int32_r2_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int32_r2_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int32_r2_parallel Source Code SUBROUTINE ReadArray_HDF5_int32_r2_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfInt32_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r2_parallel","tags":"","loc":"proc/readarray_hdf5_int32_r2_parallel.html"},{"title":"ReadArray_HDF5_int32_r2_serial – SELF","text":"private subroutine ReadArray_HDF5_int32_r2_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r2), intent(inout) :: hfArray Calls proc~~readarray_hdf5_int32_r2_serial~~CallsGraph proc~readarray_hdf5_int32_r2_serial ReadArray_HDF5_int32_r2_serial h5dopen_f h5dopen_f proc~readarray_hdf5_int32_r2_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_int32_r2_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int32_r2_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int32_r2_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int32_r2_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int32_r2_serial~~CalledByGraph proc~readarray_hdf5_int32_r2_serial ReadArray_HDF5_int32_r2_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int32_r2_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int32_r2_serial Source Code SUBROUTINE ReadArray_HDF5_int32_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r2_serial","tags":"","loc":"proc/readarray_hdf5_int32_r2_serial.html"},{"title":"ReadArray_HDF5_int32_r3_parallel – SELF","text":"private subroutine ReadArray_HDF5_int32_r3_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r3), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) Calls proc~~readarray_hdf5_int32_r3_parallel~~CallsGraph proc~readarray_hdf5_int32_r3_parallel ReadArray_HDF5_int32_r3_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_int32_r3_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_int32_r3_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_int32_r3_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_int32_r3_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_int32_r3_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_int32_r3_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_int32_r3_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_int32_r3_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int32_r3_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int32_r3_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int32_r3_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_int32_r3_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int32_r3_parallel~~CalledByGraph proc~readarray_hdf5_int32_r3_parallel ReadArray_HDF5_int32_r3_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int32_r3_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int32_r3_parallel Source Code SUBROUTINE ReadArray_HDF5_int32_r3_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfInt32_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r3_parallel","tags":"","loc":"proc/readarray_hdf5_int32_r3_parallel.html"},{"title":"ReadArray_HDF5_int32_r3_serial – SELF","text":"private subroutine ReadArray_HDF5_int32_r3_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r3), intent(inout) :: hfArray Calls proc~~readarray_hdf5_int32_r3_serial~~CallsGraph proc~readarray_hdf5_int32_r3_serial ReadArray_HDF5_int32_r3_serial h5dopen_f h5dopen_f proc~readarray_hdf5_int32_r3_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_int32_r3_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int32_r3_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int32_r3_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int32_r3_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int32_r3_serial~~CalledByGraph proc~readarray_hdf5_int32_r3_serial ReadArray_HDF5_int32_r3_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int32_r3_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int32_r3_serial Source Code SUBROUTINE ReadArray_HDF5_int32_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r3_serial","tags":"","loc":"proc/readarray_hdf5_int32_r3_serial.html"},{"title":"ReadArray_HDF5_int32_r4_parallel – SELF","text":"private subroutine ReadArray_HDF5_int32_r4_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r4), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) Calls proc~~readarray_hdf5_int32_r4_parallel~~CallsGraph proc~readarray_hdf5_int32_r4_parallel ReadArray_HDF5_int32_r4_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_int32_r4_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_int32_r4_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_int32_r4_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_int32_r4_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_int32_r4_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_int32_r4_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_int32_r4_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_int32_r4_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int32_r4_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int32_r4_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int32_r4_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_int32_r4_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int32_r4_parallel~~CalledByGraph proc~readarray_hdf5_int32_r4_parallel ReadArray_HDF5_int32_r4_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int32_r4_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int32_r4_parallel Source Code SUBROUTINE ReadArray_HDF5_int32_r4_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfInt32_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r4_parallel","tags":"","loc":"proc/readarray_hdf5_int32_r4_parallel.html"},{"title":"ReadArray_HDF5_int32_r4_serial – SELF","text":"private subroutine ReadArray_HDF5_int32_r4_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r4), intent(inout) :: hfArray Calls proc~~readarray_hdf5_int32_r4_serial~~CallsGraph proc~readarray_hdf5_int32_r4_serial ReadArray_HDF5_int32_r4_serial h5dopen_f h5dopen_f proc~readarray_hdf5_int32_r4_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_int32_r4_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int32_r4_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int32_r4_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int32_r4_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int32_r4_serial~~CalledByGraph proc~readarray_hdf5_int32_r4_serial ReadArray_HDF5_int32_r4_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int32_r4_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int32_r4_serial Source Code SUBROUTINE ReadArray_HDF5_int32_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r4_serial","tags":"","loc":"proc/readarray_hdf5_int32_r4_serial.html"},{"title":"ReadArray_HDF5_int32_r5_parallel – SELF","text":"private subroutine ReadArray_HDF5_int32_r5_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r5), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) Calls proc~~readarray_hdf5_int32_r5_parallel~~CallsGraph proc~readarray_hdf5_int32_r5_parallel ReadArray_HDF5_int32_r5_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_int32_r5_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_int32_r5_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_int32_r5_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_int32_r5_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_int32_r5_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_int32_r5_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_int32_r5_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_int32_r5_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int32_r5_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int32_r5_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int32_r5_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_int32_r5_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int32_r5_parallel~~CalledByGraph proc~readarray_hdf5_int32_r5_parallel ReadArray_HDF5_int32_r5_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int32_r5_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int32_r5_parallel Source Code SUBROUTINE ReadArray_HDF5_int32_r5_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfInt32_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r5_parallel","tags":"","loc":"proc/readarray_hdf5_int32_r5_parallel.html"},{"title":"ReadArray_HDF5_int32_r5_serial – SELF","text":"private subroutine ReadArray_HDF5_int32_r5_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r5), intent(inout) :: hfArray Calls proc~~readarray_hdf5_int32_r5_serial~~CallsGraph proc~readarray_hdf5_int32_r5_serial ReadArray_HDF5_int32_r5_serial h5dopen_f h5dopen_f proc~readarray_hdf5_int32_r5_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_int32_r5_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int32_r5_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int32_r5_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int32_r5_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int32_r5_serial~~CalledByGraph proc~readarray_hdf5_int32_r5_serial ReadArray_HDF5_int32_r5_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int32_r5_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int32_r5_serial Source Code SUBROUTINE ReadArray_HDF5_int32_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r5_serial","tags":"","loc":"proc/readarray_hdf5_int32_r5_serial.html"},{"title":"ReadArray_HDF5_int32_r6_parallel – SELF","text":"private subroutine ReadArray_HDF5_int32_r6_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r6), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) Calls proc~~readarray_hdf5_int32_r6_parallel~~CallsGraph proc~readarray_hdf5_int32_r6_parallel ReadArray_HDF5_int32_r6_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_int32_r6_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_int32_r6_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_int32_r6_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_int32_r6_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_int32_r6_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_int32_r6_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_int32_r6_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_int32_r6_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int32_r6_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int32_r6_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int32_r6_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_int32_r6_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int32_r6_parallel~~CalledByGraph proc~readarray_hdf5_int32_r6_parallel ReadArray_HDF5_int32_r6_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int32_r6_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int32_r6_parallel Source Code SUBROUTINE ReadArray_HDF5_int32_r6_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfInt32_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r6_parallel","tags":"","loc":"proc/readarray_hdf5_int32_r6_parallel.html"},{"title":"ReadArray_HDF5_int32_r6_serial – SELF","text":"private subroutine ReadArray_HDF5_int32_r6_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r6), intent(inout) :: hfArray Calls proc~~readarray_hdf5_int32_r6_serial~~CallsGraph proc~readarray_hdf5_int32_r6_serial ReadArray_HDF5_int32_r6_serial h5dopen_f h5dopen_f proc~readarray_hdf5_int32_r6_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_int32_r6_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int32_r6_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int32_r6_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int32_r6_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int32_r6_serial~~CalledByGraph proc~readarray_hdf5_int32_r6_serial ReadArray_HDF5_int32_r6_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int32_r6_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int32_r6_serial Source Code SUBROUTINE ReadArray_HDF5_int32_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r6_serial","tags":"","loc":"proc/readarray_hdf5_int32_r6_serial.html"},{"title":"ReadArray_HDF5_int32_r7_parallel – SELF","text":"private subroutine ReadArray_HDF5_int32_r7_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r7), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) Calls proc~~readarray_hdf5_int32_r7_parallel~~CallsGraph proc~readarray_hdf5_int32_r7_parallel ReadArray_HDF5_int32_r7_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_int32_r7_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_int32_r7_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_int32_r7_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_int32_r7_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_int32_r7_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_int32_r7_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_int32_r7_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_int32_r7_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int32_r7_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int32_r7_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int32_r7_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_int32_r7_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int32_r7_parallel~~CalledByGraph proc~readarray_hdf5_int32_r7_parallel ReadArray_HDF5_int32_r7_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int32_r7_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int32_r7_parallel Source Code SUBROUTINE ReadArray_HDF5_int32_r7_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 7 ) TYPE ( hfInt32_r7 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int32_r7_parallel","tags":"","loc":"proc/readarray_hdf5_int32_r7_parallel.html"},{"title":"ReadArray_HDF5_int32_r7_serial – SELF","text":"private subroutine ReadArray_HDF5_int32_r7_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r7), intent(inout) :: hfArray Calls proc~~readarray_hdf5_int32_r7_serial~~CallsGraph proc~readarray_hdf5_int32_r7_serial ReadArray_HDF5_int32_r7_serial h5dopen_f h5dopen_f proc~readarray_hdf5_int32_r7_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_int32_r7_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int32_r7_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int32_r7_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int32_r7_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int32_r7_serial~~CalledByGraph proc~readarray_hdf5_int32_r7_serial ReadArray_HDF5_int32_r7_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int32_r7_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int32_r7_serial Source Code SUBROUTINE ReadArray_HDF5_int32_r7_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt32_r7 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int32_r7_serial","tags":"","loc":"proc/readarray_hdf5_int32_r7_serial.html"},{"title":"ReadArray_HDF5_int64_r1_parallel – SELF","text":"private subroutine ReadArray_HDF5_int64_r1_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r1), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) Calls proc~~readarray_hdf5_int64_r1_parallel~~CallsGraph proc~readarray_hdf5_int64_r1_parallel ReadArray_HDF5_int64_r1_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_int64_r1_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_int64_r1_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_int64_r1_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_int64_r1_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_int64_r1_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_int64_r1_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_int64_r1_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_int64_r1_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int64_r1_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int64_r1_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int64_r1_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_int64_r1_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int64_r1_parallel~~CalledByGraph proc~readarray_hdf5_int64_r1_parallel ReadArray_HDF5_int64_r1_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int64_r1_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int64_r1_parallel Source Code SUBROUTINE ReadArray_HDF5_int64_r1_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfInt64_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int64_r1_parallel","tags":"","loc":"proc/readarray_hdf5_int64_r1_parallel.html"},{"title":"ReadArray_HDF5_int64_r1_serial – SELF","text":"private subroutine ReadArray_HDF5_int64_r1_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r1), intent(inout) :: hfArray Calls proc~~readarray_hdf5_int64_r1_serial~~CallsGraph proc~readarray_hdf5_int64_r1_serial ReadArray_HDF5_int64_r1_serial h5dopen_f h5dopen_f proc~readarray_hdf5_int64_r1_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_int64_r1_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int64_r1_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int64_r1_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int64_r1_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int64_r1_serial~~CalledByGraph proc~readarray_hdf5_int64_r1_serial ReadArray_HDF5_int64_r1_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int64_r1_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int64_r1_serial Source Code SUBROUTINE ReadArray_HDF5_int64_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt64_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int64_r1_serial","tags":"","loc":"proc/readarray_hdf5_int64_r1_serial.html"},{"title":"ReadArray_HDF5_int64_r2_parallel – SELF","text":"private subroutine ReadArray_HDF5_int64_r2_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r2), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) Calls proc~~readarray_hdf5_int64_r2_parallel~~CallsGraph proc~readarray_hdf5_int64_r2_parallel ReadArray_HDF5_int64_r2_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_int64_r2_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_int64_r2_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_int64_r2_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_int64_r2_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_int64_r2_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_int64_r2_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_int64_r2_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_int64_r2_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int64_r2_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int64_r2_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int64_r2_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_int64_r2_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int64_r2_parallel~~CalledByGraph proc~readarray_hdf5_int64_r2_parallel ReadArray_HDF5_int64_r2_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int64_r2_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int64_r2_parallel Source Code SUBROUTINE ReadArray_HDF5_int64_r2_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfInt64_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int64_r2_parallel","tags":"","loc":"proc/readarray_hdf5_int64_r2_parallel.html"},{"title":"ReadArray_HDF5_int64_r2_serial – SELF","text":"private subroutine ReadArray_HDF5_int64_r2_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r2), intent(inout) :: hfArray Calls proc~~readarray_hdf5_int64_r2_serial~~CallsGraph proc~readarray_hdf5_int64_r2_serial ReadArray_HDF5_int64_r2_serial h5dopen_f h5dopen_f proc~readarray_hdf5_int64_r2_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_int64_r2_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int64_r2_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int64_r2_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int64_r2_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int64_r2_serial~~CalledByGraph proc~readarray_hdf5_int64_r2_serial ReadArray_HDF5_int64_r2_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int64_r2_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int64_r2_serial Source Code SUBROUTINE ReadArray_HDF5_int64_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt64_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int64_r2_serial","tags":"","loc":"proc/readarray_hdf5_int64_r2_serial.html"},{"title":"ReadArray_HDF5_int64_r3_parallel – SELF","text":"private subroutine ReadArray_HDF5_int64_r3_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r3), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) Calls proc~~readarray_hdf5_int64_r3_parallel~~CallsGraph proc~readarray_hdf5_int64_r3_parallel ReadArray_HDF5_int64_r3_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_int64_r3_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_int64_r3_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_int64_r3_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_int64_r3_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_int64_r3_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_int64_r3_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_int64_r3_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_int64_r3_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int64_r3_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int64_r3_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int64_r3_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_int64_r3_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int64_r3_parallel~~CalledByGraph proc~readarray_hdf5_int64_r3_parallel ReadArray_HDF5_int64_r3_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int64_r3_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int64_r3_parallel Source Code SUBROUTINE ReadArray_HDF5_int64_r3_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfInt64_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int64_r3_parallel","tags":"","loc":"proc/readarray_hdf5_int64_r3_parallel.html"},{"title":"ReadArray_HDF5_int64_r3_serial – SELF","text":"private subroutine ReadArray_HDF5_int64_r3_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r3), intent(inout) :: hfArray Calls proc~~readarray_hdf5_int64_r3_serial~~CallsGraph proc~readarray_hdf5_int64_r3_serial ReadArray_HDF5_int64_r3_serial h5dopen_f h5dopen_f proc~readarray_hdf5_int64_r3_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_int64_r3_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int64_r3_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int64_r3_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int64_r3_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int64_r3_serial~~CalledByGraph proc~readarray_hdf5_int64_r3_serial ReadArray_HDF5_int64_r3_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int64_r3_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int64_r3_serial Source Code SUBROUTINE ReadArray_HDF5_int64_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt64_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int64_r3_serial","tags":"","loc":"proc/readarray_hdf5_int64_r3_serial.html"},{"title":"ReadArray_HDF5_int64_r4_parallel – SELF","text":"private subroutine ReadArray_HDF5_int64_r4_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r4), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) Calls proc~~readarray_hdf5_int64_r4_parallel~~CallsGraph proc~readarray_hdf5_int64_r4_parallel ReadArray_HDF5_int64_r4_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_int64_r4_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_int64_r4_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_int64_r4_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_int64_r4_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_int64_r4_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_int64_r4_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_int64_r4_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_int64_r4_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int64_r4_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int64_r4_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int64_r4_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_int64_r4_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int64_r4_parallel~~CalledByGraph proc~readarray_hdf5_int64_r4_parallel ReadArray_HDF5_int64_r4_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int64_r4_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int64_r4_parallel Source Code SUBROUTINE ReadArray_HDF5_int64_r4_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfInt64_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int64_r4_parallel","tags":"","loc":"proc/readarray_hdf5_int64_r4_parallel.html"},{"title":"ReadArray_HDF5_int64_r4_serial – SELF","text":"private subroutine ReadArray_HDF5_int64_r4_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r4), intent(inout) :: hfArray Calls proc~~readarray_hdf5_int64_r4_serial~~CallsGraph proc~readarray_hdf5_int64_r4_serial ReadArray_HDF5_int64_r4_serial h5dopen_f h5dopen_f proc~readarray_hdf5_int64_r4_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_int64_r4_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int64_r4_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int64_r4_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int64_r4_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int64_r4_serial~~CalledByGraph proc~readarray_hdf5_int64_r4_serial ReadArray_HDF5_int64_r4_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int64_r4_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int64_r4_serial Source Code SUBROUTINE ReadArray_HDF5_int64_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt64_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int64_r4_serial","tags":"","loc":"proc/readarray_hdf5_int64_r4_serial.html"},{"title":"ReadArray_HDF5_int64_r5_parallel – SELF","text":"private subroutine ReadArray_HDF5_int64_r5_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r5), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) Calls proc~~readarray_hdf5_int64_r5_parallel~~CallsGraph proc~readarray_hdf5_int64_r5_parallel ReadArray_HDF5_int64_r5_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_int64_r5_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_int64_r5_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_int64_r5_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_int64_r5_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_int64_r5_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_int64_r5_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_int64_r5_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_int64_r5_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int64_r5_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int64_r5_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int64_r5_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_int64_r5_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int64_r5_parallel~~CalledByGraph proc~readarray_hdf5_int64_r5_parallel ReadArray_HDF5_int64_r5_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int64_r5_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int64_r5_parallel Source Code SUBROUTINE ReadArray_HDF5_int64_r5_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfInt64_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int64_r5_parallel","tags":"","loc":"proc/readarray_hdf5_int64_r5_parallel.html"},{"title":"ReadArray_HDF5_int64_r5_serial – SELF","text":"private subroutine ReadArray_HDF5_int64_r5_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r5), intent(inout) :: hfArray Calls proc~~readarray_hdf5_int64_r5_serial~~CallsGraph proc~readarray_hdf5_int64_r5_serial ReadArray_HDF5_int64_r5_serial h5dopen_f h5dopen_f proc~readarray_hdf5_int64_r5_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_int64_r5_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int64_r5_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int64_r5_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int64_r5_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int64_r5_serial~~CalledByGraph proc~readarray_hdf5_int64_r5_serial ReadArray_HDF5_int64_r5_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int64_r5_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int64_r5_serial Source Code SUBROUTINE ReadArray_HDF5_int64_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt64_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int64_r5_serial","tags":"","loc":"proc/readarray_hdf5_int64_r5_serial.html"},{"title":"ReadArray_HDF5_int64_r6_parallel – SELF","text":"private subroutine ReadArray_HDF5_int64_r6_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r6), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) Calls proc~~readarray_hdf5_int64_r6_parallel~~CallsGraph proc~readarray_hdf5_int64_r6_parallel ReadArray_HDF5_int64_r6_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_int64_r6_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_int64_r6_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_int64_r6_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_int64_r6_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_int64_r6_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_int64_r6_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_int64_r6_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_int64_r6_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int64_r6_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int64_r6_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int64_r6_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_int64_r6_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int64_r6_parallel~~CalledByGraph proc~readarray_hdf5_int64_r6_parallel ReadArray_HDF5_int64_r6_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int64_r6_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int64_r6_parallel Source Code SUBROUTINE ReadArray_HDF5_int64_r6_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfInt64_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int64_r6_parallel","tags":"","loc":"proc/readarray_hdf5_int64_r6_parallel.html"},{"title":"ReadArray_HDF5_int64_r6_serial – SELF","text":"private subroutine ReadArray_HDF5_int64_r6_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r6), intent(inout) :: hfArray Calls proc~~readarray_hdf5_int64_r6_serial~~CallsGraph proc~readarray_hdf5_int64_r6_serial ReadArray_HDF5_int64_r6_serial h5dopen_f h5dopen_f proc~readarray_hdf5_int64_r6_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_int64_r6_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int64_r6_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int64_r6_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int64_r6_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int64_r6_serial~~CalledByGraph proc~readarray_hdf5_int64_r6_serial ReadArray_HDF5_int64_r6_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int64_r6_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int64_r6_serial Source Code SUBROUTINE ReadArray_HDF5_int64_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt64_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int64_r6_serial","tags":"","loc":"proc/readarray_hdf5_int64_r6_serial.html"},{"title":"ReadArray_HDF5_int64_r7_parallel – SELF","text":"private subroutine ReadArray_HDF5_int64_r7_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r7), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) Calls proc~~readarray_hdf5_int64_r7_parallel~~CallsGraph proc~readarray_hdf5_int64_r7_parallel ReadArray_HDF5_int64_r7_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_int64_r7_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_int64_r7_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_int64_r7_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_int64_r7_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_int64_r7_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_int64_r7_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_int64_r7_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_int64_r7_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int64_r7_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int64_r7_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int64_r7_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_int64_r7_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int64_r7_parallel~~CalledByGraph proc~readarray_hdf5_int64_r7_parallel ReadArray_HDF5_int64_r7_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int64_r7_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int64_r7_parallel Source Code SUBROUTINE ReadArray_HDF5_int64_r7_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 7 ) TYPE ( hfInt64_r7 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_int64_r7_parallel","tags":"","loc":"proc/readarray_hdf5_int64_r7_parallel.html"},{"title":"ReadArray_HDF5_int64_r7_serial – SELF","text":"private subroutine ReadArray_HDF5_int64_r7_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r7), intent(inout) :: hfArray Calls proc~~readarray_hdf5_int64_r7_serial~~CallsGraph proc~readarray_hdf5_int64_r7_serial ReadArray_HDF5_int64_r7_serial h5dopen_f h5dopen_f proc~readarray_hdf5_int64_r7_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_int64_r7_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int64_r7_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int64_r7_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int64_r7_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_int64_r7_serial~~CalledByGraph proc~readarray_hdf5_int64_r7_serial ReadArray_HDF5_int64_r7_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_int64_r7_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_int64_r7_serial Source Code SUBROUTINE ReadArray_HDF5_int64_r7_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfInt64_r7 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_int64_r7_serial","tags":"","loc":"proc/readarray_hdf5_int64_r7_serial.html"},{"title":"ReadArray_HDF5_real_r1_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r1_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) Calls proc~~readarray_hdf5_real_r1_parallel~~CallsGraph proc~readarray_hdf5_real_r1_parallel ReadArray_HDF5_real_r1_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_real_r1_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_real_r1_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_real_r1_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_real_r1_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_real_r1_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_real_r1_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_real_r1_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_real_r1_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_real_r1_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_real_r1_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_real_r1_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_real_r1_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_real_r1_parallel~~CalledByGraph proc~readarray_hdf5_real_r1_parallel ReadArray_HDF5_real_r1_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_real_r1_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_real_r1_parallel Source Code SUBROUTINE ReadArray_HDF5_real_r1_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfReal_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r1_parallel","tags":"","loc":"proc/readarray_hdf5_real_r1_parallel.html"},{"title":"ReadArray_HDF5_real_r1_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r1_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(inout) :: hfArray Calls proc~~readarray_hdf5_real_r1_serial~~CallsGraph proc~readarray_hdf5_real_r1_serial ReadArray_HDF5_real_r1_serial h5dopen_f h5dopen_f proc~readarray_hdf5_real_r1_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_real_r1_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_real_r1_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_real_r1_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_real_r1_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_real_r1_serial~~CalledByGraph proc~readarray_hdf5_real_r1_serial ReadArray_HDF5_real_r1_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_real_r1_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_real_r1_serial Source Code SUBROUTINE ReadArray_HDF5_real_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r1 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r1_serial","tags":"","loc":"proc/readarray_hdf5_real_r1_serial.html"},{"title":"ReadArray_HDF5_real_r2_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r2_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) Calls proc~~readarray_hdf5_real_r2_parallel~~CallsGraph proc~readarray_hdf5_real_r2_parallel ReadArray_HDF5_real_r2_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_real_r2_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_real_r2_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_real_r2_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_real_r2_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_real_r2_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_real_r2_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_real_r2_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_real_r2_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_real_r2_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_real_r2_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_real_r2_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_real_r2_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_real_r2_parallel~~CalledByGraph proc~readarray_hdf5_real_r2_parallel ReadArray_HDF5_real_r2_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_real_r2_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_real_r2_parallel Source Code SUBROUTINE ReadArray_HDF5_real_r2_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfReal_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r2_parallel","tags":"","loc":"proc/readarray_hdf5_real_r2_parallel.html"},{"title":"ReadArray_HDF5_real_r2_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r2_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(inout) :: hfArray Calls proc~~readarray_hdf5_real_r2_serial~~CallsGraph proc~readarray_hdf5_real_r2_serial ReadArray_HDF5_real_r2_serial h5dopen_f h5dopen_f proc~readarray_hdf5_real_r2_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_real_r2_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_real_r2_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_real_r2_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_real_r2_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_real_r2_serial~~CalledByGraph proc~readarray_hdf5_real_r2_serial ReadArray_HDF5_real_r2_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_real_r2_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_real_r2_serial Source Code SUBROUTINE ReadArray_HDF5_real_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r2 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r2_serial","tags":"","loc":"proc/readarray_hdf5_real_r2_serial.html"},{"title":"ReadArray_HDF5_real_r3_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r3_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) Calls proc~~readarray_hdf5_real_r3_parallel~~CallsGraph proc~readarray_hdf5_real_r3_parallel ReadArray_HDF5_real_r3_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_real_r3_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_real_r3_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_real_r3_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_real_r3_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_real_r3_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_real_r3_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_real_r3_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_real_r3_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_real_r3_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_real_r3_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_real_r3_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_real_r3_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_real_r3_parallel~~CalledByGraph proc~readarray_hdf5_real_r3_parallel ReadArray_HDF5_real_r3_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_real_r3_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_real_r3_parallel Source Code SUBROUTINE ReadArray_HDF5_real_r3_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfReal_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r3_parallel","tags":"","loc":"proc/readarray_hdf5_real_r3_parallel.html"},{"title":"ReadArray_HDF5_real_r3_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r3_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(inout) :: hfArray Calls proc~~readarray_hdf5_real_r3_serial~~CallsGraph proc~readarray_hdf5_real_r3_serial ReadArray_HDF5_real_r3_serial h5dopen_f h5dopen_f proc~readarray_hdf5_real_r3_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_real_r3_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_real_r3_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_real_r3_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_real_r3_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_real_r3_serial~~CalledByGraph proc~readarray_hdf5_real_r3_serial ReadArray_HDF5_real_r3_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_real_r3_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_real_r3_serial Source Code SUBROUTINE ReadArray_HDF5_real_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r3 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r3_serial","tags":"","loc":"proc/readarray_hdf5_real_r3_serial.html"},{"title":"ReadArray_HDF5_real_r4_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r4_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) Calls proc~~readarray_hdf5_real_r4_parallel~~CallsGraph proc~readarray_hdf5_real_r4_parallel ReadArray_HDF5_real_r4_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_real_r4_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_real_r4_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_real_r4_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_real_r4_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_real_r4_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_real_r4_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_real_r4_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_real_r4_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_real_r4_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_real_r4_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_real_r4_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_real_r4_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_real_r4_parallel~~CalledByGraph proc~readarray_hdf5_real_r4_parallel ReadArray_HDF5_real_r4_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_real_r4_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_real_r4_parallel Source Code SUBROUTINE ReadArray_HDF5_real_r4_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfReal_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r4_parallel","tags":"","loc":"proc/readarray_hdf5_real_r4_parallel.html"},{"title":"ReadArray_HDF5_real_r4_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r4_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(inout) :: hfArray Calls proc~~readarray_hdf5_real_r4_serial~~CallsGraph proc~readarray_hdf5_real_r4_serial ReadArray_HDF5_real_r4_serial h5dopen_f h5dopen_f proc~readarray_hdf5_real_r4_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_real_r4_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_real_r4_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_real_r4_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_real_r4_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_real_r4_serial~~CalledByGraph proc~readarray_hdf5_real_r4_serial ReadArray_HDF5_real_r4_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_real_r4_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_real_r4_serial Source Code SUBROUTINE ReadArray_HDF5_real_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r4 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r4_serial","tags":"","loc":"proc/readarray_hdf5_real_r4_serial.html"},{"title":"ReadArray_HDF5_real_r5_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r5_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) Calls proc~~readarray_hdf5_real_r5_parallel~~CallsGraph proc~readarray_hdf5_real_r5_parallel ReadArray_HDF5_real_r5_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_real_r5_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_real_r5_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_real_r5_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_real_r5_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_real_r5_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_real_r5_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_real_r5_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_real_r5_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_real_r5_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_real_r5_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_real_r5_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_real_r5_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_real_r5_parallel~~CalledByGraph proc~readarray_hdf5_real_r5_parallel ReadArray_HDF5_real_r5_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_real_r5_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_real_r5_parallel Source Code SUBROUTINE ReadArray_HDF5_real_r5_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfReal_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r5_parallel","tags":"","loc":"proc/readarray_hdf5_real_r5_parallel.html"},{"title":"ReadArray_HDF5_real_r5_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r5_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(inout) :: hfArray Calls proc~~readarray_hdf5_real_r5_serial~~CallsGraph proc~readarray_hdf5_real_r5_serial ReadArray_HDF5_real_r5_serial h5dopen_f h5dopen_f proc~readarray_hdf5_real_r5_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_real_r5_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_real_r5_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_real_r5_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_real_r5_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_real_r5_serial~~CalledByGraph proc~readarray_hdf5_real_r5_serial ReadArray_HDF5_real_r5_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_real_r5_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_real_r5_serial Source Code SUBROUTINE ReadArray_HDF5_real_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r5 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r5_serial","tags":"","loc":"proc/readarray_hdf5_real_r5_serial.html"},{"title":"ReadArray_HDF5_real_r6_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r6_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) Calls proc~~readarray_hdf5_real_r6_parallel~~CallsGraph proc~readarray_hdf5_real_r6_parallel ReadArray_HDF5_real_r6_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_real_r6_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_real_r6_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_real_r6_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_real_r6_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_real_r6_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_real_r6_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_real_r6_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_real_r6_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_real_r6_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_real_r6_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_real_r6_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_real_r6_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_real_r6_parallel~~CalledByGraph proc~readarray_hdf5_real_r6_parallel ReadArray_HDF5_real_r6_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_real_r6_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_real_r6_parallel Source Code SUBROUTINE ReadArray_HDF5_real_r6_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfReal_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r6_parallel","tags":"","loc":"proc/readarray_hdf5_real_r6_parallel.html"},{"title":"ReadArray_HDF5_real_r6_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r6_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(inout) :: hfArray Calls proc~~readarray_hdf5_real_r6_serial~~CallsGraph proc~readarray_hdf5_real_r6_serial ReadArray_HDF5_real_r6_serial h5dopen_f h5dopen_f proc~readarray_hdf5_real_r6_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_real_r6_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_real_r6_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_real_r6_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_real_r6_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_real_r6_serial~~CalledByGraph proc~readarray_hdf5_real_r6_serial ReadArray_HDF5_real_r6_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_real_r6_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_real_r6_serial Source Code SUBROUTINE ReadArray_HDF5_real_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r6 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r6_serial","tags":"","loc":"proc/readarray_hdf5_real_r6_serial.html"},{"title":"ReadArray_HDF5_real_r7_parallel – SELF","text":"private subroutine ReadArray_HDF5_real_r7_parallel(fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) Calls proc~~readarray_hdf5_real_r7_parallel~~CallsGraph proc~readarray_hdf5_real_r7_parallel ReadArray_HDF5_real_r7_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_real_r7_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_real_r7_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_real_r7_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_real_r7_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_real_r7_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_real_r7_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_real_r7_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_real_r7_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_real_r7_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_real_r7_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_real_r7_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_real_r7_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_real_r7_parallel~~CalledByGraph proc~readarray_hdf5_real_r7_parallel ReadArray_HDF5_real_r7_parallel interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_real_r7_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_real_r7_parallel Source Code SUBROUTINE ReadArray_HDF5_real_r7_parallel ( fileId , arrayName , hfArray , offset ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 7 ) TYPE ( hfReal_r7 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HID_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_space_f ( dsetId , filespace , error ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5pcreate_f ( H5P_DATASET_XFER_F , plistId , error ) CALL h5pset_dxpl_mpio_f ( plistId , H5FD_MPIO_COLLECTIVE_F , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , & error , memspace , filespace , plistId ) CALL h5tclose_f ( dtypeId , error ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dsetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE ReadArray_HDF5_real_r7_parallel","tags":"","loc":"proc/readarray_hdf5_real_r7_parallel.html"},{"title":"ReadArray_HDF5_real_r7_serial – SELF","text":"private subroutine ReadArray_HDF5_real_r7_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(inout) :: hfArray Calls proc~~readarray_hdf5_real_r7_serial~~CallsGraph proc~readarray_hdf5_real_r7_serial ReadArray_HDF5_real_r7_serial h5dopen_f h5dopen_f proc~readarray_hdf5_real_r7_serial->h5dopen_f h5tclose_f h5tclose_f proc~readarray_hdf5_real_r7_serial->h5tclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_real_r7_serial->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_real_r7_serial->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_real_r7_serial->h5dread_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readarray_hdf5_real_r7_serial~~CalledByGraph proc~readarray_hdf5_real_r7_serial ReadArray_HDF5_real_r7_serial interface~readarray_hdf5 ReadArray_HDF5 interface~readarray_hdf5->proc~readarray_hdf5_real_r7_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadArray_HDF5_real_r7_serial Source Code SUBROUTINE ReadArray_HDF5_real_r7_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r7 ), INTENT ( inout ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: dtypeId INTEGER ( HID_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) CALL h5dopen_f ( fileId , arrayName , dsetId , error ) CALL h5dget_type_f ( dsetId , dtypeId , error ) CALL h5dread_f ( dsetId , dtypeId , hfArray % hostData , dims , error ) CALL h5tclose_f ( dtypeId , error ) CALL h5dclose_f ( dsetId , error ) END SUBROUTINE ReadArray_HDF5_real_r7_serial","tags":"","loc":"proc/readarray_hdf5_real_r7_serial.html"},{"title":"ReadAttribute_HDF5_character – SELF","text":"private subroutine ReadAttribute_HDF5_character(fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(out) :: attribute Calls proc~~readattribute_hdf5_character~~CallsGraph proc~readattribute_hdf5_character ReadAttribute_HDF5_character h5aread_f h5aread_f proc~readattribute_hdf5_character->h5aread_f h5tclose_f h5tclose_f proc~readattribute_hdf5_character->h5tclose_f h5aget_type_f h5aget_type_f proc~readattribute_hdf5_character->h5aget_type_f h5aclose_f h5aclose_f proc~readattribute_hdf5_character->h5aclose_f h5aopen_f h5aopen_f proc~readattribute_hdf5_character->h5aopen_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readattribute_hdf5_character~~CalledByGraph proc~readattribute_hdf5_character ReadAttribute_HDF5_character interface~readattribute_hdf5 ReadAttribute_HDF5 interface~readattribute_hdf5->proc~readattribute_hdf5_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadAttribute_HDF5_character Source Code SUBROUTINE ReadAttribute_HDF5_character ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName CHARACTER ( * ), INTENT ( out ) :: attribute ! Local INTEGER ( HID_T ) :: attrId INTEGER ( HID_T ) :: typeId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5aopen_f ( fileId , TRIM ( attributeName ), attrId , error ) CALL h5aget_type_f ( attrId , typeId , error ) CALL h5aread_f ( attrId , typeId , attribute , dims , error ) CALL h5tclose_f ( typeId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE ReadAttribute_HDF5_character","tags":"","loc":"proc/readattribute_hdf5_character.html"},{"title":"ReadAttribute_HDF5_int32 – SELF","text":"private subroutine ReadAttribute_HDF5_int32(fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(out) :: attribute Calls proc~~readattribute_hdf5_int32~~CallsGraph proc~readattribute_hdf5_int32 ReadAttribute_HDF5_int32 h5aread_f h5aread_f proc~readattribute_hdf5_int32->h5aread_f h5tclose_f h5tclose_f proc~readattribute_hdf5_int32->h5tclose_f h5aget_type_f h5aget_type_f proc~readattribute_hdf5_int32->h5aget_type_f h5aclose_f h5aclose_f proc~readattribute_hdf5_int32->h5aclose_f h5aopen_f h5aopen_f proc~readattribute_hdf5_int32->h5aopen_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readattribute_hdf5_int32~~CalledByGraph proc~readattribute_hdf5_int32 ReadAttribute_HDF5_int32 interface~readattribute_hdf5 ReadAttribute_HDF5 interface~readattribute_hdf5->proc~readattribute_hdf5_int32 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadAttribute_HDF5_int32 Source Code SUBROUTINE ReadAttribute_HDF5_int32 ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName INTEGER , INTENT ( out ) :: attribute ! Local INTEGER ( HID_T ) :: attrId INTEGER ( HID_T ) :: typeId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5aopen_f ( fileId , TRIM ( attributeName ), attrId , error ) CALL h5aget_type_f ( attrId , typeId , error ) CALL h5aread_f ( attrId , typeId , attribute , dims , error ) CALL h5tclose_f ( typeId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE ReadAttribute_HDF5_int32","tags":"","loc":"proc/readattribute_hdf5_int32.html"},{"title":"ReadAttribute_HDF5_real – SELF","text":"private subroutine ReadAttribute_HDF5_real(fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(out) :: attribute Calls proc~~readattribute_hdf5_real~~CallsGraph proc~readattribute_hdf5_real ReadAttribute_HDF5_real h5aread_f h5aread_f proc~readattribute_hdf5_real->h5aread_f h5tclose_f h5tclose_f proc~readattribute_hdf5_real->h5tclose_f h5aget_type_f h5aget_type_f proc~readattribute_hdf5_real->h5aget_type_f h5aclose_f h5aclose_f proc~readattribute_hdf5_real->h5aclose_f h5aopen_f h5aopen_f proc~readattribute_hdf5_real->h5aopen_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~readattribute_hdf5_real~~CalledByGraph proc~readattribute_hdf5_real ReadAttribute_HDF5_real interface~readattribute_hdf5 ReadAttribute_HDF5 interface~readattribute_hdf5->proc~readattribute_hdf5_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ReadAttribute_HDF5_real Source Code SUBROUTINE ReadAttribute_HDF5_real ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName REAL ( prec ), INTENT ( out ) :: attribute ! Local INTEGER ( HID_T ) :: attrId INTEGER ( HID_T ) :: typeId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5aopen_f ( fileId , TRIM ( attributeName ), attrId , error ) CALL h5aget_type_f ( attrId , typeId , error ) CALL h5aread_f ( attrId , typeId , attribute , dims , error ) CALL h5tclose_f ( typeId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE ReadAttribute_HDF5_real","tags":"","loc":"proc/readattribute_hdf5_real.html"},{"title":"WriteArray_HDF5_int32_r1_parallel – SELF","text":"private subroutine WriteArray_HDF5_int32_r1_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r1), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) Calls proc~~writearray_hdf5_int32_r1_parallel~~CallsGraph proc~writearray_hdf5_int32_r1_parallel WriteArray_HDF5_int32_r1_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_int32_r1_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int32_r1_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int32_r1_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_int32_r1_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_int32_r1_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_int32_r1_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int32_r1_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int32_r1_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_int32_r1_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int32_r1_parallel~~CalledByGraph proc~writearray_hdf5_int32_r1_parallel WriteArray_HDF5_int32_r1_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int32_r1_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int32_r1_parallel Source Code SUBROUTINE WriteArray_HDF5_int32_r1_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfint32_r1 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r1_parallel","tags":"","loc":"proc/writearray_hdf5_int32_r1_parallel.html"},{"title":"WriteArray_HDF5_int32_r1_serial – SELF","text":"private subroutine WriteArray_HDF5_int32_r1_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r1), intent(in) :: hfArray Calls proc~~writearray_hdf5_int32_r1_serial~~CallsGraph proc~writearray_hdf5_int32_r1_serial WriteArray_HDF5_int32_r1_serial h5sclose_f h5sclose_f proc~writearray_hdf5_int32_r1_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int32_r1_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int32_r1_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int32_r1_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int32_r1_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int32_r1_serial~~CalledByGraph proc~writearray_hdf5_int32_r1_serial WriteArray_HDF5_int32_r1_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int32_r1_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int32_r1_serial Source Code SUBROUTINE WriteArray_HDF5_int32_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r1 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r1_serial","tags":"","loc":"proc/writearray_hdf5_int32_r1_serial.html"},{"title":"WriteArray_HDF5_int32_r2_parallel – SELF","text":"private subroutine WriteArray_HDF5_int32_r2_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r2), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) Calls proc~~writearray_hdf5_int32_r2_parallel~~CallsGraph proc~writearray_hdf5_int32_r2_parallel WriteArray_HDF5_int32_r2_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_int32_r2_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int32_r2_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int32_r2_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_int32_r2_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_int32_r2_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_int32_r2_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int32_r2_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int32_r2_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_int32_r2_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int32_r2_parallel~~CalledByGraph proc~writearray_hdf5_int32_r2_parallel WriteArray_HDF5_int32_r2_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int32_r2_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int32_r2_parallel Source Code SUBROUTINE WriteArray_HDF5_int32_r2_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfint32_r2 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 2 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r2_parallel","tags":"","loc":"proc/writearray_hdf5_int32_r2_parallel.html"},{"title":"WriteArray_HDF5_int32_r2_serial – SELF","text":"private subroutine WriteArray_HDF5_int32_r2_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r2), intent(in) :: hfArray Calls proc~~writearray_hdf5_int32_r2_serial~~CallsGraph proc~writearray_hdf5_int32_r2_serial WriteArray_HDF5_int32_r2_serial h5sclose_f h5sclose_f proc~writearray_hdf5_int32_r2_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int32_r2_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int32_r2_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int32_r2_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int32_r2_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int32_r2_serial~~CalledByGraph proc~writearray_hdf5_int32_r2_serial WriteArray_HDF5_int32_r2_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int32_r2_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int32_r2_serial Source Code SUBROUTINE WriteArray_HDF5_int32_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r2 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r2_serial","tags":"","loc":"proc/writearray_hdf5_int32_r2_serial.html"},{"title":"WriteArray_HDF5_int32_r3_parallel – SELF","text":"private subroutine WriteArray_HDF5_int32_r3_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r3), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) Calls proc~~writearray_hdf5_int32_r3_parallel~~CallsGraph proc~writearray_hdf5_int32_r3_parallel WriteArray_HDF5_int32_r3_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_int32_r3_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int32_r3_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int32_r3_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_int32_r3_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_int32_r3_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_int32_r3_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int32_r3_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int32_r3_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_int32_r3_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int32_r3_parallel~~CalledByGraph proc~writearray_hdf5_int32_r3_parallel WriteArray_HDF5_int32_r3_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int32_r3_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int32_r3_parallel Source Code SUBROUTINE WriteArray_HDF5_int32_r3_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfint32_r3 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 3 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r3_parallel","tags":"","loc":"proc/writearray_hdf5_int32_r3_parallel.html"},{"title":"WriteArray_HDF5_int32_r3_serial – SELF","text":"private subroutine WriteArray_HDF5_int32_r3_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r3), intent(in) :: hfArray Calls proc~~writearray_hdf5_int32_r3_serial~~CallsGraph proc~writearray_hdf5_int32_r3_serial WriteArray_HDF5_int32_r3_serial h5sclose_f h5sclose_f proc~writearray_hdf5_int32_r3_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int32_r3_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int32_r3_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int32_r3_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int32_r3_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int32_r3_serial~~CalledByGraph proc~writearray_hdf5_int32_r3_serial WriteArray_HDF5_int32_r3_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int32_r3_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int32_r3_serial Source Code SUBROUTINE WriteArray_HDF5_int32_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r3 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r3_serial","tags":"","loc":"proc/writearray_hdf5_int32_r3_serial.html"},{"title":"WriteArray_HDF5_int32_r4_parallel – SELF","text":"private subroutine WriteArray_HDF5_int32_r4_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r4), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) Calls proc~~writearray_hdf5_int32_r4_parallel~~CallsGraph proc~writearray_hdf5_int32_r4_parallel WriteArray_HDF5_int32_r4_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_int32_r4_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int32_r4_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int32_r4_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_int32_r4_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_int32_r4_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_int32_r4_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int32_r4_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int32_r4_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_int32_r4_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int32_r4_parallel~~CalledByGraph proc~writearray_hdf5_int32_r4_parallel WriteArray_HDF5_int32_r4_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int32_r4_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int32_r4_parallel Source Code SUBROUTINE WriteArray_HDF5_int32_r4_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfint32_r4 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 4 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r4_parallel","tags":"","loc":"proc/writearray_hdf5_int32_r4_parallel.html"},{"title":"WriteArray_HDF5_int32_r4_serial – SELF","text":"private subroutine WriteArray_HDF5_int32_r4_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r4), intent(in) :: hfArray Calls proc~~writearray_hdf5_int32_r4_serial~~CallsGraph proc~writearray_hdf5_int32_r4_serial WriteArray_HDF5_int32_r4_serial h5sclose_f h5sclose_f proc~writearray_hdf5_int32_r4_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int32_r4_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int32_r4_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int32_r4_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int32_r4_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int32_r4_serial~~CalledByGraph proc~writearray_hdf5_int32_r4_serial WriteArray_HDF5_int32_r4_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int32_r4_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int32_r4_serial Source Code SUBROUTINE WriteArray_HDF5_int32_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r4 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r4_serial","tags":"","loc":"proc/writearray_hdf5_int32_r4_serial.html"},{"title":"WriteArray_HDF5_int32_r5_parallel – SELF","text":"private subroutine WriteArray_HDF5_int32_r5_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r5), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) Calls proc~~writearray_hdf5_int32_r5_parallel~~CallsGraph proc~writearray_hdf5_int32_r5_parallel WriteArray_HDF5_int32_r5_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_int32_r5_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int32_r5_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int32_r5_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_int32_r5_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_int32_r5_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_int32_r5_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int32_r5_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int32_r5_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_int32_r5_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int32_r5_parallel~~CalledByGraph proc~writearray_hdf5_int32_r5_parallel WriteArray_HDF5_int32_r5_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int32_r5_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int32_r5_parallel Source Code SUBROUTINE WriteArray_HDF5_int32_r5_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfint32_r5 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 5 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r5_parallel","tags":"","loc":"proc/writearray_hdf5_int32_r5_parallel.html"},{"title":"WriteArray_HDF5_int32_r5_serial – SELF","text":"private subroutine WriteArray_HDF5_int32_r5_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r5), intent(in) :: hfArray Calls proc~~writearray_hdf5_int32_r5_serial~~CallsGraph proc~writearray_hdf5_int32_r5_serial WriteArray_HDF5_int32_r5_serial h5sclose_f h5sclose_f proc~writearray_hdf5_int32_r5_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int32_r5_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int32_r5_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int32_r5_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int32_r5_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int32_r5_serial~~CalledByGraph proc~writearray_hdf5_int32_r5_serial WriteArray_HDF5_int32_r5_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int32_r5_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int32_r5_serial Source Code SUBROUTINE WriteArray_HDF5_int32_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r5 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r5_serial","tags":"","loc":"proc/writearray_hdf5_int32_r5_serial.html"},{"title":"WriteArray_HDF5_int32_r6_parallel – SELF","text":"private subroutine WriteArray_HDF5_int32_r6_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r6), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) Calls proc~~writearray_hdf5_int32_r6_parallel~~CallsGraph proc~writearray_hdf5_int32_r6_parallel WriteArray_HDF5_int32_r6_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_int32_r6_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int32_r6_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int32_r6_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_int32_r6_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_int32_r6_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_int32_r6_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int32_r6_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int32_r6_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_int32_r6_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int32_r6_parallel~~CalledByGraph proc~writearray_hdf5_int32_r6_parallel WriteArray_HDF5_int32_r6_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int32_r6_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int32_r6_parallel Source Code SUBROUTINE WriteArray_HDF5_int32_r6_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfint32_r6 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 6 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r6_parallel","tags":"","loc":"proc/writearray_hdf5_int32_r6_parallel.html"},{"title":"WriteArray_HDF5_int32_r6_serial – SELF","text":"private subroutine WriteArray_HDF5_int32_r6_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r6), intent(in) :: hfArray Calls proc~~writearray_hdf5_int32_r6_serial~~CallsGraph proc~writearray_hdf5_int32_r6_serial WriteArray_HDF5_int32_r6_serial h5sclose_f h5sclose_f proc~writearray_hdf5_int32_r6_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int32_r6_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int32_r6_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int32_r6_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int32_r6_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int32_r6_serial~~CalledByGraph proc~writearray_hdf5_int32_r6_serial WriteArray_HDF5_int32_r6_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int32_r6_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int32_r6_serial Source Code SUBROUTINE WriteArray_HDF5_int32_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r6 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r6_serial","tags":"","loc":"proc/writearray_hdf5_int32_r6_serial.html"},{"title":"WriteArray_HDF5_int32_r7_parallel – SELF","text":"private subroutine WriteArray_HDF5_int32_r7_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r7), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) integer(kind=HID_T), intent(in) :: globalDims (1:7) Calls proc~~writearray_hdf5_int32_r7_parallel~~CallsGraph proc~writearray_hdf5_int32_r7_parallel WriteArray_HDF5_int32_r7_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_int32_r7_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int32_r7_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int32_r7_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_int32_r7_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_int32_r7_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_int32_r7_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int32_r7_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int32_r7_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_int32_r7_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int32_r7_parallel~~CalledByGraph proc~writearray_hdf5_int32_r7_parallel WriteArray_HDF5_int32_r7_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int32_r7_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int32_r7_parallel Source Code SUBROUTINE WriteArray_HDF5_int32_r7_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 7 ) TYPE ( hfint32_r7 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 7 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r7_parallel","tags":"","loc":"proc/writearray_hdf5_int32_r7_parallel.html"},{"title":"WriteArray_HDF5_int32_r7_serial – SELF","text":"private subroutine WriteArray_HDF5_int32_r7_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r7), intent(in) :: hfArray Calls proc~~writearray_hdf5_int32_r7_serial~~CallsGraph proc~writearray_hdf5_int32_r7_serial WriteArray_HDF5_int32_r7_serial h5sclose_f h5sclose_f proc~writearray_hdf5_int32_r7_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int32_r7_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int32_r7_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int32_r7_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int32_r7_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int32_r7_serial~~CalledByGraph proc~writearray_hdf5_int32_r7_serial WriteArray_HDF5_int32_r7_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int32_r7_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int32_r7_serial Source Code SUBROUTINE WriteArray_HDF5_int32_r7_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint32_r7 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I32LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I32LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int32_r7_serial","tags":"","loc":"proc/writearray_hdf5_int32_r7_serial.html"},{"title":"WriteArray_HDF5_int64_r1_parallel – SELF","text":"private subroutine WriteArray_HDF5_int64_r1_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r1), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) Calls proc~~writearray_hdf5_int64_r1_parallel~~CallsGraph proc~writearray_hdf5_int64_r1_parallel WriteArray_HDF5_int64_r1_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_int64_r1_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int64_r1_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int64_r1_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_int64_r1_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_int64_r1_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_int64_r1_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int64_r1_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int64_r1_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_int64_r1_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int64_r1_parallel~~CalledByGraph proc~writearray_hdf5_int64_r1_parallel WriteArray_HDF5_int64_r1_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int64_r1_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int64_r1_parallel Source Code SUBROUTINE WriteArray_HDF5_int64_r1_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfint64_r1 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r1_parallel","tags":"","loc":"proc/writearray_hdf5_int64_r1_parallel.html"},{"title":"WriteArray_HDF5_int64_r1_serial – SELF","text":"private subroutine WriteArray_HDF5_int64_r1_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r1), intent(in) :: hfArray Calls proc~~writearray_hdf5_int64_r1_serial~~CallsGraph proc~writearray_hdf5_int64_r1_serial WriteArray_HDF5_int64_r1_serial h5sclose_f h5sclose_f proc~writearray_hdf5_int64_r1_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int64_r1_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int64_r1_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int64_r1_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int64_r1_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int64_r1_serial~~CalledByGraph proc~writearray_hdf5_int64_r1_serial WriteArray_HDF5_int64_r1_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int64_r1_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int64_r1_serial Source Code SUBROUTINE WriteArray_HDF5_int64_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint64_r1 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r1_serial","tags":"","loc":"proc/writearray_hdf5_int64_r1_serial.html"},{"title":"WriteArray_HDF5_int64_r2_parallel – SELF","text":"private subroutine WriteArray_HDF5_int64_r2_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r2), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) Calls proc~~writearray_hdf5_int64_r2_parallel~~CallsGraph proc~writearray_hdf5_int64_r2_parallel WriteArray_HDF5_int64_r2_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_int64_r2_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int64_r2_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int64_r2_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_int64_r2_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_int64_r2_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_int64_r2_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int64_r2_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int64_r2_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_int64_r2_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int64_r2_parallel~~CalledByGraph proc~writearray_hdf5_int64_r2_parallel WriteArray_HDF5_int64_r2_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int64_r2_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int64_r2_parallel Source Code SUBROUTINE WriteArray_HDF5_int64_r2_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfint64_r2 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 2 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r2_parallel","tags":"","loc":"proc/writearray_hdf5_int64_r2_parallel.html"},{"title":"WriteArray_HDF5_int64_r2_serial – SELF","text":"private subroutine WriteArray_HDF5_int64_r2_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r2), intent(in) :: hfArray Calls proc~~writearray_hdf5_int64_r2_serial~~CallsGraph proc~writearray_hdf5_int64_r2_serial WriteArray_HDF5_int64_r2_serial h5sclose_f h5sclose_f proc~writearray_hdf5_int64_r2_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int64_r2_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int64_r2_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int64_r2_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int64_r2_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int64_r2_serial~~CalledByGraph proc~writearray_hdf5_int64_r2_serial WriteArray_HDF5_int64_r2_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int64_r2_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int64_r2_serial Source Code SUBROUTINE WriteArray_HDF5_int64_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint64_r2 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r2_serial","tags":"","loc":"proc/writearray_hdf5_int64_r2_serial.html"},{"title":"WriteArray_HDF5_int64_r3_parallel – SELF","text":"private subroutine WriteArray_HDF5_int64_r3_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r3), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) Calls proc~~writearray_hdf5_int64_r3_parallel~~CallsGraph proc~writearray_hdf5_int64_r3_parallel WriteArray_HDF5_int64_r3_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_int64_r3_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int64_r3_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int64_r3_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_int64_r3_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_int64_r3_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_int64_r3_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int64_r3_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int64_r3_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_int64_r3_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int64_r3_parallel~~CalledByGraph proc~writearray_hdf5_int64_r3_parallel WriteArray_HDF5_int64_r3_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int64_r3_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int64_r3_parallel Source Code SUBROUTINE WriteArray_HDF5_int64_r3_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfint64_r3 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 3 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r3_parallel","tags":"","loc":"proc/writearray_hdf5_int64_r3_parallel.html"},{"title":"WriteArray_HDF5_int64_r3_serial – SELF","text":"private subroutine WriteArray_HDF5_int64_r3_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r3), intent(in) :: hfArray Calls proc~~writearray_hdf5_int64_r3_serial~~CallsGraph proc~writearray_hdf5_int64_r3_serial WriteArray_HDF5_int64_r3_serial h5sclose_f h5sclose_f proc~writearray_hdf5_int64_r3_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int64_r3_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int64_r3_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int64_r3_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int64_r3_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int64_r3_serial~~CalledByGraph proc~writearray_hdf5_int64_r3_serial WriteArray_HDF5_int64_r3_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int64_r3_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int64_r3_serial Source Code SUBROUTINE WriteArray_HDF5_int64_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint64_r3 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r3_serial","tags":"","loc":"proc/writearray_hdf5_int64_r3_serial.html"},{"title":"WriteArray_HDF5_int64_r4_parallel – SELF","text":"private subroutine WriteArray_HDF5_int64_r4_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r4), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) Calls proc~~writearray_hdf5_int64_r4_parallel~~CallsGraph proc~writearray_hdf5_int64_r4_parallel WriteArray_HDF5_int64_r4_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_int64_r4_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int64_r4_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int64_r4_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_int64_r4_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_int64_r4_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_int64_r4_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int64_r4_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int64_r4_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_int64_r4_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int64_r4_parallel~~CalledByGraph proc~writearray_hdf5_int64_r4_parallel WriteArray_HDF5_int64_r4_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int64_r4_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int64_r4_parallel Source Code SUBROUTINE WriteArray_HDF5_int64_r4_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfint64_r4 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 4 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r4_parallel","tags":"","loc":"proc/writearray_hdf5_int64_r4_parallel.html"},{"title":"WriteArray_HDF5_int64_r4_serial – SELF","text":"private subroutine WriteArray_HDF5_int64_r4_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r4), intent(in) :: hfArray Calls proc~~writearray_hdf5_int64_r4_serial~~CallsGraph proc~writearray_hdf5_int64_r4_serial WriteArray_HDF5_int64_r4_serial h5sclose_f h5sclose_f proc~writearray_hdf5_int64_r4_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int64_r4_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int64_r4_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int64_r4_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int64_r4_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int64_r4_serial~~CalledByGraph proc~writearray_hdf5_int64_r4_serial WriteArray_HDF5_int64_r4_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int64_r4_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int64_r4_serial Source Code SUBROUTINE WriteArray_HDF5_int64_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint64_r4 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r4_serial","tags":"","loc":"proc/writearray_hdf5_int64_r4_serial.html"},{"title":"WriteArray_HDF5_int64_r5_parallel – SELF","text":"private subroutine WriteArray_HDF5_int64_r5_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r5), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) Calls proc~~writearray_hdf5_int64_r5_parallel~~CallsGraph proc~writearray_hdf5_int64_r5_parallel WriteArray_HDF5_int64_r5_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_int64_r5_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int64_r5_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int64_r5_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_int64_r5_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_int64_r5_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_int64_r5_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int64_r5_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int64_r5_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_int64_r5_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int64_r5_parallel~~CalledByGraph proc~writearray_hdf5_int64_r5_parallel WriteArray_HDF5_int64_r5_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int64_r5_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int64_r5_parallel Source Code SUBROUTINE WriteArray_HDF5_int64_r5_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfint64_r5 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 5 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r5_parallel","tags":"","loc":"proc/writearray_hdf5_int64_r5_parallel.html"},{"title":"WriteArray_HDF5_int64_r5_serial – SELF","text":"private subroutine WriteArray_HDF5_int64_r5_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r5), intent(in) :: hfArray Calls proc~~writearray_hdf5_int64_r5_serial~~CallsGraph proc~writearray_hdf5_int64_r5_serial WriteArray_HDF5_int64_r5_serial h5sclose_f h5sclose_f proc~writearray_hdf5_int64_r5_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int64_r5_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int64_r5_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int64_r5_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int64_r5_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int64_r5_serial~~CalledByGraph proc~writearray_hdf5_int64_r5_serial WriteArray_HDF5_int64_r5_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int64_r5_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int64_r5_serial Source Code SUBROUTINE WriteArray_HDF5_int64_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint64_r5 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r5_serial","tags":"","loc":"proc/writearray_hdf5_int64_r5_serial.html"},{"title":"WriteArray_HDF5_int64_r6_parallel – SELF","text":"private subroutine WriteArray_HDF5_int64_r6_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r6), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) Calls proc~~writearray_hdf5_int64_r6_parallel~~CallsGraph proc~writearray_hdf5_int64_r6_parallel WriteArray_HDF5_int64_r6_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_int64_r6_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int64_r6_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int64_r6_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_int64_r6_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_int64_r6_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_int64_r6_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int64_r6_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int64_r6_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_int64_r6_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int64_r6_parallel~~CalledByGraph proc~writearray_hdf5_int64_r6_parallel WriteArray_HDF5_int64_r6_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int64_r6_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int64_r6_parallel Source Code SUBROUTINE WriteArray_HDF5_int64_r6_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfint64_r6 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 6 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r6_parallel","tags":"","loc":"proc/writearray_hdf5_int64_r6_parallel.html"},{"title":"WriteArray_HDF5_int64_r6_serial – SELF","text":"private subroutine WriteArray_HDF5_int64_r6_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r6), intent(in) :: hfArray Calls proc~~writearray_hdf5_int64_r6_serial~~CallsGraph proc~writearray_hdf5_int64_r6_serial WriteArray_HDF5_int64_r6_serial h5sclose_f h5sclose_f proc~writearray_hdf5_int64_r6_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int64_r6_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int64_r6_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int64_r6_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int64_r6_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int64_r6_serial~~CalledByGraph proc~writearray_hdf5_int64_r6_serial WriteArray_HDF5_int64_r6_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int64_r6_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int64_r6_serial Source Code SUBROUTINE WriteArray_HDF5_int64_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint64_r6 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r6_serial","tags":"","loc":"proc/writearray_hdf5_int64_r6_serial.html"},{"title":"WriteArray_HDF5_int64_r7_parallel – SELF","text":"private subroutine WriteArray_HDF5_int64_r7_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r7), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) integer(kind=HID_T), intent(in) :: globalDims (1:7) Calls proc~~writearray_hdf5_int64_r7_parallel~~CallsGraph proc~writearray_hdf5_int64_r7_parallel WriteArray_HDF5_int64_r7_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_int64_r7_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int64_r7_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int64_r7_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_int64_r7_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_int64_r7_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_int64_r7_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int64_r7_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int64_r7_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_int64_r7_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int64_r7_parallel~~CalledByGraph proc~writearray_hdf5_int64_r7_parallel WriteArray_HDF5_int64_r7_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int64_r7_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int64_r7_parallel Source Code SUBROUTINE WriteArray_HDF5_int64_r7_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 7 ) TYPE ( hfint64_r7 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 7 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r7_parallel","tags":"","loc":"proc/writearray_hdf5_int64_r7_parallel.html"},{"title":"WriteArray_HDF5_int64_r7_serial – SELF","text":"private subroutine WriteArray_HDF5_int64_r7_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r7), intent(in) :: hfArray Calls proc~~writearray_hdf5_int64_r7_serial~~CallsGraph proc~writearray_hdf5_int64_r7_serial WriteArray_HDF5_int64_r7_serial h5sclose_f h5sclose_f proc~writearray_hdf5_int64_r7_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int64_r7_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int64_r7_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int64_r7_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int64_r7_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_int64_r7_serial~~CalledByGraph proc~writearray_hdf5_int64_r7_serial WriteArray_HDF5_int64_r7_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_int64_r7_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_int64_r7_serial Source Code SUBROUTINE WriteArray_HDF5_int64_r7_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfint64_r7 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), H5T_STD_I64LE , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , H5T_STD_I64LE , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_int64_r7_serial","tags":"","loc":"proc/writearray_hdf5_int64_r7_serial.html"},{"title":"WriteArray_HDF5_real_r1_parallel – SELF","text":"private subroutine WriteArray_HDF5_real_r1_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) Calls proc~~writearray_hdf5_real_r1_parallel~~CallsGraph proc~writearray_hdf5_real_r1_parallel WriteArray_HDF5_real_r1_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_real_r1_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_real_r1_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_real_r1_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_real_r1_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_real_r1_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_real_r1_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_real_r1_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_real_r1_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_real_r1_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_real_r1_parallel~~CalledByGraph proc~writearray_hdf5_real_r1_parallel WriteArray_HDF5_real_r1_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_real_r1_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_real_r1_parallel Source Code SUBROUTINE WriteArray_HDF5_real_r1_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 ) TYPE ( hfReal_r1 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r1_parallel","tags":"","loc":"proc/writearray_hdf5_real_r1_parallel.html"},{"title":"WriteArray_HDF5_real_r1_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r1_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(in) :: hfArray Calls proc~~writearray_hdf5_real_r1_serial~~CallsGraph proc~writearray_hdf5_real_r1_serial WriteArray_HDF5_real_r1_serial h5sclose_f h5sclose_f proc~writearray_hdf5_real_r1_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_real_r1_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_real_r1_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_real_r1_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_real_r1_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_real_r1_serial~~CalledByGraph proc~writearray_hdf5_real_r1_serial WriteArray_HDF5_real_r1_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_real_r1_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_real_r1_serial Source Code SUBROUTINE WriteArray_HDF5_real_r1_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r1 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r1_serial","tags":"","loc":"proc/writearray_hdf5_real_r1_serial.html"},{"title":"WriteArray_HDF5_real_r2_parallel – SELF","text":"private subroutine WriteArray_HDF5_real_r2_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) Calls proc~~writearray_hdf5_real_r2_parallel~~CallsGraph proc~writearray_hdf5_real_r2_parallel WriteArray_HDF5_real_r2_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_real_r2_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_real_r2_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_real_r2_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_real_r2_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_real_r2_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_real_r2_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_real_r2_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_real_r2_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_real_r2_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_real_r2_parallel~~CalledByGraph proc~writearray_hdf5_real_r2_parallel WriteArray_HDF5_real_r2_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_real_r2_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_real_r2_parallel Source Code SUBROUTINE WriteArray_HDF5_real_r2_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 2 ) TYPE ( hfReal_r2 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 2 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r2_parallel","tags":"","loc":"proc/writearray_hdf5_real_r2_parallel.html"},{"title":"WriteArray_HDF5_real_r2_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r2_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(in) :: hfArray Calls proc~~writearray_hdf5_real_r2_serial~~CallsGraph proc~writearray_hdf5_real_r2_serial WriteArray_HDF5_real_r2_serial h5sclose_f h5sclose_f proc~writearray_hdf5_real_r2_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_real_r2_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_real_r2_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_real_r2_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_real_r2_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_real_r2_serial~~CalledByGraph proc~writearray_hdf5_real_r2_serial WriteArray_HDF5_real_r2_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_real_r2_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_real_r2_serial Source Code SUBROUTINE WriteArray_HDF5_real_r2_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r2 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 2 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r2_serial","tags":"","loc":"proc/writearray_hdf5_real_r2_serial.html"},{"title":"WriteArray_HDF5_real_r3_parallel – SELF","text":"private subroutine WriteArray_HDF5_real_r3_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) Calls proc~~writearray_hdf5_real_r3_parallel~~CallsGraph proc~writearray_hdf5_real_r3_parallel WriteArray_HDF5_real_r3_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_real_r3_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_real_r3_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_real_r3_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_real_r3_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_real_r3_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_real_r3_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_real_r3_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_real_r3_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_real_r3_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_real_r3_parallel~~CalledByGraph proc~writearray_hdf5_real_r3_parallel WriteArray_HDF5_real_r3_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_real_r3_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_real_r3_parallel Source Code SUBROUTINE WriteArray_HDF5_real_r3_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 3 ) TYPE ( hfReal_r3 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 3 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r3_parallel","tags":"","loc":"proc/writearray_hdf5_real_r3_parallel.html"},{"title":"WriteArray_HDF5_real_r3_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r3_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(in) :: hfArray Calls proc~~writearray_hdf5_real_r3_serial~~CallsGraph proc~writearray_hdf5_real_r3_serial WriteArray_HDF5_real_r3_serial h5sclose_f h5sclose_f proc~writearray_hdf5_real_r3_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_real_r3_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_real_r3_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_real_r3_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_real_r3_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_real_r3_serial~~CalledByGraph proc~writearray_hdf5_real_r3_serial WriteArray_HDF5_real_r3_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_real_r3_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_real_r3_serial Source Code SUBROUTINE WriteArray_HDF5_real_r3_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r3 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 3 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r3_serial","tags":"","loc":"proc/writearray_hdf5_real_r3_serial.html"},{"title":"WriteArray_HDF5_real_r4_parallel – SELF","text":"private subroutine WriteArray_HDF5_real_r4_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) Calls proc~~writearray_hdf5_real_r4_parallel~~CallsGraph proc~writearray_hdf5_real_r4_parallel WriteArray_HDF5_real_r4_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_real_r4_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_real_r4_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_real_r4_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_real_r4_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_real_r4_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_real_r4_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_real_r4_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_real_r4_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_real_r4_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_real_r4_parallel~~CalledByGraph proc~writearray_hdf5_real_r4_parallel WriteArray_HDF5_real_r4_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_real_r4_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_real_r4_parallel Source Code SUBROUTINE WriteArray_HDF5_real_r4_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 4 ) TYPE ( hfReal_r4 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 4 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r4_parallel","tags":"","loc":"proc/writearray_hdf5_real_r4_parallel.html"},{"title":"WriteArray_HDF5_real_r4_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r4_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(in) :: hfArray Calls proc~~writearray_hdf5_real_r4_serial~~CallsGraph proc~writearray_hdf5_real_r4_serial WriteArray_HDF5_real_r4_serial h5sclose_f h5sclose_f proc~writearray_hdf5_real_r4_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_real_r4_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_real_r4_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_real_r4_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_real_r4_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_real_r4_serial~~CalledByGraph proc~writearray_hdf5_real_r4_serial WriteArray_HDF5_real_r4_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_real_r4_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_real_r4_serial Source Code SUBROUTINE WriteArray_HDF5_real_r4_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r4 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 4 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r4_serial","tags":"","loc":"proc/writearray_hdf5_real_r4_serial.html"},{"title":"WriteArray_HDF5_real_r5_parallel – SELF","text":"private subroutine WriteArray_HDF5_real_r5_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) Calls proc~~writearray_hdf5_real_r5_parallel~~CallsGraph proc~writearray_hdf5_real_r5_parallel WriteArray_HDF5_real_r5_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_real_r5_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_real_r5_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_real_r5_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_real_r5_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_real_r5_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_real_r5_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_real_r5_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_real_r5_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_real_r5_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_real_r5_parallel~~CalledByGraph proc~writearray_hdf5_real_r5_parallel WriteArray_HDF5_real_r5_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_real_r5_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_real_r5_parallel Source Code SUBROUTINE WriteArray_HDF5_real_r5_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 5 ) TYPE ( hfReal_r5 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 5 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r5_parallel","tags":"","loc":"proc/writearray_hdf5_real_r5_parallel.html"},{"title":"WriteArray_HDF5_real_r5_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r5_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(in) :: hfArray Calls proc~~writearray_hdf5_real_r5_serial~~CallsGraph proc~writearray_hdf5_real_r5_serial WriteArray_HDF5_real_r5_serial h5sclose_f h5sclose_f proc~writearray_hdf5_real_r5_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_real_r5_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_real_r5_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_real_r5_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_real_r5_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_real_r5_serial~~CalledByGraph proc~writearray_hdf5_real_r5_serial WriteArray_HDF5_real_r5_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_real_r5_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_real_r5_serial Source Code SUBROUTINE WriteArray_HDF5_real_r5_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r5 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 5 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r5_serial","tags":"","loc":"proc/writearray_hdf5_real_r5_serial.html"},{"title":"WriteArray_HDF5_real_r6_parallel – SELF","text":"private subroutine WriteArray_HDF5_real_r6_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) Calls proc~~writearray_hdf5_real_r6_parallel~~CallsGraph proc~writearray_hdf5_real_r6_parallel WriteArray_HDF5_real_r6_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_real_r6_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_real_r6_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_real_r6_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_real_r6_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_real_r6_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_real_r6_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_real_r6_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_real_r6_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_real_r6_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_real_r6_parallel~~CalledByGraph proc~writearray_hdf5_real_r6_parallel WriteArray_HDF5_real_r6_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_real_r6_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_real_r6_parallel Source Code SUBROUTINE WriteArray_HDF5_real_r6_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 6 ) TYPE ( hfReal_r6 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 6 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r6_parallel","tags":"","loc":"proc/writearray_hdf5_real_r6_parallel.html"},{"title":"WriteArray_HDF5_real_r6_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r6_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(in) :: hfArray Calls proc~~writearray_hdf5_real_r6_serial~~CallsGraph proc~writearray_hdf5_real_r6_serial WriteArray_HDF5_real_r6_serial h5sclose_f h5sclose_f proc~writearray_hdf5_real_r6_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_real_r6_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_real_r6_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_real_r6_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_real_r6_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_real_r6_serial~~CalledByGraph proc~writearray_hdf5_real_r6_serial WriteArray_HDF5_real_r6_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_real_r6_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_real_r6_serial Source Code SUBROUTINE WriteArray_HDF5_real_r6_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r6 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 6 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r6_serial","tags":"","loc":"proc/writearray_hdf5_real_r6_serial.html"},{"title":"WriteArray_HDF5_real_r7_parallel – SELF","text":"private subroutine WriteArray_HDF5_real_r7_parallel(fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) integer(kind=HID_T), intent(in) :: globalDims (1:7) Calls proc~~writearray_hdf5_real_r7_parallel~~CallsGraph proc~writearray_hdf5_real_r7_parallel WriteArray_HDF5_real_r7_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_real_r7_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_real_r7_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_real_r7_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_real_r7_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_real_r7_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_real_r7_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_real_r7_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_real_r7_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_real_r7_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_real_r7_parallel~~CalledByGraph proc~writearray_hdf5_real_r7_parallel WriteArray_HDF5_real_r7_parallel interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_real_r7_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_real_r7_parallel Source Code SUBROUTINE WriteArray_HDF5_real_r7_parallel ( fileId , arrayName , hfArray , offset , globalDims ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName INTEGER ( HID_T ), INTENT ( in ) :: offset ( 1 : 7 ) TYPE ( hfReal_r7 ), INTENT ( in ) :: hfArray INTEGER ( HID_T ), INTENT ( in ) :: globalDims ( 1 : 7 ) ! Local INTEGER ( HID_T ) :: plistId INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: filespace INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , globalDims , filespace , error ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) ! Set the data creation mode to CHUNK CALL h5pcreate_f ( H5P_DATASET_CREATE_F , plistId , error ) CALL h5pset_chunk_f ( plistId , aRank , dims , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , filespace , & dsetId , error , plistId ) CALL h5sselect_hyperslab_f ( filespace , H5S_SELECT_SET_F , offset , dims , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error , memspace , filespace ) CALL h5pclose_f ( plistId , error ) CALL h5sclose_f ( filespace , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r7_parallel","tags":"","loc":"proc/writearray_hdf5_real_r7_parallel.html"},{"title":"WriteArray_HDF5_real_r7_serial – SELF","text":"private subroutine WriteArray_HDF5_real_r7_serial(fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(in) :: hfArray Calls proc~~writearray_hdf5_real_r7_serial~~CallsGraph proc~writearray_hdf5_real_r7_serial WriteArray_HDF5_real_r7_serial h5sclose_f h5sclose_f proc~writearray_hdf5_real_r7_serial->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_real_r7_serial->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_real_r7_serial->h5dcreate_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_real_r7_serial->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_real_r7_serial->h5dclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writearray_hdf5_real_r7_serial~~CalledByGraph proc~writearray_hdf5_real_r7_serial WriteArray_HDF5_real_r7_serial interface~writearray_hdf5 WriteArray_HDF5 interface~writearray_hdf5->proc~writearray_hdf5_real_r7_serial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteArray_HDF5_real_r7_serial Source Code SUBROUTINE WriteArray_HDF5_real_r7_serial ( fileId , arrayName , hfArray ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: arrayName TYPE ( hfReal_r7 ), INTENT ( in ) :: hfArray ! Local INTEGER ( HID_T ) :: dsetId INTEGER ( HID_T ) :: memspace INTEGER ( HSIZE_T ) :: dims ( 1 : 7 ) INTEGER :: error INTEGER :: aRank aRank = RANK ( hfArray % hostData ) dims = SHAPE ( hfArray % hostData ) CALL h5screate_simple_f ( aRank , dims , memspace , error ) CALL h5dcreate_f ( fileId , TRIM ( arrayName ), HDF5_IO_PREC , memspace , & dsetId , error ) CALL h5dwrite_f ( dsetId , HDF5_IO_PREC , & hfArray % hostData , dims , error ) CALL h5dclose_f ( dSetId , error ) CALL h5sclose_f ( memspace , error ) END SUBROUTINE WriteArray_HDF5_real_r7_serial","tags":"","loc":"proc/writearray_hdf5_real_r7_serial.html"},{"title":"WriteAttribute_HDF5_character – SELF","text":"private subroutine WriteAttribute_HDF5_character(fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(in) :: attribute Calls proc~~writeattribute_hdf5_character~~CallsGraph proc~writeattribute_hdf5_character WriteAttribute_HDF5_character h5sclose_f h5sclose_f proc~writeattribute_hdf5_character->h5sclose_f h5awrite_f h5awrite_f proc~writeattribute_hdf5_character->h5awrite_f h5acreate_f h5acreate_f proc~writeattribute_hdf5_character->h5acreate_f h5screate_f h5screate_f proc~writeattribute_hdf5_character->h5screate_f h5aclose_f h5aclose_f proc~writeattribute_hdf5_character->h5aclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writeattribute_hdf5_character~~CalledByGraph proc~writeattribute_hdf5_character WriteAttribute_HDF5_character interface~writeattribute_hdf5 WriteAttribute_HDF5 interface~writeattribute_hdf5->proc~writeattribute_hdf5_character Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteAttribute_HDF5_character Source Code SUBROUTINE WriteAttribute_HDF5_character ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName CHARACTER ( * ), INTENT ( in ) :: attribute ! Local INTEGER ( HID_T ) :: aspaceId INTEGER ( HID_T ) :: attrId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5screate_f ( H5S_SCALAR_F , aspaceId , error ) CALL h5acreate_f ( fileId , TRIM ( attributeName ), H5T_STRING , & aspaceId , attrId , error ) CALL h5awrite_f ( attrId , H5T_STRING , TRIM ( attribute ), dims , error ) CALL h5sclose_f ( aspaceId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE WriteAttribute_HDF5_character","tags":"","loc":"proc/writeattribute_hdf5_character.html"},{"title":"WriteAttribute_HDF5_int32 – SELF","text":"private subroutine WriteAttribute_HDF5_int32(fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(in) :: attribute Calls proc~~writeattribute_hdf5_int32~~CallsGraph proc~writeattribute_hdf5_int32 WriteAttribute_HDF5_int32 h5sclose_f h5sclose_f proc~writeattribute_hdf5_int32->h5sclose_f h5awrite_f h5awrite_f proc~writeattribute_hdf5_int32->h5awrite_f h5acreate_f h5acreate_f proc~writeattribute_hdf5_int32->h5acreate_f h5screate_f h5screate_f proc~writeattribute_hdf5_int32->h5screate_f h5aclose_f h5aclose_f proc~writeattribute_hdf5_int32->h5aclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writeattribute_hdf5_int32~~CalledByGraph proc~writeattribute_hdf5_int32 WriteAttribute_HDF5_int32 interface~writeattribute_hdf5 WriteAttribute_HDF5 interface~writeattribute_hdf5->proc~writeattribute_hdf5_int32 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteAttribute_HDF5_int32 Source Code SUBROUTINE WriteAttribute_HDF5_int32 ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName INTEGER , INTENT ( in ) :: attribute ! Local INTEGER ( HID_T ) :: aspaceId INTEGER ( HID_T ) :: attrId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5screate_f ( H5S_SCALAR_F , aspaceId , error ) CALL h5acreate_f ( fileId , TRIM ( attributeName ), H5T_STD_I32LE , & aspaceId , attrId , error ) CALL h5awrite_f ( attrId , H5T_STD_I32LE , attribute , dims , error ) CALL h5sclose_f ( aspaceId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE WriteAttribute_HDF5_int32","tags":"","loc":"proc/writeattribute_hdf5_int32.html"},{"title":"WriteAttribute_HDF5_real – SELF","text":"private subroutine WriteAttribute_HDF5_real(fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(in) :: attribute Calls proc~~writeattribute_hdf5_real~~CallsGraph proc~writeattribute_hdf5_real WriteAttribute_HDF5_real h5sclose_f h5sclose_f proc~writeattribute_hdf5_real->h5sclose_f h5awrite_f h5awrite_f proc~writeattribute_hdf5_real->h5awrite_f h5acreate_f h5acreate_f proc~writeattribute_hdf5_real->h5acreate_f h5screate_f h5screate_f proc~writeattribute_hdf5_real->h5screate_f h5aclose_f h5aclose_f proc~writeattribute_hdf5_real->h5aclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~writeattribute_hdf5_real~~CalledByGraph proc~writeattribute_hdf5_real WriteAttribute_HDF5_real interface~writeattribute_hdf5 WriteAttribute_HDF5 interface~writeattribute_hdf5->proc~writeattribute_hdf5_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteAttribute_HDF5_real Source Code SUBROUTINE WriteAttribute_HDF5_real ( fileId , attributeName , attribute ) IMPLICIT NONE INTEGER ( HID_T ), INTENT ( in ) :: fileId CHARACTER ( * ), INTENT ( in ) :: attributeName REAL ( prec ), INTENT ( in ) :: attribute ! Local INTEGER ( HID_T ) :: aspaceId INTEGER ( HID_T ) :: attrId INTEGER ( HSIZE_T ) :: dims ( 1 : 1 ) INTEGER :: error dims ( 1 ) = 1 CALL h5screate_f ( H5S_SCALAR_F , aspaceId , error ) CALL h5acreate_f ( fileId , TRIM ( attributeName ), HDF5_IO_PREC , & aspaceId , attrId , error ) CALL h5awrite_f ( attrId , HDF5_IO_PREC , attribute , dims , error ) CALL h5sclose_f ( aspaceId , error ) CALL h5aclose_f ( attrId , error ) END SUBROUTINE WriteAttribute_HDF5_real","tags":"","loc":"proc/writeattribute_hdf5_real.html"},{"title":"Open_HDF5 – SELF","text":"public interface Open_HDF5 Calls interface~~open_hdf5~~CallsGraph interface~open_hdf5 Open_HDF5 proc~open_hdf5_serial Open_HDF5_serial interface~open_hdf5->proc~open_hdf5_serial proc~open_hdf5_parallel Open_HDF5_parallel interface~open_hdf5->proc~open_hdf5_parallel h5fopen_f h5fopen_f proc~open_hdf5_serial->h5fopen_f h5open_f h5open_f proc~open_hdf5_serial->h5open_f h5fcreate_f h5fcreate_f proc~open_hdf5_serial->h5fcreate_f h5pset_fapl_mpio_f h5pset_fapl_mpio_f proc~open_hdf5_parallel->h5pset_fapl_mpio_f h5pcreate_f h5pcreate_f proc~open_hdf5_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~open_hdf5_parallel->h5pclose_f proc~open_hdf5_parallel->h5fopen_f proc~open_hdf5_parallel->h5open_f proc~open_hdf5_parallel->h5fcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures Open_HDF5_serial Open_HDF5_parallel Module Procedures private subroutine Open_HDF5_serial (fileName, accessFlag, fileId) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId private subroutine Open_HDF5_parallel (fileName, accessFlag, fileId, mpiComm) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId integer, intent(in) :: mpiComm","tags":"","loc":"interface/open_hdf5.html"},{"title":"ReadArray_HDF5 – SELF","text":"public interface ReadArray_HDF5 Calls interface~~readarray_hdf5~~CallsGraph interface~readarray_hdf5 ReadArray_HDF5 proc~readarray_hdf5_int32_r4_parallel ReadArray_HDF5_int32_r4_parallel interface~readarray_hdf5->proc~readarray_hdf5_int32_r4_parallel proc~readarray_hdf5_real_r1_serial ReadArray_HDF5_real_r1_serial interface~readarray_hdf5->proc~readarray_hdf5_real_r1_serial proc~readarray_hdf5_real_r5_parallel ReadArray_HDF5_real_r5_parallel interface~readarray_hdf5->proc~readarray_hdf5_real_r5_parallel proc~readarray_hdf5_int64_r4_serial ReadArray_HDF5_int64_r4_serial interface~readarray_hdf5->proc~readarray_hdf5_int64_r4_serial proc~readarray_hdf5_int32_r1_serial ReadArray_HDF5_int32_r1_serial interface~readarray_hdf5->proc~readarray_hdf5_int32_r1_serial proc~readarray_hdf5_real_r3_serial ReadArray_HDF5_real_r3_serial interface~readarray_hdf5->proc~readarray_hdf5_real_r3_serial proc~readarray_hdf5_int64_r6_parallel ReadArray_HDF5_int64_r6_parallel interface~readarray_hdf5->proc~readarray_hdf5_int64_r6_parallel proc~readarray_hdf5_int32_r2_parallel ReadArray_HDF5_int32_r2_parallel interface~readarray_hdf5->proc~readarray_hdf5_int32_r2_parallel proc~readarray_hdf5_real_r4_parallel ReadArray_HDF5_real_r4_parallel interface~readarray_hdf5->proc~readarray_hdf5_real_r4_parallel proc~readarray_hdf5_real_r7_serial ReadArray_HDF5_real_r7_serial interface~readarray_hdf5->proc~readarray_hdf5_real_r7_serial proc~readarray_hdf5_int32_r6_serial ReadArray_HDF5_int32_r6_serial interface~readarray_hdf5->proc~readarray_hdf5_int32_r6_serial proc~readarray_hdf5_int32_r2_serial ReadArray_HDF5_int32_r2_serial interface~readarray_hdf5->proc~readarray_hdf5_int32_r2_serial proc~readarray_hdf5_int32_r7_serial ReadArray_HDF5_int32_r7_serial interface~readarray_hdf5->proc~readarray_hdf5_int32_r7_serial proc~readarray_hdf5_real_r6_parallel ReadArray_HDF5_real_r6_parallel interface~readarray_hdf5->proc~readarray_hdf5_real_r6_parallel proc~readarray_hdf5_real_r4_serial ReadArray_HDF5_real_r4_serial interface~readarray_hdf5->proc~readarray_hdf5_real_r4_serial proc~readarray_hdf5_int32_r1_parallel ReadArray_HDF5_int32_r1_parallel interface~readarray_hdf5->proc~readarray_hdf5_int32_r1_parallel proc~readarray_hdf5_real_r2_parallel ReadArray_HDF5_real_r2_parallel interface~readarray_hdf5->proc~readarray_hdf5_real_r2_parallel proc~readarray_hdf5_int64_r5_parallel ReadArray_HDF5_int64_r5_parallel interface~readarray_hdf5->proc~readarray_hdf5_int64_r5_parallel proc~readarray_hdf5_int32_r6_parallel ReadArray_HDF5_int32_r6_parallel interface~readarray_hdf5->proc~readarray_hdf5_int32_r6_parallel proc~readarray_hdf5_int64_r3_parallel ReadArray_HDF5_int64_r3_parallel interface~readarray_hdf5->proc~readarray_hdf5_int64_r3_parallel proc~readarray_hdf5_int32_r7_parallel ReadArray_HDF5_int32_r7_parallel interface~readarray_hdf5->proc~readarray_hdf5_int32_r7_parallel proc~readarray_hdf5_int64_r3_serial ReadArray_HDF5_int64_r3_serial interface~readarray_hdf5->proc~readarray_hdf5_int64_r3_serial proc~readarray_hdf5_int64_r2_parallel ReadArray_HDF5_int64_r2_parallel interface~readarray_hdf5->proc~readarray_hdf5_int64_r2_parallel proc~readarray_hdf5_int64_r7_parallel ReadArray_HDF5_int64_r7_parallel interface~readarray_hdf5->proc~readarray_hdf5_int64_r7_parallel proc~readarray_hdf5_real_r2_serial ReadArray_HDF5_real_r2_serial interface~readarray_hdf5->proc~readarray_hdf5_real_r2_serial proc~readarray_hdf5_int64_r1_parallel ReadArray_HDF5_int64_r1_parallel interface~readarray_hdf5->proc~readarray_hdf5_int64_r1_parallel proc~readarray_hdf5_real_r7_parallel ReadArray_HDF5_real_r7_parallel interface~readarray_hdf5->proc~readarray_hdf5_real_r7_parallel proc~readarray_hdf5_int64_r7_serial ReadArray_HDF5_int64_r7_serial interface~readarray_hdf5->proc~readarray_hdf5_int64_r7_serial proc~readarray_hdf5_int64_r6_serial ReadArray_HDF5_int64_r6_serial interface~readarray_hdf5->proc~readarray_hdf5_int64_r6_serial proc~readarray_hdf5_real_r5_serial ReadArray_HDF5_real_r5_serial interface~readarray_hdf5->proc~readarray_hdf5_real_r5_serial proc~readarray_hdf5_int64_r1_serial ReadArray_HDF5_int64_r1_serial interface~readarray_hdf5->proc~readarray_hdf5_int64_r1_serial proc~readarray_hdf5_int64_r4_parallel ReadArray_HDF5_int64_r4_parallel interface~readarray_hdf5->proc~readarray_hdf5_int64_r4_parallel proc~readarray_hdf5_real_r6_serial ReadArray_HDF5_real_r6_serial interface~readarray_hdf5->proc~readarray_hdf5_real_r6_serial proc~readarray_hdf5_real_r3_parallel ReadArray_HDF5_real_r3_parallel interface~readarray_hdf5->proc~readarray_hdf5_real_r3_parallel proc~readarray_hdf5_int32_r5_serial ReadArray_HDF5_int32_r5_serial interface~readarray_hdf5->proc~readarray_hdf5_int32_r5_serial proc~readarray_hdf5_int64_r5_serial ReadArray_HDF5_int64_r5_serial interface~readarray_hdf5->proc~readarray_hdf5_int64_r5_serial proc~readarray_hdf5_int32_r3_serial ReadArray_HDF5_int32_r3_serial interface~readarray_hdf5->proc~readarray_hdf5_int32_r3_serial proc~readarray_hdf5_int32_r4_serial ReadArray_HDF5_int32_r4_serial interface~readarray_hdf5->proc~readarray_hdf5_int32_r4_serial proc~readarray_hdf5_int64_r2_serial ReadArray_HDF5_int64_r2_serial interface~readarray_hdf5->proc~readarray_hdf5_int64_r2_serial proc~readarray_hdf5_int32_r3_parallel ReadArray_HDF5_int32_r3_parallel interface~readarray_hdf5->proc~readarray_hdf5_int32_r3_parallel proc~readarray_hdf5_int32_r5_parallel ReadArray_HDF5_int32_r5_parallel interface~readarray_hdf5->proc~readarray_hdf5_int32_r5_parallel proc~readarray_hdf5_real_r1_parallel ReadArray_HDF5_real_r1_parallel interface~readarray_hdf5->proc~readarray_hdf5_real_r1_parallel h5pset_dxpl_mpio_f h5pset_dxpl_mpio_f proc~readarray_hdf5_int32_r4_parallel->h5pset_dxpl_mpio_f h5dopen_f h5dopen_f proc~readarray_hdf5_int32_r4_parallel->h5dopen_f h5sclose_f h5sclose_f proc~readarray_hdf5_int32_r4_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~readarray_hdf5_int32_r4_parallel->h5screate_simple_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~readarray_hdf5_int32_r4_parallel->h5sselect_hyperslab_f h5tclose_f h5tclose_f proc~readarray_hdf5_int32_r4_parallel->h5tclose_f h5pcreate_f h5pcreate_f proc~readarray_hdf5_int32_r4_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~readarray_hdf5_int32_r4_parallel->h5pclose_f h5dget_type_f h5dget_type_f proc~readarray_hdf5_int32_r4_parallel->h5dget_type_f h5dclose_f h5dclose_f proc~readarray_hdf5_int32_r4_parallel->h5dclose_f h5dread_f h5dread_f proc~readarray_hdf5_int32_r4_parallel->h5dread_f h5dget_space_f h5dget_space_f proc~readarray_hdf5_int32_r4_parallel->h5dget_space_f proc~readarray_hdf5_real_r1_serial->h5dopen_f proc~readarray_hdf5_real_r1_serial->h5tclose_f proc~readarray_hdf5_real_r1_serial->h5dget_type_f proc~readarray_hdf5_real_r1_serial->h5dclose_f proc~readarray_hdf5_real_r1_serial->h5dread_f proc~readarray_hdf5_real_r5_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_real_r5_parallel->h5dopen_f proc~readarray_hdf5_real_r5_parallel->h5sclose_f proc~readarray_hdf5_real_r5_parallel->h5screate_simple_f proc~readarray_hdf5_real_r5_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_real_r5_parallel->h5tclose_f proc~readarray_hdf5_real_r5_parallel->h5pcreate_f proc~readarray_hdf5_real_r5_parallel->h5pclose_f proc~readarray_hdf5_real_r5_parallel->h5dget_type_f proc~readarray_hdf5_real_r5_parallel->h5dclose_f proc~readarray_hdf5_real_r5_parallel->h5dread_f proc~readarray_hdf5_real_r5_parallel->h5dget_space_f proc~readarray_hdf5_int64_r4_serial->h5dopen_f proc~readarray_hdf5_int64_r4_serial->h5tclose_f proc~readarray_hdf5_int64_r4_serial->h5dget_type_f proc~readarray_hdf5_int64_r4_serial->h5dclose_f proc~readarray_hdf5_int64_r4_serial->h5dread_f proc~readarray_hdf5_int32_r1_serial->h5dopen_f proc~readarray_hdf5_int32_r1_serial->h5tclose_f proc~readarray_hdf5_int32_r1_serial->h5dget_type_f proc~readarray_hdf5_int32_r1_serial->h5dclose_f proc~readarray_hdf5_int32_r1_serial->h5dread_f proc~readarray_hdf5_real_r3_serial->h5dopen_f proc~readarray_hdf5_real_r3_serial->h5tclose_f proc~readarray_hdf5_real_r3_serial->h5dget_type_f proc~readarray_hdf5_real_r3_serial->h5dclose_f proc~readarray_hdf5_real_r3_serial->h5dread_f proc~readarray_hdf5_int64_r6_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_int64_r6_parallel->h5dopen_f proc~readarray_hdf5_int64_r6_parallel->h5sclose_f proc~readarray_hdf5_int64_r6_parallel->h5screate_simple_f proc~readarray_hdf5_int64_r6_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_int64_r6_parallel->h5tclose_f proc~readarray_hdf5_int64_r6_parallel->h5pcreate_f proc~readarray_hdf5_int64_r6_parallel->h5pclose_f proc~readarray_hdf5_int64_r6_parallel->h5dget_type_f proc~readarray_hdf5_int64_r6_parallel->h5dclose_f proc~readarray_hdf5_int64_r6_parallel->h5dread_f proc~readarray_hdf5_int64_r6_parallel->h5dget_space_f proc~readarray_hdf5_int32_r2_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_int32_r2_parallel->h5dopen_f proc~readarray_hdf5_int32_r2_parallel->h5sclose_f proc~readarray_hdf5_int32_r2_parallel->h5screate_simple_f proc~readarray_hdf5_int32_r2_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_int32_r2_parallel->h5tclose_f proc~readarray_hdf5_int32_r2_parallel->h5pcreate_f proc~readarray_hdf5_int32_r2_parallel->h5pclose_f proc~readarray_hdf5_int32_r2_parallel->h5dget_type_f proc~readarray_hdf5_int32_r2_parallel->h5dclose_f proc~readarray_hdf5_int32_r2_parallel->h5dread_f proc~readarray_hdf5_int32_r2_parallel->h5dget_space_f proc~readarray_hdf5_real_r4_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_real_r4_parallel->h5dopen_f proc~readarray_hdf5_real_r4_parallel->h5sclose_f proc~readarray_hdf5_real_r4_parallel->h5screate_simple_f proc~readarray_hdf5_real_r4_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_real_r4_parallel->h5tclose_f proc~readarray_hdf5_real_r4_parallel->h5pcreate_f proc~readarray_hdf5_real_r4_parallel->h5pclose_f proc~readarray_hdf5_real_r4_parallel->h5dget_type_f proc~readarray_hdf5_real_r4_parallel->h5dclose_f proc~readarray_hdf5_real_r4_parallel->h5dread_f proc~readarray_hdf5_real_r4_parallel->h5dget_space_f proc~readarray_hdf5_real_r7_serial->h5dopen_f proc~readarray_hdf5_real_r7_serial->h5tclose_f proc~readarray_hdf5_real_r7_serial->h5dget_type_f proc~readarray_hdf5_real_r7_serial->h5dclose_f proc~readarray_hdf5_real_r7_serial->h5dread_f proc~readarray_hdf5_int32_r6_serial->h5dopen_f proc~readarray_hdf5_int32_r6_serial->h5tclose_f proc~readarray_hdf5_int32_r6_serial->h5dget_type_f proc~readarray_hdf5_int32_r6_serial->h5dclose_f proc~readarray_hdf5_int32_r6_serial->h5dread_f proc~readarray_hdf5_int32_r2_serial->h5dopen_f proc~readarray_hdf5_int32_r2_serial->h5tclose_f proc~readarray_hdf5_int32_r2_serial->h5dget_type_f proc~readarray_hdf5_int32_r2_serial->h5dclose_f proc~readarray_hdf5_int32_r2_serial->h5dread_f proc~readarray_hdf5_int32_r7_serial->h5dopen_f proc~readarray_hdf5_int32_r7_serial->h5tclose_f proc~readarray_hdf5_int32_r7_serial->h5dget_type_f proc~readarray_hdf5_int32_r7_serial->h5dclose_f proc~readarray_hdf5_int32_r7_serial->h5dread_f proc~readarray_hdf5_real_r6_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_real_r6_parallel->h5dopen_f proc~readarray_hdf5_real_r6_parallel->h5sclose_f proc~readarray_hdf5_real_r6_parallel->h5screate_simple_f proc~readarray_hdf5_real_r6_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_real_r6_parallel->h5tclose_f proc~readarray_hdf5_real_r6_parallel->h5pcreate_f proc~readarray_hdf5_real_r6_parallel->h5pclose_f proc~readarray_hdf5_real_r6_parallel->h5dget_type_f proc~readarray_hdf5_real_r6_parallel->h5dclose_f proc~readarray_hdf5_real_r6_parallel->h5dread_f proc~readarray_hdf5_real_r6_parallel->h5dget_space_f proc~readarray_hdf5_real_r4_serial->h5dopen_f proc~readarray_hdf5_real_r4_serial->h5tclose_f proc~readarray_hdf5_real_r4_serial->h5dget_type_f proc~readarray_hdf5_real_r4_serial->h5dclose_f proc~readarray_hdf5_real_r4_serial->h5dread_f proc~readarray_hdf5_int32_r1_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_int32_r1_parallel->h5dopen_f proc~readarray_hdf5_int32_r1_parallel->h5sclose_f proc~readarray_hdf5_int32_r1_parallel->h5screate_simple_f proc~readarray_hdf5_int32_r1_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_int32_r1_parallel->h5tclose_f proc~readarray_hdf5_int32_r1_parallel->h5pcreate_f proc~readarray_hdf5_int32_r1_parallel->h5pclose_f proc~readarray_hdf5_int32_r1_parallel->h5dget_type_f proc~readarray_hdf5_int32_r1_parallel->h5dclose_f proc~readarray_hdf5_int32_r1_parallel->h5dread_f proc~readarray_hdf5_int32_r1_parallel->h5dget_space_f proc~readarray_hdf5_real_r2_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_real_r2_parallel->h5dopen_f proc~readarray_hdf5_real_r2_parallel->h5sclose_f proc~readarray_hdf5_real_r2_parallel->h5screate_simple_f proc~readarray_hdf5_real_r2_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_real_r2_parallel->h5tclose_f proc~readarray_hdf5_real_r2_parallel->h5pcreate_f proc~readarray_hdf5_real_r2_parallel->h5pclose_f proc~readarray_hdf5_real_r2_parallel->h5dget_type_f proc~readarray_hdf5_real_r2_parallel->h5dclose_f proc~readarray_hdf5_real_r2_parallel->h5dread_f proc~readarray_hdf5_real_r2_parallel->h5dget_space_f proc~readarray_hdf5_int64_r5_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_int64_r5_parallel->h5dopen_f proc~readarray_hdf5_int64_r5_parallel->h5sclose_f proc~readarray_hdf5_int64_r5_parallel->h5screate_simple_f proc~readarray_hdf5_int64_r5_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_int64_r5_parallel->h5tclose_f proc~readarray_hdf5_int64_r5_parallel->h5pcreate_f proc~readarray_hdf5_int64_r5_parallel->h5pclose_f proc~readarray_hdf5_int64_r5_parallel->h5dget_type_f proc~readarray_hdf5_int64_r5_parallel->h5dclose_f proc~readarray_hdf5_int64_r5_parallel->h5dread_f proc~readarray_hdf5_int64_r5_parallel->h5dget_space_f proc~readarray_hdf5_int32_r6_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_int32_r6_parallel->h5dopen_f proc~readarray_hdf5_int32_r6_parallel->h5sclose_f proc~readarray_hdf5_int32_r6_parallel->h5screate_simple_f proc~readarray_hdf5_int32_r6_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_int32_r6_parallel->h5tclose_f proc~readarray_hdf5_int32_r6_parallel->h5pcreate_f proc~readarray_hdf5_int32_r6_parallel->h5pclose_f proc~readarray_hdf5_int32_r6_parallel->h5dget_type_f proc~readarray_hdf5_int32_r6_parallel->h5dclose_f proc~readarray_hdf5_int32_r6_parallel->h5dread_f proc~readarray_hdf5_int32_r6_parallel->h5dget_space_f proc~readarray_hdf5_int64_r3_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_int64_r3_parallel->h5dopen_f proc~readarray_hdf5_int64_r3_parallel->h5sclose_f proc~readarray_hdf5_int64_r3_parallel->h5screate_simple_f proc~readarray_hdf5_int64_r3_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_int64_r3_parallel->h5tclose_f proc~readarray_hdf5_int64_r3_parallel->h5pcreate_f proc~readarray_hdf5_int64_r3_parallel->h5pclose_f proc~readarray_hdf5_int64_r3_parallel->h5dget_type_f proc~readarray_hdf5_int64_r3_parallel->h5dclose_f proc~readarray_hdf5_int64_r3_parallel->h5dread_f proc~readarray_hdf5_int64_r3_parallel->h5dget_space_f proc~readarray_hdf5_int32_r7_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_int32_r7_parallel->h5dopen_f proc~readarray_hdf5_int32_r7_parallel->h5sclose_f proc~readarray_hdf5_int32_r7_parallel->h5screate_simple_f proc~readarray_hdf5_int32_r7_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_int32_r7_parallel->h5tclose_f proc~readarray_hdf5_int32_r7_parallel->h5pcreate_f proc~readarray_hdf5_int32_r7_parallel->h5pclose_f proc~readarray_hdf5_int32_r7_parallel->h5dget_type_f proc~readarray_hdf5_int32_r7_parallel->h5dclose_f proc~readarray_hdf5_int32_r7_parallel->h5dread_f proc~readarray_hdf5_int32_r7_parallel->h5dget_space_f proc~readarray_hdf5_int64_r3_serial->h5dopen_f proc~readarray_hdf5_int64_r3_serial->h5tclose_f proc~readarray_hdf5_int64_r3_serial->h5dget_type_f proc~readarray_hdf5_int64_r3_serial->h5dclose_f proc~readarray_hdf5_int64_r3_serial->h5dread_f proc~readarray_hdf5_int64_r2_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_int64_r2_parallel->h5dopen_f proc~readarray_hdf5_int64_r2_parallel->h5sclose_f proc~readarray_hdf5_int64_r2_parallel->h5screate_simple_f proc~readarray_hdf5_int64_r2_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_int64_r2_parallel->h5tclose_f proc~readarray_hdf5_int64_r2_parallel->h5pcreate_f proc~readarray_hdf5_int64_r2_parallel->h5pclose_f proc~readarray_hdf5_int64_r2_parallel->h5dget_type_f proc~readarray_hdf5_int64_r2_parallel->h5dclose_f proc~readarray_hdf5_int64_r2_parallel->h5dread_f proc~readarray_hdf5_int64_r2_parallel->h5dget_space_f proc~readarray_hdf5_int64_r7_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_int64_r7_parallel->h5dopen_f proc~readarray_hdf5_int64_r7_parallel->h5sclose_f proc~readarray_hdf5_int64_r7_parallel->h5screate_simple_f proc~readarray_hdf5_int64_r7_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_int64_r7_parallel->h5tclose_f proc~readarray_hdf5_int64_r7_parallel->h5pcreate_f proc~readarray_hdf5_int64_r7_parallel->h5pclose_f proc~readarray_hdf5_int64_r7_parallel->h5dget_type_f proc~readarray_hdf5_int64_r7_parallel->h5dclose_f proc~readarray_hdf5_int64_r7_parallel->h5dread_f proc~readarray_hdf5_int64_r7_parallel->h5dget_space_f proc~readarray_hdf5_real_r2_serial->h5dopen_f proc~readarray_hdf5_real_r2_serial->h5tclose_f proc~readarray_hdf5_real_r2_serial->h5dget_type_f proc~readarray_hdf5_real_r2_serial->h5dclose_f proc~readarray_hdf5_real_r2_serial->h5dread_f proc~readarray_hdf5_int64_r1_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_int64_r1_parallel->h5dopen_f proc~readarray_hdf5_int64_r1_parallel->h5sclose_f proc~readarray_hdf5_int64_r1_parallel->h5screate_simple_f proc~readarray_hdf5_int64_r1_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_int64_r1_parallel->h5tclose_f proc~readarray_hdf5_int64_r1_parallel->h5pcreate_f proc~readarray_hdf5_int64_r1_parallel->h5pclose_f proc~readarray_hdf5_int64_r1_parallel->h5dget_type_f proc~readarray_hdf5_int64_r1_parallel->h5dclose_f proc~readarray_hdf5_int64_r1_parallel->h5dread_f proc~readarray_hdf5_int64_r1_parallel->h5dget_space_f proc~readarray_hdf5_real_r7_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_real_r7_parallel->h5dopen_f proc~readarray_hdf5_real_r7_parallel->h5sclose_f proc~readarray_hdf5_real_r7_parallel->h5screate_simple_f proc~readarray_hdf5_real_r7_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_real_r7_parallel->h5tclose_f proc~readarray_hdf5_real_r7_parallel->h5pcreate_f proc~readarray_hdf5_real_r7_parallel->h5pclose_f proc~readarray_hdf5_real_r7_parallel->h5dget_type_f proc~readarray_hdf5_real_r7_parallel->h5dclose_f proc~readarray_hdf5_real_r7_parallel->h5dread_f proc~readarray_hdf5_real_r7_parallel->h5dget_space_f proc~readarray_hdf5_int64_r7_serial->h5dopen_f proc~readarray_hdf5_int64_r7_serial->h5tclose_f proc~readarray_hdf5_int64_r7_serial->h5dget_type_f proc~readarray_hdf5_int64_r7_serial->h5dclose_f proc~readarray_hdf5_int64_r7_serial->h5dread_f proc~readarray_hdf5_int64_r6_serial->h5dopen_f proc~readarray_hdf5_int64_r6_serial->h5tclose_f proc~readarray_hdf5_int64_r6_serial->h5dget_type_f proc~readarray_hdf5_int64_r6_serial->h5dclose_f proc~readarray_hdf5_int64_r6_serial->h5dread_f proc~readarray_hdf5_real_r5_serial->h5dopen_f proc~readarray_hdf5_real_r5_serial->h5tclose_f proc~readarray_hdf5_real_r5_serial->h5dget_type_f proc~readarray_hdf5_real_r5_serial->h5dclose_f proc~readarray_hdf5_real_r5_serial->h5dread_f proc~readarray_hdf5_int64_r1_serial->h5dopen_f proc~readarray_hdf5_int64_r1_serial->h5tclose_f proc~readarray_hdf5_int64_r1_serial->h5dget_type_f proc~readarray_hdf5_int64_r1_serial->h5dclose_f proc~readarray_hdf5_int64_r1_serial->h5dread_f proc~readarray_hdf5_int64_r4_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_int64_r4_parallel->h5dopen_f proc~readarray_hdf5_int64_r4_parallel->h5sclose_f proc~readarray_hdf5_int64_r4_parallel->h5screate_simple_f proc~readarray_hdf5_int64_r4_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_int64_r4_parallel->h5tclose_f proc~readarray_hdf5_int64_r4_parallel->h5pcreate_f proc~readarray_hdf5_int64_r4_parallel->h5pclose_f proc~readarray_hdf5_int64_r4_parallel->h5dget_type_f proc~readarray_hdf5_int64_r4_parallel->h5dclose_f proc~readarray_hdf5_int64_r4_parallel->h5dread_f proc~readarray_hdf5_int64_r4_parallel->h5dget_space_f proc~readarray_hdf5_real_r6_serial->h5dopen_f proc~readarray_hdf5_real_r6_serial->h5tclose_f proc~readarray_hdf5_real_r6_serial->h5dget_type_f proc~readarray_hdf5_real_r6_serial->h5dclose_f proc~readarray_hdf5_real_r6_serial->h5dread_f proc~readarray_hdf5_real_r3_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_real_r3_parallel->h5dopen_f proc~readarray_hdf5_real_r3_parallel->h5sclose_f proc~readarray_hdf5_real_r3_parallel->h5screate_simple_f proc~readarray_hdf5_real_r3_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_real_r3_parallel->h5tclose_f proc~readarray_hdf5_real_r3_parallel->h5pcreate_f proc~readarray_hdf5_real_r3_parallel->h5pclose_f proc~readarray_hdf5_real_r3_parallel->h5dget_type_f proc~readarray_hdf5_real_r3_parallel->h5dclose_f proc~readarray_hdf5_real_r3_parallel->h5dread_f proc~readarray_hdf5_real_r3_parallel->h5dget_space_f proc~readarray_hdf5_int32_r5_serial->h5dopen_f proc~readarray_hdf5_int32_r5_serial->h5tclose_f proc~readarray_hdf5_int32_r5_serial->h5dget_type_f proc~readarray_hdf5_int32_r5_serial->h5dclose_f proc~readarray_hdf5_int32_r5_serial->h5dread_f proc~readarray_hdf5_int64_r5_serial->h5dopen_f proc~readarray_hdf5_int64_r5_serial->h5tclose_f proc~readarray_hdf5_int64_r5_serial->h5dget_type_f proc~readarray_hdf5_int64_r5_serial->h5dclose_f proc~readarray_hdf5_int64_r5_serial->h5dread_f proc~readarray_hdf5_int32_r3_serial->h5dopen_f proc~readarray_hdf5_int32_r3_serial->h5tclose_f proc~readarray_hdf5_int32_r3_serial->h5dget_type_f proc~readarray_hdf5_int32_r3_serial->h5dclose_f proc~readarray_hdf5_int32_r3_serial->h5dread_f proc~readarray_hdf5_int32_r4_serial->h5dopen_f proc~readarray_hdf5_int32_r4_serial->h5tclose_f proc~readarray_hdf5_int32_r4_serial->h5dget_type_f proc~readarray_hdf5_int32_r4_serial->h5dclose_f proc~readarray_hdf5_int32_r4_serial->h5dread_f proc~readarray_hdf5_int64_r2_serial->h5dopen_f proc~readarray_hdf5_int64_r2_serial->h5tclose_f proc~readarray_hdf5_int64_r2_serial->h5dget_type_f proc~readarray_hdf5_int64_r2_serial->h5dclose_f proc~readarray_hdf5_int64_r2_serial->h5dread_f proc~readarray_hdf5_int32_r3_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_int32_r3_parallel->h5dopen_f proc~readarray_hdf5_int32_r3_parallel->h5sclose_f proc~readarray_hdf5_int32_r3_parallel->h5screate_simple_f proc~readarray_hdf5_int32_r3_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_int32_r3_parallel->h5tclose_f proc~readarray_hdf5_int32_r3_parallel->h5pcreate_f proc~readarray_hdf5_int32_r3_parallel->h5pclose_f proc~readarray_hdf5_int32_r3_parallel->h5dget_type_f proc~readarray_hdf5_int32_r3_parallel->h5dclose_f proc~readarray_hdf5_int32_r3_parallel->h5dread_f proc~readarray_hdf5_int32_r3_parallel->h5dget_space_f proc~readarray_hdf5_int32_r5_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_int32_r5_parallel->h5dopen_f proc~readarray_hdf5_int32_r5_parallel->h5sclose_f proc~readarray_hdf5_int32_r5_parallel->h5screate_simple_f proc~readarray_hdf5_int32_r5_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_int32_r5_parallel->h5tclose_f proc~readarray_hdf5_int32_r5_parallel->h5pcreate_f proc~readarray_hdf5_int32_r5_parallel->h5pclose_f proc~readarray_hdf5_int32_r5_parallel->h5dget_type_f proc~readarray_hdf5_int32_r5_parallel->h5dclose_f proc~readarray_hdf5_int32_r5_parallel->h5dread_f proc~readarray_hdf5_int32_r5_parallel->h5dget_space_f proc~readarray_hdf5_real_r1_parallel->h5pset_dxpl_mpio_f proc~readarray_hdf5_real_r1_parallel->h5dopen_f proc~readarray_hdf5_real_r1_parallel->h5sclose_f proc~readarray_hdf5_real_r1_parallel->h5screate_simple_f proc~readarray_hdf5_real_r1_parallel->h5sselect_hyperslab_f proc~readarray_hdf5_real_r1_parallel->h5tclose_f proc~readarray_hdf5_real_r1_parallel->h5pcreate_f proc~readarray_hdf5_real_r1_parallel->h5pclose_f proc~readarray_hdf5_real_r1_parallel->h5dget_type_f proc~readarray_hdf5_real_r1_parallel->h5dclose_f proc~readarray_hdf5_real_r1_parallel->h5dread_f proc~readarray_hdf5_real_r1_parallel->h5dget_space_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures ReadArray_HDF5_real_r1_serial ReadArray_HDF5_real_r2_serial ReadArray_HDF5_real_r3_serial ReadArray_HDF5_real_r4_serial ReadArray_HDF5_real_r5_serial ReadArray_HDF5_real_r6_serial ReadArray_HDF5_real_r7_serial ReadArray_HDF5_int32_r1_serial ReadArray_HDF5_int32_r2_serial ReadArray_HDF5_int32_r3_serial ReadArray_HDF5_int32_r4_serial ReadArray_HDF5_int32_r5_serial ReadArray_HDF5_int32_r6_serial ReadArray_HDF5_int32_r7_serial ReadArray_HDF5_int64_r1_serial ReadArray_HDF5_int64_r2_serial ReadArray_HDF5_int64_r3_serial ReadArray_HDF5_int64_r4_serial ReadArray_HDF5_int64_r5_serial ReadArray_HDF5_int64_r6_serial ReadArray_HDF5_int64_r7_serial ReadArray_HDF5_real_r1_parallel ReadArray_HDF5_real_r2_parallel ReadArray_HDF5_real_r3_parallel ReadArray_HDF5_real_r4_parallel ReadArray_HDF5_real_r5_parallel ReadArray_HDF5_real_r6_parallel ReadArray_HDF5_real_r7_parallel ReadArray_HDF5_int32_r1_parallel ReadArray_HDF5_int32_r2_parallel ReadArray_HDF5_int32_r3_parallel ReadArray_HDF5_int32_r4_parallel ReadArray_HDF5_int32_r5_parallel ReadArray_HDF5_int32_r6_parallel ReadArray_HDF5_int32_r7_parallel ReadArray_HDF5_int64_r1_parallel ReadArray_HDF5_int64_r2_parallel ReadArray_HDF5_int64_r3_parallel ReadArray_HDF5_int64_r4_parallel ReadArray_HDF5_int64_r5_parallel ReadArray_HDF5_int64_r6_parallel ReadArray_HDF5_int64_r7_parallel Module Procedures private subroutine ReadArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r1), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r2), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r3), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r4), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r5), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r6), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r7), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r1), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r2), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r3), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r4), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r5), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r6), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r7), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_real_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) private subroutine ReadArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) private subroutine ReadArray_HDF5_real_r5_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) private subroutine ReadArray_HDF5_real_r6_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) private subroutine ReadArray_HDF5_real_r7_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) private subroutine ReadArray_HDF5_int32_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r1), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_int32_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r2), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_int32_r3_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r3), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) private subroutine ReadArray_HDF5_int32_r4_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r4), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) private subroutine ReadArray_HDF5_int32_r5_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r5), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) private subroutine ReadArray_HDF5_int32_r6_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r6), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) private subroutine ReadArray_HDF5_int32_r7_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r7), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) private subroutine ReadArray_HDF5_int64_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r1), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_int64_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r2), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_int64_r3_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r3), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) private subroutine ReadArray_HDF5_int64_r4_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r4), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) private subroutine ReadArray_HDF5_int64_r5_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r5), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) private subroutine ReadArray_HDF5_int64_r6_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r6), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) private subroutine ReadArray_HDF5_int64_r7_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r7), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7)","tags":"","loc":"interface/readarray_hdf5.html"},{"title":"ReadAttribute_HDF5 – SELF","text":"public interface ReadAttribute_HDF5 Calls interface~~readattribute_hdf5~~CallsGraph interface~readattribute_hdf5 ReadAttribute_HDF5 proc~readattribute_hdf5_character ReadAttribute_HDF5_character interface~readattribute_hdf5->proc~readattribute_hdf5_character proc~readattribute_hdf5_int32 ReadAttribute_HDF5_int32 interface~readattribute_hdf5->proc~readattribute_hdf5_int32 proc~readattribute_hdf5_real ReadAttribute_HDF5_real interface~readattribute_hdf5->proc~readattribute_hdf5_real h5aread_f h5aread_f proc~readattribute_hdf5_character->h5aread_f h5tclose_f h5tclose_f proc~readattribute_hdf5_character->h5tclose_f h5aget_type_f h5aget_type_f proc~readattribute_hdf5_character->h5aget_type_f h5aclose_f h5aclose_f proc~readattribute_hdf5_character->h5aclose_f h5aopen_f h5aopen_f proc~readattribute_hdf5_character->h5aopen_f proc~readattribute_hdf5_int32->h5aread_f proc~readattribute_hdf5_int32->h5tclose_f proc~readattribute_hdf5_int32->h5aget_type_f proc~readattribute_hdf5_int32->h5aclose_f proc~readattribute_hdf5_int32->h5aopen_f proc~readattribute_hdf5_real->h5aread_f proc~readattribute_hdf5_real->h5tclose_f proc~readattribute_hdf5_real->h5aget_type_f proc~readattribute_hdf5_real->h5aclose_f proc~readattribute_hdf5_real->h5aopen_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures ReadAttribute_HDF5_int32 ReadAttribute_HDF5_real ReadAttribute_HDF5_character Module Procedures private subroutine ReadAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(out) :: attribute private subroutine ReadAttribute_HDF5_real (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(out) :: attribute private subroutine ReadAttribute_HDF5_character (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(out) :: attribute","tags":"","loc":"interface/readattribute_hdf5.html"},{"title":"WriteArray_HDF5 – SELF","text":"public interface WriteArray_HDF5 Calls interface~~writearray_hdf5~~CallsGraph interface~writearray_hdf5 WriteArray_HDF5 proc~writearray_hdf5_int32_r7_parallel WriteArray_HDF5_int32_r7_parallel interface~writearray_hdf5->proc~writearray_hdf5_int32_r7_parallel proc~writearray_hdf5_int64_r3_parallel WriteArray_HDF5_int64_r3_parallel interface~writearray_hdf5->proc~writearray_hdf5_int64_r3_parallel proc~writearray_hdf5_int64_r5_serial WriteArray_HDF5_int64_r5_serial interface~writearray_hdf5->proc~writearray_hdf5_int64_r5_serial proc~writearray_hdf5_real_r1_serial WriteArray_HDF5_real_r1_serial interface~writearray_hdf5->proc~writearray_hdf5_real_r1_serial proc~writearray_hdf5_int64_r7_parallel WriteArray_HDF5_int64_r7_parallel interface~writearray_hdf5->proc~writearray_hdf5_int64_r7_parallel proc~writearray_hdf5_int64_r7_serial WriteArray_HDF5_int64_r7_serial interface~writearray_hdf5->proc~writearray_hdf5_int64_r7_serial proc~writearray_hdf5_int64_r2_serial WriteArray_HDF5_int64_r2_serial interface~writearray_hdf5->proc~writearray_hdf5_int64_r2_serial proc~writearray_hdf5_int32_r2_parallel WriteArray_HDF5_int32_r2_parallel interface~writearray_hdf5->proc~writearray_hdf5_int32_r2_parallel proc~writearray_hdf5_int32_r3_parallel WriteArray_HDF5_int32_r3_parallel interface~writearray_hdf5->proc~writearray_hdf5_int32_r3_parallel proc~writearray_hdf5_int64_r4_serial WriteArray_HDF5_int64_r4_serial interface~writearray_hdf5->proc~writearray_hdf5_int64_r4_serial proc~writearray_hdf5_real_r5_parallel WriteArray_HDF5_real_r5_parallel interface~writearray_hdf5->proc~writearray_hdf5_real_r5_parallel proc~writearray_hdf5_real_r4_serial WriteArray_HDF5_real_r4_serial interface~writearray_hdf5->proc~writearray_hdf5_real_r4_serial proc~writearray_hdf5_int32_r6_serial WriteArray_HDF5_int32_r6_serial interface~writearray_hdf5->proc~writearray_hdf5_int32_r6_serial proc~writearray_hdf5_int64_r1_parallel WriteArray_HDF5_int64_r1_parallel interface~writearray_hdf5->proc~writearray_hdf5_int64_r1_parallel proc~writearray_hdf5_real_r4_parallel WriteArray_HDF5_real_r4_parallel interface~writearray_hdf5->proc~writearray_hdf5_real_r4_parallel proc~writearray_hdf5_int32_r6_parallel WriteArray_HDF5_int32_r6_parallel interface~writearray_hdf5->proc~writearray_hdf5_int32_r6_parallel proc~writearray_hdf5_real_r2_parallel WriteArray_HDF5_real_r2_parallel interface~writearray_hdf5->proc~writearray_hdf5_real_r2_parallel proc~writearray_hdf5_int32_r2_serial WriteArray_HDF5_int32_r2_serial interface~writearray_hdf5->proc~writearray_hdf5_int32_r2_serial proc~writearray_hdf5_real_r6_serial WriteArray_HDF5_real_r6_serial interface~writearray_hdf5->proc~writearray_hdf5_real_r6_serial proc~writearray_hdf5_int64_r6_parallel WriteArray_HDF5_int64_r6_parallel interface~writearray_hdf5->proc~writearray_hdf5_int64_r6_parallel proc~writearray_hdf5_real_r5_serial WriteArray_HDF5_real_r5_serial interface~writearray_hdf5->proc~writearray_hdf5_real_r5_serial proc~writearray_hdf5_int64_r3_serial WriteArray_HDF5_int64_r3_serial interface~writearray_hdf5->proc~writearray_hdf5_int64_r3_serial proc~writearray_hdf5_real_r7_parallel WriteArray_HDF5_real_r7_parallel interface~writearray_hdf5->proc~writearray_hdf5_real_r7_parallel proc~writearray_hdf5_int32_r4_parallel WriteArray_HDF5_int32_r4_parallel interface~writearray_hdf5->proc~writearray_hdf5_int32_r4_parallel proc~writearray_hdf5_int32_r7_serial WriteArray_HDF5_int32_r7_serial interface~writearray_hdf5->proc~writearray_hdf5_int32_r7_serial proc~writearray_hdf5_int64_r1_serial WriteArray_HDF5_int64_r1_serial interface~writearray_hdf5->proc~writearray_hdf5_int64_r1_serial proc~writearray_hdf5_int64_r6_serial WriteArray_HDF5_int64_r6_serial interface~writearray_hdf5->proc~writearray_hdf5_int64_r6_serial proc~writearray_hdf5_int32_r4_serial WriteArray_HDF5_int32_r4_serial interface~writearray_hdf5->proc~writearray_hdf5_int32_r4_serial proc~writearray_hdf5_int64_r2_parallel WriteArray_HDF5_int64_r2_parallel interface~writearray_hdf5->proc~writearray_hdf5_int64_r2_parallel proc~writearray_hdf5_int32_r5_serial WriteArray_HDF5_int32_r5_serial interface~writearray_hdf5->proc~writearray_hdf5_int32_r5_serial proc~writearray_hdf5_int32_r3_serial WriteArray_HDF5_int32_r3_serial interface~writearray_hdf5->proc~writearray_hdf5_int32_r3_serial proc~writearray_hdf5_real_r1_parallel WriteArray_HDF5_real_r1_parallel interface~writearray_hdf5->proc~writearray_hdf5_real_r1_parallel proc~writearray_hdf5_real_r3_serial WriteArray_HDF5_real_r3_serial interface~writearray_hdf5->proc~writearray_hdf5_real_r3_serial proc~writearray_hdf5_int32_r1_parallel WriteArray_HDF5_int32_r1_parallel interface~writearray_hdf5->proc~writearray_hdf5_int32_r1_parallel proc~writearray_hdf5_real_r2_serial WriteArray_HDF5_real_r2_serial interface~writearray_hdf5->proc~writearray_hdf5_real_r2_serial proc~writearray_hdf5_int64_r4_parallel WriteArray_HDF5_int64_r4_parallel interface~writearray_hdf5->proc~writearray_hdf5_int64_r4_parallel proc~writearray_hdf5_real_r6_parallel WriteArray_HDF5_real_r6_parallel interface~writearray_hdf5->proc~writearray_hdf5_real_r6_parallel proc~writearray_hdf5_real_r7_serial WriteArray_HDF5_real_r7_serial interface~writearray_hdf5->proc~writearray_hdf5_real_r7_serial proc~writearray_hdf5_real_r3_parallel WriteArray_HDF5_real_r3_parallel interface~writearray_hdf5->proc~writearray_hdf5_real_r3_parallel proc~writearray_hdf5_int64_r5_parallel WriteArray_HDF5_int64_r5_parallel interface~writearray_hdf5->proc~writearray_hdf5_int64_r5_parallel proc~writearray_hdf5_int32_r1_serial WriteArray_HDF5_int32_r1_serial interface~writearray_hdf5->proc~writearray_hdf5_int32_r1_serial proc~writearray_hdf5_int32_r5_parallel WriteArray_HDF5_int32_r5_parallel interface~writearray_hdf5->proc~writearray_hdf5_int32_r5_parallel h5sclose_f h5sclose_f proc~writearray_hdf5_int32_r7_parallel->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writearray_hdf5_int32_r7_parallel->h5screate_simple_f h5dcreate_f h5dcreate_f proc~writearray_hdf5_int32_r7_parallel->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~writearray_hdf5_int32_r7_parallel->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~writearray_hdf5_int32_r7_parallel->h5pcreate_f h5pclose_f h5pclose_f proc~writearray_hdf5_int32_r7_parallel->h5pclose_f h5dwrite_f h5dwrite_f proc~writearray_hdf5_int32_r7_parallel->h5dwrite_f h5dclose_f h5dclose_f proc~writearray_hdf5_int32_r7_parallel->h5dclose_f h5sselect_hyperslab_f h5sselect_hyperslab_f proc~writearray_hdf5_int32_r7_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_int64_r3_parallel->h5sclose_f proc~writearray_hdf5_int64_r3_parallel->h5screate_simple_f proc~writearray_hdf5_int64_r3_parallel->h5dcreate_f proc~writearray_hdf5_int64_r3_parallel->h5pset_chunk_f proc~writearray_hdf5_int64_r3_parallel->h5pcreate_f proc~writearray_hdf5_int64_r3_parallel->h5pclose_f proc~writearray_hdf5_int64_r3_parallel->h5dwrite_f proc~writearray_hdf5_int64_r3_parallel->h5dclose_f proc~writearray_hdf5_int64_r3_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_int64_r5_serial->h5sclose_f proc~writearray_hdf5_int64_r5_serial->h5screate_simple_f proc~writearray_hdf5_int64_r5_serial->h5dcreate_f proc~writearray_hdf5_int64_r5_serial->h5dwrite_f proc~writearray_hdf5_int64_r5_serial->h5dclose_f proc~writearray_hdf5_real_r1_serial->h5sclose_f proc~writearray_hdf5_real_r1_serial->h5screate_simple_f proc~writearray_hdf5_real_r1_serial->h5dcreate_f proc~writearray_hdf5_real_r1_serial->h5dwrite_f proc~writearray_hdf5_real_r1_serial->h5dclose_f proc~writearray_hdf5_int64_r7_parallel->h5sclose_f proc~writearray_hdf5_int64_r7_parallel->h5screate_simple_f proc~writearray_hdf5_int64_r7_parallel->h5dcreate_f proc~writearray_hdf5_int64_r7_parallel->h5pset_chunk_f proc~writearray_hdf5_int64_r7_parallel->h5pcreate_f proc~writearray_hdf5_int64_r7_parallel->h5pclose_f proc~writearray_hdf5_int64_r7_parallel->h5dwrite_f proc~writearray_hdf5_int64_r7_parallel->h5dclose_f proc~writearray_hdf5_int64_r7_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_int64_r7_serial->h5sclose_f proc~writearray_hdf5_int64_r7_serial->h5screate_simple_f proc~writearray_hdf5_int64_r7_serial->h5dcreate_f proc~writearray_hdf5_int64_r7_serial->h5dwrite_f proc~writearray_hdf5_int64_r7_serial->h5dclose_f proc~writearray_hdf5_int64_r2_serial->h5sclose_f proc~writearray_hdf5_int64_r2_serial->h5screate_simple_f proc~writearray_hdf5_int64_r2_serial->h5dcreate_f proc~writearray_hdf5_int64_r2_serial->h5dwrite_f proc~writearray_hdf5_int64_r2_serial->h5dclose_f proc~writearray_hdf5_int32_r2_parallel->h5sclose_f proc~writearray_hdf5_int32_r2_parallel->h5screate_simple_f proc~writearray_hdf5_int32_r2_parallel->h5dcreate_f proc~writearray_hdf5_int32_r2_parallel->h5pset_chunk_f proc~writearray_hdf5_int32_r2_parallel->h5pcreate_f proc~writearray_hdf5_int32_r2_parallel->h5pclose_f proc~writearray_hdf5_int32_r2_parallel->h5dwrite_f proc~writearray_hdf5_int32_r2_parallel->h5dclose_f proc~writearray_hdf5_int32_r2_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_int32_r3_parallel->h5sclose_f proc~writearray_hdf5_int32_r3_parallel->h5screate_simple_f proc~writearray_hdf5_int32_r3_parallel->h5dcreate_f proc~writearray_hdf5_int32_r3_parallel->h5pset_chunk_f proc~writearray_hdf5_int32_r3_parallel->h5pcreate_f proc~writearray_hdf5_int32_r3_parallel->h5pclose_f proc~writearray_hdf5_int32_r3_parallel->h5dwrite_f proc~writearray_hdf5_int32_r3_parallel->h5dclose_f proc~writearray_hdf5_int32_r3_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_int64_r4_serial->h5sclose_f proc~writearray_hdf5_int64_r4_serial->h5screate_simple_f proc~writearray_hdf5_int64_r4_serial->h5dcreate_f proc~writearray_hdf5_int64_r4_serial->h5dwrite_f proc~writearray_hdf5_int64_r4_serial->h5dclose_f proc~writearray_hdf5_real_r5_parallel->h5sclose_f proc~writearray_hdf5_real_r5_parallel->h5screate_simple_f proc~writearray_hdf5_real_r5_parallel->h5dcreate_f proc~writearray_hdf5_real_r5_parallel->h5pset_chunk_f proc~writearray_hdf5_real_r5_parallel->h5pcreate_f proc~writearray_hdf5_real_r5_parallel->h5pclose_f proc~writearray_hdf5_real_r5_parallel->h5dwrite_f proc~writearray_hdf5_real_r5_parallel->h5dclose_f proc~writearray_hdf5_real_r5_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_real_r4_serial->h5sclose_f proc~writearray_hdf5_real_r4_serial->h5screate_simple_f proc~writearray_hdf5_real_r4_serial->h5dcreate_f proc~writearray_hdf5_real_r4_serial->h5dwrite_f proc~writearray_hdf5_real_r4_serial->h5dclose_f proc~writearray_hdf5_int32_r6_serial->h5sclose_f proc~writearray_hdf5_int32_r6_serial->h5screate_simple_f proc~writearray_hdf5_int32_r6_serial->h5dcreate_f proc~writearray_hdf5_int32_r6_serial->h5dwrite_f proc~writearray_hdf5_int32_r6_serial->h5dclose_f proc~writearray_hdf5_int64_r1_parallel->h5sclose_f proc~writearray_hdf5_int64_r1_parallel->h5screate_simple_f proc~writearray_hdf5_int64_r1_parallel->h5dcreate_f proc~writearray_hdf5_int64_r1_parallel->h5pset_chunk_f proc~writearray_hdf5_int64_r1_parallel->h5pcreate_f proc~writearray_hdf5_int64_r1_parallel->h5pclose_f proc~writearray_hdf5_int64_r1_parallel->h5dwrite_f proc~writearray_hdf5_int64_r1_parallel->h5dclose_f proc~writearray_hdf5_int64_r1_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_real_r4_parallel->h5sclose_f proc~writearray_hdf5_real_r4_parallel->h5screate_simple_f proc~writearray_hdf5_real_r4_parallel->h5dcreate_f proc~writearray_hdf5_real_r4_parallel->h5pset_chunk_f proc~writearray_hdf5_real_r4_parallel->h5pcreate_f proc~writearray_hdf5_real_r4_parallel->h5pclose_f proc~writearray_hdf5_real_r4_parallel->h5dwrite_f proc~writearray_hdf5_real_r4_parallel->h5dclose_f proc~writearray_hdf5_real_r4_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_int32_r6_parallel->h5sclose_f proc~writearray_hdf5_int32_r6_parallel->h5screate_simple_f proc~writearray_hdf5_int32_r6_parallel->h5dcreate_f proc~writearray_hdf5_int32_r6_parallel->h5pset_chunk_f proc~writearray_hdf5_int32_r6_parallel->h5pcreate_f proc~writearray_hdf5_int32_r6_parallel->h5pclose_f proc~writearray_hdf5_int32_r6_parallel->h5dwrite_f proc~writearray_hdf5_int32_r6_parallel->h5dclose_f proc~writearray_hdf5_int32_r6_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_real_r2_parallel->h5sclose_f proc~writearray_hdf5_real_r2_parallel->h5screate_simple_f proc~writearray_hdf5_real_r2_parallel->h5dcreate_f proc~writearray_hdf5_real_r2_parallel->h5pset_chunk_f proc~writearray_hdf5_real_r2_parallel->h5pcreate_f proc~writearray_hdf5_real_r2_parallel->h5pclose_f proc~writearray_hdf5_real_r2_parallel->h5dwrite_f proc~writearray_hdf5_real_r2_parallel->h5dclose_f proc~writearray_hdf5_real_r2_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_int32_r2_serial->h5sclose_f proc~writearray_hdf5_int32_r2_serial->h5screate_simple_f proc~writearray_hdf5_int32_r2_serial->h5dcreate_f proc~writearray_hdf5_int32_r2_serial->h5dwrite_f proc~writearray_hdf5_int32_r2_serial->h5dclose_f proc~writearray_hdf5_real_r6_serial->h5sclose_f proc~writearray_hdf5_real_r6_serial->h5screate_simple_f proc~writearray_hdf5_real_r6_serial->h5dcreate_f proc~writearray_hdf5_real_r6_serial->h5dwrite_f proc~writearray_hdf5_real_r6_serial->h5dclose_f proc~writearray_hdf5_int64_r6_parallel->h5sclose_f proc~writearray_hdf5_int64_r6_parallel->h5screate_simple_f proc~writearray_hdf5_int64_r6_parallel->h5dcreate_f proc~writearray_hdf5_int64_r6_parallel->h5pset_chunk_f proc~writearray_hdf5_int64_r6_parallel->h5pcreate_f proc~writearray_hdf5_int64_r6_parallel->h5pclose_f proc~writearray_hdf5_int64_r6_parallel->h5dwrite_f proc~writearray_hdf5_int64_r6_parallel->h5dclose_f proc~writearray_hdf5_int64_r6_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_real_r5_serial->h5sclose_f proc~writearray_hdf5_real_r5_serial->h5screate_simple_f proc~writearray_hdf5_real_r5_serial->h5dcreate_f proc~writearray_hdf5_real_r5_serial->h5dwrite_f proc~writearray_hdf5_real_r5_serial->h5dclose_f proc~writearray_hdf5_int64_r3_serial->h5sclose_f proc~writearray_hdf5_int64_r3_serial->h5screate_simple_f proc~writearray_hdf5_int64_r3_serial->h5dcreate_f proc~writearray_hdf5_int64_r3_serial->h5dwrite_f proc~writearray_hdf5_int64_r3_serial->h5dclose_f proc~writearray_hdf5_real_r7_parallel->h5sclose_f proc~writearray_hdf5_real_r7_parallel->h5screate_simple_f proc~writearray_hdf5_real_r7_parallel->h5dcreate_f proc~writearray_hdf5_real_r7_parallel->h5pset_chunk_f proc~writearray_hdf5_real_r7_parallel->h5pcreate_f proc~writearray_hdf5_real_r7_parallel->h5pclose_f proc~writearray_hdf5_real_r7_parallel->h5dwrite_f proc~writearray_hdf5_real_r7_parallel->h5dclose_f proc~writearray_hdf5_real_r7_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_int32_r4_parallel->h5sclose_f proc~writearray_hdf5_int32_r4_parallel->h5screate_simple_f proc~writearray_hdf5_int32_r4_parallel->h5dcreate_f proc~writearray_hdf5_int32_r4_parallel->h5pset_chunk_f proc~writearray_hdf5_int32_r4_parallel->h5pcreate_f proc~writearray_hdf5_int32_r4_parallel->h5pclose_f proc~writearray_hdf5_int32_r4_parallel->h5dwrite_f proc~writearray_hdf5_int32_r4_parallel->h5dclose_f proc~writearray_hdf5_int32_r4_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_int32_r7_serial->h5sclose_f proc~writearray_hdf5_int32_r7_serial->h5screate_simple_f proc~writearray_hdf5_int32_r7_serial->h5dcreate_f proc~writearray_hdf5_int32_r7_serial->h5dwrite_f proc~writearray_hdf5_int32_r7_serial->h5dclose_f proc~writearray_hdf5_int64_r1_serial->h5sclose_f proc~writearray_hdf5_int64_r1_serial->h5screate_simple_f proc~writearray_hdf5_int64_r1_serial->h5dcreate_f proc~writearray_hdf5_int64_r1_serial->h5dwrite_f proc~writearray_hdf5_int64_r1_serial->h5dclose_f proc~writearray_hdf5_int64_r6_serial->h5sclose_f proc~writearray_hdf5_int64_r6_serial->h5screate_simple_f proc~writearray_hdf5_int64_r6_serial->h5dcreate_f proc~writearray_hdf5_int64_r6_serial->h5dwrite_f proc~writearray_hdf5_int64_r6_serial->h5dclose_f proc~writearray_hdf5_int32_r4_serial->h5sclose_f proc~writearray_hdf5_int32_r4_serial->h5screate_simple_f proc~writearray_hdf5_int32_r4_serial->h5dcreate_f proc~writearray_hdf5_int32_r4_serial->h5dwrite_f proc~writearray_hdf5_int32_r4_serial->h5dclose_f proc~writearray_hdf5_int64_r2_parallel->h5sclose_f proc~writearray_hdf5_int64_r2_parallel->h5screate_simple_f proc~writearray_hdf5_int64_r2_parallel->h5dcreate_f proc~writearray_hdf5_int64_r2_parallel->h5pset_chunk_f proc~writearray_hdf5_int64_r2_parallel->h5pcreate_f proc~writearray_hdf5_int64_r2_parallel->h5pclose_f proc~writearray_hdf5_int64_r2_parallel->h5dwrite_f proc~writearray_hdf5_int64_r2_parallel->h5dclose_f proc~writearray_hdf5_int64_r2_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_int32_r5_serial->h5sclose_f proc~writearray_hdf5_int32_r5_serial->h5screate_simple_f proc~writearray_hdf5_int32_r5_serial->h5dcreate_f proc~writearray_hdf5_int32_r5_serial->h5dwrite_f proc~writearray_hdf5_int32_r5_serial->h5dclose_f proc~writearray_hdf5_int32_r3_serial->h5sclose_f proc~writearray_hdf5_int32_r3_serial->h5screate_simple_f proc~writearray_hdf5_int32_r3_serial->h5dcreate_f proc~writearray_hdf5_int32_r3_serial->h5dwrite_f proc~writearray_hdf5_int32_r3_serial->h5dclose_f proc~writearray_hdf5_real_r1_parallel->h5sclose_f proc~writearray_hdf5_real_r1_parallel->h5screate_simple_f proc~writearray_hdf5_real_r1_parallel->h5dcreate_f proc~writearray_hdf5_real_r1_parallel->h5pset_chunk_f proc~writearray_hdf5_real_r1_parallel->h5pcreate_f proc~writearray_hdf5_real_r1_parallel->h5pclose_f proc~writearray_hdf5_real_r1_parallel->h5dwrite_f proc~writearray_hdf5_real_r1_parallel->h5dclose_f proc~writearray_hdf5_real_r1_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_real_r3_serial->h5sclose_f proc~writearray_hdf5_real_r3_serial->h5screate_simple_f proc~writearray_hdf5_real_r3_serial->h5dcreate_f proc~writearray_hdf5_real_r3_serial->h5dwrite_f proc~writearray_hdf5_real_r3_serial->h5dclose_f proc~writearray_hdf5_int32_r1_parallel->h5sclose_f proc~writearray_hdf5_int32_r1_parallel->h5screate_simple_f proc~writearray_hdf5_int32_r1_parallel->h5dcreate_f proc~writearray_hdf5_int32_r1_parallel->h5pset_chunk_f proc~writearray_hdf5_int32_r1_parallel->h5pcreate_f proc~writearray_hdf5_int32_r1_parallel->h5pclose_f proc~writearray_hdf5_int32_r1_parallel->h5dwrite_f proc~writearray_hdf5_int32_r1_parallel->h5dclose_f proc~writearray_hdf5_int32_r1_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_real_r2_serial->h5sclose_f proc~writearray_hdf5_real_r2_serial->h5screate_simple_f proc~writearray_hdf5_real_r2_serial->h5dcreate_f proc~writearray_hdf5_real_r2_serial->h5dwrite_f proc~writearray_hdf5_real_r2_serial->h5dclose_f proc~writearray_hdf5_int64_r4_parallel->h5sclose_f proc~writearray_hdf5_int64_r4_parallel->h5screate_simple_f proc~writearray_hdf5_int64_r4_parallel->h5dcreate_f proc~writearray_hdf5_int64_r4_parallel->h5pset_chunk_f proc~writearray_hdf5_int64_r4_parallel->h5pcreate_f proc~writearray_hdf5_int64_r4_parallel->h5pclose_f proc~writearray_hdf5_int64_r4_parallel->h5dwrite_f proc~writearray_hdf5_int64_r4_parallel->h5dclose_f proc~writearray_hdf5_int64_r4_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_real_r6_parallel->h5sclose_f proc~writearray_hdf5_real_r6_parallel->h5screate_simple_f proc~writearray_hdf5_real_r6_parallel->h5dcreate_f proc~writearray_hdf5_real_r6_parallel->h5pset_chunk_f proc~writearray_hdf5_real_r6_parallel->h5pcreate_f proc~writearray_hdf5_real_r6_parallel->h5pclose_f proc~writearray_hdf5_real_r6_parallel->h5dwrite_f proc~writearray_hdf5_real_r6_parallel->h5dclose_f proc~writearray_hdf5_real_r6_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_real_r7_serial->h5sclose_f proc~writearray_hdf5_real_r7_serial->h5screate_simple_f proc~writearray_hdf5_real_r7_serial->h5dcreate_f proc~writearray_hdf5_real_r7_serial->h5dwrite_f proc~writearray_hdf5_real_r7_serial->h5dclose_f proc~writearray_hdf5_real_r3_parallel->h5sclose_f proc~writearray_hdf5_real_r3_parallel->h5screate_simple_f proc~writearray_hdf5_real_r3_parallel->h5dcreate_f proc~writearray_hdf5_real_r3_parallel->h5pset_chunk_f proc~writearray_hdf5_real_r3_parallel->h5pcreate_f proc~writearray_hdf5_real_r3_parallel->h5pclose_f proc~writearray_hdf5_real_r3_parallel->h5dwrite_f proc~writearray_hdf5_real_r3_parallel->h5dclose_f proc~writearray_hdf5_real_r3_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_int64_r5_parallel->h5sclose_f proc~writearray_hdf5_int64_r5_parallel->h5screate_simple_f proc~writearray_hdf5_int64_r5_parallel->h5dcreate_f proc~writearray_hdf5_int64_r5_parallel->h5pset_chunk_f proc~writearray_hdf5_int64_r5_parallel->h5pcreate_f proc~writearray_hdf5_int64_r5_parallel->h5pclose_f proc~writearray_hdf5_int64_r5_parallel->h5dwrite_f proc~writearray_hdf5_int64_r5_parallel->h5dclose_f proc~writearray_hdf5_int64_r5_parallel->h5sselect_hyperslab_f proc~writearray_hdf5_int32_r1_serial->h5sclose_f proc~writearray_hdf5_int32_r1_serial->h5screate_simple_f proc~writearray_hdf5_int32_r1_serial->h5dcreate_f proc~writearray_hdf5_int32_r1_serial->h5dwrite_f proc~writearray_hdf5_int32_r1_serial->h5dclose_f proc~writearray_hdf5_int32_r5_parallel->h5sclose_f proc~writearray_hdf5_int32_r5_parallel->h5screate_simple_f proc~writearray_hdf5_int32_r5_parallel->h5dcreate_f proc~writearray_hdf5_int32_r5_parallel->h5pset_chunk_f proc~writearray_hdf5_int32_r5_parallel->h5pcreate_f proc~writearray_hdf5_int32_r5_parallel->h5pclose_f proc~writearray_hdf5_int32_r5_parallel->h5dwrite_f proc~writearray_hdf5_int32_r5_parallel->h5dclose_f proc~writearray_hdf5_int32_r5_parallel->h5sselect_hyperslab_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures WriteArray_HDF5_real_r1_serial WriteArray_HDF5_real_r2_serial WriteArray_HDF5_real_r3_serial WriteArray_HDF5_real_r4_serial WriteArray_HDF5_real_r5_serial WriteArray_HDF5_real_r6_serial WriteArray_HDF5_real_r7_serial WriteArray_HDF5_int32_r1_serial WriteArray_HDF5_int32_r2_serial WriteArray_HDF5_int32_r3_serial WriteArray_HDF5_int32_r4_serial WriteArray_HDF5_int32_r5_serial WriteArray_HDF5_int32_r6_serial WriteArray_HDF5_int32_r7_serial WriteArray_HDF5_int64_r1_serial WriteArray_HDF5_int64_r2_serial WriteArray_HDF5_int64_r3_serial WriteArray_HDF5_int64_r4_serial WriteArray_HDF5_int64_r5_serial WriteArray_HDF5_int64_r6_serial WriteArray_HDF5_int64_r7_serial WriteArray_HDF5_real_r1_parallel WriteArray_HDF5_real_r2_parallel WriteArray_HDF5_real_r3_parallel WriteArray_HDF5_real_r4_parallel WriteArray_HDF5_real_r5_parallel WriteArray_HDF5_real_r6_parallel WriteArray_HDF5_real_r7_parallel WriteArray_HDF5_int32_r1_parallel WriteArray_HDF5_int32_r2_parallel WriteArray_HDF5_int32_r3_parallel WriteArray_HDF5_int32_r4_parallel WriteArray_HDF5_int32_r5_parallel WriteArray_HDF5_int32_r6_parallel WriteArray_HDF5_int32_r7_parallel WriteArray_HDF5_int64_r1_parallel WriteArray_HDF5_int64_r2_parallel WriteArray_HDF5_int64_r3_parallel WriteArray_HDF5_int64_r4_parallel WriteArray_HDF5_int64_r5_parallel WriteArray_HDF5_int64_r6_parallel WriteArray_HDF5_int64_r7_parallel Module Procedures private subroutine WriteArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r1), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r2), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r3), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r4), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r5), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r6), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r7), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r1), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r2), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r3), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r4), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r5), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r6), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r7), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r1_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) private subroutine WriteArray_HDF5_real_r2_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) private subroutine WriteArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) private subroutine WriteArray_HDF5_real_r5_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) private subroutine WriteArray_HDF5_real_r6_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) private subroutine WriteArray_HDF5_real_r7_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) integer(kind=HID_T), intent(in) :: globalDims (1:7) private subroutine WriteArray_HDF5_int32_r1_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r1), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) private subroutine WriteArray_HDF5_int32_r2_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r2), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) private subroutine WriteArray_HDF5_int32_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r3), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_int32_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r4), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) private subroutine WriteArray_HDF5_int32_r5_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r5), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) private subroutine WriteArray_HDF5_int32_r6_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r6), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) private subroutine WriteArray_HDF5_int32_r7_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r7), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) integer(kind=HID_T), intent(in) :: globalDims (1:7) private subroutine WriteArray_HDF5_int64_r1_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r1), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) private subroutine WriteArray_HDF5_int64_r2_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r2), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) private subroutine WriteArray_HDF5_int64_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r3), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_int64_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r4), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) private subroutine WriteArray_HDF5_int64_r5_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r5), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) private subroutine WriteArray_HDF5_int64_r6_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r6), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) private subroutine WriteArray_HDF5_int64_r7_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r7), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) integer(kind=HID_T), intent(in) :: globalDims (1:7)","tags":"","loc":"interface/writearray_hdf5.html"},{"title":"WriteAttribute_HDF5 – SELF","text":"public interface WriteAttribute_HDF5 Calls interface~~writeattribute_hdf5~~CallsGraph interface~writeattribute_hdf5 WriteAttribute_HDF5 proc~writeattribute_hdf5_character WriteAttribute_HDF5_character interface~writeattribute_hdf5->proc~writeattribute_hdf5_character proc~writeattribute_hdf5_real WriteAttribute_HDF5_real interface~writeattribute_hdf5->proc~writeattribute_hdf5_real proc~writeattribute_hdf5_int32 WriteAttribute_HDF5_int32 interface~writeattribute_hdf5->proc~writeattribute_hdf5_int32 h5sclose_f h5sclose_f proc~writeattribute_hdf5_character->h5sclose_f h5awrite_f h5awrite_f proc~writeattribute_hdf5_character->h5awrite_f h5acreate_f h5acreate_f proc~writeattribute_hdf5_character->h5acreate_f h5screate_f h5screate_f proc~writeattribute_hdf5_character->h5screate_f h5aclose_f h5aclose_f proc~writeattribute_hdf5_character->h5aclose_f proc~writeattribute_hdf5_real->h5sclose_f proc~writeattribute_hdf5_real->h5awrite_f proc~writeattribute_hdf5_real->h5acreate_f proc~writeattribute_hdf5_real->h5screate_f proc~writeattribute_hdf5_real->h5aclose_f proc~writeattribute_hdf5_int32->h5sclose_f proc~writeattribute_hdf5_int32->h5awrite_f proc~writeattribute_hdf5_int32->h5acreate_f proc~writeattribute_hdf5_int32->h5screate_f proc~writeattribute_hdf5_int32->h5aclose_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures WriteAttribute_HDF5_int32 WriteAttribute_HDF5_real WriteAttribute_HDF5_character Module Procedures private subroutine WriteAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(in) :: attribute private subroutine WriteAttribute_HDF5_real (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(in) :: attribute private subroutine WriteAttribute_HDF5_character (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(in) :: attribute","tags":"","loc":"interface/writeattribute_hdf5.html"},{"title":"CalculateContravariantBasis_SEMHex – SELF","text":"public subroutine CalculateContravariantBasis_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code CalculateContravariantBasis_SEMHex Source Code SUBROUTINE CalculateContravariantBasis_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom ! Local INTEGER :: iEl , i , j , k REAL ( prec ) :: fac REAL ( prec ) :: mag ! Now calculate the contravariant basis vectors ! In this convention, dsdx(j,i) is contravariant vector i, component j ! To project onto contravariant vector i, dot vector along the first dimension DO iEl = 1 , myGeom % nElem DO k = 0 , myGeom % dxds % N DO j = 0 , myGeom % dxds % N DO i = 0 , myGeom % dxds % N ! Ja1 myGeom % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) ! Ja2 myGeom % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) ! Ja3 myGeom % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) END DO END DO END DO END DO ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . FALSE .) ! Now, calculate nHat (outward pointing normal) DO iEl = 1 , myGeom % nElem DO k = 1 , 6 DO j = 0 , myGeom % J % N DO i = 0 , myGeom % J % N IF ( k == selfSide3D_Top . OR . k == selfSide3D_East . OR . k == selfSide3D_North ) THEN fac = SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , j , 1 , k , iEl )) ELSE fac = - SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , j , 1 , k , iEl )) END IF IF ( k == 1 ) THEN ! Bottom mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 3 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 3 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 2 ) THEN ! South mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 2 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 2 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 3 ) THEN ! East mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 1 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 4 ) THEN ! North mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 2 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 2 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 5 ) THEN ! West mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 1 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 , i , j , 1 , k , iEl ) / mag ELSEIF ( k == 6 ) THEN ! Top mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 3 , i , j , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 3 , 3 , i , j , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , j , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 3 , i , j , 1 , k , iEl ) / mag ENDIF ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , 1 , k , iEl ) = & myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , 1 , k , iEl ) * fac END DO END DO END DO END DO END SUBROUTINE CalculateContravariantBasis_SEMHex","tags":"","loc":"proc/calculatecontravariantbasis_semhex.html"},{"title":"CalculateContravariantBasis_SEMQuad – SELF","text":"public subroutine CalculateContravariantBasis_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code CalculateContravariantBasis_SEMQuad Source Code SUBROUTINE CalculateContravariantBasis_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom ! Local INTEGER :: iEl , i , j , k REAL ( prec ) :: fac REAL ( prec ) :: mag ! Now calculate the contravariant basis vectors ! In this convention, dsdx(j,i) is contravariant vector i, component j ! To project onto contravariant vector i, dot vector along the first dimension DO iEl = 1 , myGeom % nElem DO j = 0 , myGeom % dxds % N DO i = 0 , myGeom % dxds % N myGeom % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iEl ) = myGeom % dxds % interior % hostData ( 2 , 2 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iEl ) = - myGeom % dxds % interior % hostData ( 1 , 2 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iEl ) = - myGeom % dxds % interior % hostData ( 2 , 1 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iEl ) = myGeom % dxds % interior % hostData ( 1 , 1 , i , j , 1 , iEl ) END DO END DO END DO ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . FALSE .) ! Now, modify the sign of dsdx so that ! myGeom % dsdx % boundary is equal to the outward pointing normal vector DO iEl = 1 , myGeom % nElem DO k = 1 , 4 DO i = 0 , myGeom % J % N IF ( k == selfSide2D_East . OR . k == selfSide2D_North ) THEN fac = SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , 1 , k , iEl )) ELSE fac = - SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , 1 , k , iEl )) END IF IF ( k == 1 ) THEN ! South mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 2 , i , 1 , k , iEl ) / mag ELSEIF ( k == 2 ) THEN ! East mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 , i , 1 , k , iEl ) / mag ELSEIF ( k == 3 ) THEN ! North mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 2 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 2 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 2 , i , 1 , k , iEl ) / mag ELSEIF ( k == 4 ) THEN ! West mag = SQRT ( myGeom % dsdx % boundary % hostData ( 1 , 1 , i , 1 , k , iEl ) ** 2 + & myGeom % dsdx % boundary % hostData ( 2 , 1 , i , 1 , k , iEl ) ** 2 ) myGeom % nScale % boundary % hostData ( i , 1 , k , iEl ) = mag myGeom % nHat % boundary % hostData ( 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 , i , 1 , k , iEl ) / mag ENDIF ! Set the directionality for dsdx on the boundaries ! This is primarily used for DG gradient calculations, ! which do not use nHat for the boundary terms. myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 : 2 , i , 1 , k , iEl ) = & myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 : 2 , i , 1 , k , iEl ) * fac END DO END DO END DO END SUBROUTINE CalculateContravariantBasis_SEMQuad","tags":"","loc":"proc/calculatecontravariantbasis_semquad.html"},{"title":"CalculateMetricTerms_Geometry1D – SELF","text":"public subroutine CalculateMetricTerms_Geometry1D(myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Contents Source Code CalculateMetricTerms_Geometry1D Source Code SUBROUTINE CalculateMetricTerms_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % Derivative ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % UpdateDevice () END SUBROUTINE CalculateMetricTerms_Geometry1D","tags":"","loc":"proc/calculatemetricterms_geometry1d.html"},{"title":"CalculateMetricTerms_SEMHex – SELF","text":"public subroutine CalculateMetricTerms_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Calls proc~~calculatemetricterms_semhex~~CallsGraph proc~calculatemetricterms_semhex CalculateMetricTerms_SEMHex gpuavailable gpuavailable proc~calculatemetricterms_semhex->gpuavailable Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code CalculateMetricTerms_SEMHex Source Code SUBROUTINE CalculateMetricTerms_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom !IF (GPUAvailable()) THEN !  CALL myGeom % x % Gradient(myGeom % dxds,gpuAccel=.TRUE.) !  CALL myGeom % dxds % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % dxds % Determinant(myGeom % J,gpuAccel=.TRUE.) !  CALL myGeom % J % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % UpdateHost() !ELSE CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . FALSE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . FALSE .) !END IF CALL myGeom % CalculateContravariantBasis () IF ( GPUAvailable ()) THEN CALL myGeom % UpdateDevice () ENDIF END SUBROUTINE CalculateMetricTerms_SEMHex","tags":"","loc":"proc/calculatemetricterms_semhex.html"},{"title":"CalculateMetricTerms_SEMQuad – SELF","text":"public subroutine CalculateMetricTerms_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Calls proc~~calculatemetricterms_semquad~~CallsGraph proc~calculatemetricterms_semquad CalculateMetricTerms_SEMQuad gpuavailable gpuavailable proc~calculatemetricterms_semquad->gpuavailable Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code CalculateMetricTerms_SEMQuad Source Code SUBROUTINE CalculateMetricTerms_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom !    IF (GPUAvailable()) THEN !      CALL myGeom % x % Gradient(myGeom % dxds,gpuAccel=.TRUE.) !      CALL myGeom % dxds % BoundaryInterp(gpuAccel=.TRUE.) !      CALL myGeom % dxds % Determinant(myGeom % J,gpuAccel=.TRUE.) !      CALL myGeom % J % BoundaryInterp(gpuAccel=.TRUE.) !      CALL myGeom % UpdateHost() !    ELSE CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . FALSE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . FALSE .) !    END IF CALL myGeom % CalculateContravariantBasis () IF ( GPUAvailable ()) THEN CALL myGeom % dsdx % UpdateDevice () CALL myGeom % nHat % UpdateDevice () CALL myGeom % nScale % UpdateDevice () ENDIF END SUBROUTINE CalculateMetricTerms_SEMQuad","tags":"","loc":"proc/calculatemetricterms_semquad.html"},{"title":"Free_Geometry1D – SELF","text":"public subroutine Free_Geometry1D(myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Contents Source Code Free_Geometry1D Source Code SUBROUTINE Free_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () END SUBROUTINE Free_Geometry1D","tags":"","loc":"proc/free_geometry1d.html"},{"title":"Free_SEMHex – SELF","text":"public subroutine Free_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code Free_SEMHex Source Code SUBROUTINE Free_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () CALL myGeom % dsdx % Free () CALL myGeom % nHat % Free () CALL myGeom % nScale % Free () CALL myGeom % J % Free () END SUBROUTINE Free_SEMHex","tags":"","loc":"proc/free_semhex.html"},{"title":"Free_SEMQuad – SELF","text":"public subroutine Free_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code Free_SEMQuad Source Code SUBROUTINE Free_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () CALL myGeom % dsdx % Free () CALL myGeom % nHat % Free () CALL myGeom % nScale % Free () CALL myGeom % J % Free () END SUBROUTINE Free_SEMQuad","tags":"","loc":"proc/free_semquad.html"},{"title":"GenerateFromMesh_Geometry1D – SELF","text":"public subroutine GenerateFromMesh_Geometry1D(myGeom, mesh, cqType, tqType, cqDegree, tqDegree, meshQuadrature) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom type(Mesh1D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in), optional :: meshQuadrature Contents Source Code GenerateFromMesh_Geometry1D Source Code SUBROUTINE GenerateFromMesh_Geometry1D ( myGeom , mesh , cqType , tqType , cqDegree , tqDegree , meshQuadrature ) ! Generates the geometry for a 1-D mesh ( set of line segments ) ! Assumes that mesh is using Gauss-Lobatto quadrature and the degree is given by mesh % nGeo IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( out ) :: myGeom TYPE ( Mesh1D ), INTENT ( in ) :: mesh INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ), OPTIONAL :: meshQuadrature ! Local INTEGER :: iel , i , nid TYPE ( Scalar1D ) :: xMesh INTEGER :: quadrature IF ( PRESENT ( meshQuadrature )) THEN quadrature = meshQuadrature ELSE quadrature = GAUSS_LOBATTO END IF CALL myGeom % Init ( cqType , tqType , cqDegree , tqDegree , mesh % nElem ) ! Create a scalar1D class to map from nGeo,Gauss-Lobatto grid to ! cqDegree, cqType grid CALL xMesh % Init ( mesh % nGeo , quadrature , & cqDegree , cqType , & 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 DO iel = 1 , mesh % nElem DO i = 0 , mesh % nGeo xMesh % interior % hostData ( i , 1 , iel ) = mesh % hopr_nodeCoords % hostData ( nid ) nid = nid + 1 END DO END DO ! Interpolate from the mesh hopr_nodeCoords to the geometry (Possibly not gauss_lobatto quadrature) CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () CALL myGeom % UpdateDevice () CALL xMesh % Free () END SUBROUTINE GenerateFromMesh_Geometry1D","tags":"","loc":"proc/generatefrommesh_geometry1d.html"},{"title":"GenerateFromMesh_SEMHex – SELF","text":"public subroutine GenerateFromMesh_SEMHex(myGeom, mesh, cqType, tqType, cqDegree, tqDegree, meshQuadrature) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom type(Mesh3D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in), optional :: meshQuadrature Contents Source Code GenerateFromMesh_SEMHex Source Code SUBROUTINE GenerateFromMesh_SEMHex ( myGeom , mesh , cqType , tqType , cqDegree , tqDegree , meshQuadrature ) ! Assumes that !  * mesh is using Gauss-Lobatto quadrature !  * the degree is given by mesh % nGeo !  * mesh only has quadrilateral elements ! IMPLICIT NONE CLASS ( SEMHex ), INTENT ( out ) :: myGeom TYPE ( Mesh3D ), INTENT ( in ) :: mesh INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ), OPTIONAL :: meshQuadrature ! Local INTEGER :: iel INTEGER :: i , j , k , nid TYPE ( Vector3D ) :: xMesh INTEGER :: quadrature IF ( PRESENT ( meshQuadrature )) THEN quadrature = meshQuadrature ELSE quadrature = GAUSS_LOBATTO END IF CALL myGeom % Init ( cqType , tqType , cqDegree , tqDegree , mesh % nElem ) ! Create a scalar1D class to map from nGeo,Gauss-Lobatto grid to ! cqDegree, cqType grid CALL xMesh % Init ( mesh % nGeo , quadrature , & cqDegree , cqType , & 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 DO iel = 1 , mesh % nElem DO k = 0 , mesh % nGeo DO j = 0 , mesh % nGeo DO i = 0 , mesh % nGeo xMesh % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) = mesh % hopr_nodeCoords % hostData ( 1 : 3 , nid ) nid = nid + 1 END DO END DO END DO END DO ! Interpolate from the mesh hopr_nodeCoords to the geometry (Possibly not gauss_lobatto quadrature) !IF (GPUAvailable()) THEN !  CALL xMesh % UpdateDevice() !  CALL xMesh % GridInterp(myGeom % x,.TRUE.) !  CALL myGeom % x % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % CalculateMetricTerms() !  CALL myGeom % UpdateHost() !ELSE CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () !END IF CALL myGeom % UpdateDevice () CALL xMesh % Free () END SUBROUTINE GenerateFromMesh_SEMHex","tags":"","loc":"proc/generatefrommesh_semhex.html"},{"title":"GenerateFromMesh_SEMQuad – SELF","text":"public subroutine GenerateFromMesh_SEMQuad(myGeom, mesh, cqType, tqType, cqDegree, tqDegree, meshQuadrature) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom type(Mesh2D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in), optional :: meshQuadrature Contents Source Code GenerateFromMesh_SEMQuad Source Code SUBROUTINE GenerateFromMesh_SEMQuad ( myGeom , mesh , cqType , tqType , cqDegree , tqDegree , meshQuadrature ) ! Assumes that !  * mesh is using Gauss-Lobatto quadrature !  * the degree is given by mesh % nGeo !  * mesh only has quadrilateral elements ! IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( out ) :: myGeom TYPE ( Mesh2D ), INTENT ( in ) :: mesh INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ), OPTIONAL :: meshQuadrature ! Local INTEGER :: iel INTEGER :: i , j , nid TYPE ( Vector2D ) :: xMesh INTEGER :: quadrature IF ( PRESENT ( meshQuadrature )) THEN quadrature = meshQuadrature ELSE quadrature = GAUSS_LOBATTO END IF CALL myGeom % Init ( cqType , tqType , cqDegree , tqDegree , mesh % nElem ) ! Create a scalar1D class to map from nGeo,Gauss-Lobatto grid to ! cqDegree, cqType grid CALL xMesh % Init ( mesh % nGeo , quadrature , & cqDegree , cqType , & 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 DO iel = 1 , mesh % nElem DO j = 0 , mesh % nGeo DO i = 0 , mesh % nGeo xMesh % interior % hostData ( 1 : 2 , i , j , 1 , iel ) = mesh % hopr_nodeCoords % hostData ( 1 : 2 , nid ) nid = nid + 1 END DO END DO END DO !IF (GPUAvailable()) THEN !  CALL xMesh % UpdateDevice() !  CALL xMesh % GridInterp(myGeom % x,.TRUE.) !  CALL myGeom % x % BoundaryInterp(gpuAccel=.TRUE.) !  CALL myGeom % CalculateMetricTerms() !  CALL myGeom % UpdateHost() !ELSE CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () !END IF CALL myGeom % UpdateDevice () CALL xMesh % Free () END SUBROUTINE GenerateFromMesh_SEMQuad","tags":"","loc":"proc/generatefrommesh_semquad.html"},{"title":"Init_Geometry1D – SELF","text":"public subroutine Init_Geometry1D(myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem Contents Source Code Init_Geometry1D Source Code SUBROUTINE Init_Geometry1D ( myGeom , cqType , tqType , cqDegree , tqDegree , nElem ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( out ) :: myGeom INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem myGeom % cqType = cqType myGeom % tqType = tqType myGeom % nElem = nElem CALL myGeom % x % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_Geometry1D","tags":"","loc":"proc/init_geometry1d.html"},{"title":"Init_SEMHex – SELF","text":"public subroutine Init_SEMHex(myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem Contents Source Code Init_SEMHex Source Code SUBROUTINE Init_SEMHex ( myGeom , cqType , tqType , cqDegree , tqDegree , nElem ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( out ) :: myGeom INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem myGeom % cqType = cqType myGeom % tqType = tqType myGeom % nElem = nElem CALL myGeom % x % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dsdx % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % nHat % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % nScale % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % J % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_SEMHex","tags":"","loc":"proc/init_semhex.html"},{"title":"Init_SEMQuad – SELF","text":"public subroutine Init_SEMQuad(myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem Contents Source Code Init_SEMQuad Source Code SUBROUTINE Init_SEMQuad ( myGeom , cqType , tqType , cqDegree , tqDegree , nElem ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( out ) :: myGeom INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem myGeom % cqType = cqType myGeom % tqType = tqType myGeom % nElem = nElem CALL myGeom % x % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dsdx % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % nHat % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % nScale % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % J % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_SEMQuad","tags":"","loc":"proc/init_semquad.html"},{"title":"UpdateDevice_Geometry1D – SELF","text":"public subroutine UpdateDevice_Geometry1D(myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Contents Source Code UpdateDevice_Geometry1D Source Code SUBROUTINE UpdateDevice_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () END SUBROUTINE UpdateDevice_Geometry1D","tags":"","loc":"proc/updatedevice_geometry1d.html"},{"title":"UpdateDevice_SEMHex – SELF","text":"public subroutine UpdateDevice_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code UpdateDevice_SEMHex Source Code SUBROUTINE UpdateDevice_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () CALL myGeom % dsdx % UpdateDevice () CALL myGeom % nHat % UpdateDevice () CALL myGeom % nScale % UpdateDevice () CALL myGeom % J % UpdateDevice () END SUBROUTINE UpdateDevice_SEMHex","tags":"","loc":"proc/updatedevice_semhex.html"},{"title":"UpdateDevice_SEMQuad – SELF","text":"public subroutine UpdateDevice_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code UpdateDevice_SEMQuad Source Code SUBROUTINE UpdateDevice_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () CALL myGeom % dsdx % UpdateDevice () CALL myGeom % nHat % UpdateDevice () CALL myGeom % nScale % UpdateDevice () CALL myGeom % J % UpdateDevice () END SUBROUTINE UpdateDevice_SEMQuad","tags":"","loc":"proc/updatedevice_semquad.html"},{"title":"UpdateHost_Geometry1D – SELF","text":"public subroutine UpdateHost_Geometry1D(myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Contents Source Code UpdateHost_Geometry1D Source Code SUBROUTINE UpdateHost_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () END SUBROUTINE UpdateHost_Geometry1D","tags":"","loc":"proc/updatehost_geometry1d.html"},{"title":"UpdateHost_SEMHex – SELF","text":"public subroutine UpdateHost_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code UpdateHost_SEMHex Source Code SUBROUTINE UpdateHost_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () CALL myGeom % dsdx % UpdateHost () CALL myGeom % nHat % UpdateHost () CALL myGeom % nScale % UpdateHost () CALL myGeom % J % UpdateHost () END SUBROUTINE UpdateHost_SEMHex","tags":"","loc":"proc/updatehost_semhex.html"},{"title":"UpdateHost_SEMQuad – SELF","text":"public subroutine UpdateHost_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code UpdateHost_SEMQuad Source Code SUBROUTINE UpdateHost_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () CALL myGeom % dsdx % UpdateHost () CALL myGeom % nHat % UpdateHost () CALL myGeom % nScale % UpdateHost () CALL myGeom % J % UpdateHost () END SUBROUTINE UpdateHost_SEMQuad","tags":"","loc":"proc/updatehost_semquad.html"},{"title":"AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper – SELF","text":"interface public subroutine AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper(dsdx, J, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dsdx type(c_ptr) :: J integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/adjustboundarycontravariantbasis_semhex_gpu_wrapper.html"},{"title":"AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper – SELF","text":"interface public subroutine AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper(dsdx, J, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dsdx type(c_ptr) :: J integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/adjustboundarycontravariantbasis_semquad_gpu_wrapper.html"},{"title":"CalculateContravariantBasis_SEMHex_gpu_wrapper – SELF","text":"interface public subroutine CalculateContravariantBasis_SEMHex_gpu_wrapper(dxds, dsdx, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dxds type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/calculatecontravariantbasis_semhex_gpu_wrapper.html"},{"title":"CalculateContravariantBasis_SEMQuad_gpu_wrapper – SELF","text":"interface public subroutine CalculateContravariantBasis_SEMQuad_gpu_wrapper(dxds, dsdx, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dxds type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/calculatecontravariantbasis_semquad_gpu_wrapper.html"},{"title":"ApplyFlip_MappedScalar2D – SELF","text":"public subroutine ApplyFlip_MappedScalar2D(scalar, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: gpuAccel Calls proc~~applyflip_mappedscalar2d~~CallsGraph proc~applyflip_mappedscalar2d ApplyFlip_MappedScalar2D interface~applyflip_mappedscalar2d_gpu_wrapper ApplyFlip_MappedScalar2D_gpu_wrapper proc~applyflip_mappedscalar2d->interface~applyflip_mappedscalar2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ApplyFlip_MappedScalar2D Source Code SUBROUTINE ApplyFlip_MappedScalar2D ( scalar , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId REAL ( prec ) :: extBuff ( 0 : scalar % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedScalar2D_gpu_wrapper ( scalar % extBoundary % deviceData , & mesh % self_sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & scalar % N , & scalar % nVar , & scalar % nElem ) ELSE DO e1 = 1 , scalar % nElem DO s1 = 1 , 4 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) ! Need to update extBoundary with flip applied IF ( flip == 1 ) THEN DO ivar = 1 , scalar % nvar DO i = 0 , scalar % N i2 = scalar % N - i extBuff ( i ) = scalar % extBoundary % hostData ( i2 , ivar , s1 , e1 ) END DO DO i = 0 , scalar % N scalar % extBoundary % hostData ( i , ivar , s1 , e1 ) = extBuff ( i ) END DO END DO END IF END IF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedScalar2D","tags":"","loc":"proc/applyflip_mappedscalar2d.html"},{"title":"ApplyFlip_MappedScalar3D – SELF","text":"public subroutine ApplyFlip_MappedScalar3D(scalar, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: gpuAccel Calls proc~~applyflip_mappedscalar3d~~CallsGraph proc~applyflip_mappedscalar3d ApplyFlip_MappedScalar3D interface~applyflip_mappedscalar3d_gpu_wrapper ApplyFlip_MappedScalar3D_gpu_wrapper proc~applyflip_mappedscalar3d->interface~applyflip_mappedscalar3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ApplyFlip_MappedScalar3D Source Code SUBROUTINE ApplyFlip_MappedScalar3D ( scalar , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 , j , j2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId REAL ( prec ) :: extBuff ( 0 : scalar % N , 0 : scalar % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedScalar3D_gpu_wrapper ( scalar % extBoundary % deviceData , & mesh % self_sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & scalar % N , & scalar % nVar , & scalar % nElem ) ELSE DO e1 = 1 , scalar % nElem DO s1 = 1 , 6 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) ! Need to update extBoundary with flip applied IF ( flip == 2 ) THEN DO ivar = 1 , scalar % nvar DO j = 0 , scalar % N DO i = 0 , scalar % N i2 = scalar % N - j j2 = i extBuff ( i , j ) = scalar % extBoundary % hostData ( i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % extBoundary % hostData ( i , j , ivar , s1 , e1 ) = extBuff ( i , j ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , scalar % nvar DO j = 0 , scalar % N DO i = 0 , scalar % N i2 = scalar % N - i j2 = scalar % N - j extBuff ( i , j ) = scalar % extBoundary % hostData ( i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % extBoundary % hostData ( i , j , ivar , s1 , e1 ) = extBuff ( i , j ) END DO END DO END DO ELSEIF ( flip == 4 ) THEN DO ivar = 1 , scalar % nvar DO j = 0 , scalar % N DO i = 0 , scalar % N i2 = j j2 = scalar % N - i extBuff ( i , j ) = scalar % extBoundary % hostData ( i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % extBoundary % hostData ( i , j , ivar , s1 , e1 ) = extBuff ( i , j ) END DO END DO END DO END IF END IF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedScalar3D","tags":"","loc":"proc/applyflip_mappedscalar3d.html"},{"title":"ApplyFlip_MappedTensor2D – SELF","text":"public subroutine ApplyFlip_MappedTensor2D(tensor, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: gpuAccel Calls proc~~applyflip_mappedtensor2d~~CallsGraph proc~applyflip_mappedtensor2d ApplyFlip_MappedTensor2D interface~applyflip_mappedtensor2d_gpu_wrapper ApplyFlip_MappedTensor2D_gpu_wrapper proc~applyflip_mappedtensor2d->interface~applyflip_mappedtensor2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ApplyFlip_MappedTensor2D Source Code SUBROUTINE ApplyFlip_MappedTensor2D ( tensor , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedTensor2D ), INTENT ( inout ) :: tensor TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId REAL ( prec ) :: extBuff ( 1 : 2 , 1 : 2 , 0 : tensor % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedTensor2D_gpu_wrapper ( tensor % extBoundary % deviceData , & mesh % self_sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & tensor % N , & tensor % nVar , & tensor % nElem ) ELSE DO e1 = 1 , tensor % nElem DO s1 = 1 , 4 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) ! Need to update extBoundary with flip applied IF ( flip == 1 ) THEN DO ivar = 1 , tensor % nvar DO i = 0 , tensor % N i2 = tensor % N - i extBuff ( 1 : 2 , 1 : 2 , i ) = tensor % extBoundary % hostData ( 1 : 2 , 1 : 2 , i2 , ivar , s1 , e1 ) END DO DO i = 0 , tensor % N tensor % extBoundary % hostData ( 1 : 2 , 1 : 2 , i , ivar , s1 , e1 ) = extBuff ( 1 : 2 , 1 : 2 , i ) END DO END DO END IF END IF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedTensor2D","tags":"","loc":"proc/applyflip_mappedtensor2d.html"},{"title":"ApplyFlip_MappedTensor3D – SELF","text":"public subroutine ApplyFlip_MappedTensor3D(tensor, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: gpuAccel Calls proc~~applyflip_mappedtensor3d~~CallsGraph proc~applyflip_mappedtensor3d ApplyFlip_MappedTensor3D interface~applyflip_mappedtensor3d_gpu_wrapper ApplyFlip_MappedTensor3D_gpu_wrapper proc~applyflip_mappedtensor3d->interface~applyflip_mappedtensor3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ApplyFlip_MappedTensor3D Source Code SUBROUTINE ApplyFlip_MappedTensor3D ( tensor , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedTensor3D ), INTENT ( inout ) :: tensor TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 , j , j2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId REAL ( prec ) :: extBuff ( 1 : 3 , 1 : 3 , 0 : tensor % N , 0 : tensor % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedTensor3D_gpu_wrapper ( tensor % extBoundary % deviceData , & mesh % self_sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & tensor % N , & tensor % nVar , & tensor % nElem ) ELSE DO e1 = 1 , tensor % nElem DO s1 = 1 , 6 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) IF ( flip == 2 ) THEN DO ivar = 1 , tensor % nvar DO j = 0 , tensor % N DO i = 0 , tensor % N i2 = tensor % N - j j2 = i extBuff ( 1 : 3 , 1 : 3 , i , j ) = tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , 1 : 3 , i , j ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , tensor % nvar DO j = 0 , tensor % N DO i = 0 , tensor % N i2 = tensor % N - i j2 = tensor % N - j extBuff ( 1 : 3 , 1 : 3 , i , j ) = tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , 1 : 3 , i , j ) END DO END DO END DO ELSEIF ( flip == 4 ) THEN DO ivar = 1 , tensor % nvar DO j = 0 , tensor % N DO i = 0 , tensor % N i2 = j j2 = tensor % N - i extBuff ( 1 : 3 , 1 : 3 , i , j ) = tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , 1 : 3 , i , j ) END DO END DO END DO END IF END IF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedTensor3D","tags":"","loc":"proc/applyflip_mappedtensor3d.html"},{"title":"ApplyFlip_MappedVector2D – SELF","text":"public subroutine ApplyFlip_MappedVector2D(vector, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: gpuAccel Calls proc~~applyflip_mappedvector2d~~CallsGraph proc~applyflip_mappedvector2d ApplyFlip_MappedVector2D interface~applyflip_mappedvector2d_gpu_wrapper ApplyFlip_MappedVector2D_gpu_wrapper proc~applyflip_mappedvector2d->interface~applyflip_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ApplyFlip_MappedVector2D Source Code SUBROUTINE ApplyFlip_MappedVector2D ( vector , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId REAL ( prec ) :: extBuff ( 1 : 2 , 0 : vector % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedVector2D_gpu_wrapper ( vector % extBoundary % deviceData , & mesh % self_sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & vector % N , & vector % nVar , & vector % nElem ) ELSE DO e1 = 1 , vector % nElem DO s1 = 1 , 4 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) ! Need to update extBoundary with flip applied IF ( flip == 1 ) THEN DO ivar = 1 , vector % nvar DO i = 0 , vector % N i2 = vector % N - i extBuff ( 1 : 2 , i ) = vector % extBoundary % hostData ( 1 : 2 , i2 , ivar , s1 , e1 ) END DO DO i = 0 , vector % N vector % extBoundary % hostData ( 1 : 2 , i , ivar , s1 , e1 ) = extBuff ( 1 : 2 , i ) END DO END DO END IF END IF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedVector2D","tags":"","loc":"proc/applyflip_mappedvector2d.html"},{"title":"ApplyFlip_MappedVector3D – SELF","text":"public subroutine ApplyFlip_MappedVector3D(vector, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: gpuAccel Calls proc~~applyflip_mappedvector3d~~CallsGraph proc~applyflip_mappedvector3d ApplyFlip_MappedVector3D interface~applyflip_mappedvector3d_gpu_wrapper ApplyFlip_MappedVector3D_gpu_wrapper proc~applyflip_mappedvector3d->interface~applyflip_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ApplyFlip_MappedVector3D Source Code SUBROUTINE ApplyFlip_MappedVector3D ( vector , mpiHandler , mesh , gpuAccel ) ! Apply side flips to sides where MPI exchanges took place. IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: i , i2 , j , j2 INTEGER :: r2 , flip , ivar INTEGER :: globalSideId REAL ( prec ) :: extBuff ( 1 : 3 , 0 : vector % N , 0 : vector % N ) IF ( mpiHandler % mpiEnabled ) THEN IF ( gpuAccel ) THEN CALL ApplyFlip_MappedVector3D_gpu_wrapper ( vector % extBoundary % deviceData , & mesh % self_sideInfo % deviceData , & mpiHandler % elemToRank % deviceData , & mpiHandler % rankId , & vector % N , & vector % nVar , & vector % nElem ) ELSE DO e1 = 1 , vector % nElem DO s1 = 1 , 6 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) IF ( flip == 2 ) THEN DO ivar = 1 , vector % nvar DO j = 0 , vector % N DO i = 0 , vector % N i2 = vector % N - j j2 = i extBuff ( 1 : 3 , i , j ) = vector % extBoundary % hostData ( 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , vector % N DO i = 0 , vector % N vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , i , j ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , vector % nvar DO j = 0 , vector % N DO i = 0 , vector % N i2 = vector % N - i j2 = vector % N - j extBuff ( 1 : 3 , i , j ) = vector % extBoundary % hostData ( 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , vector % N DO i = 0 , vector % N vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , i , j ) END DO END DO END DO ELSEIF ( flip == 4 ) THEN DO ivar = 1 , vector % nvar DO j = 0 , vector % N DO i = 0 , vector % N i2 = j j2 = vector % N - i extBuff ( 1 : 3 , i , j ) = vector % extBoundary % hostData ( 1 : 3 , i2 , j2 , ivar , s1 , e1 ) END DO END DO DO j = 0 , vector % N DO i = 0 , vector % N vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , s1 , e1 ) = extBuff ( 1 : 3 , i , j ) END DO END DO END DO END IF END IF END DO END DO END IF END IF END SUBROUTINE ApplyFlip_MappedVector3D","tags":"","loc":"proc/applyflip_mappedvector3d.html"},{"title":"BassiRebaySides_MappedScalar2D – SELF","text":"public subroutine BassiRebaySides_MappedScalar2D(scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel Calls proc~~bassirebaysides_mappedscalar2d~~CallsGraph proc~bassirebaysides_mappedscalar2d BassiRebaySides_MappedScalar2D interface~bassirebaysides_mappedscalar2d_gpu_wrapper BassiRebaySides_MappedScalar2D_gpu_wrapper proc~bassirebaysides_mappedscalar2d->interface~bassirebaysides_mappedscalar2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code BassiRebaySides_MappedScalar2D Source Code SUBROUTINE BassiRebaySides_MappedScalar2D ( scalar , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedScalar2D_gpu_wrapper ( scalar % avgBoundary % deviceData , & scalar % boundary % deviceData , & scalar % extBoundary % deviceData , & scalar % N , & scalar % nvar , & scalar % nElem ) ELSE DO iel = 1 , scalar % nElem DO iside = 1 , 4 DO ivar = 1 , scalar % nVar DO i = 0 , scalar % N scalar % avgBoundary % hostData ( i , ivar , iside , iel ) = 0.5_prec * ( & scalar % boundary % hostData ( i , ivar , iside , iel ) + & scalar % extBoundary % hostData ( i , ivar , iside , iel )) END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedScalar2D","tags":"","loc":"proc/bassirebaysides_mappedscalar2d.html"},{"title":"BassiRebaySides_MappedScalar3D – SELF","text":"public subroutine BassiRebaySides_MappedScalar3D(scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel Calls proc~~bassirebaysides_mappedscalar3d~~CallsGraph proc~bassirebaysides_mappedscalar3d BassiRebaySides_MappedScalar3D interface~bassirebaysides_mappedscalar3d_gpu_wrapper BassiRebaySides_MappedScalar3D_gpu_wrapper proc~bassirebaysides_mappedscalar3d->interface~bassirebaysides_mappedscalar3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code BassiRebaySides_MappedScalar3D Source Code SUBROUTINE BassiRebaySides_MappedScalar3D ( scalar , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i , j IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedScalar3D_gpu_wrapper ( scalar % avgBoundary % deviceData , & scalar % boundary % deviceData , & scalar % extBoundary % deviceData , & scalar % N , & scalar % nvar , & scalar % nElem ) ELSE DO iel = 1 , scalar % nElem DO iside = 1 , 6 DO ivar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % avgBoundary % hostData ( i , j , ivar , iside , iel ) = 0.5_prec * ( & scalar % boundary % hostData ( i , j , ivar , iside , iel ) + & scalar % extBoundary % hostData ( i , j , ivar , iside , iel )) END DO END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedScalar3D","tags":"","loc":"proc/bassirebaysides_mappedscalar3d.html"},{"title":"BassiRebaySides_MappedTensor2D – SELF","text":"public subroutine BassiRebaySides_MappedTensor2D(tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel Calls proc~~bassirebaysides_mappedtensor2d~~CallsGraph proc~bassirebaysides_mappedtensor2d BassiRebaySides_MappedTensor2D interface~bassirebaysides_mappedtensor2d_gpu_wrapper BassiRebaySides_MappedTensor2D_gpu_wrapper proc~bassirebaysides_mappedtensor2d->interface~bassirebaysides_mappedtensor2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code BassiRebaySides_MappedTensor2D Source Code SUBROUTINE BassiRebaySides_MappedTensor2D ( tensor , gpuAccel ) IMPLICIT NONE CLASS ( MappedTensor2D ), INTENT ( inout ) :: tensor LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedTensor2D_gpu_wrapper ( tensor % extBoundary % deviceData , & tensor % boundary % deviceData , & tensor % N , & tensor % nvar , & tensor % nElem ) ELSE DO iel = 1 , tensor % nElem DO iside = 1 , 4 DO ivar = 1 , tensor % nVar DO i = 0 , tensor % N tensor % boundary % hostData ( 1 : 2 , 1 : 2 , i , ivar , iside , iel ) = 0.5_prec * ( & tensor % boundary % hostData ( 1 : 2 , 1 : 2 , i , ivar , iside , iel ) + & tensor % extBoundary % hostData ( 1 : 2 , 1 : 2 , i , ivar , iside , iel )) END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedTensor2D","tags":"","loc":"proc/bassirebaysides_mappedtensor2d.html"},{"title":"BassiRebaySides_MappedTensor3D – SELF","text":"public subroutine BassiRebaySides_MappedTensor3D(tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel Calls proc~~bassirebaysides_mappedtensor3d~~CallsGraph proc~bassirebaysides_mappedtensor3d BassiRebaySides_MappedTensor3D interface~bassirebaysides_mappedtensor3d_gpu_wrapper BassiRebaySides_MappedTensor3D_gpu_wrapper proc~bassirebaysides_mappedtensor3d->interface~bassirebaysides_mappedtensor3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code BassiRebaySides_MappedTensor3D Source Code SUBROUTINE BassiRebaySides_MappedTensor3D ( tensor , gpuAccel ) IMPLICIT NONE CLASS ( MappedTensor3D ), INTENT ( inout ) :: tensor LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i , j IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedTensor3D_gpu_wrapper ( tensor % extBoundary % deviceData , & tensor % boundary % deviceData , & tensor % N , & tensor % nvar , & tensor % nElem ) ELSE DO iel = 1 , tensor % nElem DO iside = 1 , 6 DO ivar = 1 , tensor % nVar DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , ivar , iside , iel ) = 0.5_prec * ( & tensor % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , ivar , iside , iel ) + & tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i , j , ivar , iside , iel )) END DO END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedTensor3D","tags":"","loc":"proc/bassirebaysides_mappedtensor3d.html"},{"title":"BassiRebaySides_MappedVector2D – SELF","text":"public subroutine BassiRebaySides_MappedVector2D(vector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector logical, intent(in) :: gpuAccel Calls proc~~bassirebaysides_mappedvector2d~~CallsGraph proc~bassirebaysides_mappedvector2d BassiRebaySides_MappedVector2D interface~bassirebaysides_mappedvector2d_gpu_wrapper BassiRebaySides_MappedVector2D_gpu_wrapper proc~bassirebaysides_mappedvector2d->interface~bassirebaysides_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code BassiRebaySides_MappedVector2D Source Code SUBROUTINE BassiRebaySides_MappedVector2D ( vector , gpuAccel ) IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedVector2D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & vector % N , & vector % nvar , & vector % nElem ) ELSE DO iel = 1 , vector % nElem DO iside = 1 , 4 DO ivar = 1 , vector % nVar DO i = 0 , vector % N vector % boundary % hostData ( 1 : 2 , i , ivar , iside , iel ) = 0.5_prec * ( & vector % boundary % hostData ( 1 : 2 , i , ivar , iside , iel ) + & vector % extBoundary % hostData ( 1 : 2 , i , ivar , iside , iel )) END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedVector2D","tags":"","loc":"proc/bassirebaysides_mappedvector2d.html"},{"title":"BassiRebaySides_MappedVector3D – SELF","text":"public subroutine BassiRebaySides_MappedVector3D(vector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector logical, intent(in) :: gpuAccel Calls proc~~bassirebaysides_mappedvector3d~~CallsGraph proc~bassirebaysides_mappedvector3d BassiRebaySides_MappedVector3D interface~bassirebaysides_mappedvector3d_gpu_wrapper BassiRebaySides_MappedVector3D_gpu_wrapper proc~bassirebaysides_mappedvector3d->interface~bassirebaysides_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code BassiRebaySides_MappedVector3D Source Code SUBROUTINE BassiRebaySides_MappedVector3D ( vector , gpuAccel ) IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iel INTEGER :: iside INTEGER :: ivar INTEGER :: i , j IF ( gpuAccel ) THEN CALL BassiRebaySides_MappedVector3D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & vector % N , & vector % nvar , & vector % nElem ) ELSE DO iel = 1 , vector % nElem DO iside = 1 , 6 DO ivar = 1 , vector % nVar DO j = 0 , vector % N DO i = 0 , vector % N vector % boundary % hostData ( 1 : 3 , i , j , ivar , iside , iel ) = 0.5_prec * ( & vector % boundary % hostData ( 1 : 3 , i , j , ivar , iside , iel ) + & vector % extBoundary % hostData ( 1 : 3 , i , j , ivar , iside , iel )) END DO END DO END DO END DO END DO END IF END SUBROUTINE BassiRebaySides_MappedVector3D","tags":"","loc":"proc/bassirebaysides_mappedvector3d.html"},{"title":"ContravariantProjection_MappedVector2D – SELF","text":"public subroutine ContravariantProjection_MappedVector2D(physVector, geometry, compVector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: physVector type(SEMQuad), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: compVector logical, intent(in) :: gpuAccel Calls proc~~contravariantprojection_mappedvector2d~~CallsGraph proc~contravariantprojection_mappedvector2d ContravariantProjection_MappedVector2D interface~contravariantprojectionboundary_mappedvector2d_gpu_wrapper ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper proc~contravariantprojection_mappedvector2d->interface~contravariantprojectionboundary_mappedvector2d_gpu_wrapper interface~contravariantprojection_mappedvector2d_gpu_wrapper ContravariantProjection_MappedVector2D_gpu_wrapper proc~contravariantprojection_mappedvector2d->interface~contravariantprojection_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ContravariantProjection_MappedVector2D Source Code SUBROUTINE ContravariantProjection_MappedVector2D ( physVector , geometry , compVector , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantProjection_MappedVector2D\" ! Takes a vector that has physical space coordinate directions (x,y,z) and projects the vector ! into the the contravariant basis vector directions. Keep in mind that the contravariant basis ! vectors are really the Jacobian weighted contravariant basis vectors IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: physVector TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel TYPE ( MappedVector2D ), INTENT ( inout ) :: compVector ! Local INTEGER :: i , j , ivar , iel , iside REAL ( prec ) :: nhat ( 1 : 2 ) REAL ( prec ) :: nmag IF ( gpuAccel ) THEN CALL ContravariantProjection_MappedVector2D_gpu_wrapper ( physVector % interior % deviceData , & compVector % interior % deviceData , & geometry % dsdx % interior % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) CALL ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper ( physVector % boundary % deviceData , & compVector % boundaryNormal % deviceData , & geometry % nHat % boundary % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) ELSE ! Assume that tensor(j,i) is vector i, component j ! => dot product is done along first dimension ! to project onto computational space DO iel = 1 , physVector % nElem DO ivar = 1 , physVector % nVar DO j = 0 , physVector % N DO i = 0 , physVector % N compVector % interior % hostData ( 1 , i , j , ivar , iel ) = & geometry % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iel ) * & physVector % interior % hostData ( 1 , i , j , ivar , iel ) + & geometry % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iel ) * & physVector % interior % hostData ( 2 , i , j , ivar , iel ) compVector % interior % hostData ( 2 , i , j , ivar , iel ) = & geometry % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iel ) * & physVector % interior % hostData ( 1 , i , j , ivar , iel ) + & geometry % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iel ) * & physVector % interior % hostData ( 2 , i , j , ivar , iel ) END DO END DO END DO END DO ! Boundary Terms DO iel = 1 , physVector % nElem DO iside = 1 , 4 DO ivar = 1 , physVector % nVar DO j = 0 , physVector % N nhat ( 1 : 2 ) = geometry % nHat % boundary % hostData ( 1 : 2 , j , 1 , iSide , iEl ) nmag = geometry % nScale % boundary % hostData ( j , 1 , iSide , iEl ) compVector % boundaryNormal % hostData ( j , ivar , iside , iel ) = & ( nhat ( 1 ) * physVector % boundary % hostData ( 1 , j , ivar , iside , iel ) + & nhat ( 2 ) * physVector % boundary % hostData ( 2 , j , ivar , iside , iel ) ) * nmag END DO END DO END DO END DO END IF END SUBROUTINE ContravariantProjection_MappedVector2D","tags":"","loc":"proc/contravariantprojection_mappedvector2d.html"},{"title":"ContravariantProjection_MappedVector3D – SELF","text":"public subroutine ContravariantProjection_MappedVector3D(physVector, geometry, compVector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: physVector type(SEMHex), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: compVector logical, intent(in) :: gpuAccel Calls proc~~contravariantprojection_mappedvector3d~~CallsGraph proc~contravariantprojection_mappedvector3d ContravariantProjection_MappedVector3D interface~contravariantprojection_mappedvector3d_gpu_wrapper ContravariantProjection_MappedVector3D_gpu_wrapper proc~contravariantprojection_mappedvector3d->interface~contravariantprojection_mappedvector3d_gpu_wrapper interface~contravariantprojectionboundary_mappedvector3d_gpu_wrapper ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper proc~contravariantprojection_mappedvector3d->interface~contravariantprojectionboundary_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ContravariantProjection_MappedVector3D Source Code SUBROUTINE ContravariantProjection_MappedVector3D ( physVector , geometry , compVector , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantProjection_MappedVector3D\" ! Takes a vector that has physical space coordinate directions (x,y,z) and projects the vector ! into the the contravariant basis vector directions. Keep in mind that the contravariant basis ! vectors are really the Jacobian weighted contravariant basis vectors IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: physVector TYPE ( MappedVector3D ), INTENT ( inout ) :: compVector TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , k , iVar , iEl , iside REAL ( prec ) :: nHat ( 1 : 3 ) REAL ( prec ) :: nmag IF ( gpuAccel ) THEN CALL ContravariantProjection_MappedVector3D_gpu_wrapper ( physVector % interior % deviceData , & compVector % interior % deviceData , & geometry % dsdx % interior % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) CALL ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper ( physVector % boundary % deviceData , & compVector % boundaryNormal % deviceData , & geometry % nHat % boundary % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) ELSE ! Assume that tensor(j,i) is vector i, component j ! => dot product is done along first dimension to ! project onto computational space DO iEl = 1 , physVector % nElem DO iVar = 1 , physVector % nVar DO k = 0 , physVector % N DO j = 0 , physVector % N DO i = 0 , physVector % N compVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) compVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) compVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) END DO END DO END DO END DO END DO ! Boundary Terms DO iEl = 1 , physVector % nElem DO iside = 1 , 6 DO iVar = 1 , physVector % nVar DO k = 0 , physVector % N DO j = 0 , physVector % N nHat ( 1 : 3 ) = geometry % nHat % boundary % hostData ( 1 : 3 , j , k , 1 , iSide , iEl ) nmag = geometry % nScale % boundary % hostData ( j , k , 1 , iSide , iEl ) compVector % boundaryNormal % hostData ( j , k , iVar , iside , iEl ) = & ( nHat ( 1 ) * physVector % boundary % hostData ( 1 , j , k , iVar , iside , iEl ) + & nHat ( 2 ) * physVector % boundary % hostData ( 2 , j , k , iVar , iside , iEl ) + & nHat ( 3 ) * physVector % boundary % hostData ( 3 , j , k , iVar , iside , iEl ) ) * nmag END DO END DO END DO END DO END DO END IF END SUBROUTINE ContravariantProjection_MappedVector3D","tags":"","loc":"proc/contravariantprojection_mappedvector3d.html"},{"title":"ContravariantWeight_MappedScalar2D – SELF","text":"public subroutine ContravariantWeight_MappedScalar2D(scalar, geometry, workTensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type(SEMQuad), intent(in) :: geometry type( MappedTensor2D ), intent(inout) :: workTensor logical, intent(in) :: gpuAccel Calls proc~~contravariantweight_mappedscalar2d~~CallsGraph proc~contravariantweight_mappedscalar2d ContravariantWeight_MappedScalar2D interface~contravariantweight_mappedscalar2d_gpu_wrapper ContravariantWeight_MappedScalar2D_gpu_wrapper proc~contravariantweight_mappedscalar2d->interface~contravariantweight_mappedscalar2d_gpu_wrapper interface~contravariantweightboundary_mappedscalar2d_gpu_wrapper ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper proc~contravariantweight_mappedscalar2d->interface~contravariantweightboundary_mappedscalar2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ContravariantWeight_MappedScalar2D Source Code SUBROUTINE ContravariantWeight_MappedScalar2D ( scalar , geometry , workTensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantWeight_MappedScalar2D\" IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( in ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel TYPE ( MappedTensor2D ), INTENT ( inout ) :: workTensor ! Local INTEGER :: i , j , iVar , iEl , iside IF ( gpuAccel ) THEN CALL ContravariantWeight_MappedScalar2D_gpu_wrapper ( scalar % interior % deviceData , & workTensor % interior % deviceData , & geometry % dsdx % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) CALL ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper ( scalar % avgBoundary % deviceData , & workTensor % boundary % deviceData , & geometry % dsdx % boundary % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N workTensor % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 1 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) workTensor % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 2 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) workTensor % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 1 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) workTensor % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 2 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ! Boundary Terms DO iEl = 1 , scalar % nElem DO iside = 1 , 4 DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N workTensor % boundary % hostData ( 1 , 1 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 1 , j , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 1 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 2 , j , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , iVar , iside , iEl ) workTensor % boundary % hostData ( 1 , 2 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 1 , j , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 2 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 2 , j , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , iVar , iside , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE ContravariantWeight_MappedScalar2D","tags":"","loc":"proc/contravariantweight_mappedscalar2d.html"},{"title":"ContravariantWeight_MappedScalar3D – SELF","text":"public subroutine ContravariantWeight_MappedScalar3D(scalar, geometry, workTensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type(SEMHex), intent(in) :: geometry type( MappedTensor3D ), intent(inout) :: workTensor logical, intent(in) :: gpuAccel Calls proc~~contravariantweight_mappedscalar3d~~CallsGraph proc~contravariantweight_mappedscalar3d ContravariantWeight_MappedScalar3D interface~contravariantweightboundary_mappedscalar3d_gpu_wrapper ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper proc~contravariantweight_mappedscalar3d->interface~contravariantweightboundary_mappedscalar3d_gpu_wrapper interface~contravariantweight_mappedscalar3d_gpu_wrapper ContravariantWeight_MappedScalar3D_gpu_wrapper proc~contravariantweight_mappedscalar3d->interface~contravariantweight_mappedscalar3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ContravariantWeight_MappedScalar3D Source Code SUBROUTINE ContravariantWeight_MappedScalar3D ( scalar , geometry , workTensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantWeight_MappedScalar3D\" IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( in ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel TYPE ( MappedTensor3D ), INTENT ( inout ) :: workTensor ! Local INTEGER :: i , j , k , iVar , iEl , iside IF ( gpuAccel ) THEN CALL ContravariantWeight_MappedScalar3D_gpu_wrapper ( scalar % interior % deviceData , & workTensor % interior % deviceData , & geometry % dsdx % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) CALL ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper ( scalar % avgBoundary % deviceData , & workTensor % boundary % deviceData , & geometry % dsdx % boundary % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N DO i = 0 , scalar % N ! Get the x-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) ! Get the y-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) ! Get the z-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO END DO END DO END DO ! Boundary Term DO iEl = 1 , scalar % nElem DO iside = 1 , 6 DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N ! Get the x-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % boundary % hostData ( 1 , 1 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 1 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 1 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 2 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 3 , 1 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 3 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) ! Get the y-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % boundary % hostData ( 1 , 2 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 1 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 2 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 2 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 3 , 2 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 3 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) ! Get the z-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % boundary % hostData ( 1 , 3 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 3 , 1 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 3 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 3 , 2 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 3 , 3 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 3 , 3 , j , k , 1 , iside , iEl ) * & scalar % avgBoundary % hostData ( j , k , iVar , iside , iEl ) END DO END DO END DO END DO END DO END IF END SUBROUTINE ContravariantWeight_MappedScalar3D","tags":"","loc":"proc/contravariantweight_mappedscalar3d.html"},{"title":"Derivative_MappedScalar1D – SELF","text":"public subroutine Derivative_MappedScalar1D(scalar, geometry, dF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: scalar type(Geometry1D), intent(in) :: geometry type( MappedScalar1D ), intent(inout) :: dF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Derivative_MappedScalar1D Source Code SUBROUTINE Derivative_MappedScalar1D ( scalar , geometry , dF , dForm , gpuAccel ) ! Strong Form Operator ! ! Calculates the gradient of a scalar 1D function using the conservative form of the ! mapped gradient operator ! ! df/dx =  d\\xi/dx( df/d\\xi ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( in ) :: scalar TYPE ( Geometry1D ), INTENT ( in ) :: geometry TYPE ( MappedScalar1D ), INTENT ( inout ) :: dF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL scalar % interp % DGDerivative_1D ( scalar % interior % deviceData , & scalar % boundary % deviceData , & df % interior % deviceData , & scalar % nVar , & scalar % nElem ) ELSE CALL scalar % interp % DGDerivative_1D ( scalar % interior % hostData , & scalar % boundary % hostData , & df % interior % hostData , & scalar % nVar , & scalar % nElem ) END IF ELSEIF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL scalar % interp % Derivative_1D ( scalar % interior % deviceData , & df % interior % deviceData , & scalar % nVar , & scalar % nElem ) ELSE CALL scalar % interp % Derivative_1D ( scalar % interior % hostData , & df % interior % hostData , & scalar % nVar , & scalar % nElem ) END IF END IF CALL df % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Derivative_MappedScalar1D","tags":"","loc":"proc/derivative_mappedscalar1d.html"},{"title":"Divergence_MappedVector2D – SELF","text":"public subroutine Divergence_MappedVector2D(compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: compVector type(SEMQuad), intent(in) :: geometry type( MappedScalar2D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Divergence_MappedVector2D Source Code SUBROUTINE Divergence_MappedVector2D ( compVector , geometry , divVector , dForm , gpuAccel ) ! Strong Form Operator ! ! DG Weak Form Operator ! ! Assumes vector has been projected to computational coordinates ! IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: compVector TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedScalar2D ), INTENT ( inout ) :: divVector INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDGDivergence_2D ( compVector % interior % deviceData , & compVector % boundaryNormal % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDGDivergence_2D ( compVector % interior % hostData , & compVector % boundaryNormal % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDivergence_2D ( compVector % interior % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDivergence_2D ( compVector % interior % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF END IF CALL divVector % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Divergence_MappedVector2D","tags":"","loc":"proc/divergence_mappedvector2d.html"},{"title":"Divergence_MappedVector3D – SELF","text":"public subroutine Divergence_MappedVector3D(compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: compVector type(SEMHex), intent(in) :: geometry type( MappedScalar3D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Divergence_MappedVector3D Source Code SUBROUTINE Divergence_MappedVector3D ( compVector , geometry , divVector , dForm , gpuAccel ) ! IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: compVector TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedScalar3D ), INTENT ( inout ) :: divVector INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDGDivergence_3D ( compVector % interior % deviceData , & compVector % boundaryNormal % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDGDivergence_3D ( compVector % interior % hostData , & compVector % boundaryNormal % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDivergence_3D ( compVector % interior % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDivergence_3D ( compVector % interior % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) END IF END IF CALL divVector % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Divergence_MappedVector3D","tags":"","loc":"proc/divergence_mappedvector3d.html"},{"title":"Gradient_MappedScalar2D – SELF","text":"public subroutine Gradient_MappedScalar2D(scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Gradient_MappedScalar2D Source Code SUBROUTINE Gradient_MappedScalar2D ( scalar , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator - (Conservative Form) ! ! Calculates the gradient of a scalar 2D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( in ) :: scalar TYPE ( MappedTensor2D ), INTENT ( inout ) :: workTensor TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedVector2D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL scalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSEIF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF END IF CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedScalar2D","tags":"","loc":"proc/gradient_mappedscalar2d.html"},{"title":"Gradient_MappedScalar3D – SELF","text":"public subroutine Gradient_MappedScalar3D(scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Gradient_MappedScalar3D Source Code SUBROUTINE Gradient_MappedScalar3D ( scalar , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator ! ! Calculates the gradient of a scalar 3D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( in ) :: scalar TYPE ( MappedTensor3D ), INTENT ( inout ) :: workTensor TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedVector3D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL scalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF END IF CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedScalar3D","tags":"","loc":"proc/gradient_mappedscalar3d.html"},{"title":"Gradient_MappedVector2D – SELF","text":"public subroutine Gradient_MappedVector2D(vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedScalar2D ), intent(inout) :: workScalar type( MappedVector2D ), intent(inout) :: workVector type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedTensor2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Gradient_MappedVector2D Source Code SUBROUTINE Gradient_MappedVector2D ( vector , workScalar , workVector , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator - (Conservative Form) ! ! Calculates the gradient of a scalar 2D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: vector TYPE ( MappedScalar2D ), INTENT ( inout ) :: workScalar ! (scalar) nvar = 2*nvar TYPE ( MappedVector2D ), INTENT ( inout ) :: workVector ! (scalar) nvar = 2*nvar TYPE ( MappedTensor2D ), INTENT ( inout ) :: workTensor ! (tensor) nvar = 2*nvar TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedTensor2D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL vector % MapToScalar ( workScalar , gpuAccel ) CALL workScalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF END IF CALL workVector % MapToTensor ( gradF , gpuAccel ) CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedVector2D","tags":"","loc":"proc/gradient_mappedvector2d.html"},{"title":"Gradient_MappedVector3D – SELF","text":"public subroutine Gradient_MappedVector3D(vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedScalar3D ), intent(inout) :: workScalar type( MappedVector3D ), intent(inout) :: workVector type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedTensor3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Gradient_MappedVector3D Source Code SUBROUTINE Gradient_MappedVector3D ( vector , workScalar , workVector , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator - (Conservative Form) ! ! Calculates the gradient of a scalar 3D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: vector TYPE ( MappedScalar3D ), INTENT ( inout ) :: workScalar ! (scalar) nvar = 3*nvar TYPE ( MappedVector3D ), INTENT ( inout ) :: workVector ! (vector) nvar = 3*nvar TYPE ( MappedTensor3D ), INTENT ( inout ) :: workTensor ! (tensor) nvar = 3*nvar TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedTensor3D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL vector % MapToScalar ( workScalar , gpuAccel ) CALL workScalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF END IF CALL workVector % MapToTensor ( gradF , gpuAccel ) CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedVector3D","tags":"","loc":"proc/gradient_mappedvector3d.html"},{"title":"JacobianWeight_MappedScalar1D – SELF","text":"public subroutine JacobianWeight_MappedScalar1D(scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar type(Geometry1D), intent(in) :: geometry logical, intent(in) :: gpuAccel Calls proc~~jacobianweight_mappedscalar1d~~CallsGraph proc~jacobianweight_mappedscalar1d JacobianWeight_MappedScalar1D interface~jacobianweight_mappedscalar1d_gpu_wrapper JacobianWeight_MappedScalar1D_gpu_wrapper proc~jacobianweight_mappedscalar1d->interface~jacobianweight_mappedscalar1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code JacobianWeight_MappedScalar1D Source Code SUBROUTINE JacobianWeight_MappedScalar1D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar1D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( inout ) :: scalar TYPE ( Geometry1D ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i IF ( gpuAccel ) THEN CALL JacobianWeight_MappedScalar1D_gpu_wrapper ( scalar % interior % deviceData , & geometry % dxds % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO i = 0 , scalar % N scalar % interior % hostData ( i , iVar , iEl ) = scalar % interior % hostData ( i , iVar , iEl ) / & geometry % dxds % interior % hostData ( i , 1 , iEl ) END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedScalar1D","tags":"","loc":"proc/jacobianweight_mappedscalar1d.html"},{"title":"JacobianWeight_MappedScalar2D – SELF","text":"public subroutine JacobianWeight_MappedScalar2D(scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel Calls proc~~jacobianweight_mappedscalar2d~~CallsGraph proc~jacobianweight_mappedscalar2d JacobianWeight_MappedScalar2D interface~jacobianweight_mappedscalar2d_gpu_wrapper JacobianWeight_MappedScalar2D_gpu_wrapper proc~jacobianweight_mappedscalar2d->interface~jacobianweight_mappedscalar2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code JacobianWeight_MappedScalar2D Source Code SUBROUTINE JacobianWeight_MappedScalar2D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j IF ( gpuAccel ) THEN CALL JacobianWeight_MappedScalar2D_gpu_wrapper ( scalar % interior % deviceData , & geometry % J % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % interior % hostData ( i , j , iVar , iEl ) = scalar % interior % hostData ( i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedScalar2D","tags":"","loc":"proc/jacobianweight_mappedscalar2d.html"},{"title":"JacobianWeight_MappedScalar3D – SELF","text":"public subroutine JacobianWeight_MappedScalar3D(scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel Calls proc~~jacobianweight_mappedscalar3d~~CallsGraph proc~jacobianweight_mappedscalar3d JacobianWeight_MappedScalar3D interface~jacobianweight_mappedscalar3d_gpu_wrapper JacobianWeight_MappedScalar3D_gpu_wrapper proc~jacobianweight_mappedscalar3d->interface~jacobianweight_mappedscalar3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code JacobianWeight_MappedScalar3D Source Code SUBROUTINE JacobianWeight_MappedScalar3D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k IF ( gpuAccel ) THEN CALL JacobianWeight_MappedScalar3D_gpu_wrapper ( scalar % interior % deviceData , & geometry % J % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % interior % hostData ( i , j , k , iVar , iEl ) = scalar % interior % hostData ( i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) END DO END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedScalar3D","tags":"","loc":"proc/jacobianweight_mappedscalar3d.html"},{"title":"JacobianWeight_MappedTensor2D – SELF","text":"public subroutine JacobianWeight_MappedTensor2D(tensor, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel Calls proc~~jacobianweight_mappedtensor2d~~CallsGraph proc~jacobianweight_mappedtensor2d JacobianWeight_MappedTensor2D interface~jacobianweight_mappedtensor2d_gpu_wrapper JacobianWeight_MappedTensor2D_gpu_wrapper proc~jacobianweight_mappedtensor2d->interface~jacobianweight_mappedtensor2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code JacobianWeight_MappedTensor2D Source Code SUBROUTINE JacobianWeight_MappedTensor2D ( tensor , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedTensor2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedTensor2D ), INTENT ( inout ) :: tensor TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j IF ( gpuAccel ) THEN CALL JacobianWeight_MappedTensor2D_gpu_wrapper ( tensor % interior % deviceData , & geometry % J % interior % deviceData , & tensor % N , & tensor % nVar , & tensor % nElem ) ELSE DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) = tensor % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) tensor % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) = tensor % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) tensor % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) = tensor % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) tensor % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) = tensor % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedTensor2D","tags":"","loc":"proc/jacobianweight_mappedtensor2d.html"},{"title":"JacobianWeight_MappedTensor3D – SELF","text":"public subroutine JacobianWeight_MappedTensor3D(tensor, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel Calls proc~~jacobianweight_mappedtensor3d~~CallsGraph proc~jacobianweight_mappedtensor3d JacobianWeight_MappedTensor3D interface~jacobianweight_mappedtensor3d_gpu_wrapper JacobianWeight_MappedTensor3D_gpu_wrapper proc~jacobianweight_mappedtensor3d->interface~jacobianweight_mappedtensor3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code JacobianWeight_MappedTensor3D Source Code SUBROUTINE JacobianWeight_MappedTensor3D ( tensor , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedTensor3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedTensor3D ), INTENT ( inout ) :: tensor TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k IF ( gpuAccel ) THEN CALL JacobianWeight_MappedTensor3D_gpu_wrapper ( tensor % interior % deviceData , & geometry % J % interior % deviceData , & tensor % N , & tensor % nVar , & tensor % nElem ) ELSE DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO k = 0 , tensor % N DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) END DO END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedTensor3D","tags":"","loc":"proc/jacobianweight_mappedtensor3d.html"},{"title":"JacobianWeight_MappedVector2D – SELF","text":"public subroutine JacobianWeight_MappedVector2D(vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel Calls proc~~jacobianweight_mappedvector2d~~CallsGraph proc~jacobianweight_mappedvector2d JacobianWeight_MappedVector2D interface~jacobianweight_mappedvector2d_gpu_wrapper JacobianWeight_MappedVector2D_gpu_wrapper proc~jacobianweight_mappedvector2d->interface~jacobianweight_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code JacobianWeight_MappedVector2D Source Code SUBROUTINE JacobianWeight_MappedVector2D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedVector2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j IF ( gpuAccel ) THEN CALL JacobianWeight_MappedVector2D_gpu_wrapper ( vector % interior % deviceData , & geometry % J % interior % deviceData , & vector % N , & vector % nVar , & vector % nElem ) ELSE DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO j = 0 , vector % N DO i = 0 , vector % N vector % interior % hostData ( 1 , i , j , iVar , iEl ) = vector % interior % hostData ( 1 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) vector % interior % hostData ( 2 , i , j , iVar , iEl ) = vector % interior % hostData ( 2 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedVector2D","tags":"","loc":"proc/jacobianweight_mappedvector2d.html"},{"title":"JacobianWeight_MappedVector3D – SELF","text":"public subroutine JacobianWeight_MappedVector3D(vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel Calls proc~~jacobianweight_mappedvector3d~~CallsGraph proc~jacobianweight_mappedvector3d JacobianWeight_MappedVector3D interface~jacobianweight_mappedvector3d_gpu_wrapper JacobianWeight_MappedVector3D_gpu_wrapper proc~jacobianweight_mappedvector3d->interface~jacobianweight_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code JacobianWeight_MappedVector3D Source Code SUBROUTINE JacobianWeight_MappedVector3D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedVector3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k IF ( gpuAccel ) THEN CALL JacobianWeight_MappedVector3D_gpu_wrapper ( vector % interior % deviceData , & geometry % J % interior % deviceData , & vector % N , & vector % nVar , & vector % nElem ) ELSE DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO k = 0 , vector % N DO j = 0 , vector % N DO i = 0 , vector % N vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) END DO END DO END DO END DO END DO END IF END SUBROUTINE JacobianWeight_MappedVector3D","tags":"","loc":"proc/jacobianweight_mappedvector3d.html"},{"title":"MPIExchangeAsync_MappedScalar2D – SELF","text":"public subroutine MPIExchangeAsync_MappedScalar2D(scalar, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: resetCount Calls proc~~mpiexchangeasync_mappedscalar2d~~CallsGraph proc~mpiexchangeasync_mappedscalar2d MPIExchangeAsync_MappedScalar2D mpi_isend mpi_isend proc~mpiexchangeasync_mappedscalar2d->mpi_isend mpi_irecv mpi_irecv proc~mpiexchangeasync_mappedscalar2d->mpi_irecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code MPIExchangeAsync_MappedScalar2D Source Code SUBROUTINE MPIExchangeAsync_MappedScalar2D ( scalar , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , scalar % nElem DO s1 = 1 , 4 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) msgCount = msgCount + 1 CALL MPI_IRECV ( scalar % extBoundary % hostData (:,:, s1 , e1 ), & ( scalar % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( scalar % boundary % hostData (:,:, s1 , e1 ), & ( scalar % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedScalar2D","tags":"","loc":"proc/mpiexchangeasync_mappedscalar2d.html"},{"title":"MPIExchangeAsync_MappedScalar3D – SELF","text":"public subroutine MPIExchangeAsync_MappedScalar3D(scalar, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: resetCount Calls proc~~mpiexchangeasync_mappedscalar3d~~CallsGraph proc~mpiexchangeasync_mappedscalar3d MPIExchangeAsync_MappedScalar3D mpi_isend mpi_isend proc~mpiexchangeasync_mappedscalar3d->mpi_isend mpi_irecv mpi_irecv proc~mpiexchangeasync_mappedscalar3d->mpi_irecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code MPIExchangeAsync_MappedScalar3D Source Code SUBROUTINE MPIExchangeAsync_MappedScalar3D ( scalar , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , scalar % nElem DO s1 = 1 , 6 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) msgCount = msgCount + 1 CALL MPI_IRECV ( scalar % extBoundary % hostData (:,:,:, s1 , e1 ), & ( scalar % N + 1 ) * ( scalar % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( scalar % boundary % hostData (:,:,:, s1 , e1 ), & ( scalar % N + 1 ) * ( scalar % N + 1 ) * scalar % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedScalar3D","tags":"","loc":"proc/mpiexchangeasync_mappedscalar3d.html"},{"title":"MPIExchangeAsync_MappedTensor2D – SELF","text":"public subroutine MPIExchangeAsync_MappedTensor2D(tensor, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: resetCount Calls proc~~mpiexchangeasync_mappedtensor2d~~CallsGraph proc~mpiexchangeasync_mappedtensor2d MPIExchangeAsync_MappedTensor2D mpi_isend mpi_isend proc~mpiexchangeasync_mappedtensor2d->mpi_isend mpi_irecv mpi_irecv proc~mpiexchangeasync_mappedtensor2d->mpi_irecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code MPIExchangeAsync_MappedTensor2D Source Code SUBROUTINE MPIExchangeAsync_MappedTensor2D ( tensor , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedTensor2D ), INTENT ( inout ) :: tensor TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , tensor % nElem DO s1 = 1 , 4 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) msgCount = msgCount + 1 CALL MPI_IRECV ( tensor % extBoundary % hostData (:,:,:,:, s1 , e1 ), & 4 * ( tensor % N + 1 ) * tensor % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( tensor % boundary % hostData (:,:,:,:, s1 , e1 ), & 4 * ( tensor % N + 1 ) * tensor % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedTensor2D","tags":"","loc":"proc/mpiexchangeasync_mappedtensor2d.html"},{"title":"MPIExchangeAsync_MappedTensor3D – SELF","text":"public subroutine MPIExchangeAsync_MappedTensor3D(tensor, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: resetCount Calls proc~~mpiexchangeasync_mappedtensor3d~~CallsGraph proc~mpiexchangeasync_mappedtensor3d MPIExchangeAsync_MappedTensor3D mpi_isend mpi_isend proc~mpiexchangeasync_mappedtensor3d->mpi_isend mpi_irecv mpi_irecv proc~mpiexchangeasync_mappedtensor3d->mpi_irecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code MPIExchangeAsync_MappedTensor3D Source Code SUBROUTINE MPIExchangeAsync_MappedTensor3D ( tensor , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedTensor3D ), INTENT ( inout ) :: tensor TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , tensor % nElem DO s1 = 1 , 6 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) msgCount = msgCount + 1 CALL MPI_IRECV ( tensor % extBoundary % hostData (:,:,:,:,:, s1 , e1 ), & 9 * ( tensor % N + 1 ) * ( tensor % N + 1 ) * tensor % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( tensor % boundary % hostData (:,:,:,:,:, s1 , e1 ), & 9 * ( tensor % N + 1 ) * ( tensor % N + 1 ) * tensor % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedTensor3D","tags":"","loc":"proc/mpiexchangeasync_mappedtensor3d.html"},{"title":"MPIExchangeAsync_MappedVector2D – SELF","text":"public subroutine MPIExchangeAsync_MappedVector2D(vector, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: resetCount Calls proc~~mpiexchangeasync_mappedvector2d~~CallsGraph proc~mpiexchangeasync_mappedvector2d MPIExchangeAsync_MappedVector2D mpi_isend mpi_isend proc~mpiexchangeasync_mappedvector2d->mpi_isend mpi_irecv mpi_irecv proc~mpiexchangeasync_mappedvector2d->mpi_irecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code MPIExchangeAsync_MappedVector2D Source Code SUBROUTINE MPIExchangeAsync_MappedVector2D ( vector , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh2D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , vector % nElem DO s1 = 1 , 4 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) msgCount = msgCount + 1 CALL MPI_IRECV ( vector % extBoundary % hostData (:,:,:, s1 , e1 ), & 2 * ( vector % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( vector % boundary % hostData (:,:,:, s1 , e1 ), & 2 * ( vector % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedVector2D","tags":"","loc":"proc/mpiexchangeasync_mappedvector2d.html"},{"title":"MPIExchangeAsync_MappedVector3D – SELF","text":"public subroutine MPIExchangeAsync_MappedVector3D(vector, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: resetCount Calls proc~~mpiexchangeasync_mappedvector3d~~CallsGraph proc~mpiexchangeasync_mappedvector3d MPIExchangeAsync_MappedVector3D mpi_isend mpi_isend proc~mpiexchangeasync_mappedvector3d->mpi_isend mpi_irecv mpi_irecv proc~mpiexchangeasync_mappedvector3d->mpi_irecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code MPIExchangeAsync_MappedVector3D Source Code SUBROUTINE MPIExchangeAsync_MappedVector3D ( vector , mpiHandler , mesh , resetCount ) IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( MPILayer ), INTENT ( inout ) :: mpiHandler TYPE ( Mesh3D ), INTENT ( in ) :: mesh LOGICAL , INTENT ( in ) :: resetCount ! Local INTEGER :: e1 , s1 , e2 , s2 INTEGER :: globalSideId , r2 INTEGER :: iError INTEGER :: msgCount IF ( mpiHandler % mpiEnabled ) THEN IF ( resetCount ) THEN msgCount = 0 ELSE msgCount = mpiHandler % msgCount END IF DO e1 = 1 , vector % nElem DO s1 = 1 , 6 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) ! Neighbor Element r2 = mpiHandler % elemToRank % hostData ( e2 ) ! Neighbor Rank IF ( r2 /= mpiHandler % rankId ) THEN s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 globalSideId = mesh % self_sideInfo % hostdata ( 2 , s1 , e1 ) msgCount = msgCount + 1 CALL MPI_IRECV ( vector % extBoundary % hostData (:,:,:,:, s1 , e1 ), & 3 * ( vector % N + 1 ) * ( vector % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) msgCount = msgCount + 1 CALL MPI_ISEND ( vector % boundary % hostData (:,:,:,:, s1 , e1 ), & 3 * ( vector % N + 1 ) * ( vector % N + 1 ) * vector % nVar , & mpiHandler % mpiPrec , & r2 , globalSideId , & mpiHandler % mpiComm , & mpiHandler % requests % hostData ( msgCount , 1 ), iError ) END IF END DO END DO mpiHandler % msgCount = msgCount END IF END SUBROUTINE MPIExchangeAsync_MappedVector3D","tags":"","loc":"proc/mpiexchangeasync_mappedvector3d.html"},{"title":"MapToScalar_MappedVector2D – SELF","text":"public subroutine MapToScalar_MappedVector2D(vector, scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedScalar2D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel Calls proc~~maptoscalar_mappedvector2d~~CallsGraph proc~maptoscalar_mappedvector2d MapToScalar_MappedVector2D interface~maptoscalarboundary_mappedvector2d_gpu_wrapper MapToScalarBoundary_MappedVector2D_gpu_wrapper proc~maptoscalar_mappedvector2d->interface~maptoscalarboundary_mappedvector2d_gpu_wrapper interface~maptoscalar_mappedvector2d_gpu_wrapper MapToScalar_MappedVector2D_gpu_wrapper proc~maptoscalar_mappedvector2d->interface~maptoscalar_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code MapToScalar_MappedVector2D Source Code SUBROUTINE MapToScalar_MappedVector2D ( vector , scalar , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToScalar_MappedVector2D\" IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: vector TYPE ( MappedScalar2D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , i , j , ivar , jvar , iel , iside IF ( gpuAccel ) THEN CALL MapToScalar_MappedVector2D_gpu_wrapper ( scalar % interior % deviceData , & vector % interior % deviceData , & vector % N , & vector % nVar , & vector % nelem ) CALL MapToScalarBoundary_MappedVector2D_gpu_wrapper ( scalar % boundary % deviceData , & vector % boundary % deviceData , & vector % N , & vector % nVar , & vector % nelem ) ELSE DO iel = 1 , vector % nelem DO ivar = 1 , vector % nvar DO j = 0 , vector % N DO i = 0 , vector % N DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) scalar % interior % hostData ( i , j , jvar , iel ) = vector % interior % hostData ( row , i , j , ivar , iel ) END DO END DO END DO END DO END DO ! Boundary Terms DO iel = 1 , vector % nelem DO iside = 1 , 4 DO ivar = 1 , vector % nvar DO j = 0 , vector % N DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) scalar % boundary % hostData ( j , jvar , iside , iel ) = vector % boundary % hostData ( row , j , ivar , iside , iel ) END DO END DO END DO END DO END DO END IF END SUBROUTINE MapToScalar_MappedVector2D","tags":"","loc":"proc/maptoscalar_mappedvector2d.html"},{"title":"MapToScalar_MappedVector3D – SELF","text":"public subroutine MapToScalar_MappedVector3D(vector, scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedScalar3D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel Calls proc~~maptoscalar_mappedvector3d~~CallsGraph proc~maptoscalar_mappedvector3d MapToScalar_MappedVector3D interface~maptoscalar_mappedvector3d_gpu_wrapper MapToScalar_MappedVector3D_gpu_wrapper proc~maptoscalar_mappedvector3d->interface~maptoscalar_mappedvector3d_gpu_wrapper interface~maptoscalarboundary_mappedvector3d_gpu_wrapper MapToScalarBoundary_MappedVector3D_gpu_wrapper proc~maptoscalar_mappedvector3d->interface~maptoscalarboundary_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code MapToScalar_MappedVector3D Source Code SUBROUTINE MapToScalar_MappedVector3D ( vector , scalar , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToScalar_MappedVector3D\" IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: vector TYPE ( MappedScalar3D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , i , j , k , ivar , jvar , iel , iside IF ( gpuAccel ) THEN CALL MapToScalar_MappedVector3D_gpu_wrapper ( scalar % interior % deviceData , & vector % interior % deviceData , & vector % N , & vector % nVar , & vector % nelem ) CALL MapToScalarBoundary_MappedVector3D_gpu_wrapper ( scalar % boundary % deviceData , & vector % boundary % deviceData , & vector % N , & vector % nVar , & vector % nelem ) ELSE DO iel = 1 , vector % nelem DO ivar = 1 , vector % nvar DO k = 0 , vector % N DO j = 0 , vector % N DO i = 0 , vector % N DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) scalar % interior % hostData ( i , j , k , jvar , iel ) = vector % interior % hostData ( row , i , j , k , ivar , iel ) END DO END DO END DO END DO END DO END DO ! Boundary Terms DO iel = 1 , vector % nelem DO iside = 1 , 6 DO ivar = 1 , vector % nvar DO k = 0 , vector % N DO j = 0 , vector % N DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) scalar % boundary % hostData ( j , k , jvar , iside , iel ) = vector % boundary % hostData ( row , j , k , ivar , iside , iel ) END DO END DO END DO END DO END DO END DO END IF END SUBROUTINE MapToScalar_MappedVector3D","tags":"","loc":"proc/maptoscalar_mappedvector3d.html"},{"title":"MapToTensor_MappedVector2D – SELF","text":"public subroutine MapToTensor_MappedVector2D(vector, tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedTensor2D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel Calls proc~~maptotensor_mappedvector2d~~CallsGraph proc~maptotensor_mappedvector2d MapToTensor_MappedVector2D interface~maptotensorboundary_mappedvector2d_gpu_wrapper MapToTensorBoundary_MappedVector2D_gpu_wrapper proc~maptotensor_mappedvector2d->interface~maptotensorboundary_mappedvector2d_gpu_wrapper interface~maptotensor_mappedvector2d_gpu_wrapper MapToTensor_MappedVector2D_gpu_wrapper proc~maptotensor_mappedvector2d->interface~maptotensor_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code MapToTensor_MappedVector2D Source Code SUBROUTINE MapToTensor_MappedVector2D ( vector , tensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToTensor_MappedVector2D\" IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: vector TYPE ( MappedTensor2D ), INTENT ( inout ) :: tensor LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , col , i , j , ivar , jvar , iel , iside IF ( gpuAccel ) THEN CALL MapToTensor_MappedVector2D_gpu_wrapper ( tensor % interior % deviceData , & vector % interior % deviceData , & tensor % N , & tensor % nVar , & tensor % nelem ) CALL MapToTensorBoundary_MappedVector2D_gpu_wrapper ( tensor % boundary % deviceData , & vector % boundary % deviceData , & tensor % N , & tensor % nVar , & tensor % nelem ) ELSE DO iel = 1 , tensor % nelem DO ivar = 1 , tensor % nvar DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) tensor % interior % hostData ( row , col , i , j , ivar , iel ) = vector % interior % hostData ( col , i , j , jvar , iel ) END DO END DO END DO END DO END DO END DO ! Boundary Terms DO iel = 1 , tensor % nelem DO iside = 1 , 4 DO ivar = 1 , tensor % nvar DO j = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) tensor % boundary % hostData ( row , col , j , ivar , iside , iel ) = vector % boundary % hostData ( col , j , jvar , iside , iel ) END DO END DO END DO END DO END DO END DO END IF END SUBROUTINE MapToTensor_MappedVector2D","tags":"","loc":"proc/maptotensor_mappedvector2d.html"},{"title":"MapToTensor_MappedVector3D – SELF","text":"public subroutine MapToTensor_MappedVector3D(vector, tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedTensor3D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel Calls proc~~maptotensor_mappedvector3d~~CallsGraph proc~maptotensor_mappedvector3d MapToTensor_MappedVector3D interface~maptotensor_mappedvector3d_gpu_wrapper MapToTensor_MappedVector3D_gpu_wrapper proc~maptotensor_mappedvector3d->interface~maptotensor_mappedvector3d_gpu_wrapper interface~maptotensorboundary_mappedvector3d_gpu_wrapper MapToTensorBoundary_MappedVector3D_gpu_wrapper proc~maptotensor_mappedvector3d->interface~maptotensorboundary_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code MapToTensor_MappedVector3D Source Code SUBROUTINE MapToTensor_MappedVector3D ( vector , tensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToTensor_MappedVector3D\" IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: vector TYPE ( MappedTensor3D ), INTENT ( inout ) :: tensor LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , col , i , j , k , ivar , jvar , iel , iside IF ( gpuAccel ) THEN CALL MapToTensor_MappedVector3D_gpu_wrapper ( tensor % interior % deviceData , & vector % interior % deviceData , & tensor % N , & tensor % nVar , & tensor % nelem ) CALL MapToTensorBoundary_MappedVector3D_gpu_wrapper ( tensor % boundary % deviceData , & vector % boundary % deviceData , & tensor % N , & tensor % nVar , & tensor % nelem ) ELSE DO iel = 1 , tensor % nelem DO ivar = 1 , tensor % nvar DO k = 0 , tensor % N DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) tensor % interior % hostData ( row , col , i , j , k , ivar , iel ) = vector % interior % hostData ( col , i , j , k , jvar , iel ) END DO END DO END DO END DO END DO END DO END DO ! Boundary Terms DO iel = 1 , tensor % nelem DO iside = 1 , 6 DO ivar = 1 , tensor % nvar DO k = 0 , tensor % N DO j = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) tensor % boundary % hostData ( row , col , j , k , ivar , iside , iel ) = vector % boundary % hostData ( col , j , k , jvar , iside , iel ) END DO END DO END DO END DO END DO END DO END DO END IF END SUBROUTINE MapToTensor_MappedVector3D","tags":"","loc":"proc/maptotensor_mappedvector3d.html"},{"title":"SideExchange_MappedScalar2D – SELF","text":"public subroutine SideExchange_MappedScalar2D(scalar, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type(Mesh2D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel Calls proc~~sideexchange_mappedscalar2d~~CallsGraph proc~sideexchange_mappedscalar2d SideExchange_MappedScalar2D interface~sideexchange_mappedscalar2d_gpu_wrapper SideExchange_MappedScalar2D_gpu_wrapper proc~sideexchange_mappedscalar2d->interface~sideexchange_mappedscalar2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SideExchange_MappedScalar2D Source Code SUBROUTINE SideExchange_MappedScalar2D ( scalar , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( Mesh2D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 INTEGER :: flip , bcid INTEGER :: i1 , i2 , ivar INTEGER :: neighborRank IF ( gpuAccel ) THEN CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL SideExchange_MappedScalar2D_gpu_wrapper ( scalar % extBoundary % deviceData , & scalar % boundary % deviceData , & mesh % self_sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & scalar % N , & scalar % nvar , & scalar % nElem ) CALL decomp % FinalizeMPIExchangeAsync () ELSE CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 4 e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % self_sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2 ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , scalar % nvar DO i1 = 0 , scalar % N scalar % extBoundary % hostData ( i1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i1 , ivar , s2 , e2 ) END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , scalar % nvar DO i1 = 0 , scalar % N i2 = scalar % N - i1 scalar % extBoundary % hostData ( i1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , ivar , s2 , e2 ) END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL scalar % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedScalar2D","tags":"","loc":"proc/sideexchange_mappedscalar2d.html"},{"title":"SideExchange_MappedScalar3D – SELF","text":"public subroutine SideExchange_MappedScalar3D(scalar, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type(Mesh3D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel Calls proc~~sideexchange_mappedscalar3d~~CallsGraph proc~sideexchange_mappedscalar3d SideExchange_MappedScalar3D interface~sideexchange_mappedscalar3d_gpu_wrapper SideExchange_MappedScalar3D_gpu_wrapper proc~sideexchange_mappedscalar3d->interface~sideexchange_mappedscalar3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SideExchange_MappedScalar3D Source Code SUBROUTINE SideExchange_MappedScalar3D ( scalar , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( Mesh3D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 INTEGER :: flip , bcid , globalSideId INTEGER :: neighborRank INTEGER :: i1 , i2 , j1 , j2 , ivar IF ( gpuAccel ) THEN CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL SideExchange_MappedScalar3D_gpu_wrapper ( scalar % extBoundary % deviceData , & scalar % boundary % deviceData , & mesh % self_sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & scalar % N , & scalar % nvar , & scalar % nElem ) CALL decomp % FinalizeMPIExchangeAsync () ELSE CALL scalar % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 6 globalSideId = mesh % self_sideInfo % hostData ( 2 , s1 , e1 ) e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % self_sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2 ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % N DO i1 = 0 , scalar % N scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i1 , j1 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % N DO i1 = 0 , scalar % N i2 = scalar % N - j1 j2 = i1 scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 2 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % N DO i1 = 0 , scalar % N i2 = scalar % N - i1 j2 = scalar % N - j1 scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , scalar % nvar DO j1 = 0 , scalar % N DO i1 = 0 , scalar % N i2 = j1 j2 = scalar % N - i1 scalar % extBoundary % hostData ( i1 , j1 , ivar , s1 , e1 ) = & scalar % boundary % hostData ( i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL scalar % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedScalar3D","tags":"","loc":"proc/sideexchange_mappedscalar3d.html"},{"title":"SideExchange_MappedTensor2D – SELF","text":"public subroutine SideExchange_MappedTensor2D(tensor, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor type(Mesh2D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel Calls proc~~sideexchange_mappedtensor2d~~CallsGraph proc~sideexchange_mappedtensor2d SideExchange_MappedTensor2D interface~sideexchange_mappedtensor2d_gpu_wrapper SideExchange_MappedTensor2D_gpu_wrapper proc~sideexchange_mappedtensor2d->interface~sideexchange_mappedtensor2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SideExchange_MappedTensor2D Source Code SUBROUTINE SideExchange_MappedTensor2D ( tensor , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedTensor2D ), INTENT ( inout ) :: tensor TYPE ( Mesh2D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 INTEGER :: flip , bcid , globalSideId INTEGER :: neighborRank INTEGER :: i1 , i2 , ivar IF ( gpuAccel ) THEN CALL tensor % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL SideExchange_MappedTensor2D_gpu_wrapper ( tensor % extBoundary % deviceData , & tensor % boundary % deviceData , & mesh % self_sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & tensor % N , & tensor % nvar , & tensor % nElem ) CALL decomp % FinalizeMPIExchangeAsync () ELSE CALL tensor % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 4 globalSideId = mesh % self_sideInfo % hostData ( 2 , s1 , e1 ) e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % self_sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2 ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , tensor % nvar DO i1 = 0 , tensor % N tensor % extBoundary % hostData ( 1 : 2 , 1 : 2 , i1 , ivar , s1 , e1 ) = & tensor % boundary % hostData ( 1 : 2 , 1 : 2 , i1 , ivar , s2 , e2 ) END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , tensor % nvar DO i1 = 0 , tensor % N i2 = tensor % N - i1 tensor % extBoundary % hostData ( 1 : 2 , 1 : 2 , i1 , ivar , s1 , e1 ) = & tensor % boundary % hostData ( 1 : 2 , 1 : 2 , i2 , ivar , s2 , e2 ) END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL tensor % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedTensor2D","tags":"","loc":"proc/sideexchange_mappedtensor2d.html"},{"title":"SideExchange_MappedTensor3D – SELF","text":"public subroutine SideExchange_MappedTensor3D(tensor, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor type(Mesh3D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel Calls proc~~sideexchange_mappedtensor3d~~CallsGraph proc~sideexchange_mappedtensor3d SideExchange_MappedTensor3D interface~sideexchange_mappedtensor3d_gpu_wrapper SideExchange_MappedTensor3D_gpu_wrapper proc~sideexchange_mappedtensor3d->interface~sideexchange_mappedtensor3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SideExchange_MappedTensor3D Source Code SUBROUTINE SideExchange_MappedTensor3D ( tensor , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedTensor3D ), INTENT ( inout ) :: tensor TYPE ( Mesh3D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 INTEGER :: flip , bcid , globalSideId INTEGER :: neighborRank INTEGER :: i1 , i2 , j1 , j2 , ivar IF ( gpuAccel ) THEN CALL tensor % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL SideExchange_MappedTensor3D_gpu_wrapper ( tensor % extBoundary % deviceData , & tensor % boundary % deviceData , & mesh % self_sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & tensor % N , & tensor % nvar , & tensor % nElem ) CALL decomp % FinalizeMPIExchangeAsync () ELSE CALL tensor % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 6 globalSideId = mesh % self_sideInfo % hostData ( 2 , s1 , e1 ) e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % self_sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2 ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , tensor % nvar DO j1 = 0 , tensor % N DO i1 = 0 , tensor % N tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & tensor % boundary % hostData ( 1 : 3 , 1 : 3 , i1 , j1 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , tensor % nvar DO j1 = 0 , tensor % N DO i1 = 0 , tensor % N i2 = tensor % N - j1 j2 = i1 tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & tensor % boundary % hostData ( 1 : 3 , 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 2 ) THEN DO ivar = 1 , tensor % nvar DO j1 = 0 , tensor % N DO i1 = 0 , tensor % N i2 = tensor % N - i1 j2 = tensor % N - j1 tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & tensor % boundary % hostData ( 1 : 3 , 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , tensor % nvar DO j1 = 0 , tensor % N DO i1 = 0 , tensor % N i2 = j1 j2 = tensor % N - i1 tensor % extBoundary % hostData ( 1 : 3 , 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & tensor % boundary % hostData ( 1 : 3 , 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL tensor % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedTensor3D","tags":"","loc":"proc/sideexchange_mappedtensor3d.html"},{"title":"SideExchange_MappedVector2D – SELF","text":"public subroutine SideExchange_MappedVector2D(vector, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type(Mesh2D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel Calls proc~~sideexchange_mappedvector2d~~CallsGraph proc~sideexchange_mappedvector2d SideExchange_MappedVector2D interface~sideexchange_mappedvector2d_gpu_wrapper SideExchange_MappedVector2D_gpu_wrapper proc~sideexchange_mappedvector2d->interface~sideexchange_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SideExchange_MappedVector2D Source Code SUBROUTINE SideExchange_MappedVector2D ( vector , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( Mesh2D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 INTEGER :: flip , bcid , globalSideId INTEGER :: neighborRank INTEGER :: i1 , i2 , ivar IF ( gpuAccel ) THEN CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL SideExchange_MappedVector2D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & mesh % self_sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & vector % N , & vector % nvar , & vector % nElem ) CALL decomp % FinalizeMPIExchangeAsync () ELSE CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 4 globalSideId = mesh % self_sideInfo % hostData ( 2 , s1 , e1 ) e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % self_sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN neighborRank = decomp % elemToRank % hostData ( e2 ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , vector % nvar DO i1 = 0 , vector % N vector % extBoundary % hostData ( 1 : 2 , i1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 2 , i1 , ivar , s2 , e2 ) END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , vector % nvar DO i1 = 0 , vector % N i2 = vector % N - i1 vector % extBoundary % hostData ( 1 : 2 , i1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 2 , i2 , ivar , s2 , e2 ) END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL vector % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedVector2D","tags":"","loc":"proc/sideexchange_mappedvector2d.html"},{"title":"SideExchange_MappedVector3D – SELF","text":"public subroutine SideExchange_MappedVector3D(vector, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type(Mesh3D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel Calls proc~~sideexchange_mappedvector3d~~CallsGraph proc~sideexchange_mappedvector3d SideExchange_MappedVector3D interface~sideexchange_mappedvector3d_gpu_wrapper SideExchange_MappedVector3D_gpu_wrapper proc~sideexchange_mappedvector3d->interface~sideexchange_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SideExchange_MappedVector3D Source Code SUBROUTINE SideExchange_MappedVector3D ( vector , mesh , decomp , gpuAccel ) IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( Mesh3D ), INTENT ( in ) :: mesh TYPE ( MPILayer ), INTENT ( inout ) :: decomp LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: e1 , e2 , s1 , s2 INTEGER :: flip , bcid , globalSideId INTEGER :: neighborRank INTEGER :: i1 , i2 , j1 , j2 , ivar IF ( gpuAccel ) THEN CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) CALL SideExchange_MappedVector3D_gpu_wrapper ( vector % extBoundary % deviceData , & vector % boundary % deviceData , & mesh % self_sideInfo % deviceData , & decomp % elemToRank % deviceData , & decomp % rankId , & vector % N , & vector % nvar , & vector % nElem ) CALL decomp % FinalizeMPIExchangeAsync () ELSE CALL vector % MPIExchangeAsync ( decomp , mesh , resetCount = . TRUE .) DO e1 = 1 , mesh % nElem DO s1 = 1 , 6 globalSideId = mesh % self_sideInfo % hostData ( 2 , s1 , e1 ) e2 = mesh % self_sideInfo % hostData ( 3 , s1 , e1 ) s2 = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) / 10 flip = mesh % self_sideInfo % hostData ( 4 , s1 , e1 ) - s2 * 10 bcid = mesh % self_sideInfo % hostData ( 5 , s1 , e1 ) IF ( bcid == 0 ) THEN ! Interior neighborRank = decomp % elemToRank % hostData ( e2 ) IF ( neighborRank == decomp % rankId ) THEN IF ( flip == 0 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % N DO i1 = 0 , vector % N vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i1 , j1 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 1 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % N DO i1 = 0 , vector % N i2 = vector % N - j1 j2 = i1 vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 2 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % N DO i1 = 0 , vector % N i2 = vector % N - i1 j2 = vector % N - j1 vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO ELSEIF ( flip == 3 ) THEN DO ivar = 1 , vector % nvar DO j1 = 0 , vector % N DO i1 = 0 , vector % N i2 = j1 j2 = vector % N - i1 vector % extBoundary % hostData ( 1 : 3 , i1 , j1 , ivar , s1 , e1 ) = & vector % boundary % hostData ( 1 : 3 , i2 , j2 , ivar , s2 , e2 ) END DO END DO END DO END IF END IF END IF END DO END DO CALL decomp % FinalizeMPIExchangeAsync () END IF CALL vector % ApplyFlip ( decomp , mesh , gpuAccel ) END SUBROUTINE SideExchange_MappedVector3D","tags":"","loc":"proc/sideexchange_mappedvector3d.html"},{"title":"ApplyFlip_MappedScalar2D_gpu_wrapper – SELF","text":"interface Called by interface~~applyflip_mappedscalar2d_gpu_wrapper~~CalledByGraph interface~applyflip_mappedscalar2d_gpu_wrapper ApplyFlip_MappedScalar2D_gpu_wrapper proc~applyflip_mappedscalar2d ApplyFlip_MappedScalar2D proc~applyflip_mappedscalar2d->interface~applyflip_mappedscalar2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ApplyFlip_MappedScalar2D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/applyflip_mappedscalar2d_gpu_wrapper.html"},{"title":"ApplyFlip_MappedScalar3D_gpu_wrapper – SELF","text":"interface Called by interface~~applyflip_mappedscalar3d_gpu_wrapper~~CalledByGraph interface~applyflip_mappedscalar3d_gpu_wrapper ApplyFlip_MappedScalar3D_gpu_wrapper proc~applyflip_mappedscalar3d ApplyFlip_MappedScalar3D proc~applyflip_mappedscalar3d->interface~applyflip_mappedscalar3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ApplyFlip_MappedScalar3D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/applyflip_mappedscalar3d_gpu_wrapper.html"},{"title":"ApplyFlip_MappedTensor2D_gpu_wrapper – SELF","text":"interface Called by interface~~applyflip_mappedtensor2d_gpu_wrapper~~CalledByGraph interface~applyflip_mappedtensor2d_gpu_wrapper ApplyFlip_MappedTensor2D_gpu_wrapper proc~applyflip_mappedtensor2d ApplyFlip_MappedTensor2D proc~applyflip_mappedtensor2d->interface~applyflip_mappedtensor2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ApplyFlip_MappedTensor2D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/applyflip_mappedtensor2d_gpu_wrapper.html"},{"title":"ApplyFlip_MappedTensor3D_gpu_wrapper – SELF","text":"interface Called by interface~~applyflip_mappedtensor3d_gpu_wrapper~~CalledByGraph interface~applyflip_mappedtensor3d_gpu_wrapper ApplyFlip_MappedTensor3D_gpu_wrapper proc~applyflip_mappedtensor3d ApplyFlip_MappedTensor3D proc~applyflip_mappedtensor3d->interface~applyflip_mappedtensor3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ApplyFlip_MappedTensor3D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/applyflip_mappedtensor3d_gpu_wrapper.html"},{"title":"ApplyFlip_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~applyflip_mappedvector2d_gpu_wrapper~~CalledByGraph interface~applyflip_mappedvector2d_gpu_wrapper ApplyFlip_MappedVector2D_gpu_wrapper proc~applyflip_mappedvector2d ApplyFlip_MappedVector2D proc~applyflip_mappedvector2d->interface~applyflip_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ApplyFlip_MappedVector2D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/applyflip_mappedvector2d_gpu_wrapper.html"},{"title":"ApplyFlip_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~applyflip_mappedvector3d_gpu_wrapper~~CalledByGraph interface~applyflip_mappedvector3d_gpu_wrapper ApplyFlip_MappedVector3D_gpu_wrapper proc~applyflip_mappedvector3d ApplyFlip_MappedVector3D proc~applyflip_mappedvector3d->interface~applyflip_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ApplyFlip_MappedVector3D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/applyflip_mappedvector3d_gpu_wrapper.html"},{"title":"BassiRebaySides_MappedScalar2D_gpu_wrapper – SELF","text":"interface Called by interface~~bassirebaysides_mappedscalar2d_gpu_wrapper~~CalledByGraph interface~bassirebaysides_mappedscalar2d_gpu_wrapper BassiRebaySides_MappedScalar2D_gpu_wrapper proc~bassirebaysides_mappedscalar2d BassiRebaySides_MappedScalar2D proc~bassirebaysides_mappedscalar2d->interface~bassirebaysides_mappedscalar2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine BassiRebaySides_MappedScalar2D_gpu_wrapper(avgBoundary, boundary, extBoundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: avgBoundary type(c_ptr) :: boundary type(c_ptr) :: extBoundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/bassirebaysides_mappedscalar2d_gpu_wrapper.html"},{"title":"BassiRebaySides_MappedScalar3D_gpu_wrapper – SELF","text":"interface Called by interface~~bassirebaysides_mappedscalar3d_gpu_wrapper~~CalledByGraph interface~bassirebaysides_mappedscalar3d_gpu_wrapper BassiRebaySides_MappedScalar3D_gpu_wrapper proc~bassirebaysides_mappedscalar3d BassiRebaySides_MappedScalar3D proc~bassirebaysides_mappedscalar3d->interface~bassirebaysides_mappedscalar3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine BassiRebaySides_MappedScalar3D_gpu_wrapper(avgBoundary, boundary, extBoundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: avgBoundary type(c_ptr) :: boundary type(c_ptr) :: extBoundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/bassirebaysides_mappedscalar3d_gpu_wrapper.html"},{"title":"BassiRebaySides_MappedTensor2D_gpu_wrapper – SELF","text":"interface Called by interface~~bassirebaysides_mappedtensor2d_gpu_wrapper~~CalledByGraph interface~bassirebaysides_mappedtensor2d_gpu_wrapper BassiRebaySides_MappedTensor2D_gpu_wrapper proc~bassirebaysides_mappedtensor2d BassiRebaySides_MappedTensor2D proc~bassirebaysides_mappedtensor2d->interface~bassirebaysides_mappedtensor2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine BassiRebaySides_MappedTensor2D_gpu_wrapper(extBoundary, boundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/bassirebaysides_mappedtensor2d_gpu_wrapper.html"},{"title":"BassiRebaySides_MappedTensor3D_gpu_wrapper – SELF","text":"interface Called by interface~~bassirebaysides_mappedtensor3d_gpu_wrapper~~CalledByGraph interface~bassirebaysides_mappedtensor3d_gpu_wrapper BassiRebaySides_MappedTensor3D_gpu_wrapper proc~bassirebaysides_mappedtensor3d BassiRebaySides_MappedTensor3D proc~bassirebaysides_mappedtensor3d->interface~bassirebaysides_mappedtensor3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine BassiRebaySides_MappedTensor3D_gpu_wrapper(extBoundary, boundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/bassirebaysides_mappedtensor3d_gpu_wrapper.html"},{"title":"BassiRebaySides_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~bassirebaysides_mappedvector2d_gpu_wrapper~~CalledByGraph interface~bassirebaysides_mappedvector2d_gpu_wrapper BassiRebaySides_MappedVector2D_gpu_wrapper proc~bassirebaysides_mappedvector2d BassiRebaySides_MappedVector2D proc~bassirebaysides_mappedvector2d->interface~bassirebaysides_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine BassiRebaySides_MappedVector2D_gpu_wrapper(extBoundary, boundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/bassirebaysides_mappedvector2d_gpu_wrapper.html"},{"title":"BassiRebaySides_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~bassirebaysides_mappedvector3d_gpu_wrapper~~CalledByGraph interface~bassirebaysides_mappedvector3d_gpu_wrapper BassiRebaySides_MappedVector3D_gpu_wrapper proc~bassirebaysides_mappedvector3d BassiRebaySides_MappedVector3D proc~bassirebaysides_mappedvector3d->interface~bassirebaysides_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine BassiRebaySides_MappedVector3D_gpu_wrapper(extBoundary, boundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/bassirebaysides_mappedvector3d_gpu_wrapper.html"},{"title":"ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantprojectionboundary_mappedvector2d_gpu_wrapper~~CalledByGraph interface~contravariantprojectionboundary_mappedvector2d_gpu_wrapper ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper proc~contravariantprojection_mappedvector2d ContravariantProjection_MappedVector2D proc~contravariantprojection_mappedvector2d->interface~contravariantprojectionboundary_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/contravariantprojectionboundary_mappedvector2d_gpu_wrapper.html"},{"title":"ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantprojectionboundary_mappedvector3d_gpu_wrapper~~CalledByGraph interface~contravariantprojectionboundary_mappedvector3d_gpu_wrapper ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper proc~contravariantprojection_mappedvector3d ContravariantProjection_MappedVector3D proc~contravariantprojection_mappedvector3d->interface~contravariantprojectionboundary_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/contravariantprojectionboundary_mappedvector3d_gpu_wrapper.html"},{"title":"ContravariantProjection_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantprojection_mappedvector2d_gpu_wrapper~~CalledByGraph interface~contravariantprojection_mappedvector2d_gpu_wrapper ContravariantProjection_MappedVector2D_gpu_wrapper proc~contravariantprojection_mappedvector2d ContravariantProjection_MappedVector2D proc~contravariantprojection_mappedvector2d->interface~contravariantprojection_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantProjection_MappedVector2D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/contravariantprojection_mappedvector2d_gpu_wrapper.html"},{"title":"ContravariantProjection_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantprojection_mappedvector3d_gpu_wrapper~~CalledByGraph interface~contravariantprojection_mappedvector3d_gpu_wrapper ContravariantProjection_MappedVector3D_gpu_wrapper proc~contravariantprojection_mappedvector3d ContravariantProjection_MappedVector3D proc~contravariantprojection_mappedvector3d->interface~contravariantprojection_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantProjection_MappedVector3D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/contravariantprojection_mappedvector3d_gpu_wrapper.html"},{"title":"ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantweightboundary_mappedscalar2d_gpu_wrapper~~CalledByGraph interface~contravariantweightboundary_mappedscalar2d_gpu_wrapper ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper proc~contravariantweight_mappedscalar2d ContravariantWeight_MappedScalar2D proc~contravariantweight_mappedscalar2d->interface~contravariantweightboundary_mappedscalar2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/contravariantweightboundary_mappedscalar2d_gpu_wrapper.html"},{"title":"ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantweightboundary_mappedscalar3d_gpu_wrapper~~CalledByGraph interface~contravariantweightboundary_mappedscalar3d_gpu_wrapper ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper proc~contravariantweight_mappedscalar3d ContravariantWeight_MappedScalar3D proc~contravariantweight_mappedscalar3d->interface~contravariantweightboundary_mappedscalar3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/contravariantweightboundary_mappedscalar3d_gpu_wrapper.html"},{"title":"ContravariantWeight_MappedScalar2D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantweight_mappedscalar2d_gpu_wrapper~~CalledByGraph interface~contravariantweight_mappedscalar2d_gpu_wrapper ContravariantWeight_MappedScalar2D_gpu_wrapper proc~contravariantweight_mappedscalar2d ContravariantWeight_MappedScalar2D proc~contravariantweight_mappedscalar2d->interface~contravariantweight_mappedscalar2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantWeight_MappedScalar2D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/contravariantweight_mappedscalar2d_gpu_wrapper.html"},{"title":"ContravariantWeight_MappedScalar3D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantweight_mappedscalar3d_gpu_wrapper~~CalledByGraph interface~contravariantweight_mappedscalar3d_gpu_wrapper ContravariantWeight_MappedScalar3D_gpu_wrapper proc~contravariantweight_mappedscalar3d ContravariantWeight_MappedScalar3D proc~contravariantweight_mappedscalar3d->interface~contravariantweight_mappedscalar3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantWeight_MappedScalar3D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/contravariantweight_mappedscalar3d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedScalar1D_gpu_wrapper – SELF","text":"interface Called by interface~~jacobianweight_mappedscalar1d_gpu_wrapper~~CalledByGraph interface~jacobianweight_mappedscalar1d_gpu_wrapper JacobianWeight_MappedScalar1D_gpu_wrapper proc~jacobianweight_mappedscalar1d JacobianWeight_MappedScalar1D proc~jacobianweight_mappedscalar1d->interface~jacobianweight_mappedscalar1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine JacobianWeight_MappedScalar1D_gpu_wrapper(scalar, dxds, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: dxds integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedscalar1d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedScalar2D_gpu_wrapper – SELF","text":"interface Called by interface~~jacobianweight_mappedscalar2d_gpu_wrapper~~CalledByGraph interface~jacobianweight_mappedscalar2d_gpu_wrapper JacobianWeight_MappedScalar2D_gpu_wrapper proc~jacobianweight_mappedscalar2d JacobianWeight_MappedScalar2D proc~jacobianweight_mappedscalar2d->interface~jacobianweight_mappedscalar2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine JacobianWeight_MappedScalar2D_gpu_wrapper(scalar, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedscalar2d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedScalar3D_gpu_wrapper – SELF","text":"interface Called by interface~~jacobianweight_mappedscalar3d_gpu_wrapper~~CalledByGraph interface~jacobianweight_mappedscalar3d_gpu_wrapper JacobianWeight_MappedScalar3D_gpu_wrapper proc~jacobianweight_mappedscalar3d JacobianWeight_MappedScalar3D proc~jacobianweight_mappedscalar3d->interface~jacobianweight_mappedscalar3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine JacobianWeight_MappedScalar3D_gpu_wrapper(scalar, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedscalar3d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedTensor2D_gpu_wrapper – SELF","text":"interface Called by interface~~jacobianweight_mappedtensor2d_gpu_wrapper~~CalledByGraph interface~jacobianweight_mappedtensor2d_gpu_wrapper JacobianWeight_MappedTensor2D_gpu_wrapper proc~jacobianweight_mappedtensor2d JacobianWeight_MappedTensor2D proc~jacobianweight_mappedtensor2d->interface~jacobianweight_mappedtensor2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine JacobianWeight_MappedTensor2D_gpu_wrapper(tensor, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedtensor2d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedTensor3D_gpu_wrapper – SELF","text":"interface Called by interface~~jacobianweight_mappedtensor3d_gpu_wrapper~~CalledByGraph interface~jacobianweight_mappedtensor3d_gpu_wrapper JacobianWeight_MappedTensor3D_gpu_wrapper proc~jacobianweight_mappedtensor3d JacobianWeight_MappedTensor3D proc~jacobianweight_mappedtensor3d->interface~jacobianweight_mappedtensor3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine JacobianWeight_MappedTensor3D_gpu_wrapper(tensor, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedtensor3d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~jacobianweight_mappedvector2d_gpu_wrapper~~CalledByGraph interface~jacobianweight_mappedvector2d_gpu_wrapper JacobianWeight_MappedVector2D_gpu_wrapper proc~jacobianweight_mappedvector2d JacobianWeight_MappedVector2D proc~jacobianweight_mappedvector2d->interface~jacobianweight_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine JacobianWeight_MappedVector2D_gpu_wrapper(vector, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedvector2d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~jacobianweight_mappedvector3d_gpu_wrapper~~CalledByGraph interface~jacobianweight_mappedvector3d_gpu_wrapper JacobianWeight_MappedVector3D_gpu_wrapper proc~jacobianweight_mappedvector3d JacobianWeight_MappedVector3D proc~jacobianweight_mappedvector3d->interface~jacobianweight_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine JacobianWeight_MappedVector3D_gpu_wrapper(vector, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedvector3d_gpu_wrapper.html"},{"title":"MapToScalarBoundary_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~maptoscalarboundary_mappedvector2d_gpu_wrapper~~CalledByGraph interface~maptoscalarboundary_mappedvector2d_gpu_wrapper MapToScalarBoundary_MappedVector2D_gpu_wrapper proc~maptoscalar_mappedvector2d MapToScalar_MappedVector2D proc~maptoscalar_mappedvector2d->interface~maptoscalarboundary_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToScalarBoundary_MappedVector2D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/maptoscalarboundary_mappedvector2d_gpu_wrapper.html"},{"title":"MapToScalarBoundary_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~maptoscalarboundary_mappedvector3d_gpu_wrapper~~CalledByGraph interface~maptoscalarboundary_mappedvector3d_gpu_wrapper MapToScalarBoundary_MappedVector3D_gpu_wrapper proc~maptoscalar_mappedvector3d MapToScalar_MappedVector3D proc~maptoscalar_mappedvector3d->interface~maptoscalarboundary_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToScalarBoundary_MappedVector3D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/maptoscalarboundary_mappedvector3d_gpu_wrapper.html"},{"title":"MapToScalar_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~maptoscalar_mappedvector2d_gpu_wrapper~~CalledByGraph interface~maptoscalar_mappedvector2d_gpu_wrapper MapToScalar_MappedVector2D_gpu_wrapper proc~maptoscalar_mappedvector2d MapToScalar_MappedVector2D proc~maptoscalar_mappedvector2d->interface~maptoscalar_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToScalar_MappedVector2D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/maptoscalar_mappedvector2d_gpu_wrapper.html"},{"title":"MapToScalar_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~maptoscalar_mappedvector3d_gpu_wrapper~~CalledByGraph interface~maptoscalar_mappedvector3d_gpu_wrapper MapToScalar_MappedVector3D_gpu_wrapper proc~maptoscalar_mappedvector3d MapToScalar_MappedVector3D proc~maptoscalar_mappedvector3d->interface~maptoscalar_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToScalar_MappedVector3D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/maptoscalar_mappedvector3d_gpu_wrapper.html"},{"title":"MapToTensorBoundary_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~maptotensorboundary_mappedvector2d_gpu_wrapper~~CalledByGraph interface~maptotensorboundary_mappedvector2d_gpu_wrapper MapToTensorBoundary_MappedVector2D_gpu_wrapper proc~maptotensor_mappedvector2d MapToTensor_MappedVector2D proc~maptotensor_mappedvector2d->interface~maptotensorboundary_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToTensorBoundary_MappedVector2D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/maptotensorboundary_mappedvector2d_gpu_wrapper.html"},{"title":"MapToTensorBoundary_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~maptotensorboundary_mappedvector3d_gpu_wrapper~~CalledByGraph interface~maptotensorboundary_mappedvector3d_gpu_wrapper MapToTensorBoundary_MappedVector3D_gpu_wrapper proc~maptotensor_mappedvector3d MapToTensor_MappedVector3D proc~maptotensor_mappedvector3d->interface~maptotensorboundary_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToTensorBoundary_MappedVector3D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/maptotensorboundary_mappedvector3d_gpu_wrapper.html"},{"title":"MapToTensor_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~maptotensor_mappedvector2d_gpu_wrapper~~CalledByGraph interface~maptotensor_mappedvector2d_gpu_wrapper MapToTensor_MappedVector2D_gpu_wrapper proc~maptotensor_mappedvector2d MapToTensor_MappedVector2D proc~maptotensor_mappedvector2d->interface~maptotensor_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToTensor_MappedVector2D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/maptotensor_mappedvector2d_gpu_wrapper.html"},{"title":"MapToTensor_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~maptotensor_mappedvector3d_gpu_wrapper~~CalledByGraph interface~maptotensor_mappedvector3d_gpu_wrapper MapToTensor_MappedVector3D_gpu_wrapper proc~maptotensor_mappedvector3d MapToTensor_MappedVector3D proc~maptotensor_mappedvector3d->interface~maptotensor_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToTensor_MappedVector3D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/maptotensor_mappedvector3d_gpu_wrapper.html"},{"title":"SideExchange_MappedScalar2D_gpu_wrapper – SELF","text":"interface Called by interface~~sideexchange_mappedscalar2d_gpu_wrapper~~CalledByGraph interface~sideexchange_mappedscalar2d_gpu_wrapper SideExchange_MappedScalar2D_gpu_wrapper proc~sideexchange_mappedscalar2d SideExchange_MappedScalar2D proc~sideexchange_mappedscalar2d->interface~sideexchange_mappedscalar2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine SideExchange_MappedScalar2D_gpu_wrapper(extBoundary, boundary, self_sideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: self_sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/sideexchange_mappedscalar2d_gpu_wrapper.html"},{"title":"SideExchange_MappedScalar3D_gpu_wrapper – SELF","text":"interface Called by interface~~sideexchange_mappedscalar3d_gpu_wrapper~~CalledByGraph interface~sideexchange_mappedscalar3d_gpu_wrapper SideExchange_MappedScalar3D_gpu_wrapper proc~sideexchange_mappedscalar3d SideExchange_MappedScalar3D proc~sideexchange_mappedscalar3d->interface~sideexchange_mappedscalar3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine SideExchange_MappedScalar3D_gpu_wrapper(extBoundary, boundary, self_sideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: self_sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/sideexchange_mappedscalar3d_gpu_wrapper.html"},{"title":"SideExchange_MappedTensor2D_gpu_wrapper – SELF","text":"interface Called by interface~~sideexchange_mappedtensor2d_gpu_wrapper~~CalledByGraph interface~sideexchange_mappedtensor2d_gpu_wrapper SideExchange_MappedTensor2D_gpu_wrapper proc~sideexchange_mappedtensor2d SideExchange_MappedTensor2D proc~sideexchange_mappedtensor2d->interface~sideexchange_mappedtensor2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine SideExchange_MappedTensor2D_gpu_wrapper(extBoundary, boundary, self_sideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: self_sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/sideexchange_mappedtensor2d_gpu_wrapper.html"},{"title":"SideExchange_MappedTensor3D_gpu_wrapper – SELF","text":"interface Called by interface~~sideexchange_mappedtensor3d_gpu_wrapper~~CalledByGraph interface~sideexchange_mappedtensor3d_gpu_wrapper SideExchange_MappedTensor3D_gpu_wrapper proc~sideexchange_mappedtensor3d SideExchange_MappedTensor3D proc~sideexchange_mappedtensor3d->interface~sideexchange_mappedtensor3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine SideExchange_MappedTensor3D_gpu_wrapper(extBoundary, boundary, self_sideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: self_sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/sideexchange_mappedtensor3d_gpu_wrapper.html"},{"title":"SideExchange_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~sideexchange_mappedvector2d_gpu_wrapper~~CalledByGraph interface~sideexchange_mappedvector2d_gpu_wrapper SideExchange_MappedVector2D_gpu_wrapper proc~sideexchange_mappedvector2d SideExchange_MappedVector2D proc~sideexchange_mappedvector2d->interface~sideexchange_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine SideExchange_MappedVector2D_gpu_wrapper(extBoundary, boundary, self_sideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: self_sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/sideexchange_mappedvector2d_gpu_wrapper.html"},{"title":"SideExchange_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~sideexchange_mappedvector3d_gpu_wrapper~~CalledByGraph interface~sideexchange_mappedvector3d_gpu_wrapper SideExchange_MappedVector3D_gpu_wrapper proc~sideexchange_mappedvector3d SideExchange_MappedVector3D proc~sideexchange_mappedvector3d->interface~sideexchange_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine SideExchange_MappedVector3D_gpu_wrapper(extBoundary, boundary, self_sideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: self_sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/sideexchange_mappedvector3d_gpu_wrapper.html"},{"title":"ForwardStep_Advection2D – SELF","text":"public subroutine ForwardStep_Advection2D(this, endTime) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this real(kind=prec), intent(in) :: endTime Contents Source Code ForwardStep_Advection2D Source Code SUBROUTINE ForwardStep_Advection2D ( this , endTime ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this REAL ( prec ), INTENT ( in ) :: endTime ! Local INTEGER :: nSteps REAL ( prec ) :: dt IF ( this % integrator == RK3 ) THEN ! Step forward dt = this % dt nSteps = INT (( endTime - this % simulationTime ) / dt ) CALL this % TimeStepRK3 ( nSteps ) ! Take any additional steps to reach desired endTime this % dt = endTime - this % simulationTime IF ( this % dt > 0 ) THEN nSteps = 1 CALL this % TimeStepRK3 ( nSteps ) ENDIF ! Reset the time step this % dt = dt ENDIF END SUBROUTINE ForwardStep_Advection2D","tags":"","loc":"proc/forwardstep_advection2d.html"},{"title":"Free_Advection2D – SELF","text":"public subroutine Free_Advection2D(this) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this Contents Source Code Free_Advection2D Source Code SUBROUTINE Free_Advection2D ( this ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this CALL this % mesh % Free () CALL this % geometry % Free () CALL this % solution % Free () CALL this % dSdt % Free () CALL this % plotSolution % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () CALL this % workScalar % Free () CALL this % workVector % Free () CALL this % workTensor % Free () CALL this % compFlux % Free () CALL this % velocity % Free () CALL this % plotVelocity % Free () CALL this % plotX % Free () DEALLOCATE ( this % solutionMetaData ) DEALLOCATE ( this % boundaryConditionEqn ) DEALLOCATE ( this % solutionEqn ) DEALLOCATE ( this % sourceEqn ) END SUBROUTINE Free_Advection2D","tags":"","loc":"proc/free_advection2d.html"},{"title":"GetCLIParameters – SELF","text":"private subroutine GetCLIParameters(cli) Arguments Type Intent Optional Attributes Name type(COMMAND_LINE_INTERFACE), intent(inout) :: cli Called by proc~~getcliparameters~2~~CalledByGraph proc~getcliparameters~2 GetCLIParameters proc~initfromcli_advection2d InitFromCLI_Advection2D proc~initfromcli_advection2d->proc~getcliparameters~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code GetCLIParameters Source Code SUBROUTINE GetCLIParameters ( cli ) TYPE ( COMMAND_LINE_INTERFACE ), INTENT ( inout ) :: cli CALL cli % init ( progname = \"sadv2d\" , & version = \"v0.0.0\" , & description = \"SELF Advection in 2-D\" , & license = \"ANTI-CAPITALIST SOFTWARE LICENSE (v 1.4)\" , & authors = \"Joseph Schoonover (Fluid Numerics LLC)\" ) CALL cli % add ( switch = \"--mpi\" , & help = \"Enable MPI\" , & act = \"store_true\" , & def = \"false\" , & required = . FALSE .) CALL cli % add ( switch = \"--gpu\" , & help = \"Enable GPU acceleration\" , & act = \"store_true\" , & def = \"false\" , & required = . FALSE .) CALL cli % add ( switch = \"--time-step\" , & switch_ab = \"-dt\" , & help = \"The time step size for the time integrator\" , & def = \"0.001\" , & required = . FALSE .) CALL cli % add ( switch = \"--initial-time\" , & switch_ab = \"-t0\" , & help = \"The initial time level\" , & def = \"0.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--output-interval\" , & switch_ab = \"-oi\" , & help = \"The time between file output\" , & def = \"0.5\" , & required = . FALSE .) CALL cli % add ( switch = \"--end-time\" , & switch_ab = \"-tn\" , & help = \"The final time level\" , & def = \"1.0\" , & required = . FALSE .) ! Get the control degree CALL cli % add ( switch = \"--control-degree\" , & switch_ab = \"-c\" , & help = \"The polynomial degree of the control points.\" // NEW_LINE ( \"A\" ), & def = \"7\" , & required = . FALSE .) ! Get the target degree (assumed for plotting) CALL cli % add ( switch = \"--target-degree\" , & switch_ab = \"-t\" , & help = \"The polynomial degree for the\" // & & \" target points for interpolation.\" // & & \" Typically used for plotting\" // NEW_LINE ( \"A\" ), & def = \"14\" , & required = . FALSE .) ! Get the control quadrature ! Everyone know Legendre-Gauss Quadrature is the best... CALL cli % add ( switch = \"--control-quadrature\" , & switch_ab = \"-cq\" , & def = \"gauss\" , & help = \"The quadrature type for control points.\" // NEW_LINE ( \"A\" ), & choices = \"gauss,gauss-lobatto,chebyshev-gauss,chebyshev-gauss-lobatto\" , & required = . FALSE .) ! Set the target grid quadrature ! Default to uniform (assumed for plotting) CALL cli % add ( switch = \"--target-quadrature\" , & switch_ab = \"-tq\" , & def = \"uniform\" , & help = \"The quadrature type for target points.\" // NEW_LINE ( \"A\" ), & choices = \"gauss,gauss-lobatto,uniform\" , & required = . FALSE .) ! (Optional) Provide a file for a mesh ! Assumed in HOPR or ISM-v2 format CALL cli % add ( switch = \"--mesh\" , & switch_ab = \"-m\" , & help = \"Path to a mesh file for control mesh.\" // NEW_LINE ( \"A\" ), & def = \"\" , & required = . FALSE .) ! (Optional) If a mesh is not provided, you ! can request a structured grid to be generated ! just set the nxelement, nyelements.. CALL cli % add ( switch = \"--nxelements\" , & switch_ab = \"-nx\" , & help = \"The number of elements in the x-direction for structured mesh generation.\" , & def = \"5\" , & required = . FALSE .) CALL cli % add ( switch = \"--nyelements\" , & switch_ab = \"-ny\" , & help = \"The number of elements in the y-direction for structured mesh generation.\" , & def = \"5\" , & required = . FALSE .) ! Alright... now tell me some physical mesh dimensions CALL cli % add ( switch = \"--xlength\" , & switch_ab = \"-lx\" , & help = \"The physical x-scale for structured mesh generation.\" // & \" Ignored if a mesh file is provided\" , & def = \"1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--ylength\" , & switch_ab = \"-ly\" , & help = \"The physical y-scale for structured mesh generation.\" // & \" Ignored if a mesh file is provided\" , & def = \"1.0\" , & required = . FALSE .) ! Set the velocity field CALL cli % add ( switch = \"--velocity-x\" , & switch_ab = \"-vx\" , & help = \"Equation for the x-component of the velocity field (x,y dependent only!)\" ,& def = \"vx=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--velocity-y\" , & switch_ab = \"-vy\" , & help = \"Equation for the y-component of the velocity field (x,y dependent only!)\" ,& def = \"vy=1.0\" , & required = . FALSE .) ! Tracer diffusivity CALL cli % add ( switch = \"--diffusivity\" , & switch_ab = \"-nu\" , & help = \"Tracer diffusivity (applied to all tracers)\" , & def = \"0.0\" , & required = . FALSE .) ! Set the initial conditions ! .. TO DO .. !  > How to handle multiple tracer fields ?? CALL cli % add ( switch = \"--initial-condition\" , & switch_ab = \"-ic\" , & help = \"Equation for the initial tracer distributions\" ,& def = \"f = exp( -( ((x-t)-0.5)&#94;2 + ((y-t)-0.5)&#94;2)/0.01 )\" , & required = . FALSE .) CALL cli % add ( switch = \"--boundary-condition\" , & switch_ab = \"-bc\" , & help = \"Equation for the boundary tracer distributions (can be time dependent!)\" , & def = \"f = exp( -( ((x-t)-0.5)&#94;2 + ((y-t)-0.5)&#94;2)/0.01 )\" , & required = . FALSE .) CALL cli % add ( switch = \"--source\" , & switch_ab = \"-s\" , & help = \"Equation for the source term (can be time dependent!)\" , & def = \"s = 0.0\" , & required = . FALSE .) ! Give me a time integrator CALL cli % add ( switch = \"--integrator\" , & switch_ab = \"-int\" , & help = \"Sets the time integration method. Only 'euler' or 'williamson_rk3'\" , & def = \"williamson_rk3\" , & required = . FALSE .) END SUBROUTINE GetCLIParameters","tags":"","loc":"proc/getcliparameters~2.html"},{"title":"InitFromCLI_Advection2D – SELF","text":"public subroutine InitFromCLI_Advection2D(this) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this Calls proc~~initfromcli_advection2d~~CallsGraph proc~initfromcli_advection2d InitFromCLI_Advection2D equationparser equationparser proc~initfromcli_advection2d->equationparser proc~getcliparameters~2 GetCLIParameters proc~initfromcli_advection2d->proc~getcliparameters~2 uppercase uppercase proc~initfromcli_advection2d->uppercase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code InitFromCLI_Advection2D Source Code SUBROUTINE InitFromCLI_Advection2D ( this ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this ! Local TYPE ( COMMAND_LINE_INTERFACE ) :: cli TYPE ( MeshSpec ) :: spec CHARACTER ( self_QuadratureTypeCharLength ) :: cqTypeChar CHARACTER ( self_QuadratureTypeCharLength ) :: tqTypeChar CHARACTER ( self_IntegratorTypeCharLength ) :: integratorChar REAL ( prec ) :: Lx , Ly ! Domain lengths REAL ( prec ) :: dt ! Default time step size REAL ( prec ) :: diffusivity INTEGER :: controlDegree INTEGER :: targetDegree INTEGER :: controlQuadrature ! ENUMS in SELF_Constants.f90 INTEGER :: targetQuadrature ! ENUMS in SELF_Constants.f90 CHARACTER ( LEN = self_FileNameLength ) :: meshFile INTEGER :: nxElements INTEGER :: nyElements INTEGER :: integrator ! ENUMS needed in SELF_Constants.f90 !! TO DO !! CHARACTER ( LEN = self_EquationLength ) :: velEqnX ! Velocity Equation (x-direction) CHARACTER ( LEN = self_EquationLength ) :: velEqnY ! Velocity Equation (y-direction) CHARACTER ( LEN = self_EquationLength ) :: icEqn ! Initial condition Equation CHARACTER ( LEN = self_EquationLength ) :: bcEqn ! Boundary condition Equation CHARACTER ( LEN = self_EquationLength ) :: sourceEqn ! Boundary condition Equation LOGICAL :: enableMPI LOGICAL :: enableGPU LOGICAL :: diffusiveFlux REAL ( prec ) :: outputInterval REAL ( prec ) :: initialTime REAL ( prec ) :: endTime TYPE ( EquationParser ) :: eqn ( 1 ) TYPE ( EquationParser ) :: velEqn ( 1 : 2 ) ! Get the CLI parameters ! CALL GetCLIParameters ( cli ) ! Set the CLI parameters ! CALL cli % get ( val = enableMPI , switch = '--mpi' ) CALL cli % get ( val = enableGPU , switch = '--gpu' ) CALL cli % get ( val = meshfile , switch = '--mesh' ) CALL cli % get ( val = dt , switch = \"--time-step\" ) CALL cli % get ( val = outputInterval , switch = \"--output-interval\" ) CALL cli % get ( val = initialTime , switch = \"--initial-time\" ) CALL cli % get ( val = endTime , switch = \"--end-time\" ) CALL cli % get ( val = controlDegree , switch = \"--control-degree\" ) CALL cli % get ( val = targetDegree , switch = \"--target-degree\" ) CALL cli % get ( val = cqTypeChar , switch = \"--control-quadrature\" ) CALL cli % get ( val = tqTypeChar , switch = \"--target-quadrature\" ) CALL cli % get ( val = meshFile , switch = \"--mesh\" ) CALL cli % get ( val = nxElements , switch = \"--nxelements\" ) CALL cli % get ( val = nyElements , switch = \"--nyelements\" ) CALL cli % get ( val = Lx , switch = \"--xlength\" ) CALL cli % get ( val = Ly , switch = \"--ylength\" ) CALL cli % get ( val = velEqnX , switch = \"--velocity-x\" ) CALL cli % get ( val = velEqnY , switch = \"--velocity-y\" ) CALL cli % get ( val = icEqn , switch = \"--initial-condition\" ) CALL cli % get ( val = bcEqn , switch = \"--boundary-condition\" ) CALL cli % get ( val = sourceEqn , switch = \"--source\" ) CALL cli % get ( val = integratorChar , switch = \"--integrator\" ) CALL cli % get ( val = diffusivity , switch = \"--diffusivity\" ) diffusiveFlux = . TRUE . IF ( diffusivity == 0.0_prec ) THEN diffusiveFlux = . FALSE . ELSEIF ( diffusivity < 0.0_prec ) THEN IF ( dt > 0.0_prec ) THEN PRINT * , 'Negative diffusivity provably unstable for forward stepping' PRINT * , 'Invalid diffusivity value. Stopping' STOP ENDIF ENDIF IF ( TRIM ( UpperCase ( cqTypeChar )) == 'GAUSS' ) THEN controlQuadrature = GAUSS ELSEIF ( TRIM ( UpperCase ( cqTypeChar )) == 'GAUSS-LOBATTO' ) THEN controlQuadrature = GAUSS_LOBATTO ELSEIF ( TRIM ( UpperCase ( cqTypeChar )) == 'CHEBYSHEV-GAUSS' ) THEN controlQuadrature = CHEBYSHEV_GAUSS ELSEIF ( TRIM ( UpperCase ( cqTypeChar )) == 'CHEBYSHEV-GAUSS-LOBATTO' ) THEN controlQuadrature = CHEBYSHEV_GAUSS_LOBATTO ELSE PRINT * , 'Invalid Control Quadrature' STOP - 1 END IF IF ( TRIM ( UpperCase ( tqTypeChar )) == 'UNIFORM' ) THEN targetQuadrature = UNIFORM ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'GAUSS' ) THEN targetQuadrature = GAUSS ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'GAUSS-LOBATTO' ) THEN targetQuadrature = GAUSS_LOBATTO ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'CHEBYSHEV-GAUSS' ) THEN targetQuadrature = CHEBYSHEV_GAUSS ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'CHEBYSHEV-GAUSS-LOBATTO' ) THEN targetQuadrature = CHEBYSHEV_GAUSS_LOBATTO ELSE PRINT * , 'Invalid Target Quadrature' STOP - 1 END IF IF ( TRIM ( UpperCase ( integratorChar )) == 'EULER' ) THEN integrator = EULER ELSEIF ( TRIM ( UpperCase ( integratorChar )) == 'WILLIAMSON_RK3' ) THEN integrator = RK3 ELSE PRINT * , 'Invalid time integrator' STOP - 1 END IF IF ( TRIM ( meshfile ) == \"\" ) THEN spec % blockMesh = . TRUE . ELSE spec % blockMesh = . FALSE . ENDIF spec % filename = meshfile spec % filetype = SELF_MESH_ISM_V2_2D spec % blockMesh_nGeo = 1 spec % blockMesh_x0 = 0.0_prec spec % blockMesh_x1 = Lx spec % blockMesh_y0 = 0.0_prec spec % blockMesh_y1 = Ly spec % blockMesh_z0 = 0.0_prec spec % blockMesh_z1 = 0.0_prec spec % blockMesh_nElemX = nxElements spec % blockMesh_nElemY = nyElements spec % blockMesh_nElemZ = 0 ! 2-D mesh ! CALL this % Init ( controlQuadrature , & targetQuadrature , & controlDegree , & targetDegree , & 1 , enableMPI , & spec ) this % simulationTime = 0.0_prec this % Lx = Lx this % Ly = Ly ! Domain lengths this % dt = dt ! Default time step size this % initialTime = initialTime this % simulationTime = initialTime this % endTime = endTime this % outputInterval = outputInterval this % controlDegree = controlDegree this % targetDegree = targetDegree this % controlQuadrature = controlQuadrature ! ENUMS in SELF_Constants.f90 this % targetQuadrature = targetQuadrature ! ENUMS in SELF_Constants.f90 this % meshFile = meshFile this % nxElements = nxElements this % nyElements = nyElements this % integrator = integrator ! ENUMS needed in SELF_Constants.f90 !! TO DO !! this % velEqnX = velEqnX ! Velocity Equation (x-direction) this % velEqnY = velEqnY ! Velocity Equation (y-direction) this % icEqn = icEqn ! Initial condition Equation this % bcEqn = bcEqn ! Boundary condition Equation this % enableMPI = enableMPI this % gpuAccel = enableGPU this % diffusivity = diffusivity this % diffusiveFlux = diffusiveFlux eqn ( 1 ) = EquationParser ( icEqn , ( / 'x' , 'y' , 't' / )) CALL this % SetSolution ( eqn ) this % solutionEqn ( 1 ) = EquationParser ( icEqn , ( / 'x' , 'y' , 't' / )) velEqn ( 1 ) = EquationParser ( velEqnX , ( / 'x' , 'y' / )) velEqn ( 2 ) = EquationParser ( velEqnY , ( / 'x' , 'y' / )) CALL this % SetVelocity ( velEqn ) this % boundaryConditionEqn ( 1 ) = EquationParser ( bcEqn , ( / 'x' , 'y' , 't' / )) CALL this % SetBoundaryCondition ( this % boundaryConditionEqn ) this % sourceEqn ( 1 ) = EquationParser ( sourceEqn , ( / 'x' , 'y' , 't' / )) END SUBROUTINE InitFromCLI_Advection2D","tags":"","loc":"proc/initfromcli_advection2d.html"},{"title":"Init_Advection2D – SELF","text":"public subroutine Init_Advection2D(this, cqType, tqType, cqDegree, tqDegree, nvar, enableMPI, spec) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(out) :: this integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nvar logical, intent(in) :: enableMPI type(MeshSpec), intent(in) :: spec Contents Source Code Init_Advection2D Source Code SUBROUTINE Init_Advection2D ( this , cqType , tqType , cqDegree , tqDegree , nvar , enableMPI , spec ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nvar LOGICAL , INTENT ( in ) :: enableMPI TYPE ( MeshSpec ), INTENT ( in ) :: spec CALL this % decomp % Init ( enableMPI ) ! Load Mesh IF ( enableMPI ) THEN CALL this % mesh % Load ( spec , this % decomp ) ELSE CALL this % mesh % Load ( spec ) ENDIF CALL this % decomp % SetMaxMsg ( this % mesh % nUniqueSides ) CALL this % decomp % setElemToRank ( this % mesh % nElem ) ! Create geometry from mesh CALL this % geometry % GenerateFromMesh (& this % mesh , cqType , tqType , cqDegree , tqDegree ) CALL this % plotSolution % Init (& tqDegree , tqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % dSdt % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % solution % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % solutionGradient % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % flux % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % velocity % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % plotVelocity % Init (& tqDegree , tqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % plotX % Init (& tqDegree , tqType , tqDegree , tqType , 1 ,& this % mesh % nElem ) CALL this % source % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % fluxDivergence % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % workScalar % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % workVector % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % workTensor % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) CALL this % compFlux % Init (& cqDegree , cqType , tqDegree , tqType , nVar ,& this % mesh % nElem ) ALLOCATE ( this % solutionMetaData ( 1 : nvar )) ALLOCATE ( this % boundaryConditionEqn ( 1 : nvar )) ALLOCATE ( this % solutionEqn ( 1 : nvar )) ALLOCATE ( this % sourceEqn ( 1 : nvar )) END SUBROUTINE Init_Advection2D","tags":"","loc":"proc/init_advection2d.html"},{"title":"InternalFlux_Advection2D – SELF","text":"public subroutine InternalFlux_Advection2D(this) Calculates the advective flux using the provided velocity Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this Calls proc~~internalflux_advection2d~~CallsGraph proc~internalflux_advection2d InternalFlux_Advection2D interface~internalflux_advection2d_gpu_wrapper InternalFlux_Advection2D_gpu_wrapper proc~internalflux_advection2d->interface~internalflux_advection2d_gpu_wrapper interface~internaldiffusiveflux_advection2d_gpu_wrapper InternalDiffusiveFlux_Advection2D_gpu_wrapper proc~internalflux_advection2d->interface~internaldiffusiveflux_advection2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code InternalFlux_Advection2D Source Code SUBROUTINE InternalFlux_Advection2D ( this ) !! Calculates the advective flux using the provided velocity IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this ! Local INTEGER :: i , j , iVar , iEl REAL ( prec ) :: Fx , Fy IF ( this % gpuAccel ) THEN ! When GPU acceleration is enabled (requested by the user) ! we call the gpu wrapper interface, which will call the ! HIP kernel \"under the hood\" ! ! TO DO : Pass the contravariant basis vector to GPU kernel CALL InternalFlux_Advection2D_gpu_wrapper ( this % flux % interior % deviceData ,& this % solution % interior % deviceData , & this % velocity % interior % deviceData , & this % geometry % dsdx % interior % deviceData , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) IF ( this % diffusiveFlux ) THEN CALL InternalDiffusiveFlux_Advection2D_gpu_wrapper ( this % flux % interior % deviceData ,& this % solutionGradient % interior % deviceData , & this % geometry % dsdx % interior % deviceData , & this % diffusivity , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ENDIF ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % N DO i = 0 , this % solution % N Fx = this % velocity % interior % hostData ( 1 , i , j , 1 , iEl ) * & this % solution % interior % hostData ( i , j , iVar , iEl ) Fy = this % velocity % interior % hostData ( 2 , i , j , 1 , iEl ) * & this % solution % interior % hostData ( i , j , iVar , iEl ) this % flux % interior % hostData ( 1 , i , j , iVar , iEl ) = & this % geometry % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iel ) * Fy this % flux % interior % hostData ( 2 , i , j , iVar , iEl ) = & this % geometry % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iel ) * Fx + & this % geometry % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iel ) * Fy ENDDO ENDDO ENDDO ENDDO ! When diffusivity == 0, then we don't bother calculating the diffusive flux IF ( this % diffusiveFlux ) THEN ! Otherwise, we add the diffusive flux to to the flux vector DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Diffusive flux is diffusivity coefficient mulitplied by ! solution gradient Fx = this % solutionGradient % interior % hostData ( 1 , i , j , iVar , iEl ) * & this % diffusivity Fy = this % solutionGradient % interior % hostData ( 2 , i , j , iVar , iEl ) * & this % diffusivity ! Project the diffusive flux vector onto computational coordinates this % flux % interior % hostData ( 1 , i , j , iVar , iEl ) = & this % flux % interior % hostData ( 1 , i , j , iVar , iEl ) - & this % geometry % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iel ) * Fx - & this % geometry % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iel ) * Fy this % flux % interior % hostData ( 2 , i , j , iVar , iEl ) = & this % flux % interior % hostData ( 2 , i , j , iVar , iEl ) - & this % geometry % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iel ) * Fx - & this % geometry % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iel ) * Fy ENDDO ENDDO ENDDO ENDDO ENDIF ! DiffusiveFlux ENDIF ! GPU Acceleration END SUBROUTINE InternalFlux_Advection2D","tags":"","loc":"proc/internalflux_advection2d.html"},{"title":"SetBoundaryConditionFromEquation_Advection2D – SELF","text":"public subroutine SetBoundaryConditionFromEquation_Advection2D(this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) Contents Source Code SetBoundaryConditionFromEquation_Advection2D Source Code SUBROUTINE SetBoundaryConditionFromEquation_Advection2D ( this , eqn ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: i , iEl , iVar , iSide REAL ( prec ) :: x REAL ( prec ) :: y DO iEl = 1 , this % solution % nElem DO iSide = 1 , 4 DO iVar = 1 , this % solution % nvar DO i = 0 , this % solution % N ! If this element's side has no neighbor assigned ! it is assumed to be a physical boundary. ! In this case, we want to assign the external boundary ! condition. IF ( this % mesh % self_sideInfo % hostData ( 3 , iSide , iEl ) == 0 ) THEN ! Get the mesh positions x = this % geometry % x % boundary % hostData ( 1 , i , 1 , iSide , iEl ) y = this % geometry % x % boundary % hostData ( 2 , i , 1 , iSide , iEl ) ! Set the external boundary condition this % solution % extBoundary % hostData ( i , iVar , iSide , iEl ) = & eqn ( iVar ) % Evaluate (( / x , y , this % simulationTime / )) ENDIF ENDDO ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN ! Copy data to the GPU CALL this % solution % extBoundary % UpdateDevice () ENDIF END SUBROUTINE SetBoundaryConditionFromEquation_Advection2D","tags":"","loc":"proc/setboundaryconditionfromequation_advection2d.html"},{"title":"SetSolutionFromEquation_Advection2D – SELF","text":"public subroutine SetSolutionFromEquation_Advection2D(this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) Contents Source Code SetSolutionFromEquation_Advection2D Source Code SUBROUTINE SetSolutionFromEquation_Advection2D ( this , eqn ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: i , j , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: t DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Get the mesh positions x = this % geometry % x % interior % hostData ( 1 , i , j , 1 , iEl ) y = this % geometry % x % interior % hostData ( 2 , i , j , 1 , iEl ) t = this % simulationTime this % solution % interior % hostData ( i , j , iVar , iEl ) = & eqn ( iVar ) % Evaluate (( / x , y , t / )) ENDDO ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN CALL this % solution % interior % UpdateDevice () ENDIF END SUBROUTINE SetSolutionFromEquation_Advection2D","tags":"","loc":"proc/setsolutionfromequation_advection2d.html"},{"title":"SetSourceFromEquation_Advection2D – SELF","text":"public subroutine SetSourceFromEquation_Advection2D(this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) Contents Source Code SetSourceFromEquation_Advection2D Source Code SUBROUTINE SetSourceFromEquation_Advection2D ( this , eqn ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : this % solution % nVar ) ! Local INTEGER :: i , j , iEl , iVar REAL ( prec ) :: x REAL ( prec ) :: y REAL ( prec ) :: t DO iEl = 1 , this % source % nElem DO iVar = 1 , this % source % nVar DO j = 0 , this % source % N DO i = 0 , this % source % N ! Get the mesh positions x = this % geometry % x % interior % hostData ( 1 , i , j , 1 , iEl ) y = this % geometry % x % interior % hostData ( 2 , i , j , 1 , iEl ) t = this % simulationTime this % source % interior % hostData ( i , j , iVar , iEl ) = & eqn ( iVar ) % Evaluate (( / x , y , t / )) ENDDO ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN CALL this % source % interior % UpdateDevice () ENDIF END SUBROUTINE SetSourceFromEquation_Advection2D","tags":"","loc":"proc/setsourcefromequation_advection2d.html"},{"title":"SetVelocityFromEquation_Advection2D – SELF","text":"public subroutine SetVelocityFromEquation_Advection2D(this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:2) Contents Source Code SetVelocityFromEquation_Advection2D Source Code SUBROUTINE SetVelocityFromEquation_Advection2D ( this , eqn ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this TYPE ( EquationParser ), INTENT ( in ) :: eqn ( 1 : 2 ) ! Local INTEGER :: i , j , iEl , iVar , iSide REAL ( prec ) :: x REAL ( prec ) :: y DO iEl = 1 , this % solution % nElem ! Set the velocity at the element interiors DO j = 0 , this % solution % N DO i = 0 , this % solution % N ! Get the mesh positions x = this % geometry % x % interior % hostData ( 1 , i , j , 1 , iEl ) y = this % geometry % x % interior % hostData ( 2 , i , j , 1 , iEl ) ! Set the velocity in the x-direction this % velocity % interior % hostData ( 1 , i , j , 1 , iEl ) = & eqn ( 1 ) % Evaluate (( / x , y / )) ! Set the velocity in the y-direction this % velocity % interior % hostData ( 2 , i , j , 1 , iEl ) = & eqn ( 2 ) % Evaluate (( / x , y / )) ENDDO ENDDO ! Set the velocity at element edges DO iSide = 1 , 4 DO i = 0 , this % solution % N ! Get the mesh positions x = this % geometry % x % boundary % hostData ( 1 , i , 1 , iSide , iEl ) y = this % geometry % x % boundary % hostData ( 2 , i , 1 , iSide , iEl ) ! Set the velocity in the x-direction this % velocity % boundary % hostData ( 1 , i , 1 , iSide , iEl ) = & eqn ( 1 ) % Evaluate (( / x , y / )) ! Set the velocity in the y-direction this % velocity % boundary % hostData ( 2 , i , 1 , iSide , iEl ) = & eqn ( 2 ) % Evaluate (( / x , y / )) ENDDO ENDDO ENDDO IF ( this % gpuAccel ) THEN CALL this % velocity % interior % UpdateDevice () CALL this % velocity % boundary % UpdateDevice () ENDIF END SUBROUTINE SetVelocityFromEquation_Advection2D","tags":"","loc":"proc/setvelocityfromequation_advection2d.html"},{"title":"SideFlux_Advection2D – SELF","text":"public subroutine SideFlux_Advection2D(this) Calculates the Advective Flux on element sides using a Lax-Friedrich's upwind Riemann Solver Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this Calls proc~~sideflux_advection2d~~CallsGraph proc~sideflux_advection2d SideFlux_Advection2D interface~sidediffusiveflux_advection2d_gpu_wrapper SideDiffusiveFlux_Advection2D_gpu_wrapper proc~sideflux_advection2d->interface~sidediffusiveflux_advection2d_gpu_wrapper interface~sideflux_advection2d_gpu_wrapper SideFlux_Advection2D_gpu_wrapper proc~sideflux_advection2d->interface~sideflux_advection2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SideFlux_Advection2D Source Code SUBROUTINE SideFlux_Advection2D ( this ) !! Calculates the Advective Flux on element sides using a Lax-Friedrich's upwind Riemann Solver IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this ! Local INTEGER :: i , iSide , iVar , iEl REAL ( prec ) :: nhat ( 1 : 2 ) REAL ( prec ) :: nmag REAL ( prec ) :: un REAL ( prec ) :: extState REAL ( prec ) :: intState IF ( this % gpuAccel ) THEN CALL SideFlux_Advection2D_gpu_wrapper ( this % flux % boundaryNormal % deviceData , & this % solution % boundary % deviceData , & this % solution % extBoundary % deviceData , & this % velocity % boundary % deviceData , & this % geometry % nHat % boundary % deviceData , & this % geometry % nScale % boundary % deviceData , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) IF ( this % diffusiveFlux ) THEN CALL SideDiffusiveFlux_Advection2D_gpu_wrapper ( this % flux % boundaryNormal % deviceData , & this % solutionGradient % boundary % deviceData , & this % solutionGradient % extBoundary % deviceData , & this % geometry % nHat % boundary % deviceData , & this % geometry % nScale % boundary % deviceData , & this % diffusivity , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ENDIF ELSE DO iEl = 1 , this % solution % nElem DO iSide = 1 , 4 DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % N ! Get the boundary normals on cell edges from the mesh geometry nhat ( 1 : 2 ) = this % geometry % nHat % boundary % hostData ( 1 : 2 , i , 1 , iSide , iEl ) ! Calculate the normal velocity at the cell edges un = this % velocity % boundary % hostData ( 1 , i , 1 , iSide , iEl ) * nHat ( 1 ) + & this % velocity % boundary % hostData ( 2 , i , 1 , iSide , iEl ) * nHat ( 2 ) ! Pull external and internal state for the Riemann Solver (Lax-Friedrichs) extState = this % solution % extBoundary % hostData ( i , iVar , iSide , iEl ) intState = this % solution % boundary % hostData ( i , iVar , iSide , iEl ) nmag = this % geometry % nScale % boundary % hostData ( i , 1 , iSide , iEl ) ! Calculate the flux this % flux % boundaryNormal % hostData ( i , iVar , iSide , iEl ) = 0.5_prec * & ( un * ( intState + extState ) - abs ( un ) * ( extState - intState ) ) * nmag ENDDO ENDDO ENDDO ENDDO IF ( this % diffusiveFlux ) THEN DO iEl = 1 , this % solution % nElem DO iSide = 1 , 4 DO iVar = 1 , this % solution % nVar DO i = 0 , this % solution % N nhat ( 1 : 2 ) = this % geometry % nHat % boundary % hostData ( 1 : 2 , i , 1 , iSide , iEl ) nmag = this % geometry % nScale % boundary % hostData ( i , 1 , iSide , iEl ) !  Calculate \\nabla{f} \\cdot \\hat{n} on the cell sides extState = this % solutionGradient % extBoundary % hostData ( 1 , i , iVar , iSide , iEl ) * nHat ( 1 ) + & this % solutionGradient % extBoundary % hostData ( 2 , i , iVar , iSide , iEl ) * nHat ( 2 ) intState = this % solutionGradient % boundary % hostData ( 1 , i , iVar , iSide , iEl ) * nHat ( 1 ) + & this % solutionGradient % boundary % hostData ( 2 , i , iVar , iSide , iEl ) * nHat ( 2 ) ! Bassi-Rebay flux is the average of the internal and external diffusive flux vectors. this % flux % boundaryNormal % hostData ( i , iVar , iSide , iEl ) = & this % flux % boundaryNormal % hostData ( i , iVar , iSide , iEl ) - & 0.5_prec * this % diffusivity * ( extState + intState ) * nmag ENDDO ENDDO ENDDO ENDDO ENDIF ! Diffusivity ENDIF ! GPU Acceleration END SUBROUTINE SideFlux_Advection2D","tags":"","loc":"proc/sideflux_advection2d.html"},{"title":"Tendency_Advection2D – SELF","text":"public subroutine Tendency_Advection2D(this) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this Contents Source Code Tendency_Advection2D Source Code SUBROUTINE Tendency_Advection2D ( this ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this CALL this % solution % BoundaryInterp ( this % gpuAccel ) IF ( this % diffusiveFlux ) THEN CALL this % CalculateSolutionGradient ( this % gpuAccel ) ENDIF ! Internal Flux calculates both the advective and diffusive flux -- need diffusivity CALL this % InternalFlux ( ) ! Exchange side information between neighboring cells CALL this % solution % SideExchange ( this % mesh , & this % decomp , & this % gpuAccel ) IF ( this % diffusiveFlux ) THEN CALL this % solutionGradient % SideExchange ( this % mesh , & this % decomp , & this % gpuAccel ) ENDIF CALL this % SideFlux ( ) CALL this % CalculateFluxDivergence ( this % gpuAccel ) CALL this % CalculatedSdt ( this % gpuAccel ) END SUBROUTINE Tendency_Advection2D","tags":"","loc":"proc/tendency_advection2d.html"},{"title":"TimeStepRK3_Advection2D – SELF","text":"public subroutine TimeStepRK3_Advection2D(this, nSteps) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this integer, intent(in) :: nSteps Calls proc~~timesteprk3_advection2d~~CallsGraph proc~timesteprk3_advection2d TimeStepRK3_Advection2D interface~updategrk3_advection2d_gpu_wrapper UpdateGRK3_Advection2D_gpu_wrapper proc~timesteprk3_advection2d->interface~updategrk3_advection2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TimeStepRK3_Advection2D Source Code SUBROUTINE TimeStepRK3_Advection2D ( this , nSteps ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: this INTEGER , INTENT ( in ) :: nSteps ! Local INTEGER :: m , iStep INTEGER :: iEl INTEGER :: iVar INTEGER :: i , j TYPE ( hfReal_r4 ) :: gRK3 REAL ( prec ) :: t0 REAL ( prec ) :: dt REAL ( prec ) :: rk3A REAL ( prec ) :: rk3G CALL gRK3 % Alloc ( loBound = ( / 0 , 0 , 1 , 1 / ), & upBound = ( / this % solution % N ,& this % solution % N ,& this % solution % nVar , & this % solution % nElem / )) dt = this % dt DO iStep = 1 , nSteps t0 = this % simulationTime gRK3 % hostData = 0.0_prec DO m = 1 , 3 ! Loop over RK3 steps CALL this % Tendency ( ) IF ( this % gpuAccel ) THEN rk3A = rk3_a ( m ) rk3G = rk3_g ( m ) CALL UpdateGRK3_Advection2D_gpu_wrapper ( gRK3 % deviceData , & this % solution % interior % deviceData , & this % dSdt % interior % deviceData , & rk3A , rk3G , dt , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % N DO i = 0 , this % solution % N gRK3 % hostData ( i , j , iVar , iEl ) = rk3_a ( m ) * gRK3 % hostData ( i , j , iVar , iEl ) + & this % dSdt % interior % hostData ( i , j , iVar , iEl ) this % solution % interior % hostData ( i , j , iVar , iEl ) = & this % solution % interior % hostData ( i , j , iVar , iEl ) + & rk3_g ( m ) * dt * gRK3 % hostData ( i , j , iVar , iEl ) ENDDO ENDDO ENDDO ENDDO ENDIF this % simulationTime = this % simulationTime + rk3_b ( m ) * dt ENDDO this % simulationTime = t0 + dt ENDDO CALL gRK3 % Free () END SUBROUTINE TimeStepRK3_Advection2D","tags":"","loc":"proc/timesteprk3_advection2d.html"},{"title":"WriteTecplot_Advection2D – SELF","text":"public subroutine WriteTecplot_Advection2D(self, filename) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: self character, intent(in), optional :: filename Calls proc~~writetecplot_advection2d~~CallsGraph proc~writetecplot_advection2d WriteTecplot_Advection2D timestamp timestamp proc~writetecplot_advection2d->timestamp newunit newunit proc~writetecplot_advection2d->newunit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code WriteTecplot_Advection2D Source Code SUBROUTINE WriteTecplot_Advection2D ( self , filename ) IMPLICIT NONE CLASS ( Advection2D ), INTENT ( inout ) :: self CHARACTER ( * ), INTENT ( in ), OPTIONAL :: filename ! Local CHARACTER ( 8 ) :: zoneID INTEGER :: fUnit INTEGER :: iEl , i , j CHARACTER ( LEN = self_FileNameLength ) :: tecFile CHARACTER ( 13 ) :: timeStampString IF ( PRESENT ( filename ) ) THEN tecFile = filename ELSE timeStampString = TimeStamp ( self % simulationTime , 's' ) tecFile = 'solution.' // timeStampString // '.tec' ENDIF IF ( self % gpuAccel ) THEN ! Copy data to the CPU CALL self % solution % interior % UpdateHost () ENDIF ! Map the mesh positions to the target grid CALL self % geometry % x % GridInterp ( self % plotX , gpuAccel = . FALSE .) ! Map the solution to the target grid CALL self % solution % GridInterp ( self % plotSolution , gpuAccel = . FALSE .) ! Map the velocity to the target grid CALL self % velocity % GridInterp ( self % plotVelocity , gpuAccel = . FALSE .) ! Let's write some tecplot!! OPEN ( UNIT = NEWUNIT ( fUnit ), & FILE = TRIM ( tecFile ), & FORM = 'formatted' , & STATUS = 'replace' ) ! TO DO :: Adjust for multiple tracer fields WRITE ( fUnit , * ) 'VARIABLES = \"X\", \"Y\", \"tracer\",\"u\",\"v\"' DO iEl = 1 , self % solution % nElem ! TO DO :: Get the global element ID WRITE ( zoneID , '(I8.8)' ) iEl WRITE ( fUnit , * ) 'ZONE T=\"el' // trim ( zoneID ) // '\", I=' , self % solution % M + 1 ,& ', J=' , self % solution % M + 1 , ',F=POINT' DO j = 0 , self % solution % M DO i = 0 , self % solution % M WRITE ( fUnit , '(5(E15.7,1x))' ) self % plotX % interior % hostData ( 1 , i , j , 1 , iEl ), & self % plotX % interior % hostData ( 2 , i , j , 1 , iEl ), & self % plotSolution % interior % hostData ( i , j , 1 , iEl ),& self % plotVelocity % interior % hostData ( 1 , i , j , 1 , iEl ),& self % plotVelocity % interior % hostData ( 2 , i , j , 1 , iEl ) ENDDO ENDDO ENDDO CLOSE ( UNIT = fUnit ) END SUBROUTINE WriteTecplot_Advection2D","tags":"","loc":"proc/writetecplot_advection2d.html"},{"title":"InternalDiffusiveFlux_Advection2D_gpu_wrapper – SELF","text":"interface Called by interface~~internaldiffusiveflux_advection2d_gpu_wrapper~~CalledByGraph interface~internaldiffusiveflux_advection2d_gpu_wrapper InternalDiffusiveFlux_Advection2D_gpu_wrapper proc~internalflux_advection2d InternalFlux_Advection2D proc~internalflux_advection2d->interface~internaldiffusiveflux_advection2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine InternalDiffusiveFlux_Advection2D_gpu_wrapper(flux, solutionGradient, dsdx, diffusivity, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: solutionGradient type(c_ptr) :: dsdx real(kind=c_prec), VALUE :: diffusivity integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/internaldiffusiveflux_advection2d_gpu_wrapper.html"},{"title":"InternalFlux_Advection2D_gpu_wrapper – SELF","text":"interface Called by interface~~internalflux_advection2d_gpu_wrapper~~CalledByGraph interface~internalflux_advection2d_gpu_wrapper InternalFlux_Advection2D_gpu_wrapper proc~internalflux_advection2d InternalFlux_Advection2D proc~internalflux_advection2d->interface~internalflux_advection2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine InternalFlux_Advection2D_gpu_wrapper(flux, solution, velocity, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: solution type(c_ptr) :: velocity type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/internalflux_advection2d_gpu_wrapper.html"},{"title":"SideDiffusiveFlux_Advection2D_gpu_wrapper – SELF","text":"interface Called by interface~~sidediffusiveflux_advection2d_gpu_wrapper~~CalledByGraph interface~sidediffusiveflux_advection2d_gpu_wrapper SideDiffusiveFlux_Advection2D_gpu_wrapper proc~sideflux_advection2d SideFlux_Advection2D proc~sideflux_advection2d->interface~sidediffusiveflux_advection2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine SideDiffusiveFlux_Advection2D_gpu_wrapper(flux, boundarySolGradient, extSolGradient, nHat, nScale, diffusivity, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: boundarySolGradient type(c_ptr) :: extSolGradient type(c_ptr) :: nHat type(c_ptr) :: nScale real(kind=c_prec), VALUE :: diffusivity integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/sidediffusiveflux_advection2d_gpu_wrapper.html"},{"title":"SideFlux_Advection2D_gpu_wrapper – SELF","text":"interface Called by interface~~sideflux_advection2d_gpu_wrapper~~CalledByGraph interface~sideflux_advection2d_gpu_wrapper SideFlux_Advection2D_gpu_wrapper proc~sideflux_advection2d SideFlux_Advection2D proc~sideflux_advection2d->interface~sideflux_advection2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine SideFlux_Advection2D_gpu_wrapper(flux, boundarySol, extSol, velocity, nHat, nScale, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: boundarySol type(c_ptr) :: extSol type(c_ptr) :: velocity type(c_ptr) :: nHat type(c_ptr) :: nScale integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/sideflux_advection2d_gpu_wrapper.html"},{"title":"UpdateGRK3_Advection2D_gpu_wrapper – SELF","text":"interface Called by interface~~updategrk3_advection2d_gpu_wrapper~~CalledByGraph interface~updategrk3_advection2d_gpu_wrapper UpdateGRK3_Advection2D_gpu_wrapper proc~timesteprk3_advection2d TimeStepRK3_Advection2D proc~timesteprk3_advection2d->interface~updategrk3_advection2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine UpdateGRK3_Advection2D_gpu_wrapper(gRK3, solution, dSdt, rk3A, rk3G, dt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: gRK3 type(c_ptr) :: solution type(c_ptr) :: dSdt real(kind=c_prec), VALUE :: rk3A real(kind=c_prec), VALUE :: rk3G real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/updategrk3_advection2d_gpu_wrapper.html"},{"title":"ListIsEmpty_LinkedList – SELF","text":"public function ListIsEmpty_LinkedList(myList) result(isempty) \\addtogroup SELF_LinkedList\n @{\n \\fn ListIsEmpty_LinkedList\n Checks if the LinkedList is empty and returns a logical indicating the status of the list. Usage : TYPE (LinkedList) :: this LOGICAL :: listStatus .... listStatus =  this % ListIsEmpty( ) Parameters : in myList LinkedList out isempty LOGICAL If the list is empty, isempty=.TRUE., If the list has entries, isempty=.FALSE., @} Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList Return Value logical Contents Source Code ListIsEmpty_LinkedList Source Code FUNCTION ListIsEmpty_LinkedList ( myList ) RESULT ( isempty ) IMPLICIT NONE CLASS ( LinkedList ) :: myList LOGICAL :: isempty isempty = . NOT . ( ASSOCIATED ( myList % head )) END FUNCTION ListIsEmpty_LinkedList","tags":"","loc":"proc/listisempty_linkedlist.html"},{"title":"AddToList_LinkedList – SELF","text":"public subroutine AddToList_LinkedList(myList, inData, inKey) \\addtogroup SELF_LinkedList\n @{\n \\fn AddToList_LinkedList\n Adds a new entry to the LinkedList with the provided data and key Usage : TYPE (LinkedList) :: this INTEGER :: inData, inKey .... CALL this % AddToList( inData, inKey ) Parameters : in/out myList LinkedList in inData INTEGER Data to assign to the new entry in the list in inKey INTEGER Key to assign to the new entry in the list @} Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer :: inData integer, optional :: inKey Contents Source Code AddToList_LinkedList Source Code SUBROUTINE AddToList_LinkedList ( myList , inData , inKey ) IMPLICIT NONE CLASS ( LinkedList ) :: myList INTEGER :: inData INTEGER , OPTIONAL :: inKey ! LOCAL TYPE ( Record ), POINTER :: previous INTEGER :: allocationStatus ! Check to see if this list is empty IF ( myList % ListIsEmpty ()) THEN ALLOCATE ( myList % head , STAT = allocationStatus ) IF ( allocationStatus /= 0 ) THEN PRINT * , 'MODULE LinkedListClass.f90 : S/R AddToList : Memory not allocated for next entry in list.' ! An exception handler should be built to handle these problems END IF ! Point the current position to the head myList % current => myList % head ! Set the data CALL myList % SetData ( inData ) IF ( PRESENT ( inKey )) THEN CALL myList % SetKey ( inKey ) ELSE CALL myList % SetKey ( keyStart ) END IF ! Point the next to null and the tail to current myList % current % next => NULL () myList % tail => myList % current ELSE ! the list is not empty ! Then we allocate space for the next item in the list ALLOCATE ( myList % tail % next , STAT = allocationStatus ) IF ( allocationStatus /= 0 ) THEN PRINT * , 'MODULE LinkedListClass.f90 : S/R AddToList : Memory not allocated for next entry in list.' ! An exception handler should be built to handle these problems END IF !  Temporarily hold onto the tail in case we need the key (if inKey is not present) previous => myList % tail ! Reassign the tail myList % tail => myList % tail % next ! Set the current to the tail myList % current => myList % tail ! Fill in the data CALL myList % SetData ( inData ) ! Fill in the key information IF ( PRESENT ( inKey )) THEN CALL myList % SetKey ( inKey ) ELSE CALL myList % SetKey ( previous % key + keyInc ) END IF ! Point the next to null and the tail to current myList % current % next => NULL () END IF END SUBROUTINE AddToList_LinkedList","tags":"","loc":"proc/addtolist_linkedlist.html"},{"title":"Free_LinkedList – SELF","text":"public subroutine Free_LinkedList(myList) \\addtogroup SELF_LinkedList\n @{\n \\fn Free_LinkedList\n  Cycles through the Linked List, deallocates associated memory, and nullifies the LinkedList\n  pointers. Usage : TYPE (LinkedList) :: this .... CALL this % Free( Inputs/Outputs ) Parameters : in/out myList LinkedList @} Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList Contents Source Code Free_LinkedList Source Code SUBROUTINE Free_LinkedList ( myList ) IMPLICIT NONE CLASS ( LinkedList ) :: myList ! LOCAL TYPE ( Record ), POINTER :: pNext ! Set the current position of the list to the head myList % current => myList % head ! Scroll through the list until the current position is nullified DO WHILE ( ASSOCIATED ( myList % current )) pNext => myList % current % next DEALLOCATE ( myList % current ) myList % current => pNext END DO END SUBROUTINE Free_LinkedList","tags":"","loc":"proc/free_linkedlist.html"},{"title":"GetCount_LinkedList – SELF","text":"public subroutine GetCount_LinkedList(myList, numberOfListItems) \\addtogroup SELF_LinkedList\n @{\n \\fn GetCount_LinkedList\n Counts the number of associated entries in the list Usage : TYPE (LinkedList) :: this INTEGER :: nItems .... CALL this % GetCount( nItems ) Parameters : in myList LinkedList out nItems INTEGER The number of entries in the list @} Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer, intent(out) :: numberOfListItems Contents Source Code GetCount_LinkedList Source Code SUBROUTINE GetCount_LinkedList ( myList , numberOfListItems ) IMPLICIT NONE CLASS ( LinkedList ) :: myList INTEGER , INTENT ( out ) :: numberOfListItems numberOfListItems = 0 ! Initialize the number of list items ! Check to see if this list is empty IF ( myList % ListIsEmpty ()) THEN PRINT * , 'Module LinkedListClass.f90 : S/R ListCount : List is empty.' RETURN ELSE ! the list is not empty CALL myList % MoveToHead () ! Rewind the list DO WHILE ( ASSOCIATED ( myList % current )) numberOfListItems = numberOfListItems + 1 CALL myList % moveToNext () END DO END IF END SUBROUTINE GetCount_LinkedList","tags":"","loc":"proc/getcount_linkedlist.html"},{"title":"GetCurrentData_LinkedList – SELF","text":"public subroutine GetCurrentData_LinkedList(myList, outData) \\addtogroup SELF_LinkedList\n @{\n \\fn GetCurrentData_LinkedList\n Gets the current list data and returns the integer value. Usage : TYPE (LinkedList) :: this INTEGER :: outData .... CALL this % GetCurrentData( outData ) Parameters : in myList LinkedList out outData INTEGER @} Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer :: outData Contents Source Code GetCurrentData_LinkedList Source Code SUBROUTINE GetCurrentData_LinkedList ( myList , outData ) IMPLICIT NONE CLASS ( LinkedList ) :: myList INTEGER :: outData outData = myList % current % listData END SUBROUTINE GetCurrentData_LinkedList","tags":"","loc":"proc/getcurrentdata_linkedlist.html"},{"title":"GetCurrentKey_LinkedList – SELF","text":"public subroutine GetCurrentKey_LinkedList(myList, outKey) \\addtogroup SELF_LinkedList\n @{\n \\fn GetCurrentKey_LinkedList\n Gets the current key and returns the integer value. Usage : TYPE (LinkedList) :: this INTEGER :: outKey .... CALL this % GetCurrentKey( outKey ) Parameters : in myList LinkedList out outKey INTEGER @} Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer :: outKey Contents Source Code GetCurrentKey_LinkedList Source Code SUBROUTINE GetCurrentKey_LinkedList ( myList , outKey ) IMPLICIT NONE CLASS ( LinkedList ) :: myList INTEGER :: outKey outKey = myList % current % key END SUBROUTINE GetCurrentKey_LinkedList","tags":"","loc":"proc/getcurrentkey_linkedlist.html"},{"title":"Init_LinkedList – SELF","text":"public subroutine Init_LinkedList(myList) \\addtogroup SELF_LinkedList\n @{\n \\fn Init_LinkedList\n Initializes a LinkedList by nullifying the head, tail, and current pointers Usage : TYPE (LinkedList) :: this .... CALL this % Init(  ) Parameters : in/out myList LinkedList @} Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList Contents Source Code Init_LinkedList Source Code SUBROUTINE Init_LinkedList ( myList ) IMPLICIT NONE CLASS ( LinkedList ) :: myList myList % head => NULL () myList % tail => NULL () myList % current => NULL () END SUBROUTINE Init_LinkedList","tags":"","loc":"proc/init_linkedlist.html"},{"title":"MoveToHead_LinkedList – SELF","text":"public subroutine MoveToHead_LinkedList(myList) \\addtogroup SELF_LinkedList\n @{\n \\fn MoveToHead_LinkedList\n Advances the current pointer in the LinkedList to the start of the list  (list head) Usage : TYPE (LinkedList) :: this .... CALL this % MoveToHead( ) Parameters : in/out myList LinkedList @} Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList Contents Source Code MoveToHead_LinkedList Source Code SUBROUTINE MoveToHead_LinkedList ( myList ) IMPLICIT NONE CLASS ( LinkedList ) :: myList myList % current => myList % head END SUBROUTINE MoveToHead_LinkedList","tags":"","loc":"proc/movetohead_linkedlist.html"},{"title":"MoveToNext_LinkedList – SELF","text":"public subroutine MoveToNext_LinkedList(myList) \\addtogroup SELF_LinkedList\n @{\n \\fn MoveToNext_LinkedList\n Advances the current pointer in the LinkedList to the next position Usage : TYPE (LinkedList) :: this .... CALL this % MoveToNext( ) Parameters : in/out myList LinkedList @} Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList Contents Source Code MoveToNext_LinkedList Source Code SUBROUTINE MoveToNext_LinkedList ( myList ) IMPLICIT NONE CLASS ( LinkedList ) :: myList myList % current => myList % current % next END SUBROUTINE MoveToNext_LinkedList","tags":"","loc":"proc/movetonext_linkedlist.html"},{"title":"MoveToTail_LinkedList – SELF","text":"public subroutine MoveToTail_LinkedList(myList) \\addtogroup SELF_LinkedList\n @{\n \\fn MoveToTail_LinkedList\n Advances the current pointer in the LinkedList to the end of the list (list tail) Usage : TYPE (LinkedList) :: this .... CALL this % MoveToTail( ) Parameters : in/out myList LinkedList @} Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList Contents Source Code MoveToTail_LinkedList Source Code SUBROUTINE MoveToTail_LinkedList ( myList ) IMPLICIT NONE CLASS ( LinkedList ) :: myList myList % current => myList % tail END SUBROUTINE MoveToTail_LinkedList","tags":"","loc":"proc/movetotail_linkedlist.html"},{"title":"PrintToScreen_LinkedList – SELF","text":"public subroutine PrintToScreen_LinkedList(myList) \\addtogroup SELF_LinkedList\n @{\n \\fn PrintToScreen_LinkedList\n Prints the list data and keys to the screen Usage : TYPE (LinkedList) :: this .... CALL this % PrintToScreen(  ) Parameters : in myList LinkedList @} Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList Contents Source Code PrintToScreen_LinkedList Source Code SUBROUTINE PrintToScreen_LinkedList ( myList ) IMPLICIT NONE CLASS ( LinkedList ) :: myList myList % current => myList % head PRINT * , '          Data        Key' DO WHILE ( ASSOCIATED ( myList % current )) PRINT * , myList % current % listData , myList % current % key CALL myList % MoveToNext () END DO END SUBROUTINE PrintToScreen_LinkedList","tags":"","loc":"proc/printtoscreen_linkedlist.html"},{"title":"RemoveCurrent_LinkedList – SELF","text":"public subroutine RemoveCurrent_LinkedList(myList) \\addtogroup SELF_LinkedList\n @{\n \\fn RemoveCurrent_LinkedList\n Removes the current entry from the list and patches the previous with the next. Usage : TYPE (LinkedList) :: this .... CALL this % RemoveCurrent( ) Parameters : in/out myList LinkedList @} Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList Contents Source Code RemoveCurrent_LinkedList Source Code SUBROUTINE RemoveCurrent_LinkedList ( myList ) IMPLICIT NONE CLASS ( LinkedList ) :: myList ! LOCAL TYPE ( Record ), POINTER :: previous , pNext INTEGER :: currentKey , thisKey CALL myList % GetKey ( currentKey ) ! Check to see if this list is empty IF ( myList % ListIsEmpty ()) THEN PRINT * , 'Module LinkedListClass.f90 : S/R RemoveCurrent : List is empty. Nothing to remove' RETURN ELSE ! the list is not empty CALL myList % MoveToHead () ! Rewind the list ! Get the key for this list item CALL myList % GetKey ( thisKey ) ! Check if we are trying to remove the head of the list IF ( thisKey == currentKey ) THEN ! temporarily point to the next in the list pNext => myList % current % next ! Deallocate memory pointed to by current position DEALLOCATE ( myList % current ) ! Update current position myList % head => pNext ! Reset the head of the list RETURN END IF ! If the execution of the code has arrived here, then we are not removing the head of the ! list. ! Hang on to the head as the previous previous => myList % current CALL myList % MoveToNext () DO WHILE ( ASSOCIATED ( myList % current )) ! Get the key for this list item CALL myList % GetKey ( thisKey ) ! Check if we are trying to remove the head of the list IF ( thisKey == currentKey ) THEN ! temporarily point to the next in the list pNext => myList % current % next ! Patch the previous item to the next item previous % next => pNext IF (. NOT . ASSOCIATED ( pNext )) THEN myList % tail => previous END IF ! Deallocate memory pointed to by current position DEALLOCATE ( myList % current ) EXIT ELSE previous => myList % current CALL myList % moveToNext () END IF END DO END IF END SUBROUTINE RemoveCurrent_LinkedList","tags":"","loc":"proc/removecurrent_linkedlist.html"},{"title":"SetCurrentData_LinkedList – SELF","text":"public subroutine SetCurrentData_LinkedList(myList, inData) \\addtogroup SELF_LinkedList\n @{\n \\fn SetCurrentData_LinkedList\n Sets the current list data to the supplied integer value. Usage : TYPE (LinkedList) :: this INTEGER :: inData .... CALL this % SetCurrentData( inData ) Parameters : in/out myList LinkedList in inData INTEGER @} Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer :: inData Contents Source Code SetCurrentData_LinkedList Source Code SUBROUTINE SetCurrentData_LinkedList ( myList , inData ) IMPLICIT NONE CLASS ( LinkedList ) :: myList INTEGER :: inData myList % current % listData = inData END SUBROUTINE SetCurrentData_LinkedList","tags":"","loc":"proc/setcurrentdata_linkedlist.html"},{"title":"SetCurrentKey_LinkedList – SELF","text":"public subroutine SetCurrentKey_LinkedList(myList, inKey) \\addtogroup SELF_LinkedList\n @{\n \\fn SetCurrentKey_LinkedList\n Sets the current list key to the supplied integer value. Usage : TYPE (LinkedList) :: this INTEGER :: inKey .... CALL this % SetCurrentKey( inKey ) Parameters : in/out myList LinkedList in inKey INTEGER @} Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer :: inKey Contents Source Code SetCurrentKey_LinkedList Source Code SUBROUTINE SetCurrentKey_LinkedList ( myList , inKey ) IMPLICIT NONE CLASS ( LinkedList ) :: myList INTEGER :: inKey myList % current % key = inKey END SUBROUTINE SetCurrentKey_LinkedList","tags":"","loc":"proc/setcurrentkey_linkedlist.html"},{"title":"ContainsKeys_HashTable – SELF","text":"public function ContainsKeys_HashTable(myTable, i, j) result(doesContain) \\addtogroup SELF_HashTable\n @{\n \\fn ContainsKeys_HashTable\n Checks to see if an entry in the hash-table exists for the keys \"i\" and \"j\". This function checks the i-th linked-list for a record with a key set to \"j\". If the keys exist,\n the function returns a logical set to \"TRUE\". Otherwise, the function returns \"FALSE\". Usage : TYPE (HashTable) :: this INTEGER :: i,j LOGICAL :: keysExist .... keysExist = this % ContainsKeys( i, j ) Parameters : in myTable HashTable Initialized hash-table in i INTEGER Key that points to a particular linked-list in the hash-table in j INTEGER Key for a particular record in the i-th linked-list. out doesContain LOGICAL Logical indicating if the keys exist in the hash-table @} Arguments Type Intent Optional Attributes Name class( HashTable ) :: myTable integer :: i integer :: j Return Value logical Contents Source Code ContainsKeys_HashTable Source Code FUNCTION ContainsKeys_HashTable ( myTable , i , j ) RESULT ( doesContain ) IMPLICIT NONE CLASS ( HashTable ) :: myTable INTEGER :: i , j LOGICAL :: doesContain ! LOCAL INTEGER :: thisKey doesContain = . FALSE . IF ( myTable % list ( i ) % ListIsEmpty ()) THEN ! this list hasn't been started RETURN END IF ! Rewind the list myTable % list ( i ) % current => myTable % list ( i ) % head DO WHILE ( ASSOCIATED ( myTable % list ( i ) % current )) CALL myTable % list ( i ) % GetKey ( thisKey ) IF ( thisKey == j ) THEN ! This list already has this key doesContain = . TRUE . RETURN END IF ! other wise we move to the next element in the list CALL myTable % list ( i ) % MoveToNext () END DO END FUNCTION ContainsKeys_HashTable","tags":"","loc":"proc/containskeys_hashtable.html"},{"title":"AddDataForKeys_HashTable – SELF","text":"public subroutine AddDataForKeys_HashTable(myTable, inData, i, j) \\addtogroup SELF_HashTable\n @{\n \\fn AddDataForKeys_HashTable\n Adds data to the i-th linked list with a key set to \"j\" To access data in a hash-table, two keys need to be given. The first key points to the linked-list\n in the hash table. The second key gives access to a particular record in the linked-list. Usage : TYPE (HashTable) :: this INTEGER :: data, i, j .... CALL this % AddDataForKeys( inData, i, j ) Parameters : in/out myTable HashTable Initialized hash-table in inData INTEGER Data for the j-th record of the i-th linked-list in\n                                              the hash-table. in i INTEGER Key that points to a particular linked-list in the hash-table in j INTEGER Key for a particular record in the i-th linked-list. @} Arguments Type Intent Optional Attributes Name class( HashTable ) :: myTable integer :: inData integer :: i integer :: j Contents Source Code AddDataForKeys_HashTable Source Code SUBROUTINE AddDataForKeys_HashTable ( myTable , inData , i , j ) IMPLICIT NONE CLASS ( HashTable ) :: myTable INTEGER :: inData , i , j CALL myTable % list ( i ) % AddToList ( inData , j ) END SUBROUTINE AddDataForKeys_HashTable","tags":"","loc":"proc/adddataforkeys_hashtable.html"},{"title":"Free_HashTable – SELF","text":"public subroutine Free_HashTable(myTable) \\addtogroup SELF_HashTable\n @{\n \\fn Free_HashTable\n  Deallocates memory associated with the Hash-Table Usage : TYPE (HashTable) :: this .... CALL this % Free( ) Parameters : in/out myTable HashTable On input, initialized hash-table On output, memory associated with hash-table\n                                                     has been deallocated. @} Arguments Type Intent Optional Attributes Name class( HashTable ) :: myTable Contents Source Code Free_HashTable Source Code SUBROUTINE Free_HashTable ( myTable ) IMPLICIT NONE CLASS ( HashTable ) :: myTable ! LOCAL INTEGER :: i , N N = SIZE ( myTable % list ) DO i = 1 , N CALL myTable % list ( i ) % Free () END DO DEALLOCATE ( myTable % list ) END SUBROUTINE Free_HashTable","tags":"","loc":"proc/free_hashtable.html"},{"title":"GetDataForKeys_HashTable – SELF","text":"public subroutine GetDataForKeys_HashTable(myTable, outData, i, j) \\addtogroup SELF_HashTable\n @{\n \\fn GetDataForKeys_HashTable\n Returns data from the hash table associated with the keys \"i\" and \"j\". Usage : TYPE (HashTable) :: this INTEGER :: i, j, data .... CALL this % GetDataForKeys( data, i, j ) Parameters : in myTable HashTable Initialized hash-table in i INTEGER Key that points to a particular linked-list in the hash-table in j INTEGER Key for a particular record in the i-th linked-list. out outData INTEGER Data associated with keys \"i\" and \"j\" @} Arguments Type Intent Optional Attributes Name class( HashTable ) :: myTable integer :: outData integer :: i integer :: j Contents Source Code GetDataForKeys_HashTable Source Code SUBROUTINE GetDataForKeys_HashTable ( myTable , outData , i , j ) IMPLICIT NONE CLASS ( HashTable ) :: myTable INTEGER :: outData , i , j ! LOCAL INTEGER :: thisData , thisKey IF ( myTable % list ( i ) % ListIsEmpty ()) THEN ! this table entry is not pointing to a linked list PRINT * , 'MODULE HASHTABLE_CLASS : S/R GetDataForKeys :' PRINT * , 'List ' , i , ' is empty.' outData = fillValueInt RETURN END IF myTable % list ( i ) % current => myTable % list ( i ) % head DO WHILE ( ASSOCIATED ( myTable % list ( i ) % current )) ! this table entry does not contain the keys i,j CALL myTable % list ( i ) % GetData ( thisData ) CALL myTable % list ( i ) % GetKey ( thisKey ) IF ( thisKey == j ) THEN outData = thisData RETURN END IF CALL myTable % list ( i ) % MoveToNext () END DO END SUBROUTINE GetDataForKeys_HashTable","tags":"","loc":"proc/getdataforkeys_hashtable.html"},{"title":"Init_HashTable – SELF","text":"public subroutine Init_HashTable(myTable, N) \\addtogroup SELF_HashTable\n @{\n \\fn Init_HashTable\n Allocates space for the hash table and initializes each linked list within the hash-table Usage : TYPE (HashTable) :: this INTEGER :: N .... CALL this % Init( N ) Parameters : out myTable HashTable Initialized hash-table in N INTEGER The number of linked-lists in the hash table @} Arguments Type Intent Optional Attributes Name class( HashTable ) :: myTable integer :: N Contents Source Code Init_HashTable Source Code SUBROUTINE Init_HashTable ( myTable , N ) IMPLICIT NONE CLASS ( HashTable ) :: myTable INTEGER :: N ! LOCAL INTEGER :: i ALLOCATE ( myTable % list ( 1 : N )) DO i = 1 , N CALL myTable % list ( i ) % Init () END DO END SUBROUTINE Init_HashTable","tags":"","loc":"proc/init_hashtable.html"},{"title":"CalculateDSDt_DG2D – SELF","text":"public subroutine CalculateDSDt_DG2D(this, gpuAccel) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this logical, intent(in) :: gpuAccel Calls proc~~calculatedsdt_dg2d~~CallsGraph proc~calculatedsdt_dg2d CalculateDSDt_DG2D interface~calculatedsdt_dg2d_gpu_wrapper CalculateDSDt_DG2D_gpu_wrapper proc~calculatedsdt_dg2d->interface~calculatedsdt_dg2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code CalculateDSDt_DG2D Source Code SUBROUTINE CalculateDSDt_DG2D ( this , gpuAccel ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( inout ) :: this LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , k , iVar , iEl IF ( gpuAccel ) THEN CALL CalculateDSDt_DG2D_gpu_wrapper ( this % fluxDivergence % interior % deviceData , & this % source % interior % deviceData , & this % dSdt % interior % deviceData , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO j = 0 , this % solution % N DO i = 0 , this % solution % N this % dSdt % interior % hostData ( i , j , iVar , iEl ) = & this % source % interior % hostData ( i , j , iVar , iEl ) - & this % fluxDivergence % interior % hostData ( i , j , iVar , iEl ) ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE CalculateDSDt_DG2D","tags":"","loc":"proc/calculatedsdt_dg2d.html"},{"title":"CalculateDSDt_DG3D – SELF","text":"public subroutine CalculateDSDt_DG3D(this, gpuAccel) Adds the flux convergence and source terms together and assigns to dSdt Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this logical, intent(in) :: gpuAccel Calls proc~~calculatedsdt_dg3d~~CallsGraph proc~calculatedsdt_dg3d CalculateDSDt_DG3D interface~calculatedsdt_dg3d_gpu_wrapper CalculateDSDt_DG3D_gpu_wrapper proc~calculatedsdt_dg3d->interface~calculatedsdt_dg3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code CalculateDSDt_DG3D Source Code SUBROUTINE CalculateDSDt_DG3D ( this , gpuAccel ) !! Adds the flux convergence and source terms together and assigns to dSdt IMPLICIT NONE CLASS ( DG3D ), INTENT ( inout ) :: this LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , k , iVar , iEl IF ( gpuAccel ) THEN CALL CalculateDSDt_DG3D_gpu_wrapper ( this % fluxDivergence % interior % deviceData , & this % source % interior % deviceData , & this % dSdt % interior % deviceData , & this % solution % N , & this % solution % nVar , & this % solution % nElem ) ELSE DO iEl = 1 , this % solution % nElem DO iVar = 1 , this % solution % nVar DO k = 0 , this % solution % N DO j = 0 , this % solution % N DO i = 0 , this % solution % N this % dSdt % interior % hostData ( i , j , k , iVar , iEl ) = & this % source % interior % hostData ( i , j , k , iVar , iEl ) - & this % fluxDivergence % interior % hostData ( i , j , k , iVar , iEl ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE CalculateDSDt_DG3D","tags":"","loc":"proc/calculatedsdt_dg3d.html"},{"title":"CalculateFluxDivergence_DG2D – SELF","text":"public subroutine CalculateFluxDivergence_DG2D(this, gpuAccel) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this logical, intent(in) :: gpuAccel Contents Source Code CalculateFluxDivergence_DG2D Source Code SUBROUTINE CalculateFluxDivergence_DG2D ( this , gpuAccel ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( inout ) :: this LOGICAL , INTENT ( in ) :: gpuAccel CALL this % flux % Divergence ( this % geometry , & this % fluxDivergence , & selfWeakDGForm , gpuAccel ) END SUBROUTINE CalculateFluxDivergence_DG2D","tags":"","loc":"proc/calculatefluxdivergence_dg2d.html"},{"title":"CalculateFluxDivergence_DG3D – SELF","text":"public subroutine CalculateFluxDivergence_DG3D(this, gpuAccel) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this logical, intent(in) :: gpuAccel Contents Source Code CalculateFluxDivergence_DG3D Source Code SUBROUTINE CalculateFluxDivergence_DG3D ( this , gpuAccel ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( inout ) :: this LOGICAL , INTENT ( in ) :: gpuAccel CALL this % flux % Divergence ( this % geometry , & this % fluxDivergence , & selfWeakDGForm , gpuAccel ) END SUBROUTINE CalculateFluxDivergence_DG3D","tags":"","loc":"proc/calculatefluxdivergence_dg3d.html"},{"title":"CalculateSolutionGradient_DG2D – SELF","text":"public subroutine CalculateSolutionGradient_DG2D(this, gpuAccel) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this logical, intent(in) :: gpuAccel Contents Source Code CalculateSolutionGradient_DG2D Source Code SUBROUTINE CalculateSolutionGradient_DG2D ( this , gpuAccel ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( inout ) :: this LOGICAL , INTENT ( in ) :: gpuAccel CALL this % solution % BassiRebaySides ( gpuAccel ) CALL this % solution % Gradient ( this % workTensor , & this % geometry , & this % solutionGradient , & selfWeakDGForm , gpuAccel ) END SUBROUTINE CalculateSolutionGradient_DG2D","tags":"","loc":"proc/calculatesolutiongradient_dg2d.html"},{"title":"CalculateSolutionGradient_DG3D – SELF","text":"public subroutine CalculateSolutionGradient_DG3D(this, gpuAccel) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this logical, intent(in) :: gpuAccel Contents Source Code CalculateSolutionGradient_DG3D Source Code SUBROUTINE CalculateSolutionGradient_DG3D ( this , gpuAccel ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( inout ) :: this LOGICAL , INTENT ( in ) :: gpuAccel CALL this % solution % BassiRebaySides ( gpuAccel ) CALL this % solution % Gradient ( this % workTensor , & this % geometry , & this % solutionGradient , & selfWeakDGForm , gpuAccel ) END SUBROUTINE CalculateSolutionGradient_DG3D","tags":"","loc":"proc/calculatesolutiongradient_dg3d.html"},{"title":"Free_DG2D – SELF","text":"public subroutine Free_DG2D(this) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this Contents Source Code Free_DG2D Source Code SUBROUTINE Free_DG2D ( this ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( inout ) :: this CALL this % mesh % Free () CALL this % geometry % Free () CALL this % solution % Free () CALL this % plotSolution % Free () CALL this % dSdt % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () CALL this % workScalar % Free () CALL this % workVector % Free () CALL this % workTensor % Free () CALL this % compFlux % Free () DEALLOCATE ( this % solutionMetaData ) END SUBROUTINE Free_DG2D","tags":"","loc":"proc/free_dg2d.html"},{"title":"Free_DG3D – SELF","text":"public subroutine Free_DG3D(this) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this Contents Source Code Free_DG3D Source Code SUBROUTINE Free_DG3D ( this ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( inout ) :: this CALL this % mesh % Free () CALL this % geometry % Free () CALL this % solution % Free () CALL this % dSdt % Free () CALL this % solutionGradient % Free () CALL this % flux % Free () CALL this % source % Free () CALL this % fluxDivergence % Free () CALL this % workScalar % Free () CALL this % workVector % Free () CALL this % workTensor % Free () CALL this % compFlux % Free () DEALLOCATE ( this % solutionMetaData ) END SUBROUTINE Free_DG3D","tags":"","loc":"proc/free_dg3d.html"},{"title":"Init_DG2D – SELF","text":"public subroutine Init_DG2D(this, cqType, tqType, cqDegree, tqDegree, nvar, enableMPI, spec) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(out) :: this integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nvar logical, intent(in) :: enableMPI type(MeshSpec), intent(in) :: spec Contents Source Code Init_DG2D Source Code SUBROUTINE Init_DG2D ( this , cqType , tqType , cqDegree , tqDegree , nvar , enableMPI , spec ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nvar LOGICAL , INTENT ( in ) :: enableMPI TYPE ( MeshSpec ), INTENT ( in ) :: spec CALL this % decomp % Init ( enableMPI ) ! Load Mesh CALL this % mesh % Load ( spec , this % decomp ) CALL this % decomp % SetMaxMsg ( this % mesh % nUniqueSides ) CALL this % decomp % setElemToRank ( this % mesh % nElem ) ! Create geometry from mesh CALL this % geometry % GenerateFromMesh ( this % mesh , cqType , tqType , cqDegree , tqDegree ) CALL this % solution % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % plotSolution % Init ( tqDegree , tqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % dSdt % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % solutionGradient % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % flux % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % source % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % fluxDivergence % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % workScalar % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % workVector % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % workTensor % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % compFlux % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) ALLOCATE ( this % solutionMetaData ( 1 : nvar )) END SUBROUTINE Init_DG2D","tags":"","loc":"proc/init_dg2d.html"},{"title":"Init_DG3D – SELF","text":"public subroutine Init_DG3D(this, cqType, tqType, cqDegree, tqDegree, nvar, enableMPI, spec) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(out) :: this integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nvar logical, intent(in) :: enableMPI type(MeshSpec), intent(in) :: spec Contents Source Code Init_DG3D Source Code SUBROUTINE Init_DG3D ( this , cqType , tqType , cqDegree , tqDegree , nvar , enableMPI , spec ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nvar LOGICAL , INTENT ( in ) :: enableMPI TYPE ( MeshSpec ), INTENT ( in ) :: spec CALL this % decomp % Init ( enableMPI ) ! Load Mesh CALL this % mesh % Load ( spec , this % decomp ) CALL this % decomp % SetMaxMsg ( this % mesh % nUniqueSides ) ! Create geometry from mesh CALL this % geometry % GenerateFromMesh ( this % mesh , cqType , tqType , cqDegree , tqDegree ) CALL this % solution % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % dSdt % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % solutionGradient % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % flux % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % source % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % fluxDivergence % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % workScalar % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % workVector % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % workTensor % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) CALL this % compFlux % Init ( cqDegree , cqType , tqDegree , tqType , nVar , this % mesh % nElem ) ALLOCATE ( this % solutionMetaData ( 1 : nvar )) END SUBROUTINE Init_DG3D","tags":"","loc":"proc/init_dg3d.html"},{"title":"Read_DG2D – SELF","text":"public subroutine Read_DG2D(this, fileName) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this character, intent(in) :: fileName Calls proc~~read_dg2d~~CallsGraph proc~read_dg2d Read_DG2D readattribute_hdf5 readattribute_hdf5 proc~read_dg2d->readattribute_hdf5 readarray_hdf5 readarray_hdf5 proc~read_dg2d->readarray_hdf5 close_hdf5 close_hdf5 proc~read_dg2d->close_hdf5 open_hdf5 open_hdf5 proc~read_dg2d->open_hdf5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Read_DG2D Source Code SUBROUTINE Read_DG2D ( this , fileName ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 4 ) INTEGER :: firstElem INTEGER :: N IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % decomp % mpiComm ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) END IF CALL ReadAttribute_HDF5 ( fileId , 'N' , N ) IF ( this % solution % N /= N ) THEN STOP 'Error : Solution polynomial degree does not match input file' END IF IF ( this % decomp % mpiEnabled ) THEN firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 4 ) = ( / 0 , 0 , 1 , firstElem / ) CALL ReadArray_HDF5 ( fileId , 'solution' , & this % solution % interior , solOffset ) ELSE CALL ReadArray_HDF5 ( fileId , 'solution' , this % solution % interior ) END IF CALL Close_HDF5 ( fileId ) END SUBROUTINE Read_DG2D","tags":"","loc":"proc/read_dg2d.html"},{"title":"Read_DG3D – SELF","text":"public subroutine Read_DG3D(this, fileName) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this character, intent(in) :: fileName Calls proc~~read_dg3d~~CallsGraph proc~read_dg3d Read_DG3D readattribute_hdf5 readattribute_hdf5 proc~read_dg3d->readattribute_hdf5 readarray_hdf5 readarray_hdf5 proc~read_dg3d->readarray_hdf5 close_hdf5 close_hdf5 proc~read_dg3d->close_hdf5 open_hdf5 open_hdf5 proc~read_dg3d->open_hdf5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Read_DG3D Source Code SUBROUTINE Read_DG3D ( this , fileName ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( inout ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 5 ) INTEGER :: firstElem INTEGER :: N IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId , & this % decomp % mpiComm ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_RDWR_F , fileId ) END IF CALL ReadAttribute_HDF5 ( fileId , 'N' , N ) IF ( this % solution % N /= N ) THEN STOP 'Error : Solution polynomial degree does not match input file' END IF IF ( this % decomp % mpiEnabled ) THEN firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 5 ) = ( / 0 , 0 , 0 , 1 , firstElem / ) CALL ReadArray_HDF5 ( fileId , 'solution' , this % solution % interior , solOffset ) ELSE CALL ReadArray_HDF5 ( fileId , 'solution' , this % solution % interior ) END IF CALL Close_HDF5 ( fileId ) END SUBROUTINE Read_DG3D","tags":"","loc":"proc/read_dg3d.html"},{"title":"UpdateDevice_DG2D – SELF","text":"public subroutine UpdateDevice_DG2D(this) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this Contents Source Code UpdateDevice_DG2D Source Code SUBROUTINE UpdateDevice_DG2D ( this ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( inout ) :: this CALL this % mesh % UpdateDevice () CALL this % geometry % UpdateDevice () CALL this % plotSolution % UpdateDevice () CALL this % dSdt % UpdateDevice () CALL this % solutionGradient % UpdateDevice () CALL this % flux % UpdateDevice () CALL this % source % UpdateDevice () CALL this % fluxDivergence % UpdateDevice () CALL this % workScalar % UpdateDevice () CALL this % workVector % UpdateDevice () CALL this % workTensor % UpdateDevice () CALL this % compFlux % UpdateDevice () END SUBROUTINE UpdateDevice_DG2D","tags":"","loc":"proc/updatedevice_dg2d.html"},{"title":"UpdateDevice_DG3D – SELF","text":"public subroutine UpdateDevice_DG3D(this) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this Contents Source Code UpdateDevice_DG3D Source Code SUBROUTINE UpdateDevice_DG3D ( this ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( inout ) :: this CALL this % mesh % UpdateDevice () CALL this % geometry % UpdateDevice () CALL this % solution % UpdateDevice () CALL this % dSdt % UpdateDevice () CALL this % solutionGradient % UpdateDevice () CALL this % flux % UpdateDevice () CALL this % source % UpdateDevice () CALL this % fluxDivergence % UpdateDevice () CALL this % workScalar % UpdateDevice () CALL this % workVector % UpdateDevice () CALL this % workTensor % UpdateDevice () CALL this % compFlux % UpdateDevice () END SUBROUTINE UpdateDevice_DG3D","tags":"","loc":"proc/updatedevice_dg3d.html"},{"title":"UpdateHost_DG2D – SELF","text":"public subroutine UpdateHost_DG2D(this) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this Contents Source Code UpdateHost_DG2D Source Code SUBROUTINE UpdateHost_DG2D ( this ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( inout ) :: this CALL this % mesh % UpdateHost () CALL this % geometry % UpdateHost () CALL this % solution % UpdateHost () CALL this % plotSolution % UpdateHost () CALL this % dSdt % UpdateHost () CALL this % solutionGradient % UpdateHost () CALL this % flux % UpdateHost () CALL this % source % UpdateHost () CALL this % fluxDivergence % UpdateHost () CALL this % workScalar % UpdateHost () CALL this % workVector % UpdateHost () CALL this % workTensor % UpdateHost () CALL this % compFlux % UpdateHost () END SUBROUTINE UpdateHost_DG2D","tags":"","loc":"proc/updatehost_dg2d.html"},{"title":"UpdateHost_DG3D – SELF","text":"public subroutine UpdateHost_DG3D(this) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this Contents Source Code UpdateHost_DG3D Source Code SUBROUTINE UpdateHost_DG3D ( this ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( inout ) :: this CALL this % mesh % UpdateHost () CALL this % geometry % UpdateHost () CALL this % solution % UpdateHost () CALL this % dSdt % UpdateHost () CALL this % solutionGradient % UpdateHost () CALL this % flux % UpdateHost () CALL this % source % UpdateHost () CALL this % fluxDivergence % UpdateHost () CALL this % workScalar % UpdateHost () CALL this % workVector % UpdateHost () CALL this % workTensor % UpdateHost () CALL this % compFlux % UpdateHost () END SUBROUTINE UpdateHost_DG3D","tags":"","loc":"proc/updatehost_dg3d.html"},{"title":"Write_DG2D – SELF","text":"public subroutine Write_DG2D(this, fileName) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(in) :: this character, intent(in) :: fileName Calls proc~~write_dg2d~~CallsGraph proc~write_dg2d Write_DG2D writearray_hdf5 writearray_hdf5 proc~write_dg2d->writearray_hdf5 close_hdf5 close_hdf5 proc~write_dg2d->close_hdf5 open_hdf5 open_hdf5 proc~write_dg2d->open_hdf5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Write_DG2D Source Code SUBROUTINE Write_DG2D ( this , fileName ) IMPLICIT NONE CLASS ( DG2D ), INTENT ( in ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 4 ) INTEGER ( HID_T ) :: xOffset ( 1 : 5 ) INTEGER ( HID_T ) :: solGlobalDims ( 1 : 4 ) INTEGER ( HID_T ) :: xGlobalDims ( 1 : 5 ) INTEGER :: firstElem IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_TRUNC_F , fileId , this % decomp % mpiComm ) firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 4 ) = ( / 0 , 0 , 1 , firstElem / ) solGlobalDims ( 1 : 4 ) = ( / this % solution % N , & this % solution % N , & this % solution % nVar , & this % decomp % nElem / ) xOffset ( 1 : 5 ) = ( / 1 , 0 , 0 , 1 , firstElem / ) xGlobalDims ( 1 : 5 ) = ( / 2 , & this % solution % N , & this % solution % N , & this % solution % nVar , & this % decomp % nElem / ) CALL WriteArray_HDF5 ( fileId , '/solution' , & this % solution % interior , solOffset , solGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/fluxDivergence' , & this % fluxDivergence % interior , solOffset , solGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/flux' , & this % flux % interior , xOffset , xGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/solutionGradient' , & this % solutionGradient % interior , xOffset , xGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/x' , & this % geometry % x % interior , xOffset , xGlobalDims ) CALL Close_HDF5 ( fileId ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_TRUNC_F , fileId ) CALL WriteArray_HDF5 ( fileId , '/solution' , this % solution % interior ) CALL WriteArray_HDF5 ( fileId , '/fluxDivergence' , this % fluxDivergence % interior ) CALL WriteArray_HDF5 ( fileId , '/flux' , this % flux % interior ) CALL WriteArray_HDF5 ( fileId , '/solutionGradient' , this % solutionGradient % interior ) CALL WriteArray_HDF5 ( fileId , '/x' , this % geometry % x % interior ) CALL Close_HDF5 ( fileId ) END IF END SUBROUTINE Write_DG2D","tags":"","loc":"proc/write_dg2d.html"},{"title":"Write_DG3D – SELF","text":"public subroutine Write_DG3D(this, fileName) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(in) :: this character, intent(in) :: fileName Calls proc~~write_dg3d~~CallsGraph proc~write_dg3d Write_DG3D writearray_hdf5 writearray_hdf5 proc~write_dg3d->writearray_hdf5 close_hdf5 close_hdf5 proc~write_dg3d->close_hdf5 open_hdf5 open_hdf5 proc~write_dg3d->open_hdf5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Write_DG3D Source Code SUBROUTINE Write_DG3D ( this , fileName ) IMPLICIT NONE CLASS ( DG3D ), INTENT ( in ) :: this CHARACTER ( * ), INTENT ( in ) :: fileName ! Local INTEGER ( HID_T ) :: fileId INTEGER ( HID_T ) :: solOffset ( 1 : 5 ) INTEGER ( HID_T ) :: xOffset ( 1 : 6 ) INTEGER ( HID_T ) :: solGlobalDims ( 1 : 5 ) INTEGER ( HID_T ) :: xGlobalDims ( 1 : 6 ) INTEGER :: firstElem IF ( this % decomp % mpiEnabled ) THEN CALL Open_HDF5 ( fileName , H5F_ACC_TRUNC_F , fileId , & this % decomp % mpiComm ) firstElem = this % decomp % offsetElem % hostData ( this % decomp % rankId ) + 1 solOffset ( 1 : 5 ) = ( / 0 , 0 , 0 , 1 , firstElem / ) solGlobalDims ( 1 : 5 ) = ( / this % solution % N , & this % solution % N , & this % solution % N , & this % solution % nVar , & this % decomp % nElem / ) xOffset ( 1 : 6 ) = ( / 1 , 0 , 0 , 0 , 1 , firstElem / ) xGlobalDims ( 1 : 6 ) = ( / 3 , & this % solution % N , & this % solution % N , & this % solution % N , & this % solution % nVar , & this % decomp % nElem / ) CALL WriteArray_HDF5 ( fileId , '/solution' , & this % solution % interior , solOffset , solGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/fluxDivergence' , & this % fluxDivergence % interior , solOffset , solGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/flux' , & this % flux % interior , xOffset , xGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/solutionGradient' , & this % solutionGradient % interior , xOffset , xGlobalDims ) CALL WriteArray_HDF5 ( fileId , '/x' , & this % geometry % x % interior , xOffset , xGlobalDims ) CALL Close_HDF5 ( fileId ) ELSE CALL Open_HDF5 ( fileName , H5F_ACC_TRUNC_F , fileId ) CALL WriteArray_HDF5 ( fileId , '/solution' , this % solution % interior ) CALL WriteArray_HDF5 ( fileId , '/fluxDivergence' , this % fluxDivergence % interior ) CALL WriteArray_HDF5 ( fileId , '/flux' , this % flux % interior ) CALL WriteArray_HDF5 ( fileId , '/solutionGradient' , this % solutionGradient % interior ) CALL WriteArray_HDF5 ( fileId , '/x' , this % geometry % x % interior ) CALL Close_HDF5 ( fileId ) END IF END SUBROUTINE Write_DG3D","tags":"","loc":"proc/write_dg3d.html"},{"title":"CalculateDSDt_DG2D_gpu_wrapper – SELF","text":"interface Called by interface~~calculatedsdt_dg2d_gpu_wrapper~~CalledByGraph interface~calculatedsdt_dg2d_gpu_wrapper CalculateDSDt_DG2D_gpu_wrapper proc~calculatedsdt_dg2d CalculateDSDt_DG2D proc~calculatedsdt_dg2d->interface~calculatedsdt_dg2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine CalculateDSDt_DG2D_gpu_wrapper(fluxDivergence, source, dSdt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: fluxDivergence type(c_ptr) :: source type(c_ptr) :: dSdt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/calculatedsdt_dg2d_gpu_wrapper.html"},{"title":"CalculateDSDt_DG3D_gpu_wrapper – SELF","text":"interface Called by interface~~calculatedsdt_dg3d_gpu_wrapper~~CalledByGraph interface~calculatedsdt_dg3d_gpu_wrapper CalculateDSDt_DG3D_gpu_wrapper proc~calculatedsdt_dg3d CalculateDSDt_DG3D proc~calculatedsdt_dg3d->interface~calculatedsdt_dg3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine CalculateDSDt_DG3D_gpu_wrapper(fluxDivergence, source, dSdt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: fluxDivergence type(c_ptr) :: source type(c_ptr) :: dSdt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/calculatedsdt_dg3d_gpu_wrapper.html"},{"title":"ChebyshevGauss – SELF","text":"private subroutine ChebyshevGauss(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Called by proc~~chebyshevgauss~~CalledByGraph proc~chebyshevgauss ChebyshevGauss proc~chebyshevquadrature ChebyshevQuadrature proc~chebyshevquadrature->proc~chebyshevgauss Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ChebyshevGauss Source Code SUBROUTINE ChebyshevGauss ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local INTEGER :: j DO j = 0 , N weights ( j ) = pi / ( REAL ( N , real64 ) + 1.0_real64 ) nodes ( j ) = - cos ( 0.5_real64 * ( 2.0_real64 * REAL ( j , real64 ) + 1.0_real64 ) * weights ( j )) END DO END SUBROUTINE ChebyshevGauss","tags":"","loc":"proc/chebyshevgauss.html"},{"title":"ChebyshevGaussLobatto – SELF","text":"private subroutine ChebyshevGaussLobatto(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Called by proc~~chebyshevgausslobatto~~CalledByGraph proc~chebyshevgausslobatto ChebyshevGaussLobatto proc~chebyshevquadrature ChebyshevQuadrature proc~chebyshevquadrature->proc~chebyshevgausslobatto Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ChebyshevGaussLobatto Source Code SUBROUTINE ChebyshevGaussLobatto ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! LOCAL INTEGER :: j DO j = 0 , N weights ( j ) = pi / REAL ( N , real64 ) nodes ( j ) = - cos ( REAL ( j , real64 ) * weights ( j )) END DO weights ( 0 ) = weights ( 0 ) * 0.5_real64 weights ( N ) = weights ( N ) * 0.5_real64 END SUBROUTINE ChebyshevGaussLobatto","tags":"","loc":"proc/chebyshevgausslobatto.html"},{"title":"ChebyshevQuadrature – SELF","text":"public subroutine ChebyshevQuadrature(N, nodes, weights, QuadType) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=real64), intent(out) :: nodes (0:N) real(kind=real64), intent(out) :: weights (0:N) integer, intent(in) :: QuadType Calls proc~~chebyshevquadrature~~CallsGraph proc~chebyshevquadrature ChebyshevQuadrature proc~chebyshevgausslobatto ChebyshevGaussLobatto proc~chebyshevquadrature->proc~chebyshevgausslobatto proc~chebyshevgauss ChebyshevGauss proc~chebyshevquadrature->proc~chebyshevgauss Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ChebyshevQuadrature Source Code SUBROUTINE ChebyshevQuadrature ( N , nodes , weights , quadType ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N REAL ( real64 ), INTENT ( out ) :: nodes ( 0 : N ) REAL ( real64 ), INTENT ( out ) :: weights ( 0 : N ) INTEGER , INTENT ( in ) :: QuadType ! Local REAL ( real64 ) :: nodesLocal ( 0 : N ) REAL ( real64 ) :: weightsLocal ( 0 : N ) INTEGER :: i IF ( QuadType == CHEBYSHEV_GAUSS_LOBATTO ) then CALL ChebyshevGaussLobatto ( N , nodesLocal , weightsLocal ) ELSEIF ( QuadType == CHEBYSHEV_GAUSS ) then CALL ChebyshevGauss ( N , nodesLocal , weightsLocal ) END IF DO i = 0 , N nodes ( i ) = REAL ( nodesLocal ( i ), prec ) weights ( i ) = REAL ( weightsLocal ( i ), prec ) END DO END SUBROUTINE ChebyshevQuadrature","tags":"","loc":"proc/chebyshevquadrature.html"},{"title":"LegendreGauss – SELF","text":"private subroutine LegendreGauss(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Calls proc~~legendregauss~~CallsGraph proc~legendregauss LegendreGauss proc~legendrepolynomial LegendrePolynomial proc~legendregauss->proc~legendrepolynomial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~legendregauss~~CalledByGraph proc~legendregauss LegendreGauss proc~legendrequadrature LegendreQuadrature proc~legendrequadrature->proc~legendregauss Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code LegendreGauss Source Code SUBROUTINE LegendreGauss ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local REAL ( real64 ) :: nodes_local ( 0 : N ) REAL ( real64 ) :: weights_local ( 0 : N ) REAL ( real64 ) :: lN1 , dlN1 REAL ( real64 ) :: delta INTEGER :: j , kIt IF ( N == 0 ) then nodes_local ( 0 ) = 0.0_real64 weights_local ( 0 ) = 2.0_real64 ELSEIF ( N == 1 ) then nodes_local ( 0 ) = - SQRT ( 1.0_real64 / 3.0_real64 ) weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = - nodes ( 0 ) weights_local ( 1 ) = weights ( 0 ) ELSE DO j = 0 , (( N + 1 ) / 2 ) nodes_local ( j ) = - cos (( 2.0_real64 * REAL ( j , real64 ) + 1.0_real64 ) * pi / ( 2.0_real64 * REAL ( N , real64 ) + 1.0_real64 )) DO kIt = 1 , newtonMax CALL LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) delta = - lN1 / dlN1 nodes_local ( j ) = nodes_local ( j ) + delta IF ( abs ( delta ) <= TOL * nodes_local ( j )) EXIT END DO CALL LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) weights_local ( j ) = 2.0_real64 / (( 1.0_real64 - nodes_local ( j ) * nodes_local ( j )) * dlN1 * dlN1 ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) END DO END IF IF ( MOD ( REAL ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) then CALL LegendrePolynomial ( N + 1 , 0.0_real64 , lN1 , dlN1 ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0 / ( dlN1 * dlN1 ) END IF DO j = 0 , N nodes ( j ) = REAL ( nodes_local ( j ), real64 ) weights ( j ) = REAL ( weights_local ( j ), real64 ) END DO END SUBROUTINE LegendreGauss","tags":"","loc":"proc/legendregauss.html"},{"title":"LegendreGaussLobatto – SELF","text":"private subroutine LegendreGaussLobatto(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Calls proc~~legendregausslobatto~~CallsGraph proc~legendregausslobatto LegendreGaussLobatto proc~legendreqandl LegendreQandL proc~legendregausslobatto->proc~legendreqandl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~legendregausslobatto~~CalledByGraph proc~legendregausslobatto LegendreGaussLobatto proc~legendrequadrature LegendreQuadrature proc~legendrequadrature->proc~legendregausslobatto Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code LegendreGaussLobatto Source Code SUBROUTINE LegendreGaussLobatto ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local REAL ( real64 ) :: nodes_local ( 0 : N ) REAL ( real64 ) :: weights_local ( 0 : N ) REAL ( real64 ) :: delta , q , qprime , lN INTEGER :: j , kIt IF ( N == 1 ) then nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = 1.0_real64 weights_local ( 1 ) = 1.0_real64 ELSE nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 )) nodes_local ( N ) = 1.0_real64 weights_local ( N ) = weights_local ( 0 ) DO j = 1 , (( N + 1 ) / 2 - 1 ) nodes_local ( j ) = - COS (( REAL ( j , real64 ) + 0.25_real64 ) * pi / REAL ( N , real64 ) - & 3.0_real64 / ( 8.0_real64 * REAL ( N , real64 ) * pi * ( REAL ( j , real64 ) + 0.25_real64 ))) DO kIt = 1 , newtonMax CALL LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) delta = - q / qprime nodes_local ( j ) = nodes_local ( j ) + delta IF ( ABS ( delta ) <= TOL * nodes_local ( j )) EXIT END DO CALL LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) weights_local ( j ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 ) * lN * lN ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) END DO END IF IF ( MOD ( REAL ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) THEN CALL LegendreQandL ( N , 0.0_real64 , q , qprime , lN ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 ) * lN * lN ) END IF DO j = 0 , N nodes ( j ) = REAL ( nodes_local ( j ), real64 ) weights ( j ) = REAL ( weights_local ( j ), real64 ) END DO END SUBROUTINE LegendreGaussLobatto","tags":"","loc":"proc/legendregausslobatto.html"},{"title":"LegendrePolynomial – SELF","text":"public subroutine LegendrePolynomial(N, x, lAtX, dLdxAtX) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: lAtX real(kind=real64) :: dLdxAtX Called by proc~~legendrepolynomial~~CalledByGraph proc~legendrepolynomial LegendrePolynomial proc~legendregauss LegendreGauss proc~legendregauss->proc~legendrepolynomial proc~legendrequadrature LegendreQuadrature proc~legendrequadrature->proc~legendregauss Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code LegendrePolynomial Source Code SUBROUTINE LegendrePolynomial ( N , x , lAtX , dLdxAtX ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: x REAL ( real64 ) :: lAtX , dLdxAtX ! Local REAL ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 INTEGER :: i IF ( N == 0 ) then lAtX = 1.0_real64 dLdxAtX = 0.0_real64 ELSEIF ( N == 1 ) then lAtX = x dLdxAtX = 1.0_real64 ELSE lnM2 = 1.0_real64 lnM1 = x dlnM2 = 0.0_real64 dlnM1 = 1.0_real64 DO i = 2 , N lAtX = (( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * x * lnM1 - & ( REAL ( i , real64 ) - 1.0_real64 ) * lnM2 ) / ( REAL ( i , real64 )) dldxAtX = dlnM2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lnM1 lnM2 = lnM1 lnM1 = lAtX dlnM2 = dlnM1 dlnM1 = dldxAtX END DO END IF END SUBROUTINE LegendrePolynomial","tags":"","loc":"proc/legendrepolynomial.html"},{"title":"LegendreQandL – SELF","text":"private subroutine LegendreQandL(N, x, q, qprime, lN) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: q real(kind=real64) :: qprime real(kind=real64) :: lN Called by proc~~legendreqandl~~CalledByGraph proc~legendreqandl LegendreQandL proc~legendregausslobatto LegendreGaussLobatto proc~legendregausslobatto->proc~legendreqandl proc~legendrequadrature LegendreQuadrature proc~legendrequadrature->proc~legendregausslobatto Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code LegendreQandL Source Code SUBROUTINE LegendreQandL ( N , x , q , qprime , lN ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: x REAL ( real64 ) :: lN , q , qprime ! Local REAL ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 , dlN , lN1 , dlN1 INTEGER :: i lNm2 = 1.0_real64 lNm1 = x dlNm2 = 0.0_real64 dlNm1 = 1.0_real64 DO i = 2 , N lN = ( 2.0_real64 * i - 1.0_real64 ) / ( REAL ( i , real64 )) * x * lNm1 - ( REAL ( i , real64 ) - 1.0_real64 ) / ( REAL ( i , real64 )) * lNm2 dlN = dlNm2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lNm1 lNm2 = lNm1 lNm1 = lN dlNm2 = dlNm1 dlNm1 = dlN END DO i = N + 1 lN1 = ( 2.0_real64 * i - 1.0_real64 ) / ( REAL ( i , real64 )) * x * lN - ( REAL ( i , real64 ) - 1.0_real64 ) / ( REAL ( i , real64 )) * lNm2 dlN1 = dlNm2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lNm1 q = lN1 - lNm2 qprime = dlN1 - dlNm2 END SUBROUTINE LegendreQandL","tags":"","loc":"proc/legendreqandl.html"},{"title":"LegendreQuadrature – SELF","text":"public subroutine LegendreQuadrature(N, nodes, weights, QuadType) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=prec), intent(out) :: nodes (0:N) real(kind=prec), intent(out) :: weights (0:N) integer, intent(in) :: QuadType Calls proc~~legendrequadrature~~CallsGraph proc~legendrequadrature LegendreQuadrature proc~legendregauss LegendreGauss proc~legendrequadrature->proc~legendregauss proc~legendregausslobatto LegendreGaussLobatto proc~legendrequadrature->proc~legendregausslobatto proc~legendrepolynomial LegendrePolynomial proc~legendregauss->proc~legendrepolynomial proc~legendreqandl LegendreQandL proc~legendregausslobatto->proc~legendreqandl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code LegendreQuadrature Source Code SUBROUTINE LegendreQuadrature ( N , nodes , weights , QuadType ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N REAL ( prec ), INTENT ( out ) :: nodes ( 0 : N ) REAL ( prec ), INTENT ( out ) :: weights ( 0 : N ) INTEGER , INTENT ( in ) :: QuadType ! Local REAL ( real64 ) :: nodesLocal ( 0 : N ) REAL ( real64 ) :: weightsLocal ( 0 : N ) INTEGER :: i IF ( QuadType == GAUSS_LOBATTO ) THEN CALL LegendreGaussLobatto ( N , nodesLocal , weightsLocal ) ELSEIF ( QuadType == GAUSS ) THEN CALL LegendreGauss ( N , nodesLocal , weightsLocal ) END IF DO i = 0 , N nodes ( i ) = REAL ( nodesLocal ( i ), prec ) weights ( i ) = REAL ( weightsLocal ( i ), prec ) END DO END SUBROUTINE LegendreQuadrature","tags":"","loc":"proc/legendrequadrature.html"},{"title":"CalculateLagrangePolynomials – SELF","text":"public function CalculateLagrangePolynomials(myPoly, sE) result(lAtS) Arguments Type Intent Optional Attributes Name class( Lagrange ) :: myPoly real(kind=prec) :: sE Return Value real(kind=prec)\n  (0:myPoly%N) Calls proc~~calculatelagrangepolynomials~~CallsGraph proc~calculatelagrangepolynomials CalculateLagrangePolynomials almostequal almostequal proc~calculatelagrangepolynomials->almostequal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code CalculateLagrangePolynomials Source Code FUNCTION CalculateLagrangePolynomials ( myPoly , sE ) RESULT ( lAtS ) IMPLICIT NONE CLASS ( Lagrange ) :: myPoly REAL ( prec ) :: sE REAL ( prec ) :: lAtS ( 0 : myPoly % N ) ! Local INTEGER :: j LOGICAL :: xMatchesNode REAL ( real64 ) :: temp1 , temp2 REAL ( real64 ) :: sELocal REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: lS ( 0 : myPoly % N ) sELocal = REAL ( sE , real64 ) DO j = 0 , myPoly % N controlPoints ( j ) = REAL ( myPoly % controlPoints % hostData ( j ), real64 ) bWeights ( j ) = REAL ( myPoly % bWeights % hostData ( j ), real64 ) END DO xMatchesNode = . FALSE . DO j = 0 , myPoly % N lS ( j ) = 0.0_real64 IF ( AlmostEqual ( sELocal , controlPoints ( j ))) THEN lS ( j ) = 1.0_real64 xMatchesNode = . TRUE . END IF END DO IF ( xMatchesNode ) THEN RETURN END IF temp1 = 0.0_real64 DO j = 0 , myPoly % N temp2 = bWeights ( j ) / ( sE - controlPoints ( j )) lS ( j ) = temp2 temp1 = temp1 + temp2 END DO lS = lS / temp1 DO j = 0 , myPoly % N lAtS ( j ) = REAL ( lS ( j ), prec ) END DO END FUNCTION CalculateLagrangePolynomials","tags":"","loc":"proc/calculatelagrangepolynomials.html"},{"title":"CalculateBarycentricWeights – SELF","text":"public subroutine CalculateBarycentricWeights(myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Contents Source Code CalculateBarycentricWeights Source Code SUBROUTINE CalculateBarycentricWeights ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: i , j REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) DO i = 0 , myPoly % N bWeights ( i ) = 1.0_real64 controlPoints ( i ) = REAL ( myPoly % controlPoints % hostData ( i ), real64 ) END DO ! Computes the product w_k = w_k*(s_k - s_j), k /= j DO j = 1 , myPoly % N DO i = 0 , j - 1 bWeights ( i ) = bWeights ( i ) * ( controlPoints ( i ) - controlPoints ( j )) bWeights ( j ) = bWeights ( j ) * ( controlPoints ( j ) - controlPoints ( i )) END DO END DO DO j = 0 , myPoly % N bWeights ( j ) = 1.0_prec / bWeights ( j ) myPoly % bWeights % hostData ( j ) = REAL ( bWeights ( j ), prec ) END DO END SUBROUTINE CalculateBarycentricWeights","tags":"","loc":"proc/calculatebarycentricweights.html"},{"title":"CalculateDerivativeMatrix – SELF","text":"public subroutine CalculateDerivativeMatrix(myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Contents Source Code CalculateDerivativeMatrix Source Code SUBROUTINE CalculateDerivativeMatrix ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: row , col REAL ( real64 ) :: dmat ( 0 : myPoly % N , 0 : myPoly % N ) REAL ( real64 ) :: dgmat ( 0 : myPoly % N , 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: qWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) DO row = 0 , myPoly % N bWeights ( row ) = REAL ( myPoly % bWeights % hostData ( row ), real64 ) qWeights ( row ) = REAL ( myPoly % qWeights % hostData ( row ), real64 ) controlPoints ( row ) = REAL ( myPoly % controlPoints % hostData ( row ), real64 ) END DO DO row = 0 , myPoly % N dmat ( row , row ) = 0.0_prec DO col = 0 , myPoly % N IF (. NOT . ( col == row )) THEN dmat ( row , col ) = bWeights ( col ) / & ( bWeights ( row ) * & ( controlPoints ( row ) - & controlPoints ( col ))) dmat ( row , row ) = dmat ( row , row ) - dmat ( row , col ) END IF END DO END DO DO row = 0 , myPoly % N DO col = 0 , myPoly % N dgmat ( row , col ) = - dmat ( col , row ) * & qWeights ( col ) / & qWeights ( row ) END DO END DO DO row = 0 , myPoly % N DO col = 0 , myPoly % N myPoly % dMatrix % hostData ( row , col ) = REAL ( dmat ( col , row ), prec ) myPoly % dgMatrix % hostData ( row , col ) = REAL ( dgmat ( col , row ), prec ) END DO END DO END SUBROUTINE CalculateDerivativeMatrix","tags":"","loc":"proc/calculatederivativematrix.html"},{"title":"CalculateInterpolationMatrix – SELF","text":"public subroutine CalculateInterpolationMatrix(myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Calls proc~~calculateinterpolationmatrix~~CallsGraph proc~calculateinterpolationmatrix CalculateInterpolationMatrix almostequal almostequal proc~calculateinterpolationmatrix->almostequal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code CalculateInterpolationMatrix Source Code SUBROUTINE CalculateInterpolationMatrix ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: row , col LOGICAL :: rowHasMatch REAL ( real64 ) :: temp1 , temp2 REAL ( real64 ) :: iMatrix ( 0 : myPoly % M , 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) REAL ( real64 ) :: targetPoints ( 0 : myPoly % M ) DO col = 0 , myPoly % N controlPoints ( col ) = REAL ( myPoly % controlPoints % hostData ( col ), real64 ) bWeights ( col ) = REAL ( myPoly % bWeights % hostData ( col ), real64 ) END DO DO row = 0 , myPoly % M targetPoints ( row ) = REAL ( myPoly % targetPoints % hostData ( row ), real64 ) END DO DO row = 0 , myPoly % M rowHasMatch = . FALSE . DO col = 0 , myPoly % N iMatrix ( row , col ) = 0.0_real64 IF ( AlmostEqual ( targetPoints ( row ), controlPoints ( col ))) THEN rowHasMatch = . TRUE . iMatrix ( row , col ) = 1.0_real64 END IF END DO IF (. NOT . ( rowHasMatch )) THEN temp1 = 0.0_real64 DO col = 0 , myPoly % N temp2 = bWeights ( col ) / & ( targetPoints ( row ) - & controlPoints ( col )) iMatrix ( row , col ) = temp2 temp1 = temp1 + temp2 END DO DO col = 0 , myPoly % N iMatrix ( row , col ) = iMatrix ( row , col ) / temp1 END DO END IF END DO DO row = 0 , myPoly % M DO col = 0 , myPoly % N myPoly % iMatrix % hostData ( col , row ) = REAL ( iMatrix ( row , col ), prec ) END DO END DO END SUBROUTINE CalculateInterpolationMatrix","tags":"","loc":"proc/calculateinterpolationmatrix.html"},{"title":"DGDerivative_1D_cpu – SELF","text":"public subroutine DGDerivative_1D_cpu(myPoly, f, bf, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:nVariables,1:2,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code DGDerivative_1D_cpu Source Code SUBROUTINE DGDerivative_1D_cpu ( myPoly , f , bf , df , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : nVariables , 1 : 2 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: df ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N ! Interior Derivative Matrix Application df ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO ! Boundary Contribution df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + ( bf ( iVar , 2 , iEl ) * myPoly % bMatrix % hostData ( i , 1 ) - & bf ( iVar , 1 , iEl ) * myPoly % bMatrix % hostData ( i , 0 )) / & myPoly % qWeights % hostData ( i ) END DO END DO END DO END SUBROUTINE DGDerivative_1D_cpu","tags":"","loc":"proc/dgderivative_1d_cpu.html"},{"title":"DGDerivative_1D_gpu – SELF","text":"public subroutine DGDerivative_1D_gpu(myPoly, f_dev, bf_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~dgderivative_1d_gpu~~CallsGraph proc~dgderivative_1d_gpu DGDerivative_1D_gpu interface~dgderivative_1d_gpu_wrapper DGDerivative_1D_gpu_wrapper proc~dgderivative_1d_gpu->interface~dgderivative_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code DGDerivative_1D_gpu Source Code SUBROUTINE DGDerivative_1D_gpu ( myPoly , f_dev , bf_dev , df_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: df_dev CALL DGDerivative_1D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bf_dev , df_dev , & myPoly % N , & nVariables , nElements ) END SUBROUTINE DGDerivative_1D_gpu","tags":"","loc":"proc/dgderivative_1d_gpu.html"},{"title":"Derivative_1D_cpu – SELF","text":"public subroutine Derivative_1D_cpu(myPoly, f, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code Derivative_1D_cpu Source Code SUBROUTINE Derivative_1D_cpu ( myPoly , f , df , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: df ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N df ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO END DO END DO END DO END SUBROUTINE Derivative_1D_cpu","tags":"","loc":"proc/derivative_1d_cpu.html"},{"title":"Derivative_1D_gpu – SELF","text":"public subroutine Derivative_1D_gpu(myPoly, f_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~derivative_1d_gpu~~CallsGraph proc~derivative_1d_gpu Derivative_1D_gpu interface~derivative_1d_gpu_wrapper Derivative_1D_gpu_wrapper proc~derivative_1d_gpu->interface~derivative_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Derivative_1D_gpu Source Code SUBROUTINE Derivative_1D_gpu ( myPoly , f_dev , df_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: df_dev CALL Derivative_1D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , df_dev , & myPoly % N , & nVariables , nElements ) END SUBROUTINE Derivative_1D_gpu","tags":"","loc":"proc/derivative_1d_gpu.html"},{"title":"Free_Lagrange – SELF","text":"public subroutine Free_Lagrange(myPoly) Frees all memory (host and device) associated with an instance of the Lagrange class Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance Contents Source Code Free_Lagrange Source Code SUBROUTINE Free_Lagrange ( myPoly ) !! Frees all memory (host and device) associated with an instance of the Lagrange class IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly !! Lagrange class instance CALL myPoly % controlPoints % Free () CALL myPoly % targetPoints % Free () CALL myPoly % bWeights % Free () CALL myPoly % qWeights % Free () CALL myPoly % iMatrix % Free () CALL myPoly % dMatrix % Free () CALL myPoly % dgMatrix % Free () CALL myPoly % bMatrix % Free () END SUBROUTINE Free_Lagrange","tags":"","loc":"proc/free_lagrange.html"},{"title":"Init_Lagrange – SELF","text":"public subroutine Init_Lagrange(myPoly, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange class\nOn output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(out) :: myPoly Lagrange class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) Calls proc~~init_lagrange~~CallsGraph proc~init_lagrange Init_Lagrange chebyshevquadrature chebyshevquadrature proc~init_lagrange->chebyshevquadrature uniformpoints uniformpoints proc~init_lagrange->uniformpoints legendrequadrature legendrequadrature proc~init_lagrange->legendrequadrature Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Init_Lagrange Source Code SUBROUTINE Init_Lagrange ( myPoly , N , controlNodeType , M , targetNodeType ) !! Initialize an instance of the Lagrange class !! On output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of !! control points, number of target points, and the types for the control and target nodes. !! If a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. IMPLICIT NONE CLASS ( Lagrange ), INTENT ( out ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: N !! The number of control points for interpolant INTEGER , INTENT ( in ) :: M !! The number of target points for the interpolant INTEGER , INTENT ( in ) :: controlNodeType !! The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) INTEGER , INTENT ( in ) :: targetNodeType !! The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1), !! GAUSS_LOBATTO(=2), or UNIFORM(=3) ! -------! ! Local REAL ( prec ) :: q ( 0 : M ) myPoly % N = N myPoly % M = M CALL myPoly % controlPoints % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % targetPoints % Alloc ( loBound = 0 , & upBound = M ) CALL myPoly % bWeights % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % qWeights % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % iMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , M / )) CALL myPoly % dMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , N / )) CALL myPoly % dgMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , N / )) CALL myPoly % bMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , 1 / )) IF ( controlNodeType == GAUSS . OR . controlNodeType == GAUSS_LOBATTO ) THEN CALL LegendreQuadrature ( N , & myPoly % controlPoints % hostData , & myPoly % qWeights % hostData , & controlNodeType ) ELSEIF ( controlNodeType == CHEBYSHEV_GAUSS . OR . controlNodeType == CHEBYSHEV_GAUSS_LOBATTO ) THEN CALL ChebyshevQuadrature ( N , & myPoly % controlPoints % hostData , & myPoly % qWeights % hostData , & controlNodeType ) ELSEIF ( controlNodeType == UNIFORM ) THEN myPoly % controlPoints % hostData = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , N ) myPoly % qWeights % hostData = 2.0_prec / REAL ( N , prec ) END IF ! Target Points IF ( targetNodeType == GAUSS . OR . targetNodeType == GAUSS_LOBATTO ) THEN CALL LegendreQuadrature ( M , & myPoly % targetPoints % hostData , & q , & targetNodeType ) ELSEIF ( targetNodeType == UNIFORM ) THEN myPoly % targetPoints % hostData = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , M ) END IF CALL myPoly % CalculateBarycentricWeights () CALL myPoly % CalculateInterpolationMatrix () CALL myPoly % CalculateDerivativeMatrix () myPoly % bMatrix % hostData ( 0 : N , 0 ) = myPoly % CalculateLagrangePolynomials ( - 1.0_prec ) myPoly % bMatrix % hostData ( 0 : N , 1 ) = myPoly % CalculateLagrangePolynomials ( 1.0_prec ) CALL myPoly % UpdateDevice () END SUBROUTINE Init_Lagrange","tags":"","loc":"proc/init_lagrange.html"},{"title":"ScalarBoundaryInterp_1D_cpu – SELF","text":"public subroutine ScalarBoundaryInterp_1D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:nVariables,1:2,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarBoundaryInterp_1D_cpu Source Code SUBROUTINE ScalarBoundaryInterp_1D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : nVariables , 1 : 2 , 1 : nElements ) ! Local INTEGER :: ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables fb ( 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , iVar , iEl ) ! West fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , iVar , iEl ) ! East END DO fBound ( iVar , 1 : 2 , iEl ) = fb ( 1 : 2 ) END DO END DO END SUBROUTINE ScalarBoundaryInterp_1D_cpu","tags":"","loc":"proc/scalarboundaryinterp_1d_cpu.html"},{"title":"ScalarBoundaryInterp_1D_gpu – SELF","text":"public subroutine ScalarBoundaryInterp_1D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalarboundaryinterp_1d_gpu~~CallsGraph proc~scalarboundaryinterp_1d_gpu ScalarBoundaryInterp_1D_gpu interface~scalarboundaryinterp_1d_gpu_wrapper ScalarBoundaryInterp_1D_gpu_wrapper proc~scalarboundaryinterp_1d_gpu->interface~scalarboundaryinterp_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarBoundaryInterp_1D_gpu Source Code SUBROUTINE ScalarBoundaryInterp_1D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL ScalarBoundaryInterp_1D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE ScalarBoundaryInterp_1D_gpu","tags":"","loc":"proc/scalarboundaryinterp_1d_gpu.html"},{"title":"ScalarBoundaryInterp_2D_cpu – SELF","text":"public subroutine ScalarBoundaryInterp_2D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarBoundaryInterp_2D_cpu Source Code SUBROUTINE ScalarBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , ii , iVar , iEl ) ! South fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , i , iVar , iEl ) ! East fb ( 3 ) = fb ( 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , ii , iVar , iEl ) ! North fb ( 4 ) = fb ( 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , i , iVar , iEl ) ! West END DO fBound ( i , iVar , 1 : 4 , iEl ) = fb ( 1 : 4 ) END DO END DO END DO END SUBROUTINE ScalarBoundaryInterp_2D_cpu","tags":"","loc":"proc/scalarboundaryinterp_2d_cpu.html"},{"title":"ScalarBoundaryInterp_2D_gpu – SELF","text":"public subroutine ScalarBoundaryInterp_2D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalarboundaryinterp_2d_gpu~~CallsGraph proc~scalarboundaryinterp_2d_gpu ScalarBoundaryInterp_2D_gpu interface~scalarboundaryinterp_2d_gpu_wrapper ScalarBoundaryInterp_2D_gpu_wrapper proc~scalarboundaryinterp_2d_gpu->interface~scalarboundaryinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarBoundaryInterp_2D_gpu Source Code SUBROUTINE ScalarBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL ScalarBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE ScalarBoundaryInterp_2D_gpu","tags":"","loc":"proc/scalarboundaryinterp_2d_gpu.html"},{"title":"ScalarBoundaryInterp_3D_cpu – SELF","text":"public subroutine ScalarBoundaryInterp_3D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarBoundaryInterp_3D_cpu Source Code SUBROUTINE ScalarBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , j , ii , iVar , iEl ) ! Bottom fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , ii , j , iVar , iEl ) ! South fb ( 3 ) = fb ( 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , i , j , iVar , iEl ) ! East fb ( 4 ) = fb ( 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , ii , j , iVar , iEl ) ! North fb ( 5 ) = fb ( 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , i , j , iVar , iEl ) ! West fb ( 6 ) = fb ( 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , j , ii , iVar , iEl ) ! Top END DO fBound ( i , j , iVar , 1 : 6 , iEl ) = fb ( 1 : 6 ) END DO END DO END DO END DO END SUBROUTINE ScalarBoundaryInterp_3D_cpu","tags":"","loc":"proc/scalarboundaryinterp_3d_cpu.html"},{"title":"ScalarBoundaryInterp_3D_gpu – SELF","text":"public subroutine ScalarBoundaryInterp_3D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalarboundaryinterp_3d_gpu~~CallsGraph proc~scalarboundaryinterp_3d_gpu ScalarBoundaryInterp_3D_gpu interface~scalarboundaryinterp_3d_gpu_wrapper ScalarBoundaryInterp_3D_gpu_wrapper proc~scalarboundaryinterp_3d_gpu->interface~scalarboundaryinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarBoundaryInterp_3D_gpu Source Code SUBROUTINE ScalarBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL ScalarBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE ScalarBoundaryInterp_3D_gpu","tags":"","loc":"proc/scalarboundaryinterp_3d_gpu.html"},{"title":"ScalarDGGradient_2D_cpu – SELF","text":"public subroutine ScalarDGGradient_2D_cpu(myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarDGGradient_2D_cpu Source Code SUBROUTINE ScalarDGGradient_2D_cpu ( myPoly , f , bf , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = gradF ( 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( ii , j , iVar , iEl ) gradF ( 2 , i , j , iVar , iEl ) = gradF ( 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , j ) * f ( i , ii , iVar , iEl ) END DO ! Boundary Contribution gradF ( 1 , i , j , iVar , iEl ) = gradF ( 1 , i , j , iVar , iEl ) + ( bf ( j , iVar , 2 , iEl ) * myPoly % bMatrix % hostData ( i , 1 ) + & bf ( j , iVar , 4 , iEl ) * myPoly % bMatrix % hostData ( i , 0 )) / & myPoly % qWeights % hostData ( i ) gradF ( 2 , i , j , iVar , iEl ) = gradF ( 2 , i , j , iVar , iEl ) + ( bf ( i , iVar , 3 , iEl ) * myPoly % bMatrix % hostData ( j , 1 ) + & bf ( i , iVar , 1 , iEl ) * myPoly % bMatrix % hostData ( j , 0 )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE ScalarDGGradient_2D_cpu","tags":"","loc":"proc/scalardggradient_2d_cpu.html"},{"title":"ScalarDGGradient_2D_gpu – SELF","text":"public subroutine ScalarDGGradient_2D_gpu(myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalardggradient_2d_gpu~~CallsGraph proc~scalardggradient_2d_gpu ScalarDGGradient_2D_gpu interface~scalardggradient_2d_gpu_wrapper ScalarDGGradient_2D_gpu_wrapper proc~scalardggradient_2d_gpu->interface~scalardggradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarDGGradient_2D_gpu Source Code SUBROUTINE ScalarDGGradient_2D_gpu ( myPoly , f_dev , bf_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL ScalarDGGradient_2D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bf_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE ScalarDGGradient_2D_gpu","tags":"","loc":"proc/scalardggradient_2d_gpu.html"},{"title":"ScalarGradient_2D_cpu – SELF","text":"public subroutine ScalarGradient_2D_cpu(myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarGradient_2D_cpu Source Code SUBROUTINE ScalarGradient_2D_cpu ( myPoly , f , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = gradF ( 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , j , iVar , iEl ) gradF ( 2 , i , j , iVar , iEl ) = gradF ( 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE ScalarGradient_2D_cpu","tags":"","loc":"proc/scalargradient_2d_cpu.html"},{"title":"ScalarGradient_2D_gpu – SELF","text":"public subroutine ScalarGradient_2D_gpu(myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalargradient_2d_gpu~~CallsGraph proc~scalargradient_2d_gpu ScalarGradient_2D_gpu interface~scalargradient_2d_gpu_wrapper ScalarGradient_2D_gpu_wrapper proc~scalargradient_2d_gpu->interface~scalargradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarGradient_2D_gpu Source Code SUBROUTINE ScalarGradient_2D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL ScalarGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE ScalarGradient_2D_gpu","tags":"","loc":"proc/scalargradient_2d_gpu.html"},{"title":"ScalarGradient_3D_cpu – SELF","text":"public subroutine ScalarGradient_3D_cpu(myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarGradient_3D_cpu Source Code SUBROUTINE ScalarGradient_3D_cpu ( myPoly , f , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , i , j , k , iVar , iEl ) = gradF ( 1 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , j , k , iVar , iEl ) gradF ( 2 , i , j , k , iVar , iEl ) = gradF ( 2 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( i , ii , k , iVar , iEl ) gradF ( 3 , i , j , k , iVar , iEl ) = gradF ( 3 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , k ) * f ( i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE ScalarGradient_3D_cpu","tags":"","loc":"proc/scalargradient_3d_cpu.html"},{"title":"ScalarGradient_3D_gpu – SELF","text":"public subroutine ScalarGradient_3D_gpu(myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalargradient_3d_gpu~~CallsGraph proc~scalargradient_3d_gpu ScalarGradient_3D_gpu interface~scalargradient_3d_gpu_wrapper ScalarGradient_3D_gpu_wrapper proc~scalargradient_3d_gpu->interface~scalargradient_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarGradient_3D_gpu Source Code SUBROUTINE ScalarGradient_3D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL ScalarGradient_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE ScalarGradient_3D_gpu","tags":"","loc":"proc/scalargradient_3d_gpu.html"},{"title":"ScalarGridInterp_1D_cpu – SELF","text":"public subroutine ScalarGridInterp_1D_cpu(myPoly, f, fInterp, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Interpolation is applied using a series of matrix-vector multiplications, using\nthe Lagrange class's interpolation matrix Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fInterp (0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid Contents Source Code ScalarGridInterp_1D_cpu Source Code SUBROUTINE ScalarGridInterp_1D_cpu ( myPoly , f , fInterp , nVariables , nElements ) !! Host (CPU) implementation of the ScalarGridInterp_1D interface. !! In most cases, you should use the `ScalarGridInterp_1D` generic interface, !! rather than calling this routine directly. !! Interpolate a scalar-1D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,ivar,iel} = \\sum_{i=0}&#94;N f_{i,ivar,iel} I_{i,m}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) !! (Input) Array of function values, defined on the control grid REAL ( prec ), INTENT ( out ) :: fInterp ( 0 : myPoly % M , 1 : nVariables , 1 : nElements ) !! (Output) Array of function values, defined on the target grid ! Local INTEGER :: iVar , iEl , i , ii DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % M fInterp ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N fInterp ( i , iVar , iEl ) = fInterp ( i , iVar , iEl ) + myPoly % iMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_1D_cpu","tags":"","loc":"proc/scalargridinterp_1d_cpu.html"},{"title":"ScalarGridInterp_1D_gpu – SELF","text":"public subroutine ScalarGridInterp_1D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_1D_gpu_wrapper\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Interpolation is applied using a series of matrix-vector multiplications, using\nthe Lagrange class's interpolation matrix Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid Calls proc~~scalargridinterp_1d_gpu~~CallsGraph proc~scalargridinterp_1d_gpu ScalarGridInterp_1D_gpu interface~scalargridinterp_1d_gpu_wrapper ScalarGridInterp_1D_gpu_wrapper proc~scalargridinterp_1d_gpu->interface~scalargridinterp_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarGridInterp_1D_gpu Source Code SUBROUTINE ScalarGridInterp_1D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) !! Device (GPU) implementation of the ScalarGridInterp_1D interface. !! In most cases, you should use the `ScalarGridInterp_1D` generic interface, !! rather than calling this routine directly. !! This routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_1D_gpu_wrapper !! Interpolate a scalar-1D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,ivar,iel} = \\sum_{i=0}&#94;N f_{i,ivar,iel} I_{i,m}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid TYPE ( c_ptr ), INTENT ( in ) :: f_dev !! (Input) Array of function values, defined on the control grid TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev !! (Output) Array of function values, defined on the target grid CALL ScalarGridInterp_1D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE ScalarGridInterp_1D_gpu","tags":"","loc":"proc/scalargridinterp_1d_gpu.html"},{"title":"ScalarGridInterp_2D_cpu – SELF","text":"public subroutine ScalarGridInterp_2D_cpu(myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Interpolation is applied using a series of matrix-vector multiplications, using\nthe Lagrange class's interpolation matrix Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid Contents Source Code ScalarGridInterp_2D_cpu Source Code SUBROUTINE ScalarGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) !! Host (CPU) implementation of the ScalarGridInterp_2D interface. !! In most cases, you should use the `ScalarGridInterp_2D` generic interface, !! rather than calling this routine directly. !! Interpolate a scalar-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) !! (Input) Array of function values, defined on the control grid REAL ( prec ), INTENT ( out ) :: fNew ( 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) !! (Output) Array of function values, defined on the target grid ! Local INTEGER :: i , j , ii , jj , iEl , iVar REAL ( prec ) :: fi , fij DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fij = 0.0_prec DO jj = 0 , myPoly % N fi = 0.0_prec DO ii = 0 , myPoly % N fi = fi + f ( ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij = fij + fi * myPoly % iMatrix % hostData ( jj , j ) END DO fNew ( i , j , iVar , iEl ) = fij END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_2D_cpu","tags":"","loc":"proc/scalargridinterp_2d_cpu.html"},{"title":"ScalarGridInterp_2D_gpu – SELF","text":"public subroutine ScalarGridInterp_2D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_2D_gpu_wrapper\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Interpolation is applied using a series of matrix-vector multiplications, using\nthe Lagrange class's interpolation matrix Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid Calls proc~~scalargridinterp_2d_gpu~~CallsGraph proc~scalargridinterp_2d_gpu ScalarGridInterp_2D_gpu interface~scalargridinterp_2d_gpu_wrapper ScalarGridInterp_2D_gpu_wrapper proc~scalargridinterp_2d_gpu->interface~scalargridinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarGridInterp_2D_gpu Source Code SUBROUTINE ScalarGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) !! Device (GPU) implementation of the ScalarGridInterp_2D interface. !! In most cases, you should use the `ScalarGridInterp_2D` generic interface, !! rather than calling this routine directly. !! This routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_2D_gpu_wrapper !! Interpolate a scalar-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid TYPE ( c_ptr ), INTENT ( in ) :: f_dev !! (Input) Array of function values, defined on the control grid TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev !! (Output) Array of function values, defined on the target grid CALL ScalarGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE ScalarGridInterp_2D_gpu","tags":"","loc":"proc/scalargridinterp_2d_gpu.html"},{"title":"ScalarGridInterp_3D_cpu – SELF","text":"public subroutine ScalarGridInterp_3D_cpu(myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarGridInterp_3D_cpu Source Code SUBROUTINE ScalarGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi , fij , fijk DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fijk = 0.0_prec DO kk = 0 , myPoly % N fij = 0.0_prec DO jj = 0 , myPoly % N fi = 0.0_prec DO ii = 0 , myPoly % N fi = fi + f ( ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij = fij + fi * myPoly % iMatrix % hostData ( jj , j ) END DO fijk = fijk + fij * myPoly % iMatrix % hostData ( kk , k ) END DO fInterp ( i , j , k , iVar , iEl ) = fijk END DO END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_3D_cpu","tags":"","loc":"proc/scalargridinterp_3d_cpu.html"},{"title":"ScalarGridInterp_3D_gpu – SELF","text":"public subroutine ScalarGridInterp_3D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalargridinterp_3d_gpu~~CallsGraph proc~scalargridinterp_3d_gpu ScalarGridInterp_3D_gpu interface~scalargridinterp_3d_gpu_wrapper ScalarGridInterp_3D_gpu_wrapper proc~scalargridinterp_3d_gpu->interface~scalargridinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarGridInterp_3D_gpu Source Code SUBROUTINE ScalarGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev CALL ScalarGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE ScalarGridInterp_3D_gpu","tags":"","loc":"proc/scalargridinterp_3d_gpu.html"},{"title":"TensorBoundaryInterp_2D_cpu – SELF","text":"public subroutine TensorBoundaryInterp_2D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorBoundaryInterp_2D_cpu Source Code SUBROUTINE TensorBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , ii , idir , jdir , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 , 1 : 2 , 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 2 , 1 : 2 , 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N DO jdir = 1 , 2 DO idir = 1 , 2 fb ( idir , jdir , 1 ) = fb ( idir , jdir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , ii , iVar , iEl ) ! South fb ( idir , jdir , 2 ) = fb ( idir , jdir , 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , ii , i , iVar , iEl ) ! East fb ( idir , jdir , 3 ) = fb ( idir , jdir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , ii , iVar , iEl ) ! North fb ( idir , jdir , 4 ) = fb ( idir , jdir , 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , ii , i , iVar , iEl ) ! West END DO END DO END DO DO jdir = 1 , 2 DO idir = 1 , 2 fBound ( idir , jdir , i , iVar , 1 : 4 , iEl ) = fb ( idir , jdir , 1 : 4 ) END DO END DO END DO END DO END DO END SUBROUTINE TensorBoundaryInterp_2D_cpu","tags":"","loc":"proc/tensorboundaryinterp_2d_cpu.html"},{"title":"TensorBoundaryInterp_2D_gpu – SELF","text":"public subroutine TensorBoundaryInterp_2D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~tensorboundaryinterp_2d_gpu~~CallsGraph proc~tensorboundaryinterp_2d_gpu TensorBoundaryInterp_2D_gpu interface~tensorboundaryinterp_2d_gpu_wrapper TensorBoundaryInterp_2D_gpu_wrapper proc~tensorboundaryinterp_2d_gpu->interface~tensorboundaryinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorBoundaryInterp_2D_gpu Source Code SUBROUTINE TensorBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL TensorBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE TensorBoundaryInterp_2D_gpu","tags":"","loc":"proc/tensorboundaryinterp_2d_gpu.html"},{"title":"TensorBoundaryInterp_3D_cpu – SELF","text":"public subroutine TensorBoundaryInterp_3D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorBoundaryInterp_3D_cpu Source Code SUBROUTINE TensorBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , jdir , iVar , iEl REAL ( prec ) :: fb ( 1 : 3 , 1 : 3 , 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 3 , 1 : 3 , 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N DO jdir = 1 , 3 DO idir = 1 , 3 fb ( idir , jdir , 1 ) = fb ( idir , jdir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , j , ii , iVar , iEl ) ! Bottom fb ( idir , jdir , 2 ) = fb ( idir , jdir , 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , ii , j , iVar , iEl ) ! South fb ( idir , jdir , 3 ) = fb ( idir , jdir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , ii , i , j , iVar , iEl ) ! East fb ( idir , jdir , 4 ) = fb ( idir , jdir , 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , ii , j , iVar , iEl ) ! North fb ( idir , jdir , 5 ) = fb ( idir , jdir , 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , ii , i , j , iVar , iEl ) ! West fb ( idir , jdir , 6 ) = fb ( idir , jdir , 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , j , ii , iVar , iEl ) ! Top END DO END DO END DO DO jdir = 1 , 3 DO idir = 1 , 3 fBound ( idir , jdir , i , j , iVar , 1 : 6 , iEl ) = fb ( idir , jdir , 1 : 6 ) END DO END DO END DO END DO END DO END DO END SUBROUTINE TensorBoundaryInterp_3D_cpu","tags":"","loc":"proc/tensorboundaryinterp_3d_cpu.html"},{"title":"TensorBoundaryInterp_3D_gpu – SELF","text":"public subroutine TensorBoundaryInterp_3D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~tensorboundaryinterp_3d_gpu~~CallsGraph proc~tensorboundaryinterp_3d_gpu TensorBoundaryInterp_3D_gpu interface~tensorboundaryinterp_3d_gpu_wrapper TensorBoundaryInterp_3D_gpu_wrapper proc~tensorboundaryinterp_3d_gpu->interface~tensorboundaryinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorBoundaryInterp_3D_gpu Source Code SUBROUTINE TensorBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL TensorBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE TensorBoundaryInterp_3D_gpu","tags":"","loc":"proc/tensorboundaryinterp_3d_gpu.html"},{"title":"TensorDGDivergence_2D_cpu – SELF","text":"public subroutine TensorDGDivergence_2D_cpu(myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorDGDivergence_2D_cpu Source Code SUBROUTINE TensorDGDivergence_2D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = dF ( 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , iVar , iEl ) dF ( 2 , i , j , iVar , iEl ) = dF ( 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , iVar , iEl ) END DO dF ( 1 , i , j , iVar , iEl ) = dF ( 1 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 1 , 1 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 1 , 1 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 2 , 1 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 2 , 1 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) dF ( 2 , i , j , iVar , iEl ) = dF ( 2 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 1 , 2 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 1 , 2 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 2 , 2 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 2 , 2 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE TensorDGDivergence_2D_cpu","tags":"","loc":"proc/tensordgdivergence_2d_cpu.html"},{"title":"TensorDGDivergence_2D_gpu – SELF","text":"public subroutine TensorDGDivergence_2D_gpu(myPoly, f_dev, bf_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~tensordgdivergence_2d_gpu~~CallsGraph proc~tensordgdivergence_2d_gpu TensorDGDivergence_2D_gpu interface~tensordgdivergence_2d_gpu_wrapper TensorDGDivergence_2D_gpu_wrapper proc~tensordgdivergence_2d_gpu->interface~tensordgdivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorDGDivergence_2D_gpu Source Code SUBROUTINE TensorDGDivergence_2D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL TensorDGDivergence_2D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE TensorDGDivergence_2D_gpu","tags":"","loc":"proc/tensordgdivergence_2d_gpu.html"},{"title":"TensorDGDivergence_3D_cpu – SELF","text":"public subroutine TensorDGDivergence_3D_cpu(myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorDGDivergence_3D_cpu Source Code SUBROUTINE TensorDGDivergence_3D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bF ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , 1 , i , j , ii , iVar , iEl ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , 2 , i , j , ii , iVar , iEl ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 3 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 3 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , 3 , i , j , ii , iVar , iEl ) END DO dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , 1 , j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , 1 , j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , 1 , i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , 1 , i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( 3 , 1 , i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( 3 , 1 , i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , 2 , j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , 2 , j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , 2 , i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , 2 , i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( 3 , 2 , i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( 3 , 2 , i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , 3 , j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , 3 , j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , 3 , i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , 3 , i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( 3 , 3 , i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( 3 , 3 , i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) END DO END DO END DO END DO END DO END SUBROUTINE TensorDGDivergence_3D_cpu","tags":"","loc":"proc/tensordgdivergence_3d_cpu.html"},{"title":"TensorDGDivergence_3D_gpu – SELF","text":"public subroutine TensorDGDivergence_3D_gpu(myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~tensordgdivergence_3d_gpu~~CallsGraph proc~tensordgdivergence_3d_gpu TensorDGDivergence_3D_gpu interface~tensordgdivergence_3d_gpu_wrapper TensorDGDivergence_3D_gpu_wrapper proc~tensordgdivergence_3d_gpu->interface~tensordgdivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorDGDivergence_3D_gpu Source Code SUBROUTINE TensorDGDivergence_3D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL TensorDGDivergence_3D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE TensorDGDivergence_3D_gpu","tags":"","loc":"proc/tensordgdivergence_3d_gpu.html"},{"title":"TensorDivergence_2D_cpu – SELF","text":"public subroutine TensorDivergence_2D_cpu(myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorDivergence_2D_cpu Source Code SUBROUTINE TensorDivergence_2D_cpu ( myPoly , f , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = dF ( 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , iVar , iEl ) dF ( 2 , i , j , iVar , iEl ) = dF ( 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE TensorDivergence_2D_cpu","tags":"","loc":"proc/tensordivergence_2d_cpu.html"},{"title":"TensorDivergence_2D_gpu – SELF","text":"public subroutine TensorDivergence_2D_gpu(myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~tensordivergence_2d_gpu~~CallsGraph proc~tensordivergence_2d_gpu TensorDivergence_2D_gpu interface~tensordivergence_2d_gpu_wrapper TensorDivergence_2D_gpu_wrapper proc~tensordivergence_2d_gpu->interface~tensordivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorDivergence_2D_gpu Source Code SUBROUTINE TensorDivergence_2D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL TensorDivergence_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE TensorDivergence_2D_gpu","tags":"","loc":"proc/tensordivergence_2d_gpu.html"},{"title":"TensorDivergence_3D_cpu – SELF","text":"public subroutine TensorDivergence_3D_cpu(myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorDivergence_3D_cpu Source Code SUBROUTINE TensorDivergence_3D_cpu ( myPoly , f , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , 1 , i , j , ii , iVar , iEl ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , 2 , i , j , ii , iVar , iEl ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 3 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 3 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , 3 , i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE TensorDivergence_3D_cpu","tags":"","loc":"proc/tensordivergence_3d_cpu.html"},{"title":"TensorDivergence_3D_gpu – SELF","text":"public subroutine TensorDivergence_3D_gpu(myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~tensordivergence_3d_gpu~~CallsGraph proc~tensordivergence_3d_gpu TensorDivergence_3D_gpu interface~tensordivergence_3d_gpu_wrapper TensorDivergence_3D_gpu_wrapper proc~tensordivergence_3d_gpu->interface~tensordivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorDivergence_3D_gpu Source Code SUBROUTINE TensorDivergence_3D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL TensorDivergence_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE TensorDivergence_3D_gpu","tags":"","loc":"proc/tensordivergence_3d_gpu.html"},{"title":"TensorGridInterp_2D_cpu – SELF","text":"public subroutine TensorGridInterp_2D_cpu(myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the TensorGridInterp_2D interface.\nIn most cases, you should use the TensorGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a tensor-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Interpolation is applied using a series of matrix-tensor multiplications, using\nthe Lagrange class's interpolation matrix Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (1:2,1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid Contents Source Code TensorGridInterp_2D_cpu Source Code SUBROUTINE TensorGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) !! Host (CPU) implementation of the TensorGridInterp_2D interface. !! In most cases, you should use the `TensorGridInterp_2D` generic interface, !! rather than calling this routine directly. !! Interpolate a tensor-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-tensor multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{row,col,m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{row,col,i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) !! (Input) Array of function values, defined on the control grid REAL ( prec ), INTENT ( out ) :: fNew ( 1 : 2 , 1 : 2 , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) !! (Output) Array of function values, defined on the target grid ! Local INTEGER :: i , j , ii , jj , iEl , iVar REAL ( prec ) :: fi ( 1 : 2 , 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fNew ( 1 : 2 , 1 : 2 , i , j , iVar , iEl ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 2 , 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 2 , 1 : 2 ) = fi ( 1 : 2 , 1 : 2 ) + f ( 1 : 2 , 1 : 2 , ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fNew ( 1 : 2 , 1 : 2 , i , j , iVar , iEl ) = fNew ( 1 : 2 , 1 : 2 , i , j , iVar , iEl ) + fi ( 1 : 2 , 1 : 2 ) * myPoly % iMatrix % hostData ( jj , j ) END DO END DO END DO END DO END DO END SUBROUTINE TensorGridInterp_2D_cpu","tags":"","loc":"proc/tensorgridinterp_2d_cpu.html"},{"title":"TensorGridInterp_2D_gpu – SELF","text":"public subroutine TensorGridInterp_2D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the TensorGridInterp_2D interface.\nIn most cases, you should use the TensorGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:TensorGridInterp_2D_gpu_wrapper\nInterpolate a tensor-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Interpolation is applied using a series of matrix-vector multiplications, using\nthe Lagrange class's interpolation matrix Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid Calls proc~~tensorgridinterp_2d_gpu~~CallsGraph proc~tensorgridinterp_2d_gpu TensorGridInterp_2D_gpu interface~tensorgridinterp_2d_gpu_wrapper TensorGridInterp_2D_gpu_wrapper proc~tensorgridinterp_2d_gpu->interface~tensorgridinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorGridInterp_2D_gpu Source Code SUBROUTINE TensorGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) !! Device (GPU) implementation of the TensorGridInterp_2D interface. !! In most cases, you should use the `TensorGridInterp_2D` generic interface, !! rather than calling this routine directly. !! This routine calls hip/SELF_Lagrange.cpp:TensorGridInterp_2D_gpu_wrapper !! Interpolate a tensor-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{row,col,m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{row,col,i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid TYPE ( c_ptr ), INTENT ( in ) :: f_dev !! (Input) Array of function values, defined on the control grid TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev !! (Output) Array of function values, defined on the target grid CALL TensorGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE TensorGridInterp_2D_gpu","tags":"","loc":"proc/tensorgridinterp_2d_gpu.html"},{"title":"TensorGridInterp_3D_cpu – SELF","text":"public subroutine TensorGridInterp_3D_cpu(myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorGridInterp_3D_cpu Source Code SUBROUTINE TensorGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 1 : 3 , 1 : 3 , 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi ( 1 : 3 , 1 : 3 ), fij ( 1 : 3 , 1 : 3 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fInterp ( 1 : 3 , 1 : 3 , i , j , k , iVar , iEl ) = 0.0_prec DO kk = 0 , myPoly % N fij ( 1 : 3 , 1 : 3 ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 3 , 1 : 3 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 3 , 1 : 3 ) = fi ( 1 : 3 , 1 : 3 ) + f ( 1 : 3 , 1 : 3 , ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij ( 1 : 3 , 1 : 3 ) = fij ( 1 : 3 , 1 : 3 ) + fi ( 1 : 3 , 1 : 3 ) * myPoly % iMatrix % hostData ( jj , j ) END DO fInterp ( 1 : 3 , 1 : 3 , i , j , k , iVar , iEl ) = fInterp ( 1 : 3 , 1 : 3 , i , j , k , iVar , iEl ) + & fij ( 1 : 3 , 1 : 3 ) * myPoly % iMatrix % hostData ( kk , k ) END DO END DO END DO END DO END DO END DO END SUBROUTINE TensorGridInterp_3D_cpu","tags":"","loc":"proc/tensorgridinterp_3d_cpu.html"},{"title":"TensorGridInterp_3D_gpu – SELF","text":"public subroutine TensorGridInterp_3D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~tensorgridinterp_3d_gpu~~CallsGraph proc~tensorgridinterp_3d_gpu TensorGridInterp_3D_gpu interface~tensorgridinterp_3d_gpu_wrapper TensorGridInterp_3D_gpu_wrapper proc~tensorgridinterp_3d_gpu->interface~tensorgridinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorGridInterp_3D_gpu Source Code SUBROUTINE TensorGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev CALL TensorGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE TensorGridInterp_3D_gpu","tags":"","loc":"proc/tensorgridinterp_3d_gpu.html"},{"title":"UpdateDevice_Lagrange – SELF","text":"public subroutine UpdateDevice_Lagrange(myPoly) Copy the Lagrange attributes from the host (CPU) to the device (GPU) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance Contents Source Code UpdateDevice_Lagrange Source Code SUBROUTINE UpdateDevice_Lagrange ( myPoly ) !! Copy the Lagrange attributes from the host (CPU) to the device (GPU) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly !! Lagrange class instance CALL myPoly % controlPoints % UpdateDevice () CALL myPoly % targetPoints % UpdateDevice () CALL myPoly % bWeights % UpdateDevice () CALL myPoly % qWeights % UpdateDevice () CALL myPoly % iMatrix % UpdateDevice () CALL myPoly % dMatrix % UpdateDevice () CALL myPoly % dgMatrix % UpdateDevice () CALL myPoly % bMatrix % UpdateDevice () END SUBROUTINE UpdateDevice_Lagrange","tags":"","loc":"proc/updatedevice_lagrange.html"},{"title":"UpdateHost_Lagrange – SELF","text":"public subroutine UpdateHost_Lagrange(myPoly) Copy the Lagrange attributes from the device (GPU) to the host (CPU) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance Contents Source Code UpdateHost_Lagrange Source Code SUBROUTINE UpdateHost_Lagrange ( myPoly ) !! Copy the Lagrange attributes from the device (GPU) to the host (CPU) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly !! Lagrange class instance CALL myPoly % controlPoints % UpdateHost () CALL myPoly % targetPoints % UpdateHost () CALL myPoly % bWeights % UpdateHost () CALL myPoly % qWeights % UpdateHost () CALL myPoly % iMatrix % UpdateHost () CALL myPoly % dMatrix % UpdateHost () CALL myPoly % dgMatrix % UpdateHost () CALL myPoly % bMatrix % UpdateHost () END SUBROUTINE UpdateHost_Lagrange","tags":"","loc":"proc/updatehost_lagrange.html"},{"title":"VectorBoundaryInterp_2D_cpu – SELF","text":"public subroutine VectorBoundaryInterp_2D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorBoundaryInterp_2D_cpu Source Code SUBROUTINE VectorBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , ii , idir , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 , 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 2 , 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N DO idir = 1 , 2 fb ( idir , 1 ) = fb ( idir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , ii , iVar , iEl ) ! South fb ( idir , 2 ) = fb ( idir , 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , ii , i , iVar , iEl ) ! East fb ( idir , 3 ) = fb ( idir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , ii , iVar , iEl ) ! North fb ( idir , 4 ) = fb ( idir , 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , ii , i , iVar , iEl ) ! West END DO END DO DO idir = 1 , 2 fBound ( idir , i , iVar , 1 : 4 , iEl ) = fb ( idir , 1 : 4 ) END DO END DO END DO END DO END SUBROUTINE VectorBoundaryInterp_2D_cpu","tags":"","loc":"proc/vectorboundaryinterp_2d_cpu.html"},{"title":"VectorBoundaryInterp_2D_gpu – SELF","text":"public subroutine VectorBoundaryInterp_2D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectorboundaryinterp_2d_gpu~~CallsGraph proc~vectorboundaryinterp_2d_gpu VectorBoundaryInterp_2D_gpu interface~vectorboundaryinterp_2d_gpu_wrapper VectorBoundaryInterp_2D_gpu_wrapper proc~vectorboundaryinterp_2d_gpu->interface~vectorboundaryinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorBoundaryInterp_2D_gpu Source Code SUBROUTINE VectorBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL VectorBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE VectorBoundaryInterp_2D_gpu","tags":"","loc":"proc/vectorboundaryinterp_2d_gpu.html"},{"title":"VectorBoundaryInterp_3D_cpu – SELF","text":"public subroutine VectorBoundaryInterp_3D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorBoundaryInterp_3D_cpu Source Code SUBROUTINE VectorBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , iVar , iEl REAL ( prec ) :: fb ( 1 : 3 , 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 3 , 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N DO idir = 1 , 3 fb ( idir , 1 ) = fb ( idir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , j , ii , iVar , iEl ) ! Bottom fb ( idir , 2 ) = fb ( idir , 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , ii , j , iVar , iEl ) ! South fb ( idir , 3 ) = fb ( idir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , ii , i , j , iVar , iEl ) ! East fb ( idir , 4 ) = fb ( idir , 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , ii , j , iVar , iEl ) ! North fb ( idir , 5 ) = fb ( idir , 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , ii , i , j , iVar , iEl ) ! West fb ( idir , 6 ) = fb ( idir , 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , j , ii , iVar , iEl ) ! Top END DO END DO DO idir = 1 , 3 fBound ( idir , i , j , iVar , 1 : 6 , iEl ) = fb ( idir , 1 : 6 ) END DO END DO END DO END DO END DO END SUBROUTINE VectorBoundaryInterp_3D_cpu","tags":"","loc":"proc/vectorboundaryinterp_3d_cpu.html"},{"title":"VectorBoundaryInterp_3D_gpu – SELF","text":"public subroutine VectorBoundaryInterp_3D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectorboundaryinterp_3d_gpu~~CallsGraph proc~vectorboundaryinterp_3d_gpu VectorBoundaryInterp_3D_gpu interface~vectorboundaryinterp_3d_gpu_wrapper VectorBoundaryInterp_3D_gpu_wrapper proc~vectorboundaryinterp_3d_gpu->interface~vectorboundaryinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorBoundaryInterp_3D_gpu Source Code SUBROUTINE VectorBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound CALL VectorBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) END SUBROUTINE VectorBoundaryInterp_3D_gpu","tags":"","loc":"proc/vectorboundaryinterp_3d_gpu.html"},{"title":"VectorCurl_2D_cpu – SELF","text":"public subroutine VectorCurl_2D_cpu(myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorCurl_2D_cpu Source Code SUBROUTINE VectorCurl_2D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE VectorCurl_2D_cpu","tags":"","loc":"proc/vectorcurl_2d_cpu.html"},{"title":"VectorCurl_2D_gpu – SELF","text":"public subroutine VectorCurl_2D_gpu(myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectorcurl_2d_gpu~~CallsGraph proc~vectorcurl_2d_gpu VectorCurl_2D_gpu interface~vectorcurl_2d_gpu_wrapper VectorCurl_2D_gpu_wrapper proc~vectorcurl_2d_gpu->interface~vectorcurl_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorCurl_2D_gpu Source Code SUBROUTINE VectorCurl_2D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorCurl_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorCurl_2D_gpu","tags":"","loc":"proc/vectorcurl_2d_gpu.html"},{"title":"VectorCurl_3D_cpu – SELF","text":"public subroutine VectorCurl_3D_cpu(myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorCurl_3D_cpu Source Code SUBROUTINE VectorCurl_3D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 3 , i , ii , k , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , k ) * f ( 2 , i , j , ii , iVar , iEl ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , k ) * f ( 1 , i , j , ii , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , i ) * f ( 3 , ii , j , k , iVar , iEl ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , k , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , k , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorCurl_3D_cpu","tags":"","loc":"proc/vectorcurl_3d_cpu.html"},{"title":"VectorCurl_3D_gpu – SELF","text":"public subroutine VectorCurl_3D_gpu(myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectorcurl_3d_gpu~~CallsGraph proc~vectorcurl_3d_gpu VectorCurl_3D_gpu interface~vectorcurl_3d_gpu_wrapper VectorCurl_3D_gpu_wrapper proc~vectorcurl_3d_gpu->interface~vectorcurl_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorCurl_3D_gpu Source Code SUBROUTINE VectorCurl_3D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorCurl_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorCurl_3D_gpu","tags":"","loc":"proc/vectorcurl_3d_gpu.html"},{"title":"VectorDGDivergence_2D_cpu – SELF","text":"public subroutine VectorDGDivergence_2D_cpu(myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDGDivergence_2D_cpu Source Code SUBROUTINE VectorDGDivergence_2D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Assumes bF is the vector component in the direction normal to the boundary IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bF ( 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bF ( j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bF ( i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE VectorDGDivergence_2D_cpu","tags":"","loc":"proc/vectordgdivergence_2d_cpu.html"},{"title":"VectorDGDivergence_2D_gpu – SELF","text":"public subroutine VectorDGDivergence_2D_gpu(myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectordgdivergence_2d_gpu~~CallsGraph proc~vectordgdivergence_2d_gpu VectorDGDivergence_2D_gpu interface~vectordgdivergence_2d_gpu_wrapper VectorDGDivergence_2D_gpu_wrapper proc~vectordgdivergence_2d_gpu->interface~vectordgdivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorDGDivergence_2D_gpu Source Code SUBROUTINE VectorDGDivergence_2D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDGDivergence_2D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDGDivergence_2D_gpu","tags":"","loc":"proc/vectordgdivergence_2d_gpu.html"},{"title":"VectorDGDivergence_3D_cpu – SELF","text":"public subroutine VectorDGDivergence_3D_cpu(myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDGDivergence_3D_cpu Source Code SUBROUTINE VectorDGDivergence_3D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Assumes bF is the vector component in the direction normal to the element boundaries IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) END DO END DO END DO END DO END DO END SUBROUTINE VectorDGDivergence_3D_cpu","tags":"","loc":"proc/vectordgdivergence_3d_cpu.html"},{"title":"VectorDGDivergence_3D_gpu – SELF","text":"public subroutine VectorDGDivergence_3D_gpu(myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectordgdivergence_3d_gpu~~CallsGraph proc~vectordgdivergence_3d_gpu VectorDGDivergence_3D_gpu interface~vectordgdivergence_3d_gpu_wrapper VectorDGDivergence_3D_gpu_wrapper proc~vectordgdivergence_3d_gpu->interface~vectordgdivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorDGDivergence_3D_gpu Source Code SUBROUTINE VectorDGDivergence_3D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDGDivergence_3D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDGDivergence_3D_gpu","tags":"","loc":"proc/vectordgdivergence_3d_gpu.html"},{"title":"VectorDGGradient_2D_cpu – SELF","text":"public subroutine VectorDGGradient_2D_cpu(myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDGGradient_2D_cpu Source Code SUBROUTINE VectorDGGradient_2D_cpu ( myPoly , f , bf , gradF , nVariables , nElements ) ! ! Input : Vector(1:2,...) ! Output : Tensor(1:2,1:2,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 1 , 2 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = gradF ( 1 , 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) gradF ( 2 , 1 , i , j , iVar , iEl ) = gradF ( 2 , 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 2 , ii , j , iVar , iEl ) gradF ( 1 , 2 , i , j , iVar , iEl ) = gradF ( 1 , 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , j ) * f ( 1 , i , ii , iVar , iEl ) gradF ( 2 , 2 , i , j , iVar , iEl ) = gradF ( 2 , 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO gradF ( 1 , 1 , i , j , iVar , iEl ) = gradF ( 1 , 1 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 1 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 1 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) gradF ( 2 , 1 , i , j , iVar , iEl ) = gradF ( 2 , 1 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 2 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 2 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) gradF ( 1 , 2 , i , j , iVar , iEl ) = gradF ( 1 , 2 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 1 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 1 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) gradF ( 2 , 2 , i , j , iVar , iEl ) = gradF ( 2 , 2 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 2 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 2 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE VectorDGGradient_2D_cpu","tags":"","loc":"proc/vectordggradient_2d_cpu.html"},{"title":"VectorDGGradient_2D_gpu – SELF","text":"public subroutine VectorDGGradient_2D_gpu(myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectordggradient_2d_gpu~~CallsGraph proc~vectordggradient_2d_gpu VectorDGGradient_2D_gpu interface~vectordggradient_2d_gpu_wrapper VectorDGGradient_2D_gpu_wrapper proc~vectordggradient_2d_gpu->interface~vectordggradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorDGGradient_2D_gpu Source Code SUBROUTINE VectorDGGradient_2D_gpu ( myPoly , f_dev , bf_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL VectorDGGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bf_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDGGradient_2D_gpu","tags":"","loc":"proc/vectordggradient_2d_gpu.html"},{"title":"VectorDivergence_2D_cpu – SELF","text":"public subroutine VectorDivergence_2D_cpu(myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDivergence_2D_cpu Source Code SUBROUTINE VectorDivergence_2D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE VectorDivergence_2D_cpu","tags":"","loc":"proc/vectordivergence_2d_cpu.html"},{"title":"VectorDivergence_2D_gpu – SELF","text":"public subroutine VectorDivergence_2D_gpu(myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectordivergence_2d_gpu~~CallsGraph proc~vectordivergence_2d_gpu VectorDivergence_2D_gpu interface~vectordivergence_2d_gpu_wrapper VectorDivergence_2D_gpu_wrapper proc~vectordivergence_2d_gpu->interface~vectordivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorDivergence_2D_gpu Source Code SUBROUTINE VectorDivergence_2D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDivergence_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDivergence_2D_gpu","tags":"","loc":"proc/vectordivergence_2d_gpu.html"},{"title":"VectorDivergence_3D_cpu – SELF","text":"public subroutine VectorDivergence_3D_cpu(myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDivergence_3D_cpu Source Code SUBROUTINE VectorDivergence_3D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorDivergence_3D_cpu","tags":"","loc":"proc/vectordivergence_3d_cpu.html"},{"title":"VectorDivergence_3D_gpu – SELF","text":"public subroutine VectorDivergence_3D_gpu(myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectordivergence_3d_gpu~~CallsGraph proc~vectordivergence_3d_gpu VectorDivergence_3D_gpu interface~vectordivergence_3d_gpu_wrapper VectorDivergence_3D_gpu_wrapper proc~vectordivergence_3d_gpu->interface~vectordivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorDivergence_3D_gpu Source Code SUBROUTINE VectorDivergence_3D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev CALL VectorDivergence_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorDivergence_3D_gpu","tags":"","loc":"proc/vectordivergence_3d_gpu.html"},{"title":"VectorGradient_2D_cpu – SELF","text":"public subroutine VectorGradient_2D_cpu(myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorGradient_2D_cpu Source Code SUBROUTINE VectorGradient_2D_cpu ( myPoly , f , gradF , nVariables , nElements ) ! ! Input : Vector(1:2,...) ! Output : Tensor(1:2,1:2,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 1 , 2 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = gradF ( 1 , 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) gradF ( 2 , 1 , i , j , iVar , iEl ) = gradF ( 2 , 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , iVar , iEl ) gradF ( 1 , 2 , i , j , iVar , iEl ) = gradF ( 1 , 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , iVar , iEl ) gradF ( 2 , 2 , i , j , iVar , iEl ) = gradF ( 2 , 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE VectorGradient_2D_cpu","tags":"","loc":"proc/vectorgradient_2d_cpu.html"},{"title":"VectorGradient_2D_gpu – SELF","text":"public subroutine VectorGradient_2D_gpu(myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectorgradient_2d_gpu~~CallsGraph proc~vectorgradient_2d_gpu VectorGradient_2D_gpu interface~vectorgradient_2d_gpu_wrapper VectorGradient_2D_gpu_wrapper proc~vectorgradient_2d_gpu->interface~vectorgradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorGradient_2D_gpu Source Code SUBROUTINE VectorGradient_2D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL VectorGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorGradient_2D_gpu","tags":"","loc":"proc/vectorgradient_2d_gpu.html"},{"title":"VectorGradient_3D_cpu – SELF","text":"public subroutine VectorGradient_3D_cpu(myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorGradient_3D_cpu Source Code SUBROUTINE VectorGradient_3D_cpu ( myPoly , f , gradF , nVariables , nElements ) ! ! Input : Vector(1:3,...) ! Output : Tensor(1:3,1:3,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(3,1) = d/ds1( Vector(3,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) !          > Tensor(3,2) = d/ds2( Vector(3,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 1 , 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 1 , 3 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , 3 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , 1 , i , j , k , iVar , iEl ) = gradF ( 1 , 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) gradF ( 2 , 1 , i , j , k , iVar , iEl ) = gradF ( 2 , 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , k , iVar , iEl ) gradF ( 3 , 1 , i , j , k , iVar , iEl ) = gradF ( 3 , 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 3 , ii , j , k , iVar , iEl ) gradF ( 1 , 2 , i , j , k , iVar , iEl ) = gradF ( 1 , 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , k , iVar , iEl ) gradF ( 2 , 2 , i , j , k , iVar , iEl ) = gradF ( 2 , 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) gradF ( 3 , 2 , i , j , k , iVar , iEl ) = gradF ( 3 , 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 3 , i , ii , k , iVar , iEl ) gradF ( 1 , 3 , i , j , k , iVar , iEl ) = gradF ( 1 , 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 1 , i , j , ii , iVar , iEl ) gradF ( 2 , 3 , i , j , k , iVar , iEl ) = gradF ( 2 , 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 2 , i , j , ii , iVar , iEl ) gradF ( 3 , 3 , i , j , k , iVar , iEl ) = gradF ( 3 , 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorGradient_3D_cpu","tags":"","loc":"proc/vectorgradient_3d_cpu.html"},{"title":"VectorGradient_3D_gpu – SELF","text":"public subroutine VectorGradient_3D_gpu(myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectorgradient_3d_gpu~~CallsGraph proc~vectorgradient_3d_gpu VectorGradient_3D_gpu interface~vectorgradient_3d_gpu_wrapper VectorGradient_3D_gpu_wrapper proc~vectorgradient_3d_gpu->interface~vectorgradient_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorGradient_3D_gpu Source Code SUBROUTINE VectorGradient_3D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev CALL VectorGradient_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) END SUBROUTINE VectorGradient_3D_gpu","tags":"","loc":"proc/vectorgradient_3d_gpu.html"},{"title":"VectorGridInterp_2D_cpu – SELF","text":"public subroutine VectorGridInterp_2D_cpu(myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Interpolation is applied using a series of matrix-vector multiplications, using\nthe Lagrange class's interpolation matrix Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid Contents Source Code VectorGridInterp_2D_cpu Source Code SUBROUTINE VectorGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) !! Host (CPU) implementation of the VectorGridInterp_2D interface. !! In most cases, you should use the `VectorGridInterp_2D` generic interface, !! rather than calling this routine directly. !! Interpolate a vector-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{dir,m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{dir,i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) !! (Input) Array of function values, defined on the control grid REAL ( prec ), INTENT ( out ) :: fNew ( 1 : 2 , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) !! (Output) Array of function values, defined on the target grid ! Local INTEGER :: i , j , ii , jj , iEl , iVar REAL ( prec ) :: fi ( 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fNew ( 1 , i , j , iVar , iEl ) = 0.0_prec fNew ( 2 , i , j , iVar , iEl ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 2 ) = fi ( 1 : 2 ) + f ( 1 : 2 , ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fNew ( 1 : 2 , i , j , iVar , iEl ) = fNew ( 1 : 2 , i , j , iVar , iEl ) + fi ( 1 : 2 ) * myPoly % iMatrix % hostData ( jj , j ) END DO END DO END DO END DO END DO END SUBROUTINE VectorGridInterp_2D_cpu","tags":"","loc":"proc/vectorgridinterp_2d_cpu.html"},{"title":"VectorGridInterp_2D_gpu – SELF","text":"public subroutine VectorGridInterp_2D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:VectorGridInterp_2D_gpu_wrapper\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Interpolation is applied using a series of matrix-vector multiplications, using\nthe Lagrange class's interpolation matrix Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid Calls proc~~vectorgridinterp_2d_gpu~~CallsGraph proc~vectorgridinterp_2d_gpu VectorGridInterp_2D_gpu interface~vectorgridinterp_2d_gpu_wrapper VectorGridInterp_2D_gpu_wrapper proc~vectorgridinterp_2d_gpu->interface~vectorgridinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorGridInterp_2D_gpu Source Code SUBROUTINE VectorGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) !! Device (GPU) implementation of the VectorGridInterp_2D interface. !! In most cases, you should use the `VectorGridInterp_2D` generic interface, !! rather than calling this routine directly. !! This routine calls hip/SELF_Lagrange.cpp:VectorGridInterp_2D_gpu_wrapper !! Interpolate a vector-2D (real) array from the control grid to the target grid. !! The control and target grids are the ones associated with an initialized !! Lagrange instance. !! !! Interpolation is applied using a series of matrix-vector multiplications, using !! the Lagrange class's interpolation matrix !! !!  \\tilde{f}_{dir,m,n,ivar,iel} = \\sum_{j=0}&#94;N \\sum_{i=0}&#94;N f_{dir,i,j,ivar,iel} I_{i,m} I_{j,n}  !! IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly !! Lagrange class instance INTEGER , INTENT ( in ) :: nVariables !! The number of variables/functions that are interpolated INTEGER , INTENT ( in ) :: nElements !! The number of spectral elements in the SEM grid TYPE ( c_ptr ), INTENT ( in ) :: f_dev !! (Input) Array of function values, defined on the control grid TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev !! (Output) Array of function values, defined on the target grid CALL VectorGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE VectorGridInterp_2D_gpu","tags":"","loc":"proc/vectorgridinterp_2d_gpu.html"},{"title":"VectorGridInterp_3D_cpu – SELF","text":"public subroutine VectorGridInterp_3D_cpu(myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorGridInterp_3D_cpu Source Code SUBROUTINE VectorGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 1 : 3 , 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi ( 1 : 3 ), fij ( 1 : 3 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fInterp ( 1 : 3 , i , j , k , iVar , iEl ) = 0.0_prec DO kk = 0 , myPoly % N fij ( 1 : 3 ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 3 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 3 ) = fi ( 1 : 3 ) + f ( 1 : 3 , ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij ( 1 : 3 ) = fij ( 1 : 3 ) + fi ( 1 : 3 ) * myPoly % iMatrix % hostData ( jj , j ) END DO fInterp ( 1 : 3 , i , j , k , iVar , iEl ) = fInterp ( 1 : 3 , i , j , k , iVar , iEl ) + fij ( 1 : 3 ) * myPoly % iMatrix % hostData ( kk , k ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorGridInterp_3D_cpu","tags":"","loc":"proc/vectorgridinterp_3d_cpu.html"},{"title":"VectorGridInterp_3D_gpu – SELF","text":"public subroutine VectorGridInterp_3D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectorgridinterp_3d_gpu~~CallsGraph proc~vectorgridinterp_3d_gpu VectorGridInterp_3D_gpu interface~vectorgridinterp_3d_gpu_wrapper VectorGridInterp_3D_gpu_wrapper proc~vectorgridinterp_3d_gpu->interface~vectorgridinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorGridInterp_3D_gpu Source Code SUBROUTINE VectorGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev CALL VectorGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) END SUBROUTINE VectorGridInterp_3D_gpu","tags":"","loc":"proc/vectorgridinterp_3d_gpu.html"},{"title":"DGDerivative_1D_gpu_wrapper – SELF","text":"interface Called by interface~~dgderivative_1d_gpu_wrapper~~CalledByGraph interface~dgderivative_1d_gpu_wrapper DGDerivative_1D_gpu_wrapper proc~dgderivative_1d_gpu DGDerivative_1D_gpu proc~dgderivative_1d_gpu->interface~dgderivative_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine DGDerivative_1D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/dgderivative_1d_gpu_wrapper.html"},{"title":"Derivative_1D_gpu_wrapper – SELF","text":"interface Called by interface~~derivative_1d_gpu_wrapper~~CalledByGraph interface~derivative_1d_gpu_wrapper Derivative_1D_gpu_wrapper proc~derivative_1d_gpu Derivative_1D_gpu proc~derivative_1d_gpu->interface~derivative_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine Derivative_1D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/derivative_1d_gpu_wrapper.html"},{"title":"ScalarBoundaryInterp_1D_gpu_wrapper – SELF","text":"interface Called by interface~~scalarboundaryinterp_1d_gpu_wrapper~~CalledByGraph interface~scalarboundaryinterp_1d_gpu_wrapper ScalarBoundaryInterp_1D_gpu_wrapper proc~scalarboundaryinterp_1d_gpu ScalarBoundaryInterp_1D_gpu proc~scalarboundaryinterp_1d_gpu->interface~scalarboundaryinterp_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarBoundaryInterp_1D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalarboundaryinterp_1d_gpu_wrapper.html"},{"title":"ScalarBoundaryInterp_2D_gpu_wrapper – SELF","text":"interface Called by interface~~scalarboundaryinterp_2d_gpu_wrapper~~CalledByGraph interface~scalarboundaryinterp_2d_gpu_wrapper ScalarBoundaryInterp_2D_gpu_wrapper proc~scalarboundaryinterp_2d_gpu ScalarBoundaryInterp_2D_gpu proc~scalarboundaryinterp_2d_gpu->interface~scalarboundaryinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalarboundaryinterp_2d_gpu_wrapper.html"},{"title":"ScalarBoundaryInterp_3D_gpu_wrapper – SELF","text":"interface Called by interface~~scalarboundaryinterp_3d_gpu_wrapper~~CalledByGraph interface~scalarboundaryinterp_3d_gpu_wrapper ScalarBoundaryInterp_3D_gpu_wrapper proc~scalarboundaryinterp_3d_gpu ScalarBoundaryInterp_3D_gpu proc~scalarboundaryinterp_3d_gpu->interface~scalarboundaryinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalarboundaryinterp_3d_gpu_wrapper.html"},{"title":"ScalarDGGradient_2D_gpu_wrapper – SELF","text":"interface Called by interface~~scalardggradient_2d_gpu_wrapper~~CalledByGraph interface~scalardggradient_2d_gpu_wrapper ScalarDGGradient_2D_gpu_wrapper proc~scalardggradient_2d_gpu ScalarDGGradient_2D_gpu proc~scalardggradient_2d_gpu->interface~scalardggradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarDGGradient_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalardggradient_2d_gpu_wrapper.html"},{"title":"ScalarGradient_2D_gpu_wrapper – SELF","text":"interface Called by interface~~scalargradient_2d_gpu_wrapper~~CalledByGraph interface~scalargradient_2d_gpu_wrapper ScalarGradient_2D_gpu_wrapper proc~scalargradient_2d_gpu ScalarGradient_2D_gpu proc~scalargradient_2d_gpu->interface~scalargradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarGradient_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalargradient_2d_gpu_wrapper.html"},{"title":"ScalarGradient_3D_gpu_wrapper – SELF","text":"interface Called by interface~~scalargradient_3d_gpu_wrapper~~CalledByGraph interface~scalargradient_3d_gpu_wrapper ScalarGradient_3D_gpu_wrapper proc~scalargradient_3d_gpu ScalarGradient_3D_gpu proc~scalargradient_3d_gpu->interface~scalargradient_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarGradient_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalargradient_3d_gpu_wrapper.html"},{"title":"ScalarGridInterp_1D_gpu_wrapper – SELF","text":"interface Called by interface~~scalargridinterp_1d_gpu_wrapper~~CalledByGraph interface~scalargridinterp_1d_gpu_wrapper ScalarGridInterp_1D_gpu_wrapper proc~scalargridinterp_1d_gpu ScalarGridInterp_1D_gpu proc~scalargridinterp_1d_gpu->interface~scalargridinterp_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarGridInterp_1D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalargridinterp_1d_gpu_wrapper.html"},{"title":"ScalarGridInterp_2D_gpu_wrapper – SELF","text":"interface Called by interface~~scalargridinterp_2d_gpu_wrapper~~CalledByGraph interface~scalargridinterp_2d_gpu_wrapper ScalarGridInterp_2D_gpu_wrapper proc~scalargridinterp_2d_gpu ScalarGridInterp_2D_gpu proc~scalargridinterp_2d_gpu->interface~scalargridinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalargridinterp_2d_gpu_wrapper.html"},{"title":"ScalarGridInterp_3D_gpu_wrapper – SELF","text":"interface Called by interface~~scalargridinterp_3d_gpu_wrapper~~CalledByGraph interface~scalargridinterp_3d_gpu_wrapper ScalarGridInterp_3D_gpu_wrapper proc~scalargridinterp_3d_gpu ScalarGridInterp_3D_gpu proc~scalargridinterp_3d_gpu->interface~scalargridinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/scalargridinterp_3d_gpu_wrapper.html"},{"title":"TensorBoundaryInterp_2D_gpu_wrapper – SELF","text":"interface Called by interface~~tensorboundaryinterp_2d_gpu_wrapper~~CalledByGraph interface~tensorboundaryinterp_2d_gpu_wrapper TensorBoundaryInterp_2D_gpu_wrapper proc~tensorboundaryinterp_2d_gpu TensorBoundaryInterp_2D_gpu proc~tensorboundaryinterp_2d_gpu->interface~tensorboundaryinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/tensorboundaryinterp_2d_gpu_wrapper.html"},{"title":"TensorBoundaryInterp_3D_gpu_wrapper – SELF","text":"interface Called by interface~~tensorboundaryinterp_3d_gpu_wrapper~~CalledByGraph interface~tensorboundaryinterp_3d_gpu_wrapper TensorBoundaryInterp_3D_gpu_wrapper proc~tensorboundaryinterp_3d_gpu TensorBoundaryInterp_3D_gpu proc~tensorboundaryinterp_3d_gpu->interface~tensorboundaryinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/tensorboundaryinterp_3d_gpu_wrapper.html"},{"title":"TensorDGDivergence_2D_gpu_wrapper – SELF","text":"interface Called by interface~~tensordgdivergence_2d_gpu_wrapper~~CalledByGraph interface~tensordgdivergence_2d_gpu_wrapper TensorDGDivergence_2D_gpu_wrapper proc~tensordgdivergence_2d_gpu TensorDGDivergence_2D_gpu proc~tensordgdivergence_2d_gpu->interface~tensordgdivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorDGDivergence_2D_gpu_wrapper(dMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/tensordgdivergence_2d_gpu_wrapper.html"},{"title":"TensorDGDivergence_3D_gpu_wrapper – SELF","text":"interface Called by interface~~tensordgdivergence_3d_gpu_wrapper~~CalledByGraph interface~tensordgdivergence_3d_gpu_wrapper TensorDGDivergence_3D_gpu_wrapper proc~tensordgdivergence_3d_gpu TensorDGDivergence_3D_gpu proc~tensordgdivergence_3d_gpu->interface~tensordgdivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorDGDivergence_3D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/tensordgdivergence_3d_gpu_wrapper.html"},{"title":"TensorDivergence_2D_gpu_wrapper – SELF","text":"interface Called by interface~~tensordivergence_2d_gpu_wrapper~~CalledByGraph interface~tensordivergence_2d_gpu_wrapper TensorDivergence_2D_gpu_wrapper proc~tensordivergence_2d_gpu TensorDivergence_2D_gpu proc~tensordivergence_2d_gpu->interface~tensordivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorDivergence_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/tensordivergence_2d_gpu_wrapper.html"},{"title":"TensorDivergence_3D_gpu_wrapper – SELF","text":"interface Called by interface~~tensordivergence_3d_gpu_wrapper~~CalledByGraph interface~tensordivergence_3d_gpu_wrapper TensorDivergence_3D_gpu_wrapper proc~tensordivergence_3d_gpu TensorDivergence_3D_gpu proc~tensordivergence_3d_gpu->interface~tensordivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorDivergence_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/tensordivergence_3d_gpu_wrapper.html"},{"title":"TensorGridInterp_2D_gpu_wrapper – SELF","text":"interface Called by interface~~tensorgridinterp_2d_gpu_wrapper~~CalledByGraph interface~tensorgridinterp_2d_gpu_wrapper TensorGridInterp_2D_gpu_wrapper proc~tensorgridinterp_2d_gpu TensorGridInterp_2D_gpu proc~tensorgridinterp_2d_gpu->interface~tensorgridinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/tensorgridinterp_2d_gpu_wrapper.html"},{"title":"TensorGridInterp_3D_gpu_wrapper – SELF","text":"interface Called by interface~~tensorgridinterp_3d_gpu_wrapper~~CalledByGraph interface~tensorgridinterp_3d_gpu_wrapper TensorGridInterp_3D_gpu_wrapper proc~tensorgridinterp_3d_gpu TensorGridInterp_3D_gpu proc~tensorgridinterp_3d_gpu->interface~tensorgridinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/tensorgridinterp_3d_gpu_wrapper.html"},{"title":"VectorBoundaryInterp_2D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorboundaryinterp_2d_gpu_wrapper~~CalledByGraph interface~vectorboundaryinterp_2d_gpu_wrapper VectorBoundaryInterp_2D_gpu_wrapper proc~vectorboundaryinterp_2d_gpu VectorBoundaryInterp_2D_gpu proc~vectorboundaryinterp_2d_gpu->interface~vectorboundaryinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectorboundaryinterp_2d_gpu_wrapper.html"},{"title":"VectorBoundaryInterp_3D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorboundaryinterp_3d_gpu_wrapper~~CalledByGraph interface~vectorboundaryinterp_3d_gpu_wrapper VectorBoundaryInterp_3D_gpu_wrapper proc~vectorboundaryinterp_3d_gpu VectorBoundaryInterp_3D_gpu proc~vectorboundaryinterp_3d_gpu->interface~vectorboundaryinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectorboundaryinterp_3d_gpu_wrapper.html"},{"title":"VectorCurl_2D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorcurl_2d_gpu_wrapper~~CalledByGraph interface~vectorcurl_2d_gpu_wrapper VectorCurl_2D_gpu_wrapper proc~vectorcurl_2d_gpu VectorCurl_2D_gpu proc~vectorcurl_2d_gpu->interface~vectorcurl_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorCurl_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectorcurl_2d_gpu_wrapper.html"},{"title":"VectorCurl_3D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorcurl_3d_gpu_wrapper~~CalledByGraph interface~vectorcurl_3d_gpu_wrapper VectorCurl_3D_gpu_wrapper proc~vectorcurl_3d_gpu VectorCurl_3D_gpu proc~vectorcurl_3d_gpu->interface~vectorcurl_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorCurl_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectorcurl_3d_gpu_wrapper.html"},{"title":"VectorDGDivergence_2D_gpu_wrapper – SELF","text":"interface Called by interface~~vectordgdivergence_2d_gpu_wrapper~~CalledByGraph interface~vectordgdivergence_2d_gpu_wrapper VectorDGDivergence_2D_gpu_wrapper proc~vectordgdivergence_2d_gpu VectorDGDivergence_2D_gpu proc~vectordgdivergence_2d_gpu->interface~vectordgdivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorDGDivergence_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectordgdivergence_2d_gpu_wrapper.html"},{"title":"VectorDGDivergence_3D_gpu_wrapper – SELF","text":"interface Called by interface~~vectordgdivergence_3d_gpu_wrapper~~CalledByGraph interface~vectordgdivergence_3d_gpu_wrapper VectorDGDivergence_3D_gpu_wrapper proc~vectordgdivergence_3d_gpu VectorDGDivergence_3D_gpu proc~vectordgdivergence_3d_gpu->interface~vectordgdivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorDGDivergence_3D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectordgdivergence_3d_gpu_wrapper.html"},{"title":"VectorDGGradient_2D_gpu_wrapper – SELF","text":"interface Called by interface~~vectordggradient_2d_gpu_wrapper~~CalledByGraph interface~vectordggradient_2d_gpu_wrapper VectorDGGradient_2D_gpu_wrapper proc~vectordggradient_2d_gpu VectorDGGradient_2D_gpu proc~vectordggradient_2d_gpu->interface~vectordggradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorDGGradient_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectordggradient_2d_gpu_wrapper.html"},{"title":"VectorDivergence_2D_gpu_wrapper – SELF","text":"interface Called by interface~~vectordivergence_2d_gpu_wrapper~~CalledByGraph interface~vectordivergence_2d_gpu_wrapper VectorDivergence_2D_gpu_wrapper proc~vectordivergence_2d_gpu VectorDivergence_2D_gpu proc~vectordivergence_2d_gpu->interface~vectordivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorDivergence_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectordivergence_2d_gpu_wrapper.html"},{"title":"VectorDivergence_3D_gpu_wrapper – SELF","text":"interface Called by interface~~vectordivergence_3d_gpu_wrapper~~CalledByGraph interface~vectordivergence_3d_gpu_wrapper VectorDivergence_3D_gpu_wrapper proc~vectordivergence_3d_gpu VectorDivergence_3D_gpu proc~vectordivergence_3d_gpu->interface~vectordivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorDivergence_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectordivergence_3d_gpu_wrapper.html"},{"title":"VectorGradient_2D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorgradient_2d_gpu_wrapper~~CalledByGraph interface~vectorgradient_2d_gpu_wrapper VectorGradient_2D_gpu_wrapper proc~vectorgradient_2d_gpu VectorGradient_2D_gpu proc~vectorgradient_2d_gpu->interface~vectorgradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorGradient_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectorgradient_2d_gpu_wrapper.html"},{"title":"VectorGradient_3D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorgradient_3d_gpu_wrapper~~CalledByGraph interface~vectorgradient_3d_gpu_wrapper VectorGradient_3D_gpu_wrapper proc~vectorgradient_3d_gpu VectorGradient_3D_gpu proc~vectorgradient_3d_gpu->interface~vectorgradient_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorGradient_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectorgradient_3d_gpu_wrapper.html"},{"title":"VectorGridInterp_2D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorgridinterp_2d_gpu_wrapper~~CalledByGraph interface~vectorgridinterp_2d_gpu_wrapper VectorGridInterp_2D_gpu_wrapper proc~vectorgridinterp_2d_gpu VectorGridInterp_2D_gpu proc~vectorgridinterp_2d_gpu->interface~vectorgridinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectorgridinterp_2d_gpu_wrapper.html"},{"title":"VectorGridInterp_3D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorgridinterp_3d_gpu_wrapper~~CalledByGraph interface~vectorgridinterp_3d_gpu_wrapper VectorGridInterp_3D_gpu_wrapper proc~vectorgridinterp_3d_gpu VectorGridInterp_3D_gpu proc~vectorgridinterp_3d_gpu->interface~vectorgridinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl","tags":"","loc":"interface/vectorgridinterp_3d_gpu_wrapper.html"},{"title":"SELF_SupportRoutines – SELF","text":"\\file SELF_SupportRoutines.f90\nContains the \\ref SELF_SupportRoutines module\n\\defgroup SELF_SupportRoutines SELF_SupportRoutines\nThis module defines a set of general purpose routines. Uses iso_fortran_env SELF_Constants module~~self_supportroutines~~UsesGraph module~self_supportroutines SELF_SupportRoutines module~self_constants SELF_Constants module~self_supportroutines->module~self_constants iso_fortran_env iso_fortran_env module~self_supportroutines->iso_fortran_env module~self_constants->iso_fortran_env iso_c_binding iso_c_binding module~self_constants->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_supportroutines~~UsedByGraph module~self_supportroutines SELF_SupportRoutines module~self_lagrange SELF_Lagrange module~self_lagrange->module~self_supportroutines module~self_geometry SELF_Geometry module~self_geometry->module~self_supportroutines module~self_geometry->module~self_lagrange module~self_mesh SELF_Mesh module~self_geometry->module~self_mesh module~self_data SELF_Data module~self_geometry->module~self_data module~self_mesh->module~self_supportroutines module~self_mesh->module~self_lagrange module~self_mesh->module~self_data module~self_advection3d SELF_Advection3D module~self_advection3d->module~self_supportroutines module~self_advection3d->module~self_mesh module~self_dg SELF_DG module~self_advection3d->module~self_dg module~self_advection2d SELF_Advection2D module~self_advection2d->module~self_supportroutines module~self_advection2d->module~self_mesh module~self_advection2d->module~self_dg module~self_mappeddata SELF_MappedData module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_geometry module~self_mappeddata->module~self_mesh module~self_mappeddata->module~self_data module~self_data->module~self_lagrange module~self_dg->module~self_mesh module~self_dg->module~self_mappeddata program~sadv2d sadv2d program~sadv2d->module~self_mesh program~sadv2d->module~self_advection2d program~sadv3d sadv3d program~sadv3d->module~self_mesh program~sadv3d->module~self_advection3d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions AlmostEqual CompareArray Determinant Float2Str FloorCURT FloorSQRT GetMinor Int2Str InvertSpectralOpMatrix Invert_2x2 Invert_3x3 IsInf NewUnit TimeStamp UniformPoints UpperCase Subroutines ForwardShift InsertionSort ReverseArray SortAndSum SortArray Functions public function AlmostEqual (a, b) result(AisB) \\addtogroup SELF_SupportRoutines\n @{\n \\fn AlmostEqual\n Compares two floating point numbers and determines if they are equal (to machine precision). Read more… Arguments Type Intent Optional Attributes Name real(kind=real64) :: a real(kind=real64) :: b Return Value logical public function CompareArray (arrayOne, arrayTwo, N) result(arraysMatch) \\addtogroup SELF_SupportRoutines\n @{\n \\fn CompareArray\n Compares to INTEGER arrays and determines if they are identical. Read more… Arguments Type Intent Optional Attributes Name integer :: arrayOne (1:N) integer :: arrayTwo (1:N) integer :: N Return Value logical public recursive function Determinant (A, N) result(D) \\addtogroup SELF_SupportRoutines\n @{\n \\fn Determinant\n A recursive function that calculates the determinant of an \\f$ N\\times N \\f$ matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:N,1:N) integer :: N Return Value real(kind=prec) public function Float2Str (aNumber) result(aString) Arguments Type Intent Optional Attributes Name real(kind=prec) :: aNumber Return Value character(len=12) public function FloorCURT (x) result(curtX) Arguments Type Intent Optional Attributes Name integer :: x Return Value integer public function FloorSQRT (x) result(sqrtX) Arguments Type Intent Optional Attributes Name integer :: x Return Value integer public function GetMinor (A, i, j, N) result(M) \\addtogroup SELF_SupportRoutines\n @{\n \\fn GetMinor\n Returns the submatrix obtained by removing a given row and column of the input matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:N,1:N) integer :: i integer :: j integer :: N Return Value real(kind=prec)\n  (1:N-1,1:N-1) public function Int2Str (aNumber) result(aString) Arguments Type Intent Optional Attributes Name integer :: aNumber Return Value character(len=12) public function InvertSpectralOpMatrix (A, N) result(Ainv) Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (0:N,0:N) integer :: N Return Value real(kind=prec)\n  (0:N,0:N) public function Invert_2x2 (A) result(Ainv) \\addtogroup SELF_SupportRoutines\n @{\n \\fn Invert_2x2\n  Computes the inverse of a 2x2 matrix using Kramer's rule. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:2,1:2) Return Value real(kind=prec)\n  (1:2,1:2) public function Invert_3x3 (A) result(Ainv) \\addtogroup SELF_SupportRoutines\n @{\n \\fn Invert_3x3\n  Computes the inverse of a 3x3 matrix using Kramer's rule. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:3,1:3) Return Value real(kind=prec)\n  (1:3,1:3) public function IsInf (a) Arguments Type Intent Optional Attributes Name real(kind=prec) :: a Return Value logical public function NewUnit (thisunit) \\addtogroup SELF_SupportRoutines\n @{\n \\fn NewUnit\n Returns a file unit identifier that is currently not in use. Read more… Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: thisunit Return Value integer public function TimeStamp (time, units) result(timeStampString) Arguments Type Intent Optional Attributes Name real(kind=prec) :: time character(len=1) :: units Return Value character(len=13) public function UniformPoints (a, b, firstInd, lastInd) result(xU) \\addtogroup SELF_SupportRoutines\n @{\n \\fn UniformPoints\n Generates a REAL(prec) array of N points evenly spaced between two points. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec) :: a real(kind=prec) :: b integer :: firstInd integer :: lastInd Return Value real(kind=prec)\n  (firstInd:lastInd) public function UpperCase (str) result(Upper) Arguments Type Intent Optional Attributes Name character, intent(in) :: str Return Value character Subroutines public subroutine ForwardShift (myArray, N) \\addtogroup SELF_SupportRoutines\n @{\n \\fn ForwardShift\n Shift an array integers by one index forward, moving the last index to the first. Read more… Arguments Type Intent Optional Attributes Name integer, intent(inout) :: myArray (1:N) integer, intent(in) :: N public subroutine InsertionSort (inArray, outArray, N) \\addtogroup SELF_SupportRoutines\n @{\n \\fn InsertionSort\n Sorts an array of integers from smallest to largest using the insertion-sort algorithm. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: inArray (1:N) integer, intent(out) :: outArray (1:N) integer, intent(in) :: N public subroutine ReverseArray (myArray, low, high) \\addtogroup SELF_SupportRoutines\n @{\n \\fn ReverseArray\n Reverses the order of a REAL(prec) array. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec), intent(inout) :: myArray (low:high) integer, intent(in) :: low integer, intent(in) :: high public subroutine SortAndSum (myArray, low, high, arraysum) \\addtogroup SELF_SupportRoutines\n @{\n \\fn SortAndSum\n Computes the sum of an array by first sorting the array from smallest absolute value to largest\n absolute value. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec), intent(inout) :: myArray (low:high) integer, intent(in) :: low integer, intent(in) :: high real(kind=prec), intent(out) :: arraysum public subroutine SortArray (myArray, low, high) \\addtogroup SELF_SupportRoutines\n @{\n \\fn SortArray\n Sorts a REAL(prec) array from smallest absolute value to largest absolute value. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec), intent(inout) :: myArray (low:high) integer, intent(in) :: low integer, intent(in) :: high","tags":"","loc":"module/self_supportroutines.html"},{"title":"SELF_Metadata – SELF","text":"Uses SELF_HDF5 module~~self_metadata~~UsesGraph module~self_metadata SELF_Metadata module~self_hdf5 SELF_HDF5 module~self_metadata->module~self_hdf5 module~self_memory SELF_Memory module~self_hdf5->module~self_memory HDF5 HDF5 module~self_hdf5->HDF5 module~self_constants SELF_Constants module~self_hdf5->module~self_constants iso_fortran_env iso_fortran_env module~self_hdf5->iso_fortran_env module~self_memory->module~self_constants module~self_memory->iso_fortran_env iso_c_binding iso_c_binding module~self_memory->iso_c_binding hipfort_check hipfort_check module~self_memory->hipfort_check hipfort hipfort module~self_memory->hipfort module~self_constants->iso_fortran_env module~self_constants->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_metadata~~UsedByGraph module~self_metadata SELF_Metadata module~self_dg SELF_DG module~self_dg->module~self_metadata module~self_advection3d SELF_Advection3D module~self_advection3d->module~self_dg module~self_advection2d SELF_Advection2D module~self_advection2d->module~self_dg program~sadv2d sadv2d program~sadv2d->module~self_advection2d program~sadv3d sadv3d program~sadv3d->module~self_advection3d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables SELF_MTD_DescriptionLength SELF_MTD_NameLength SELF_MTD_UnitsLength Derived Types Metadata Subroutines Set_Description_Metadata Set_Name_Metadata Set_Units_Metadata Variables Type Visibility Attributes Name Initial integer, public, parameter :: SELF_MTD_DescriptionLength = 1000 integer, public, parameter :: SELF_MTD_NameLength = 250 integer, public, parameter :: SELF_MTD_UnitsLength = 20 Derived Types type, public :: Metadata Components Type Visibility Attributes Name Initial character, public :: description character, public :: name character, public :: units Type-Bound Procedures procedure, public :: Set_Description => Set_Description_Metadata procedure, public :: Set_Name => Set_Name_Metadata procedure, public :: Set_Units => Set_Units_Metadata Subroutines public subroutine Set_Description_Metadata (mtd, description) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: description public subroutine Set_Name_Metadata (mtd, name) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: name public subroutine Set_Units_Metadata (mtd, units) Arguments Type Intent Optional Attributes Name class( Metadata ), intent(inout) :: mtd character, intent(in) :: units","tags":"","loc":"module/self_metadata.html"},{"title":"SELF_Memory – SELF","text":"Uses iso_c_binding hipfort_check hipfort SELF_Constants iso_fortran_env module~~self_memory~~UsesGraph module~self_memory SELF_Memory module~self_constants SELF_Constants module~self_memory->module~self_constants hipfort_check hipfort_check module~self_memory->hipfort_check hipfort hipfort module~self_memory->hipfort iso_c_binding iso_c_binding module~self_memory->iso_c_binding iso_fortran_env iso_fortran_env module~self_memory->iso_fortran_env module~self_constants->iso_c_binding module~self_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_memory~~UsedByGraph module~self_memory SELF_Memory module~self_lagrange SELF_Lagrange module~self_lagrange->module~self_memory module~self_mpi SELF_MPI module~self_mpi->module~self_memory module~self_hdf5 SELF_HDF5 module~self_hdf5->module~self_memory module~self_mappeddata SELF_MappedData module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_mpi module~self_data SELF_Data module~self_mappeddata->module~self_data module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry module~self_mesh SELF_Mesh module~self_mappeddata->module~self_mesh module~self_data->module~self_lagrange module~self_dg SELF_DG module~self_dg->module~self_mpi module~self_dg->module~self_hdf5 module~self_dg->module~self_mappeddata module~self_metadata SELF_Metadata module~self_dg->module~self_metadata module~self_dg->module~self_mesh module~self_metadata->module~self_hdf5 module~self_geometry->module~self_lagrange module~self_geometry->module~self_data module~self_geometry->module~self_mesh module~self_mesh->module~self_lagrange module~self_mesh->module~self_mpi module~self_mesh->module~self_hdf5 module~self_mesh->module~self_data program~sadv2d sadv2d program~sadv2d->module~self_mesh module~self_advection2d SELF_Advection2D program~sadv2d->module~self_advection2d module~self_advection3d SELF_Advection3D module~self_advection3d->module~self_dg module~self_advection3d->module~self_mesh program~sadv3d sadv3d program~sadv3d->module~self_mesh program~sadv3d->module~self_advection3d module~self_advection2d->module~self_dg module~self_advection2d->module~self_mesh Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Derived Types hfInt32_r1 hfInt32_r2 hfInt32_r3 hfInt32_r4 hfInt32_r5 hfInt32_r6 hfInt32_r7 hfInt64_r1 hfInt64_r2 hfInt64_r3 hfInt64_r4 hfInt64_r5 hfInt64_r6 hfInt64_r7 hfReal_r1 hfReal_r2 hfReal_r3 hfReal_r4 hfReal_r5 hfReal_r6 hfReal_r7 Functions GPUAvailable Subroutines Alloc_hfInt32_r1 Alloc_hfInt32_r2 Alloc_hfInt32_r3 Alloc_hfInt32_r4 Alloc_hfInt32_r5 Alloc_hfInt32_r6 Alloc_hfInt32_r7 Alloc_hfInt64_r1 Alloc_hfInt64_r2 Alloc_hfInt64_r3 Alloc_hfInt64_r4 Alloc_hfInt64_r5 Alloc_hfInt64_r6 Alloc_hfInt64_r7 Alloc_hfReal_r1 Alloc_hfReal_r2 Alloc_hfReal_r3 Alloc_hfReal_r4 Alloc_hfReal_r5 Alloc_hfReal_r6 Alloc_hfReal_r7 Free_hfInt32_r1 Free_hfInt32_r2 Free_hfInt32_r3 Free_hfInt32_r4 Free_hfInt32_r5 Free_hfInt32_r6 Free_hfInt32_r7 Free_hfInt64_r1 Free_hfInt64_r2 Free_hfInt64_r3 Free_hfInt64_r4 Free_hfInt64_r5 Free_hfInt64_r6 Free_hfInt64_r7 Free_hfReal_r1 Free_hfReal_r2 Free_hfReal_r3 Free_hfReal_r4 Free_hfReal_r5 Free_hfReal_r6 Free_hfReal_r7 UpdateDevice_hfInt32_r1 UpdateDevice_hfInt32_r2 UpdateDevice_hfInt32_r3 UpdateDevice_hfInt32_r4 UpdateDevice_hfInt32_r5 UpdateDevice_hfInt32_r6 UpdateDevice_hfInt32_r7 UpdateDevice_hfInt64_r1 UpdateDevice_hfInt64_r2 UpdateDevice_hfInt64_r3 UpdateDevice_hfInt64_r4 UpdateDevice_hfInt64_r5 UpdateDevice_hfInt64_r6 UpdateDevice_hfInt64_r7 UpdateDevice_hfReal_r1 UpdateDevice_hfReal_r2 UpdateDevice_hfReal_r3 UpdateDevice_hfReal_r4 UpdateDevice_hfReal_r5 UpdateDevice_hfReal_r6 UpdateDevice_hfReal_r7 UpdateHost_hfInt32_r1 UpdateHost_hfInt32_r2 UpdateHost_hfInt32_r3 UpdateHost_hfInt32_r4 UpdateHost_hfInt32_r5 UpdateHost_hfInt32_r6 UpdateHost_hfInt32_r7 UpdateHost_hfInt64_r1 UpdateHost_hfInt64_r2 UpdateHost_hfInt64_r3 UpdateHost_hfInt64_r4 UpdateHost_hfInt64_r5 UpdateHost_hfInt64_r6 UpdateHost_hfInt64_r7 UpdateHost_hfReal_r1 UpdateHost_hfReal_r2 UpdateHost_hfReal_r3 UpdateHost_hfReal_r4 UpdateHost_hfReal_r5 UpdateHost_hfReal_r6 UpdateHost_hfReal_r7 Derived Types type, public :: hfInt32_r1 Data type for storing one-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r1 procedure, public :: Free => Free_hfInt32_r1 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r1 procedure, public :: UpdateHost => UpdateHost_hfInt32_r1 type, public :: hfInt32_r2 Data type for storing two-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r2 procedure, public :: Free => Free_hfInt32_r2 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r2 procedure, public :: UpdateHost => UpdateHost_hfInt32_r2 type, public :: hfInt32_r3 Data type for storing three-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r3 procedure, public :: Free => Free_hfInt32_r3 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r3 procedure, public :: UpdateHost => UpdateHost_hfInt32_r3 type, public :: hfInt32_r4 Data type for storing four-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r4 procedure, public :: Free => Free_hfInt32_r4 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r4 procedure, public :: UpdateHost => UpdateHost_hfInt32_r4 type, public :: hfInt32_r5 Data type for storing five-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r5 procedure, public :: Free => Free_hfInt32_r5 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r5 procedure, public :: UpdateHost => UpdateHost_hfInt32_r5 type, public :: hfInt32_r6 Data type for storing six-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r6 procedure, public :: Free => Free_hfInt32_r6 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r6 procedure, public :: UpdateHost => UpdateHost_hfInt32_r6 type, public :: hfInt32_r7 Data type for storing seven-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r7 procedure, public :: Free => Free_hfInt32_r7 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r7 procedure, public :: UpdateHost => UpdateHost_hfInt32_r7 type, public :: hfInt64_r1 Data type for storing one-dimensional int64 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r1 procedure, public :: Free => Free_hfInt64_r1 procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r1 procedure, public :: UpdateHost => UpdateHost_hfInt64_r1 type, public :: hfInt64_r2 Data type for storing two-dimensional int64 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r2 procedure, public :: Free => Free_hfInt64_r2 procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r2 procedure, public :: UpdateHost => UpdateHost_hfInt64_r2 type, public :: hfInt64_r3 Data type for storing three-dimensional int64 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r3 procedure, public :: Free => Free_hfInt64_r3 procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r3 procedure, public :: UpdateHost => UpdateHost_hfInt64_r3 type, public :: hfInt64_r4 Data type for storing four-dimensional int64 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r4 procedure, public :: Free => Free_hfInt64_r4 procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r4 procedure, public :: UpdateHost => UpdateHost_hfInt64_r4 type, public :: hfInt64_r5 Data type for storing five-dimensional int64 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r5 procedure, public :: Free => Free_hfInt64_r5 procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r5 procedure, public :: UpdateHost => UpdateHost_hfInt64_r5 type, public :: hfInt64_r6 Data type for storing six-dimensional int64 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r6 procedure, public :: Free => Free_hfInt64_r6 procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r6 procedure, public :: UpdateHost => UpdateHost_hfInt64_r6 type, public :: hfInt64_r7 Data type for storing seven-dimensional int64 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r7 procedure, public :: Free => Free_hfInt64_r7 procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r7 procedure, public :: UpdateHost => UpdateHost_hfInt64_r7 type, public :: hfReal_r1 Data type for storing one-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r1 procedure, public :: Free => Free_hfReal_r1 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r1 procedure, public :: UpdateHost => UpdateHost_hfReal_r1 type, public :: hfReal_r2 Data type for storing two-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r2 procedure, public :: Free => Free_hfReal_r2 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r2 procedure, public :: UpdateHost => UpdateHost_hfReal_r2 type, public :: hfReal_r3 Data type for storing three-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r3 procedure, public :: Free => Free_hfReal_r3 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r3 procedure, public :: UpdateHost => UpdateHost_hfReal_r3 type, public :: hfReal_r4 Data type for storing four-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r4 procedure, public :: Free => Free_hfReal_r4 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r4 procedure, public :: UpdateHost => UpdateHost_hfReal_r4 type, public :: hfReal_r5 Data type for storing five-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r5 procedure, public :: Free => Free_hfReal_r5 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r5 procedure, public :: UpdateHost => UpdateHost_hfReal_r5 type, public :: hfReal_r6 Data type for storing one-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r6 procedure, public :: Free => Free_hfReal_r6 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r6 procedure, public :: UpdateHost => UpdateHost_hfReal_r6 type, public :: hfReal_r7 Data type for storing seven-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r7 procedure, public :: Free => Free_hfReal_r7 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r7 procedure, public :: UpdateHost => UpdateHost_hfReal_r7 Functions public function GPUAvailable () result(avail) Arguments None Return Value logical Subroutines public subroutine Alloc_hfInt32_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound public subroutine Alloc_hfInt32_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) public subroutine Alloc_hfInt32_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) public subroutine Alloc_hfInt32_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) public subroutine Alloc_hfInt32_r5 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) public subroutine Alloc_hfInt32_r6 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) public subroutine Alloc_hfInt32_r7 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) public subroutine Alloc_hfInt64_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound public subroutine Alloc_hfInt64_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) public subroutine Alloc_hfInt64_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) public subroutine Alloc_hfInt64_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) public subroutine Alloc_hfInt64_r5 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) public subroutine Alloc_hfInt64_r6 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) public subroutine Alloc_hfInt64_r7 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) public subroutine Alloc_hfReal_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound public subroutine Alloc_hfReal_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) public subroutine Alloc_hfReal_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) public subroutine Alloc_hfReal_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) public subroutine Alloc_hfReal_r5 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) public subroutine Alloc_hfReal_r6 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) public subroutine Alloc_hfReal_r7 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) public subroutine Free_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this public subroutine Free_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this public subroutine Free_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this public subroutine Free_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this public subroutine Free_hfInt32_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this public subroutine Free_hfInt32_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this public subroutine Free_hfInt32_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this public subroutine Free_hfInt64_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this public subroutine Free_hfInt64_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this public subroutine Free_hfInt64_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this public subroutine Free_hfInt64_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this public subroutine Free_hfInt64_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this public subroutine Free_hfInt64_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this public subroutine Free_hfInt64_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this public subroutine Free_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this public subroutine Free_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this public subroutine Free_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this public subroutine Free_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this public subroutine Free_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this public subroutine Free_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this public subroutine Free_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this public subroutine UpdateDevice_hfInt64_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this public subroutine UpdateDevice_hfInt64_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this public subroutine UpdateDevice_hfInt64_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this public subroutine UpdateDevice_hfInt64_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this public subroutine UpdateDevice_hfInt64_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this public subroutine UpdateDevice_hfInt64_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this public subroutine UpdateDevice_hfInt64_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this public subroutine UpdateHost_hfInt64_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this public subroutine UpdateHost_hfInt64_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this public subroutine UpdateHost_hfInt64_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this public subroutine UpdateHost_hfInt64_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this public subroutine UpdateHost_hfInt64_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this public subroutine UpdateHost_hfInt64_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this public subroutine UpdateHost_hfInt64_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this","tags":"","loc":"module/self_memory.html"},{"title":"SELF_Constants – SELF","text":"Uses iso_fortran_env iso_c_binding module~~self_constants~~UsesGraph module~self_constants SELF_Constants iso_c_binding iso_c_binding module~self_constants->iso_c_binding iso_fortran_env iso_fortran_env module~self_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_constants~~UsedByGraph module~self_constants SELF_Constants module~self_lagrange SELF_Lagrange module~self_lagrange->module~self_constants module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature module~self_supportroutines SELF_SupportRoutines module~self_lagrange->module~self_supportroutines module~self_mappeddata SELF_MappedData module~self_mappeddata->module~self_constants module~self_mappeddata->module~self_lagrange module~self_data SELF_Data module~self_mappeddata->module~self_data module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry module~self_mpi SELF_MPI module~self_mappeddata->module~self_mpi module~self_mesh SELF_Mesh module~self_mappeddata->module~self_mesh module~self_data->module~self_constants module~self_data->module~self_lagrange module~self_memory->module~self_constants module~self_quadrature->module~self_constants module~self_advection3d SELF_Advection3D module~self_advection3d->module~self_constants module~self_advection3d->module~self_mesh module~self_advection3d->module~self_supportroutines module~self_dg SELF_DG module~self_advection3d->module~self_dg module~self_hdf5 SELF_HDF5 module~self_hdf5->module~self_constants module~self_hdf5->module~self_memory module~self_hashtable SELF_HashTable module~self_hashtable->module~self_constants program~sadv3d sadv3d program~sadv3d->module~self_constants program~sadv3d->module~self_advection3d program~sadv3d->module~self_mesh module~self_geometry->module~self_constants module~self_geometry->module~self_lagrange module~self_geometry->module~self_data module~self_geometry->module~self_mesh module~self_geometry->module~self_supportroutines module~self_mpi->module~self_constants module~self_mpi->module~self_memory program~sadv2d sadv2d program~sadv2d->module~self_constants program~sadv2d->module~self_mesh module~self_advection2d SELF_Advection2D program~sadv2d->module~self_advection2d module~self_mesh->module~self_constants module~self_mesh->module~self_lagrange module~self_mesh->module~self_data module~self_mesh->module~self_hdf5 module~self_mesh->module~self_hashtable module~self_mesh->module~self_mpi module~self_mesh->module~self_supportroutines module~self_supportroutines->module~self_constants module~self_advection2d->module~self_constants module~self_advection2d->module~self_mesh module~self_advection2d->module~self_supportroutines module~self_advection2d->module~self_dg module~self_metadata SELF_Metadata module~self_metadata->module~self_hdf5 module~self_dg->module~self_mappeddata module~self_dg->module~self_hdf5 module~self_dg->module~self_mpi module~self_dg->module~self_mesh module~self_dg->module~self_metadata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables CG CHEBYSHEV_GAUSS CHEBYSHEV_GAUSS_LOBATTO DG EULER GAUSS GAUSS_LOBATTO MsgFmt RK3 SELF_EQN_DEFAULT_LENGTH TOL UNIFORM c_prec c_prec daysToMonths daysToSeconds fillValue fillValueInt hoursToDays maxInverseIters minutesToHours monthsToYears nada newtonMax newtonTolerance pi prec prec rk3_a rk3_b rk3_g secondsToMinutes self_EquationLength self_FileNameLength self_IntegratorTypeCharLength self_QuadratureTypeCharLength tolerance Variables Type Visibility Attributes Name Initial integer, public, parameter :: CG = 2001 integer, public, parameter :: CHEBYSHEV_GAUSS = 3 integer, public, parameter :: CHEBYSHEV_GAUSS_LOBATTO = 4 integer, public, parameter :: DG = 2000 integer, public, parameter :: EULER = 100 integer, public, parameter :: GAUSS = 1 integer, public, parameter :: GAUSS_LOBATTO = 2 character(len=6), public, parameter :: MsgFmt = '(2x,A)' integer, public, parameter :: RK3 = 203 integer, public, parameter :: SELF_EQN_DEFAULT_LENGTH = 100 real(kind=prec), public, parameter :: TOL = epsilon(1.0_prec) integer, public, parameter :: UNIFORM = 3 integer, public, parameter :: c_prec = C_DOUBLE integer, public, parameter :: c_prec = C_FLOAT real(kind=prec), public, parameter :: daysToMonths = 12.0_prec/365.25_prec real(kind=prec), public, parameter :: daysToSeconds = 86400.0_prec real(kind=prec), public, parameter :: fillValue = -9999.99_prec integer, public, parameter :: fillValueInt = -99999 real(kind=prec), public, parameter :: hoursToDays = 1.0_prec/24.0_prec integer, public, parameter :: maxInverseIters = 1000 real(kind=prec), public, parameter :: minutesToHours = 1.0_prec/60.0_prec real(kind=prec), public, parameter :: monthsToYears = 1.0_prec/12.0_prec character(len=1), public, parameter :: nada = ' ' integer, public, parameter :: newtonMax = 500 real(kind=prec), public, parameter :: newtonTolerance = 10.0**(-8) real(kind=prec), public, parameter :: pi = 4.0_prec*atan(1.0_prec) integer, public, parameter :: prec = real64 integer, public, parameter :: prec = real32 real(kind=prec), public, parameter :: rk3_a (1:3) = (/0.0_prec, -5.0_prec/9.0_prec, -153.0_prec/128.0_prec/) real(kind=prec), public, parameter :: rk3_b (1:3) = (/0.0_prec, 1.0_prec/3.0_prec, 3.0_prec/4.0_prec/) real(kind=prec), public, parameter :: rk3_g (1:3) = (/1.0_prec/3.0_prec, 15.0_prec/16.0_prec, 8.0_prec/15.0_prec/) real(kind=prec), public, parameter :: secondsToMinutes = 1.0_prec/60.0_prec integer, public, parameter :: self_EquationLength = 210 integer, public, parameter :: self_FileNameLength = 500 integer, public, parameter :: self_IntegratorTypeCharLength = 50 integer, public, parameter :: self_QuadratureTypeCharLength = 50 real(kind=prec), public, parameter :: tolerance = 10.0**(-10)","tags":"","loc":"module/self_constants.html"},{"title":"SELF_Advection3D – SELF","text":"Uses SELF_DG iso_c_binding SELF_Mesh FEQParse FLAP SELF_Constants SELF_SupportRoutines module~~self_advection3d~~UsesGraph module~self_advection3d SELF_Advection3D module~self_constants SELF_Constants module~self_advection3d->module~self_constants module~self_dg SELF_DG module~self_advection3d->module~self_dg FEQParse FEQParse module~self_advection3d->FEQParse FLAP FLAP module~self_advection3d->FLAP iso_c_binding iso_c_binding module~self_advection3d->iso_c_binding module~self_mesh SELF_Mesh module~self_advection3d->module~self_mesh module~self_supportroutines SELF_SupportRoutines module~self_advection3d->module~self_supportroutines module~self_constants->iso_c_binding iso_fortran_env iso_fortran_env module~self_constants->iso_fortran_env module~self_dg->module~self_mesh module~self_mappeddata SELF_MappedData module~self_dg->module~self_mappeddata module~self_metadata SELF_Metadata module~self_dg->module~self_metadata HDF5 HDF5 module~self_dg->HDF5 module~self_mpi SELF_MPI module~self_dg->module~self_mpi module~self_hdf5 SELF_HDF5 module~self_dg->module~self_hdf5 module~self_mesh->module~self_constants module~self_mesh->iso_c_binding module~self_mesh->module~self_supportroutines module~self_lagrange SELF_Lagrange module~self_mesh->module~self_lagrange module~self_data SELF_Data module~self_mesh->module~self_data module~self_hashtable SELF_HashTable module~self_mesh->module~self_hashtable module~self_mesh->HDF5 module~self_mesh->module~self_mpi module~self_mesh->module~self_hdf5 module~self_supportroutines->module~self_constants module~self_supportroutines->iso_fortran_env module~self_lagrange->module~self_constants module~self_lagrange->iso_c_binding module~self_lagrange->module~self_supportroutines module~self_lagrange->iso_fortran_env module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort_check hipfort_check module~self_lagrange->hipfort_check hipfort hipfort module~self_lagrange->hipfort module~self_mappeddata->module~self_constants module~self_mappeddata->iso_c_binding module~self_mappeddata->module~self_mesh module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_data module~self_mappeddata->module~self_mpi module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry module~self_data->module~self_constants module~self_data->iso_c_binding module~self_data->module~self_lagrange module~self_metadata->module~self_hdf5 module~self_hashtable->module~self_constants module~self_linkedlist SELF_LinkedList module~self_hashtable->module~self_linkedlist module~self_mpi->module~self_constants module~self_mpi->iso_c_binding module~self_mpi->module~self_memory module~self_hdf5->module~self_constants module~self_hdf5->iso_fortran_env module~self_hdf5->HDF5 module~self_hdf5->module~self_memory module~self_memory->module~self_constants module~self_memory->iso_c_binding module~self_memory->iso_fortran_env module~self_memory->hipfort_check module~self_memory->hipfort module~self_quadrature->module~self_constants module~self_quadrature->iso_fortran_env module~self_geometry->module~self_constants module~self_geometry->module~self_mesh module~self_geometry->module~self_supportroutines module~self_geometry->module~self_lagrange module~self_geometry->module~self_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_advection3d~~UsedByGraph module~self_advection3d SELF_Advection3D program~sadv3d sadv3d program~sadv3d->module~self_advection3d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces InternalDiffusiveFlux_Advection3D_gpu_wrapper InternalFlux_Advection3D_gpu_wrapper SideDiffusiveFlux_Advection3D_gpu_wrapper SideFlux_Advection3D_gpu_wrapper UpdateGRK3_Advection3D_gpu_wrapper Derived Types Advection3D Subroutines ForwardStep_Advection3D Free_Advection3D GetCLIParameters InitFromCLI_Advection3D Init_Advection3D InternalFlux_Advection3D SetBoundaryConditionFromEquation_Advection3D SetSolutionFromEquation_Advection3D SetSourceFromEquation_Advection3D SetVelocityFromEquation_Advection3D SideFlux_Advection3D Tendency_Advection3D TimeStepRK3_Advection3D WriteTecplot_Advection3D Interfaces interface public subroutine InternalDiffusiveFlux_Advection3D_gpu_wrapper(flux, solutionGradient, dsdx, diffusivity, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: solutionGradient type(c_ptr) :: dsdx real(kind=c_prec), VALUE :: diffusivity integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine InternalFlux_Advection3D_gpu_wrapper(flux, solution, velocity, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: solution type(c_ptr) :: velocity type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine SideDiffusiveFlux_Advection3D_gpu_wrapper(flux, boundarySolGradient, extSolGradient, nHat, nScale, diffusivity, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: boundarySolGradient type(c_ptr) :: extSolGradient type(c_ptr) :: nHat type(c_ptr) :: nScale real(kind=c_prec), VALUE :: diffusivity integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine SideFlux_Advection3D_gpu_wrapper(flux, boundarySol, extSol, velocity, nHat, nScale, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: boundarySol type(c_ptr) :: extSol type(c_ptr) :: velocity type(c_ptr) :: nHat type(c_ptr) :: nScale integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateGRK3_Advection3D_gpu_wrapper(gRK3, solution, dSdt, rk3A, rk3G, dt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: gRK3 type(c_ptr) :: solution type(c_ptr) :: dSdt real(kind=c_prec), VALUE :: rk3A real(kind=c_prec), VALUE :: rk3G real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl Derived Types type, public, extends(DG3D) :: Advection3D Components Type Visibility Attributes Name Initial real(kind=prec), public :: Lx real(kind=prec), public :: Ly real(kind=prec), public :: Lz character(len=self_EquationLength), public :: bcEqn type(EquationParser), public, ALLOCATABLE :: boundaryConditionEqn (:) integer, public :: controlDegree integer, public :: controlQuadrature logical, public :: diffusiveFlux real(kind=prec), public :: diffusivity real(kind=prec), public :: dt logical, public :: enableMPI real(kind=prec), public :: endTime logical, public :: gpuAccel character(len=self_EquationLength), public :: icEqn character(len=self_FileNameLength), public :: icFile real(kind=prec), public :: initialTime integer, public :: integrator character(len=self_FileNameLength), public :: meshFile integer, public :: nxElements integer, public :: nyElements integer, public :: nzElements real(kind=prec), public :: outputInterval type(Vector3D), public :: plotVelocity type(Vector3D), public :: plotX real(kind=prec), public :: simulationTime type(EquationParser), public, ALLOCATABLE :: solutionEqn (:) type(EquationParser), public, ALLOCATABLE :: sourceEqn (:) integer, public :: targetDegree integer, public :: targetQuadrature character(len=self_EquationLength), public :: velEqnX character(len=self_EquationLength), public :: velEqnY character(len=self_EquationLength), public :: velEqnZ type(MappedVector3D), public :: velocity Type-Bound Procedures procedure, public :: ForwardStep => ForwardStep_Advection3D procedure, public :: Free => Free_Advection3D procedure, public :: Init => Init_Advection3D procedure, public :: InitFromCLI => InitFromCLI_Advection3D procedure, public :: InternalFlux => InternalFlux_Advection3D generic, public :: SetBoundaryCondition => SetBoundaryConditionFromEquation_Advection3D procedure, private :: SetBoundaryConditionFromEquation_Advection3D generic, public :: SetSolution => SetSolutionFromEquation_Advection3D procedure, private :: SetSolutionFromEquation_Advection3D generic, public :: SetSource => SetSourceFromEquation_Advection3D procedure, private :: SetSourceFromEquation_Advection3D generic, public :: SetVelocity => SetVelocityFromEquation_Advection3D procedure, private :: SetVelocityFromEquation_Advection3D procedure, public :: SideFlux => SideFlux_Advection3D procedure, public :: Tendency => Tendency_Advection3D procedure, public :: TimeStepRK3 => TimeStepRK3_Advection3D procedure, public :: WriteTecplot => WriteTecplot_Advection3D Subroutines public subroutine ForwardStep_Advection3D (this, endTime) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this real(kind=prec), intent(in) :: endTime public subroutine Free_Advection3D (this) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this private subroutine GetCLIParameters (cli) Arguments Type Intent Optional Attributes Name type(COMMAND_LINE_INTERFACE), intent(inout) :: cli public subroutine InitFromCLI_Advection3D (this) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this public subroutine Init_Advection3D (this, cqType, tqType, cqDegree, tqDegree, nvar, enableMPI, spec) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(out) :: this integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nvar logical, intent(in) :: enableMPI type(MeshSpec), intent(in) :: spec public subroutine InternalFlux_Advection3D (this) Calculates the advective flux using the provided velocity Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this public subroutine SetBoundaryConditionFromEquation_Advection3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) public subroutine SetSolutionFromEquation_Advection3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) public subroutine SetSourceFromEquation_Advection3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) public subroutine SetVelocityFromEquation_Advection3D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:3) public subroutine SideFlux_Advection3D (this) Calculates the Advective Flux on element sides using a Lax-Friedrich's upwind Riemann Solver Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this public subroutine Tendency_Advection3D (this) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this public subroutine TimeStepRK3_Advection3D (this, nSteps) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: this integer, intent(in) :: nSteps public subroutine WriteTecplot_Advection3D (self, filename) Arguments Type Intent Optional Attributes Name class( Advection3D ), intent(inout) :: self character, intent(in), optional :: filename","tags":"","loc":"module/self_advection3d.html"},{"title":"SELF_Data – SELF","text":"Uses iso_c_binding SELF_Constants SELF_Lagrange module~~self_data~~UsesGraph module~self_data SELF_Data module~self_lagrange SELF_Lagrange module~self_data->module~self_lagrange iso_c_binding iso_c_binding module~self_data->iso_c_binding module~self_constants SELF_Constants module~self_data->module~self_constants module~self_lagrange->iso_c_binding module~self_lagrange->module~self_constants module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort_check hipfort_check module~self_lagrange->hipfort_check hipfort hipfort module~self_lagrange->hipfort iso_fortran_env iso_fortran_env module~self_lagrange->iso_fortran_env module~self_supportroutines SELF_SupportRoutines module~self_lagrange->module~self_supportroutines module~self_constants->iso_c_binding module~self_constants->iso_fortran_env module~self_memory->iso_c_binding module~self_memory->module~self_constants module~self_memory->hipfort_check module~self_memory->hipfort module~self_memory->iso_fortran_env module~self_quadrature->module~self_constants module~self_quadrature->iso_fortran_env module~self_supportroutines->module~self_constants module~self_supportroutines->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_data~~UsedByGraph module~self_data SELF_Data module~self_geometry SELF_Geometry module~self_geometry->module~self_data module~self_mesh SELF_Mesh module~self_geometry->module~self_mesh module~self_mesh->module~self_data module~self_mappeddata SELF_MappedData module~self_mappeddata->module~self_data module~self_mappeddata->module~self_geometry module~self_mappeddata->module~self_mesh module~self_dg SELF_DG module~self_dg->module~self_mesh module~self_dg->module~self_mappeddata program~sadv3d sadv3d program~sadv3d->module~self_mesh module~self_advection3d SELF_Advection3D program~sadv3d->module~self_advection3d program~sadv2d sadv2d program~sadv2d->module~self_mesh module~self_advection2d SELF_Advection2D program~sadv2d->module~self_advection2d module~self_advection3d->module~self_mesh module~self_advection3d->module~self_dg module~self_advection2d->module~self_mesh module~self_advection2d->module~self_dg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables selfStrongForm selfWeakCGForm selfWeakDGForm Interfaces Determinant_Tensor2D_gpu_wrapper Determinant_Tensor3D_gpu_wrapper Derived Types Scalar1D Scalar2D Scalar3D Tensor2D Tensor3D Vector2D Vector3D Functions AbsMaxBoundary_Scalar1D AbsMaxBoundary_Scalar2D AbsMaxBoundary_Scalar3D AbsMaxBoundary_Tensor2D AbsMaxBoundary_Tensor3D AbsMaxBoundary_Vector2D AbsMaxBoundary_Vector3D AbsMaxInterior_Scalar1D AbsMaxInterior_Scalar2D AbsMaxInterior_Scalar3D AbsMaxInterior_Tensor2D AbsMaxInterior_Tensor3D AbsMaxInterior_Vector2D AbsMaxInterior_Vector3D Add_Scalar1D Add_Scalar2D Add_Scalar3D Add_Tensor2D Add_Tensor3D Add_Vector2D Add_Vector3D Subtract_Scalar1D Subtract_Scalar2D Subtract_Scalar3D Subtract_Tensor2D Subtract_Tensor3D Subtract_Vector2D Subtract_Vector3D Subroutines BoundaryInterp_Scalar1D BoundaryInterp_Scalar2D BoundaryInterp_Scalar3D BoundaryInterp_Tensor2D BoundaryInterp_Tensor3D BoundaryInterp_Vector2D BoundaryInterp_Vector3D Curl_Vector2D Curl_Vector3D Derivative_Scalar1D Determinant_Tensor2D Determinant_Tensor3D Divergence_Tensor2D Divergence_Tensor3D Divergence_Vector2D Divergence_Vector3D Equals_Scalar1D Equals_Scalar2D Equals_Scalar3D Equals_Tensor2D Equals_Tensor3D Equals_Vector2D Equals_Vector3D Free_Scalar1D Free_Scalar2D Free_Scalar3D Free_Tensor2D Free_Tensor3D Free_Vector2D Free_Vector3D Gradient_Scalar2D Gradient_Scalar3D Gradient_Vector2D Gradient_Vector3D GridInterp_Scalar1D GridInterp_Scalar2D GridInterp_Scalar3D GridInterp_Tensor2D GridInterp_Tensor3D GridInterp_Vector2D GridInterp_Vector3D Init_Scalar1D Init_Scalar2D Init_Scalar3D Init_Tensor2D Init_Tensor3D Init_Vector2D Init_Vector3D UpdateDevice_Scalar1D UpdateDevice_Scalar2D UpdateDevice_Scalar3D UpdateDevice_Tensor2D UpdateDevice_Tensor3D UpdateDevice_Vector2D UpdateDevice_Vector3D UpdateHost_Scalar1D UpdateHost_Scalar2D UpdateHost_Scalar3D UpdateHost_Tensor2D UpdateHost_Tensor3D UpdateHost_Vector2D UpdateHost_Vector3D Variables Type Visibility Attributes Name Initial integer, public, parameter :: selfStrongForm = 0 integer, public, parameter :: selfWeakCGForm = 2 integer, public, parameter :: selfWeakDGForm = 1 Interfaces interface public subroutine Determinant_Tensor2D_gpu_wrapper(tensor_dev, detTensor_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor_dev type(c_ptr) :: detTensor_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine Determinant_Tensor3D_gpu_wrapper(tensor_dev, detTensor_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor_dev type(c_ptr) :: detTensor_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl Derived Types type, public :: Scalar1D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r3), public :: boundary integer, public :: controlType type(hfReal_r3), public :: extBoundary type(hfReal_r3), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Scalar1D procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Scalar1D procedure, public :: AbsMaxInterior => AbsMaxInterior_Scalar1D procedure, private, PASS(SELFa) :: Add_Scalar1D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D generic, public :: Derivative => Derivative_Scalar1D procedure, private :: Derivative_Scalar1D procedure, private, PASS(SELFOut) :: Equals_Scalar1D procedure, public :: Free => Free_Scalar1D procedure, public :: GridInterp => GridInterp_Scalar1D procedure, public :: Init => Init_Scalar1D generic, public :: OPERATOR(+) => Add_Scalar1D generic, public :: OPERATOR(-) => Subtract_Scalar1D procedure, private, PASS(SELFa) :: Subtract_Scalar1D procedure, public :: UpdateDevice => UpdateDevice_Scalar1D procedure, public :: UpdateHost => UpdateHost_Scalar1D type, public :: Scalar2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r4), public :: avgBoundary type(hfReal_r4), public :: boundary integer, public :: controlType type(hfReal_r4), public :: extBoundary type(hfReal_r4), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Scalar2D procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Scalar2D procedure, public :: AbsMaxInterior => AbsMaxInterior_Scalar2D procedure, private, PASS(SELFa) :: Add_Scalar2D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D procedure, private, PASS(SELFOut) :: Equals_Scalar2D procedure, public :: Free => Free_Scalar2D generic, public :: Gradient => Gradient_Scalar2D procedure, private :: Gradient_Scalar2D procedure, public :: GridInterp => GridInterp_Scalar2D procedure, public :: Init => Init_Scalar2D generic, public :: OPERATOR(+) => Add_Scalar2D generic, public :: OPERATOR(-) => Subtract_Scalar2D procedure, private, PASS(SELFa) :: Subtract_Scalar2D procedure, public :: UpdateDevice => UpdateDevice_Scalar2D procedure, public :: UpdateHost => UpdateHost_Scalar2D type, public :: Scalar3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r5), public :: avgBoundary type(hfReal_r5), public :: boundary integer, public :: controlType type(hfReal_r5), public :: extBoundary type(hfReal_r5), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Scalar3D procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Scalar3D procedure, public :: AbsMaxInterior => AbsMaxInterior_Scalar3D procedure, private, PASS(SELFa) :: Add_Scalar3D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D procedure, private, PASS(SELFOut) :: Equals_Scalar3D procedure, public :: Free => Free_Scalar3D generic, public :: Gradient => Gradient_Scalar3D procedure, private :: Gradient_Scalar3D procedure, public :: GridInterp => GridInterp_Scalar3D procedure, public :: Init => Init_Scalar3D generic, public :: OPERATOR(+) => Add_Scalar3D generic, public :: OPERATOR(-) => Subtract_Scalar3D procedure, private, PASS(SELFa) :: Subtract_Scalar3D procedure, public :: UpdateDevice => UpdateDevice_Scalar3D procedure, public :: UpdateHost => UpdateHost_Scalar3D type, public :: Tensor2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r6), public :: boundary integer, public :: controlType type(hfReal_r6), public :: extBoundary type(hfReal_r6), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Tensor2D procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Tensor2D procedure, public :: AbsMaxInterior => AbsMaxInterior_Tensor2D procedure, private, PASS(SELFa) :: Add_Tensor2D procedure, public :: BoundaryInterp => BoundaryInterp_Tensor2D procedure, public :: Determinant => Determinant_Tensor2D generic, public :: Divergence => Divergence_Tensor2D procedure, private :: Divergence_Tensor2D procedure, private, PASS(SELFOut) :: Equals_Tensor2D procedure, public :: Free => Free_Tensor2D procedure, public :: GridInterp => GridInterp_Tensor2D procedure, public :: Init => Init_Tensor2D generic, public :: OPERATOR(+) => Add_Tensor2D generic, public :: OPERATOR(-) => Subtract_Tensor2D procedure, private, PASS(SELFa) :: Subtract_Tensor2D procedure, public :: UpdateDevice => UpdateDevice_Tensor2D procedure, public :: UpdateHost => UpdateHost_Tensor2D type, public :: Tensor3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r7), public :: boundary integer, public :: controlType type(hfReal_r7), public :: extBoundary type(hfReal_r7), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Tensor3D procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Tensor3D procedure, public :: AbsMaxInterior => AbsMaxInterior_Tensor3D procedure, private, PASS(SELFa) :: Add_Tensor3D procedure, public :: BoundaryInterp => BoundaryInterp_Tensor3D procedure, public :: Determinant => Determinant_Tensor3D generic, public :: Divergence => Divergence_Tensor3D procedure, private :: Divergence_Tensor3D procedure, private, PASS(SELFOut) :: Equals_Tensor3D procedure, public :: Free => Free_Tensor3D procedure, public :: GridInterp => GridInterp_Tensor3D procedure, public :: Init => Init_Tensor3D generic, public :: OPERATOR(+) => Add_Tensor3D generic, public :: OPERATOR(-) => Subtract_Tensor3D procedure, private, PASS(SELFa) :: Subtract_Tensor3D procedure, public :: UpdateDevice => UpdateDevice_Tensor3D procedure, public :: UpdateHost => UpdateHost_Tensor3D type, public :: Vector2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r5), public :: boundary type(hfReal_r4), public :: boundaryNormal integer, public :: controlType type(hfReal_r5), public :: extBoundary type(hfReal_r5), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Vector2D procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Vector2D procedure, public :: AbsMaxInterior => AbsMaxInterior_Vector2D procedure, private, PASS(SELFa) :: Add_Vector2D procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D generic, public :: Curl => Curl_Vector2D procedure, private :: Curl_Vector2D generic, public :: Divergence => Divergence_Vector2D procedure, private :: Divergence_Vector2D procedure, private, PASS(SELFOut) :: Equals_Vector2D procedure, public :: Free => Free_Vector2D generic, public :: Gradient => Gradient_Vector2D procedure, private :: Gradient_Vector2D procedure, public :: GridInterp => GridInterp_Vector2D procedure, public :: Init => Init_Vector2D generic, public :: OPERATOR(+) => Add_Vector2D generic, public :: OPERATOR(-) => Subtract_Vector2D procedure, private, PASS(SELFa) :: Subtract_Vector2D procedure, public :: UpdateDevice => UpdateDevice_Vector2D procedure, public :: UpdateHost => UpdateHost_Vector2D type, public :: Vector3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r6), public :: boundary type(hfReal_r5), public :: boundaryNormal integer, public :: controlType type(hfReal_r6), public :: extBoundary type(hfReal_r6), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Vector3D procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Vector3D procedure, public :: AbsMaxInterior => AbsMaxInterior_Vector3D procedure, private, PASS(SELFa) :: Add_Vector3D procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D generic, public :: Curl => Curl_Vector3D procedure, private :: Curl_Vector3D generic, public :: Divergence => Divergence_Vector3D procedure, private :: Divergence_Vector3D procedure, private, PASS(SELFOut) :: Equals_Vector3D procedure, public :: Free => Free_Vector3D generic, public :: Gradient => Gradient_Vector3D procedure, private :: Gradient_Vector3D procedure, public :: GridInterp => GridInterp_Vector3D procedure, public :: Init => Init_Vector3D generic, public :: OPERATOR(+) => Add_Vector3D generic, public :: OPERATOR(-) => Subtract_Vector3D procedure, private, PASS(SELFa) :: Subtract_Vector3D procedure, public :: UpdateDevice => UpdateDevice_Vector3D procedure, public :: UpdateHost => UpdateHost_Vector3D Functions public function AbsMaxBoundary_Scalar1D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar1D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:2) public function AbsMaxBoundary_Scalar2D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar2D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:4) public function AbsMaxBoundary_Scalar3D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar3D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:6) public function AbsMaxBoundary_Tensor2D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor2D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar,1:4) public function AbsMaxBoundary_Tensor3D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor3D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar,1:6) public function AbsMaxBoundary_Vector2D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector2D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar,1:4) public function AbsMaxBoundary_Vector3D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector3D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar,1:6) public function AbsMaxInterior_Scalar1D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar1D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) public function AbsMaxInterior_Scalar2D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar2D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) public function AbsMaxInterior_Scalar3D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar3D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) public function AbsMaxInterior_Tensor2D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor2D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar) public function AbsMaxInterior_Tensor3D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor3D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar) public function AbsMaxInterior_Vector2D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector2D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar) public function AbsMaxInterior_Vector3D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector3D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar) public function Add_Scalar1D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) public function Add_Scalar2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) public function Add_Scalar3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) public function Add_Tensor2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) public function Add_Tensor3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) public function Add_Vector2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) public function Add_Vector3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) public function Subtract_Scalar1D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) public function Subtract_Scalar2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) public function Subtract_Scalar3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) public function Subtract_Tensor2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) public function Subtract_Tensor3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) public function Subtract_Vector2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) public function Subtract_Vector3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) Subroutines public subroutine BoundaryInterp_Scalar1D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Scalar2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Scalar3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Tensor2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Tensor3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Vector2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Vector3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine Curl_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Curl_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Derivative_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Determinant_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Determinant_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Divergence_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Divergence_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Divergence_Vector2D (SELFStorage, SELFOut, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Divergence_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Equals_Scalar1D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFOut type( Scalar1D ), intent(in) :: SELFin public subroutine Equals_Scalar2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFOut type( Scalar2D ), intent(in) :: SELFin public subroutine Equals_Scalar3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFOut type( Scalar3D ), intent(in) :: SELFin public subroutine Equals_Tensor2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFOut type( Tensor2D ), intent(in) :: SELFin public subroutine Equals_Tensor3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFOut type( Tensor3D ), intent(in) :: SELFin public subroutine Equals_Vector2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFOut type( Vector2D ), intent(in) :: SELFin public subroutine Equals_Vector3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFOut type( Vector3D ), intent(in) :: SELFin public subroutine Free_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage public subroutine Free_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage public subroutine Free_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage public subroutine Free_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage public subroutine Free_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage public subroutine Free_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage public subroutine Free_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage public subroutine Gradient_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Gradient_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Gradient_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Gradient_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Init_Scalar1D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Scalar2D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Scalar3D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Tensor2D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Tensor3D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Vector2D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Vector3D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine UpdateDevice_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage","tags":"","loc":"module/self_data.html"},{"title":"SELF_Mesh – SELF","text":"Uses iso_c_binding SELF_MPI SELF_HashTable SELF_HDF5 SELF_Data SELF_Constants SELF_Lagrange SELF_SupportRoutines HDF5 module~~self_mesh~~UsesGraph module~self_mesh SELF_Mesh module~self_lagrange SELF_Lagrange module~self_mesh->module~self_lagrange module~self_constants SELF_Constants module~self_mesh->module~self_constants module~self_data SELF_Data module~self_mesh->module~self_data module~self_hashtable SELF_HashTable module~self_mesh->module~self_hashtable iso_c_binding iso_c_binding module~self_mesh->iso_c_binding module~self_mpi SELF_MPI module~self_mesh->module~self_mpi HDF5 HDF5 module~self_mesh->HDF5 module~self_supportroutines SELF_SupportRoutines module~self_mesh->module~self_supportroutines module~self_hdf5 SELF_HDF5 module~self_mesh->module~self_hdf5 module~self_lagrange->module~self_constants module~self_lagrange->iso_c_binding module~self_lagrange->module~self_supportroutines module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort_check hipfort_check module~self_lagrange->hipfort_check hipfort hipfort module~self_lagrange->hipfort iso_fortran_env iso_fortran_env module~self_lagrange->iso_fortran_env module~self_constants->iso_c_binding module~self_constants->iso_fortran_env module~self_data->module~self_lagrange module~self_data->module~self_constants module~self_data->iso_c_binding module~self_hashtable->module~self_constants module~self_linkedlist SELF_LinkedList module~self_hashtable->module~self_linkedlist module~self_mpi->module~self_constants module~self_mpi->iso_c_binding module~self_mpi->module~self_memory module~self_supportroutines->module~self_constants module~self_supportroutines->iso_fortran_env module~self_hdf5->module~self_constants module~self_hdf5->HDF5 module~self_hdf5->module~self_memory module~self_hdf5->iso_fortran_env module~self_memory->module~self_constants module~self_memory->iso_c_binding module~self_memory->hipfort_check module~self_memory->hipfort module~self_memory->iso_fortran_env module~self_quadrature->module~self_constants module~self_quadrature->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_mesh~~UsedByGraph module~self_mesh SELF_Mesh module~self_mappeddata SELF_MappedData module~self_mappeddata->module~self_mesh module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry module~self_dg SELF_DG module~self_dg->module~self_mesh module~self_dg->module~self_mappeddata module~self_advection3d SELF_Advection3D module~self_advection3d->module~self_mesh module~self_advection3d->module~self_dg module~self_geometry->module~self_mesh program~sadv2d sadv2d program~sadv2d->module~self_mesh module~self_advection2d SELF_Advection2D program~sadv2d->module~self_advection2d program~sadv3d sadv3d program~sadv3d->module~self_mesh program~sadv3d->module~self_advection3d module~self_advection2d->module~self_mesh module~self_advection2d->module~self_dg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables SELF_MESH_HOPR_2D SELF_MESH_HOPR_3D SELF_MESH_ISM_V2_2D SELF_MESH_ISM_V2_3D selfHexahedronBilinear selfHexahedronLinear selfHexahedronNonlinear selfLineLinear selfLineNonlinear selfMaxNodalValence2D selfMaxNodalValence3D selfMinNodalValence2D selfMinNodalValence3D selfPrismBilinear selfPrismLinear selfPrismNonlinear selfPyramidBilinear selfPyramidLinear selfPyramidNonlinear selfQuadBilinear selfQuadLinear selfQuadNonlinear selfSide2D_East selfSide2D_North selfSide2D_South selfSide2D_West selfSide3D_Bottom selfSide3D_East selfSide3D_North selfSide3D_South selfSide3D_Top selfSide3D_West selfTetrahedronLinear selfTetrahedronNonlinear selfTriangleLinear selfTriangleNonlinear self_BCDefault self_nBCsDefault Derived Types Mesh1D Mesh2D Mesh3D MeshSpec Functions LinearBlend Unidirectional Subroutines Free_Mesh1D Free_Mesh2D Free_Mesh3D GenerateConnectivity_Mesh2D Init_Mesh1D Init_Mesh2D Init_Mesh3D Load_Mesh2D_parallel Load_Mesh2D_serial Load_Mesh3D_parallel Load_Mesh3D_serial Read_HOPr_Mesh1D_parallel Read_HOPr_Mesh1D_serial Read_HOPr_Mesh2D_parallel Read_HOPr_Mesh2D_serial Read_HOPr_Mesh3D_parallel Read_HOPr_Mesh3D_serial Read_ISMv2_Mesh2D UniformBlockMesh_Mesh1D UniformBlockMesh_Mesh2D UniformBlockMesh_Mesh3D UpdateDevice_Mesh1D UpdateDevice_Mesh2D UpdateDevice_Mesh3D UpdateHost_Mesh1D UpdateHost_Mesh2D UpdateHost_Mesh3D Write_HOPr_Mesh1D Write_HOPr_Mesh2D Write_HOPr_Mesh3D Variables Type Visibility Attributes Name Initial integer, public, parameter :: SELF_MESH_HOPR_2D = 3 integer, public, parameter :: SELF_MESH_HOPR_3D = 4 integer, public, parameter :: SELF_MESH_ISM_V2_2D = 1 integer, public, parameter :: SELF_MESH_ISM_V2_3D = 2 integer, public, parameter :: selfHexahedronBilinear = 118 integer, public, parameter :: selfHexahedronLinear = 108 integer, public, parameter :: selfHexahedronNonlinear = 208 integer, public, parameter :: selfLineLinear = 1 integer, public, parameter :: selfLineNonlinear = 2 integer, public, parameter :: selfMaxNodalValence2D = 6 integer, public, parameter :: selfMaxNodalValence3D = 10 integer, public, parameter :: selfMinNodalValence2D = 4 integer, public, parameter :: selfMinNodalValence3D = 8 integer, public, parameter :: selfPrismBilinear = 116 integer, public, parameter :: selfPrismLinear = 106 integer, public, parameter :: selfPrismNonlinear = 206 integer, public, parameter :: selfPyramidBilinear = 115 integer, public, parameter :: selfPyramidLinear = 105 integer, public, parameter :: selfPyramidNonlinear = 205 integer, public, parameter :: selfQuadBilinear = 14 integer, public, parameter :: selfQuadLinear = 4 integer, public, parameter :: selfQuadNonlinear = 24 integer, public, parameter :: selfSide2D_East = 2 integer, public, parameter :: selfSide2D_North = 3 integer, public, parameter :: selfSide2D_South = 1 integer, public, parameter :: selfSide2D_West = 4 integer, public, parameter :: selfSide3D_Bottom = 1 integer, public, parameter :: selfSide3D_East = 3 integer, public, parameter :: selfSide3D_North = 4 integer, public, parameter :: selfSide3D_South = 2 integer, public, parameter :: selfSide3D_Top = 6 integer, public, parameter :: selfSide3D_West = 5 integer, public, parameter :: selfTetrahedronLinear = 104 integer, public, parameter :: selfTetrahedronNonlinear = 204 integer, public, parameter :: selfTriangleLinear = 3 integer, public, parameter :: selfTriangleNonlinear = 23 integer, public, parameter :: self_BCDefault = 1 integer, public, parameter :: self_nBCsDefault = 5 Derived Types type, public :: Mesh1D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type(hfInt32_r2), public :: BCType type(hfInt32_r2), public :: hopr_elemInfo type(hfInt32_r1), public :: hopr_globalNodeIDs type(hfReal_r1), public :: hopr_nodeCoords integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nNodes integer, public :: nUniqueNodes Type-Bound Procedures procedure, public :: Free => Free_Mesh1D procedure, public :: Init => Init_Mesh1D generic, public :: Read_HOPr => Read_HOPr_Mesh1D_serial, Read_HOPr_Mesh1D_parallel procedure, private :: Read_HOPr_Mesh1D_parallel procedure, private :: Read_HOPr_Mesh1D_serial procedure, public :: UniformBlockMesh => UniformBlockMesh_Mesh1D procedure, public :: UpdateDevice => UpdateDevice_Mesh1D procedure, public :: UpdateHost => UpdateHost_Mesh1D procedure, public :: Write_HOPr => Write_HOPr_Mesh1D type, public :: Mesh2D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type(hfInt32_r2), public :: BCType type(hfReal_r2), public :: hohq_cornerNodes type(hfInt32_r2), public :: hohq_elemInfo type(hfReal_r4), public :: hohq_sideCurves type(hfInt32_r2), public :: hohq_sideInfo type(hfInt32_r1), public :: hopr_CGNSCornerMap type(hfInt32_r2), public :: hopr_CGNSSideMap type(hfInt32_r2), public :: hopr_curveNodeMap type(hfInt32_r2), public :: hopr_curveNodeMapInv type(hfInt32_r2), public :: hopr_elemInfo type(hfInt32_r1), public :: hopr_globalNodeIDs type(hfReal_r2), public :: hopr_nodeCoords type(hfInt32_r2), public :: hopr_sideInfo integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides type(hfReal_r3), public :: self_nodeCoords type(hfInt32_r3), public :: self_sideInfo Type-Bound Procedures procedure, public :: Free => Free_Mesh2D procedure, private :: GenerateConnectivity => GenerateConnectivity_Mesh2D procedure, public :: Init => Init_Mesh2D generic, public :: Load => Load_Mesh2D_serial, Load_Mesh2D_parallel procedure, private :: Load_Mesh2D_parallel procedure, private :: Load_Mesh2D_serial generic, public :: Read_HOPr => Read_HOPr_Mesh2D_serial, Read_HOPr_Mesh2D_parallel procedure, private :: Read_HOPr_Mesh2D_parallel procedure, private :: Read_HOPr_Mesh2D_serial procedure, public :: Read_ISMv2 => Read_ISMv2_Mesh2D procedure, public :: UniformBlockMesh => UniformBlockMesh_Mesh2D procedure, public :: UpdateDevice => UpdateDevice_Mesh2D procedure, public :: UpdateHost => UpdateHost_Mesh2D procedure, public :: Write_HOPr => Write_HOPr_Mesh2D type, public :: Mesh3D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type(hfInt32_r2), public :: BCType type(hfReal_r2), public :: hohq_cornerNodes type(hfInt32_r2), public :: hohq_elemInfo type(hfInt32_r2), public :: hohq_sideInfo type(hfReal_r5), public :: hohq_sideSurfaces type(hfInt32_r1), public :: hopr_CGNSCornerMap type(hfInt32_r2), public :: hopr_CGNSSideMap type(hfInt32_r2), public :: hopr_curveNodeMap type(hfInt32_r3), public :: hopr_curveNodeMapInv type(hfInt32_r2), public :: hopr_elemInfo type(hfInt32_r1), public :: hopr_globalNodeIDs type(hfReal_r2), public :: hopr_nodeCoords type(hfInt32_r2), public :: hopr_sideInfo integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides type(hfReal_r3), public :: self_nodeCoords type(hfInt32_r3), public :: self_sideInfo Type-Bound Procedures procedure, public :: Free => Free_Mesh3D procedure, public :: Init => Init_Mesh3D generic, public :: Load => Load_Mesh3D_serial, Load_Mesh3D_parallel procedure, private :: Load_Mesh3D_parallel procedure, private :: Load_Mesh3D_serial generic, public :: Read_HOPr => Read_HOPr_Mesh3D_serial, Read_HOPr_Mesh3D_parallel procedure, private :: Read_HOPr_Mesh3D_parallel procedure, private :: Read_HOPr_Mesh3D_serial procedure, public :: UniformBlockMesh => UniformBlockMesh_Mesh3D procedure, public :: UpdateDevice => UpdateDevice_Mesh3D procedure, public :: UpdateHost => UpdateHost_Mesh3D procedure, public :: Write_HOPr => Write_HOPr_Mesh3D type, public :: MeshSpec Components Type Visibility Attributes Name Initial logical, public :: blockMesh integer, public :: blockMesh_nElemX integer, public :: blockMesh_nElemY integer, public :: blockMesh_nElemZ integer, public :: blockMesh_nGeo real(kind=prec), public :: blockMesh_x0 real(kind=prec), public :: blockMesh_x1 real(kind=prec), public :: blockMesh_y0 real(kind=prec), public :: blockMesh_y1 real(kind=prec), public :: blockMesh_z0 real(kind=prec), public :: blockMesh_z1 integer, public :: fileType character, public :: filename Functions public function LinearBlend (a) result(weights) Arguments Type Intent Optional Attributes Name real(kind=prec) :: a Return Value real(kind=prec)\n  (1:2) public function Unidirectional (valLeft, valRight, a) result(P) Arguments Type Intent Optional Attributes Name real(kind=prec) :: valLeft (1:3) real(kind=prec) :: valRight (1:3) real(kind=prec) :: a Return Value real(kind=prec)\n  (1:3) Subroutines public subroutine Free_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh public subroutine Free_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh public subroutine Free_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh public subroutine GenerateConnectivity_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh public subroutine Init_Mesh1D (myMesh, nGeo, nElem, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nNodes integer, intent(in) :: nBCs public subroutine Init_Mesh2D (myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs public subroutine Init_Mesh3D (myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs public subroutine Load_Mesh2D_parallel (myMesh, myMeshSpec, decomp) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec type(MPILayer), intent(inout) :: decomp public subroutine Load_Mesh2D_serial (myMesh, myMeshSpec) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec public subroutine Load_Mesh3D_parallel (myMesh, myMeshSpec, decomp) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec type(MPILayer), intent(inout) :: decomp public subroutine Load_Mesh3D_serial (myMesh, myMeshSpec) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh type( MeshSpec ), intent(in) :: myMeshSpec public subroutine Read_HOPr_Mesh1D_parallel (myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh character, intent(in) :: meshFile type(MPILayer), intent(inout) :: decomp public subroutine Read_HOPr_Mesh1D_serial (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh character, intent(in) :: meshFile public subroutine Read_HOPr_Mesh2D_parallel (myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh character, intent(in) :: meshFile type(MPILayer), intent(inout) :: decomp public subroutine Read_HOPr_Mesh2D_serial (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh character, intent(in) :: meshFile public subroutine Read_HOPr_Mesh3D_parallel (myMesh, meshFile, decomp) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh character, intent(in) :: meshFile type(MPILayer), intent(inout) :: decomp public subroutine Read_HOPr_Mesh3D_serial (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh character, intent(in) :: meshFile public subroutine Read_ISMv2_Mesh2D (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh character, intent(in) :: meshFile public subroutine UniformBlockMesh_Mesh1D (myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem real(kind=prec), intent(in) :: x (1:2) public subroutine UniformBlockMesh_Mesh2D (myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem (1:2) real(kind=prec), intent(in) :: x (1:4) public subroutine UniformBlockMesh_Mesh3D (myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem (1:3) real(kind=prec), intent(in) :: x (1:6) public subroutine UpdateDevice_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh public subroutine UpdateDevice_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh public subroutine UpdateDevice_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh public subroutine UpdateHost_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh public subroutine UpdateHost_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh public subroutine UpdateHost_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh public subroutine Write_HOPr_Mesh1D (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh character, intent(in) :: meshFile public subroutine Write_HOPr_Mesh2D (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh character, intent(in) :: meshFile public subroutine Write_HOPr_Mesh3D (myMesh, meshFile) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh character, intent(in) :: meshFile","tags":"","loc":"module/self_mesh.html"},{"title":"SELF_MPI – SELF","text":"Uses iso_c_binding SELF_Constants SELF_Memory module~~self_mpi~~UsesGraph module~self_mpi SELF_MPI module~self_memory SELF_Memory module~self_mpi->module~self_memory iso_c_binding iso_c_binding module~self_mpi->iso_c_binding module~self_constants SELF_Constants module~self_mpi->module~self_constants module~self_memory->iso_c_binding module~self_memory->module~self_constants iso_fortran_env iso_fortran_env module~self_memory->iso_fortran_env hipfort_check hipfort_check module~self_memory->hipfort_check hipfort hipfort module~self_memory->hipfort module~self_constants->iso_c_binding module~self_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_mpi~~UsedByGraph module~self_mpi SELF_MPI module~self_mesh SELF_Mesh module~self_mesh->module~self_mpi module~self_mappeddata SELF_MappedData module~self_mappeddata->module~self_mpi module~self_mappeddata->module~self_mesh module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry module~self_dg SELF_DG module~self_dg->module~self_mpi module~self_dg->module~self_mesh module~self_dg->module~self_mappeddata program~sadv3d sadv3d program~sadv3d->module~self_mesh module~self_advection3d SELF_Advection3D program~sadv3d->module~self_advection3d module~self_geometry->module~self_mesh program~sadv2d sadv2d program~sadv2d->module~self_mesh module~self_advection2d SELF_Advection2D program~sadv2d->module~self_advection2d module~self_advection3d->module~self_mesh module~self_advection3d->module~self_dg module~self_advection2d->module~self_mesh module~self_advection2d->module~self_dg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Derived Types MPILayer Subroutines DomainDecomp ElemToRank FinalizeMPIExchangeAsync Free_MPILayer Init_MPILayer SetElemToRank SetMaxMsg Derived Types type, public :: MPILayer Components Type Visibility Attributes Name Initial type(hfInt32_r1), public :: elemToRank integer, public :: maxMsg integer, public :: mpiComm logical, public :: mpiEnabled integer, public :: mpiPrec integer, public :: msgCount integer, public :: nElem integer, public :: nRanks type(hfInt32_r1), public :: offSetElem integer, public :: rankId type(hfInt32_r2), public :: requests Type-Bound Procedures procedure, public :: FinalizeMPIExchangeAsync procedure, public :: Free => Free_MPILayer procedure, public :: Init => Init_MPILayer procedure, public :: SetElemToRank procedure, public :: SetMaxMsg Subroutines public subroutine DomainDecomp (nElems, nDomains, offsetElem) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nElems integer, intent(in) :: nDomains integer, intent(out) :: offsetElem (0:nDomains) public subroutine ElemToRank (nDomains, offsetElem, elemID, domain) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nDomains integer, intent(in) :: offsetElem (0:nDomains) integer, intent(in) :: elemID integer, intent(out) :: domain public subroutine FinalizeMPIExchangeAsync (mpiHandler) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: mpiHandler public subroutine Free_MPILayer (this) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this public subroutine Init_MPILayer (this, enableMPI) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(out) :: this logical, intent(in) :: enableMPI public subroutine SetElemToRank (this, nElem) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this integer, intent(in) :: nElem public subroutine SetMaxMsg (this, maxMsg) Arguments Type Intent Optional Attributes Name class( MPILayer ), intent(inout) :: this integer, intent(in) :: maxMsg","tags":"","loc":"module/self_mpi.html"},{"title":"SELF_HDF5 – SELF","text":"Uses iso_fortran_env HDF5 SELF_Constants SELF_Memory module~~self_hdf5~~UsesGraph module~self_hdf5 SELF_HDF5 module~self_memory SELF_Memory module~self_hdf5->module~self_memory HDF5 HDF5 module~self_hdf5->HDF5 module~self_constants SELF_Constants module~self_hdf5->module~self_constants iso_fortran_env iso_fortran_env module~self_hdf5->iso_fortran_env module~self_memory->module~self_constants module~self_memory->iso_fortran_env iso_c_binding iso_c_binding module~self_memory->iso_c_binding hipfort_check hipfort_check module~self_memory->hipfort_check hipfort hipfort module~self_memory->hipfort module~self_constants->iso_fortran_env module~self_constants->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_hdf5~~UsedByGraph module~self_hdf5 SELF_HDF5 module~self_metadata SELF_Metadata module~self_metadata->module~self_hdf5 module~self_mesh SELF_Mesh module~self_mesh->module~self_hdf5 module~self_dg SELF_DG module~self_dg->module~self_hdf5 module~self_dg->module~self_metadata module~self_dg->module~self_mesh module~self_mappeddata SELF_MappedData module~self_dg->module~self_mappeddata module~self_mappeddata->module~self_mesh module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry program~sadv3d sadv3d program~sadv3d->module~self_mesh module~self_advection3d SELF_Advection3D program~sadv3d->module~self_advection3d module~self_geometry->module~self_mesh program~sadv2d sadv2d program~sadv2d->module~self_mesh module~self_advection2d SELF_Advection2D program~sadv2d->module~self_advection2d module~self_advection3d->module~self_mesh module~self_advection3d->module~self_dg module~self_advection2d->module~self_mesh module~self_advection2d->module~self_dg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces Open_HDF5 ReadArray_HDF5 ReadAttribute_HDF5 WriteArray_HDF5 WriteAttribute_HDF5 Subroutines Close_HDF5 CreateGroup_HDF5 Open_HDF5_parallel Open_HDF5_serial ReadArray_HDF5_int32_r1_parallel ReadArray_HDF5_int32_r1_serial ReadArray_HDF5_int32_r2_parallel ReadArray_HDF5_int32_r2_serial ReadArray_HDF5_int32_r3_parallel ReadArray_HDF5_int32_r3_serial ReadArray_HDF5_int32_r4_parallel ReadArray_HDF5_int32_r4_serial ReadArray_HDF5_int32_r5_parallel ReadArray_HDF5_int32_r5_serial ReadArray_HDF5_int32_r6_parallel ReadArray_HDF5_int32_r6_serial ReadArray_HDF5_int32_r7_parallel ReadArray_HDF5_int32_r7_serial ReadArray_HDF5_int64_r1_parallel ReadArray_HDF5_int64_r1_serial ReadArray_HDF5_int64_r2_parallel ReadArray_HDF5_int64_r2_serial ReadArray_HDF5_int64_r3_parallel ReadArray_HDF5_int64_r3_serial ReadArray_HDF5_int64_r4_parallel ReadArray_HDF5_int64_r4_serial ReadArray_HDF5_int64_r5_parallel ReadArray_HDF5_int64_r5_serial ReadArray_HDF5_int64_r6_parallel ReadArray_HDF5_int64_r6_serial ReadArray_HDF5_int64_r7_parallel ReadArray_HDF5_int64_r7_serial ReadArray_HDF5_real_r1_parallel ReadArray_HDF5_real_r1_serial ReadArray_HDF5_real_r2_parallel ReadArray_HDF5_real_r2_serial ReadArray_HDF5_real_r3_parallel ReadArray_HDF5_real_r3_serial ReadArray_HDF5_real_r4_parallel ReadArray_HDF5_real_r4_serial ReadArray_HDF5_real_r5_parallel ReadArray_HDF5_real_r5_serial ReadArray_HDF5_real_r6_parallel ReadArray_HDF5_real_r6_serial ReadArray_HDF5_real_r7_parallel ReadArray_HDF5_real_r7_serial ReadAttribute_HDF5_character ReadAttribute_HDF5_int32 ReadAttribute_HDF5_real WriteArray_HDF5_int32_r1_parallel WriteArray_HDF5_int32_r1_serial WriteArray_HDF5_int32_r2_parallel WriteArray_HDF5_int32_r2_serial WriteArray_HDF5_int32_r3_parallel WriteArray_HDF5_int32_r3_serial WriteArray_HDF5_int32_r4_parallel WriteArray_HDF5_int32_r4_serial WriteArray_HDF5_int32_r5_parallel WriteArray_HDF5_int32_r5_serial WriteArray_HDF5_int32_r6_parallel WriteArray_HDF5_int32_r6_serial WriteArray_HDF5_int32_r7_parallel WriteArray_HDF5_int32_r7_serial WriteArray_HDF5_int64_r1_parallel WriteArray_HDF5_int64_r1_serial WriteArray_HDF5_int64_r2_parallel WriteArray_HDF5_int64_r2_serial WriteArray_HDF5_int64_r3_parallel WriteArray_HDF5_int64_r3_serial WriteArray_HDF5_int64_r4_parallel WriteArray_HDF5_int64_r4_serial WriteArray_HDF5_int64_r5_parallel WriteArray_HDF5_int64_r5_serial WriteArray_HDF5_int64_r6_parallel WriteArray_HDF5_int64_r6_serial WriteArray_HDF5_int64_r7_parallel WriteArray_HDF5_int64_r7_serial WriteArray_HDF5_real_r1_parallel WriteArray_HDF5_real_r1_serial WriteArray_HDF5_real_r2_parallel WriteArray_HDF5_real_r2_serial WriteArray_HDF5_real_r3_parallel WriteArray_HDF5_real_r3_serial WriteArray_HDF5_real_r4_parallel WriteArray_HDF5_real_r4_serial WriteArray_HDF5_real_r5_parallel WriteArray_HDF5_real_r5_serial WriteArray_HDF5_real_r6_parallel WriteArray_HDF5_real_r6_serial WriteArray_HDF5_real_r7_parallel WriteArray_HDF5_real_r7_serial WriteAttribute_HDF5_character WriteAttribute_HDF5_int32 WriteAttribute_HDF5_real Interfaces public interface Open_HDF5 private subroutine Open_HDF5_serial (fileName, accessFlag, fileId) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId private subroutine Open_HDF5_parallel (fileName, accessFlag, fileId, mpiComm) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId integer, intent(in) :: mpiComm public interface ReadArray_HDF5 private subroutine ReadArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r1), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r2), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r3), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r4), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r5), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r6), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r7), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r1), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r2), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r3), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r4), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r5), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r6), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r7), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_real_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) private subroutine ReadArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) private subroutine ReadArray_HDF5_real_r5_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) private subroutine ReadArray_HDF5_real_r6_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) private subroutine ReadArray_HDF5_real_r7_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) private subroutine ReadArray_HDF5_int32_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r1), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_int32_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r2), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_int32_r3_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r3), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) private subroutine ReadArray_HDF5_int32_r4_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r4), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) private subroutine ReadArray_HDF5_int32_r5_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r5), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) private subroutine ReadArray_HDF5_int32_r6_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r6), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) private subroutine ReadArray_HDF5_int32_r7_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r7), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) private subroutine ReadArray_HDF5_int64_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r1), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_int64_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r2), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_int64_r3_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r3), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) private subroutine ReadArray_HDF5_int64_r4_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r4), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) private subroutine ReadArray_HDF5_int64_r5_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r5), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) private subroutine ReadArray_HDF5_int64_r6_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r6), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) private subroutine ReadArray_HDF5_int64_r7_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r7), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) public interface ReadAttribute_HDF5 private subroutine ReadAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(out) :: attribute private subroutine ReadAttribute_HDF5_real (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(out) :: attribute private subroutine ReadAttribute_HDF5_character (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(out) :: attribute public interface WriteArray_HDF5 private subroutine WriteArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r1), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r2), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r3), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r4), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r5), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r6), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r7), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r1), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r2), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r3), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r4), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r5), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r6), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r7), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r1_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) private subroutine WriteArray_HDF5_real_r2_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) private subroutine WriteArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) private subroutine WriteArray_HDF5_real_r5_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) private subroutine WriteArray_HDF5_real_r6_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) private subroutine WriteArray_HDF5_real_r7_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) integer(kind=HID_T), intent(in) :: globalDims (1:7) private subroutine WriteArray_HDF5_int32_r1_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r1), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) private subroutine WriteArray_HDF5_int32_r2_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r2), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) private subroutine WriteArray_HDF5_int32_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r3), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_int32_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r4), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) private subroutine WriteArray_HDF5_int32_r5_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r5), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) private subroutine WriteArray_HDF5_int32_r6_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r6), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) private subroutine WriteArray_HDF5_int32_r7_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r7), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) integer(kind=HID_T), intent(in) :: globalDims (1:7) private subroutine WriteArray_HDF5_int64_r1_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r1), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) private subroutine WriteArray_HDF5_int64_r2_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r2), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) private subroutine WriteArray_HDF5_int64_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r3), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_int64_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r4), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) private subroutine WriteArray_HDF5_int64_r5_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r5), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) private subroutine WriteArray_HDF5_int64_r6_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r6), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) private subroutine WriteArray_HDF5_int64_r7_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r7), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) integer(kind=HID_T), intent(in) :: globalDims (1:7) public interface WriteAttribute_HDF5 private subroutine WriteAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(in) :: attribute private subroutine WriteAttribute_HDF5_real (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(in) :: attribute private subroutine WriteAttribute_HDF5_character (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(in) :: attribute Subroutines public subroutine Close_HDF5 (fileId) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId public subroutine CreateGroup_HDF5 (fileId, groupName) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: groupName private subroutine Open_HDF5_parallel (fileName, accessFlag, fileId, mpiComm) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId integer, intent(in) :: mpiComm private subroutine Open_HDF5_serial (fileName, accessFlag, fileId) Arguments Type Intent Optional Attributes Name character, intent(in) :: fileName integer, intent(in) :: accessFlag integer(kind=HID_T), intent(inout) :: fileId private subroutine ReadArray_HDF5_int32_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r1), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r1), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r2), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r2), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r3_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r3), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) private subroutine ReadArray_HDF5_int32_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r3), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r4_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r4), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) private subroutine ReadArray_HDF5_int32_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r4), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r5_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r5), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) private subroutine ReadArray_HDF5_int32_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r5), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r6_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r6), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) private subroutine ReadArray_HDF5_int32_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r6), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int32_r7_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r7), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) private subroutine ReadArray_HDF5_int32_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt32_r7), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r1), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_int64_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r1), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r2), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_int64_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r2), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r3_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r3), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) private subroutine ReadArray_HDF5_int64_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r3), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r4_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r4), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) private subroutine ReadArray_HDF5_int64_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r4), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r5_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r5), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) private subroutine ReadArray_HDF5_int64_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r5), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r6_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r6), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) private subroutine ReadArray_HDF5_int64_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r6), intent(inout) :: hfArray private subroutine ReadArray_HDF5_int64_r7_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r7), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) private subroutine ReadArray_HDF5_int64_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfInt64_r7), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r1_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) private subroutine ReadArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r2_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) private subroutine ReadArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) private subroutine ReadArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) private subroutine ReadArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r5_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) private subroutine ReadArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r6_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) private subroutine ReadArray_HDF5_real_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(inout) :: hfArray private subroutine ReadArray_HDF5_real_r7_parallel (fileId, arrayName, hfArray, offset) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(inout) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) private subroutine ReadArray_HDF5_real_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(inout) :: hfArray private subroutine ReadAttribute_HDF5_character (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(out) :: attribute private subroutine ReadAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(out) :: attribute private subroutine ReadAttribute_HDF5_real (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(out) :: attribute private subroutine WriteArray_HDF5_int32_r1_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r1), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) private subroutine WriteArray_HDF5_int32_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r1), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r2_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r2), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) private subroutine WriteArray_HDF5_int32_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r2), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r3), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_int32_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r3), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r4), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) private subroutine WriteArray_HDF5_int32_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r4), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r5_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r5), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) private subroutine WriteArray_HDF5_int32_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r5), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r6_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r6), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) private subroutine WriteArray_HDF5_int32_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r6), intent(in) :: hfArray private subroutine WriteArray_HDF5_int32_r7_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r7), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) integer(kind=HID_T), intent(in) :: globalDims (1:7) private subroutine WriteArray_HDF5_int32_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint32_r7), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r1_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r1), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) private subroutine WriteArray_HDF5_int64_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r1), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r2_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r2), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) private subroutine WriteArray_HDF5_int64_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r2), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r3), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_int64_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r3), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r4), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) private subroutine WriteArray_HDF5_int64_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r4), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r5_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r5), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) private subroutine WriteArray_HDF5_int64_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r5), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r6_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r6), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) private subroutine WriteArray_HDF5_int64_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r6), intent(in) :: hfArray private subroutine WriteArray_HDF5_int64_r7_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r7), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) integer(kind=HID_T), intent(in) :: globalDims (1:7) private subroutine WriteArray_HDF5_int64_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfint64_r7), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r1_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1) integer(kind=HID_T), intent(in) :: globalDims (1) private subroutine WriteArray_HDF5_real_r1_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r1), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r2_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:2) integer(kind=HID_T), intent(in) :: globalDims (1:2) private subroutine WriteArray_HDF5_real_r2_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r2), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r3_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:3) integer(kind=HID_T), intent(in) :: globalDims (1:3) private subroutine WriteArray_HDF5_real_r3_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r3), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r4_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:4) integer(kind=HID_T), intent(in) :: globalDims (1:4) private subroutine WriteArray_HDF5_real_r4_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r4), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r5_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:5) integer(kind=HID_T), intent(in) :: globalDims (1:5) private subroutine WriteArray_HDF5_real_r5_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r5), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r6_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:6) integer(kind=HID_T), intent(in) :: globalDims (1:6) private subroutine WriteArray_HDF5_real_r6_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r6), intent(in) :: hfArray private subroutine WriteArray_HDF5_real_r7_parallel (fileId, arrayName, hfArray, offset, globalDims) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(in) :: hfArray integer(kind=HID_T), intent(in) :: offset (1:7) integer(kind=HID_T), intent(in) :: globalDims (1:7) private subroutine WriteArray_HDF5_real_r7_serial (fileId, arrayName, hfArray) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: arrayName type(hfReal_r7), intent(in) :: hfArray private subroutine WriteAttribute_HDF5_character (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName character, intent(in) :: attribute private subroutine WriteAttribute_HDF5_int32 (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName integer, intent(in) :: attribute private subroutine WriteAttribute_HDF5_real (fileId, attributeName, attribute) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fileId character, intent(in) :: attributeName real(kind=prec), intent(in) :: attribute","tags":"","loc":"module/self_hdf5.html"},{"title":"SELF_Geometry – SELF","text":"Uses SELF_Mesh SELF_Data SELF_Constants SELF_Lagrange SELF_SupportRoutines module~~self_geometry~~UsesGraph module~self_geometry SELF_Geometry module~self_lagrange SELF_Lagrange module~self_geometry->module~self_lagrange module~self_constants SELF_Constants module~self_geometry->module~self_constants module~self_data SELF_Data module~self_geometry->module~self_data module~self_mesh SELF_Mesh module~self_geometry->module~self_mesh module~self_supportroutines SELF_SupportRoutines module~self_geometry->module~self_supportroutines module~self_lagrange->module~self_constants module~self_lagrange->module~self_supportroutines module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort_check hipfort_check module~self_lagrange->hipfort_check hipfort hipfort module~self_lagrange->hipfort iso_c_binding iso_c_binding module~self_lagrange->iso_c_binding iso_fortran_env iso_fortran_env module~self_lagrange->iso_fortran_env module~self_constants->iso_c_binding module~self_constants->iso_fortran_env module~self_data->module~self_lagrange module~self_data->module~self_constants module~self_data->iso_c_binding module~self_mesh->module~self_lagrange module~self_mesh->module~self_constants module~self_mesh->module~self_data module~self_mesh->module~self_supportroutines module~self_hashtable SELF_HashTable module~self_mesh->module~self_hashtable module~self_mesh->iso_c_binding HDF5 HDF5 module~self_mesh->HDF5 module~self_mpi SELF_MPI module~self_mesh->module~self_mpi module~self_hdf5 SELF_HDF5 module~self_mesh->module~self_hdf5 module~self_supportroutines->module~self_constants module~self_supportroutines->iso_fortran_env module~self_memory->module~self_constants module~self_memory->hipfort_check module~self_memory->hipfort module~self_memory->iso_c_binding module~self_memory->iso_fortran_env module~self_quadrature->module~self_constants module~self_quadrature->iso_fortran_env module~self_hashtable->module~self_constants module~self_linkedlist SELF_LinkedList module~self_hashtable->module~self_linkedlist module~self_mpi->module~self_constants module~self_mpi->module~self_memory module~self_mpi->iso_c_binding module~self_hdf5->module~self_constants module~self_hdf5->module~self_memory module~self_hdf5->iso_fortran_env module~self_hdf5->HDF5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_geometry~~UsedByGraph module~self_geometry SELF_Geometry module~self_mappeddata SELF_MappedData module~self_mappeddata->module~self_geometry module~self_dg SELF_DG module~self_dg->module~self_mappeddata module~self_advection3d SELF_Advection3D module~self_advection3d->module~self_dg module~self_advection2d SELF_Advection2D module~self_advection2d->module~self_dg program~sadv2d sadv2d program~sadv2d->module~self_advection2d program~sadv3d sadv3d program~sadv3d->module~self_advection3d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper CalculateContravariantBasis_SEMHex_gpu_wrapper CalculateContravariantBasis_SEMQuad_gpu_wrapper Derived Types Geometry1D SEMHex SEMQuad Subroutines CalculateContravariantBasis_SEMHex CalculateContravariantBasis_SEMQuad CalculateMetricTerms_Geometry1D CalculateMetricTerms_SEMHex CalculateMetricTerms_SEMQuad Free_Geometry1D Free_SEMHex Free_SEMQuad GenerateFromMesh_Geometry1D GenerateFromMesh_SEMHex GenerateFromMesh_SEMQuad Init_Geometry1D Init_SEMHex Init_SEMQuad UpdateDevice_Geometry1D UpdateDevice_SEMHex UpdateDevice_SEMQuad UpdateHost_Geometry1D UpdateHost_SEMHex UpdateHost_SEMQuad Interfaces interface public subroutine AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper(dsdx, J, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dsdx type(c_ptr) :: J integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl interface public subroutine AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper(dsdx, J, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dsdx type(c_ptr) :: J integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl interface public subroutine CalculateContravariantBasis_SEMHex_gpu_wrapper(dxds, dsdx, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dxds type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl interface public subroutine CalculateContravariantBasis_SEMQuad_gpu_wrapper(dxds, dsdx, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dxds type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nEl Derived Types type, public :: Geometry1D Components Type Visibility Attributes Name Initial integer, public :: cqType type(Scalar1D), public :: dxds integer, public :: nElem integer, public :: tqType type(Scalar1D), public :: x Type-Bound Procedures procedure, public :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D procedure, public :: Free => Free_Geometry1D procedure, public :: GenerateFromMesh => GenerateFromMesh_Geometry1D procedure, public :: Init => Init_Geometry1D procedure, public :: UpdateDevice => UpdateDevice_Geometry1D procedure, public :: UpdateHost => UpdateHost_Geometry1D type, public :: SEMHex Components Type Visibility Attributes Name Initial type(Scalar3D), public :: J integer, public :: cqType type(Tensor3D), public :: dsdx type(Tensor3D), public :: dxds integer, public :: nElem type(Vector3D), public :: nHat type(Scalar3D), public :: nScale integer, public :: tqType type(Vector3D), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMHex procedure, public :: Free => Free_SEMHex procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMHex procedure, public :: Init => Init_SEMHex procedure, public :: UpdateDevice => UpdateDevice_SEMHex procedure, public :: UpdateHost => UpdateHost_SEMHex type, public :: SEMQuad Components Type Visibility Attributes Name Initial type(Scalar2D), public :: J integer, public :: cqType type(Tensor2D), public :: dsdx type(Tensor2D), public :: dxds integer, public :: nElem type(Vector2D), public :: nHat type(Scalar2D), public :: nScale integer, public :: tqType type(Vector2D), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad procedure, public :: Free => Free_SEMQuad procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMQuad procedure, public :: Init => Init_SEMQuad procedure, public :: UpdateDevice => UpdateDevice_SEMQuad procedure, public :: UpdateHost => UpdateHost_SEMQuad Subroutines public subroutine CalculateContravariantBasis_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine CalculateContravariantBasis_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine CalculateMetricTerms_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom public subroutine CalculateMetricTerms_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine CalculateMetricTerms_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine Free_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom public subroutine Free_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine Free_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine GenerateFromMesh_Geometry1D (myGeom, mesh, cqType, tqType, cqDegree, tqDegree, meshQuadrature) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom type(Mesh1D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in), optional :: meshQuadrature public subroutine GenerateFromMesh_SEMHex (myGeom, mesh, cqType, tqType, cqDegree, tqDegree, meshQuadrature) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom type(Mesh3D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in), optional :: meshQuadrature public subroutine GenerateFromMesh_SEMQuad (myGeom, mesh, cqType, tqType, cqDegree, tqDegree, meshQuadrature) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom type(Mesh2D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in), optional :: meshQuadrature public subroutine Init_Geometry1D (myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem public subroutine Init_SEMHex (myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem public subroutine Init_SEMQuad (myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem public subroutine UpdateDevice_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom public subroutine UpdateDevice_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine UpdateDevice_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine UpdateHost_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom public subroutine UpdateHost_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine UpdateHost_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom","tags":"","loc":"module/self_geometry.html"},{"title":"SELF_MappedData – SELF","text":"Uses SELF_Geometry iso_c_binding SELF_Mesh SELF_MPI SELF_Data SELF_Constants SELF_Lagrange module~~self_mappeddata~~UsesGraph module~self_mappeddata SELF_MappedData module~self_lagrange SELF_Lagrange module~self_mappeddata->module~self_lagrange module~self_constants SELF_Constants module~self_mappeddata->module~self_constants module~self_data SELF_Data module~self_mappeddata->module~self_data module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry iso_c_binding iso_c_binding module~self_mappeddata->iso_c_binding module~self_mesh SELF_Mesh module~self_mappeddata->module~self_mesh module~self_mpi SELF_MPI module~self_mappeddata->module~self_mpi module~self_lagrange->module~self_constants module~self_lagrange->iso_c_binding module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort_check hipfort_check module~self_lagrange->hipfort_check hipfort hipfort module~self_lagrange->hipfort iso_fortran_env iso_fortran_env module~self_lagrange->iso_fortran_env module~self_supportroutines SELF_SupportRoutines module~self_lagrange->module~self_supportroutines module~self_constants->iso_c_binding module~self_constants->iso_fortran_env module~self_data->module~self_lagrange module~self_data->module~self_constants module~self_data->iso_c_binding module~self_geometry->module~self_lagrange module~self_geometry->module~self_constants module~self_geometry->module~self_data module~self_geometry->module~self_mesh module~self_geometry->module~self_supportroutines module~self_mesh->module~self_lagrange module~self_mesh->module~self_constants module~self_mesh->module~self_data module~self_mesh->iso_c_binding module~self_mesh->module~self_mpi module~self_hashtable SELF_HashTable module~self_mesh->module~self_hashtable HDF5 HDF5 module~self_mesh->HDF5 module~self_mesh->module~self_supportroutines module~self_hdf5 SELF_HDF5 module~self_mesh->module~self_hdf5 module~self_mpi->module~self_constants module~self_mpi->iso_c_binding module~self_mpi->module~self_memory module~self_memory->module~self_constants module~self_memory->iso_c_binding module~self_memory->hipfort_check module~self_memory->hipfort module~self_memory->iso_fortran_env module~self_quadrature->module~self_constants module~self_quadrature->iso_fortran_env module~self_hashtable->module~self_constants module~self_linkedlist SELF_LinkedList module~self_hashtable->module~self_linkedlist module~self_supportroutines->module~self_constants module~self_supportroutines->iso_fortran_env module~self_hdf5->module~self_constants module~self_hdf5->module~self_memory module~self_hdf5->iso_fortran_env module~self_hdf5->HDF5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_mappeddata~~UsedByGraph module~self_mappeddata SELF_MappedData module~self_dg SELF_DG module~self_dg->module~self_mappeddata module~self_advection3d SELF_Advection3D module~self_advection3d->module~self_dg module~self_advection2d SELF_Advection2D module~self_advection2d->module~self_dg program~sadv2d sadv2d program~sadv2d->module~self_advection2d program~sadv3d sadv3d program~sadv3d->module~self_advection3d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces ApplyFlip_MappedScalar2D_gpu_wrapper ApplyFlip_MappedScalar3D_gpu_wrapper ApplyFlip_MappedTensor2D_gpu_wrapper ApplyFlip_MappedTensor3D_gpu_wrapper ApplyFlip_MappedVector2D_gpu_wrapper ApplyFlip_MappedVector3D_gpu_wrapper BassiRebaySides_MappedScalar2D_gpu_wrapper BassiRebaySides_MappedScalar3D_gpu_wrapper BassiRebaySides_MappedTensor2D_gpu_wrapper BassiRebaySides_MappedTensor3D_gpu_wrapper BassiRebaySides_MappedVector2D_gpu_wrapper BassiRebaySides_MappedVector3D_gpu_wrapper ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper ContravariantProjection_MappedVector2D_gpu_wrapper ContravariantProjection_MappedVector3D_gpu_wrapper ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper ContravariantWeight_MappedScalar2D_gpu_wrapper ContravariantWeight_MappedScalar3D_gpu_wrapper JacobianWeight_MappedScalar1D_gpu_wrapper JacobianWeight_MappedScalar2D_gpu_wrapper JacobianWeight_MappedScalar3D_gpu_wrapper JacobianWeight_MappedTensor2D_gpu_wrapper JacobianWeight_MappedTensor3D_gpu_wrapper JacobianWeight_MappedVector2D_gpu_wrapper JacobianWeight_MappedVector3D_gpu_wrapper MapToScalarBoundary_MappedVector2D_gpu_wrapper MapToScalarBoundary_MappedVector3D_gpu_wrapper MapToScalar_MappedVector2D_gpu_wrapper MapToScalar_MappedVector3D_gpu_wrapper MapToTensorBoundary_MappedVector2D_gpu_wrapper MapToTensorBoundary_MappedVector3D_gpu_wrapper MapToTensor_MappedVector2D_gpu_wrapper MapToTensor_MappedVector3D_gpu_wrapper SideExchange_MappedScalar2D_gpu_wrapper SideExchange_MappedScalar3D_gpu_wrapper SideExchange_MappedTensor2D_gpu_wrapper SideExchange_MappedTensor3D_gpu_wrapper SideExchange_MappedVector2D_gpu_wrapper SideExchange_MappedVector3D_gpu_wrapper Derived Types MappedScalar1D MappedScalar2D MappedScalar3D MappedTensor2D MappedTensor3D MappedVector2D MappedVector3D Subroutines ApplyFlip_MappedScalar2D ApplyFlip_MappedScalar3D ApplyFlip_MappedTensor2D ApplyFlip_MappedTensor3D ApplyFlip_MappedVector2D ApplyFlip_MappedVector3D BassiRebaySides_MappedScalar2D BassiRebaySides_MappedScalar3D BassiRebaySides_MappedTensor2D BassiRebaySides_MappedTensor3D BassiRebaySides_MappedVector2D BassiRebaySides_MappedVector3D ContravariantProjection_MappedVector2D ContravariantProjection_MappedVector3D ContravariantWeight_MappedScalar2D ContravariantWeight_MappedScalar3D Derivative_MappedScalar1D Divergence_MappedVector2D Divergence_MappedVector3D Gradient_MappedScalar2D Gradient_MappedScalar3D Gradient_MappedVector2D Gradient_MappedVector3D JacobianWeight_MappedScalar1D JacobianWeight_MappedScalar2D JacobianWeight_MappedScalar3D JacobianWeight_MappedTensor2D JacobianWeight_MappedTensor3D JacobianWeight_MappedVector2D JacobianWeight_MappedVector3D MPIExchangeAsync_MappedScalar2D MPIExchangeAsync_MappedScalar3D MPIExchangeAsync_MappedTensor2D MPIExchangeAsync_MappedTensor3D MPIExchangeAsync_MappedVector2D MPIExchangeAsync_MappedVector3D MapToScalar_MappedVector2D MapToScalar_MappedVector3D MapToTensor_MappedVector2D MapToTensor_MappedVector3D SideExchange_MappedScalar2D SideExchange_MappedScalar3D SideExchange_MappedTensor2D SideExchange_MappedTensor3D SideExchange_MappedVector2D SideExchange_MappedVector3D Interfaces interface public subroutine ApplyFlip_MappedScalar2D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ApplyFlip_MappedScalar3D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ApplyFlip_MappedTensor2D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ApplyFlip_MappedTensor3D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ApplyFlip_MappedVector2D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ApplyFlip_MappedVector3D_gpu_wrapper(extBoundary, selfSideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: selfSideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine BassiRebaySides_MappedScalar2D_gpu_wrapper(avgBoundary, boundary, extBoundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: avgBoundary type(c_ptr) :: boundary type(c_ptr) :: extBoundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine BassiRebaySides_MappedScalar3D_gpu_wrapper(avgBoundary, boundary, extBoundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: avgBoundary type(c_ptr) :: boundary type(c_ptr) :: extBoundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine BassiRebaySides_MappedTensor2D_gpu_wrapper(extBoundary, boundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine BassiRebaySides_MappedTensor3D_gpu_wrapper(extBoundary, boundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine BassiRebaySides_MappedVector2D_gpu_wrapper(extBoundary, boundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine BassiRebaySides_MappedVector3D_gpu_wrapper(extBoundary, boundary, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ContravariantProjection_MappedVector2D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ContravariantProjection_MappedVector3D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ContravariantWeight_MappedScalar2D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ContravariantWeight_MappedScalar3D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine JacobianWeight_MappedScalar1D_gpu_wrapper(scalar, dxds, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: dxds integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine JacobianWeight_MappedScalar2D_gpu_wrapper(scalar, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine JacobianWeight_MappedScalar3D_gpu_wrapper(scalar, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine JacobianWeight_MappedTensor2D_gpu_wrapper(tensor, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine JacobianWeight_MappedTensor3D_gpu_wrapper(tensor, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine JacobianWeight_MappedVector2D_gpu_wrapper(vector, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine JacobianWeight_MappedVector3D_gpu_wrapper(vector, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: jacobian integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine MapToScalarBoundary_MappedVector2D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine MapToScalarBoundary_MappedVector3D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine MapToScalar_MappedVector2D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine MapToScalar_MappedVector3D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine MapToTensorBoundary_MappedVector2D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine MapToTensorBoundary_MappedVector3D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine MapToTensor_MappedVector2D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine MapToTensor_MappedVector3D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine SideExchange_MappedScalar2D_gpu_wrapper(extBoundary, boundary, self_sideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: self_sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine SideExchange_MappedScalar3D_gpu_wrapper(extBoundary, boundary, self_sideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: self_sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine SideExchange_MappedTensor2D_gpu_wrapper(extBoundary, boundary, self_sideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: self_sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine SideExchange_MappedTensor3D_gpu_wrapper(extBoundary, boundary, self_sideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: self_sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine SideExchange_MappedVector2D_gpu_wrapper(extBoundary, boundary, self_sideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: self_sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine SideExchange_MappedVector3D_gpu_wrapper(extBoundary, boundary, self_sideInfo, elemToRank, rankId, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: extBoundary type(c_ptr) :: boundary type(c_ptr) :: self_sideInfo type(c_ptr) :: elemToRank integer(kind=C_INT), VALUE :: rankId integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl Derived Types type, public, extends(Scalar1D) :: MappedScalar1D Type-Bound Procedures generic, public :: Derivative => Derivative_MappedScalar1D procedure, private :: Derivative_MappedScalar1D procedure, public :: JacobianWeight => JacobianWeight_MappedScalar1D type, public, extends(Scalar2D) :: MappedScalar2D Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedScalar2D procedure, public :: BassiRebaySides => BassiRebaySides_MappedScalar2D procedure, private :: ContravariantWeight => ContravariantWeight_MappedScalar2D generic, public :: Gradient => Gradient_MappedScalar2D procedure, private :: Gradient_MappedScalar2D procedure, public :: JacobianWeight => JacobianWeight_MappedScalar2D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar2D procedure, public :: SideExchange => SideExchange_MappedScalar2D type, public, extends(Scalar3D) :: MappedScalar3D Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedScalar3D procedure, public :: BassiRebaySides => BassiRebaySides_MappedScalar3D procedure, private :: ContravariantWeight => ContravariantWeight_MappedScalar3D generic, public :: Gradient => Gradient_MappedScalar3D procedure, private :: Gradient_MappedScalar3D procedure, public :: JacobianWeight => JacobianWeight_MappedScalar3D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedScalar3D procedure, public :: SideExchange => SideExchange_MappedScalar3D type, public, extends(Tensor2D) :: MappedTensor2D Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedTensor2D procedure, public :: BassiRebaySides => BassiRebaySides_MappedTensor2D procedure, public :: JacobianWeight => JacobianWeight_MappedTensor2D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedTensor2D procedure, public :: SideExchange => SideExchange_MappedTensor2D type, public, extends(Tensor3D) :: MappedTensor3D Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedTensor3D procedure, public :: BassiRebaySides => BassiRebaySides_MappedTensor3D procedure, public :: JacobianWeight => JacobianWeight_MappedTensor3D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedTensor3D procedure, public :: SideExchange => SideExchange_MappedTensor3D type, public, extends(Vector2D) :: MappedVector2D Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedVector2D procedure, public :: BassiRebaySides => BassiRebaySides_MappedVector2D procedure, private :: ContravariantProjection => ContravariantProjection_MappedVector2D generic, public :: Divergence => Divergence_MappedVector2D procedure, private :: Divergence_MappedVector2D generic, public :: Gradient => Gradient_MappedVector2D procedure, private :: Gradient_MappedVector2D procedure, public :: JacobianWeight => JacobianWeight_MappedVector2D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector2D procedure, private :: MapToScalar => MapToScalar_MappedVector2D procedure, private :: MapToTensor => MapToTensor_MappedVector2D procedure, public :: SideExchange => SideExchange_MappedVector2D type, public, extends(Vector3D) :: MappedVector3D Type-Bound Procedures procedure, private :: ApplyFlip => ApplyFlip_MappedVector3D procedure, public :: BassiRebaySides => BassiRebaySides_MappedVector3D procedure, private :: ContravariantProjection => ContravariantProjection_MappedVector3D generic, public :: Divergence => Divergence_MappedVector3D procedure, private :: Divergence_MappedVector3D generic, public :: Gradient => Gradient_MappedVector3D procedure, private :: Gradient_MappedVector3D procedure, public :: JacobianWeight => JacobianWeight_MappedVector3D procedure, private :: MPIExchangeAsync => MPIExchangeAsync_MappedVector3D procedure, private :: MapToScalar => MapToScalar_MappedVector3D procedure, private :: MapToTensor => MapToTensor_MappedVector3D procedure, public :: SideExchange => SideExchange_MappedVector3D Subroutines public subroutine ApplyFlip_MappedScalar2D (scalar, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: gpuAccel public subroutine ApplyFlip_MappedScalar3D (scalar, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: gpuAccel public subroutine ApplyFlip_MappedTensor2D (tensor, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: gpuAccel public subroutine ApplyFlip_MappedTensor3D (tensor, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: gpuAccel public subroutine ApplyFlip_MappedVector2D (vector, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: gpuAccel public subroutine ApplyFlip_MappedVector3D (vector, mpiHandler, mesh, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: gpuAccel public subroutine BassiRebaySides_MappedScalar2D (scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel public subroutine BassiRebaySides_MappedScalar3D (scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel public subroutine BassiRebaySides_MappedTensor2D (tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel public subroutine BassiRebaySides_MappedTensor3D (tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel public subroutine BassiRebaySides_MappedVector2D (vector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector logical, intent(in) :: gpuAccel public subroutine BassiRebaySides_MappedVector3D (vector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector logical, intent(in) :: gpuAccel public subroutine ContravariantProjection_MappedVector2D (physVector, geometry, compVector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: physVector type(SEMQuad), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: compVector logical, intent(in) :: gpuAccel public subroutine ContravariantProjection_MappedVector3D (physVector, geometry, compVector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: physVector type(SEMHex), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: compVector logical, intent(in) :: gpuAccel public subroutine ContravariantWeight_MappedScalar2D (scalar, geometry, workTensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type(SEMQuad), intent(in) :: geometry type( MappedTensor2D ), intent(inout) :: workTensor logical, intent(in) :: gpuAccel public subroutine ContravariantWeight_MappedScalar3D (scalar, geometry, workTensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type(SEMHex), intent(in) :: geometry type( MappedTensor3D ), intent(inout) :: workTensor logical, intent(in) :: gpuAccel public subroutine Derivative_MappedScalar1D (scalar, geometry, dF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: scalar type(Geometry1D), intent(in) :: geometry type( MappedScalar1D ), intent(inout) :: dF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Divergence_MappedVector2D (compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: compVector type(SEMQuad), intent(in) :: geometry type( MappedScalar2D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Divergence_MappedVector3D (compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: compVector type(SEMHex), intent(in) :: geometry type( MappedScalar3D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Gradient_MappedScalar2D (scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Gradient_MappedScalar3D (scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Gradient_MappedVector2D (vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedScalar2D ), intent(inout) :: workScalar type( MappedVector2D ), intent(inout) :: workVector type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedTensor2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Gradient_MappedVector3D (vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedScalar3D ), intent(inout) :: workScalar type( MappedVector3D ), intent(inout) :: workVector type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedTensor3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedScalar1D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar type(Geometry1D), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedScalar2D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedScalar3D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedTensor2D (tensor, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedTensor3D (tensor, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedVector2D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedVector3D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine MPIExchangeAsync_MappedScalar2D (scalar, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: resetCount public subroutine MPIExchangeAsync_MappedScalar3D (scalar, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: resetCount public subroutine MPIExchangeAsync_MappedTensor2D (tensor, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: resetCount public subroutine MPIExchangeAsync_MappedTensor3D (tensor, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: resetCount public subroutine MPIExchangeAsync_MappedVector2D (vector, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type(MPILayer), intent(inout) :: mpiHandler type(Mesh2D), intent(in) :: mesh logical, intent(in) :: resetCount public subroutine MPIExchangeAsync_MappedVector3D (vector, mpiHandler, mesh, resetCount) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type(MPILayer), intent(inout) :: mpiHandler type(Mesh3D), intent(in) :: mesh logical, intent(in) :: resetCount public subroutine MapToScalar_MappedVector2D (vector, scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedScalar2D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel public subroutine MapToScalar_MappedVector3D (vector, scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedScalar3D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel public subroutine MapToTensor_MappedVector2D (vector, tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedTensor2D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel public subroutine MapToTensor_MappedVector3D (vector, tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedTensor3D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel public subroutine SideExchange_MappedScalar2D (scalar, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type(Mesh2D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel public subroutine SideExchange_MappedScalar3D (scalar, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type(Mesh3D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel public subroutine SideExchange_MappedTensor2D (tensor, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor type(Mesh2D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel public subroutine SideExchange_MappedTensor3D (tensor, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor type(Mesh3D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel public subroutine SideExchange_MappedVector2D (vector, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type(Mesh2D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel public subroutine SideExchange_MappedVector3D (vector, mesh, decomp, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type(Mesh3D), intent(in) :: mesh type(MPILayer), intent(inout) :: decomp logical, intent(in) :: gpuAccel","tags":"","loc":"module/self_mappeddata.html"},{"title":"SELF_Advection2D – SELF","text":"Uses SELF_DG iso_c_binding SELF_Mesh FEQParse FLAP SELF_Constants SELF_SupportRoutines module~~self_advection2d~~UsesGraph module~self_advection2d SELF_Advection2D module~self_constants SELF_Constants module~self_advection2d->module~self_constants module~self_dg SELF_DG module~self_advection2d->module~self_dg FEQParse FEQParse module~self_advection2d->FEQParse FLAP FLAP module~self_advection2d->FLAP iso_c_binding iso_c_binding module~self_advection2d->iso_c_binding module~self_mesh SELF_Mesh module~self_advection2d->module~self_mesh module~self_supportroutines SELF_SupportRoutines module~self_advection2d->module~self_supportroutines module~self_constants->iso_c_binding iso_fortran_env iso_fortran_env module~self_constants->iso_fortran_env module~self_dg->module~self_mesh module~self_mappeddata SELF_MappedData module~self_dg->module~self_mappeddata module~self_metadata SELF_Metadata module~self_dg->module~self_metadata HDF5 HDF5 module~self_dg->HDF5 module~self_mpi SELF_MPI module~self_dg->module~self_mpi module~self_hdf5 SELF_HDF5 module~self_dg->module~self_hdf5 module~self_mesh->module~self_constants module~self_mesh->iso_c_binding module~self_mesh->module~self_supportroutines module~self_lagrange SELF_Lagrange module~self_mesh->module~self_lagrange module~self_data SELF_Data module~self_mesh->module~self_data module~self_hashtable SELF_HashTable module~self_mesh->module~self_hashtable module~self_mesh->HDF5 module~self_mesh->module~self_mpi module~self_mesh->module~self_hdf5 module~self_supportroutines->module~self_constants module~self_supportroutines->iso_fortran_env module~self_lagrange->module~self_constants module~self_lagrange->iso_c_binding module~self_lagrange->module~self_supportroutines module~self_lagrange->iso_fortran_env module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort_check hipfort_check module~self_lagrange->hipfort_check hipfort hipfort module~self_lagrange->hipfort module~self_mappeddata->module~self_constants module~self_mappeddata->iso_c_binding module~self_mappeddata->module~self_mesh module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_data module~self_mappeddata->module~self_mpi module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry module~self_data->module~self_constants module~self_data->iso_c_binding module~self_data->module~self_lagrange module~self_metadata->module~self_hdf5 module~self_hashtable->module~self_constants module~self_linkedlist SELF_LinkedList module~self_hashtable->module~self_linkedlist module~self_mpi->module~self_constants module~self_mpi->iso_c_binding module~self_mpi->module~self_memory module~self_hdf5->module~self_constants module~self_hdf5->iso_fortran_env module~self_hdf5->HDF5 module~self_hdf5->module~self_memory module~self_memory->module~self_constants module~self_memory->iso_c_binding module~self_memory->iso_fortran_env module~self_memory->hipfort_check module~self_memory->hipfort module~self_quadrature->module~self_constants module~self_quadrature->iso_fortran_env module~self_geometry->module~self_constants module~self_geometry->module~self_mesh module~self_geometry->module~self_supportroutines module~self_geometry->module~self_lagrange module~self_geometry->module~self_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_advection2d~~UsedByGraph module~self_advection2d SELF_Advection2D program~sadv2d sadv2d program~sadv2d->module~self_advection2d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces InternalDiffusiveFlux_Advection2D_gpu_wrapper InternalFlux_Advection2D_gpu_wrapper SideDiffusiveFlux_Advection2D_gpu_wrapper SideFlux_Advection2D_gpu_wrapper UpdateGRK3_Advection2D_gpu_wrapper Derived Types Advection2D Subroutines ForwardStep_Advection2D Free_Advection2D GetCLIParameters InitFromCLI_Advection2D Init_Advection2D InternalFlux_Advection2D SetBoundaryConditionFromEquation_Advection2D SetSolutionFromEquation_Advection2D SetSourceFromEquation_Advection2D SetVelocityFromEquation_Advection2D SideFlux_Advection2D Tendency_Advection2D TimeStepRK3_Advection2D WriteTecplot_Advection2D Interfaces interface public subroutine InternalDiffusiveFlux_Advection2D_gpu_wrapper(flux, solutionGradient, dsdx, diffusivity, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: solutionGradient type(c_ptr) :: dsdx real(kind=c_prec), VALUE :: diffusivity integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine InternalFlux_Advection2D_gpu_wrapper(flux, solution, velocity, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: solution type(c_ptr) :: velocity type(c_ptr) :: dsdx integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine SideDiffusiveFlux_Advection2D_gpu_wrapper(flux, boundarySolGradient, extSolGradient, nHat, nScale, diffusivity, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: boundarySolGradient type(c_ptr) :: extSolGradient type(c_ptr) :: nHat type(c_ptr) :: nScale real(kind=c_prec), VALUE :: diffusivity integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine SideFlux_Advection2D_gpu_wrapper(flux, boundarySol, extSol, velocity, nHat, nScale, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: flux type(c_ptr) :: boundarySol type(c_ptr) :: extSol type(c_ptr) :: velocity type(c_ptr) :: nHat type(c_ptr) :: nScale integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine UpdateGRK3_Advection2D_gpu_wrapper(gRK3, solution, dSdt, rk3A, rk3G, dt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: gRK3 type(c_ptr) :: solution type(c_ptr) :: dSdt real(kind=c_prec), VALUE :: rk3A real(kind=c_prec), VALUE :: rk3G real(kind=c_prec), VALUE :: dt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl Derived Types type, public, extends(DG2D) :: Advection2D Components Type Visibility Attributes Name Initial real(kind=prec), public :: Lx real(kind=prec), public :: Ly character(len=self_EquationLength), public :: bcEqn type(EquationParser), public, ALLOCATABLE :: boundaryConditionEqn (:) integer, public :: controlDegree integer, public :: controlQuadrature logical, public :: diffusiveFlux real(kind=prec), public :: diffusivity real(kind=prec), public :: dt logical, public :: enableMPI real(kind=prec), public :: endTime logical, public :: gpuAccel character(len=self_EquationLength), public :: icEqn character(len=self_FileNameLength), public :: icFile real(kind=prec), public :: initialTime integer, public :: integrator character(len=self_FileNameLength), public :: meshFile integer, public :: nxElements integer, public :: nyElements real(kind=prec), public :: outputInterval type(Vector2D), public :: plotVelocity type(Vector2D), public :: plotX real(kind=prec), public :: simulationTime type(EquationParser), public, ALLOCATABLE :: solutionEqn (:) type(EquationParser), public, ALLOCATABLE :: sourceEqn (:) integer, public :: targetDegree integer, public :: targetQuadrature character(len=self_EquationLength), public :: velEqnX character(len=self_EquationLength), public :: velEqnY type(MappedVector2D), public :: velocity Type-Bound Procedures procedure, public :: ForwardStep => ForwardStep_Advection2D procedure, public :: Free => Free_Advection2D procedure, public :: Init => Init_Advection2D procedure, public :: InitFromCLI => InitFromCLI_Advection2D procedure, public :: InternalFlux => InternalFlux_Advection2D generic, public :: SetBoundaryCondition => SetBoundaryConditionFromEquation_Advection2D procedure, private :: SetBoundaryConditionFromEquation_Advection2D generic, public :: SetSolution => SetSolutionFromEquation_Advection2D procedure, private :: SetSolutionFromEquation_Advection2D generic, public :: SetSource => SetSourceFromEquation_Advection2D procedure, private :: SetSourceFromEquation_Advection2D generic, public :: SetVelocity => SetVelocityFromEquation_Advection2D procedure, private :: SetVelocityFromEquation_Advection2D procedure, public :: SideFlux => SideFlux_Advection2D procedure, public :: Tendency => Tendency_Advection2D procedure, public :: TimeStepRK3 => TimeStepRK3_Advection2D procedure, public :: WriteTecplot => WriteTecplot_Advection2D Subroutines public subroutine ForwardStep_Advection2D (this, endTime) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this real(kind=prec), intent(in) :: endTime public subroutine Free_Advection2D (this) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this private subroutine GetCLIParameters (cli) Arguments Type Intent Optional Attributes Name type(COMMAND_LINE_INTERFACE), intent(inout) :: cli public subroutine InitFromCLI_Advection2D (this) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this public subroutine Init_Advection2D (this, cqType, tqType, cqDegree, tqDegree, nvar, enableMPI, spec) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(out) :: this integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nvar logical, intent(in) :: enableMPI type(MeshSpec), intent(in) :: spec public subroutine InternalFlux_Advection2D (this) Calculates the advective flux using the provided velocity Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this public subroutine SetBoundaryConditionFromEquation_Advection2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) public subroutine SetSolutionFromEquation_Advection2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) public subroutine SetSourceFromEquation_Advection2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:this%solution%nVar) public subroutine SetVelocityFromEquation_Advection2D (this, eqn) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this type(EquationParser), intent(in) :: eqn (1:2) public subroutine SideFlux_Advection2D (this) Calculates the Advective Flux on element sides using a Lax-Friedrich's upwind Riemann Solver Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this public subroutine Tendency_Advection2D (this) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this public subroutine TimeStepRK3_Advection2D (this, nSteps) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: this integer, intent(in) :: nSteps public subroutine WriteTecplot_Advection2D (self, filename) Arguments Type Intent Optional Attributes Name class( Advection2D ), intent(inout) :: self character, intent(in), optional :: filename","tags":"","loc":"module/self_advection2d.html"},{"title":"SELF_LinkedList – SELF","text":"\\file SELF_LinkedList.f90\nContains the \\ref SELF_LinkedList module, and defines the \\ref Record and \\ref LinkedList data-structures.\n\\defgroup SELF_LinkedList SELF_LinkedList\nThis module defines the Record and \\ref LinkedList data-structure and associated routines. Used by module~~self_linkedlist~~UsedByGraph module~self_linkedlist SELF_LinkedList module~self_hashtable SELF_HashTable module~self_hashtable->module~self_linkedlist module~self_mesh SELF_Mesh module~self_mesh->module~self_hashtable module~self_mappeddata SELF_MappedData module~self_mappeddata->module~self_mesh module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry module~self_dg SELF_DG module~self_dg->module~self_mesh module~self_dg->module~self_mappeddata module~self_advection3d SELF_Advection3D module~self_advection3d->module~self_mesh module~self_advection3d->module~self_dg module~self_geometry->module~self_mesh program~sadv2d sadv2d program~sadv2d->module~self_mesh module~self_advection2d SELF_Advection2D program~sadv2d->module~self_advection2d program~sadv3d sadv3d program~sadv3d->module~self_mesh program~sadv3d->module~self_advection3d module~self_advection2d->module~self_mesh module~self_advection2d->module~self_dg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables keyInc keyStart Derived Types LinkedList Record Functions ListIsEmpty_LinkedList Subroutines AddToList_LinkedList Free_LinkedList GetCount_LinkedList GetCurrentData_LinkedList GetCurrentKey_LinkedList Init_LinkedList MoveToHead_LinkedList MoveToNext_LinkedList MoveToTail_LinkedList PrintToScreen_LinkedList RemoveCurrent_LinkedList SetCurrentData_LinkedList SetCurrentKey_LinkedList Variables Type Visibility Attributes Name Initial integer, private, parameter :: keyInc = 1 integer, private, parameter :: keyStart = 1 Derived Types type, public :: LinkedList \\addtogroup SELF_LinkedList\n@{\n\\struct LinkedList\nA LinkedList of Records Read more… Components Type Visibility Attributes Name Initial type( Record ), public, POINTER :: current type( Record ), public, POINTER :: head type( Record ), public, POINTER :: tail Type-Bound Procedures procedure, public :: AddToList => AddToList_LinkedList procedure, public :: Free => Free_LinkedList procedure, public :: GetData => GetCurrentData_LinkedList procedure, public :: GetKey => GetCurrentKey_LinkedList procedure, public :: Init => Init_LinkedList procedure, public :: ListIsEmpty => ListIsEmpty_LinkedList procedure, public :: MoveToHead => MoveToHead_LinkedList procedure, public :: MoveToNext => MoveToNext_LinkedList procedure, public :: MoveToTail => MoveToTail_LinkedList procedure, public :: PrintToScreen => PrintToScreen_LinkedList procedure, public :: RemoveCurrent => RemoveCurrent_LinkedList procedure, public :: SetData => SetCurrentData_LinkedList procedure, public :: SetKey => SetCurrentKey_LinkedList type, public :: Record \\addtogroup SELF_LinkedList\n@{\n\\struct Record\nA template record entry for a Linked-List that consists of data, a key, and a pointer to the next\nrecord Read more… Components Type Visibility Attributes Name Initial integer, public :: key integer, public :: listData type( Record ), public, POINTER :: next Functions public function ListIsEmpty_LinkedList (myList) result(isempty) \\addtogroup SELF_LinkedList\n @{\n \\fn ListIsEmpty_LinkedList\n Checks if the LinkedList is empty and returns a logical indicating the status of the list. Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList Return Value logical Subroutines public subroutine AddToList_LinkedList (myList, inData, inKey) \\addtogroup SELF_LinkedList\n @{\n \\fn AddToList_LinkedList\n Adds a new entry to the LinkedList with the provided data and key Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer :: inData integer, optional :: inKey public subroutine Free_LinkedList (myList) \\addtogroup SELF_LinkedList\n @{\n \\fn Free_LinkedList\n  Cycles through the Linked List, deallocates associated memory, and nullifies the LinkedList\n  pointers. Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList public subroutine GetCount_LinkedList (myList, numberOfListItems) \\addtogroup SELF_LinkedList\n @{\n \\fn GetCount_LinkedList\n Counts the number of associated entries in the list Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer, intent(out) :: numberOfListItems public subroutine GetCurrentData_LinkedList (myList, outData) \\addtogroup SELF_LinkedList\n @{\n \\fn GetCurrentData_LinkedList\n Gets the current list data and returns the integer value. Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer :: outData public subroutine GetCurrentKey_LinkedList (myList, outKey) \\addtogroup SELF_LinkedList\n @{\n \\fn GetCurrentKey_LinkedList\n Gets the current key and returns the integer value. Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer :: outKey public subroutine Init_LinkedList (myList) \\addtogroup SELF_LinkedList\n @{\n \\fn Init_LinkedList\n Initializes a LinkedList by nullifying the head, tail, and current pointers Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList public subroutine MoveToHead_LinkedList (myList) \\addtogroup SELF_LinkedList\n @{\n \\fn MoveToHead_LinkedList\n Advances the current pointer in the LinkedList to the start of the list  (list head) Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList public subroutine MoveToNext_LinkedList (myList) \\addtogroup SELF_LinkedList\n @{\n \\fn MoveToNext_LinkedList\n Advances the current pointer in the LinkedList to the next position Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList public subroutine MoveToTail_LinkedList (myList) \\addtogroup SELF_LinkedList\n @{\n \\fn MoveToTail_LinkedList\n Advances the current pointer in the LinkedList to the end of the list (list tail) Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList public subroutine PrintToScreen_LinkedList (myList) \\addtogroup SELF_LinkedList\n @{\n \\fn PrintToScreen_LinkedList\n Prints the list data and keys to the screen Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList public subroutine RemoveCurrent_LinkedList (myList) \\addtogroup SELF_LinkedList\n @{\n \\fn RemoveCurrent_LinkedList\n Removes the current entry from the list and patches the previous with the next. Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList public subroutine SetCurrentData_LinkedList (myList, inData) \\addtogroup SELF_LinkedList\n @{\n \\fn SetCurrentData_LinkedList\n Sets the current list data to the supplied integer value. Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer :: inData public subroutine SetCurrentKey_LinkedList (myList, inKey) \\addtogroup SELF_LinkedList\n @{\n \\fn SetCurrentKey_LinkedList\n Sets the current list key to the supplied integer value. Read more… Arguments Type Intent Optional Attributes Name class( LinkedList ) :: myList integer :: inKey","tags":"","loc":"module/self_linkedlist.html"},{"title":"SELF_HashTable – SELF","text":"\\file SELF_HashTable.f90\nContains the \\ref SELF_HashTable module, and defines the \\ref HashTable data-structures.\n\\defgroup SELF_HashTable SELF_HashTable\nThis module defines the \\ref HashTable data-structure and associated routines. Uses SELF_Constants SELF_LinkedList module~~self_hashtable~~UsesGraph module~self_hashtable SELF_HashTable module~self_linkedlist SELF_LinkedList module~self_hashtable->module~self_linkedlist module~self_constants SELF_Constants module~self_hashtable->module~self_constants iso_c_binding iso_c_binding module~self_constants->iso_c_binding iso_fortran_env iso_fortran_env module~self_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_hashtable~~UsedByGraph module~self_hashtable SELF_HashTable module~self_mesh SELF_Mesh module~self_mesh->module~self_hashtable module~self_mappeddata SELF_MappedData module~self_mappeddata->module~self_mesh module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry module~self_dg SELF_DG module~self_dg->module~self_mesh module~self_dg->module~self_mappeddata module~self_advection3d SELF_Advection3D module~self_advection3d->module~self_mesh module~self_advection3d->module~self_dg module~self_geometry->module~self_mesh program~sadv2d sadv2d program~sadv2d->module~self_mesh module~self_advection2d SELF_Advection2D program~sadv2d->module~self_advection2d program~sadv3d sadv3d program~sadv3d->module~self_mesh program~sadv3d->module~self_advection3d module~self_advection2d->module~self_mesh module~self_advection2d->module~self_dg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Derived Types HashTable Functions ContainsKeys_HashTable Subroutines AddDataForKeys_HashTable Free_HashTable GetDataForKeys_HashTable Init_HashTable Derived Types type, public :: HashTable \\addtogroup SELF_HashTable\n@{\n\\struct HashTable\nA template hash-table data structure that is comprised of an array of linked lists ( see\nSELF_LinkedList ). Read more… Components Type Visibility Attributes Name Initial type(LinkedList), public, ALLOCATABLE :: list (:) Type-Bound Procedures procedure, public :: AddDataForKeys => AddDataForKeys_HashTable procedure, public :: ContainsKeys => ContainsKeys_HashTable procedure, public :: Free => Free_HashTable procedure, public :: GetDataForKeys => GetDataForKeys_HashTable procedure, public :: Init => Init_HashTable Functions public function ContainsKeys_HashTable (myTable, i, j) result(doesContain) \\addtogroup SELF_HashTable\n @{\n \\fn ContainsKeys_HashTable\n Checks to see if an entry in the hash-table exists for the keys \"i\" and \"j\". Read more… Arguments Type Intent Optional Attributes Name class( HashTable ) :: myTable integer :: i integer :: j Return Value logical Subroutines public subroutine AddDataForKeys_HashTable (myTable, inData, i, j) \\addtogroup SELF_HashTable\n @{\n \\fn AddDataForKeys_HashTable\n Adds data to the i-th linked list with a key set to \"j\" Read more… Arguments Type Intent Optional Attributes Name class( HashTable ) :: myTable integer :: inData integer :: i integer :: j public subroutine Free_HashTable (myTable) \\addtogroup SELF_HashTable\n @{\n \\fn Free_HashTable\n  Deallocates memory associated with the Hash-Table Read more… Arguments Type Intent Optional Attributes Name class( HashTable ) :: myTable public subroutine GetDataForKeys_HashTable (myTable, outData, i, j) \\addtogroup SELF_HashTable\n @{\n \\fn GetDataForKeys_HashTable\n Returns data from the hash table associated with the keys \"i\" and \"j\". Read more… Arguments Type Intent Optional Attributes Name class( HashTable ) :: myTable integer :: outData integer :: i integer :: j public subroutine Init_HashTable (myTable, N) \\addtogroup SELF_HashTable\n @{\n \\fn Init_HashTable\n Allocates space for the hash table and initializes each linked list within the hash-table Read more… Arguments Type Intent Optional Attributes Name class( HashTable ) :: myTable integer :: N","tags":"","loc":"module/self_hashtable.html"},{"title":"SELF_DG – SELF","text":"Uses SELF_Mesh SELF_MPI SELF_HDF5 SELF_Metadata SELF_MappedData HDF5 module~~self_dg~~UsesGraph module~self_dg SELF_DG module~self_mappeddata SELF_MappedData module~self_dg->module~self_mappeddata module~self_metadata SELF_Metadata module~self_dg->module~self_metadata module~self_mesh SELF_Mesh module~self_dg->module~self_mesh HDF5 HDF5 module~self_dg->HDF5 module~self_mpi SELF_MPI module~self_dg->module~self_mpi module~self_hdf5 SELF_HDF5 module~self_dg->module~self_hdf5 module~self_mappeddata->module~self_mesh module~self_mappeddata->module~self_mpi module~self_lagrange SELF_Lagrange module~self_mappeddata->module~self_lagrange module~self_constants SELF_Constants module~self_mappeddata->module~self_constants module~self_data SELF_Data module~self_mappeddata->module~self_data module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry iso_c_binding iso_c_binding module~self_mappeddata->iso_c_binding module~self_metadata->module~self_hdf5 module~self_mesh->HDF5 module~self_mesh->module~self_mpi module~self_mesh->module~self_hdf5 module~self_mesh->module~self_lagrange module~self_mesh->module~self_constants module~self_mesh->module~self_data module~self_hashtable SELF_HashTable module~self_mesh->module~self_hashtable module~self_mesh->iso_c_binding module~self_supportroutines SELF_SupportRoutines module~self_mesh->module~self_supportroutines module~self_mpi->module~self_constants module~self_memory SELF_Memory module~self_mpi->module~self_memory module~self_mpi->iso_c_binding module~self_hdf5->HDF5 module~self_hdf5->module~self_constants module~self_hdf5->module~self_memory iso_fortran_env iso_fortran_env module~self_hdf5->iso_fortran_env module~self_lagrange->module~self_constants module~self_lagrange->module~self_memory module~self_lagrange->iso_c_binding module~self_lagrange->iso_fortran_env module~self_lagrange->module~self_supportroutines module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort_check hipfort_check module~self_lagrange->hipfort_check hipfort hipfort module~self_lagrange->hipfort module~self_constants->iso_c_binding module~self_constants->iso_fortran_env module~self_data->module~self_lagrange module~self_data->module~self_constants module~self_data->iso_c_binding module~self_memory->module~self_constants module~self_memory->iso_c_binding module~self_memory->iso_fortran_env module~self_memory->hipfort_check module~self_memory->hipfort module~self_hashtable->module~self_constants module~self_linkedlist SELF_LinkedList module~self_hashtable->module~self_linkedlist module~self_geometry->module~self_mesh module~self_geometry->module~self_lagrange module~self_geometry->module~self_constants module~self_geometry->module~self_data module~self_geometry->module~self_supportroutines module~self_supportroutines->module~self_constants module~self_supportroutines->iso_fortran_env module~self_quadrature->module~self_constants module~self_quadrature->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_dg~~UsedByGraph module~self_dg SELF_DG module~self_advection3d SELF_Advection3D module~self_advection3d->module~self_dg module~self_advection2d SELF_Advection2D module~self_advection2d->module~self_dg program~sadv2d sadv2d program~sadv2d->module~self_advection2d program~sadv3d sadv3d program~sadv3d->module~self_advection3d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables SELF_DG_BASSIREBAY Interfaces CalculateDSDt_DG2D_gpu_wrapper CalculateDSDt_DG3D_gpu_wrapper Derived Types DG2D DG3D Subroutines CalculateDSDt_DG2D CalculateDSDt_DG3D CalculateFluxDivergence_DG2D CalculateFluxDivergence_DG3D CalculateSolutionGradient_DG2D CalculateSolutionGradient_DG3D Free_DG2D Free_DG3D Init_DG2D Init_DG3D Read_DG2D Read_DG3D UpdateDevice_DG2D UpdateDevice_DG3D UpdateHost_DG2D UpdateHost_DG3D Write_DG2D Write_DG3D Variables Type Visibility Attributes Name Initial integer, public, parameter :: SELF_DG_BASSIREBAY = 100 Interfaces interface public subroutine CalculateDSDt_DG2D_gpu_wrapper(fluxDivergence, source, dSdt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: fluxDivergence type(c_ptr) :: source type(c_ptr) :: dSdt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine CalculateDSDt_DG3D_gpu_wrapper(fluxDivergence, source, dSdt, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: fluxDivergence type(c_ptr) :: source type(c_ptr) :: dSdt integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl Derived Types type, public :: DG2D Components Type Visibility Attributes Name Initial type(MappedVector2D), public :: compFlux type(MappedScalar2D), public :: dSdt type(MPILayer), public :: decomp type(MappedVector2D), public :: flux type(MappedScalar2D), public :: fluxDivergence type(SEMQuad), public :: geometry type(Mesh2D), public :: mesh type(Scalar2D), public :: plotSolution type(MappedScalar2D), public :: solution type(MappedVector2D), public :: solutionGradient type(Metadata), public, ALLOCATABLE :: solutionMetaData (:) type(MappedScalar2D), public :: source type(MappedScalar2D), public :: workScalar type(MappedTensor2D), public :: workTensor type(MappedVector2D), public :: workVector Type-Bound Procedures procedure, public :: CalculateDSDt => CalculateDSDt_DG2D procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_DG2D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DG2D procedure, public :: Free => Free_DG2D procedure, public :: Init => Init_DG2D procedure, public :: Read => Read_DG2D procedure, public :: UpdateDevice => UpdateDevice_DG2D procedure, public :: UpdateHost => UpdateHost_DG2D procedure, public :: Write => Write_DG2D type, public :: DG3D Components Type Visibility Attributes Name Initial type(MappedVector3D), public :: compFlux type(MappedScalar3D), public :: dSdt type(MPILayer), public :: decomp type(MappedVector3D), public :: flux type(MappedScalar3D), public :: fluxDivergence type(SEMHex), public :: geometry type(Mesh3D), public :: mesh type(Scalar3D), public :: plotSolution type(MappedScalar3D), public :: solution type(MappedVector3D), public :: solutionGradient type(Metadata), public, ALLOCATABLE :: solutionMetaData (:) type(MappedScalar3D), public :: source type(MappedScalar3D), public :: workScalar type(MappedTensor3D), public :: workTensor type(MappedVector3D), public :: workVector Type-Bound Procedures procedure, public :: CalculateDSDt => CalculateDSDt_DG3D procedure, public :: CalculateFluxDivergence => CalculateFluxDivergence_DG3D procedure, public :: CalculateSolutionGradient => CalculateSolutionGradient_DG3D procedure, public :: Free => Free_DG3D procedure, public :: Init => Init_DG3D procedure, public :: Read => Read_DG3D procedure, public :: UpdateDevice => UpdateDevice_DG3D procedure, public :: UpdateHost => UpdateHost_DG3D procedure, public :: Write => Write_DG3D Subroutines public subroutine CalculateDSDt_DG2D (this, gpuAccel) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this logical, intent(in) :: gpuAccel public subroutine CalculateDSDt_DG3D (this, gpuAccel) Adds the flux convergence and source terms together and assigns to dSdt Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this logical, intent(in) :: gpuAccel public subroutine CalculateFluxDivergence_DG2D (this, gpuAccel) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this logical, intent(in) :: gpuAccel public subroutine CalculateFluxDivergence_DG3D (this, gpuAccel) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this logical, intent(in) :: gpuAccel public subroutine CalculateSolutionGradient_DG2D (this, gpuAccel) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this logical, intent(in) :: gpuAccel public subroutine CalculateSolutionGradient_DG3D (this, gpuAccel) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this logical, intent(in) :: gpuAccel public subroutine Free_DG2D (this) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this public subroutine Free_DG3D (this) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this public subroutine Init_DG2D (this, cqType, tqType, cqDegree, tqDegree, nvar, enableMPI, spec) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(out) :: this integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nvar logical, intent(in) :: enableMPI type(MeshSpec), intent(in) :: spec public subroutine Init_DG3D (this, cqType, tqType, cqDegree, tqDegree, nvar, enableMPI, spec) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(out) :: this integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nvar logical, intent(in) :: enableMPI type(MeshSpec), intent(in) :: spec public subroutine Read_DG2D (this, fileName) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this character, intent(in) :: fileName public subroutine Read_DG3D (this, fileName) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this character, intent(in) :: fileName public subroutine UpdateDevice_DG2D (this) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this public subroutine UpdateDevice_DG3D (this) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this public subroutine UpdateHost_DG2D (this) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(inout) :: this public subroutine UpdateHost_DG3D (this) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(inout) :: this public subroutine Write_DG2D (this, fileName) Arguments Type Intent Optional Attributes Name class( DG2D ), intent(in) :: this character, intent(in) :: fileName public subroutine Write_DG3D (this, fileName) Arguments Type Intent Optional Attributes Name class( DG3D ), intent(in) :: this character, intent(in) :: fileName","tags":"","loc":"module/self_dg.html"},{"title":"SELF_Quadrature – SELF","text":"Uses iso_fortran_env SELF_Constants module~~self_quadrature~~UsesGraph module~self_quadrature SELF_Quadrature module~self_constants SELF_Constants module~self_quadrature->module~self_constants iso_fortran_env iso_fortran_env module~self_quadrature->iso_fortran_env module~self_constants->iso_fortran_env iso_c_binding iso_c_binding module~self_constants->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_quadrature~~UsedByGraph module~self_quadrature SELF_Quadrature module~self_lagrange SELF_Lagrange module~self_lagrange->module~self_quadrature module~self_geometry SELF_Geometry module~self_geometry->module~self_lagrange module~self_mesh SELF_Mesh module~self_geometry->module~self_mesh module~self_data SELF_Data module~self_geometry->module~self_data module~self_mesh->module~self_lagrange module~self_mesh->module~self_data module~self_mappeddata SELF_MappedData module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_geometry module~self_mappeddata->module~self_mesh module~self_mappeddata->module~self_data module~self_data->module~self_lagrange module~self_dg SELF_DG module~self_dg->module~self_mesh module~self_dg->module~self_mappeddata program~sadv3d sadv3d program~sadv3d->module~self_mesh module~self_advection3d SELF_Advection3D program~sadv3d->module~self_advection3d program~sadv2d sadv2d program~sadv2d->module~self_mesh module~self_advection2d SELF_Advection2D program~sadv2d->module~self_advection2d module~self_advection3d->module~self_mesh module~self_advection3d->module~self_dg module~self_advection2d->module~self_mesh module~self_advection2d->module~self_dg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines ChebyshevGauss ChebyshevGaussLobatto ChebyshevQuadrature LegendreGauss LegendreGaussLobatto LegendrePolynomial LegendreQandL LegendreQuadrature Subroutines private subroutine ChebyshevGauss (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) private subroutine ChebyshevGaussLobatto (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) public subroutine ChebyshevQuadrature (N, nodes, weights, QuadType) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=real64), intent(out) :: nodes (0:N) real(kind=real64), intent(out) :: weights (0:N) integer, intent(in) :: QuadType private subroutine LegendreGauss (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) private subroutine LegendreGaussLobatto (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) public subroutine LegendrePolynomial (N, x, lAtX, dLdxAtX) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: lAtX real(kind=real64) :: dLdxAtX private subroutine LegendreQandL (N, x, q, qprime, lN) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: q real(kind=real64) :: qprime real(kind=real64) :: lN public subroutine LegendreQuadrature (N, nodes, weights, QuadType) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=prec), intent(out) :: nodes (0:N) real(kind=prec), intent(out) :: weights (0:N) integer, intent(in) :: QuadType","tags":"","loc":"module/self_quadrature.html"},{"title":"SELF_Lagrange – SELF","text":"Uses iso_c_binding SELF_Quadrature hipfort_check hipfort SELF_Constants SELF_Memory iso_fortran_env SELF_SupportRoutines module~~self_lagrange~~UsesGraph module~self_lagrange SELF_Lagrange module~self_constants SELF_Constants module~self_lagrange->module~self_constants module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort_check hipfort_check module~self_lagrange->hipfort_check hipfort hipfort module~self_lagrange->hipfort iso_c_binding iso_c_binding module~self_lagrange->iso_c_binding iso_fortran_env iso_fortran_env module~self_lagrange->iso_fortran_env module~self_supportroutines SELF_SupportRoutines module~self_lagrange->module~self_supportroutines module~self_constants->iso_c_binding module~self_constants->iso_fortran_env module~self_memory->module~self_constants module~self_memory->hipfort_check module~self_memory->hipfort module~self_memory->iso_c_binding module~self_memory->iso_fortran_env module~self_quadrature->module~self_constants module~self_quadrature->iso_fortran_env module~self_supportroutines->module~self_constants module~self_supportroutines->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_lagrange~~UsedByGraph module~self_lagrange SELF_Lagrange module~self_geometry SELF_Geometry module~self_geometry->module~self_lagrange module~self_mesh SELF_Mesh module~self_geometry->module~self_mesh module~self_data SELF_Data module~self_geometry->module~self_data module~self_mesh->module~self_lagrange module~self_mesh->module~self_data module~self_mappeddata SELF_MappedData module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_geometry module~self_mappeddata->module~self_mesh module~self_mappeddata->module~self_data module~self_data->module~self_lagrange module~self_dg SELF_DG module~self_dg->module~self_mesh module~self_dg->module~self_mappeddata program~sadv3d sadv3d program~sadv3d->module~self_mesh module~self_advection3d SELF_Advection3D program~sadv3d->module~self_advection3d program~sadv2d sadv2d program~sadv2d->module~self_mesh module~self_advection2d SELF_Advection2D program~sadv2d->module~self_advection2d module~self_advection3d->module~self_mesh module~self_advection3d->module~self_dg module~self_advection2d->module~self_mesh module~self_advection2d->module~self_dg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces DGDerivative_1D_gpu_wrapper Derivative_1D_gpu_wrapper ScalarBoundaryInterp_1D_gpu_wrapper ScalarBoundaryInterp_2D_gpu_wrapper ScalarBoundaryInterp_3D_gpu_wrapper ScalarDGGradient_2D_gpu_wrapper ScalarGradient_2D_gpu_wrapper ScalarGradient_3D_gpu_wrapper ScalarGridInterp_1D_gpu_wrapper ScalarGridInterp_2D_gpu_wrapper ScalarGridInterp_3D_gpu_wrapper TensorBoundaryInterp_2D_gpu_wrapper TensorBoundaryInterp_3D_gpu_wrapper TensorDGDivergence_2D_gpu_wrapper TensorDGDivergence_3D_gpu_wrapper TensorDivergence_2D_gpu_wrapper TensorDivergence_3D_gpu_wrapper TensorGridInterp_2D_gpu_wrapper TensorGridInterp_3D_gpu_wrapper VectorBoundaryInterp_2D_gpu_wrapper VectorBoundaryInterp_3D_gpu_wrapper VectorCurl_2D_gpu_wrapper VectorCurl_3D_gpu_wrapper VectorDGDivergence_2D_gpu_wrapper VectorDGDivergence_3D_gpu_wrapper VectorDGGradient_2D_gpu_wrapper VectorDivergence_2D_gpu_wrapper VectorDivergence_3D_gpu_wrapper VectorGradient_2D_gpu_wrapper VectorGradient_3D_gpu_wrapper VectorGridInterp_2D_gpu_wrapper VectorGridInterp_3D_gpu_wrapper Derived Types Lagrange Functions CalculateLagrangePolynomials Subroutines CalculateBarycentricWeights CalculateDerivativeMatrix CalculateInterpolationMatrix DGDerivative_1D_cpu DGDerivative_1D_gpu Derivative_1D_cpu Derivative_1D_gpu Free_Lagrange Init_Lagrange ScalarBoundaryInterp_1D_cpu ScalarBoundaryInterp_1D_gpu ScalarBoundaryInterp_2D_cpu ScalarBoundaryInterp_2D_gpu ScalarBoundaryInterp_3D_cpu ScalarBoundaryInterp_3D_gpu ScalarDGGradient_2D_cpu ScalarDGGradient_2D_gpu ScalarGradient_2D_cpu ScalarGradient_2D_gpu ScalarGradient_3D_cpu ScalarGradient_3D_gpu ScalarGridInterp_1D_cpu ScalarGridInterp_1D_gpu ScalarGridInterp_2D_cpu ScalarGridInterp_2D_gpu ScalarGridInterp_3D_cpu ScalarGridInterp_3D_gpu TensorBoundaryInterp_2D_cpu TensorBoundaryInterp_2D_gpu TensorBoundaryInterp_3D_cpu TensorBoundaryInterp_3D_gpu TensorDGDivergence_2D_cpu TensorDGDivergence_2D_gpu TensorDGDivergence_3D_cpu TensorDGDivergence_3D_gpu TensorDivergence_2D_cpu TensorDivergence_2D_gpu TensorDivergence_3D_cpu TensorDivergence_3D_gpu TensorGridInterp_2D_cpu TensorGridInterp_2D_gpu TensorGridInterp_3D_cpu TensorGridInterp_3D_gpu UpdateDevice_Lagrange UpdateHost_Lagrange VectorBoundaryInterp_2D_cpu VectorBoundaryInterp_2D_gpu VectorBoundaryInterp_3D_cpu VectorBoundaryInterp_3D_gpu VectorCurl_2D_cpu VectorCurl_2D_gpu VectorCurl_3D_cpu VectorCurl_3D_gpu VectorDGDivergence_2D_cpu VectorDGDivergence_2D_gpu VectorDGDivergence_3D_cpu VectorDGDivergence_3D_gpu VectorDGGradient_2D_cpu VectorDGGradient_2D_gpu VectorDivergence_2D_cpu VectorDivergence_2D_gpu VectorDivergence_3D_cpu VectorDivergence_3D_gpu VectorGradient_2D_cpu VectorGradient_2D_gpu VectorGradient_3D_cpu VectorGradient_3D_gpu VectorGridInterp_2D_cpu VectorGridInterp_2D_gpu VectorGridInterp_3D_cpu VectorGridInterp_3D_gpu Interfaces interface public subroutine DGDerivative_1D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine Derivative_1D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarBoundaryInterp_1D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarDGGradient_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarGradient_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarGradient_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarGridInterp_1D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine ScalarGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine TensorBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine TensorBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine TensorDGDivergence_2D_gpu_wrapper(dMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine TensorDGDivergence_3D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine TensorDivergence_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine TensorDivergence_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine TensorGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine TensorGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorCurl_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorCurl_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorDGDivergence_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorDGDivergence_3D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorDGGradient_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorDivergence_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorDivergence_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorGradient_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorGradient_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl interface public subroutine VectorGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer(kind=C_INT), VALUE :: N integer(kind=C_INT), VALUE :: M integer(kind=C_INT), VALUE :: nVar integer(kind=C_INT), VALUE :: nEl Derived Types type, public :: Lagrange A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions.\nThe Lagrange data-structure stores the information necessary to interpolate between two\nsets of grid-points and to estimate the derivative of data at native grid points. Routines for\nmultidimensional interpolation are based on the tensor product of 1-D interpolants. It is\nassumed that the polynomial degree (and the interpolation nodes) are the same in each direction.\nThis assumption permits the storage of only one array of interpolation nodes and barycentric\nweights and is what allows this data structure to be flexible. Components Type Visibility Attributes Name Initial integer, public :: M The number of target points. integer, public :: N The number of control points. type(hfReal_r2), public :: bMatrix The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. type(hfReal_r1), public :: bWeights The barycentric weights that are calculated from the controlPoints and used for interpolation. type(hfReal_r1), public :: controlPoints The set of nodes in one dimension where data is known.\nTo create higher dimension interpolation and differentiation operators, structured grids in two and three\ndimensions are created by tensor products of the controlPoints. This design decision implies that all\nspectral element methods supported by the Lagrange class have the same polynomial degree in each\ncomputational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto,\nLegendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over\nthe domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of\nthese quadrature types or uniform points on [-1,1]. type(hfReal_r2), public :: dMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The\ndMatrix is based on a strong form of the derivative. type(hfReal_r2), public :: dgMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based\non a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. type(hfReal_r2), public :: iMatrix The interpolation matrix (transpose) for mapping data from the control grid to the target grid. type(hfReal_r1), public :: qWeights The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints\nprovided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss,\nChebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant . type(hfReal_r1), public :: targetPoints The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation\nand differentiation operators, structured grids in two and three dimensions are created by tensor products of\nthe targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1]\n(computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. Type-Bound Procedures procedure, private :: CalculateBarycentricWeights procedure, private :: CalculateDerivativeMatrix procedure, private :: CalculateInterpolationMatrix procedure, private :: CalculateLagrangePolynomials generic, public :: DGDerivative_1D => DGDerivative_1D_cpu, DGDerivative_1D_gpu procedure, private :: DGDerivative_1D_cpu procedure, private :: DGDerivative_1D_gpu generic, public :: Derivative_1D => Derivative_1D_cpu, Derivative_1D_gpu procedure, private :: Derivative_1D_cpu procedure, private :: Derivative_1D_gpu procedure, public :: Free => Free_Lagrange procedure, public :: Init => Init_Lagrange generic, public :: ScalarBoundaryInterp_1D => ScalarBoundaryInterp_1D_cpu, ScalarBoundaryInterp_1D_gpu procedure, private :: ScalarBoundaryInterp_1D_cpu procedure, private :: ScalarBoundaryInterp_1D_gpu generic, public :: ScalarBoundaryInterp_2D => ScalarBoundaryInterp_2D_cpu, ScalarBoundaryInterp_2D_gpu procedure, private :: ScalarBoundaryInterp_2D_cpu procedure, private :: ScalarBoundaryInterp_2D_gpu generic, public :: ScalarBoundaryInterp_3D => ScalarBoundaryInterp_3D_cpu, ScalarBoundaryInterp_3D_gpu procedure, private :: ScalarBoundaryInterp_3D_cpu procedure, private :: ScalarBoundaryInterp_3D_gpu generic, public :: ScalarDGGradient_2D => ScalarDGGradient_2D_cpu, ScalarDGGradient_2D_gpu procedure, private :: ScalarDGGradient_2D_cpu procedure, private :: ScalarDGGradient_2D_gpu generic, public :: ScalarGradient_2D => ScalarGradient_2D_cpu, ScalarGradient_2D_gpu procedure, private :: ScalarGradient_2D_cpu procedure, private :: ScalarGradient_2D_gpu generic, public :: ScalarGradient_3D => ScalarGradient_3D_cpu, ScalarGradient_3D_gpu procedure, private :: ScalarGradient_3D_cpu procedure, private :: ScalarGradient_3D_gpu generic, public :: ScalarGridInterp_1D => ScalarGridInterp_1D_cpu, ScalarGridInterp_1D_gpu procedure, private :: ScalarGridInterp_1D_cpu procedure, private :: ScalarGridInterp_1D_gpu generic, public :: ScalarGridInterp_2D => ScalarGridInterp_2D_cpu, ScalarGridInterp_2D_gpu procedure, private :: ScalarGridInterp_2D_cpu procedure, private :: ScalarGridInterp_2D_gpu generic, public :: ScalarGridInterp_3D => ScalarGridInterp_3D_cpu, ScalarGridInterp_3D_gpu procedure, private :: ScalarGridInterp_3D_cpu procedure, private :: ScalarGridInterp_3D_gpu generic, public :: TensorBoundaryInterp_2D => TensorBoundaryInterp_2D_cpu, TensorBoundaryInterp_2D_gpu procedure, private :: TensorBoundaryInterp_2D_cpu procedure, private :: TensorBoundaryInterp_2D_gpu generic, public :: TensorBoundaryInterp_3D => TensorBoundaryInterp_3D_cpu, TensorBoundaryInterp_3D_gpu procedure, private :: TensorBoundaryInterp_3D_cpu procedure, private :: TensorBoundaryInterp_3D_gpu generic, public :: TensorDGDivergence_2D => TensorDGDivergence_2D_cpu, TensorDGDivergence_2D_gpu procedure, private :: TensorDGDivergence_2D_cpu procedure, private :: TensorDGDivergence_2D_gpu generic, public :: TensorDGDivergence_3D => TensorDGDivergence_3D_cpu, TensorDGDivergence_3D_gpu procedure, private :: TensorDGDivergence_3D_cpu procedure, private :: TensorDGDivergence_3D_gpu generic, public :: TensorDivergence_2D => TensorDivergence_2D_cpu, TensorDivergence_2D_gpu procedure, private :: TensorDivergence_2D_cpu procedure, private :: TensorDivergence_2D_gpu generic, public :: TensorDivergence_3D => TensorDivergence_3D_cpu, TensorDivergence_3D_gpu procedure, private :: TensorDivergence_3D_cpu procedure, private :: TensorDivergence_3D_gpu generic, public :: TensorGridInterp_2D => TensorGridInterp_2D_cpu, TensorGridInterp_2D_gpu procedure, private :: TensorGridInterp_2D_cpu procedure, private :: TensorGridInterp_2D_gpu generic, public :: TensorGridInterp_3D => TensorGridInterp_3D_cpu, TensorGridInterp_3D_gpu procedure, private :: TensorGridInterp_3D_cpu procedure, private :: TensorGridInterp_3D_gpu procedure, public :: UpdateDevice => UpdateDevice_Lagrange procedure, public :: UpdateHost => UpdateHost_Lagrange generic, public :: VectorBoundaryInterp_2D => VectorBoundaryInterp_2D_cpu, VectorBoundaryInterp_2D_gpu procedure, private :: VectorBoundaryInterp_2D_cpu procedure, private :: VectorBoundaryInterp_2D_gpu generic, public :: VectorBoundaryInterp_3D => VectorBoundaryInterp_3D_cpu, VectorBoundaryInterp_3D_gpu procedure, private :: VectorBoundaryInterp_3D_cpu procedure, private :: VectorBoundaryInterp_3D_gpu generic, public :: VectorCurl_2D => VectorCurl_2D_cpu, VectorCurl_2D_gpu procedure, private :: VectorCurl_2D_cpu procedure, private :: VectorCurl_2D_gpu generic, public :: VectorCurl_3D => VectorCurl_3D_cpu, VectorCurl_3D_gpu procedure, private :: VectorCurl_3D_cpu procedure, private :: VectorCurl_3D_gpu generic, public :: VectorDGDivergence_2D => VectorDGDivergence_2D_cpu, VectorDGDivergence_2D_gpu procedure, private :: VectorDGDivergence_2D_cpu procedure, private :: VectorDGDivergence_2D_gpu generic, public :: VectorDGDivergence_3D => VectorDGDivergence_3D_cpu, VectorDGDivergence_3D_gpu procedure, private :: VectorDGDivergence_3D_cpu procedure, private :: VectorDGDivergence_3D_gpu generic, public :: VectorDGGradient_2D => VectorDGGradient_2D_cpu, VectorDGGradient_2D_gpu procedure, private :: VectorDGGradient_2D_cpu procedure, private :: VectorDGGradient_2D_gpu generic, public :: VectorDivergence_2D => VectorDivergence_2D_cpu, VectorDivergence_2D_gpu procedure, private :: VectorDivergence_2D_cpu procedure, private :: VectorDivergence_2D_gpu generic, public :: VectorDivergence_3D => VectorDivergence_3D_cpu, VectorDivergence_3D_gpu procedure, private :: VectorDivergence_3D_cpu procedure, private :: VectorDivergence_3D_gpu generic, public :: VectorGradient_2D => VectorGradient_2D_cpu, VectorGradient_2D_gpu procedure, private :: VectorGradient_2D_cpu procedure, private :: VectorGradient_2D_gpu generic, public :: VectorGradient_3D => VectorGradient_3D_cpu, VectorGradient_3D_gpu procedure, private :: VectorGradient_3D_cpu procedure, private :: VectorGradient_3D_gpu generic, public :: VectorGridInterp_2D => VectorGridInterp_2D_cpu, VectorGridInterp_2D_gpu procedure, private :: VectorGridInterp_2D_cpu procedure, private :: VectorGridInterp_2D_gpu generic, public :: VectorGridInterp_3D => VectorGridInterp_3D_cpu, VectorGridInterp_3D_gpu procedure, private :: VectorGridInterp_3D_cpu procedure, private :: VectorGridInterp_3D_gpu Functions public function CalculateLagrangePolynomials (myPoly, sE) result(lAtS) Arguments Type Intent Optional Attributes Name class( Lagrange ) :: myPoly real(kind=prec) :: sE Return Value real(kind=prec)\n  (0:myPoly%N) Subroutines public subroutine CalculateBarycentricWeights (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly public subroutine CalculateDerivativeMatrix (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly public subroutine CalculateInterpolationMatrix (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly public subroutine DGDerivative_1D_cpu (myPoly, f, bf, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:nVariables,1:2,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine DGDerivative_1D_gpu (myPoly, f_dev, bf_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine Derivative_1D_cpu (myPoly, f, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine Derivative_1D_gpu (myPoly, f_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine Free_Lagrange (myPoly) Frees all memory (host and device) associated with an instance of the Lagrange class Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance public subroutine Init_Lagrange (myPoly, N, controlNodeType, M, targetNodeType) Initialize an instance of the Lagrange class\nOn output, all of the attributes for the Lagrange class are allocated and values are initialized according to the number of\ncontrol points, number of target points, and the types for the control and target nodes.\nIf a GPU is available, device pointers for the Lagrange attributes are allocated and initialized. Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(out) :: myPoly Lagrange class instance integer, intent(in) :: N The number of control points for interpolant integer, intent(in) :: controlNodeType The integer code specifying the type of control points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) integer, intent(in) :: M The number of target points for the interpolant integer, intent(in) :: targetNodeType The integer code specifying the type of target points. Parameters are defined in SELF_Constants.f90. One of GAUSS(=1),\nGAUSS_LOBATTO(=2), or UNIFORM(=3) public subroutine ScalarBoundaryInterp_1D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:nVariables,1:2,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_1D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarDGGradient_2D_cpu (myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarDGGradient_2D_gpu (myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGridInterp_1D_cpu (myPoly, f, fInterp, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fInterp (0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine ScalarGridInterp_1D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_1D interface.\nIn most cases, you should use the ScalarGridInterp_1D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_1D_gpu_wrapper\nInterpolate a scalar-1D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine ScalarGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine ScalarGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the ScalarGridInterp_2D interface.\nIn most cases, you should use the ScalarGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:ScalarGridInterp_2D_gpu_wrapper\nInterpolate a scalar-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine ScalarGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDGDivergence_2D_cpu (myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDGDivergence_2D_gpu (myPoly, f_dev, bf_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDGDivergence_3D_cpu (myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDGDivergence_3D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDivergence_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDivergence_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDivergence_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDivergence_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the TensorGridInterp_2D interface.\nIn most cases, you should use the TensorGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a tensor-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (1:2,1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine TensorGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the TensorGridInterp_2D interface.\nIn most cases, you should use the TensorGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:TensorGridInterp_2D_gpu_wrapper\nInterpolate a tensor-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine TensorGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine UpdateDevice_Lagrange (myPoly) Copy the Lagrange attributes from the host (CPU) to the device (GPU) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance public subroutine UpdateHost_Lagrange (myPoly) Copy the Lagrange attributes from the device (GPU) to the host (CPU) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Lagrange class instance public subroutine VectorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorCurl_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorCurl_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorCurl_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorCurl_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_2D_cpu (myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_2D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_3D_cpu (myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_3D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGGradient_2D_cpu (myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGGradient_2D_gpu (myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Host (CPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) (Input) Array of function values, defined on the control grid real(kind=prec), intent(out) :: fNew (1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine VectorGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Device (GPU) implementation of the VectorGridInterp_2D interface.\nIn most cases, you should use the VectorGridInterp_2D generic interface,\nrather than calling this routine directly.\nThis routine calls hip/SELF_Lagrange.cpp:VectorGridInterp_2D_gpu_wrapper\nInterpolate a vector-2D (real) array from the control grid to the target grid.\nThe control and target grids are the ones associated with an initialized \nLagrange instance. Read more… Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly Lagrange class instance type(c_ptr), intent(in) :: f_dev (Input) Array of function values, defined on the control grid type(c_ptr), intent(out) :: fInterp_dev (Output) Array of function values, defined on the target grid integer, intent(in) :: nVariables The number of variables/functions that are interpolated integer, intent(in) :: nElements The number of spectral elements in the SEM grid public subroutine VectorGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements","tags":"","loc":"module/self_lagrange.html"},{"title":"sadv2d – SELF","text":"Uses FEQParse SELF_Constants SELF_Mesh SELF_Advection2D program~~sadv2d~~UsesGraph program~sadv2d sadv2d FEQParse FEQParse program~sadv2d->FEQParse module~self_mesh SELF_Mesh program~sadv2d->module~self_mesh module~self_constants SELF_Constants program~sadv2d->module~self_constants module~self_advection2d SELF_Advection2D program~sadv2d->module~self_advection2d module~self_mesh->module~self_constants module~self_lagrange SELF_Lagrange module~self_mesh->module~self_lagrange module~self_data SELF_Data module~self_mesh->module~self_data module~self_hashtable SELF_HashTable module~self_mesh->module~self_hashtable iso_c_binding iso_c_binding module~self_mesh->iso_c_binding module~self_mpi SELF_MPI module~self_mesh->module~self_mpi HDF5 HDF5 module~self_mesh->HDF5 module~self_supportroutines SELF_SupportRoutines module~self_mesh->module~self_supportroutines module~self_hdf5 SELF_HDF5 module~self_mesh->module~self_hdf5 iso_fortran_env iso_fortran_env module~self_constants->iso_fortran_env module~self_constants->iso_c_binding module~self_advection2d->FEQParse module~self_advection2d->module~self_mesh module~self_advection2d->module~self_constants module~self_dg SELF_DG module~self_advection2d->module~self_dg FLAP FLAP module~self_advection2d->FLAP module~self_advection2d->iso_c_binding module~self_advection2d->module~self_supportroutines module~self_lagrange->module~self_constants module~self_lagrange->iso_fortran_env module~self_lagrange->iso_c_binding module~self_lagrange->module~self_supportroutines module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort_check hipfort_check module~self_lagrange->hipfort_check hipfort hipfort module~self_lagrange->hipfort module~self_data->module~self_constants module~self_data->module~self_lagrange module~self_data->iso_c_binding module~self_dg->module~self_mesh module~self_dg->module~self_mpi module~self_dg->HDF5 module~self_dg->module~self_hdf5 module~self_mappeddata SELF_MappedData module~self_dg->module~self_mappeddata module~self_metadata SELF_Metadata module~self_dg->module~self_metadata module~self_hashtable->module~self_constants module~self_linkedlist SELF_LinkedList module~self_hashtable->module~self_linkedlist module~self_mpi->module~self_constants module~self_mpi->iso_c_binding module~self_mpi->module~self_memory module~self_supportroutines->module~self_constants module~self_supportroutines->iso_fortran_env module~self_hdf5->module~self_constants module~self_hdf5->iso_fortran_env module~self_hdf5->HDF5 module~self_hdf5->module~self_memory module~self_mappeddata->module~self_mesh module~self_mappeddata->module~self_constants module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_data module~self_mappeddata->iso_c_binding module~self_mappeddata->module~self_mpi module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry module~self_memory->module~self_constants module~self_memory->iso_fortran_env module~self_memory->iso_c_binding module~self_memory->hipfort_check module~self_memory->hipfort module~self_quadrature->module~self_constants module~self_quadrature->iso_fortran_env module~self_metadata->module~self_hdf5 module~self_geometry->module~self_mesh module~self_geometry->module~self_constants module~self_geometry->module~self_lagrange module~self_geometry->module~self_data module~self_geometry->module~self_supportroutines Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables endTime i model nDumps Source Code sadv2d Variables Type Attributes Name Initial real(kind=prec) :: endTime integer :: i type(Advection2D) :: model integer :: nDumps Source Code PROGRAM sadv2d USE SELF_Advection2D USE SELF_Mesh USE FEQParse USE SELF_Constants TYPE ( Advection2D ) :: model INTEGER :: nDumps INTEGER :: i REAL ( prec ) :: endTime CALL model % InitFromCLI ( ) CALL model % WriteTecplot () nDumps = INT (( model % endTime - model % initialTime ) / ( model % outputInterval ) ) DO i = 1 , nDumps endTime = model % simulationTime + model % outputInterval CALL model % ForwardStep ( endTime ) CALL model % WriteTecplot () ENDDO CALL model % Free () END PROGRAM sadv2d","tags":"","loc":"program/sadv2d.html"},{"title":"sadv3d – SELF","text":"Uses FEQParse SELF_Advection3D SELF_Mesh SELF_Constants program~~sadv3d~~UsesGraph program~sadv3d sadv3d module~self_mesh SELF_Mesh program~sadv3d->module~self_mesh FEQParse FEQParse program~sadv3d->FEQParse module~self_constants SELF_Constants program~sadv3d->module~self_constants module~self_advection3d SELF_Advection3D program~sadv3d->module~self_advection3d module~self_mesh->module~self_constants module~self_lagrange SELF_Lagrange module~self_mesh->module~self_lagrange module~self_data SELF_Data module~self_mesh->module~self_data module~self_hashtable SELF_HashTable module~self_mesh->module~self_hashtable iso_c_binding iso_c_binding module~self_mesh->iso_c_binding module~self_mpi SELF_MPI module~self_mesh->module~self_mpi HDF5 HDF5 module~self_mesh->HDF5 module~self_supportroutines SELF_SupportRoutines module~self_mesh->module~self_supportroutines module~self_hdf5 SELF_HDF5 module~self_mesh->module~self_hdf5 iso_fortran_env iso_fortran_env module~self_constants->iso_fortran_env module~self_constants->iso_c_binding module~self_advection3d->module~self_mesh module~self_advection3d->FEQParse module~self_advection3d->module~self_constants module~self_dg SELF_DG module~self_advection3d->module~self_dg FLAP FLAP module~self_advection3d->FLAP module~self_advection3d->iso_c_binding module~self_advection3d->module~self_supportroutines module~self_lagrange->module~self_constants module~self_lagrange->iso_fortran_env module~self_lagrange->iso_c_binding module~self_lagrange->module~self_supportroutines module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort_check hipfort_check module~self_lagrange->hipfort_check hipfort hipfort module~self_lagrange->hipfort module~self_data->module~self_constants module~self_data->module~self_lagrange module~self_data->iso_c_binding module~self_dg->module~self_mesh module~self_dg->module~self_mpi module~self_dg->HDF5 module~self_dg->module~self_hdf5 module~self_mappeddata SELF_MappedData module~self_dg->module~self_mappeddata module~self_metadata SELF_Metadata module~self_dg->module~self_metadata module~self_hashtable->module~self_constants module~self_linkedlist SELF_LinkedList module~self_hashtable->module~self_linkedlist module~self_mpi->module~self_constants module~self_mpi->iso_c_binding module~self_mpi->module~self_memory module~self_supportroutines->module~self_constants module~self_supportroutines->iso_fortran_env module~self_hdf5->module~self_constants module~self_hdf5->iso_fortran_env module~self_hdf5->HDF5 module~self_hdf5->module~self_memory module~self_mappeddata->module~self_mesh module~self_mappeddata->module~self_constants module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_data module~self_mappeddata->iso_c_binding module~self_mappeddata->module~self_mpi module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry module~self_memory->module~self_constants module~self_memory->iso_fortran_env module~self_memory->iso_c_binding module~self_memory->hipfort_check module~self_memory->hipfort module~self_quadrature->module~self_constants module~self_quadrature->iso_fortran_env module~self_metadata->module~self_hdf5 module~self_geometry->module~self_mesh module~self_geometry->module~self_constants module~self_geometry->module~self_lagrange module~self_geometry->module~self_data module~self_geometry->module~self_supportroutines Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables endTime i model nDumps Source Code sadv3d Variables Type Attributes Name Initial real(kind=prec) :: endTime integer :: i type(Advection3D) :: model integer :: nDumps Source Code PROGRAM sadv3d USE SELF_Advection3D USE SELF_Mesh USE FEQParse USE SELF_Constants TYPE ( Advection3D ) :: model INTEGER :: nDumps INTEGER :: i REAL ( prec ) :: endTime CALL model % InitFromCLI ( ) CALL model % WriteTecplot () nDumps = INT (( model % endTime - model % initialTime ) / ( model % outputInterval ) ) DO i = 1 , nDumps endTime = model % simulationTime + model % outputInterval CALL model % ForwardStep ( endTime ) CALL model % WriteTecplot () ENDDO CALL model % Free () END PROGRAM sadv3d","tags":"","loc":"program/sadv3d.html"}]}