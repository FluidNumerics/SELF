var tipuesearch = {"pages":[{"title":" SELF ","text":"SELF Developer Info Joe Schoonover Committed to service for science","tags":"home","loc":"index.html"},{"title":"SELF.f90 – SELF","text":"This file depends on sourcefile~~self.f90~~EfferentGraph sourcefile~self.f90 SELF.f90 sourcefile~self_tests.f90 SELF_Tests.f90 sourcefile~self.f90->sourcefile~self_tests.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self.f90->sourcefile~self_constants.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self.f90->sourcefile~self_supportroutines.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_tests.f90->sourcefile~self_memory.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_tests.f90->sourcefile~self_data.f90 sourcefile~self_tests.f90->sourcefile~self_constants.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_tests.f90->sourcefile~self_mappeddata.f90 sourcefile~self_tests.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_tests.f90->sourcefile~self_mesh.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_tests.f90->sourcefile~self_quadrature.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_tests.f90->sourcefile~self_lagrange.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_constants.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs SELF Source Code SELF.f90 Source Code PROGRAM SELF USE SELF_Constants USE SELF_SupportRoutines USE SELF_Tests USE FLAP IMPLICIT NONE TYPE ( COMMAND_LINE_INTERFACE ) :: self_cli CHARACTER ( 20 ) :: cqTypeChar CHARACTER ( 20 ) :: tqTypeChar CHARACTER ( 240 ) :: functionChar CHARACTER ( 240 ) :: derivativeChar CHARACTER ( 240 ) :: vectorChar ( 1 : 3 ) CHARACTER ( 240 ) :: tensorChar ( 1 : 3 , 1 : 3 ) CHARACTER ( 10 ) :: dFormChar CHARACTER ( 5 ) :: gpuAccelChar REAL ( prec ) :: errorTolerance INTEGER :: dForm INTEGER :: cqType INTEGER :: tqType INTEGER :: cqDegree INTEGER :: tqDegree INTEGER :: nElem INTEGER :: nVar INTEGER :: error INTEGER :: errorCount LOGICAL :: gpuAccel CALL Parse_CLI ( self_cli ) CALL self_cli % get ( val = cqTypeChar , switch = '--control-quadrature' ) CALL self_cli % get ( val = tqTypeChar , switch = '--target-quadrature' ) CALL self_cli % get ( val = cqDegree , switch = '--control-degree' ) CALL self_cli % get ( val = tqDegree , switch = '--target-degree' ) CALL self_cli % get ( val = nElem , switch = '--nelements' ) CALL self_cli % get ( val = nVar , switch = '--nvar' ) CALL self_cli % get ( val = functionChar , switch = '--function' ) CALL self_cli % get ( val = dFormChar , switch = '--derivative-type' ) CALL self_cli % get ( val = derivativeChar , switch = '--derivative' ) CALL self_cli % get ( val = gpuAccelChar , switch = '--gpu-accel' ) CALL self_cli % get ( val = vectorChar ( 1 ), switch = '--vector-x' ) CALL self_cli % get ( val = vectorChar ( 2 ), switch = '--vector-y' ) CALL self_cli % get ( val = vectorChar ( 3 ), switch = '--vector-z' ) CALL self_cli % get ( val = tensorChar ( 1 , 1 ), switch = '--tensor-11' ) CALL self_cli % get ( val = tensorChar ( 1 , 2 ), switch = '--tensor-12' ) CALL self_cli % get ( val = tensorChar ( 1 , 3 ), switch = '--tensor-13' ) CALL self_cli % get ( val = tensorChar ( 2 , 1 ), switch = '--tensor-21' ) CALL self_cli % get ( val = tensorChar ( 2 , 2 ), switch = '--tensor-22' ) CALL self_cli % get ( val = tensorChar ( 2 , 3 ), switch = '--tensor-23' ) CALL self_cli % get ( val = tensorChar ( 3 , 1 ), switch = '--tensor-31' ) CALL self_cli % get ( val = tensorChar ( 3 , 2 ), switch = '--tensor-32' ) CALL self_cli % get ( val = tensorChar ( 3 , 3 ), switch = '--tensor-33' ) CALL self_cli % get ( val = errorTolerance , switch = '--tolerance' ) IF ( TRIM ( UpperCase ( cqTypeChar )) == 'GAUSS' ) THEN cqType = GAUSS ELSEIF ( TRIM ( UpperCase ( cqTypeChar )) == 'GAUSS-LOBATTO' ) THEN cqType = GAUSS_LOBATTO ELSE PRINT * , 'Invalid Control Quadrature' STOP - 1 END IF IF ( TRIM ( UpperCase ( tqTypeChar )) == 'GAUSS' ) THEN tqType = GAUSS ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'GAUSS-LOBATTO' ) THEN tqType = GAUSS_LOBATTO ELSE PRINT * , 'Invalid Target Quadrature' STOP - 1 END IF IF ( TRIM ( UpperCase ( dFormChar )) == 'STRONG' ) THEN dForm = selfStrongForm ELSEIF ( TRIM ( UpperCase ( dFormChar )) == 'DG' ) THEN dForm = selfWeakDGForm ELSEIF ( TRIM ( UpperCase ( dFormChar )) == 'CG' ) THEN dForm = selfWeakCGForm ENDIF IF ( TRIM ( UpperCase ( gpuAccelChar )) == 'TRUE' ) THEN gpuAccel = . TRUE . ELSE gpuAccel = . FALSE . END IF errorCount = 0 IF ( self_cli % run_command ( group = \"ci-test\" )) THEN CALL BlockMesh1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , errorTolerance , error ) errorCount = errorCount + error CALL BlockMesh2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , errorTolerance , error ) errorCount = errorCount + error CALL BlockMesh3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , errorTolerance , error ) errorCount = errorCount + error CALL ScalarInterp1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar ( 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL TensorInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar ( 1 : 2 , 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL TensorInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarBoundaryInterp1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar ( 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL TensorBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar ( 1 : 2 , 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL TensorBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarDerivative1D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& functionChar , derivativeChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarGradient2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& functionChar , vectorChar ( 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarGradient3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& functionChar , vectorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorGradient2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& vectorChar ( 1 : 2 ), tensorChar ( 1 : 2 , 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorDivergence2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& vectorChar ( 1 : 2 ), functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorGradient3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& vectorChar , tensorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorDivergence3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& vectorChar , functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"blockmesh_1d\" )) THEN CALL BlockMesh1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , errorTolerance , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"blockmesh_2d\" )) THEN CALL BlockMesh2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , errorTolerance , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"blockmesh_3d\" )) THEN CALL BlockMesh3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , errorTolerance , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s1d_interp\" )) THEN CALL ScalarInterp1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s2d_interp\" )) THEN CALL ScalarInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s3d_interp\" )) THEN CALL ScalarInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v2d_interp\" )) THEN CALL VectorInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar ( 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"t2d_interp\" )) THEN CALL TensorInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar ( 1 : 2 , 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v3d_interp\" )) THEN CALL VectorInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"t3d_interp\" )) THEN CALL TensorInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s1d_binterp\" )) THEN CALL ScalarBoundaryInterp1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s2d_binterp\" )) THEN CALL ScalarBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s3d_binterp\" )) THEN CALL ScalarBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v2d_binterp\" )) THEN CALL VectorBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar ( 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"t2d_binterp\" )) THEN CALL TensorBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar ( 1 : 2 , 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v3d_binterp\" )) THEN CALL VectorBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"t3d_binterp\" )) THEN CALL TensorBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s1d_derivative\" )) THEN CALL ScalarDerivative1D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& functionChar , derivativeChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s2d_gradient\" )) THEN CALL ScalarGradient2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& functionChar , vectorChar ( 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s3d_gradient\" )) THEN CALL ScalarGradient3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& functionChar , vectorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v2d_gradient\" )) THEN CALL VectorGradient2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& vectorChar ( 1 : 2 ), tensorChar ( 1 : 2 , 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v2d_divergence\" )) THEN CALL VectorDivergence2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& vectorChar ( 1 : 2 ), functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v3d_gradient\" )) THEN CALL VectorGradient3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar , vectorChar , tensorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v3d_divergence\" )) THEN CALL VectorDivergence3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& vectorChar , functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error END IF CALL self_cli % free () IF ( errorCount > 0 ) THEN STOP errorCount ENDIF CONTAINS SUBROUTINE Parse_CLI ( cli ) IMPLICIT NONE TYPE ( COMMAND_LINE_INTERFACE ), INTENT ( out ) :: cli CALL cli % init ( progname = \"self\" , & version = \"v0.0.0\" , & description = \"Spectral Element Libraries in Fortran (SELF)\" , & license = \"ANTI-CAPITALIST SOFTWARE LICENSE (v 1.4)\" , & authors = \"Joseph Schoonover (Fluid Numerics LLC)\" ) CALL cli % add ( switch = \"--control-degree\" , & switch_ab = \"-c\" , & help = \"The polynomial degree of the control points.\" // NEW_LINE ( \"A\" ), & def = \"2\" , & required = . FALSE .) CALL cli % add ( switch = \"--target-degree\" , & switch_ab = \"-t\" , & help = \"The polynomial degree for the target points for interpolation.\" // NEW_LINE ( \"A\" ), & def = \"7\" , & required = . FALSE .) CALL cli % add ( switch = \"--control-quadrature\" , & switch_ab = \"-cq\" , & def = \"gauss\" , & help = \"The quadrature type for control points.\" // NEW_LINE ( \"A\" ), & choices = \"gauss, gauss-lobatto, uniform\" , & required = . FALSE .) CALL cli % add ( switch = \"--target-quadrature\" , & switch_ab = \"-tq\" , & def = \"gauss\" , & help = \"The quadrature type for target points.\" // NEW_LINE ( \"A\" ), & choices = \"gauss, gauss-lobatto, uniform\" , & required = . FALSE .) CALL cli % add ( switch = \"--nvar\" , & switch_ab = \"-nv\" , & help = \"The number of functions used to simulate increased workloads.\" // NEW_LINE ( \"A\" ), & def = \"5\" , & required = . FALSE .) CALL cli % add ( switch = \"--nelements\" , & switch_ab = \"-ne\" , & help = \"The number of elements to use on the test mesh. \" // & \"In multi-dimensions, the number of elements in each direction.\" // NEW_LINE ( \"A\" ), & def = \"10\" , & required = . FALSE .) CALL cli % add ( switch = \"--gpu-accel\" , & switch_ab = \"-gpu\" , & help = \"Boolean flag for enabling or disabling GPU acceleration in tests.\" // NEW_LINE ( \"A\" ), & def = \"false\" , & choices = \"true,false\" , & required = . FALSE .) CALL cli % add ( switch = \"--tolerance\" , & switch_ab = \"-tol\" , & help = \"Tolerance to use for determining if a test passes.\" // NEW_LINE ( \"A\" ), & def = \"1.0E-5\" , & required = . FALSE .) CALL cli % add ( switch = \"--derivative-type\" , & switch_ab = \"-dtype\" , & help = \"Flag to choose the type of derivative operator (weak/strong).\" // NEW_LINE ( \"A\" ), & def = \"strong\" , & choices = \"strong,dg\" , & required = . FALSE .) CALL cli % add ( switch = \"--function\" , & switch_ab = \"-f\" , & help = \"Function to interpolate from control points to target points\" // NEW_LINE ( \"A\" ), & def = \"f=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--derivative\" , & switch_ab = \"-df\" , & help = \"Derivative of the test function; used for estimating errors.\" // NEW_LINE ( \"A\" ), & def = \"df=0.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--vector-x\" , & switch_ab = \"-vx\" , & help = \"x-component of the vector function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"vx=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--vector-y\" , & switch_ab = \"-vy\" , & help = \"y-component of the vector function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"vy=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--vector-z\" , & switch_ab = \"-vz\" , & help = \"z-component of the vector function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"vz=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-11\" , & switch_ab = \"-t11\" , & help = \"Row 1 column 1 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t11=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-12\" , & switch_ab = \"-t12\" , & help = \"Row 1 column 2 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t12=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-13\" , & switch_ab = \"-t13\" , & help = \"Row 1 column 3 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t13=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-21\" , & switch_ab = \"-t21\" , & help = \"Row 2 column 1 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t21=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-22\" , & switch_ab = \"-t22\" , & help = \"Row 2 column 2 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t22=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-23\" , & switch_ab = \"-t23\" , & help = \"Row 2 column 3 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t23=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-31\" , & switch_ab = \"-t31\" , & help = \"Row 3 column 1 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t31=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-32\" , & switch_ab = \"-t32\" , & help = \"Row 3 column 2 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t32=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-33\" , & switch_ab = \"-t33\" , & help = \"Row 2 column 3 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t33=1.0\" , & required = . FALSE .) CALL cli % add_group ( group = \"ci-test\" , & description = \"Run all CI-Tests\" ) CALL cli % add_group ( group = \"blockmesh_1d\" , & description = \"Block Mesh generation in 1D\" ) CALL cli % add_group ( group = \"blockmesh_2d\" , & description = \"Block Mesh generation in 2D\" ) CALL cli % add_group ( group = \"blockmesh_3d\" , & description = \"Block Mesh generation in 3D\" ) CALL cli % add_group ( group = \"s1d_interp\" , & description = \"Scalar 1D Grid Interpolation\" ) CALL cli % add_group ( group = \"s2d_interp\" , & description = \"Scalar 2D Grid Interpolation\" ) CALL cli % add_group ( group = \"s3d_interp\" , & description = \"Scalar 3D Grid Interpolation\" ) CALL cli % add_group ( group = \"v2d_interp\" , & description = \"Vector 2D Grid Interpolation\" ) CALL cli % add_group ( group = \"v3d_interp\" , & description = \"Vector 3D Grid Interpolation\" ) CALL cli % add_group ( group = \"t2d_interp\" , & description = \"Tensor 2D Grid Interpolation\" ) CALL cli % add_group ( group = \"t3d_interp\" , & description = \"Tensor 3D Grid Interpolation\" ) CALL cli % add_group ( group = \"s1d_binterp\" , & description = \"Scalar 1D Boundary interpolation\" ) CALL cli % add_group ( group = \"s2d_binterp\" , & description = \"Scalar 2D Boundary interpolation\" ) CALL cli % add_group ( group = \"s3d_binterp\" , & description = \"Scalar 3D Boundary interpolation\" ) CALL cli % add_group ( group = \"v2d_binterp\" , & description = \"Vector 2D Boundary interpolation\" ) CALL cli % add_group ( group = \"v3d_binterp\" , & description = \"Vector 3D Boundary interpolation\" ) CALL cli % add_group ( group = \"t2d_binterp\" , & description = \"Tensor 2D Boundary interpolation\" ) CALL cli % add_group ( group = \"t3d_binterp\" , & description = \"Tensor 3D Boundary interpolation\" ) CALL cli % add_group ( group = \"s1d_derivative\" , & description = \"Scalar 1D Derivative\" ) CALL cli % add_group ( group = \"s2d_gradient\" , & description = \"Scalar 2D Gradient\" ) CALL cli % add_group ( group = \"s3d_gradient\" , & description = \"Scalar 3D Gradient\" ) CALL cli % add_group ( group = \"v2d_gradient\" , & description = \"Vector 2D Gradient\" ) CALL cli % add_group ( group = \"v2d_divergence\" , & description = \"Vector 2D Divergence\" ) CALL cli % add_group ( group = \"v2d_curl\" , & description = \"Vector 2D Curl\" ) CALL cli % add_group ( group = \"v3d_gradient\" , & description = \"Vector 3D Gradient\" ) CALL cli % add_group ( group = \"v3d_divergence\" , & description = \"Vector 3D Divergence\" ) CALL cli % add_group ( group = \"v3d_curl\" , & description = \"Vector 3D Curl\" ) CALL cli % parse () END SUBROUTINE Parse_CLI END PROGRAM SELF","tags":"","loc":"sourcefile/self.f90.html"},{"title":"SELF_Constants.f90 – SELF","text":"Files dependent on this one sourcefile~~self_constants.f90~~AfferentGraph sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_tests.f90 SELF_Tests.f90 sourcefile~self_tests.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_tests.f90->sourcefile~self_quadrature.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_tests.f90->sourcefile~self_memory.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_tests.f90->sourcefile~self_data.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_tests.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_tests.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_tests.f90->sourcefile~self_mappeddata.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_tests.f90->sourcefile~self_lagrange.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self.f90 SELF.f90 sourcefile~self.f90->sourcefile~self_constants.f90 sourcefile~self.f90->sourcefile~self_tests.f90 sourcefile~self.f90->sourcefile~self_supportroutines.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_geometry.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_constants.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mpilayer.f90 SELF_MPILayer.f90 sourcefile~self_mpilayer.f90->sourcefile~self_data.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mesh.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mappeddata.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Constants Source Code SELF_Constants.f90 Source Code ! SELF_Constants.f90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self-fluids@fluidnumerics.com ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Constants USE ISO_FORTRAN_ENV IMPLICIT NONE #ifdef HAVE_MPI INCLUDE 'mpif.h' #endif #ifdef DOUBLE_PRECISION INTEGER , PARAMETER :: prec = real64 #else INTEGER , PARAMETER :: prec = real32 #endif !*************************************************************! ! ------------------ MATHEMATICAL CONSTANTS ------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! REAL ( prec ), PARAMETER :: pi = 4.0_prec * atan ( 1.0_prec ) REAL ( prec ), PARAMETER :: TOL = epsilon ( 1.0_prec ) REAL ( prec ), PARAMETER :: fillValue = - 999 9.99_prec INTEGER , PARAMETER :: fillValueInt = - 99999 !*************************************************************! ! ----------------- ROOT FINDER CONSTANTS --------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! REAL ( prec ), PARAMETER :: tolerance = 1 0.0 ** ( - 10 ) INTEGER , PARAMETER :: maxInverseIters = 1000 REAL ( prec ), PARAMETER :: newtonTolerance = 1 0.0 ** ( - 8 ) INTEGER , PARAMETER :: newtonMax = 500 !*************************************************************! ! ----------------- TIME STEPPING CONSTANTS ------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! ! Runge-Kutta 3rd Order, low storage constants REAL ( prec ), PARAMETER :: rk3_a ( 1 : 3 ) = ( / 0.0_prec , - 5.0_prec / 9.0_prec , - 15 3.0_prec / 12 8.0_prec / ) REAL ( prec ), PARAMETER :: rk3_b ( 1 : 3 ) = ( / 0.0_prec , 1.0_prec / 3.0_prec , 3.0_prec / 4.0_prec / ) REAL ( prec ), PARAMETER :: rk3_g ( 1 : 3 ) = ( / 1.0_prec / 3.0_prec , 1 5.0_prec / 1 6.0_prec , 8.0_prec / 1 5.0_prec / ) !*************************************************************! ! ------------------- PHYSICAL CONSTANTS ---------------------! ! ************************************************************! !                                                             ! ! ------------------------------------------------------------! ! Time conversion factors REAL ( prec ), PARAMETER :: secondsToMinutes = 1.0_prec / 6 0.0_prec ! conversion for seconds to minutes REAL ( prec ), PARAMETER :: minutesToHours = 1.0_prec / 6 0.0_prec ! conversion for minutes to hours REAL ( prec ), PARAMETER :: hoursToDays = 1.0_prec / 2 4.0_prec ! conversion for hours to days REAL ( prec ), PARAMETER :: daysToMonths = 1 2.0_prec / 36 5.25_prec ! conversion for days to months REAL ( prec ), PARAMETER :: monthsToYears = 1.0_prec / 1 2.0_prec ! conversion for months to years REAL ( prec ), PARAMETER :: daysToSeconds = 8640 0.0_prec !==============================================! ! --------------- Quadrature------------------ ! !==============================================! INTEGER , PARAMETER :: GAUSS = 1 INTEGER , PARAMETER :: GAUSS_LOBATTO = 2 INTEGER , PARAMETER :: UNIFORM = 3 INTEGER , PARAMETER :: DG = 2000 INTEGER , PARAMETER :: CG = 2001 ! Misc. INTEGER and CHARACTER flag definitions CHARACTER ( 1 ), PARAMETER :: nada = ' ' CHARACTER ( 6 ), PARAMETER :: MsgFmt = '(2x,A)' END MODULE SELF_Constants","tags":"","loc":"sourcefile/self_constants.f90.html"},{"title":"SELF_Data.f90 – SELF","text":"This file depends on sourcefile~~self_data.f90~~EfferentGraph sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_data.f90~~AfferentGraph sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_tests.f90 SELF_Tests.f90 sourcefile~self_tests.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_tests.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_tests.f90->sourcefile~self_mappeddata.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_mpilayer.f90 SELF_MPILayer.f90 sourcefile~self_mpilayer.f90->sourcefile~self_data.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mesh.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mappeddata.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self.f90 SELF.f90 sourcefile~self.f90->sourcefile~self_tests.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Data Source Code SELF_Data.f90 Source Code ! SELF_Data.F90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self-fluids@fluidnumerics.com ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Data USE SELF_Constants USE SELF_Lagrange USE ISO_C_BINDING IMPLICIT NONE #include \"SELF_Macros.h\" ! ---------------------- Scalars ---------------------- ! TYPE , PUBLIC :: Scalar1D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r3 ) :: interior TYPE ( hfReal_r3 ) :: boundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar1D PROCEDURE , PUBLIC :: Free => Free_Scalar1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar1D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar1D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar1D GENERIC , PUBLIC :: Derivative => Derivative_Scalar1D PROCEDURE , PRIVATE :: Derivative_Scalar1D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar1D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar1D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Scalar1D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Scalar1D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Scalar1D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Scalar1D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Scalar1D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Scalar1D END TYPE Scalar1D TYPE , PUBLIC :: Scalar2D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r4 ) :: interior TYPE ( hfReal_r4 ) :: boundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar2D PROCEDURE , PUBLIC :: Free => Free_Scalar2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar2D GENERIC , PUBLIC :: Gradient => Gradient_Scalar2D PROCEDURE , PRIVATE :: Gradient_Scalar2D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar2D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar2D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Scalar2D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Scalar2D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Scalar2D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Scalar2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Scalar2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Scalar2D END TYPE Scalar2D TYPE , PUBLIC :: Scalar3D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r5 ) :: interior TYPE ( hfReal_r5 ) :: boundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar3D PROCEDURE , PUBLIC :: Free => Free_Scalar3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar3D GENERIC , PUBLIC :: Gradient => Gradient_Scalar3D PROCEDURE , PRIVATE :: Gradient_Scalar3D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar3D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar3D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Scalar3D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Scalar3D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Scalar3D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Scalar3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Scalar3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Scalar3D END TYPE Scalar3D ! ---------------------- Vectors ---------------------- ! TYPE , PUBLIC :: Vector2D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r5 ) :: interior TYPE ( hfReal_r5 ) :: boundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Vector2D PROCEDURE , PUBLIC :: Free => Free_Vector2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Vector2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Vector2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Vector2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Vector2D GENERIC , PUBLIC :: Gradient => Gradient_Vector2D PROCEDURE , PRIVATE :: Gradient_Vector2D GENERIC , PUBLIC :: Divergence => Divergence_Vector2D PROCEDURE , PRIVATE :: Divergence_Vector2D GENERIC , PUBLIC :: Curl => Curl_Vector2D PROCEDURE , PRIVATE :: Curl_Vector2D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Vector2D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Vector2D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Vector2D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Vector2D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Vector2D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Vector2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Vector2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Vector2D END TYPE Vector2D TYPE , PUBLIC :: Vector3D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r6 ) :: interior TYPE ( hfReal_r6 ) :: boundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Vector3D PROCEDURE , PUBLIC :: Free => Free_Vector3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Vector3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Vector3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Vector3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Vector3D GENERIC , PUBLIC :: Gradient => Gradient_Vector3D PROCEDURE , PRIVATE :: Gradient_Vector3D GENERIC , PUBLIC :: Divergence => Divergence_Vector3D PROCEDURE , PRIVATE :: Divergence_Vector3D GENERIC , PUBLIC :: Curl => Curl_Vector3D PROCEDURE , PRIVATE :: Curl_Vector3D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Vector3D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Vector3D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Vector3D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Vector3D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Vector3D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Vector3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Vector3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Vector3D END TYPE Vector3D ! ---------------------- Tensors ---------------------- ! TYPE , PUBLIC :: Tensor2D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r6 ) :: interior TYPE ( hfReal_r6 ) :: boundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Tensor2D PROCEDURE , PUBLIC :: Free => Free_Tensor2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Tensor2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Tensor2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Tensor2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Tensor2D PROCEDURE , PUBLIC :: Determinant => Determinant_Tensor2D GENERIC , PUBLIC :: Divergence => Divergence_Tensor2D PROCEDURE , PRIVATE :: Divergence_Tensor2D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Tensor2D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Tensor2D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Tensor2D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Tensor2D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Tensor2D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Tensor2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Tensor2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Tensor2D END TYPE Tensor2D TYPE , PUBLIC :: Tensor3D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r7 ) :: interior TYPE ( hfReal_r7 ) :: boundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Tensor3D PROCEDURE , PUBLIC :: Free => Free_Tensor3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Tensor3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Tensor3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Tensor3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Tensor3D PROCEDURE , PUBLIC :: Determinant => Determinant_Tensor3D GENERIC , PUBLIC :: Divergence => Divergence_Tensor3D PROCEDURE , PRIVATE :: Divergence_Tensor3D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Tensor3D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Tensor3D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Tensor3D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Tensor3D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Tensor3D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Tensor3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Tensor3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Tensor3D END TYPE Tensor3D INTEGER , PARAMETER :: selfStrongForm = 0 INTEGER , PARAMETER :: selfWeakDGForm = 1 INTEGER , PARAMETER :: selfWeakCGForm = 2 #ifdef GPU INTERFACE SUBROUTINE Determinant_Tensor2D_gpu_wrapper ( tensor_dev , detTensor_dev , N , nVar , nEl ) & bind ( c , name = \"Determinant_Tensor2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: tensor_dev , detTensor_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE Determinant_Tensor2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE Determinant_Tensor3D_gpu_wrapper ( tensor_dev , detTensor_dev , N , nVar , nEl ) & bind ( c , name = \"Determinant_Tensor3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: tensor_dev , detTensor_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE Determinant_Tensor3D_gpu_wrapper END INTERFACE #endif CONTAINS ! -- Scalar1D -- ! SUBROUTINE Init_Scalar1D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 1 , 1 / ), & upBound = ( / N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / nVar , 2 , nElem / )) END SUBROUTINE Init_Scalar1D SUBROUTINE Free_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () END SUBROUTINE Free_Scalar1D SUBROUTINE UpdateHost_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () #endif END SUBROUTINE UpdateHost_Scalar1D SUBROUTINE UpdateDevice_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Scalar1D SUBROUTINE BoundaryInterp_Scalar1D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_1D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_1D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar1D SUBROUTINE GridInterp_Scalar1D ( SELFStorage , SELFout , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar1D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_1D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_1D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar1D SUBROUTINE Derivative_Scalar1D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar1D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % Derivative_1D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % Derivative_1D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) ENDIF END SUBROUTINE Derivative_Scalar1D FUNCTION AbsMaxInterior_Scalar1D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar1D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar ) ! Local INTEGER :: iEl , iVar , i absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO i = 0 , scalar % N absMax ( iVar ) = MAX ( ABS ( scalar % interior % hostData ( i , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END FUNCTION AbsMaxInterior_Scalar1D FUNCTION AbsMaxBoundary_Scalar1D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar1D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar , 1 : 2 ) ! Local INTEGER :: iEl , iVar , iSide absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iSide = 1 , 2 DO iVar = 1 , scalar % nVar absMax ( iVar , iSide ) = MAX ( ABS ( scalar % boundary % hostData ( iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END FUNCTION AbsMaxBoundary_Scalar1D SUBROUTINE Equals_Scalar1D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFOut TYPE ( Scalar1D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Scalar1D FUNCTION Add_Scalar1D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar1D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Scalar1D FUNCTION Subtract_Scalar1D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar1D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Scalar1D ! -- Scalar2D -- ! SUBROUTINE Init_Scalar2D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 0 , 1 , 1 / ), & upBound = ( / N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / N , nVar , 4 , nElem / )) END SUBROUTINE Init_Scalar2D SUBROUTINE Free_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () END SUBROUTINE Free_Scalar2D SUBROUTINE UpdateHost_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () #endif END SUBROUTINE UpdateHost_Scalar2D SUBROUTINE UpdateDevice_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Scalar2D SUBROUTINE BoundaryInterp_Scalar2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar2D SUBROUTINE GridInterp_Scalar2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar2D SUBROUTINE Gradient_Scalar2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGradient_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGradient_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Scalar2D FUNCTION AbsMaxInterior_Scalar2D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar2D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar ) ! Local INTEGER :: iEl , iVar , i , j absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N absMax ( iVar ) = MAX ( ABS ( scalar % interior % hostData ( i , j , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Scalar2D FUNCTION AbsMaxBoundary_Scalar2D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar2D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar , 1 : 4 ) ! Local INTEGER :: iEl , iVar , i , iSide absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iSide = 1 , 4 DO iVar = 1 , scalar % nVar DO i = 0 , scalar % N absMax ( iVar , iSide ) = MAX ( ABS ( scalar % boundary % hostData ( i , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Scalar2D SUBROUTINE Equals_Scalar2D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFOut TYPE ( Scalar2D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Scalar2D FUNCTION Add_Scalar2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Scalar2D FUNCTION Subtract_Scalar2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Scalar2D ! -- Scalar3D -- ! SUBROUTINE Init_Scalar3D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) END SUBROUTINE Init_Scalar3D SUBROUTINE Free_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () END SUBROUTINE Free_Scalar3D SUBROUTINE UpdateHost_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () #endif END SUBROUTINE UpdateHost_Scalar3D SUBROUTINE UpdateDevice_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Scalar3D SUBROUTINE BoundaryInterp_Scalar3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar3D SUBROUTINE GridInterp_Scalar3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar3D SUBROUTINE Gradient_Scalar3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGradient_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGradient_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Scalar3D SUBROUTINE Equals_Scalar3D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFOut TYPE ( Scalar3D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Scalar3D FUNCTION AbsMaxInterior_Scalar3D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar3D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar ) ! Local INTEGER :: iEl , iVar , i , j , k absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N DO i = 0 , scalar % N absMax ( iVar ) = MAX ( ABS ( scalar % interior % hostData ( i , j , k , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Scalar3D FUNCTION AbsMaxBoundary_Scalar3D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar3D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar , 1 : 6 ) ! Local INTEGER :: iEl , iVar , i , j , iSide absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iSide = 1 , 6 DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N absMax ( iVar , iSide ) = MAX ( ABS ( scalar % boundary % hostData ( i , j , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Scalar3D FUNCTION Add_Scalar3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Scalar3D FUNCTION Subtract_Scalar3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Scalar3D ! -- Vector2D -- ! SUBROUTINE Init_Vector2D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 / ), & upBound = ( / 2 , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , N , nVar , 4 , nElem / )) END SUBROUTINE Init_Vector2D SUBROUTINE Free_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () END SUBROUTINE Free_Vector2D SUBROUTINE UpdateHost_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () #endif END SUBROUTINE UpdateHost_Vector2D SUBROUTINE UpdateDevice_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Vector2D SUBROUTINE BoundaryInterp_Vector2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Vector2D SUBROUTINE GridInterp_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Vector2D SUBROUTINE Gradient_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGradient_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGradient_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Vector2D SUBROUTINE Divergence_Vector2D ( SELFStorage , SELFOut , dForm , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDGDivergence_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDGDivergence_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDivergence_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDivergence_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END IF END SUBROUTINE Divergence_Vector2D SUBROUTINE Curl_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorCurl_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorCurl_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Curl_Vector2D SUBROUTINE Equals_Vector2D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFOut TYPE ( Vector2D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Vector2D FUNCTION AbsMaxInterior_Vector2D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector2D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar ) ! Local INTEGER :: iEl , iVar , i , j , iDir absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO j = 0 , vector % N DO i = 0 , vector % N DO iDir = 1 , 2 absMax ( iVar ) = MAX ( ABS ( vector % interior % hostData ( iDir , i , j , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Vector2D FUNCTION AbsMaxBoundary_Vector2D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector2D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar , 1 : 4 ) ! Local INTEGER :: iEl , iVar , i , iDir , iSide absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iSide = 1 , 4 DO iVar = 1 , vector % nVar DO i = 0 , vector % N DO iDir = 1 , 2 absMax ( iVar , iSide ) = MAX ( ABS ( vector % boundary % hostData ( iDir , i , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Vector2D FUNCTION Add_Vector2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Vector2D FUNCTION Subtract_Vector2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Vector2D ! -- Vector3D -- ! SUBROUTINE Init_Vector3D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / 3 , N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , N , N , nVar , 6 , nElem / )) END SUBROUTINE Init_Vector3D SUBROUTINE Free_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () END SUBROUTINE Free_Vector3D SUBROUTINE UpdateHost_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () #endif END SUBROUTINE UpdateHost_Vector3D SUBROUTINE UpdateDevice_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Vector3D SUBROUTINE BoundaryInterp_Vector3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Vector3D SUBROUTINE GridInterp_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Vector3D SUBROUTINE Gradient_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGradient_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGradient_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Vector3D SUBROUTINE Divergence_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDivergence_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDivergence_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Divergence_Vector3D SUBROUTINE Curl_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorCurl_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorCurl_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Curl_Vector3D FUNCTION AbsMaxInterior_Vector3D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector3D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar ) ! Local INTEGER :: iEl , iVar , i , j , k , iDir absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO k = 0 , vector % N DO j = 0 , vector % N DO i = 0 , vector % N DO iDir = 1 , 3 absMax ( iVar ) = MAX ( ABS ( vector % interior % hostData ( iDir , i , j , k , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Vector3D FUNCTION AbsMaxBoundary_Vector3D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector3D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar , 1 : 6 ) ! Local INTEGER :: iEl , iVar , i , j , iSide , iDir absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iSide = 1 , 6 DO iVar = 1 , vector % nVar DO j = 0 , vector % N DO i = 0 , vector % N DO iDir = 1 , 3 absMax ( iVar , iSide ) = MAX ( ABS ( vector % boundary % hostData ( iDir , i , j , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Vector3D SUBROUTINE Equals_Vector3D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFOut TYPE ( Vector3D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Vector3D FUNCTION Add_Vector3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Vector3D FUNCTION Subtract_Vector3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Vector3D ! -- Tensor2D -- ! SUBROUTINE Init_Tensor2D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , nVar , 4 , nElem / )) END SUBROUTINE Init_Tensor2D SUBROUTINE Free_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () END SUBROUTINE Free_Tensor2D SUBROUTINE UpdateHost_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () #endif END SUBROUTINE UpdateHost_Tensor2D SUBROUTINE UpdateDevice_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Tensor2D SUBROUTINE BoundaryInterp_Tensor2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Tensor2D SUBROUTINE GridInterp_Tensor2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Tensor2D SUBROUTINE Divergence_Tensor2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorDivergence_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorDivergence_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Divergence_Tensor2D SUBROUTINE Determinant_Tensor2D ( SELFStorage , SELFout , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"Determinant_Tensor2D\" IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL Determinant_Tensor2D_gpu_wrapper ( SELFStorage % interior % deviceData , & SELFOut % interior % deviceData , & SELFStorage % N , & SELFStorage % nVar , & SELFStorage % nElem ) #else msg = \"GPU Acceleration currently not enabled in SELF\" WARNING ( msg ) #endif ELSE DO iEl = 1 , SELFStorage % nElem DO iVar = 1 , SELFStorage % nVar DO j = 0 , SELFStorage % N DO i = 0 , SELFStorage % N SELFOut % interior % hostData ( i , j , iVar , iEl ) = SELFStorage % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) END DO END DO END DO END DO ENDIF END SUBROUTINE Determinant_Tensor2D FUNCTION AbsMaxInterior_Tensor2D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor2D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar ) ! Local INTEGER :: iEl , iVar , i , j , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 absMax ( iVar ) = MAX ( ABS ( tensor % interior % hostData ( row , col , i , j , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Tensor2D FUNCTION AbsMaxBoundary_Tensor2D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor2D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar , 1 : 4 ) ! Local INTEGER :: iEl , iVar , i , iSide , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iSide = 1 , 4 DO iVar = 1 , tensor % nVar DO i = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 absMax ( iVar , iSide ) = MAX ( ABS ( tensor % boundary % hostData ( row , col , i , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Tensor2D SUBROUTINE Equals_Tensor2D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFOut TYPE ( Tensor2D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Tensor2D FUNCTION Add_Tensor2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Tensor2D FUNCTION Subtract_Tensor2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Tensor2D ! -- Tensor3D -- ! SUBROUTINE Init_Tensor3D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , nVar , 6 , nElem / )) END SUBROUTINE Init_Tensor3D SUBROUTINE Free_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () END SUBROUTINE Free_Tensor3D SUBROUTINE UpdateHost_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () #endif END SUBROUTINE UpdateHost_Tensor3D SUBROUTINE UpdateDevice_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Tensor3D SUBROUTINE BoundaryInterp_Tensor3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Tensor3D SUBROUTINE GridInterp_Tensor3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Tensor3D SUBROUTINE Divergence_Tensor3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorDivergence_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorDivergence_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Divergence_Tensor3D SUBROUTINE Determinant_Tensor3D ( SELFStorage , SELFOut , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"Determinant_Tensor3D\" IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL Determinant_Tensor3D_gpu_wrapper ( SELFStorage % interior % deviceData , & SELFOut % interior % deviceData , & SELFStorage % N , & SELFStorage % nVar , & SELFStorage % nElem ) #else msg = \"GPU Acceleration currently not enabled in SELF\" WARNING ( msg ) #endif ELSE DO iEl = 1 , SELFStorage % nElem DO iVar = 1 , SELFStorage % nVar DO k = 0 , SELFStorage % N DO j = 0 , SELFStorage % N DO i = 0 , SELFStorage % N SELFOut % interior % hostData ( i , j , k , iVar , iEl ) = & SELFStorage % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl )) - & SELFStorage % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl )) + & SELFStorage % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl )) END DO END DO END DO END DO END DO ENDIF END SUBROUTINE Determinant_Tensor3D FUNCTION AbsMaxInterior_Tensor3D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor3D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar ) ! Local INTEGER :: iEl , iVar , i , j , k , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO k = 0 , tensor % N DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 absMax ( iVar ) = MAX ( ABS ( tensor % interior % hostData ( row , col , i , j , k , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Tensor3D FUNCTION AbsMaxBoundary_Tensor3D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor3D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar , 1 : 6 ) ! Local INTEGER :: iEl , iVar , i , j , iSide , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iSide = 1 , 6 DO iVar = 1 , tensor % nVar DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 absMax ( iVar , iSide ) = MAX ( ABS ( tensor % boundary % hostData ( row , col , i , j , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Tensor3D SUBROUTINE Equals_Tensor3D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFOut TYPE ( Tensor3D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Tensor3D FUNCTION Add_Tensor3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Tensor3D FUNCTION Subtract_Tensor3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Tensor3D END MODULE SELF_Data","tags":"","loc":"sourcefile/self_data.f90.html"},{"title":"SELF_Geometry.f90 – SELF","text":"This file depends on sourcefile~~self_geometry.f90~~EfferentGraph sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_geometry.f90->sourcefile~self_constants.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_geometry.f90~~AfferentGraph sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_tests.f90 SELF_Tests.f90 sourcefile~self_tests.f90->sourcefile~self_mappeddata.f90 sourcefile~self_mpilayer.f90 SELF_MPILayer.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mappeddata.f90 sourcefile~self.f90 SELF.f90 sourcefile~self.f90->sourcefile~self_tests.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Geometry Source Code SELF_Geometry.f90 Source Code MODULE SELF_Geometry USE SELF_Constants USE SELF_Lagrange USE SELF_Data USE SELF_SupportRoutines USE SELF_Mesh IMPLICIT NONE #include \"SELF_Macros.h\" TYPE , PUBLIC :: Geometry1D INTEGER :: cqType ! Control Quadrature Type INTEGER :: tqType ! Target Quadrature Type INTEGER :: nElem TYPE ( Scalar1D ) :: x ! Physical Positions TYPE ( Scalar1D ) :: dxds ! Conversion from computational to physical space CONTAINS PROCEDURE , PUBLIC :: Init => Init_Geometry1D PROCEDURE , PUBLIC :: Free => Free_Geometry1D PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_Geometry1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Geometry1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Geometry1D PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D END TYPE Geometry1D TYPE , PUBLIC :: SEMQuad INTEGER :: cqType ! Control Quadrature Type INTEGER :: tqType ! Target Quadrature Type INTEGER :: nElem TYPE ( Vector2D ) :: x ! Physical positions TYPE ( Tensor2D ) :: dxds ! Covariant basis vectors TYPE ( Tensor2D ) :: dsdx ! Contavariant basis vectors TYPE ( Scalar2D ) :: J ! Jacobian of the transformation CONTAINS PROCEDURE , PUBLIC :: Init => Init_SEMQuad PROCEDURE , PUBLIC :: Free => Free_SEMQuad PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_SEMQuad PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_SEMQuad PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_SEMQuad PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad PROCEDURE , PRIVATE :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad END TYPE SEMQuad TYPE , PUBLIC :: SEMHex INTEGER :: cqType ! Control Quadrature Type INTEGER :: tqType ! Target Quadrature Type INTEGER :: nElem TYPE ( Vector3D ) :: x ! Physical positions TYPE ( Tensor3D ) :: dxds ! Covariant basis vectors TYPE ( Tensor3D ) :: dsdx ! Contavariant basis vectors TYPE ( Scalar3D ) :: J ! Jacobian of the transformation CONTAINS PROCEDURE , PUBLIC :: Init => Init_SEMHex PROCEDURE , PUBLIC :: Free => Free_SEMHex PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_SEMHex PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_SEMHex PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_SEMHex PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_SEMHex PROCEDURE , PRIVATE :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex END TYPE SEMHex #ifdef GPU INTERFACE SUBROUTINE CalculateContravariantBasis_SEMQuad_gpu_wrapper ( dxds , dsdx , N , nEl ) & bind ( c , name = \"CalculateContravariantBasis_SEMQuad_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dxds , dsdx INTEGER , VALUE :: N , nEl END SUBROUTINE CalculateContravariantBasis_SEMQuad_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper ( dsdx , J , N , nEl ) & bind ( c , name = \"AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dsdx , J INTEGER , VALUE :: N , nEl END SUBROUTINE AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE CalculateContravariantBasis_SEMHex_gpu_wrapper ( dxds , dsdx , N , nEl ) & bind ( c , name = \"CalculateContravariantBasis_SEMHex_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dxds , dsdx INTEGER , VALUE :: N , nEl END SUBROUTINE CalculateContravariantBasis_SEMHex_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper ( dsdx , J , N , nEl ) & bind ( c , name = \"AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dsdx , J INTEGER , VALUE :: N , nEl END SUBROUTINE AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper END INTERFACE #endif CONTAINS SUBROUTINE Init_Geometry1D ( myGeom , cqType , tqType , cqDegree , tqDegree , nElem ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( out ) :: myGeom INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem myGeom % cqType = cqType myGeom % tqType = tqType myGeom % nElem = nElem CALL myGeom % x % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_Geometry1D SUBROUTINE Free_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () END SUBROUTINE Free_Geometry1D SUBROUTINE UpdateHost_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () #endif END SUBROUTINE UpdateHost_Geometry1D SUBROUTINE UpdateDevice_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Geometry1D SUBROUTINE GenerateFromMesh_Geometry1D ( myGeom , mesh , cqType , tqType , cqDegree , tqDegree ) ! Generates the geometry for a 1-D mesh ( set of line segments ) ! Assumes that mesh is using Gauss-Lobatto quadrature and the degree is given by mesh % nGeo IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( out ) :: myGeom TYPE ( Mesh1D ), INTENT ( in ) :: mesh INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree ! Local INTEGER :: iel , i , nid TYPE ( Scalar1D ) :: xMesh CALL myGeom % Init ( cqType , tqType , cqDegree , tqDegree , mesh % nElem ) ! Create a scalar1D class to map from nGeo,Gauss-Lobatto grid to ! cqDegree, cqType grid CALL xMesh % Init ( mesh % nGeo , GAUSS_LOBATTO , & cqDegree , cqType , & 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 DO iel = 1 , mesh % nElem DO i = 0 , mesh % nGeo xMesh % interior % hostData ( i , 1 , iel ) = mesh % nodeCoords % hostData ( nid ) nid = nid + 1 END DO END DO ! Interpolate from the mesh nodeCoords to the geometry (Possibly not gauss_lobatto quadrature) CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () CALL myGeom % UpdateDevice () CALL xMesh % Free () END SUBROUTINE GenerateFromMesh_Geometry1D SUBROUTINE CalculateMetricTerms_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % Derivative ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % UpdateDevice () END SUBROUTINE CalculateMetricTerms_Geometry1D SUBROUTINE Init_SEMQuad ( myGeom , cqType , tqType , cqDegree , tqDegree , nElem ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( out ) :: myGeom INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem myGeom % cqType = cqType myGeom % tqType = tqType myGeom % nElem = nElem CALL myGeom % x % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dsdx % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % J % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_SEMQuad SUBROUTINE Free_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () CALL myGeom % dsdx % Free () CALL myGeom % J % Free () END SUBROUTINE Free_SEMQuad SUBROUTINE UpdateHost_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () CALL myGeom % dsdx % UpdateHost () CALL myGeom % J % UpdateHost () #endif END SUBROUTINE UpdateHost_SEMQuad SUBROUTINE UpdateDevice_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () CALL myGeom % dsdx % UpdateDevice () CALL myGeom % J % UpdateDevice () #endif END SUBROUTINE UpdateDevice_SEMQuad SUBROUTINE GenerateFromMesh_SEMQuad ( myGeom , mesh , cqType , tqType , cqDegree , tqDegree ) ! Assumes that !  * mesh is using Gauss-Lobatto quadrature !  * the degree is given by mesh % nGeo !  * mesh only has quadrilateral elements ! IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( out ) :: myGeom TYPE ( Mesh2D ), INTENT ( in ) :: mesh INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree ! Local INTEGER :: iel , jel , elid INTEGER :: i , j , nid TYPE ( Vector2D ) :: xMesh CALL myGeom % Init ( cqType , tqType , cqDegree , tqDegree , mesh % nElem ) ! Create a scalar1D class to map from nGeo,Gauss-Lobatto grid to ! cqDegree, cqType grid CALL xMesh % Init ( mesh % nGeo , GAUSS_LOBATTO , & cqDegree , cqType , & 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 DO iel = 1 , mesh % nElem DO j = 0 , mesh % nGeo DO i = 0 , mesh % nGeo xMesh % interior % hostData ( 1 : 2 , i , j , 1 , iel ) = mesh % nodeCoords % hostData ( 1 : 2 , nid ) nid = nid + 1 END DO END DO END DO #ifdef GPU CALL xMesh % UpdateDevice () CALL xMesh % GridInterp ( myGeom % x ,. TRUE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . TRUE .) CALL myGeom % CalculateMetricTerms () CALL myGeom % UpdateHost () #else CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () #endif CALL xMesh % Free () END SUBROUTINE GenerateFromMesh_SEMQuad SUBROUTINE CalculateContravariantBasis_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom ! Local INTEGER :: iEl , i , j , k REAL ( prec ) :: fac #ifdef GPU CALL CalculateContravariantBasis_SEMQuad_gpu_wrapper ( myGeom % dxds % interior % deviceData , & myGeom % dsdx % interior % deviceData , & myGeom % dxds % N , & myGeom % dxds % nElem ) ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . TRUE .) CALL AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper ( myGeom % dsdx % boundary % deviceData , & myGeom % J % boundary % deviceData , & myGeom % J % N , & myGeom % J % nElem ) #else ! Now calculate the contravariant basis vectors ! In this convention, dsdx(j,i) is contravariant vector i, component j ! To project onto contravariant vector i, dot vector along the first dimension DO iEl = 1 , myGeom % nElem DO j = 0 , myGeom % dxds % N DO i = 0 , myGeom % dxds % N myGeom % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iEl ) = myGeom % dxds % interior % hostData ( 2 , 2 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iEl ) = - myGeom % dxds % interior % hostData ( 1 , 2 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iEl ) = - myGeom % dxds % interior % hostData ( 2 , 1 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iEl ) = myGeom % dxds % interior % hostData ( 1 , 1 , i , j , 1 , iEl ) END DO END DO END DO ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . FALSE .) ! Now, modify the sign of dsdx so that ! myGeom % dsdx % boundary is equal to the outward pointing normal vector DO iEl = 1 , myGeom % nElem DO k = 1 , 4 DO i = 0 , myGeom % J % N IF ( k == selfSide2D_East . OR . k == selfSide2D_North ) THEN fac = SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , 1 , k , iEl )) ELSE fac = - SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , 1 , k , iEl )) END IF myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 : 2 , i , 1 , k , iEl ) END DO END DO END DO #endif END SUBROUTINE CalculateContravariantBasis_SEMQuad SUBROUTINE CalculateMetricTerms_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . TRUE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . TRUE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . TRUE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . TRUE .) CALL myGeom % CalculateContravariantBasis () #else CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . FALSE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateContravariantBasis () #endif END SUBROUTINE CalculateMetricTerms_SEMQuad SUBROUTINE Init_SEMHex ( myGeom , cqType , tqType , cqDegree , tqDegree , nElem ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( out ) :: myGeom INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem myGeom % cqType = cqType myGeom % tqType = tqType myGeom % nElem = nElem CALL myGeom % x % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dsdx % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % J % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_SEMHex SUBROUTINE Free_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () CALL myGeom % dsdx % Free () CALL myGeom % J % Free () END SUBROUTINE Free_SEMHex SUBROUTINE UpdateHost_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () CALL myGeom % dsdx % UpdateHost () CALL myGeom % J % UpdateHost () #endif END SUBROUTINE UpdateHost_SEMHex SUBROUTINE UpdateDevice_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () CALL myGeom % dsdx % UpdateDevice () CALL myGeom % J % UpdateDevice () #endif END SUBROUTINE UpdateDevice_SEMHex SUBROUTINE GenerateFromMesh_SEMHex ( myGeom , mesh , cqType , tqType , cqDegree , tqDegree ) ! Assumes that !  * mesh is using Gauss-Lobatto quadrature !  * the degree is given by mesh % nGeo !  * mesh only has quadrilateral elements ! IMPLICIT NONE CLASS ( SEMHex ), INTENT ( out ) :: myGeom TYPE ( Mesh3D ), INTENT ( in ) :: mesh INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree ! Local INTEGER :: iel , jel , kel , elid INTEGER :: i , j , k , nid TYPE ( Vector3D ) :: xMesh CALL myGeom % Init ( cqType , tqType , cqDegree , tqDegree , mesh % nElem ) ! Create a scalar1D class to map from nGeo,Gauss-Lobatto grid to ! cqDegree, cqType grid CALL xMesh % Init ( mesh % nGeo , GAUSS_LOBATTO , & cqDegree , cqType , & 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 DO iel = 1 , mesh % nElem DO k = 0 , mesh % nGeo DO j = 0 , mesh % nGeo DO i = 0 , mesh % nGeo xMesh % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) = mesh % nodeCoords % hostData ( 1 : 3 , nid ) nid = nid + 1 END DO END DO END DO END DO ! Interpolate from the mesh nodeCoords to the geometry (Possibly not gauss_lobatto quadrature) CALL xMesh % UpdateDevice () #ifdef GPU CALL xMesh % GridInterp ( myGeom % x ,. TRUE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . TRUE .) CALL myGeom % CalculateMetricTerms () CALL myGeom % UpdateHost () #else CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () #endif CALL xMesh % Free () END SUBROUTINE GenerateFromMesh_SEMHex SUBROUTINE CalculateContravariantBasis_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom ! Local INTEGER :: iEl , i , j , k REAL ( prec ) :: fac #ifdef GPU CALL CalculateContravariantBasis_SEMHex_gpu_wrapper ( myGeom % dxds % interior % deviceData , & myGeom % dsdx % interior % deviceData , & myGeom % dxds % N , & myGeom % dxds % nElem ) ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . TRUE .) CALL AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper ( myGeom % dsdx % boundary % deviceData , & myGeom % J % boundary % deviceData , & myGeom % J % N , & myGeom % J % nElem ) #else ! Now calculate the contravariant basis vectors ! In this convention, dsdx(j,i) is contravariant vector i, component j ! To project onto contravariant vector i, dot vector along the first dimension DO iEl = 1 , myGeom % nElem DO k = 0 , myGeom % dxds % N DO j = 0 , myGeom % dxds % N DO i = 0 , myGeom % dxds % N ! Ja1 myGeom % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) ! Ja2 myGeom % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) ! Ja3 myGeom % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) END DO END DO END DO END DO ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . FALSE .) ! Now, modify the sign of dsdx so that ! myGeom % dsdx % boundary is equal to the outward pointing normal vector DO iEl = 1 , myGeom % nElem DO k = 1 , 6 DO j = 0 , myGeom % J % N DO i = 0 , myGeom % J % N IF ( k == selfSide3D_Top . OR . k == selfSide3D_East . OR . k == selfSide3D_North ) THEN fac = SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , j , 1 , k , iEl )) ELSE fac = - SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , j , 1 , k , iEl )) END IF myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , 1 , k , iEl ) END DO END DO END DO END DO #endif END SUBROUTINE CalculateContravariantBasis_SEMHex SUBROUTINE CalculateMetricTerms_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . TRUE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . TRUE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . TRUE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . TRUE .) CALL myGeom % CalculateContravariantBasis () #else CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . FALSE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateContravariantBasis () #endif END SUBROUTINE CalculateMetricTerms_SEMHex END MODULE SELF_Geometry","tags":"","loc":"sourcefile/self_geometry.f90.html"},{"title":"SELF_Lagrange.f90 – SELF","text":"This file depends on sourcefile~~self_lagrange.f90~~EfferentGraph sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_lagrange.f90~~AfferentGraph sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_tests.f90 SELF_Tests.f90 sourcefile~self_tests.f90->sourcefile~self_lagrange.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_tests.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_tests.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_tests.f90->sourcefile~self_mappeddata.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mpilayer.f90 SELF_MPILayer.f90 sourcefile~self_mpilayer.f90->sourcefile~self_data.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mesh.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mappeddata.f90 sourcefile~self.f90 SELF.f90 sourcefile~self.f90->sourcefile~self_tests.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Lagrange Source Code SELF_Lagrange.f90 Source Code ! SELF_Lagrange.f90 ! ! Copyright 2017-2021 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : support@fluidnumerics.com ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_Lagrange USE ISO_FORTRAN_ENV USE SELF_Constants USE SELF_Memory USE SELF_SupportRoutines USE SELF_Quadrature #ifdef GPU USE hipfort USE hipfort_check #endif USE ISO_C_BINDING IMPLICIT NONE TYPE , PUBLIC :: Lagrange !! A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions. !! The Lagrange data-structure stores the information necessary to interpolate between two !! sets of grid-points and to estimate the derivative of data at native grid points. Routines for !! multidimensional interpolation are based on the tensor product of 1-D interpolants. It is !! assumed that the polynomial degree (and the interpolation nodes) are the same in each direction. !! This assumption permits the storage of only one array of interpolation nodes and barycentric !! weights and is what allows this data structure to be flexible. INTEGER :: N !! The number of control points. INTEGER :: M !! The number of target points. TYPE ( hfReal_r1 ) :: controlPoints !! The set of nodes in one dimension where data is known. !! To create higher dimension interpolation and differentiation operators, structured grids in two and three !! dimensions are created by tensor products of the controlPoints. This design decision implies that all !! spectral element methods supported by the Lagrange class have the same polynomial degree in each !! computational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto, !! Legendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over !! the domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of !! these quadrature types or uniform points on [-1,1]. TYPE ( hfReal_r1 ) :: targetPoints !! The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation !! and differentiation operators, structured grids in two and three dimensions are created by tensor products of !! the targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1] !! (computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. TYPE ( hfReal_r1 ) :: bWeights !! The barycentric weights that are calculated from the controlPoints and used for interpolation. TYPE ( hfReal_r1 ) :: qWeights !! The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints !! provided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss, !! Chebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant !! dx = \\frac{2.0}{N+1}. TYPE ( hfReal_r2 ) :: iMatrix !! The interpolation matrix (transpose) for mapping data from the control grid to the target grid. TYPE ( hfReal_r2 ) :: dMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The !! dMatrix is based on a strong form of the derivative. TYPE ( hfReal_r2 ) :: dgMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based !! on a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. TYPE ( hfReal_r2 ) :: bMatrix !! The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. CONTAINS PROCEDURE , PUBLIC :: Init => Init_Lagrange PROCEDURE , PUBLIC :: Free => Free_Lagrange PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Lagrange PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Lagrange GENERIC , PUBLIC :: ScalarGridInterp_1D => ScalarGridInterp_1D_cpu , ScalarGridInterp_1D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_1D_cpu , ScalarGridInterp_1D_gpu GENERIC , PUBLIC :: ScalarGridInterp_2D => ScalarGridInterp_2D_cpu , ScalarGridInterp_2D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_2D_cpu , ScalarGridInterp_2D_gpu GENERIC , PUBLIC :: VectorGridInterp_2D => VectorGridInterp_2D_cpu , VectorGridInterp_2D_gpu PROCEDURE , PRIVATE :: VectorGridInterp_2D_cpu , VectorGridInterp_2D_gpu GENERIC , PUBLIC :: TensorGridInterp_2D => TensorGridInterp_2D_cpu , TensorGridInterp_2D_gpu PROCEDURE , PRIVATE :: TensorGridInterp_2D_cpu , TensorGridInterp_2D_gpu GENERIC , PUBLIC :: ScalarGridInterp_3D => ScalarGridInterp_3D_cpu , ScalarGridInterp_3D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_3D_cpu , ScalarGridInterp_3D_gpu GENERIC , PUBLIC :: VectorGridInterp_3D => VectorGridInterp_3D_cpu , VectorGridInterp_3D_gpu PROCEDURE , PRIVATE :: VectorGridInterp_3D_cpu , VectorGridInterp_3D_gpu GENERIC , PUBLIC :: TensorGridInterp_3D => TensorGridInterp_3D_cpu , TensorGridInterp_3D_gpu PROCEDURE , PRIVATE :: TensorGridInterp_3D_cpu , TensorGridInterp_3D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_1D => ScalarBoundaryInterp_1D_cpu , ScalarBoundaryInterp_1D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_1D_cpu , ScalarBoundaryInterp_1D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_2D => ScalarBoundaryInterp_2D_cpu , ScalarBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_2D_cpu , ScalarBoundaryInterp_2D_gpu GENERIC , PUBLIC :: VectorBoundaryInterp_2D => VectorBoundaryInterp_2D_cpu , VectorBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: VectorBoundaryInterp_2D_cpu , VectorBoundaryInterp_2D_gpu GENERIC , PUBLIC :: TensorBoundaryInterp_2D => TensorBoundaryInterp_2D_cpu , TensorBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: TensorBoundaryInterp_2D_cpu , TensorBoundaryInterp_2D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_3D => ScalarBoundaryInterp_3D_cpu , ScalarBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_3D_cpu , ScalarBoundaryInterp_3D_gpu GENERIC , PUBLIC :: VectorBoundaryInterp_3D => VectorBoundaryInterp_3D_cpu , VectorBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: VectorBoundaryInterp_3D_cpu , VectorBoundaryInterp_3D_gpu GENERIC , PUBLIC :: TensorBoundaryInterp_3D => TensorBoundaryInterp_3D_cpu , TensorBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: TensorBoundaryInterp_3D_cpu , TensorBoundaryInterp_3D_gpu GENERIC , PUBLIC :: Derivative_1D => Derivative_1D_cpu , Derivative_1D_gpu PROCEDURE , PRIVATE :: Derivative_1D_cpu , Derivative_1D_gpu GENERIC , PUBLIC :: DGDerivative_1D => DGDerivative_1D_cpu , DGDerivative_1D_gpu PROCEDURE , PRIVATE :: DGDerivative_1D_cpu , DGDerivative_1D_gpu GENERIC , PUBLIC :: ScalarGradient_2D => ScalarGradient_2D_cpu , ScalarGradient_2D_gpu PROCEDURE , PRIVATE :: ScalarGradient_2D_cpu , ScalarGradient_2D_gpu GENERIC , PUBLIC :: ScalarDGGradient_2D => ScalarDGGradient_2D_cpu , ScalarDGGradient_2D_gpu PROCEDURE , PRIVATE :: ScalarDGGradient_2D_cpu , ScalarDGGradient_2D_gpu GENERIC , PUBLIC :: VectorGradient_2D => VectorGradient_2D_cpu , VectorGradient_2D_gpu PROCEDURE , PRIVATE :: VectorGradient_2D_cpu , VectorGradient_2D_gpu GENERIC , PUBLIC :: VectorDGGradient_2D => VectorDGGradient_2D_cpu , VectorDGGradient_2D_gpu PROCEDURE , PRIVATE :: VectorDGGradient_2D_cpu , VectorDGGradient_2D_gpu GENERIC , PUBLIC :: VectorDivergence_2D => VectorDivergence_2D_cpu , VectorDivergence_2D_gpu PROCEDURE , PRIVATE :: VectorDivergence_2D_cpu , VectorDivergence_2D_gpu GENERIC , PUBLIC :: VectorDGDivergence_2D => VectorDGDivergence_2D_cpu , VectorDGDivergence_2D_gpu PROCEDURE , PRIVATE :: VectorDGDivergence_2D_cpu , VectorDGDivergence_2D_gpu GENERIC , PUBLIC :: VectorCurl_2D => VectorCurl_2D_cpu , VectorCurl_2D_gpu PROCEDURE , PRIVATE :: VectorCurl_2D_cpu , VectorCurl_2D_gpu GENERIC , PUBLIC :: TensorDivergence_2D => TensorDivergence_2D_cpu , TensorDivergence_2D_gpu PROCEDURE , PRIVATE :: TensorDivergence_2D_cpu , TensorDivergence_2D_gpu GENERIC , PUBLIC :: TensorDGDivergence_2D => TensorDGDivergence_2D_cpu , TensorDGDivergence_2D_gpu PROCEDURE , PRIVATE :: TensorDGDivergence_2D_cpu , TensorDGDivergence_2D_gpu GENERIC , PUBLIC :: ScalarGradient_3D => ScalarGradient_3D_cpu , ScalarGradient_3D_gpu PROCEDURE , PRIVATE :: ScalarGradient_3D_cpu , ScalarGradient_3D_gpu GENERIC , PUBLIC :: VectorGradient_3D => VectorGradient_3D_cpu , VectorGradient_3D_gpu PROCEDURE , PRIVATE :: VectorGradient_3D_cpu , VectorGradient_3D_gpu GENERIC , PUBLIC :: VectorDivergence_3D => VectorDivergence_3D_cpu , VectorDivergence_3D_gpu PROCEDURE , PRIVATE :: VectorDivergence_3D_cpu , VectorDivergence_3D_gpu GENERIC , PUBLIC :: VectorDGDivergence_3D => VectorDGDivergence_3D_cpu , VectorDGDivergence_3D_gpu PROCEDURE , PRIVATE :: VectorDGDivergence_3D_cpu , VectorDGDivergence_3D_gpu GENERIC , PUBLIC :: VectorCurl_3D => VectorCurl_3D_cpu , VectorCurl_3D_gpu PROCEDURE , PRIVATE :: VectorCurl_3D_cpu , VectorCurl_3D_gpu GENERIC , PUBLIC :: TensorDivergence_3D => TensorDivergence_3D_cpu , TensorDivergence_3D_gpu PROCEDURE , PRIVATE :: TensorDivergence_3D_cpu , TensorDivergence_3D_gpu GENERIC , PUBLIC :: TensorDGDivergence_3D => TensorDGDivergence_3D_cpu , TensorDGDivergence_3D_gpu PROCEDURE , PRIVATE :: TensorDGDivergence_3D_cpu , TensorDGDivergence_3D_gpu PROCEDURE , PRIVATE :: CalculateBarycentricWeights PROCEDURE , PRIVATE :: CalculateInterpolationMatrix PROCEDURE , PRIVATE :: CalculateDerivativeMatrix PROCEDURE , PRIVATE :: CalculateLagrangePolynomials END TYPE Lagrange #ifdef GPU INTERFACE SUBROUTINE ScalarGridInterp_1D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"ScalarGridInterp_1D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER , VALUE :: N , M , nVar , nEl END SUBROUTINE ScalarGridInterp_1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarGridInterp_2D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"ScalarGridInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER , VALUE :: N , M , nVar , nEl END SUBROUTINE ScalarGridInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorGridInterp_2D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"VectorGridInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER , VALUE :: N , M , nVar , nEl END SUBROUTINE VectorGridInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorGridInterp_2D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"TensorGridInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER , VALUE :: N , M , nVar , nEl END SUBROUTINE TensorGridInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarGridInterp_3D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"ScalarGridInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER , VALUE :: N , M , nVar , nEl END SUBROUTINE ScalarGridInterp_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorGridInterp_3D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"VectorGridInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER , VALUE :: N , M , nVar , nEl END SUBROUTINE VectorGridInterp_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorGridInterp_3D_gpu_wrapper ( iMatrixT_dev , f_dev , fInterp_dev , N , M , nVar , nEl ) & bind ( c , name = \"TensorGridInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: iMatrixT_dev , f_dev , fInterp_dev INTEGER , VALUE :: N , M , nVar , nEl END SUBROUTINE TensorGridInterp_3D_gpu_wrapper END INTERFACE ! /////////////// ! ! Boundary Interpolation Routines INTERFACE SUBROUTINE ScalarBoundaryInterp_1D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarBoundaryInterp_1D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE ScalarBoundaryInterp_1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarBoundaryInterp_2D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarBoundaryInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE ScalarBoundaryInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorBoundaryInterp_2D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"VectorBoundaryInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE VectorBoundaryInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorBoundaryInterp_2D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"TensorBoundaryInterp_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE TensorBoundaryInterp_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarBoundaryInterp_3D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarBoundaryInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE ScalarBoundaryInterp_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorBoundaryInterp_3D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"VectorBoundaryInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE VectorBoundaryInterp_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorBoundaryInterp_3D_gpu_wrapper ( bMatrix_dev , f_dev , fBound_dev , N , nVar , nEl ) & bind ( c , name = \"TensorBoundaryInterp_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: bMatrix_dev , f_dev , fBound_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE TensorBoundaryInterp_3D_gpu_wrapper END INTERFACE ! /////////////// ! INTERFACE SUBROUTINE Derivative_1D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"Derivative_1D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE Derivative_1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE DGDerivative_1D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"DGDerivative_1D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE DGDerivative_1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarGradient_2D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarGradient_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE ScalarGradient_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarDGGradient_2D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarDGGradient_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE ScalarDGGradient_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorGradient_2D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorGradient_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE VectorGradient_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorDGGradient_2D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorDGGradient_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE VectorDGGradient_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorDivergence_2D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorDivergence_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE VectorDivergence_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorDGDivergence_2D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorDGDivergence_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE VectorDGDivergence_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorCurl_2D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorCurl_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE VectorCurl_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorDivergence_2D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"TensorDivergence_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE TensorDivergence_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorDGDivergence_2D_gpu_wrapper ( dMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"TensorDGDivergence_2D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE TensorDGDivergence_2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ScalarGradient_3D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"ScalarGradient_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE ScalarGradient_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorGradient_3D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorGradient_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE VectorGradient_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorDivergence_3D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorDivergence_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE VectorDivergence_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorDGDivergence_3D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorDGDivergence_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE VectorDGDivergence_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE VectorCurl_3D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"VectorCurl_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE VectorCurl_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorDivergence_3D_gpu_wrapper ( dMatrixT_dev , f_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"TensorDivergence_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dMatrixT_dev , f_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE TensorDivergence_3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE TensorDGDivergence_3D_gpu_wrapper ( dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev , N , nVar , nEl ) & bind ( c , name = \"TensorDGDivergence_3D_gpu_wrapper\" ) USE iso_c_binding IMPLICIT NONE TYPE ( c_ptr ) :: dgMatrixT_dev , bMatrix_dev , qWeights_dev , f_dev , bf_dev , df_dev INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE TensorDGDivergence_3D_gpu_wrapper END INTERFACE #endif CONTAINS ! ================================================================================================ ! ! ! Init_Lagrange ! !   A manual constructor for the Lagrange class that allocates memory and fills in data !   for the attributes of the Lagrange class. ! !   The Init subroutine allocates memory for the interpolation and target points, barycentric !   weights, interpolation matrix, and derivative matrix. ! !   Usage : ! !     TYPE(Lagrange) :: interp !     INTEGER        :: N, M !     REAL(prec)     :: interpNodes(0:N), targetNodes(0:M+1) ! !     CALL interp % Init( N, M, interpNodes, targetNodes ) ! !   Input/Output : ! !     myPoly  (out) !       The Lagrange data structure to be constructed ! !     N (in) !       The degree of the polynomial interpolant ! !     M (in) !       M+1 is the number of target grid points. The upper bound of the targetNodes array ! !     interpNodes(0:N) (in) !       The interpolation nodes. ! !     targetNodes(0:M) (in) !       The target nodes. The iMatrix will map the a function at the interpolation !       nodes onto the target nodes. ! ! =============================================================================================== ! SUBROUTINE Init_Lagrange ( myPoly , N , controlNodeType , M , targetNodeType ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( out ) :: myPoly INTEGER , INTENT ( in ) :: N , M INTEGER , INTENT ( in ) :: controlNodeType , targetNodeType ! Local REAL ( prec ) :: q ( 0 : M ) myPoly % N = N myPoly % M = M CALL myPoly % controlPoints % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % targetPoints % Alloc ( loBound = 0 , & upBound = M ) CALL myPoly % bWeights % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % qWeights % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % iMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , M / )) CALL myPoly % dMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , N / )) CALL myPoly % dgMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , N / )) CALL myPoly % bMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , 1 / )) IF ( controlNodeType == GAUSS . OR . controlNodeType == GAUSS_LOBATTO ) THEN CALL LegendreQuadrature ( N , & myPoly % controlPoints % hostData , & myPoly % qWeights % hostData , & controlNodeType ) ELSEIF ( controlNodeType == UNIFORM ) THEN myPoly % controlPoints % hostData = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , N ) myPoly % qWeights % hostData = 2.0_prec / REAL ( N , prec ) END IF ! Target Points IF ( targetNodeType == GAUSS . OR . targetNodeType == GAUSS_LOBATTO ) THEN CALL LegendreQuadrature ( M , & myPoly % targetPoints % hostData , & q , & targetNodeType ) ELSEIF ( targetNodeType == UNIFORM ) THEN myPoly % targetPoints % hostData = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , M ) END IF CALL myPoly % CalculateBarycentricWeights () CALL myPoly % CalculateInterpolationMatrix () CALL myPoly % CalculateDerivativeMatrix () myPoly % bMatrix % hostData ( 0 : N , 0 ) = myPoly % CalculateLagrangePolynomials ( - 1.0_prec ) myPoly % bMatrix % hostData ( 0 : N , 1 ) = myPoly % CalculateLagrangePolynomials ( 1.0_prec ) CALL myPoly % UpdateDevice () END SUBROUTINE Init_Lagrange ! ================================================================================================ ! ! ! Free_Lagrange ! !   A manual destructor for the Lagrange class that deallocates the memory held by its attributes. ! ! ================================================================================================ ! SUBROUTINE Free_Lagrange ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly CALL myPoly % controlPoints % Free () CALL myPoly % targetPoints % Free () CALL myPoly % bWeights % Free () CALL myPoly % qWeights % Free () CALL myPoly % iMatrix % Free () CALL myPoly % dMatrix % Free () CALL myPoly % dgMatrix % Free () CALL myPoly % bMatrix % Free () END SUBROUTINE Free_Lagrange SUBROUTINE UpdateDevice_Lagrange ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly #ifdef GPU CALL myPoly % controlPoints % UpdateDevice () CALL myPoly % targetPoints % UpdateDevice () CALL myPoly % bWeights % UpdateDevice () CALL myPoly % qWeights % UpdateDevice () CALL myPoly % iMatrix % UpdateDevice () CALL myPoly % dMatrix % UpdateDevice () CALL myPoly % dgMatrix % UpdateDevice () CALL myPoly % bMatrix % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Lagrange SUBROUTINE UpdateHost_Lagrange ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly #ifdef GPU CALL myPoly % controlPoints % UpdateHost () CALL myPoly % targetPoints % UpdateHost () CALL myPoly % bWeights % UpdateHost () CALL myPoly % qWeights % UpdateHost () CALL myPoly % iMatrix % UpdateHost () CALL myPoly % dMatrix % UpdateHost () CALL myPoly % dgMatrix % UpdateHost () CALL myPoly % bMatrix % UpdateHost () #endif END SUBROUTINE UpdateHost_Lagrange ! ================================================================================================ ! ! ! ScalarGridInterp_1D ! !   Interpolates an array of nodal values at the native nodes to nodal values at the target nodes. ! !   We can write the operations of interpolating data from one set of points to another (in this !   case from \"controlPoints\" to \"targetPoints\") as ! !              fnew_a = \\sum_{i=0}&#94;N f_i l_i(\\xi_a),   a=0,1,2,...,M ! !   where l_i(\\xi) are the Lagrange interpolating polynomials through the interpolation points. !   The interpolation matrix is T_{a,i} = l_i(\\xi_a) maps an array of nodal values from the native !   interpolation nodes to the target nodes. This routine serves as a wrapper to call either the CUDA !   kernel (if CUDA is enabled) or the CPU version. ! !   Usage : ! !     TYPE(Lagrange) :: interp !     INTEGER        :: nVariables, nElements !     REAL(prec)     :: f(0:interp % N,1:nVariables,1:nElements) !     REAL(prec)     :: fNew(0:interp % M,1:nVariables,1:nElements) ! !       CALL interp % GridInterpolation_1D( fnative, fNew, nVariables, nElements ) ! !     * If CUDA is enabled, the fnative and ftarget arrays must be CUDA device variables. ! !   Parameters : ! !     interp (in) !       A previously constructed Lagrange data-structure. ! !     f (in) !       Array of function nodal values at the native interpolation nodes. ! !     nVariables (in) ! !     nElements (in) ! !     fNew (out) !      Array of function nodal values at the target interpolation nodes. ! ! ================================================================================================ ! SUBROUTINE ScalarGridInterp_1D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iVar , iEl , i , ii DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % M fInterp ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N fInterp ( i , iVar , iEl ) = fInterp ( i , iVar , iEl ) + myPoly % iMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_1D_cpu SUBROUTINE ScalarGridInterp_1D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev #ifdef GPU CALL ScalarGridInterp_1D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) #endif END SUBROUTINE ScalarGridInterp_1D_gpu ! ================================================================================================ ! ! ! ScalarGridInterp_2D ! !   Interpolates an array of nodal values at the native nodes to nodal values at the target nodes. ! !   We can write the operations of interpolating data from one set of points to another (in this !   case from \"controlPoints\" to \"targetPoints\") as ! !              fnew_{a,b} = \\sum_{i,j=0}&#94;N f_{i,j} l_i(\\xi_a) l_j(\\xi_b),   a,b=0,1,2,...,M ! !   where l_i(\\xi) are the Lagrange interpolating polynomials through the interpolation points. !   The interpolation matrix is T_{a,i} = l_i(\\xi_a) maps an array of nodal values from the native !   interpolation nodes to the target nodes. This routine serves as a wrapper to call either the CUDA !   kernel (if CUDA is enabled) or the CPU version. ! !   Usage : ! !     TYPE(Lagrange) :: interp !     INTEGER        :: nVariables, nElements !     REAL(prec)     :: f(0:interp % N,0:interp % N,1:nVariables,1:nElements) !     REAL(prec)     :: fNew(0:interp % M,0:interp % M,1:nVariables,1:nElements) ! !       CALL interp % GridInterpolation_2D( fnative, fNew, nVariables, nElements ) ! !     * If CUDA is enabled, the fnative and ftarget arrays must be CUDA device variables. ! !   Parameters : ! !     interp (in) !       A previously constructed Lagrange data-structure. ! !     f (in) !       Array of function nodal values at the native interpolation nodes. ! !     nVariables (in) ! !     nElements (in) ! !     fNew (out) !      Array of function nodal values at the target interpolation nodes. ! ! ================================================================================================ ! SUBROUTINE ScalarGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fNew ( 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , jj , p , iEl , iVar REAL ( prec ) :: fi , fij DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fij = 0.0_prec DO jj = 0 , myPoly % N fi = 0.0_prec DO ii = 0 , myPoly % N fi = fi + f ( ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij = fij + fi * myPoly % iMatrix % hostData ( jj , j ) END DO fNew ( i , j , iVar , iEl ) = fij END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_2D_cpu ! SUBROUTINE ScalarGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev #ifdef GPU CALL ScalarGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) #endif END SUBROUTINE ScalarGridInterp_2D_gpu SUBROUTINE VectorGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fNew ( 1 : 2 , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , jj , p , iEl , iVar REAL ( prec ) :: fi ( 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fNew ( 1 , i , j , iVar , iEl ) = 0.0_prec fNew ( 2 , i , j , iVar , iEl ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 2 ) = fi ( 1 : 2 ) + f ( 1 : 2 , ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fNew ( 1 : 2 , i , j , iVar , iEl ) = fNew ( 1 : 2 , i , j , iVar , iEl ) + fi ( 1 : 2 ) * myPoly % iMatrix % hostData ( jj , j ) END DO END DO END DO END DO END DO END SUBROUTINE VectorGridInterp_2D_cpu ! SUBROUTINE VectorGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev #ifdef GPU CALL VectorGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) #endif END SUBROUTINE VectorGridInterp_2D_gpu SUBROUTINE TensorGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fNew ( 1 : 2 , 1 : 2 , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , jj , p , iEl , iVar REAL ( prec ) :: fi ( 1 : 2 , 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fNew ( 1 : 2 , 1 : 2 , i , j , iVar , iEl ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 2 , 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 2 , 1 : 2 ) = fi ( 1 : 2 , 1 : 2 ) + f ( 1 : 2 , 1 : 2 , ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fNew ( 1 : 2 , 1 : 2 , i , j , iVar , iEl ) = fNew ( 1 : 2 , 1 : 2 , i , j , iVar , iEl ) + fi ( 1 : 2 , 1 : 2 ) * myPoly % iMatrix % hostData ( jj , j ) END DO END DO END DO END DO END DO END SUBROUTINE TensorGridInterp_2D_cpu ! SUBROUTINE TensorGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev #ifdef GPU CALL TensorGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) #endif END SUBROUTINE TensorGridInterp_2D_gpu ! ================================================================================================ ! ! ! GridInterpolate_3D ! !   Interpolates an array of nodal values at the native nodes to nodal values at the target nodes. ! !   We can write the operations of interpolating data from one set of points to another (in this !   case from \"controlPoints\" to \"targetPoints\") as ! !   fnew_{a,b,c} = \\sum_{i,j,k=0}&#94;N f_{i,j,k} l_i(\\xi_a) l_j(\\xi_b) l_k(\\xi_c),   a,b,c=0,1,2,...,M ! !   where l_i(\\xi) are the Lagrange interpolating polynomials through the interpolation points. !   The interpolation matrix is T_{a,i} = l_i(\\xi_a) maps an array of nodal values from the native !   interpolation nodes to the target nodes. This routine serves as a wrapper to call either the CUDA !   kernel (if CUDA is enabled) or the CPU version. ! !   Usage : ! !     TYPE(Lagrange) :: interp !     INTEGER        :: nVariables, nElements !     REAL(prec)     :: f(0:interp % N,0:interp % N,0:interp % N,1:nVariables,1:nElements) !     REAL(prec)     :: fNew(0:interp % M,0:interp % M,0:interp % M,1:nVariables,1:nElements) ! !       CALL interp % GridInterpolation_3D( fnative, fNew, nVariables, nElements ) ! !     * If CUDA is enabled, the fnative and ftarget arrays must be CUDA device variables. ! !   Parameters : ! !     interp (in) !       A previously constructed Lagrange data-structure. ! !     f (in) !       Array of function nodal values at the native interpolation nodes. ! !     nVariables (in) ! !     nElements (in) ! !     fNew (out) !      Array of function nodal values at the target interpolation nodes. ! ! ================================================================================================ ! SUBROUTINE ScalarGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi , fij , fijk DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fijk = 0.0_prec DO kk = 0 , myPoly % N fij = 0.0_prec DO jj = 0 , myPoly % N fi = 0.0_prec DO ii = 0 , myPoly % N fi = fi + f ( ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij = fij + fi * myPoly % iMatrix % hostData ( jj , j ) END DO fijk = fijk + fij * myPoly % iMatrix % hostData ( kk , k ) END DO fInterp ( i , j , k , iVar , iEl ) = fijk END DO END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_3D_cpu ! SUBROUTINE ScalarGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev #ifdef GPU CALL ScalarGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) #endif END SUBROUTINE ScalarGridInterp_3D_gpu SUBROUTINE VectorGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 1 : 3 , 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi ( 1 : 3 ), fij ( 1 : 3 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fInterp ( 1 : 3 , i , j , k , iVar , iEl ) = 0.0_prec DO kk = 0 , myPoly % N fij ( 1 : 3 ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 3 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 3 ) = fi ( 1 : 3 ) + f ( 1 : 3 , ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij ( 1 : 3 ) = fij ( 1 : 3 ) + fi ( 1 : 3 ) * myPoly % iMatrix % hostData ( jj , j ) END DO fInterp ( 1 : 3 , i , j , k , iVar , iEl ) = fInterp ( 1 : 3 , i , j , k , iVar , iEl ) + fij ( 1 : 3 ) * myPoly % iMatrix % hostData ( kk , k ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorGridInterp_3D_cpu ! SUBROUTINE VectorGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev #ifdef GPU CALL VectorGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) #endif END SUBROUTINE VectorGridInterp_3D_gpu SUBROUTINE TensorGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 1 : 3 , 1 : 3 , 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi ( 1 : 3 , 1 : 3 ), fij ( 1 : 3 , 1 : 3 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fInterp ( 1 : 3 , 1 : 3 , i , j , k , iVar , iEl ) = 0.0_prec DO kk = 0 , myPoly % N fij ( 1 : 3 , 1 : 3 ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 3 , 1 : 3 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 3 , 1 : 3 ) = fi ( 1 : 3 , 1 : 3 ) + f ( 1 : 3 , 1 : 3 , ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij ( 1 : 3 , 1 : 3 ) = fij ( 1 : 3 , 1 : 3 ) + fi ( 1 : 3 , 1 : 3 ) * myPoly % iMatrix % hostData ( jj , j ) END DO fInterp ( 1 : 3 , 1 : 3 , i , j , k , iVar , iEl ) = fInterp ( 1 : 3 , 1 : 3 , i , j , k , iVar , iEl ) + & fij ( 1 : 3 , 1 : 3 ) * myPoly % iMatrix % hostData ( kk , k ) END DO END DO END DO END DO END DO END DO END SUBROUTINE TensorGridInterp_3D_cpu ! SUBROUTINE TensorGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev #ifdef GPU CALL TensorGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) #endif END SUBROUTINE TensorGridInterp_3D_gpu ! ================================================================================================ ! ! ! Derivative_1D ! !   Calculates the derivative of the Lagrange interpolant given a set of nodal function values at !   the native interpolation nodes ! !   Given a set of nodal values at the interpolation nodes, the derivative of a function through !   the interpolation nodes can be estimated by ! !                       f'_a = \\sum_{i=0}&#94;N f_{i} l'_i(\\xi_a),   a=0,1,2,...,N ! !   where l_i(\\xi) are the Lagrange interpolating polynomials through the interpolation points. !   The derivative matrix is D_{a,i} = l'_i(\\xi_a) maps an array of nodal values at the interpolation !   nodes to its estimated derivative. This routine serves as a wrapper to call either the CUDA !   kernel (if CUDA is enabled) or the CPU version. ! !   Usage : ! !     TYPE(Lagrange) :: interp !     INTEGER        :: nVariables, nElements !     REAL(prec)     :: f(0:interp % N,1:nVariables,1:nElements) !     REAL(prec)     :: derF(0:interp % N,1:nVariables,1:nElements) ! !       CALL interp % Derivative_1D( f, derF, nVariables, nElements ) ! !     * If CUDA is enabled, the fnative and ftarget arrays must be CUDA device variables. ! !   Parameters : ! !     interp (in) !       A previously constructed Lagrange data-structure. ! !     f (in) !       Array of function nodal values at the native interpolation nodes. ! !     nVariables (in) ! !     nElements (in) ! !     derF (out) !      Array of derivative values at the target interpolation nodes. ! ! ================================================================================================ ! SUBROUTINE Derivative_1D_cpu ( myPoly , f , df , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: df ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N df ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO END DO END DO END DO END SUBROUTINE Derivative_1D_cpu SUBROUTINE Derivative_1D_gpu ( myPoly , f_dev , df_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: df_dev #ifdef GPU CALL Derivative_1D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , df_dev , & myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE Derivative_1D_gpu SUBROUTINE DGDerivative_1D_cpu ( myPoly , f , bf , df , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : nVariables , 1 : 2 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: df ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N ! Interior Derivative Matrix Application df ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO ! Boundary Contribution df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + ( bf ( iVar , 2 , iEl ) * myPoly % bMatrix % hostData ( i , 1 ) - & bf ( iVar , 1 , iEl ) * myPoly % bMatrix % hostData ( i , 0 )) / & myPoly % qWeights % hostData ( i ) END DO END DO END DO END SUBROUTINE DGDerivative_1D_cpu SUBROUTINE DGDerivative_1D_gpu ( myPoly , f_dev , bf_dev , df_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: df_dev #ifdef GPU CALL DGDerivative_1D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bf_dev , df_dev , & myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE DGDerivative_1D_gpu ! ================================================================================================ ! ! ! CalculateGradient_2D ! !   Calculates the gradient of a 2-D function, represented by a 2-D array of nodal values. ! !   Given a set of nodal values at the interpolation nodes, the gradient of a function through !   the interpolation nodes can be estimated by ! !                       (df/dx)_{a,b} = \\sum_{i=0}&#94;N f_{i,b} l'_i(\\xi_a),   a,b=0,1,2,...,N !                       (df/dy)_{a,b} = \\sum_{j=0}&#94;N f_{a,j} l'_j(\\xi_b),   a,b=0,1,2,...,N ! !   where l_i(\\xi) are the Lagrange interpolating polynomials through the interpolation points. !   The derivative matrix is D_{a,i} = l'_i(\\xi_a) maps an array of nodal values at the interpolation !   nodes to its estimated derivative. This routine serves as a wrapper to call either the CUDA !   kernel (if CUDA is enabled) or the CPU version. ! !   Usage : ! !     TYPE(Lagrange) :: interp !     INTEGER        :: nVariables, nElements !     REAL(prec)     :: f(0:interp % N,0:interp % N,1:nVariables,1:nElements) !     REAL(prec)     :: gradF(1:2,0:interp % N,0:interp % N,1:nVariables,1:nElements) ! !       CALL interp % CalculateGradient_2D( f, gradF, nVariables, nElements ) ! !     * If CUDA is enabled, the fnative and ftarget arrays must be CUDA device variables. ! !   Parameters : ! !     interp (in) !       A previously constructed Lagrange data-structure. ! !     f (in) !       Array of function nodal values at the native interpolation nodes. ! !     nVariables (in) ! !     nElements (in) ! !     gradF (out) !      Array of derivative values at the target interpolation nodes. ! ! ================================================================================================ ! ! SUBROUTINE ScalarGradient_2D_cpu ( myPoly , f , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = gradF ( 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , j , iVar , iEl ) gradF ( 2 , i , j , iVar , iEl ) = gradF ( 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE ScalarGradient_2D_cpu SUBROUTINE ScalarGradient_2D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL ScalarGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE ScalarGradient_2D_gpu ! ! SUBROUTINE ScalarDGGradient_2D_cpu ( myPoly , f , bf , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = gradF ( 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( ii , j , iVar , iEl ) gradF ( 2 , i , j , iVar , iEl ) = gradF ( 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , j ) * f ( i , ii , iVar , iEl ) END DO ! Boundary Contribution gradF ( 1 , i , j , iVar , iEl ) = gradF ( 1 , i , j , iVar , iEl ) + ( bf ( j , iVar , 2 , iEl ) * myPoly % bMatrix % hostData ( i , 1 ) + & bf ( j , iVar , 4 , iEl ) * myPoly % bMatrix % hostData ( i , 0 )) / & myPoly % qWeights % hostData ( i ) gradF ( 2 , i , j , iVar , iEl ) = gradF ( 2 , i , j , iVar , iEl ) + ( bf ( i , iVar , 3 , iEl ) * myPoly % bMatrix % hostData ( j , 1 ) + & bf ( i , iVar , 1 , iEl ) * myPoly % bMatrix % hostData ( j , 0 )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE ScalarDGGradient_2D_cpu SUBROUTINE ScalarDGGradient_2D_gpu ( myPoly , f_dev , bf_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL ScalarDGGradient_2D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bf_dev , gradF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE ScalarDGGradient_2D_gpu SUBROUTINE VectorGradient_2D_cpu ( myPoly , f , gradF , nVariables , nElements ) ! ! Input : Vector(1:2,...) ! Output : Tensor(1:2,1:2,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 1 , 2 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = gradF ( 1 , 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) gradF ( 2 , 1 , i , j , iVar , iEl ) = gradF ( 2 , 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , iVar , iEl ) gradF ( 1 , 2 , i , j , iVar , iEl ) = gradF ( 1 , 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , iVar , iEl ) gradF ( 2 , 2 , i , j , iVar , iEl ) = gradF ( 2 , 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE VectorGradient_2D_cpu SUBROUTINE VectorGradient_2D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorGradient_2D_gpu SUBROUTINE VectorDGGradient_2D_cpu ( myPoly , f , bf , gradF , nVariables , nElements ) ! ! Input : Vector(1:2,...) ! Output : Tensor(1:2,1:2,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 1 , 2 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = gradF ( 1 , 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) gradF ( 2 , 1 , i , j , iVar , iEl ) = gradF ( 2 , 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 2 , ii , j , iVar , iEl ) gradF ( 1 , 2 , i , j , iVar , iEl ) = gradF ( 1 , 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , j ) * f ( 1 , i , ii , iVar , iEl ) gradF ( 2 , 2 , i , j , iVar , iEl ) = gradF ( 2 , 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO gradF ( 1 , 1 , i , j , iVar , iEl ) = gradF ( 1 , 1 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 1 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 1 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) gradF ( 2 , 1 , i , j , iVar , iEl ) = gradF ( 2 , 1 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 2 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 2 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) gradF ( 1 , 2 , i , j , iVar , iEl ) = gradF ( 1 , 2 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 1 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 1 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) gradF ( 2 , 2 , i , j , iVar , iEl ) = gradF ( 2 , 2 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 2 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 2 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE VectorDGGradient_2D_cpu SUBROUTINE VectorDGGradient_2D_gpu ( myPoly , f_dev , bf_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorDGGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bf_dev , gradF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorDGGradient_2D_gpu SUBROUTINE VectorDivergence_2D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE VectorDivergence_2D_cpu SUBROUTINE VectorDivergence_2D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorDivergence_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorDivergence_2D_gpu SUBROUTINE VectorDGDivergence_2D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Assumes bF is the vector component in the direction normal to the boundary IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bF ( 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE VectorDGDivergence_2D_cpu SUBROUTINE VectorDGDivergence_2D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorDGDivergence_2D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorDGDivergence_2D_gpu SUBROUTINE VectorCurl_2D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE VectorCurl_2D_cpu SUBROUTINE VectorCurl_2D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorCurl_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorCurl_2D_gpu SUBROUTINE TensorDivergence_2D_cpu ( myPoly , f , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = dF ( 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , iVar , iEl ) dF ( 2 , i , j , iVar , iEl ) = dF ( 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE TensorDivergence_2D_cpu SUBROUTINE TensorDivergence_2D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL TensorDivergence_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE TensorDivergence_2D_gpu SUBROUTINE TensorDGDivergence_2D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = dF ( 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , iVar , iEl ) dF ( 2 , i , j , iVar , iEl ) = dF ( 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , iVar , iEl ) END DO dF ( 1 , i , j , iVar , iEl ) = dF ( 1 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 1 , 1 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 1 , 1 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 2 , 1 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 2 , 1 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) dF ( 2 , i , j , iVar , iEl ) = dF ( 2 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 1 , 2 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 1 , 2 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 2 , 2 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 2 , 2 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE TensorDGDivergence_2D_cpu SUBROUTINE TensorDGDivergence_2D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL TensorDGDivergence_2D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE TensorDGDivergence_2D_gpu SUBROUTINE ScalarGradient_3D_cpu ( myPoly , f , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , i , j , k , iVar , iEl ) = gradF ( 1 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , j , k , iVar , iEl ) gradF ( 2 , i , j , k , iVar , iEl ) = gradF ( 2 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( i , ii , k , iVar , iEl ) gradF ( 3 , i , j , k , iVar , iEl ) = gradF ( 3 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , k ) * f ( i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE ScalarGradient_3D_cpu SUBROUTINE ScalarGradient_3D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL ScalarGradient_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE ScalarGradient_3D_gpu ! SUBROUTINE VectorGradient_3D_cpu ( myPoly , f , gradF , nVariables , nElements ) ! ! Input : Vector(1:3,...) ! Output : Tensor(1:3,1:3,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(3,1) = d/ds1( Vector(3,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) !          > Tensor(3,2) = d/ds2( Vector(3,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 1 , 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 1 , 3 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , 3 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , 1 , i , j , k , iVar , iEl ) = gradF ( 1 , 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) gradF ( 2 , 1 , i , j , k , iVar , iEl ) = gradF ( 2 , 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , k , iVar , iEl ) gradF ( 3 , 1 , i , j , k , iVar , iEl ) = gradF ( 3 , 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 3 , ii , j , k , iVar , iEl ) gradF ( 1 , 2 , i , j , k , iVar , iEl ) = gradF ( 1 , 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , k , iVar , iEl ) gradF ( 2 , 2 , i , j , k , iVar , iEl ) = gradF ( 2 , 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) gradF ( 3 , 2 , i , j , k , iVar , iEl ) = gradF ( 3 , 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 3 , i , ii , k , iVar , iEl ) gradF ( 1 , 3 , i , j , k , iVar , iEl ) = gradF ( 1 , 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 1 , i , j , ii , iVar , iEl ) gradF ( 2 , 3 , i , j , k , iVar , iEl ) = gradF ( 2 , 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 2 , i , j , ii , iVar , iEl ) gradF ( 3 , 3 , i , j , k , iVar , iEl ) = gradF ( 3 , 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorGradient_3D_cpu SUBROUTINE VectorGradient_3D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorGradient_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorGradient_3D_gpu SUBROUTINE VectorDivergence_3D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorDivergence_3D_cpu SUBROUTINE VectorDivergence_3D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorDivergence_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorDivergence_3D_gpu SUBROUTINE VectorDGDivergence_3D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Assumes bF is the vector component in the direction normal to the element boundaries IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( 3 , i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( 3 , i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) END DO END DO END DO END DO END DO END SUBROUTINE VectorDGDivergence_3D_cpu SUBROUTINE VectorDGDivergence_3D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorDGDivergence_3D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorDGDivergence_3D_gpu SUBROUTINE VectorCurl_3D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 3 , i , ii , k , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , k ) * f ( 2 , i , j , ii , iVar , iEl ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , k ) * f ( 1 , i , j , ii , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , i ) * f ( 3 , ii , j , k , iVar , iEl ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , k , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , k , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorCurl_3D_cpu SUBROUTINE VectorCurl_3D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorCurl_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorCurl_3D_gpu SUBROUTINE TensorDivergence_3D_cpu ( myPoly , f , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , 1 , i , j , ii , iVar , iEl ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , 2 , i , j , ii , iVar , iEl ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 3 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 3 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , 3 , i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE TensorDivergence_3D_cpu SUBROUTINE TensorDivergence_3D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL TensorDivergence_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE TensorDivergence_3D_gpu SUBROUTINE TensorDGDivergence_3D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bF ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , 1 , i , j , ii , iVar , iEl ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , 2 , i , j , ii , iVar , iEl ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 3 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 3 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , 3 , i , j , ii , iVar , iEl ) END DO dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , 1 , j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , 1 , j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , 1 , i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , 1 , i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( 3 , 1 , i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( 3 , 1 , i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , 2 , j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , 2 , j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , 2 , i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , 2 , i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( 3 , 2 , i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( 3 , 2 , i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , 3 , j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , 3 , j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , 3 , i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , 3 , i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( 3 , 3 , i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( 3 , 3 , i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) END DO END DO END DO END DO END DO END SUBROUTINE TensorDGDivergence_3D_cpu SUBROUTINE TensorDGDivergence_3D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL TensorDGDivergence_3D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE TensorDGDivergence_3D_gpu ! /////////////////////////////// ! ! Boundary Interpolation Routines ! SUBROUTINE ScalarBoundaryInterp_1D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : nVariables , 1 : 2 , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables fb ( 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , iVar , iEl ) ! West fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , iVar , iEl ) ! East END DO fBound ( iVar , 1 : 2 , iEl ) = fb ( 1 : 2 ) END DO END DO END SUBROUTINE ScalarBoundaryInterp_1D_cpu SUBROUTINE ScalarBoundaryInterp_1D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound #ifdef GPU CALL ScalarBoundaryInterp_1D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) #endif END SUBROUTINE ScalarBoundaryInterp_1D_gpu SUBROUTINE ScalarBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , ii , iVar , iEl ) ! South fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , i , iVar , iEl ) ! East fb ( 3 ) = fb ( 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , ii , iVar , iEl ) ! North fb ( 4 ) = fb ( 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , i , iVar , iEl ) ! West END DO fBound ( i , iVar , 1 : 4 , iEl ) = fb ( 1 : 4 ) END DO END DO END DO END SUBROUTINE ScalarBoundaryInterp_2D_cpu SUBROUTINE ScalarBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound #ifdef GPU CALL ScalarBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) #endif END SUBROUTINE ScalarBoundaryInterp_2D_gpu SUBROUTINE VectorBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 , 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 2 , 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N DO idir = 1 , 2 fb ( idir , 1 ) = fb ( idir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , ii , iVar , iEl ) ! South fb ( idir , 2 ) = fb ( idir , 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , ii , i , iVar , iEl ) ! East fb ( idir , 3 ) = fb ( idir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , ii , iVar , iEl ) ! North fb ( idir , 4 ) = fb ( idir , 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , ii , i , iVar , iEl ) ! West END DO END DO DO idir = 1 , 2 fBound ( idir , i , iVar , 1 : 4 , iEl ) = fb ( idir , 1 : 4 ) END DO END DO END DO END DO END SUBROUTINE VectorBoundaryInterp_2D_cpu SUBROUTINE VectorBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound #ifdef GPU CALL VectorBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) #endif END SUBROUTINE VectorBoundaryInterp_2D_gpu SUBROUTINE TensorBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , jdir , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 , 1 : 2 , 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 2 , 1 : 2 , 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N DO jdir = 1 , 2 DO idir = 1 , 2 fb ( idir , jdir , 1 ) = fb ( idir , jdir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , ii , iVar , iEl ) ! South fb ( idir , jdir , 2 ) = fb ( idir , jdir , 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , ii , i , iVar , iEl ) ! East fb ( idir , jdir , 3 ) = fb ( idir , jdir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , ii , iVar , iEl ) ! North fb ( idir , jdir , 4 ) = fb ( idir , jdir , 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , ii , i , iVar , iEl ) ! West END DO END DO END DO DO jdir = 1 , 2 DO idir = 1 , 2 fBound ( idir , jdir , i , iVar , 1 : 4 , iEl ) = fb ( idir , jdir , 1 : 4 ) END DO END DO END DO END DO END DO END SUBROUTINE TensorBoundaryInterp_2D_cpu SUBROUTINE TensorBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound #ifdef GPU CALL TensorBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) #endif END SUBROUTINE TensorBoundaryInterp_2D_gpu SUBROUTINE ScalarBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , j , ii , iVar , iEl ) ! Bottom fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , ii , j , iVar , iEl ) ! South fb ( 3 ) = fb ( 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , i , j , iVar , iEl ) ! East fb ( 4 ) = fb ( 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , ii , j , iVar , iEl ) ! North fb ( 5 ) = fb ( 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , i , j , iVar , iEl ) ! West fb ( 6 ) = fb ( 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , j , ii , iVar , iEl ) ! Top END DO fBound ( i , j , iVar , 1 : 6 , iEl ) = fb ( 1 : 6 ) END DO END DO END DO END DO END SUBROUTINE ScalarBoundaryInterp_3D_cpu SUBROUTINE ScalarBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound #ifdef GPU CALL ScalarBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) #endif END SUBROUTINE ScalarBoundaryInterp_3D_gpu SUBROUTINE VectorBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , iVar , iEl REAL ( prec ) :: fb ( 1 : 3 , 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 3 , 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N DO idir = 1 , 3 fb ( idir , 1 ) = fb ( idir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , j , ii , iVar , iEl ) ! Bottom fb ( idir , 2 ) = fb ( idir , 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , ii , j , iVar , iEl ) ! South fb ( idir , 3 ) = fb ( idir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , ii , i , j , iVar , iEl ) ! East fb ( idir , 4 ) = fb ( idir , 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , ii , j , iVar , iEl ) ! North fb ( idir , 5 ) = fb ( idir , 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , ii , i , j , iVar , iEl ) ! West fb ( idir , 6 ) = fb ( idir , 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , j , ii , iVar , iEl ) ! Top END DO END DO DO idir = 1 , 3 fBound ( idir , i , j , iVar , 1 : 6 , iEl ) = fb ( idir , 1 : 6 ) END DO END DO END DO END DO END DO END SUBROUTINE VectorBoundaryInterp_3D_cpu SUBROUTINE VectorBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound #ifdef GPU CALL VectorBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) #endif END SUBROUTINE VectorBoundaryInterp_3D_gpu SUBROUTINE TensorBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , jdir , iVar , iEl REAL ( prec ) :: fb ( 1 : 3 , 1 : 3 , 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 3 , 1 : 3 , 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N DO jdir = 1 , 3 DO idir = 1 , 3 fb ( idir , jdir , 1 ) = fb ( idir , jdir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , j , ii , iVar , iEl ) ! Bottom fb ( idir , jdir , 2 ) = fb ( idir , jdir , 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , ii , j , iVar , iEl ) ! South fb ( idir , jdir , 3 ) = fb ( idir , jdir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , ii , i , j , iVar , iEl ) ! East fb ( idir , jdir , 4 ) = fb ( idir , jdir , 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , ii , j , iVar , iEl ) ! North fb ( idir , jdir , 5 ) = fb ( idir , jdir , 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , ii , i , j , iVar , iEl ) ! West fb ( idir , jdir , 6 ) = fb ( idir , jdir , 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , j , ii , iVar , iEl ) ! Top END DO END DO END DO DO jdir = 1 , 3 DO idir = 1 , 3 fBound ( idir , jdir , i , j , iVar , 1 : 6 , iEl ) = fb ( idir , jdir , 1 : 6 ) END DO END DO END DO END DO END DO END DO END SUBROUTINE TensorBoundaryInterp_3D_cpu SUBROUTINE TensorBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound #ifdef GPU CALL TensorBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) #endif END SUBROUTINE TensorBoundaryInterp_3D_gpu ! ================================================================================================ ! ! ! CalculateBarycentricWeights (PRIVATE) ! !   A PRIVATE routine that calculates and stores the barycentric weights for the Lagrange !   data-structure. ! !   This routine is from Alg. 30 on pg. 75 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! SUBROUTINE CalculateBarycentricWeights ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: i , j REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) DO i = 0 , myPoly % N bWeights ( i ) = 1.0_real64 controlPoints ( i ) = REAL ( myPoly % controlPoints % hostData ( i ), real64 ) END DO ! Computes the product w_k = w_k*(s_k - s_j), k /= j DO j = 1 , myPoly % N DO i = 0 , j - 1 bWeights ( i ) = bWeights ( i ) * ( controlPoints ( i ) - controlPoints ( j )) bWeights ( j ) = bWeights ( j ) * ( controlPoints ( j ) - controlPoints ( i )) END DO END DO DO j = 0 , myPoly % N bWeights ( j ) = 1.0_prec / bWeights ( j ) myPoly % bWeights % hostData ( j ) = REAL ( bWeights ( j ), prec ) END DO END SUBROUTINE CalculateBarycentricWeights ! ================================================================================================ ! ! ! CalculateInterpolationMatrix (PRIVATE) ! !   A PRIVATE routine that fills in the interpolation matrix for the Lagrange data structure. ! !   This function is from Alg. 32 on pg. 76 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! SUBROUTINE CalculateInterpolationMatrix ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: row , col LOGICAL :: rowHasMatch REAL ( real64 ) :: temp1 , temp2 REAL ( real64 ) :: iMatrix ( 0 : myPoly % M , 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) REAL ( real64 ) :: targetPoints ( 0 : myPoly % M ) DO col = 0 , myPoly % N controlPoints ( col ) = REAL ( myPoly % controlPoints % hostData ( col ), real64 ) bWeights ( col ) = REAL ( myPoly % bWeights % hostData ( col ), real64 ) END DO DO row = 0 , myPoly % M targetPoints ( row ) = REAL ( myPoly % targetPoints % hostData ( row ), real64 ) END DO DO row = 0 , myPoly % M rowHasMatch = . FALSE . DO col = 0 , myPoly % N iMatrix ( row , col ) = 0.0_real64 IF ( AlmostEqual ( targetPoints ( row ), controlPoints ( col ))) THEN rowHasMatch = . TRUE . iMatrix ( row , col ) = 1.0_real64 END IF END DO IF (. NOT . ( rowHasMatch )) THEN temp1 = 0.0_real64 DO col = 0 , myPoly % N temp2 = bWeights ( col ) / & ( targetPoints ( row ) - & controlPoints ( col )) iMatrix ( row , col ) = temp2 temp1 = temp1 + temp2 END DO DO col = 0 , myPoly % N iMatrix ( row , col ) = iMatrix ( row , col ) / temp1 END DO END IF END DO DO row = 0 , myPoly % M DO col = 0 , myPoly % N myPoly % iMatrix % hostData ( col , row ) = REAL ( iMatrix ( row , col ), prec ) ENDDO ENDDO END SUBROUTINE CalculateInterpolationMatrix ! ================================================================================================ ! ! ! CalculateDerivativeMatrix (PRIVATE) ! !   Calculates and stores the derivative matrix and its transpose. !   Generates a matrix that can be used to approximate derivatives at the interpolation nodes. ! !   This function is from Alg. 37 on pg. 82 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! SUBROUTINE CalculateDerivativeMatrix ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: row , col REAL ( real64 ) :: dmat ( 0 : myPoly % N , 0 : myPoly % N ) REAL ( real64 ) :: dgmat ( 0 : myPoly % N , 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: qWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) DO row = 0 , myPoly % N bWeights ( row ) = REAL ( myPoly % bWeights % hostData ( row ), real64 ) qWeights ( row ) = REAL ( myPoly % qWeights % hostData ( row ), real64 ) controlPoints ( row ) = REAL ( myPoly % controlPoints % hostData ( row ), real64 ) END DO DO row = 0 , myPoly % N dmat ( row , row ) = 0.0_prec DO col = 0 , myPoly % N IF (. NOT . ( col == row )) THEN dmat ( row , col ) = bWeights ( col ) / & ( bWeights ( row ) * & ( controlPoints ( row ) - & controlPoints ( col ))) dmat ( row , row ) = dmat ( row , row ) - dmat ( row , col ) END IF END DO END DO DO row = 0 , myPoly % N DO col = 0 , myPoly % N dgmat ( row , col ) = - dmat ( col , row ) * & qWeights ( col ) / & qWeights ( row ) ENDDO ENDDO DO row = 0 , myPoly % N DO col = 0 , myPoly % N myPoly % dMatrix % hostData ( row , col ) = REAL ( dmat ( col , row ), prec ) myPoly % dgMatrix % hostData ( row , col ) = REAL ( dgmat ( col , row ), prec ) ENDDO ENDDO END SUBROUTINE CalculateDerivativeMatrix ! ================================================================================================ ! ! ! CalculateLagrangePolynomials ! !   Evaluates each of the 1-D Lagrange interpolating polynomials at a specified point. ! !   This function is from Alg. 34 on pg. 77 of D.A. Kopriva, 2009. ! ! ================================================================================================ ! FUNCTION CalculateLagrangePolynomials ( myPoly , sE ) RESULT ( lAtS ) IMPLICIT NONE CLASS ( Lagrange ) :: myPoly REAL ( prec ) :: sE REAL ( prec ) :: lAtS ( 0 : myPoly % N ) ! Local INTEGER :: j LOGICAL :: xMatchesNode REAL ( real64 ) :: temp1 , temp2 REAL ( real64 ) :: sELocal REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: lS ( 0 : myPoly % N ) sELocal = REAL ( sE , real64 ) DO j = 0 , myPoly % N controlPoints ( j ) = REAL ( myPoly % controlPoints % hostData ( j ), real64 ) bWeights ( j ) = REAL ( myPoly % bWeights % hostData ( j ), real64 ) END DO xMatchesNode = . FALSE . DO j = 0 , myPoly % N lS ( j ) = 0.0_real64 IF ( AlmostEqual ( sELocal , controlPoints ( j ))) THEN lS ( j ) = 1.0_real64 xMatchesNode = . TRUE . END IF END DO IF ( xMatchesNode ) THEN RETURN END IF temp1 = 0.0_real64 DO j = 0 , myPoly % N temp2 = bWeights ( j ) / ( sE - controlPoints ( j )) lS ( j ) = temp2 temp1 = temp1 + temp2 END DO lS = lS / temp1 DO j = 0 , myPoly % N lAtS ( j ) = REAL ( lS ( j ), prec ) ENDDO END FUNCTION CalculateLagrangePolynomials END MODULE SELF_Lagrange","tags":"","loc":"sourcefile/self_lagrange.f90.html"},{"title":"SELF_MPILayer.f90 – SELF","text":"This file depends on sourcefile~~self_mpilayer.f90~~EfferentGraph sourcefile~self_mpilayer.f90 SELF_MPILayer.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mesh.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_mpilayer.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mappeddata.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_constants.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_MPILayer Source Code SELF_MPILayer.f90 Source Code MODULE SELF_MPILayer USE SELF_Data USE SELF_MappedData USE SELF_Mesh IMPLICIT NONE !  TYPE MPILayer ! !    INTEGER :: nMessages !    INTEGER :: mpiComm !    INTEGER :: mpiPrec !    INTEGER :: myRank !    INTEGER :: nProc !    INTEGER, ALLOCATABLE :: requestHandle(:), requestStats(:,:) ! !    CONTAINS ! !      PROCEDURE :: Init => Init_MPILayer !      PROCEDURE :: Free => Free_MPILayer ! !      GENERIC, PUBLIC :: MPI_Exchange => MPIExchange_MappedScalar2D !      PROCEDURE, PUBLIC :: MPIExchange_MappedScalar2D ! !      PROCEDURE :: Finalize_MPI_Exchange ! !  END TYPE MPILayer PUBLIC :: SELF_CalculateRankDistributions CONTAINS !  FUNCTION Int2Str( aNumber ) RESULT( aString ) !    IMPLICIT NONE !    INTEGER :: aNumber !    CHARACTER(12) :: aString ! !      WRITE(aString, '(I12)') aNumber ! !  END FUNCTION Int2Str SUBROUTINE SELF_CalculateRankDistributions ( nObj , nRanks , objBounds ) #undef __FUNC__ #define __FUNC__ SELF_CalculateRankDistributions IMPLICIT NONE INTEGER , INTENT ( in ) :: nObj INTEGER , INTENT ( in ) :: nRanks INTEGER , INTENT ( out ) :: objBounds ( 1 : 2 , 0 : nRanks - 1 ) ! Local INTEGER :: rank , nObjPerRank , remainder , lastUpperBound nObjPerRank = nObj / nRanks remainder = nObj - nObjPerRank * nRanks lastUpperBound = 0 DO rank = 0 , nRanks - 1 objBounds ( 1 , rank ) = 1 + lastUpperBound IF ( rank < remainder ) THEN objBounds ( 2 , rank ) = objBounds ( 1 , rank ) + nObjPerRank + 1 ELSE objBounds ( 2 , rank ) = objBounds ( 1 , rank ) + nObjPerRank END IF lastUpperBound = objBounds ( 2 , rank ) !   INFO( 'Rank '//TRIM(Int2Str(rank))//& !         ' [lower,upper/total] = '//& !         TRIM(Int2Str(objBounds(1,rank)))//','//& !         TRIM(Int2Str(objBounds(2,rank)))//'/'//& !         TRIM(Int2Str(nObj)) ) END DO END SUBROUTINE SELF_CalculateRankDistributions !  SUBROUTINE MPIExchange_MappedScalar2D( mpiHandler, scalar, mesh, workScalar ) !    IMPLICIT NONE !    CLASS(MPILayer), INTENT(inout) :: mpiHandler !    TYPE(MappedScalar2D), INTENT(in) :: scalar !    TYPE(Mesh2D), INTENT(in) :: mesh !    TYPE(MappedScalar2D), INTENT(inout) :: scalar !    ! Local !    INTEGER :: msgCnt, e1, s1, e2, s2 !    INTEGER :: globalSideId, externalProcId ! !    msgCnt = 0 !    DO e1 = 1, mesh % nElem !      s1 = 1 !      DO sideId = mesh % elemInfo % hostData(3,e1)+1, mesh % elemInfo % hostData(4,e1) !        ! Secondary element ID for this face !        e2 = mesh % sideInfo % hostData(3,sideId) ! !        ! In SELF, we read in HOPR pre-processed mesh information. Upon reading in and !        ! performing data decomposition, we set e2 = -e2 if the neighboring element is !        ! owned by another rank !        IF( e2 < 0 )THEN !          s2 = mesh % sideInfo % hostData(4,sideId)/10 !          globalSideId = ABS(mesh % sideInfo % hostdata(2,sideId)) ! !          ! Assume that mesh has been pre-processed with HOPR and !          ! elements are distributed to ranks by simply dividing the list [1:nElements] !          ! evenly and in order to all ranks !          ! TODO: externalProcId = GetRank( e2, mesh % nElem, mpiHandler % nRanks ) ! !          msgCnt = msgCnt + 1 !          ! Receive data on this rank's workScalar !          CALL MPI_IRECV( workScalar % boundary % hostData(:,:,s1,e1), & !                          (scalar % N+1)*scalar % nVar, & !                          mpiHandler % mpiPrec, & !                          externalProcId, globalSideId,  & !                          mpiHandler % mpiComm, & !                          mpiHandler % requestHandle(msgCnt*2-1), iError ) ! ! !          ! Send data from this rank's scalar !          CALL MPI_ISEND( workScalar % boundary % hostData(:,:,s1,e1), & !                          (scalar % N+1)*scalar % nVar, & !                          mpiHandler % mpiPrec, & !                          externalProcID, globalSideId, & !                          mpiHandler % mpiComm, & !                          mpiHandler % requestHandle(msgCnt*2), iError) ! !        ENDIF ! !      ENDDO !    ENDDO ! !  END FUNCTION MPIExchange_MappedScalar2D ! !  SUBROUTINE Finalize_MPIExchange( mpiHandler ) !    CLASS( MPILayer ), INTENT(inout) :: mpiHandler !    ! Local !    INTEGER    :: ierror ! !    CALL MPI_WaitAll( mpiHandler % nMessages*2, & !                      mpiHandler % requestHandle, & !                      mpiHandler % requestStats, & !                      iError) ! !  END SUBROUTINE Finalize_MPI_Exchange END MODULE SELF_MPILayer","tags":"","loc":"sourcefile/self_mpilayer.f90.html"},{"title":"SELF_MappedData.f90 – SELF","text":"This file depends on sourcefile~~self_mappeddata.f90~~EfferentGraph sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_mappeddata.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_constants.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_mappeddata.f90~~AfferentGraph sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_tests.f90 SELF_Tests.f90 sourcefile~self_tests.f90->sourcefile~self_mappeddata.f90 sourcefile~self_mpilayer.f90 SELF_MPILayer.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mappeddata.f90 sourcefile~self.f90 SELF.f90 sourcefile~self.f90->sourcefile~self_tests.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_MappedData Source Code SELF_MappedData.f90 Source Code ! SELF_MappedData.F90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self-fluids@fluidnumerics.com ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! MODULE SELF_MappedData USE SELF_Constants USE SELF_Lagrange USE SELF_Data USE SELF_Mesh USE SELF_Geometry USE ISO_C_BINDING IMPLICIT NONE #include \"SELF_Macros.h\" TYPE , EXTENDS ( Scalar1D ), PUBLIC :: MappedScalar1D CONTAINS GENERIC , PUBLIC :: Derivative => Derivative_MappedScalar1D PROCEDURE , PRIVATE :: Derivative_MappedScalar1D PROCEDURE , PRIVATE :: JacobianWeight => JacobianWeight_MappedScalar1D END TYPE MappedScalar1D TYPE , EXTENDS ( Scalar2D ), PUBLIC :: MappedScalar2D CONTAINS GENERIC , PUBLIC :: Gradient => Gradient_MappedScalar2D PROCEDURE , PRIVATE :: Gradient_MappedScalar2D PROCEDURE , PRIVATE :: ContravariantWeight => ContravariantWeight_MappedScalar2D PROCEDURE , PRIVATE :: JacobianWeight => JacobianWeight_MappedScalar2D END TYPE MappedScalar2D TYPE , EXTENDS ( Scalar3D ), PUBLIC :: MappedScalar3D CONTAINS GENERIC , PUBLIC :: Gradient => Gradient_MappedScalar3D PROCEDURE , PRIVATE :: Gradient_MappedScalar3D PROCEDURE , PRIVATE :: ContravariantWeight => ContravariantWeight_MappedScalar3D PROCEDURE , PRIVATE :: JacobianWeight => JacobianWeight_MappedScalar3D END TYPE MappedScalar3D TYPE , EXTENDS ( Vector2D ), PUBLIC :: MappedVector2D CONTAINS GENERIC , PUBLIC :: Divergence => Divergence_MappedVector2D GENERIC , PUBLIC :: Gradient => Gradient_MappedVector2D !    GENERIC,PUBLIC :: Curl => Curl_MappedVector2D PROCEDURE , PRIVATE :: Divergence_MappedVector2D PROCEDURE , PRIVATE :: Gradient_MappedVector2D !    PROCEDURE,PRIVATE :: Curl_MappedVector2D PROCEDURE , PRIVATE :: ContravariantProjection => ContravariantProjection_MappedVector2D PROCEDURE , PRIVATE :: JacobianWeight => JacobianWeight_MappedVector2D PROCEDURE , PRIVATE :: MapToScalar => MapToScalar_MappedVector2D PROCEDURE , PRIVATE :: MapToTensor => MapToTensor_MappedVector2D END TYPE MappedVector2D TYPE , EXTENDS ( Vector3D ), PUBLIC :: MappedVector3D CONTAINS GENERIC , PUBLIC :: Divergence => Divergence_MappedVector3D !    GENERIC,PUBLIC :: Curl => Curl_MappedVector3D GENERIC , PUBLIC :: Gradient => Gradient_MappedVector3D PROCEDURE , PRIVATE :: Divergence_MappedVector3D !    PROCEDURE,PRIVATE :: Curl_MappedVector3D PROCEDURE , PRIVATE :: Gradient_MappedVector3D PROCEDURE , PRIVATE :: ContravariantProjection => ContravariantProjection_MappedVector3D PROCEDURE , PRIVATE :: JacobianWeight => JacobianWeight_MappedVector3D PROCEDURE , PRIVATE :: MapToScalar => MapToScalar_MappedVector3D PROCEDURE , PRIVATE :: MapToTensor => MapToTensor_MappedVector3D END TYPE MappedVector3D TYPE , EXTENDS ( Tensor2D ), PUBLIC :: MappedTensor2D CONTAINS ! !    GENERIC,PUBLIC :: Divergence => Divergence_MappedTensor2D !    PROCEDURE,PRIVATE :: Divergence_MappedTensor2D PROCEDURE , PRIVATE :: JacobianWeight => JacobianWeight_MappedTensor2D END TYPE MappedTensor2D TYPE , EXTENDS ( Tensor3D ), PUBLIC :: MappedTensor3D CONTAINS ! !    GENERIC,PUBLIC :: Divergence => Divergence_MappedTensor3D !    PROCEDURE,PRIVATE :: Divergence_MappedTensor3D PROCEDURE , PRIVATE :: JacobianWeight => JacobianWeight_MappedTensor3D END TYPE MappedTensor3D #ifdef GPU INTERFACE SUBROUTINE JacobianWeight_MappedScalar1D_gpu_wrapper ( scalar , dxds , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedScalar1D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , dxds INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedScalar1D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedScalar2D_gpu_wrapper ( scalar , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedScalar2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , jacobian INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedScalar2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedScalar3D_gpu_wrapper ( scalar , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedScalar3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , jacobian INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedScalar3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantWeight_MappedScalar2D_gpu_wrapper ( scalar , workTensor , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantWeight_MappedScalar2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , workTensor , dsdx INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE ContravariantWeight_MappedScalar2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper ( scalar , workTensor , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , workTensor , dsdx INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantWeight_MappedScalar3D_gpu_wrapper ( scalar , workTensor , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantWeight_MappedScalar3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , workTensor , dsdx INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE ContravariantWeight_MappedScalar3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper ( scalar , workTensor , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , workTensor , dsdx INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantProjection_MappedVector2D_gpu_wrapper ( physVector , compVector , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantProjection_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: physVector , compVector , dsdx INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE ContravariantProjection_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper ( physVector , compVector , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: physVector , compVector , dsdx INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedVector2D_gpu_wrapper ( vector , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: vector , jacobian INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantProjection_MappedVector3D_gpu_wrapper ( physVector , compVector , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantProjection_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: physVector , compVector , dsdx INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE ContravariantProjection_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper ( physVector , compVector , dsdx , N , nVar , nEl ) & bind ( c , name = \"ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: physVector , compVector , dsdx INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedVector3D_gpu_wrapper ( vector , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: vector , jacobian INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedTensor2D_gpu_wrapper ( tensor , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedTensor2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: tensor , jacobian INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedTensor2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE JacobianWeight_MappedTensor3D_gpu_wrapper ( tensor , jacobian , N , nVar , nEl ) & bind ( c , name = \"JacobianWeight_MappedTensor3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: tensor , jacobian INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE JacobianWeight_MappedTensor3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToScalar_MappedVector2D_gpu_wrapper ( scalar , vector , N , nVar , nEl ) & bind ( c , name = \"MapToScalar_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , vector INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE MapToScalar_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToScalarBoundary_MappedVector2D_gpu_wrapper ( scalar , vector , N , nVar , nEl ) & bind ( c , name = \"MapToScalarBoundary_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , vector INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE MapToScalarBoundary_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToTensor_MappedVector2D_gpu_wrapper ( tensor , vector , N , nVar , nEl ) & bind ( c , name = \"MapToTensor_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: tensor , vector INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE MapToTensor_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToTensorBoundary_MappedVector2D_gpu_wrapper ( tensor , vector , N , nVar , nEl ) & bind ( c , name = \"MapToTensorBoundary_MappedVector2D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: tensor , vector INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE MapToTensorBoundary_MappedVector2D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToScalar_MappedVector3D_gpu_wrapper ( scalar , vector , N , nVar , nEl ) & bind ( c , name = \"MapToScalar_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , vector INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE MapToScalar_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToScalarBoundary_MappedVector3D_gpu_wrapper ( scalar , vector , N , nVar , nEl ) & bind ( c , name = \"MapToScalarBoundary_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: scalar , vector INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE MapToScalarBoundary_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToTensor_MappedVector3D_gpu_wrapper ( tensor , vector , N , nVar , nEl ) & bind ( c , name = \"MapToTensor_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: tensor , vector INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE MapToTensor_MappedVector3D_gpu_wrapper END INTERFACE INTERFACE SUBROUTINE MapToTensorBoundary_MappedVector3D_gpu_wrapper ( tensor , vector , N , nVar , nEl ) & bind ( c , name = \"MapToTensorBoundary_MappedVector3D_gpu_wrapper\" ) USE ISO_C_BINDING IMPLICIT NONE TYPE ( c_ptr ) :: tensor , vector INTEGER , VALUE :: N , nVar , nEl END SUBROUTINE MapToTensorBoundary_MappedVector3D_gpu_wrapper END INTERFACE #endif CONTAINS ! ---------------------- Scalars ---------------------- ! SUBROUTINE Derivative_MappedScalar1D ( scalar , geometry , dF , dForm , gpuAccel ) ! Strong Form Operator ! ! Calculates the gradient of a scalar 1D function using the conservative form of the ! mapped gradient operator ! ! df/dx =  d\\xi/dx( df/d\\xi ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( in ) :: scalar TYPE ( Geometry1D ), INTENT ( in ) :: geometry TYPE ( MappedScalar1D ), INTENT ( inout ) :: dF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL scalar % interp % DGDerivative_1D ( scalar % interior % deviceData , & scalar % boundary % deviceData , & df % interior % deviceData , & scalar % nVar , & scalar % nElem ) ELSE CALL scalar % interp % DGDerivative_1D ( scalar % interior % hostData , & scalar % boundary % hostData , & df % interior % hostData , & scalar % nVar , & scalar % nElem ) END IF ELSEIF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL scalar % interp % Derivative_1D ( scalar % interior % deviceData , & df % interior % deviceData , & scalar % nVar , & scalar % nElem ) ELSE CALL scalar % interp % Derivative_1D ( scalar % interior % hostData , & df % interior % hostData , & scalar % nVar , & scalar % nElem ) END IF ENDIF CALL df % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Derivative_MappedScalar1D SUBROUTINE JacobianWeight_MappedScalar1D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar1D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( inout ) :: scalar TYPE ( Geometry1D ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL JacobianWeight_MappedScalar1D_gpu_wrapper ( scalar % interior % deviceData , & geometry % dxds % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO i = 0 , scalar % N scalar % interior % hostData ( i , iVar , iEl ) = scalar % interior % hostData ( i , iVar , iEl ) / & geometry % dxds % interior % hostData ( i , 1 , iEl ) ENDDO ENDDO ENDDO ENDIF END SUBROUTINE JacobianWeight_MappedScalar1D SUBROUTINE Gradient_MappedScalar2D ( scalar , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator - (Conservative Form) ! ! Calculates the gradient of a scalar 2D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( in ) :: scalar TYPE ( MappedTensor2D ), INTENT ( inout ) :: workTensor TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedVector2D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL scalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSEIF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ENDIF CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedScalar2D SUBROUTINE ContravariantWeight_MappedScalar2D ( scalar , geometry , workTensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantWeight_MappedScalar2D\" IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( in ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel TYPE ( MappedTensor2D ), INTENT ( inout ) :: workTensor ! Local INTEGER :: i , j , iVar , iEl , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL ContravariantWeight_MappedScalar2D_gpu_wrapper ( scalar % interior % deviceData , & workTensor % interior % deviceData , & geometry % dsdx % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) CALL ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper ( scalar % boundary % deviceData , & workTensor % boundary % deviceData , & geometry % dsdx % boundary % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N workTensor % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 1 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) workTensor % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 2 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) workTensor % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 1 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) workTensor % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 2 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ! Boundary Terms DO iEl = 1 , scalar % nElem DO iside = 1 , 4 DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N workTensor % boundary % hostData ( 1 , 1 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 1 , j , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 1 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 2 , j , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , iVar , iside , iEl ) workTensor % boundary % hostData ( 1 , 2 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 1 , j , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 2 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 2 , j , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , iVar , iside , iEl ) ENDDO ENDDO ENDDO ENDDO END IF END SUBROUTINE ContravariantWeight_MappedScalar2D SUBROUTINE JacobianWeight_MappedScalar2D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL JacobianWeight_MappedScalar2D_gpu_wrapper ( scalar % interior % deviceData , & geometry % J % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % interior % hostData ( i , j , iVar , iEl ) = scalar % interior % hostData ( i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE JacobianWeight_MappedScalar2D SUBROUTINE Gradient_MappedScalar3D ( scalar , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator ! ! Calculates the gradient of a scalar 3D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( in ) :: scalar TYPE ( MappedTensor3D ), INTENT ( inout ) :: workTensor TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedVector3D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL scalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF END IF CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedScalar3D SUBROUTINE ContravariantWeight_MappedScalar3D ( scalar , geometry , workTensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantWeight_MappedScalar3D\" IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( in ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel TYPE ( MappedTensor3D ), INTENT ( inout ) :: workTensor ! Local INTEGER :: i , j , k , iVar , iEl , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL ContravariantWeight_MappedScalar3D_gpu_wrapper ( scalar % interior % deviceData , & workTensor % interior % deviceData , & geometry % dsdx % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) CALL ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper ( scalar % boundary % deviceData , & workTensor % boundary % deviceData , & geometry % dsdx % boundary % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N DO i = 0 , scalar % N ! Get the x-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) ! Get the y-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) ! Get the z-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO END DO END DO END DO ! Boundary Term DO iEl = 1 , scalar % nElem DO iside = 1 , 6 DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N ! Get the x-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % boundary % hostData ( 1 , 1 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 1 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 1 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 2 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 3 , 1 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 3 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) ! Get the y-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % boundary % hostData ( 1 , 2 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 1 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 2 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 2 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 3 , 2 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 3 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) ! Get the z-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % boundary % hostData ( 1 , 3 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 3 , 1 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 3 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 3 , 2 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 3 , 3 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 3 , 3 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) ENDDO ENDDO ENDDO ENDDO ENDDO END IF END SUBROUTINE ContravariantWeight_MappedScalar3D SUBROUTINE JacobianWeight_MappedScalar3D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL JacobianWeight_MappedScalar3D_gpu_wrapper ( scalar % interior % deviceData , & geometry % J % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % interior % hostData ( i , j , k , iVar , iEl ) = scalar % interior % hostData ( i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE JacobianWeight_MappedScalar3D ! ---------------------- Vectors ---------------------- ! SUBROUTINE Divergence_MappedVector2D ( physVector , compVector , geometry , divVector , dForm , gpuAccel ) ! Strong Form Operator ! ! DG Weak Form Operator ! IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: physVector TYPE ( MappedVector2D ), INTENT ( inout ) :: compVector TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedScalar2D ), INTENT ( inout ) :: divVector INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL physVector % ContravariantProjection ( geometry , compVector , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDGDivergence_2D ( compVector % interior % deviceData , & compVector % boundary % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDGDivergence_2D ( compVector % interior % hostData , & compVector % boundary % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) ENDIF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDivergence_2D ( compVector % interior % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDivergence_2D ( compVector % interior % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) ENDIF END IF CALL divVector % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Divergence_MappedVector2D SUBROUTINE Gradient_MappedVector2D ( vector , workScalar , workVector , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator - (Conservative Form) ! ! Calculates the gradient of a scalar 2D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: vector TYPE ( MappedScalar2D ), INTENT ( inout ) :: workScalar ! (scalar) nvar = 2*nvar TYPE ( MappedVector2D ), INTENT ( inout ) :: workVector ! (scalar) nvar = 2*nvar TYPE ( MappedTensor2D ), INTENT ( inout ) :: workTensor ! (tensor) nvar = 2*nvar TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedTensor2D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL vector % MapToScalar ( workScalar , gpuAccel ) CALL workScalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF END IF CALL workVector % MapToTensor ( gradF , gpuAccel ) CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedVector2D SUBROUTINE MapToScalar_MappedVector2D ( vector , scalar , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToScalar_MappedVector2D\" IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: vector TYPE ( MappedScalar2D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , i , j , ivar , jvar , iel , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL MapToScalar_MappedVector2D_gpu_wrapper ( scalar % interior % deviceData ,& vector % interior % deviceData ,& vector % N , & vector % nVar , & vector % nelem ) CALL MapToScalarBoundary_MappedVector2D_gpu_wrapper ( scalar % boundary % deviceData ,& vector % boundary % deviceData ,& vector % N , & vector % nVar , & vector % nelem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iel = 1 , vector % nelem DO ivar = 1 , vector % nvar DO j = 0 , vector % N DO i = 0 , vector % N DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) scalar % interior % hostData ( i , j , jvar , iel ) = vector % interior % hostData ( row , i , j , ivar , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ! Boundary Terms DO iel = 1 , vector % nelem DO iside = 1 , 4 DO ivar = 1 , vector % nvar DO j = 0 , vector % N DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) scalar % boundary % hostData ( j , jvar , iside , iel ) = vector % boundary % hostData ( row , j , ivar , iside , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE MapToScalar_MappedVector2D SUBROUTINE MapToTensor_MappedVector2D ( vector , tensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToTensor_MappedVector2D\" IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: vector TYPE ( MappedTensor2D ), INTENT ( inout ) :: tensor LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , col , i , j , ivar , jvar , iel , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL MapToTensor_MappedVector2D_gpu_wrapper ( tensor % interior % deviceData ,& vector % interior % deviceData ,& tensor % N , & tensor % nVar , & tensor % nelem ) CALL MapToTensorBoundary_MappedVector2D_gpu_wrapper ( tensor % boundary % deviceData ,& vector % boundary % deviceData ,& tensor % N , & tensor % nVar , & tensor % nelem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iel = 1 , tensor % nelem DO ivar = 1 , tensor % nvar DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) tensor % interior % hostData ( row , col , i , j , ivar , iel ) = vector % interior % hostData ( col , i , j , jvar , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ! Boundary Terms DO iel = 1 , tensor % nelem DO iside = 1 , 4 DO ivar = 1 , tensor % nvar DO j = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) tensor % boundary % hostData ( row , col , j , ivar , iside , iel ) = vector % boundary % hostData ( col , j , jvar , iside , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE MapToTensor_MappedVector2D SUBROUTINE ContravariantProjection_MappedVector2D ( physVector , geometry , compVector , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantProjection_MappedVector2D\" ! Takes a vector that has physical space coordinate directions (x,y,z) and projects the vector ! into the the contravariant basis vector directions. Keep in mind that the contravariant basis ! vectors are really the Jacobian weighted contravariant basis vectors IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: physVector TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel TYPE ( MappedVector2D ), INTENT ( inout ) :: compVector ! Local INTEGER :: i , j , ivar , iel , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL ContravariantProjection_MappedVector2D_gpu_wrapper ( physVector % interior % deviceData , & compVector % interior % deviceData , & geometry % dsdx % interior % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) CALL ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper ( physVector % boundary % deviceData , & compVector % boundary % deviceData , & geometry % dsdx % boundary % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE ! Assume that tensor(j,i) is vector i, component j ! => dot product is done along first dimension ! to project onto computational space DO iel = 1 , physVector % nElem DO ivar = 1 , physVector % nVar DO j = 0 , physVector % N DO i = 0 , physVector % N compVector % interior % hostData ( 1 , i , j , ivar , iel ) = & geometry % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iel ) * & physVector % interior % hostData ( 1 , i , j , ivar , iel ) + & geometry % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iel ) * & physVector % interior % hostData ( 2 , i , j , ivar , iel ) compVector % interior % hostData ( 2 , i , j , ivar , iel ) = & geometry % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iel ) * & physVector % interior % hostData ( 1 , i , j , ivar , iel ) + & geometry % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iel ) * & physVector % interior % hostData ( 2 , i , j , ivar , iel ) END DO END DO END DO END DO ! Boundary Terms DO iel = 1 , physVector % nElem DO iside = 1 , 4 DO ivar = 1 , physVector % nVar DO j = 0 , physVector % N compVector % boundary % hostData ( 1 , j , ivar , iside , iel ) = & geometry % dsdx % boundary % hostData ( 1 , 1 , j , 1 , iside , iel ) * & physVector % boundary % hostData ( 1 , j , ivar , iside , iel ) + & geometry % dsdx % boundary % hostData ( 2 , 1 , j , 1 , iside , iel ) * & physVector % boundary % hostData ( 2 , j , ivar , iside , iel ) compVector % boundary % hostData ( 2 , j , ivar , iside , iel ) = & geometry % dsdx % boundary % hostData ( 1 , 2 , j , 1 , iside , iel ) * & physVector % boundary % hostData ( 1 , j , ivar , iside , iel ) + & geometry % dsdx % boundary % hostData ( 2 , 2 , j , 1 , iside , iel ) * & physVector % boundary % hostData ( 2 , j , ivar , iside , iel ) ENDDO ENDDO ENDDO ENDDO END IF END SUBROUTINE ContravariantProjection_MappedVector2D SUBROUTINE JacobianWeight_MappedVector2D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedVector2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL JacobianWeight_MappedVector2D_gpu_wrapper ( vector % interior % deviceData , & geometry % J % interior % deviceData , & vector % N , & vector % nVar , & vector % nElem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO j = 0 , vector % N DO i = 0 , vector % N vector % interior % hostData ( 1 , i , j , iVar , iEl ) = vector % interior % hostData ( 1 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) vector % interior % hostData ( 2 , i , j , iVar , iEl ) = vector % interior % hostData ( 2 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE JacobianWeight_MappedVector2D SUBROUTINE Divergence_MappedVector3D ( physVector , compVector , geometry , divVector , dForm , gpuAccel ) ! IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: physVector TYPE ( MappedVector3D ), INTENT ( inout ) :: compVector TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedScalar3D ), INTENT ( inout ) :: divVector INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL physVector % ContravariantProjection ( geometry , compVector , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDGDivergence_3D ( compVector % interior % deviceData , & compVector % boundary % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDGDivergence_3D ( compVector % interior % hostData , & compVector % boundary % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) ENDIF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDivergence_3D ( compVector % interior % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDivergence_3D ( compVector % interior % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) ENDIF END IF CALL divVector % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Divergence_MappedVector3D SUBROUTINE Gradient_MappedVector3D ( vector , workScalar , workVector , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator - (Conservative Form) ! ! Calculates the gradient of a scalar 3D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: vector TYPE ( MappedScalar3D ), INTENT ( inout ) :: workScalar ! (scalar) nvar = 3*nvar TYPE ( MappedVector3D ), INTENT ( inout ) :: workVector ! (vector) nvar = 3*nvar TYPE ( MappedTensor3D ), INTENT ( inout ) :: workTensor ! (tensor) nvar = 3*nvar TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedTensor3D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL vector % MapToScalar ( workScalar , gpuAccel ) CALL workScalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF END IF CALL workVector % MapToTensor ( gradF , gpuAccel ) CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedVector3D SUBROUTINE MapToScalar_MappedVector3D ( vector , scalar , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToScalar_MappedVector3D\" IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: vector TYPE ( MappedScalar3D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , i , j , k , ivar , jvar , iel , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL MapToScalar_MappedVector3D_gpu_wrapper ( scalar % interior % deviceData ,& vector % interior % deviceData ,& vector % N , & vector % nVar , & vector % nelem ) CALL MapToScalarBoundary_MappedVector3D_gpu_wrapper ( scalar % boundary % deviceData ,& vector % boundary % deviceData ,& vector % N , & vector % nVar , & vector % nelem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iel = 1 , vector % nelem DO ivar = 1 , vector % nvar DO k = 0 , vector % N DO j = 0 , vector % N DO i = 0 , vector % N DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) scalar % interior % hostData ( i , j , k , jvar , iel ) = vector % interior % hostData ( row , i , j , k , ivar , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ! Boundary Terms DO iel = 1 , vector % nelem DO iside = 1 , 6 DO ivar = 1 , vector % nvar DO k = 0 , vector % N DO j = 0 , vector % N DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) scalar % boundary % hostData ( j , k , jvar , iside , iel ) = vector % boundary % hostData ( row , j , k , ivar , iside , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE MapToScalar_MappedVector3D SUBROUTINE MapToTensor_MappedVector3D ( vector , tensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToTensor_MappedVector3D\" IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: vector TYPE ( MappedTensor3D ), INTENT ( inout ) :: tensor LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , col , i , j , k , ivar , jvar , iel , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL MapToTensor_MappedVector3D_gpu_wrapper ( tensor % interior % deviceData ,& vector % interior % deviceData ,& tensor % N , & tensor % nVar , & tensor % nelem ) CALL MapToTensorBoundary_MappedVector3D_gpu_wrapper ( tensor % boundary % deviceData ,& vector % boundary % deviceData ,& tensor % N , & tensor % nVar , & tensor % nelem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iel = 1 , tensor % nelem DO ivar = 1 , tensor % nvar DO k = 0 , tensor % N DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) tensor % interior % hostData ( row , col , i , j , k , ivar , iel ) = vector % interior % hostData ( col , i , j , k , jvar , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ! Boundary Terms DO iel = 1 , tensor % nelem DO iside = 1 , 6 DO ivar = 1 , tensor % nvar DO k = 0 , tensor % N DO j = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) tensor % boundary % hostData ( row , col , j , k , ivar , iside , iel ) = vector % boundary % hostData ( col , j , k , jvar , iside , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE MapToTensor_MappedVector3D SUBROUTINE ContravariantProjection_MappedVector3D ( physVector , geometry , compVector , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantProjection_MappedVector3D\" ! Takes a vector that has physical space coordinate directions (x,y,z) and projects the vector ! into the the contravariant basis vector directions. Keep in mind that the contravariant basis ! vectors are really the Jacobian weighted contravariant basis vectors IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: physVector TYPE ( MappedVector3D ), INTENT ( inout ) :: compVector TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , k , iVar , iEl , iDir , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL ContravariantProjection_MappedVector3D_gpu_wrapper ( physVector % interior % deviceData , & compVector % interior % deviceData , & geometry % dsdx % interior % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) CALL ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper ( physVector % boundary % deviceData , & compVector % boundary % deviceData , & geometry % dsdx % boundary % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) #else msg = \"GPU Acceleration currently not enabled in SELF\" WARNING ( msg ) #endif ELSE ! Assume that tensor(j,i) is vector i, component j ! => dot product is done along first dimension to ! project onto computational space DO iEl = 1 , physVector % nElem DO iVar = 1 , physVector % nVar DO k = 0 , physVector % N DO j = 0 , physVector % N DO i = 0 , physVector % N compVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) compVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) compVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) END DO END DO END DO END DO END DO ! Boundary Terms DO iEl = 1 , physVector % nElem DO iside = 1 , 6 DO iVar = 1 , physVector % nVar DO k = 0 , physVector % N DO j = 0 , physVector % N compVector % boundary % hostData ( 1 , j , k , iVar , iside , iEl ) = & geometry % dsdx % boundary % hostData ( 1 , 1 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 1 , j , k , iVar , iside , iEl ) + & geometry % dsdx % boundary % hostData ( 2 , 1 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 2 , j , k , iVar , iside , iEl ) + & geometry % dsdx % boundary % hostData ( 3 , 1 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 3 , j , k , iVar , iside , iEl ) compVector % boundary % hostData ( 2 , j , k , iVar , iside , iEl ) = & geometry % dsdx % boundary % hostData ( 1 , 2 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 1 , j , k , iVar , iside , iEl ) + & geometry % dsdx % boundary % hostData ( 2 , 2 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 2 , j , k , iVar , iside , iEl ) + & geometry % dsdx % boundary % hostData ( 3 , 2 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 3 , j , k , iVar , iside , iEl ) compVector % boundary % hostData ( 3 , j , k , iVar , iside , iEl ) = & geometry % dsdx % boundary % hostData ( 1 , 3 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 1 , j , k , iVar , iside , iEl ) + & geometry % dsdx % boundary % hostData ( 2 , 3 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 2 , j , k , iVar , iside , iEl ) + & geometry % dsdx % boundary % hostData ( 3 , 3 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 3 , j , k , iVar , iside , iEl ) ENDDO ENDDO ENDDO ENDDO ENDDO END IF END SUBROUTINE ContravariantProjection_MappedVector3D SUBROUTINE JacobianWeight_MappedVector3D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedVector3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL JacobianWeight_MappedVector3D_gpu_wrapper ( vector % interior % deviceData , & geometry % J % interior % deviceData , & vector % N , & vector % nVar , & vector % nElem ) #else msg = \"GPU Acceleration currently not enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO k = 0 , vector % N DO j = 0 , vector % N DO i = 0 , vector % N vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE JacobianWeight_MappedVector3D ! ---------------------- Tensors ---------------------- ! SUBROUTINE JacobianWeight_MappedTensor2D ( tensor , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedTensor2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedTensor2D ), INTENT ( inout ) :: tensor TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL JacobianWeight_MappedTensor2D_gpu_wrapper ( tensor % interior % deviceData , & geometry % J % interior % deviceData , & tensor % N , & tensor % nVar , & tensor % nElem ) #else msg = \"GPU Acceleration currently not enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) = tensor % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) tensor % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) = tensor % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) tensor % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) = tensor % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) tensor % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) = tensor % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE JacobianWeight_MappedTensor2D SUBROUTINE JacobianWeight_MappedTensor3D ( tensor , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedTensor3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedTensor3D ), INTENT ( inout ) :: tensor TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL JacobianWeight_MappedTensor3D_gpu_wrapper ( tensor % interior % deviceData , & geometry % J % interior % deviceData , & tensor % N , & tensor % nVar , & tensor % nElem ) #else msg = \"GPU Acceleration currently not enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO k = 0 , tensor % N DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE JacobianWeight_MappedTensor3D END MODULE SELF_MappedData","tags":"","loc":"sourcefile/self_mappeddata.f90.html"},{"title":"SELF_Mesh.f90 – SELF","text":"This file depends on sourcefile~~self_mesh.f90~~EfferentGraph sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_mesh.f90~~AfferentGraph sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_tests.f90 SELF_Tests.f90 sourcefile~self_tests.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_tests.f90->sourcefile~self_mappeddata.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_mpilayer.f90 SELF_MPILayer.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mesh.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mappeddata.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self.f90 SELF.f90 sourcefile~self.f90->sourcefile~self_tests.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Mesh Source Code SELF_Mesh.f90 Source Code MODULE SELF_Mesh USE SELF_Constants USE SELF_Lagrange USE SELF_Data USE SELF_SupportRoutines USE ISO_C_BINDING IMPLICIT NONE #include \"SELF_Macros.h\" ! ========================================================================= ! ! Node, Edge, Face, Element and Connectivity Standard ! ========================================================================= ! ! ! To define the element corner nodes, the side order and side connectivity, ! we follow the standard from CGNS SIDS (CFD General Notation System, ! Standard Interface Data Structures, http: //cgns.sourceforge.net/ ). ! ! Computational coordinate directions are defined as follows ! ! xi1 direction points from \"West\" (xi1=-1) to \"East\" (xi1=1) ! xi2 direction points from \"South\" (xi2=-1) to \"North\" (xi2=1) ! xi3 direction points from \"Bottom\" (xi3=-1) to \"Top\" (xi3=1) ! ! 2-D Hexahedreal Element sides are defined as ! ! Side 1 = South  (xi2 = -1) = [CN1, CN2] ! Side 2 = East   (xi1 = 1) = [CN2, CN3] ! Side 3 = North  (xi2 = 1) = [CN4, CN3] ! Side 4 = West   (xi1 = -1) = [CN1, CN4] ! ! 3-D Hexahedreal Element sides are defined as ! ! Side 1 = Bottom (xi3 = -1) = [CN1, CN4, CN3, CN2] ! Side 2 = South  (xi2 = -1) = [CN1, CN2, CN6, CN5] ! Side 3 = East   (xi1 = 1) = [CN2, CN3, CN7, CN6] ! Side 4 = North  (xi2 = 1) = [CN3, CN4, CN8, CN7] ! Side 5 = West   (xi1 = -1) = [CN1, CN5, CN8, CN4] ! Side 6 = Top    (xi3 = 1) = [CN5, CN6, CN7, CN8] ! ! In 2-D, corner nodes are order counter-clockwise (looking in the -xi3 direction). ! ! CornerNode 1 = South-West = (-1,-1) ! CornerNode 2 = South-East = ( 1,-1) ! CornerNode 3 = North-East = ( 1, 1) ! CornerNode 4 = North-West = (-1, 1) ! ! In 3-D, corner nodes are order counter-clockwise (looking in the -xi3 direction) from ! bottom to top. ! ! CornerNode 1 = Bottom-South-West = (-1,-1,-1) ! CornerNode 2 = Bottom-South-East = ( 1,-1,-1) ! CornerNode 3 = Bottom-North-East = ( 1, 1,-1) ! CornerNode 4 = Bottom-North-West = (-1, 1,-1) ! CornerNode 5 = Top-South-West = (-1,-1, 1) ! CornerNode 6 = Top-South-East = ( 1,-1, 1) ! CornerNode 7 = Top-North-East = ( 1, 1, 1) ! CornerNode 8 = Top-North-West = (-1, 1, 1) ! ! ! Notes: !  * cornerNode attributes have not been implemented yet ! !  * For line segments, quads, and hexes, Gauss-Lobatto quadrature is required ! ! ========================================================================= ! ! Element Types - From Table 4.1 of https://www.hopr-project.org/externals/Meshformat.pdf INTEGER , PARAMETER :: selfLineLinear = 1 INTEGER , PARAMETER :: selfLineNonlinear = 2 INTEGER , PARAMETER :: selfTriangleLinear = 3 INTEGER , PARAMETER :: selfQuadLinear = 4 INTEGER , PARAMETER :: selfQuadBilinear = 14 INTEGER , PARAMETER :: selfTriangleNonlinear = 23 INTEGER , PARAMETER :: selfQuadNonlinear = 24 INTEGER , PARAMETER :: selfTetrahedronLinear = 104 INTEGER , PARAMETER :: selfPyramidLinear = 105 INTEGER , PARAMETER :: selfPrismLinear = 106 INTEGER , PARAMETER :: selfHexahedronLinear = 108 INTEGER , PARAMETER :: selfPyramidBilinear = 115 INTEGER , PARAMETER :: selfPrismBilinear = 116 INTEGER , PARAMETER :: selfHexahedronBilinear = 118 INTEGER , PARAMETER :: selfTetrahedronNonlinear = 204 INTEGER , PARAMETER :: selfPyramidNonlinear = 205 INTEGER , PARAMETER :: selfPrismNonlinear = 206 INTEGER , PARAMETER :: selfHexahedronNonlinear = 208 ! INTEGER , PARAMETER :: selfMinNodalValence2D = 4 INTEGER , PARAMETER :: selfMinNodalValence3D = 8 INTEGER , PARAMETER :: selfMaxNodalValence2D = 6 INTEGER , PARAMETER :: selfMaxNodalValence3D = 10 ! Side Ordering INTEGER , PARAMETER :: selfSide2D_South = 1 INTEGER , PARAMETER :: selfSide2D_East = 2 INTEGER , PARAMETER :: selfSide2D_North = 3 INTEGER , PARAMETER :: selfSide2D_West = 4 INTEGER , PARAMETER :: selfSide3D_Bottom = 1 INTEGER , PARAMETER :: selfSide3D_South = 2 INTEGER , PARAMETER :: selfSide3D_East = 3 INTEGER , PARAMETER :: selfSide3D_North = 4 INTEGER , PARAMETER :: selfSide3D_West = 5 INTEGER , PARAMETER :: selfSide3D_Top = 6 TYPE , PUBLIC :: Mesh1D INTEGER :: nGeo INTEGER :: nElem INTEGER :: nNodes INTEGER :: nCornerNodes INTEGER :: nUniqueNodes INTEGER :: nBCs TYPE ( hfInt32_r2 ) :: elemInfo TYPE ( hfReal_r1 ) :: nodeCoords TYPE ( hfReal_r1 ) :: globalNodeIDs TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh1D PROCEDURE , PUBLIC :: Free => Free_Mesh1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh1D PROCEDURE , PUBLIC :: UniformBlockMesh => UniformBlockMesh_Mesh1D END TYPE Mesh1D ! Mesh format is set up as the HOPr format ! See https://hopr-project.org/externals/MeshFormat.pdf TYPE , PUBLIC :: Mesh2D INTEGER :: nGeo INTEGER :: nElem INTEGER :: nNodes INTEGER :: nSides INTEGER :: nCornerNodes INTEGER :: nUniqueNodes INTEGER :: nUniqueSides INTEGER :: nBCs TYPE ( hfInt32_r2 ) :: elemInfo TYPE ( hfInt32_r2 ) :: sideInfo TYPE ( hfReal_r2 ) :: nodeCoords TYPE ( hfReal_r1 ) :: globalNodeIDs TYPE ( hfInt32_r1 ) :: CGNSCornerMap TYPE ( hfInt32_r2 ) :: CGNSSideMap TYPE ( hfInt32_r2 ) :: curveNodeMap TYPE ( hfInt32_r2 ) :: curveNodeMapInv TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh2D PROCEDURE , PUBLIC :: Free => Free_Mesh2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh2D PROCEDURE , PUBLIC :: UniformBlockMesh => UniformBlockMesh_Mesh2D !    PROCEDURE, PUBLIC :: GenerateConnectivity => GenerateConnectivity_Mesh2D END TYPE Mesh2D TYPE , PUBLIC :: Mesh3D INTEGER :: nGeo INTEGER :: nElem INTEGER :: nNodes INTEGER :: nSides INTEGER :: nCornerNodes INTEGER :: nUniqueNodes INTEGER :: nUniqueSides INTEGER :: nBCs TYPE ( hfInt32_r2 ) :: elemInfo TYPE ( hfInt32_r2 ) :: sideInfo TYPE ( hfReal_r2 ) :: nodeCoords TYPE ( hfReal_r1 ) :: globalNodeIDs TYPE ( hfInt32_r1 ) :: CGNSCornerMap TYPE ( hfInt32_r2 ) :: CGNSSideMap TYPE ( hfInt32_r2 ) :: curveNodeMap TYPE ( hfInt32_r3 ) :: curveNodeMapInv TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh3D PROCEDURE , PUBLIC :: Free => Free_Mesh3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh3D PROCEDURE , PUBLIC :: UniformBlockMesh => UniformBlockMesh_Mesh3D !      PROCEDURE, PUBLIC :: LoadHOPRMesh => LoadHOPRMesh_3D ! !      PROCEDURE, PUBLIC :: Read_CGNSMesh !      PROCEDURE, PUBLIC :: Read_UCDMesh !      PROCEDURE, PUBLIC :: Read_TrellisUCDMesh ! !    PROCEDURE, PUBLIC :: GenerateConnectivity => GenerateConnectivity_Mesh3D END TYPE Mesh3D CONTAINS SUBROUTINE Init_Mesh1D ( myMesh , nGeo , nElem , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs myMesh % nGeo = nGeo myMesh % nElem = nElem myMesh % nNodes = nNodes myMesh % nCornerNodes = nElem * 2 myMesh % nUniqueNodes = 0 myMesh % nBCs = nBCs CALL myMesh % elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nElem / )) CALL myMesh % nodeCoords % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % globalNodeIDs % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) END SUBROUTINE Init_Mesh1D SUBROUTINE Free_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nNodes = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % elemInfo % Free () CALL myMesh % nodeCoords % Free () CALL myMesh % globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh1D SUBROUTINE UpdateHost_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh #ifdef GPU CALL myMesh % elemInfo % UpdateHost () CALL myMesh % nodeCoords % UpdateHost () CALL myMesh % globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () #endif END SUBROUTINE UpdateHost_Mesh1D SUBROUTINE UpdateDevice_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh #ifdef GPU CALL myMesh % elemInfo % UpdateDevice () CALL myMesh % nodeCoords % UpdateDevice () CALL myMesh % globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Mesh1D SUBROUTINE UniformBlockMesh_Mesh1D ( myMesh , nGeo , nElem , x ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem REAL ( prec ), INTENT ( in ) :: x ( 1 : 2 ) ! Local INTEGER :: iel INTEGER :: nid , nNodes INTEGER :: i REAL ( prec ) :: xU ( 1 : nElem + 1 ) TYPE ( Scalar1D ) :: xLinear TYPE ( Scalar1D ) :: xGeo nNodes = nElem * ( nGeo + 1 ) CALL myMesh % Init ( nGeo , nElem , nNodes , 2 ) ! Set the nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem + 1 ) ! Create a linear interpolant to interpolate to nGeo grid CALL xLinear % Init ( 1 , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nElem ) CALL xGeo % Init ( nGeo , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nElem ) DO iel = 1 , nElem xLinear % interior % hostData ( 0 : 1 , 1 , iel ) = xU ( iel : iel + 1 ) END DO CALL xLinear % GridInterp ( xGeo ,. FALSE .) ! Set the element information nid = 1 DO iel = 1 , nElem myMesh % eleminfo % hostData ( 1 , iel ) = selfLineLinear ! Element Type myMesh % eleminfo % hostData ( 2 , iel ) = 1 ! Element Zone myMesh % eleminfo % hostData ( 3 , iel ) = nid ! Node Index Start DO i = 0 , nGeo myMesh % nodeCoords % hostData ( nid ) = xGeo % interior % hostData ( i , 1 , iel ) nid = nid + 1 END DO myMesh % eleminfo % hostData ( 4 , iel ) = nid - 1 ! Node Index End END DO CALL myMesh % UpdateDevice () CALL xLinear % Free () CALL xGeo % Free () END SUBROUTINE UniformBlockMesh_Mesh1D SUBROUTINE Init_Mesh2D ( myMesh , nGeo , nElem , nSides , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nSides INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs ! Local INTEGER :: i , j , l myMesh % nGeo = nGeo myMesh % nElem = nElem myMesh % nNodes = nNodes myMesh % nSides = nSides myMesh % nCornerNodes = 0 myMesh % nUniqueNodes = 0 myMesh % nUniqueSides = 0 myMesh % nBCs = nBCs CALL myMesh % elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nElem / )) CALL myMesh % sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nSides / )) CALL myMesh % nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , nNodes / )) CALL myMesh % globalNodeIDs % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % CGNSCornerMap % Alloc ( loBound = 1 , & upBound = 4 ) CALL myMesh % CGNSSideMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , 4 / )) CALL myMesh % curveNodeMap % Alloc ( loBound = ( / 1 , 1 / ),& upBound = ( / 2 ,( nGeo + 1 ) ** 2 / )) CALL myMesh % curveNodeMapInv % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / nGeo , nGeo / )) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation myMesh % CGNSCornerMap % hostData ( 1 ) = 1 myMesh % CGNSCornerMap % hostData ( 2 ) = nGeo + 1 myMesh % CGNSCornerMap % hostData ( 3 ) = ( nGeo + 1 ) ** 2 myMesh % CGNSCornerMap % hostData ( 4 ) = nGeo * ( nGeo + 1 ) + 1 DO j = 0 , nGeo DO i = 0 , nGeo l = l + 1 myMesh % curveNodeMap % hostData ( 1 : 2 , l ) = ( / i , j / ) myMesh % curveNodeMapInv % hostData ( i , j ) = l ENDDO ENDDO ! Maps from local corner node id to CGNS side myMesh % CGNSSideMap % hostData ( 1 : 2 , 1 ) = ( / 1 , 2 / ) myMesh % CGNSSideMap % hostData ( 1 : 2 , 2 ) = ( / 2 , 3 / ) myMesh % CGNSSideMap % hostData ( 1 : 2 , 3 ) = ( / 4 , 3 / ) myMesh % CGNSSideMap % hostData ( 1 : 2 , 4 ) = ( / 1 , 4 / ) END SUBROUTINE Init_Mesh2D SUBROUTINE Free_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nNodes = 0 myMesh % nSides = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % elemInfo % Free () CALL myMesh % sideInfo % Free () CALL myMesh % nodeCoords % Free () CALL myMesh % CGNSCornerMap % Free () CALL myMesh % globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh2D SUBROUTINE UpdateHost_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh #ifdef GPU CALL myMesh % elemInfo % UpdateHost () CALL myMesh % sideInfo % UpdateHost () CALL myMesh % nodeCoords % UpdateHost () CALL myMesh % globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () #endif END SUBROUTINE UpdateHost_Mesh2D SUBROUTINE UpdateDevice_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh #ifdef GPU CALL myMesh % elemInfo % UpdateDevice () CALL myMesh % sideInfo % UpdateDevice () CALL myMesh % nodeCoords % UpdateDevice () CALL myMesh % globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Mesh2D !  SUBROUTINE GenerateConnectivity_Mesh2D(myMesh) !  ! Create the sideInfo information given eleminfo !  !  > Assumes quadrilateral mesh in 2-D !  !  > Assumes hexahedral mesh in 3-D !    IMPLICIT NONE !    CLASS(Mesh2D),INTENT(inout) :: myMesh ! !    ! Find matching nodes !    DO !    ! SideInfo !    ! !    !  SideType : Side Type encoding. The number of corner nodes is the last digit. !    !  GlobalSideID : Unique side ID global identifier !    ! !    !  nbElemID : Neighbor Element ID !    ! !    !  10*nbLocSide+Flip : first digit - local side of the connected neighbor element; last digit - Orientation between the sides !    !  (flip in [0,2]) !    ! !    !  BCID : Refers to the row index of the Boundary Condition List in BCNames/BCType array (in [1,nBCs]); = 0 for inner sides ! !    ! Nodes are assumed to be defined on gauss-lobatto points - This allows us to check if nodes are the same along boundary !    ! edges/faces ! !    ! Loop over elements, !    !   > Loop over local nodes !    !     > Loop over elements up to current element minus 1 !    !       > Loop over local nodes !    !         > Check for match with previous node !    !         > IF MATCH !    !           > Update Global Node ID to matched node Global Node ID !    !         > ELSE !    !           > Assign new global node id ! !    ! Loop over elements, !    !   > Loop over local sides !    !     > Assign side type (Assume line in 2-D) !    !     > Set nbElemID = current element ID !    !     > Set \"current local side\" as nbLocalSideID, \"0\" orientiation !    !     > Set the BCID = 0 !    !     > Save nodelist for this side !    ! !    !   > Loop over elements up to current element minus 1 !    !      > Check for match with previous side !    !      > IF MATCH !    !        > Update Global ID of secondary element !    !        > Set nbElemID for both elements; nbElemID of primary element is secondary element ID and vice-versa. !    !        > Set nbLocalSideID for local side of neighboring element ( !    !        > Update \"Flip\" of secondary element, relative to primary element ! ! !  END SUBROUTINE GenerateConnectivity_Mesh2D SUBROUTINE UniformBlockMesh_Mesh2D ( myMesh , nGeo , nElem , x ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem ( 1 : 2 ) REAL ( prec ), INTENT ( in ) :: x ( 1 : 4 ) ! Local INTEGER :: iel , jel , nEl , elid INTEGER :: sid , nid , nNodes INTEGER :: nSides INTEGER :: i , j REAL ( prec ) :: xU ( 1 : nElem ( 1 ) + 1 ) REAL ( prec ) :: yU ( 1 : nElem ( 2 ) + 1 ) TYPE ( Vector2D ) :: xLinear TYPE ( Vector2D ) :: xGeo nEl = nElem ( 1 ) * nElem ( 2 ) nNodes = nel * ( nGeo + 1 ) * ( nGeo + 1 ) nSides = ( nElem ( 1 ) + 1 ) * nElem ( 2 ) + ( nElem ( 2 ) + 1 ) * nElem ( 1 ) CALL myMesh % Init ( nGeo , nEl , nSides , nNodes , 1 ) ! Set the nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem ( 1 ) + 1 ) yU = UniformPoints ( x ( 3 ), x ( 4 ), 1 , nElem ( 2 ) + 1 ) ! Create a linear interpolant to interpolate to nGeo grid CALL xLinear % Init ( 1 , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) CALL xGeo % Init ( nGeo , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) elid = 1 DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) ! x component xLinear % interior % hostData ( 1 , 0 : 1 , 0 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 1 , 1 , elid ) = xU ( iel : iel + 1 ) ! y component xLinear % interior % hostData ( 2 , 0 , 0 : 1 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 1 , 0 : 1 , 1 , elid ) = yU ( jel : jel + 1 ) ! Incremenent the element ID elid = elid + 1 END DO END DO CALL xLinear % GridInterp ( xGeo ,. FALSE .) ! Set the element information nid = 1 sid = 0 elid = 1 DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) myMesh % eleminfo % hostData ( 1 , iel ) = selfQuadLinear ! Element Type myMesh % eleminfo % hostData ( 2 , iel ) = 1 ! Element Zone myMesh % eleminfo % hostData ( 3 , iel ) = sid ! Side Index Start sid = sid + 4 myMesh % eleminfo % hostData ( 4 , iel ) = sid ! Side Index End myMesh % eleminfo % hostData ( 5 , iel ) = nid - 1 ! Node Index Start DO j = 0 , nGeo DO i = 0 , nGeo myMesh % nodeCoords % hostData ( 1 : 2 , nid ) = xGeo % interior % hostData ( 1 : 2 , i , j , 1 , elid ) nid = nid + 1 END DO END DO myMesh % eleminfo % hostData ( 6 , iel ) = nid ! Node Index End elid = elid + 1 END DO END DO CALL myMesh % UpdateDevice () CALL xLinear % Free () CALL xGeo % Free () END SUBROUTINE UniformBlockMesh_Mesh2D SUBROUTINE Init_Mesh3D ( myMesh , nGeo , nElem , nSides , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nSides INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs ! Local INTEGER :: i , j , k , l myMesh % nElem = nElem myMesh % nGeo = nGeo myMesh % nSides = nSides myMesh % nNodes = nNodes myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = nBCs CALL myMesh % elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nElem / )) CALL myMesh % sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nSides / )) CALL myMesh % nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , nNodes / )) CALL myMesh % globalNodeIDs % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % CGNSCornerMap % Alloc ( loBound = 1 , & upBound = 8 ) CALL myMesh % CGNSSideMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , 6 / )) CALL myMesh % curveNodeMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 ,( nGeo + 1 ) ** 3 / )) CALL myMesh % curveNodeMapInv % Alloc ( loBound = ( / 0 , 0 , 0 / ), & upBound = ( / nGeo , nGeo , nGeo / )) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation myMesh % CGNSCornerMap % hostData ( 1 ) = 1 myMesh % CGNSCornerMap % hostData ( 2 ) = nGeo + 1 myMesh % CGNSCornerMap % hostData ( 3 ) = ( nGeo + 1 ) ** 2 myMesh % CGNSCornerMap % hostData ( 4 ) = nGeo * ( nGeo + 1 ) + 1 myMesh % CGNSCornerMap % hostData ( 5 ) = nGeo * ( nGeo + 1 ) ** 2 + 1 myMesh % CGNSCornerMap % hostData ( 6 ) = nGeo * ( nGeo + 1 ) ** 2 + ( nGeo + 1 ) myMesh % CGNSCornerMap % hostData ( 7 ) = ( nGeo + 1 ) ** 3 myMesh % CGNSCornerMap % hostData ( 8 ) = nGeo * ( nGeo + 1 ) * ( nGeo + 2 ) + 1 DO k = 0 , nGeo DO j = 0 , nGeo DO i = 0 , nGeo l = l + 1 myMesh % curveNodeMap % hostData ( 1 : 3 , l ) = ( / i , j , k / ) myMesh % curveNodeMapInv % hostData ( i , j , k ) = l ENDDO ENDDO ENDDO ! Maps from local corner node id to CGNS side myMesh % CGNSSideMap % hostData ( 1 : 4 , 1 ) = ( / 1 , 4 , 3 , 2 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 4 ) = ( / 3 , 4 , 8 , 7 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 5 ) = ( / 1 , 5 , 8 , 4 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) END SUBROUTINE Init_Mesh3D SUBROUTINE Free_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nSides = 0 myMesh % nNodes = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % elemInfo % Free () CALL myMesh % sideInfo % Free () CALL myMesh % nodeCoords % Free () CALL myMesh % CGNSCornerMap % Free () CALL myMesh % globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh3D SUBROUTINE UpdateHost_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh #ifdef GPU CALL myMesh % elemInfo % UpdateHost () CALL myMesh % sideInfo % UpdateHost () CALL myMesh % nodeCoords % UpdateHost () CALL myMesh % globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () #endif END SUBROUTINE UpdateHost_Mesh3D SUBROUTINE UpdateDevice_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh #ifdef GPU CALL myMesh % elemInfo % UpdateDevice () CALL myMesh % sideInfo % UpdateDevice () CALL myMesh % nodeCoords % UpdateDevice () CALL myMesh % globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Mesh3D SUBROUTINE UniformBlockMesh_Mesh3D ( myMesh , nGeo , nElem , x ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem ( 1 : 3 ) REAL ( prec ), INTENT ( in ) :: x ( 1 : 6 ) ! Local INTEGER :: iel , jel , kel , nEl , elid INTEGER :: sid , nid , nNodes INTEGER :: nSides INTEGER :: i , j , k REAL ( prec ) :: xU ( 1 : nElem ( 1 ) + 1 ) REAL ( prec ) :: yU ( 1 : nElem ( 2 ) + 1 ) REAL ( prec ) :: zU ( 1 : nElem ( 3 ) + 1 ) TYPE ( Vector3D ) :: xLinear TYPE ( Vector3D ) :: xGeo nEl = nElem ( 1 ) * nElem ( 2 ) * nElem ( 3 ) nNodes = nel * ( nGeo + 1 ) * ( nGeo + 1 ) * ( nGeo + 1 ) nSides = ( nElem ( 1 ) + 1 ) * nElem ( 2 ) * nElem ( 3 ) + & ( nElem ( 2 ) + 1 ) * nElem ( 1 ) * nElem ( 3 ) + & ( nElem ( 3 ) + 1 ) * nElem ( 1 ) * nElem ( 2 ) CALL myMesh % Init ( nGeo , nEl , nSides , nNodes , 1 ) ! Set the nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem ( 1 ) + 1 ) yU = UniformPoints ( x ( 3 ), x ( 4 ), 1 , nElem ( 2 ) + 1 ) zU = UniformPoints ( x ( 5 ), x ( 6 ), 1 , nElem ( 3 ) + 1 ) ! Create a linear interpolant to interpolate to nGeo grid CALL xLinear % Init ( 1 , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) CALL xGeo % Init ( nGeo , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) elid = 1 DO kel = 1 , nElem ( 3 ) DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) ! x component xLinear % interior % hostData ( 1 , 0 : 1 , 0 , 0 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 1 , 0 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 0 , 1 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 1 , 1 , 1 , elid ) = xU ( iel : iel + 1 ) ! y component xLinear % interior % hostData ( 2 , 0 , 0 : 1 , 0 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 1 , 0 : 1 , 0 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 0 , 0 : 1 , 1 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 1 , 0 : 1 , 1 , 1 , elid ) = yU ( jel : jel + 1 ) ! z component xLinear % interior % hostData ( 3 , 0 , 0 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) xLinear % interior % hostData ( 3 , 1 , 0 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) xLinear % interior % hostData ( 3 , 0 , 1 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) xLinear % interior % hostData ( 3 , 1 , 1 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) ! Incremenent the element ID elid = elid + 1 END DO END DO END DO CALL xLinear % GridInterp ( xGeo ,. FALSE .) ! Set the element information nid = 1 sid = 0 elid = 1 DO kel = 1 , nElem ( 3 ) DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) myMesh % eleminfo % hostData ( 1 , iel ) = selfQuadLinear ! Element Type myMesh % eleminfo % hostData ( 2 , iel ) = 1 ! Element Zone myMesh % eleminfo % hostData ( 3 , iel ) = sid ! Side Index Start sid = sid + 6 myMesh % eleminfo % hostData ( 4 , iel ) = sid ! Side Index End myMesh % eleminfo % hostData ( 5 , iel ) = nid - 1 ! Node Index Start DO k = 0 , nGeo DO j = 0 , nGeo DO i = 0 , nGeo myMesh % nodeCoords % hostData ( 1 : 3 , nid ) = xGeo % interior % hostData ( 1 : 3 , i , j , k , 1 , elid ) nid = nid + 1 END DO END DO END DO myMesh % eleminfo % hostData ( 6 , iel ) = nid ! Node Index End elid = elid + 1 END DO END DO END DO ! TO DO: Add Side information ! CALL myMesh % UpdateDevice () CALL xLinear % Free () CALL xGeo % Free () END SUBROUTINE UniformBlockMesh_Mesh3D END MODULE SELF_Mesh","tags":"","loc":"sourcefile/self_mesh.f90.html"},{"title":"SELF_Quadrature.f90 – SELF","text":"This file depends on sourcefile~~self_quadrature.f90~~EfferentGraph sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_quadrature.f90~~AfferentGraph sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_tests.f90 SELF_Tests.f90 sourcefile~self_tests.f90->sourcefile~self_quadrature.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_tests.f90->sourcefile~self_lagrange.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_tests.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_tests.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_tests.f90->sourcefile~self_mappeddata.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self.f90 SELF.f90 sourcefile~self.f90->sourcefile~self_tests.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mpilayer.f90 SELF_MPILayer.f90 sourcefile~self_mpilayer.f90->sourcefile~self_data.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mesh.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mappeddata.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Quadrature Source Code SELF_Quadrature.f90 Source Code ! SELF_Quadrature.f90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self-fluids@fluidnumerics.com ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! ! ! Contains routines from D.A. Kopriva, 2009, \"Implementing Spectral Methods for Partial ! Differential Equations: Algorithms for Scientists and Engineers\", Springer. ! ! Routines are defined for computing Legendre and Chebyshev Gauss and Gauss-Lobatto ! quadrature nodes and weights. MODULE SELF_Quadrature USE ISO_FORTRAN_ENV USE SELF_Constants IMPLICIT NONE PUBLIC :: ChebyshevQuadrature , LegendreQuadrature PRIVATE :: ChebyshevGauss , ChebyshevGaussLobatto , & LegendreGauss , LegendreGaussLobatto , & LegendreQandL CONTAINS ! =============================================================================================== ! ! LegendreQuadrature !   Returns the specified Legendre quadrature nodes and integration weights. ! !   Given a polynomial degree, and quadrature type (Gauss or Gauss Lobatto), this subroutine manages !   the calls to underlying private routines to generate the desired Legendre quadrature. ! !   Usage : ! !     INTEGER    :: N, quadType !     REAL(real64) :: nodes(0:N), weights(0:N) ! !       CALL LegendreQuadrature( N, quadType, nodes, weights ) ! !   Parameters : ! !     N (in) !       Degree of the quadrature ! !     quadType (in) !       Flag specifying the quadrature type. Can be set to GAUSS or GAUSS_LOBATTO ! !     nodes(0:N) (out) !       Array of quadrature nodes ! !     weights(0:N) (out) !       Array of quadrature weights ! ! =============================================================================================== ! SUBROUTINE LegendreQuadrature ( N , nodes , weights , QuadType ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N REAL ( prec ), INTENT ( out ) :: nodes ( 0 : N ) REAL ( prec ), INTENT ( out ) :: weights ( 0 : N ) INTEGER , INTENT ( in ) :: QuadType ! Local REAL ( real64 ) :: nodesLocal ( 0 : N ) REAL ( real64 ) :: weightsLocal ( 0 : N ) INTEGER :: i IF ( QuadType == GAUSS_LOBATTO ) THEN CALL LegendreGaussLobatto ( N , nodesLocal , weightsLocal ) ELSEIF ( QuadType == GAUSS ) THEN CALL LegendreGauss ( N , nodesLocal , weightsLocal ) END IF DO i = 0 , N nodes ( i ) = REAL ( nodesLocal ( i ), prec ) weights ( i ) = REAL ( weightsLocal ( i ), prec ) ENDDO END SUBROUTINE LegendreQuadrature ! =============================================================================================== ! ! ChebyshevQuadrature ! !   Returns the specified Chebyshev quadrature nodes and integration weights. ! !   Given a polynomial degree, and quadrature type (Gauss or Gauss Lobatto), this subroutine manages !   the calls to underlying private routines to generate the desired Chebyshev quadrature. ! !   Usage : ! !     INTEGER    :: N, quadType !     REAL(real64) :: nodes(0:N), weights(0:N) ! !       CALL ChebyshevQuadrature( N, quadType, nodes, weights ) ! !   Input/Output : ! !     N (in) !       Degree of the quadrature ! !     quadType (in) !       Flag specifying the quadrature type. Can be set to GAUSS or GAUSS_LOBATTO ! !     nodes(0:N) (out) !       Array of quadrature nodes ! !     weights(0:N) (out) !       Array of quadrature weights ! ! ================================================================================================ ! SUBROUTINE ChebyshevQuadrature ( N , quadType , nodes , weights ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N REAL ( real64 ), INTENT ( out ) :: nodes ( 0 : N ) REAL ( real64 ), INTENT ( out ) :: weights ( 0 : N ) INTEGER , INTENT ( in ) :: QuadType ! Local REAL ( real64 ) :: nodesLocal ( 0 : N ) REAL ( real64 ) :: weightsLocal ( 0 : N ) INTEGER :: i IF ( QuadType == GAUSS_LOBATTO ) then CALL ChebyshevGaussLobatto ( N , nodesLocal , weightsLocal ) ELSEIF ( QuadType == GAUSS ) then CALL ChebyshevGauss ( N , nodesLocal , weightsLocal ) END IF DO i = 0 , N nodes ( i ) = REAL ( nodesLocal ( i ), prec ) weights ( i ) = REAL ( weightsLocal ( i ), prec ) ENDDO END SUBROUTINE ChebyshevQuadrature ! =============================================================================================== ! ! S/R ChebyshevGauss !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 67 !   Algorithm 26 ! =============================================================================================== ! SUBROUTINE ChebyshevGauss ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local INTEGER :: j DO j = 0 , N weights ( j ) = pi / ( REAL ( N , real64 ) + 1.0_real64 ) nodes ( j ) = - cos ( 0.5_real64 * ( 2.0_real64 * REAL ( j , real64 ) + 1.0_real64 ) * weights ( j )) END DO END SUBROUTINE ChebyshevGauss ! =============================================================================================== ! ! S/R ChebyshevGaussLobatto !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 68 !   Algorithm 27 ! =============================================================================================== ! SUBROUTINE ChebyshevGaussLobatto ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! LOCAL INTEGER :: j DO j = 0 , N weights ( j ) = pi / REAL ( N , real64 ) nodes ( j ) = - cos ( REAL ( j , real64 ) * weights ( j )) END DO weights ( 0 ) = weights ( 0 ) * 0.5_real64 weights ( N ) = weights ( N ) * 0.5_real64 END SUBROUTINE ChebyshevGaussLobatto ! =============================================================================================== ! ! S/R LegendreGauss !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 64 !   Algorithm 23 ! =============================================================================================== ! SUBROUTINE LegendreGauss ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local REAL ( real64 ) :: nodes_local ( 0 : N ) REAL ( real64 ) :: weights_local ( 0 : N ) REAL ( real64 ) :: lN1 , dlN1 REAL ( real64 ) :: delta INTEGER :: j , kIt IF ( N == 0 ) then nodes_local ( 0 ) = 0.0_real64 weights_local ( 0 ) = 2.0_real64 ELSEIF ( N == 1 ) then nodes_local ( 0 ) = - SQRT ( 1.0_real64 / 3.0_real64 ) weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = - nodes ( 0 ) weights_local ( 1 ) = weights ( 0 ) ELSE DO j = 0 , (( N + 1 ) / 2 ) nodes_local ( j ) = - cos (( 2.0_real64 * REAL ( j , real64 ) + 1.0_real64 ) * pi / ( 2.0_real64 * REAL ( N , real64 ) + 1.0_real64 )) DO kIt = 1 , newtonMax CALL LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) delta = - lN1 / dlN1 nodes_local ( j ) = nodes_local ( j ) + delta IF ( abs ( delta ) <= TOL * nodes_local ( j )) EXIT END DO CALL LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) weights_local ( j ) = 2.0_real64 / (( 1.0_real64 - nodes_local ( j ) * nodes_local ( j )) * dlN1 * dlN1 ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) END DO END IF IF ( MOD ( REAL ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) then CALL LegendrePolynomial ( N + 1 , 0.0_real64 , lN1 , dlN1 ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0 / ( dlN1 * dlN1 ) END IF DO j = 0 , N nodes ( j ) = REAL ( nodes_local ( j ), real64 ) weights ( j ) = REAL ( weights_local ( j ), real64 ) END DO END SUBROUTINE LegendreGauss ! =============================================================================================== ! ! S/R LegendreGaussLobatto !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 66 !   Algorithm 25 ! =============================================================================================== ! SUBROUTINE LegendreGaussLobatto ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local REAL ( real64 ) :: nodes_local ( 0 : N ) REAL ( real64 ) :: weights_local ( 0 : N ) REAL ( real64 ) :: delta , q , qprime , lN INTEGER :: j , kIt IF ( N == 1 ) then nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = 1.0_real64 weights_local ( 1 ) = 1.0_real64 ELSE nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 )) nodes_local ( N ) = 1.0_real64 weights_local ( N ) = weights_local ( 0 ) DO j = 1 , (( N + 1 ) / 2 - 1 ) nodes_local ( j ) = - COS (( REAL ( j , real64 ) + 0.25_real64 ) * pi / REAL ( N , real64 ) - & 3.0_real64 / ( 8.0_real64 * REAL ( N , real64 ) * pi * ( REAL ( j , real64 ) + 0.25_real64 ))) DO kIt = 1 , newtonMax CALL LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) delta = - q / qprime nodes_local ( j ) = nodes_local ( j ) + delta IF ( ABS ( delta ) <= TOL * nodes_local ( j )) EXIT END DO CALL LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) weights_local ( j ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 ) * lN * lN ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) END DO END IF IF ( MOD ( REAL ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) THEN CALL LegendreQandL ( N , 0.0_real64 , q , qprime , lN ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 ) * lN * lN ) END IF DO j = 0 , N nodes ( j ) = REAL ( nodes_local ( j ), real64 ) weights ( j ) = REAL ( weights_local ( j ), real64 ) END DO END SUBROUTINE LegendreGaussLobatto ! =============================================================================================== ! ! S/R LegendrePolynomial !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 63 !   Algorithm 22 ! =============================================================================================== ! SUBROUTINE LegendrePolynomial ( N , x , lAtX , dLdxAtX ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: x REAL ( real64 ) :: lAtX , dLdxAtX ! Local REAL ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 INTEGER :: i IF ( N == 0 ) then lAtX = 1.0_real64 dLdxAtX = 0.0_real64 ELSEIF ( N == 1 ) then lAtX = x dLdxAtX = 1.0_real64 ELSE lnM2 = 1.0_real64 lnM1 = x dlnM2 = 0.0_real64 dlnM1 = 1.0_real64 DO i = 2 , N lAtX = (( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * x * lnM1 - & ( REAL ( i , real64 ) - 1.0_real64 ) * lnM2 ) / ( REAL ( i , real64 )) dldxAtX = dlnM2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lnM1 lnM2 = lnM1 lnM1 = lAtX dlnM2 = dlnM1 dlnM1 = dldxAtX END DO END IF END SUBROUTINE LegendrePolynomial ! =============================================================================================== ! ! S/R LegendreQandL !   From Kopriva (2009) \"Implementing Spectral Methods for Partial Differential Equations\", p. 65 !   Algorithm 24 ! =============================================================================================== ! SUBROUTINE LegendreQandL ( N , x , q , qprime , lN ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: x REAL ( real64 ) :: lN , q , qprime ! Local REAL ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 , dlN , lN1 , dlN1 INTEGER :: i lNm2 = 1.0_real64 lNm1 = x dlNm2 = 0.0_real64 dlNm1 = 1.0_real64 DO i = 2 , N lN = ( 2.0_real64 * i - 1.0_real64 ) / ( REAL ( i , real64 )) * x * lNm1 - ( REAL ( i , real64 ) - 1.0_real64 ) / ( REAL ( i , real64 )) * lNm2 dlN = dlNm2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lNm1 lNm2 = lNm1 lNm1 = lN dlNm2 = dlNm1 dlNm1 = dlN END DO i = N + 1 lN1 = ( 2.0_real64 * i - 1.0_real64 ) / ( REAL ( i , real64 )) * x * lN - ( REAL ( i , real64 ) - 1.0_real64 ) / ( REAL ( i , real64 )) * lNm2 dlN1 = dlNm2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lNm1 q = lN1 - lNm2 qprime = dlN1 - dlNm2 END SUBROUTINE LegendreQandL END MODULE SELF_Quadrature","tags":"","loc":"sourcefile/self_quadrature.f90.html"},{"title":"SELF_SupportRoutines.f90 – SELF","text":"This file depends on sourcefile~~self_supportroutines.f90~~EfferentGraph sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_supportroutines.f90~~AfferentGraph sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_tests.f90 SELF_Tests.f90 sourcefile~self_tests.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_tests.f90->sourcefile~self_mesh.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_tests.f90->sourcefile~self_lagrange.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_tests.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_tests.f90->sourcefile~self_mappeddata.f90 sourcefile~self.f90 SELF.f90 sourcefile~self.f90->sourcefile~self_supportroutines.f90 sourcefile~self.f90->sourcefile~self_tests.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_mpilayer.f90 SELF_MPILayer.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mesh.f90 sourcefile~self_mpilayer.f90->sourcefile~self_data.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mappeddata.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_SupportRoutines Source Code SELF_SupportRoutines.f90 Source Code ! SELF_SupportRoutines.f90 ! ! Copyright 2020 Fluid Numerics LLC ! Author : Joseph Schoonover (joe@fluidnumerics.com) ! Support : self-fluids@fluidnumerics.com ! ! //////////////////////////////////////////////////////////////////////////////////////////////// ! !> \\file SELF_SupportRoutines.f90 !! Contains the \\ref SELF_SupportRoutines module !> \\defgroup SELF_SupportRoutines SELF_SupportRoutines !! This module defines a set of general purpose routines. MODULE SELF_SupportRoutines USE ISO_FORTRAN_ENV USE SELF_Constants IMPLICIT NONE CONTAINS FUNCTION Int2Str ( aNumber ) RESULT ( aString ) IMPLICIT NONE INTEGER :: aNumber CHARACTER ( 12 ) :: aString WRITE ( aString , '(I9)' ) aNumber END FUNCTION Int2Str FUNCTION Float2Str ( aNumber ) RESULT ( aString ) IMPLICIT NONE REAL ( prec ) :: aNumber CHARACTER ( 12 ) :: aString WRITE ( aString , '(E12.4)' ) aNumber END FUNCTION Float2Str !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! Function AlmostEqual ! !> \\fn AlmostEqual !! Compares two floating point numbers and determines if they are equal (to machine precision). !! !!   This function is from Alg. 139 on pg. 359 of D.A. Kopriva, 2009, \"Implementing Spectral Element !!    Methods for Scientists and Engineers\" !! !! <H2> Usage : </H2> !! <B>Logical</B> :: AisB <BR> !! <B>REAL</B>(prec) :: a, b <BR> !!         .... <BR> !!     AisB = AlmostEqual( a, b ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> a <td> REAL(prec) <td> scalar !!   <tr> <td> in <th> b <td> REAL(prec) <td> scalar !!   <tr> <td> in <th> AisB <td> Logical <td> !!                     <B>.TRUE.</B> IF a=b to machine precision <BR> !!                     <B>.FALSE.</B> otherwise !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION AlmostEqual ( a , b ) RESULT ( AisB ) IMPLICIT NONE REAL ( real64 ) :: a , b LOGICAL :: AisB IF ( a == 0.0_real64 . OR . b == 0.0_real64 ) THEN IF ( ABS ( a - b ) <= EPSILON ( 1.0_real64 )) THEN AisB = . TRUE . ELSE AisB = . FALSE . END IF ELSE IF (( abs ( a - b ) <= EPSILON ( 1.0_real64 ) * abs ( a )) . OR . ( abs ( a - b ) <= EPSILON ( 1.0_real64 ) * abs ( b ))) THEN AisB = . TRUE . ELSE AisB = . FALSE . END IF END IF END FUNCTION AlmostEqual ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R InsertionSort ! !> \\fn InsertionSort !! Sorts an array of integers from smallest to largest using the insertion-sort algorithm. !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: N <BR> !! <B>INTEGER</B> :: inArray(1:N) <BR> !! <B>INTEGER</B> :: outArray(1:N) <BR> !!         .... <BR> !!     <B>CALL</B> InsertionSort( inArray, outArray, N ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> N <td> INTEGER <td> !!                     The number of elements in the input and output arrays !!   <tr> <td> in <th> inArray(1:N) <td> INTEGER <td> !!                     Array of unsorted integers. !!   <tr> <td> out <th> outArray <td> INTEGER <td> !!                      Array of integers, sorted from most negative to most positive numbers. !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE InsertionSort ( inArray , outArray , N ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: inArray ( 1 : N ) INTEGER , INTENT ( out ) :: outArray ( 1 : N ) ! LOCAL INTEGER :: i , j INTEGER :: temp outArray = inArray DO i = 2 , N j = i DO WHILE ( j > 1 ) IF ( outArray ( j - 1 ) > outArray ( j )) THEN !Swap outArray(j) outArray(j-1) temp = outArray ( j ) outArray ( j ) = outArray ( j - 1 ) outArray ( j - 1 ) = temp j = j - 1 ELSE EXIT END IF END DO END DO END SUBROUTINE InsertionSort ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R SortArray ! !> \\fn SortArray !! Sorts a REAL(prec) array from smallest absolute value to largest absolute value. !! !! <H2> Usage : </H2> !! <B>REAL</B>(prec) :: myArray(low:high) <BR> !! <B>INTEGER</B>    :: low, high <BR> !!         .... <BR> !!     <B>CALL</B> SortArray( myArray, low, high ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myArray(low:high) <td> REAL(prec) <td> !!                         On <B>input</B> Unsorted array of floating point values <BR> !!                         On <B>output</B> Sorted array of floating point values, arranged in order !!                         of increasing absolute value. !!   <tr> <td> in <th> low <td> INTEGER <td> !!                     Lower bound of the input and output arrays !!   <tr> <td> in <th> high <td> INTEGER <td> !!                     Upper bound of the input and output arrays !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE SortArray ( myArray , low , high ) IMPLICIT NONE INTEGER , INTENT ( in ) :: low , high REAL ( prec ), INTENT ( inout ) :: myArray ( low : high ) ! LOCAL INTEGER :: locOfMin INTEGER :: ind REAL ( prec ) :: temp DO ind = low , high - 1 locOfMin = MINLOC ( abs ( myArray ( ind : high )), 1 ) + low - 1 + ind temp = myArray ( ind ) myArray ( ind ) = myArray ( locOfMin ) myArray ( locOfMin ) = temp END DO END SUBROUTINE SortArray ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R SortAndSum ! !> \\fn SortAndSum !! Computes the sum of an array by first sorting the array from smallest absolute value to largest !! absolute value. !! !! When computing the sum of an array of floating point values, round-off errors can be reduced !! by adding from the smallest to largest values. <BR> !! !! This subroutine depends on <BR> !!    Subroutine \\ref sortarray !! !! <H2> Usage : </H2> !! <B>REAL</B>(prec) :: myArray(low:high) <BR> !! <B>REAL</B>(prec) :: arraySum <BR> !! <B>INTEGER</B>    :: low, high <BR> !!         .... <BR> !!     <B>CALL</B> SortAndSum( myArray, low, high, arraySum ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myArray(low:high) <td> REAL(prec) <td> !!                         On <B>input</B> Unsorted array of floating point values <BR> !!                         On <B>output</B> Sorted array of floating point values, arranged in order !!                         of increasing absolute value. !!   <tr> <td> in <th> low <td> INTEGER <td> !!                     Lower bound of the input and output arrays !!   <tr> <td> in <th> high <td> INTEGER <td> !!                     Upper bound of the input and output arrays !!   <tr> <td> out <th> arraySum <td> REAL(prec) <td> !!                     Sum of the array components. !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE SortAndSum ( myArray , low , high , arraysum ) IMPLICIT NONE INTEGER , INTENT ( in ) :: low , high REAL ( prec ), INTENT ( inout ) :: myArray ( low : high ) REAL ( prec ), INTENT ( out ) :: arraysum ! LOCAL INTEGER :: ind CALL SortArray ( myArray , low , high ) arraysum = 0.0_prec DO ind = low , high arraysum = arraysum + myArray ( ind ) END DO END SUBROUTINE SortAndSum ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R ReverseArray ! !> \\fn ReverseArray !! Reverses the order of a REAL(prec) array. !! !! <H2> Usage : </H2> !! <B>REAL</B>(prec) :: myArray(low:high) <BR> !! <B>INTEGER</B>    :: low, high <BR> !!         .... <BR> !!     <B>CALL</B> ReverseArray( myArray, low, high ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myArray(low:high) <td> REAL(prec) <td> !!                         On <B>output</B>, the input array in reverse order . !!   <tr> <td> in <th> low <td> INTEGER <td> !!                     Lower bound of the input and output arrays !!   <tr> <td> in <th> high <td> INTEGER <td> !!                     Upper bound of the input and output arrays !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE ReverseArray ( myArray , low , high ) IMPLICIT NONE INTEGER , INTENT ( in ) :: low , high REAL ( prec ), INTENT ( inout ) :: myArray ( low : high ) ! LOCAL REAL ( prec ) :: temp ( low : high ) INTEGER :: i , j temp = myArray j = high DO i = low , high myArray ( i ) = temp ( j ) j = j - 1 END DO END SUBROUTINE ReverseArray ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R ForwardShift ! !> \\fn ForwardShift !! Shift an array integers by one index forward, moving the last index to the first. !! !! Shifts the array entries as follows : <BR> !!  myArray(1) <-- myArray(N) <BR> !!  myArray(2) <-- myArray(1) <BR> !!  myArray(3) <-- myArray(2) <BR> !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: N !! <B>INTEGER</B> :: myArray(1:N) <BR> !!         .... <BR> !!     <B>CALL</B> ForwardShift( myArray, N ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in/out <th> myArray(1:N) <td> INTEGER <td> !!                         On <B>output</B>, the input array with elements shifted forward by !!                         one index. !!   <tr> <td> in <th> N <td> INTEGER <td> !!                     The number of elements in the array !!  </table> !! ! ================================================================================================ ! !>@} SUBROUTINE ForwardShift ( myArray , N ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( inout ) :: myArray ( 1 : N ) ! LOCAL INTEGER :: temp ( 1 : N ) temp = myArray myArray ( 1 ) = temp ( N ) myArray ( 2 : N ) = temp ( 1 : N - 1 ) END SUBROUTINE ForwardShift ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R CompareArray ! !> \\fn CompareArray !! Compares to INTEGER arrays and determines if they are identical. !! !! A logical is returned that specifies whether or not two arrays are identical. To determine !! if the two arrays are identical, the sum of the difference between each element in the input !! array is calculated. If the arrays are identical, each contribution to the sum is zero and hence !! the sum is zero. If the sum is non-zero, the arrays are distinct. !! !! This routine is used in the \\ref HexMeshClass module. A face of an element in an unstructured !! mesh is identified by its four corner nodes. When identifying unique faces in an unstructured !! mesh, we need to determine if two elements share a face. This can be accomplished by comparing !! the four corner nodes (from each element) that define each face. !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: N <BR> !! <B>INTEGER</B> :: arrayOne(1:N) <BR> !! <B>INTEGER</B> :: arrayTwo(1:N) <BR> !! <B>LOGICAL</B> :: arraysMatch <BR> !!         .... <BR> !!     arraysMatch = CompareArray( arrayOne, arrayTwo, N ) <BR> !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> arrayOne(1:N) <td> INTEGER <td> !!   <tr> <td> in <th> arrayTwo(1:N) <td> INTEGER <td> !!   <tr> <td> in <th> N <td> INTEGER <td> !!   <tr> <td> out <th> arraysMatch <td> INTEGER <td> !! !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION CompareArray ( arrayOne , arrayTwo , N ) RESULT ( arraysMatch ) IMPLICIT NONE INTEGER :: N INTEGER :: arrayOne ( 1 : N ), arrayTwo ( 1 : N ) LOGICAL :: arraysMatch ! LOCAL INTEGER :: i , theSumOfDiffs theSumOfDiffs = 0 DO i = 1 , N theSumOfDiffs = theSumOfDiffs + arrayOne ( i ) - arrayTwo ( i ) END DO IF ( theSumOfDiffs == 0 ) THEN arraysMatch = . TRUE . ELSE arraysMatch = . FALSE . END IF END FUNCTION CompareArray ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R NewUnit ! !> \\fn NewUnit !! Returns a file unit identifier that is currently not in use. !! !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: thisUnit <BR> !!         .... <BR> !!     <B>OPEN</B>( UNIT=NewUnit(thisUnit), FILE=filename) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> out <th> thisunit <td> INTEGER <td> File unit that is not in use !!  </table> !! ! ================================================================================================ ! !>@} INTEGER FUNCTION NewUnit ( thisunit ) IMPLICIT NONE INTEGER , INTENT ( out ), OPTIONAL :: thisunit ! Local INTEGER , PARAMETER :: unitMin = 100 , unitMax = 1000 LOGICAL :: isopened INTEGER :: iUnit newunit = - 1 DO iUnit = unitMin , unitMax ! Check to see IF this UNIT is opened INQUIRE ( UNIT = iUnit , opened = isopened ) IF (. not . isopened ) THEN newunit = iUnit EXIT END IF END DO IF ( PRESENT ( thisunit )) thisunit = newunit END FUNCTION NewUnit ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R UniformPoints ! !> \\fn UniformPoints !! Generates a REAL(prec) array of N points evenly spaced between two points. !! !! !! <H2> Usage : </H2> !! <B>REAL</B>(prec) :: a <BR> !! <B>REAL</B>(prec) :: b <BR> !! <B>REAL</B>(prec) :: xU(0:N) <BR> !! <B>INTEGER</B> :: N <BR> !!         .... <BR> !!     xU = UniformPoints( a, b, N ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> a <td> REAL(prec) <td> Starting point of the interval !!   <tr> <td> in <th> b <td> REAL(prec) <td> Ending point of the interval !!   <tr> <td> in <th> N <td> INTEGER <td> The number of points in the interval \\f$[a,b]\\f$ !!   <tr> <td> in <th> xU(0:N) <td> REAL(prec) <td> !!                     Array of evenly spaced points in the interval \\f$[a,b]\\f$ !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION UniformPoints ( a , b , firstInd , lastInd ) RESULT ( xU ) IMPLICIT NONE REAL ( prec ) :: a , b INTEGER :: firstInd , lastInd REAL ( prec ) :: xU ( firstInd : lastInd ) ! LOCAL REAL ( prec ) :: dx INTEGER :: i dx = ( b - a ) / REAL (( lastInd - firstInd ), prec ) DO i = firstInd , lastInd xU ( i ) = a + dx * REAL ( i - firstInd , prec ) END DO END FUNCTION UniformPoints ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! S/R Determinant ! !> \\fn Determinant !! A recursive function that calculates the determinant of an \\f$ N\\times N \\f$ matrix. !! !! This function is used in the functions \\ref invert_2x2 and \\ref invert_3x3 <BR> !! !! This function depends on <BR> !!    Function \\ref getminor !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: N !! <B>REAL</B>(prec) :: A(1:N,1:N), D <BR> !!         .... <BR> !!     D = Determinant( A, N ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> A(1:N,1:N) <td> REAL(prec) <td> Square matrix !!   <tr> <td> in <th> N <td> INTEGER <td> Dimension of the matrix !!   <tr> <td> out <th> detA <td> REAL(prec) <td> The determinant of the matrix !!  </table> !! ! ================================================================================================ ! !>@} RECURSIVE FUNCTION Determinant ( A , N ) RESULT ( D ) IMPLICIT NONE INTEGER :: N REAL ( prec ) :: A ( 1 : N , 1 : N ) REAL ( prec ) :: D ! LOCAL REAL ( prec ) :: M ( 1 : N - 1 , 1 : N - 1 ) INTEGER :: j IF ( N == 2 ) THEN D = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) RETURN ELSE D = 0.0_prec DO j = 1 , N M = GetMinor ( A , 1 , j , N ) D = D + ( - 1.0_prec ) ** ( j + 1 ) * A ( 1 , j ) * Determinant ( M , N - 1 ) END DO END IF END FUNCTION Determinant ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! Function GetMinor ! !> \\fn GetMinor !! Returns the submatrix obtained by removing a given row and column of the input matrix. !! !! The minor of a matrix is used in calculating the determinant of a matrix. !! !! <H2> Usage : </H2> !! <B>INTEGER</B> :: i, j, N <BR> !! <B>REAL</B>(prec) :: A(1:N,1:N), M(1:N-1,1:N-1) <BR> !!         .... <BR> !!     M = GetMinor( A, i, j, N ) <BR> !! !! <H2> Usage : </H2> !! <B>TYPE</B>(DataType) :: this <BR> !!         .... <BR> !!     <B>CALL</B> this % RoutineName( Inputs/Outputs ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> A(1:N,1:N) <td> REAL(prec) <td> Square matrix !!   <tr> <td> in <th> i <td> INTEGER <td> The row that is removed from A to form the minor of A !!   <tr> <td> in <th> j <td> INTEGER <td> The column that is removed from A to form the minor of A !!   <tr> <td> in <th> N <td> INTEGER <td> The dimension of A !!   <tr> <td> in <th> M(1:N-1,1:N-1) <td> REAL(prec) <td> The (i,j) minor of A !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION GetMinor ( A , i , j , N ) RESULT ( M ) IMPLICIT NONE INTEGER :: i , j , N REAL ( prec ) :: A ( 1 : N , 1 : N ) REAL ( prec ) :: M ( 1 : N - 1 , 1 : N - 1 ) ! LOCAL INTEGER :: row , col INTEGER :: thisRow , thisCol thisRow = 0 DO row = 1 , N ! loop over the rows of A IF ( row /= i ) THEN thisRow = thisRow + 1 thisCol = 0 DO col = 1 , N ! loop over the columns of A IF ( col /= j ) THEN thisCol = thisCol + 1 M ( thisRow , thisCol ) = A ( row , col ) END IF END DO ! col, loop over the columns of A END IF END DO ! row, loop over the rows of A END FUNCTION GetMinor ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! Function Invert_2x2 ! !> \\fn Invert_2x2 !!  Computes the inverse of a 2x2 matrix using Kramer's rule. !! !! This Function depends on <BR> !! \\ref determinant !! !! <H2> Usage : </H2> !! <B>REAL</B>(prec) :: A(1:2,1:2), Ainv(1:2,1:2) <BR> !!         .... <BR> !!     Ainv = Invert_2x2( A ) <BR> !! !!  <H2> Parameters : </H2> !!  <table> !!   <tr> <td> in <th> A(1:2,1:2) <td> REAL(prec) <td> Real 2x2 matrix !!   <tr> <td> in <th> Ainv(1:2,1:2) <td> REAL(prec) <td> Real 2x2 matrix, inverse of A !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION Invert_2x2 ( A ) RESULT ( Ainv ) IMPLICIT NONE REAL ( prec ) :: A ( 1 : 2 , 1 : 2 ) REAL ( prec ) :: Ainv ( 1 : 2 , 1 : 2 ) ! LOCAL REAL ( prec ) :: detA detA = Determinant ( A , 2 ) Ainv ( 1 , 1 ) = A ( 2 , 2 ) / detA Ainv ( 2 , 2 ) = A ( 1 , 1 ) / detA Ainv ( 1 , 2 ) = - A ( 1 , 2 ) / detA Ainv ( 2 , 1 ) = - A ( 2 , 1 ) / detA END FUNCTION Invert_2x2 ! !> \\addtogroup SELF_SupportRoutines !! @{ ! ================================================================================================ ! ! Function Invert_3x3 ! !> \\fn Invert_3x3 !!  Computes the inverse of a 3x3 matrix using Kramer's rule. !! !! This Function depends on <BR> !! \\ref determinant !! !! <H3> Usage : </H3> !! <B>REAL</B>(prec) :: A(1:3,1:3), Ainv(1:3,1:3) <BR> !!         .... <BR> !!     Ainv = Invert_3x3( A ) <BR> !! !!  <H3> Parameters : </H3> !!  <table> !!   <tr> <td> in <th> A(1:3,1:3) <td> REAL(prec) <td> Real 3x3 matrix !!   <tr> <td> in <th> Ainv(1:3,1:3) <td> REAL(prec) <td> Real 3x3 matrix, inverse of A !!  </table> !! ! ================================================================================================ ! !>@} FUNCTION Invert_3x3 ( A ) RESULT ( Ainv ) ! ! =============================================================================================== ! IMPLICIT NONE REAL ( prec ) :: A ( 1 : 3 , 1 : 3 ) REAL ( prec ) :: Ainv ( 1 : 3 , 1 : 3 ) ! LOCAL REAL ( prec ) :: detA REAL ( prec ) :: submat ( 1 : 2 , 1 : 2 ) REAL ( prec ) :: detSubmat detA = Determinant ( A , 3 ) ! Row 1 column 1 of inverse (use submatrix neglecting row 1 and column 1 of A) submat = A ( 2 : 3 , 2 : 3 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 1 , 1 ) = detSubmat / detA ! Row 1 column 2 of inverse (use submatrix neglecting row 2 and column 1 of A) submat = A ( 1 : 3 : 2 , 2 : 3 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 1 , 2 ) = - detSubmat / detA ! Row 1 column 3 of inverse (use submatrix neglecting row 3 and column 1 of A) submat = A ( 1 : 2 , 2 : 3 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 1 , 3 ) = detSubmat / detA ! Row 2 column 1 of inverse (use submatrix neglecting row 1 and column 2 of A) submat = A ( 2 : 3 , 1 : 3 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 2 , 1 ) = - detSubmat / detA ! Row 2 column 2 of inverse (use submatrix neglecting row 2 and column 2 of A) submat = A ( 1 : 3 : 2 , 1 : 3 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 2 , 2 ) = detSubmat / detA ! Row 2 column 3 of inverse (use submatrix neglecting row 3 and column 2 of A) submat = A ( 1 : 2 , 1 : 3 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 2 , 3 ) = - detSubmat / detA ! Row 3 column 1 of inverse (use submatrix neglecting row 1 and column 3 of A) submat = A ( 2 : 3 , 1 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 3 , 1 ) = detSubmat / detA ! Row 3 column 2 of inverse (use submatrix neglecting row 2 and column 3 of A) submat = A ( 1 : 3 : 2 , 1 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 3 , 2 ) = - detSubmat / detA ! Row 3 column 3 of inverse (use submatrix neglecting row 3 and column 3 of A) submat = A ( 1 : 2 , 1 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 3 , 3 ) = detSubmat / detA END FUNCTION Invert_3x3 ! FUNCTION InvertSpectralOpMatrix ( A , N ) RESULT ( Ainv ) ! Inverts an (N+1)x(N+1) matrix using a polynomial representation of the ! inverse IMPLICIT NONE INTEGER :: N REAL ( prec ) :: A ( 0 : N , 0 : N ) REAL ( prec ) :: Ainv ( 0 : N , 0 : N ) ! Local INTEGER :: row , col , j , iter REAL ( prec ) :: I ( 0 : N , 0 : N ) REAL ( prec ) :: Ainv_ij , maxChange Ainv = 0.0_prec I = 0.0_prec DO row = 0 , N Ainv ( row , row ) = 1.0_prec I ( row , row ) = 1.0_prec END DO DO iter = 1 , maxInverseIters maxChange = 0.0_prec DO col = 0 , N DO row = 0 , N Ainv_ij = 0.0_prec DO j = 0 , N Ainv_ij = Ainv_ij + Ainv ( j , col ) * ( I ( row , j ) - A ( row , j )) END DO maxChange = MAX ( ABS ( Ainv ( row , col ) - Ainv_ij ), maxChange ) Ainv ( row , col ) = Ainv_ij END DO END DO IF ( maxChange <= tolerance ) THEN PRINT * , ' InvertSpectralOpMatrix : Converged in ' , iter , ' iterations.' EXIT END IF END DO IF ( maxChange > tolerance ) THEN PRINT * , 'InvertSpectralOpMatrix : Did not converge.' , maxChange END IF END FUNCTION InvertSpectralOpMatrix ! FUNCTION UpperCase ( str ) RESULT ( upper ) Implicit None CHARACTER ( * ), INTENT ( In ) :: str CHARACTER ( LEN ( str )) :: Upper INTEGER :: ic , i CHARACTER ( 27 ), PARAMETER :: cap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ ' CHARACTER ( 27 ), PARAMETER :: low = 'abcdefghijklmnopqrstuvwxyz ' DO i = 1 , LEN ( str ) ic = INDEX ( low , str ( i : i )) IF ( ic > 0 ) THEN Upper ( i : i ) = cap ( ic : ic ) ELSE Upper ( i : i ) = str ( i : i ) END IF END DO END FUNCTION UpperCase ! FUNCTION TimeStamp ( time , units ) RESULT ( timeStampString ) IMPLICIT NONE REAL ( prec ) :: time CHARACTER ( 1 ) :: units CHARACTER ( 13 ) :: timeStampString ! Local INTEGER :: day , minute , hour , second , millisecond CHARACTER ( 4 ) :: dayStamp CHARACTER ( 2 ) :: hourStamp , minuteStamp , secondStamp CHARACTER ( 3 ) :: milliSecondStamp REAL ( real64 ) :: time_real64 time_real64 = REAL ( time , real64 ) ! Units in \"seconds\" IF ( units ( 1 : 1 ) == 's' ) THEN ! Obtain the day day = INT ( time_real64 / 8640 0.0_real64 ) hour = INT (( time_real64 & - 8640 0.0_real64 * day ) / 360 0.0_real64 ) minute = INT (( time_real64 & - 360 0.0_real64 * hour & - 8640 0.0_real64 * day ) / 6 0.0_real64 ) second = INT (( time_real64 & - 6 0.0_real64 * minute & - 360 0.0_real64 * hour & - 8640 0.0_real64 * day )) milliSecond = NINT ((( time_real64 & - 6 0.0_real64 * minute & - 360 0.0_real64 * hour & - 8640 0.0_real64 * day ) & - REAL ( second , real64 )) * 100 0.0_real64 ) WRITE ( dayStamp , '(I4.4)' ) day WRITE ( hourStamp , '(I2.2)' ) hour WRITE ( minuteStamp , '(I2.2)' ) minute WRITE ( secondStamp , '(I2.2)' ) second WRITE ( milliSecondStamp , '(I3.3)' ) millisecond timeStampString = dayStamp // hourStamp // minuteStamp // secondStamp // milliSecondStamp ! minutes ELSEIF ( units ( 1 : 1 ) == 'm' ) THEN ! hours ELSEIF ( units ( 1 : 1 ) == 'h' ) THEN END IF END FUNCTION TimeStamp LOGICAL FUNCTION IsNaN ( a ) IMPLICIT NONE REAL ( prec ) :: a IF ( a . ne . a ) THEN IsNaN = . TRUE . ELSE IsNaN = . FALSE . END IF RETURN END FUNCTION IsNaN LOGICAL FUNCTION IsInf ( a ) IMPLICIT NONE REAL ( prec ) :: a IF ( a > HUGE ( prec )) THEN IsInf = . TRUE . ELSE IsInf = . FALSE . END IF RETURN END FUNCTION IsInf FUNCTION FloorSQRT ( x ) RESULT ( sqrtX ) INTEGER :: x , sqrtX ! Local INTEGER :: i , res IF ( x == 0 . OR . x == 1 ) THEN sqrtX = x ELSE res = 1 i = 1 DO WHILE ( res <= x ) i = i + 1 res = i * i END DO sqrtX = i - 1 END IF END FUNCTION FloorSQRT FUNCTION FloorCURT ( x ) RESULT ( curtX ) INTEGER :: x , curtX ! Local INTEGER :: i , res IF ( x == 0 . OR . x == 1 ) THEN curtX = x ELSE res = 1 i = 1 DO WHILE ( res <= x ) i = i + 1 res = i * i * i END DO curtX = i - 1 END IF END FUNCTION FloorCURT END MODULE SELF_SupportRoutines","tags":"","loc":"sourcefile/self_supportroutines.f90.html"},{"title":"SELF_Tests.f90 – SELF","text":"This file depends on sourcefile~~self_tests.f90~~EfferentGraph sourcefile~self_tests.f90 SELF_Tests.f90 sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_tests.f90->sourcefile~self_memory.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_tests.f90->sourcefile~self_data.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_tests.f90->sourcefile~self_constants.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_tests.f90->sourcefile~self_mappeddata.f90 sourcefile~self_supportroutines.f90 SELF_SupportRoutines.f90 sourcefile~self_tests.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_tests.f90->sourcefile~self_mesh.f90 sourcefile~self_quadrature.f90 SELF_Quadrature.f90 sourcefile~self_tests.f90->sourcefile~self_quadrature.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_tests.f90->sourcefile~self_lagrange.f90 sourcefile~self_quadrature.f90->sourcefile~self_constants.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_constants.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_supportroutines.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90->sourcefile~self_supportroutines.f90 sourcefile~self_mesh.f90->sourcefile~self_constants.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_constants.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self_lagrange.f90->sourcefile~self_constants.f90 sourcefile~self_lagrange.f90->sourcefile~self_quadrature.f90 sourcefile~self_lagrange.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_constants.f90 sourcefile~self_geometry.f90->sourcefile~self_supportroutines.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_tests.f90~~AfferentGraph sourcefile~self_tests.f90 SELF_Tests.f90 sourcefile~self.f90 SELF.f90 sourcefile~self.f90->sourcefile~self_tests.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Tests Source Code SELF_Tests.f90 Source Code MODULE SELF_Tests USE SELF_Constants USE SELF_Memory USE SELF_SupportRoutines USE SELF_Quadrature USE SELF_Lagrange USE SELF_Data USE SELF_Mesh USE SELF_MappedData USE FEQParse IMPLICIT NONE #include \"SELF_Macros.h\" CONTAINS SUBROUTINE BlockMesh1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , tolerance , error ) #undef __FUNC__ #define __FUNC__ \"BlockMesh1D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem REAL ( prec ), INTENT ( in ) :: tolerance INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh1D ) :: mesh TYPE ( Geometry1D ) :: geometry REAL ( prec ) :: expect_dxds , dxds_error , expect_boundx , boundx_error INTEGER :: iel , i error = 0 INFO ( 'Number of elements : ' // Int2Str ( nElem )) INFO ( 'Control point degree : ' // Int2Str ( cqDegree )) INFO ( 'Target point degree : ' // Int2Str ( tqDegree )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) CALL mesh % UniformBlockMesh ( cqDegree , nElem , ( / 0.0_prec , 1.0_prec / )) ! Create the geometry CALL geometry % GenerateFromMesh ( mesh , cqType , tqType , cqDegree , tqDegree ) ! Verify the mesh expect_dxds = ( 1.0_prec / REAL ( nElem , prec )) / 2.0_prec ! Calculate error in metric terms dxds_error = 0.0_prec DO iel = 1 , nElem DO i = 0 , cqDegree dxds_error = MAX ( dxds_error , ABS ( geometry % dxds % interior % hostData ( i , 1 , iel ) - expect_dxds )) END DO END DO ! Calculate error in boundary interpolation boundx_error = 0.0_prec DO iel = 1 , nElem i = mesh % eleminfo % hostData ( 3 , iel ) expect_boundx = mesh % nodeCoords % hostData ( i ) boundx_error = MAX ( boundx_error , ABS ( geometry % x % boundary % hostData ( 1 , 1 , iel ) - expect_boundx )) i = mesh % eleminfo % hostData ( 4 , iel ) expect_boundx = mesh % nodeCoords % hostData ( i ) boundx_error = MAX ( boundx_error , ABS ( geometry % x % boundary % hostData ( 1 , 2 , iel ) - expect_boundx )) END DO CALL mesh % Free () CALL geometry % Free () msg = \"Numerical Error (dx/ds) : \" // Float2Str ( dxds_error ) IF ( dxds_error > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF msg = \"Numerical Error (xBound) : \" // Float2Str ( boundx_error ) IF ( boundx_error > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF END SUBROUTINE BlockMesh1D_Test SUBROUTINE BlockMesh2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , tolerance , error ) #undef __FUNC__ #define __FUNC__ \"BlockMesh2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem REAL ( prec ), INTENT ( in ) :: tolerance INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: mesh TYPE ( SEMQuad ) :: geometry REAL ( prec ) :: expect_dxds ( 1 : 2 , 1 : 2 ), dxds_error ( 1 : 2 , 1 : 2 ) REAL ( prec ) :: expect_J , J_error INTEGER :: iel , jel , i , j INTEGER :: row , col error = 0 INFO ( 'Number of elements : ' // Int2Str ( nElem * nElem )) INFO ( 'Control point degree : ' // Int2Str ( cqDegree )) INFO ( 'Target point degree : ' // Int2Str ( tqDegree )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) CALL mesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) ! Create the geometry CALL geometry % GenerateFromMesh ( mesh , cqType , tqType , cqDegree , tqDegree ) ! Verify the mesh expect_dxds ( 1 , 1 ) = ( 1.0_prec / REAL ( nElem , prec )) / 2.0_prec expect_dxds ( 1 , 2 ) = 0.0_prec expect_dxds ( 2 , 1 ) = 0.0_prec expect_dxds ( 2 , 2 ) = ( 1.0_prec / REAL ( nElem , prec )) / 2.0_prec expect_J = expect_dxds ( 1 , 1 ) * expect_dxds ( 2 , 2 ) ! Calculate error in metric terms dxds_error = 0.0_prec DO iel = 1 , nElem DO j = 0 , cqDegree DO i = 0 , cqDegree DO col = 1 , 2 DO row = 1 , 2 dxds_error ( row , col ) = MAX ( dxds_error ( row , col ), & ABS ( geometry % dxds % & interior % hostData ( row , col , i , j , 1 , iel ) - & expect_dxds ( row , col ))) END DO END DO J_error = MAX ( J_error , ABS ( geometry % J % & interior % hostData ( i , j , 1 , iel ) - & expect_J )) END DO END DO END DO CALL mesh % Free () CALL geometry % Free () DO col = 1 , 2 DO row = 1 , 2 msg = \"Numerical Error (dx/ds) (\" // & TRIM ( Int2Str ( row )) // \",\" // & TRIM ( Int2Str ( col )) // \") : \" // & Float2Str ( dxds_error ( row , col )) IF ( dxds_error ( row , col ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF END DO END DO msg = \"Numerical Error (Jacobian) : \" // Float2Str ( J_error ) IF ( J_error > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF END SUBROUTINE BlockMesh2D_Test SUBROUTINE BlockMesh3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , tolerance , error ) #undef __FUNC__ #define __FUNC__ \"BlockMesh3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem REAL ( prec ), INTENT ( in ) :: tolerance INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: mesh TYPE ( SEMHex ) :: geometry REAL ( prec ) :: expect_dxds ( 1 : 3 , 1 : 3 ), dxds_error ( 1 : 3 , 1 : 3 ) REAL ( prec ) :: expect_J , J_error INTEGER :: iel , jel , kel , i , j , k INTEGER :: row , col error = 0 msg = 'Number of elements : ' // Int2Str ( nElem * nElem * nElem ) INFO ( TRIM ( msg )) INFO ( 'Control point degree : ' // Int2Str ( cqDegree )) INFO ( 'Target point degree : ' // Int2Str ( tqDegree )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) CALL mesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) ! Create the geometry CALL geometry % GenerateFromMesh ( mesh , cqType , tqType , cqDegree , tqDegree ) ! Verify the mesh expect_dxds ( 1 , 1 ) = ( 1.0_prec / REAL ( nElem , prec )) / 2.0_prec expect_dxds ( 1 , 2 ) = 0.0_prec expect_dxds ( 1 , 3 ) = 0.0_prec expect_dxds ( 2 , 1 ) = 0.0_prec expect_dxds ( 2 , 2 ) = ( 1.0_prec / REAL ( nElem , prec )) / 2.0_prec expect_dxds ( 2 , 3 ) = 0.0_prec expect_dxds ( 3 , 1 ) = 0.0_prec expect_dxds ( 3 , 2 ) = 0.0_prec expect_dxds ( 3 , 3 ) = ( 1.0_prec / REAL ( nElem , prec )) / 2.0_prec expect_J = expect_dxds ( 1 , 1 ) * expect_dxds ( 2 , 2 ) * expect_dxds ( 3 , 3 ) ! Calculate error in metric terms dxds_error = 0.0_prec J_error = 0.0_prec DO iel = 1 , nElem DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree DO col = 1 , 3 DO row = 1 , 3 dxds_error ( row , col ) = MAX ( dxds_error ( row , col ), & ABS ( geometry % dxds % & interior % hostData ( row , col , i , j , k , 1 , iel ) - & expect_dxds ( row , col ))) END DO END DO J_error = MAX ( J_error , ABS ( geometry % J % & interior % hostData ( i , j , k , 1 , iel ) - & expect_J )) END DO END DO END DO END DO CALL mesh % Free () CALL geometry % Free () DO col = 1 , 3 DO row = 1 , 3 msg = \"Numerical Error (dx/ds) (\" // & TRIM ( Int2Str ( row )) // \",\" // & TRIM ( Int2Str ( col )) // \") : \" // & Float2Str ( dxds_error ( row , col )) IF ( dxds_error ( row , col ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF END DO END DO msg = \"Numerical Error (Jacobian) : \" // Float2Str ( J_error ) IF ( J_error > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF END SUBROUTINE BlockMesh3D_Test SUBROUTINE ScalarInterp1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar , functionChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarInterp1D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: functionChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh1D ) :: controlMesh , targetMesh TYPE ( Geometry1D ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: feq TYPE ( Scalar1D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , ivar error = 0 msg = 'Number of elements : ' // Int2Str ( nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , nElem ,( / 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the target mesh and geometry CALL targetMesh % UniformBlockMesh ( tqDegree , nElem ,( / 0.0_prec , 1.0_prec / )) CALL targetGeometry % GenerateFromMesh ( targetMesh , tqType , tqType , tqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) CALL fInterp % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nElem ) CALL fActual % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nElem ) CALL fError % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nElem ) ! Create the equation parser object feq = EquationParser ( functionChar , ( / 'x' / )) ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO i = 0 , cqDegree f % interior % hostData ( i , ivar , iel ) = & feq % Evaluate ( ( / controlGeometry % x % interior % hostData ( i , 1 , iel ) / ) ) ENDDO ENDDO ENDDO ! Load the target function DO iel = 1 , targetGeometry % nElem DO ivar = 1 , nvar DO i = 0 , tqDegree fActual % interior % hostData ( i , ivar , iel ) = & feq % Evaluate ( ( / targetGeometry % x % interior % hostData ( i , 1 , iel ) / ) ) ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % GridInterp ( fInterp , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL fInterp % UpdateHost () END IF #endif fError = fActual - fInterp ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL targetMesh % Free () CALL targetGeometry % Free () CALL f % Free () CALL fInterp % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE ScalarInterp1D_Test SUBROUTINE ScalarBoundaryInterp1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& functionChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarBoundaryInterp1D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: functionChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh1D ) :: controlMesh TYPE ( Geometry1D ) :: controlGeometry TYPE ( EquationParser ) :: feq TYPE ( Scalar1D ) :: f , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar , 1 : 2 ) INTEGER :: iel , i , ivar , iSide error = 0 msg = 'Number of elements : ' // Int2Str ( nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , nElem ,( / 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) CALL fActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) CALL fError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) ! Create the equation parser object feq = EquationParser ( functionChar , ( / 'x' / )) ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO i = 0 , cqDegree f % interior % hostData ( i , ivar , iel ) = & feq % Evaluate ( ( / controlGeometry % x % interior % hostData ( i , 1 , iel ) / ) ) ENDDO ! Right Boundary fActual % boundary % hostData ( ivar , 1 , iel ) = & feq % Evaluate ( ( / controlGeometry % x % boundary % hostData ( 1 , 1 , iel ) / ) ) ! Right boundary fActual % boundary % hostData ( ivar , 2 , iel ) = & feq % Evaluate ( ( / controlGeometry % x % boundary % hostData ( 1 , 2 , iel ) / ) ) ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % BoundaryInterp ( gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateHost () END IF #endif fError = fActual - f ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxBoundary ( ) DO iSide = 1 , 2 msg = \"Numerical Error : \" // TRIM ( Int2Str ( iSide )) // Float2Str ( maxErrors ( 1 , iSide )) IF ( maxErrors ( 1 , iSide ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) msg = \"Status : [FAIL]\" ERROR ( TRIM ( msg )) ELSE INFO ( TRIM ( msg )) msg = \"Status : [PASS]\" INFO ( TRIM ( msg )) END IF ENDDO ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE ScalarBoundaryInterp1D_Test SUBROUTINE ScalarDerivative1D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nvar ,& fChar , dfChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarDerivative1D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: dForm INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: fChar CHARACTER ( * ), INTENT ( in ) :: dfChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh1D ) :: controlMesh TYPE ( Geometry1D ) :: controlGeometry TYPE ( EquationParser ) :: feq , dfeq TYPE ( MappedScalar1D ) :: f , dfInterp , dfActual , dfError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , ivar error = 0 IF ( dForm == selfStrongForm ) THEN msg = 'Formulation Type : Strong Form' ELSEIF ( dForm == selfWeakDGForm ) THEN msg = 'Formulation Type : Weak DG Form' ELSEIF ( dForm == selfWeakCGForm ) THEN msg = 'Formulation Type : Weak CG Form' ENDIF INFO ( TRIM ( msg )) msg = 'Number of elements : ' // Int2Str ( nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , nElem ,( / 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) CALL dfInterp % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) CALL dfActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) CALL dfError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) ! Create the equation parser object feq = EquationParser ( fChar , ( / 'x' / )) dfeq = EquationParser ( dfChar , ( / 'x' / )) ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO i = 0 , cqDegree f % interior % hostData ( i , ivar , iel ) = & feq % Evaluate ( ( / controlGeometry % x % interior % hostData ( i , 1 , iel ) / ) ) dfActual % interior % hostData ( i , ivar , iel ) = & dfeq % Evaluate ( ( / controlGeometry % x % interior % hostData ( i , 1 , iel ) / ) ) ENDDO ! Left Boundary f % boundary % hostData ( ivar , 1 , iel ) = & feq % Evaluate ( ( / controlGeometry % x % boundary % hostData ( 1 , 1 , iel ) / ) ) ! Right boundary f % boundary % hostData ( ivar , 2 , iel ) = & feq % Evaluate ( ( / controlGeometry % x % boundary % hostData ( 1 , 2 , iel ) / ) ) ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % Derivative ( controlGeometry , dfInterp , dForm , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL dfInterp % UpdateHost () END IF #endif dfError = dfActual - dfInterp ! Calculate Absolute Maximum Error maxErrors = dfError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL dfInterp % Free () CALL dfActual % Free () CALL dfError % Free () END SUBROUTINE ScalarDerivative1D_Test SUBROUTINE ScalarInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& functionChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarInterp2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: functionChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh , targetMesh TYPE ( SEMQuad ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: feq TYPE ( Scalar2D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: nel , iel , jel INTEGER :: i , j , ivar nel = nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the target mesh and geometry CALL targetMesh % UniformBlockMesh ( tqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL targetGeometry % GenerateFromMesh ( targetMesh , tqType , tqType , tqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fInterp % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object feq = EquationParser ( functionChar , ( / 'x' , 'y' / )) ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree f % interior % hostData ( i , j , ivar , iel ) = & feq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ! Load the target function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , tqDegree DO i = 0 , tqDegree fActual % interior % hostData ( i , j , ivar , iel ) = & feq % Evaluate ( targetGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % GridInterp ( fInterp , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL fInterp % UpdateHost () END IF #endif fError = fActual - fInterp ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL targetMesh % Free () CALL targetGeometry % Free () CALL f % Free () CALL fInterp % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE ScalarInterp2D_Test SUBROUTINE ScalarBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& functionChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarBoundaryInterp2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: functionChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh TYPE ( SEMQuad ) :: controlGeometry TYPE ( EquationParser ) :: feq TYPE ( Scalar2D ) :: f , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar , 1 : 4 ) INTEGER :: nel , iel , jel INTEGER :: i , j , ivar , iside nel = nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object feq = EquationParser ( functionChar , ( / 'x' , 'y' / )) ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree f % interior % hostData ( i , j , ivar , iel ) = & feq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO DO iside = 1 , 4 fActual % boundary % hostData ( j , ivar , iside , iel ) = & feq % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 2 , j , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % BoundaryInterp ( gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateHost () END IF #endif fError = fActual - f ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxBoundary ( ) DO iside = 1 , 4 msg = \"Numerical Error : \" // TRIM ( Int2Str ( iSide )) // Float2Str ( maxErrors ( 1 , iSide )) IF ( maxErrors ( 1 , iSide ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) msg = \"Status : [FAIL]\" ERROR ( TRIM ( msg )) ELSE INFO ( TRIM ( msg )) msg = \"Status : [PASS]\" INFO ( TRIM ( msg )) END IF ENDDO ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE ScalarBoundaryInterp2D_Test SUBROUTINE ScalarGradient2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nvar ,& fChar , gradientChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarGradient2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: dForm INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: fChar CHARACTER ( 240 ), INTENT ( in ) :: gradientChar ( 1 : 2 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh TYPE ( SEMQuad ) :: controlGeometry TYPE ( EquationParser ) :: feq , gxeq , gyeq TYPE ( MappedScalar2D ) :: f TYPE ( MappedTensor2D ) :: workTensor TYPE ( MappedVector2D ) :: dfInterp , dfActual , dfError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , j , ivar , iside error = 0 IF ( dForm == selfStrongForm ) THEN msg = 'Formulation Type : Strong Form' ELSEIF ( dForm == selfWeakDGForm ) THEN msg = 'Formulation Type : Weak DG Form' ELSEIF ( dForm == selfWeakCGForm ) THEN msg = 'Formulation Type : Weak CG Form' ENDIF INFO ( TRIM ( msg )) msg = 'Number of elements : ' // Int2Str ( nElem ) msg = 'Number of elements : ' // Int2Str ( nElem * nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL workTensor % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfInterp % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create the equation parser object feq = EquationParser ( fChar , ( / 'x' , 'y' / )) gxeq = EquationParser ( gradientChar ( 1 ), ( / 'x' , 'y' / )) gyeq = EquationParser ( gradientChar ( 2 ), ( / 'x' , 'y' / )) ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree f % interior % hostData ( i , j , ivar , iel ) = & feq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) dfActual % interior % hostData ( 1 , i , j , ivar , iel ) = & gxeq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) dfActual % interior % hostData ( 2 , i , j , ivar , iel ) = & gyeq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO DO iside = 1 , 4 f % boundary % hostData ( j , ivar , iside , iel ) = & feq % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 2 , j , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % Gradient ( workTensor , controlGeometry , dfInterp , dForm , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL dfInterp % UpdateHost () END IF #endif dfError = dfActual - dfInterp ! Calculate Absolute Maximum Error maxErrors = dfError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL workTensor % Free () CALL dfInterp % Free () CALL dfActual % Free () CALL dfError % Free () END SUBROUTINE ScalarGradient2D_Test SUBROUTINE VectorInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& vectorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorInterp2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 2 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh , targetMesh TYPE ( SEMQuad ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: vEq ( 1 : 2 ) TYPE ( Vector2D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: nel , iel , jel INTEGER :: i , j , ivar , idir nel = nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the target mesh and geometry CALL targetMesh % UniformBlockMesh ( tqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL targetGeometry % GenerateFromMesh ( targetMesh , tqType , tqType , tqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fInterp % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO idir = 1 , 2 vEq ( idir ) = EquationParser ( vectorChar ( idir ), ( / 'x' , 'y' / )) ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree DO idir = 1 , 2 f % interior % hostData ( idir , i , j , ivar , iel ) = & vEq ( idir ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ! Load the target function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , tqDegree DO i = 0 , tqDegree DO idir = 1 , 2 fActual % interior % hostData ( idir , i , j , ivar , iel ) = & vEq ( idir ) % Evaluate ( targetGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % GridInterp ( fInterp , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL fInterp % UpdateHost () END IF #endif fError = fActual - fInterp ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL targetMesh % Free () CALL targetGeometry % Free () CALL f % Free () CALL fInterp % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE VectorInterp2D_Test SUBROUTINE VectorBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& vectorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorBoundaryInterp2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 2 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh TYPE ( SEMQuad ) :: controlGeometry TYPE ( EquationParser ) :: vEq ( 1 : 2 ) TYPE ( Vector2D ) :: f , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar , 1 : 4 ) INTEGER :: nel , iel , jel INTEGER :: i , j , ivar , iside , idir nel = nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO idir = 1 , 2 vEq ( idir ) = EquationParser ( vectorChar ( idir ), ( / 'x' , 'y' / )) ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree DO idir = 1 , 2 f % interior % hostData ( idir , i , j , ivar , iel ) = & vEq ( idir ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO DO iside = 1 , 4 DO idir = 1 , 2 fActual % boundary % hostData ( idir , j , ivar , iside , iel ) = & vEq ( idir ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 2 , j , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ! Run the grid interpolation #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif CALL f % BoundaryInterp ( gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateHost () END IF #endif fError = fActual - f ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxBoundary ( ) DO iside = 1 , 4 msg = \"Numerical Error : \" // TRIM ( Int2Str ( iSide )) // Float2Str ( maxErrors ( 1 , iSide )) IF ( maxErrors ( 1 , iSide ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) msg = \"Status : [FAIL]\" ERROR ( TRIM ( msg )) ELSE INFO ( TRIM ( msg )) msg = \"Status : [PASS]\" INFO ( TRIM ( msg )) END IF ENDDO ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE VectorBoundaryInterp2D_Test SUBROUTINE VectorGradient2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nvar ,& vectorChar , tensorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorGradient2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: dForm INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 2 ) CHARACTER ( 240 ), INTENT ( in ) :: tensorChar ( 1 : 2 , 1 : 2 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh TYPE ( SEMQuad ) :: controlGeometry TYPE ( EquationParser ) :: feq ( 1 : 2 ), dfeqChar ( 1 : 2 , 1 : 2 ) TYPE ( MappedVector2D ) :: f TYPE ( MappedScalar2D ) :: workScalar TYPE ( MappedVector2D ) :: workVector TYPE ( MappedTensor2D ) :: workTensor TYPE ( MappedTensor2D ) :: dfInterp , dfActual , dfError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , j , ivar , row , col , iside error = 0 IF ( dForm == selfStrongForm ) THEN msg = 'Formulation Type : Strong Form' ELSEIF ( dForm == selfWeakDGForm ) THEN msg = 'Formulation Type : Weak DG Form' ELSEIF ( dForm == selfWeakCGForm ) THEN msg = 'Formulation Type : Weak CG Form' ENDIF INFO ( TRIM ( msg )) msg = 'Number of elements : ' // Int2Str ( nElem ) msg = 'Number of elements : ' // Int2Str ( nElem * nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfInterp % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create work objects CALL workScalar % Init ( cqDegree , cqType , tqDegree , tqType , 2 * nvar , controlGeometry % nElem ) CALL workVector % Init ( cqDegree , cqType , tqDegree , tqType , 2 * nvar , controlGeometry % nElem ) CALL workTensor % Init ( cqDegree , cqType , tqDegree , tqType , 2 * nvar , controlGeometry % nElem ) ! Create the equation parser object DO row = 1 , 2 feq ( row ) = EquationParser ( vectorChar ( row ), ( / 'x' , 'y' / )) ENDDO DO col = 1 , 2 DO row = 1 , 2 dfeqChar ( row , col ) = EquationParser ( tensorChar ( row , col ), ( / 'x' , 'y' / )) ENDDO ENDDO ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree DO row = 1 , 2 f % interior % hostData ( row , i , j , ivar , iel ) = & feq ( row ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO DO col = 1 , 2 DO row = 1 , 2 dfActual % interior % hostData ( row , col , i , j , ivar , iel ) = & dfeqChar ( row , col ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO DO iside = 1 , 4 DO row = 1 , 2 f % boundary % hostData ( row , j , ivar , iside , iel ) = & fEq ( row ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 2 , j , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % Gradient ( workScalar , workVector , workTensor , controlGeometry , dfInterp , dForm , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL dfInterp % UpdateHost () END IF #endif dfError = dfActual - dfInterp ! Calculate Absolute Maximum Error maxErrors = dfError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL workScalar % Free () CALL workVector % Free () CALL workTensor % Free () CALL dfInterp % Free () CALL dfActual % Free () CALL dfError % Free () END SUBROUTINE VectorGradient2D_Test SUBROUTINE VectorDivergence2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nvar ,& vectorChar , scalarChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorDivergence2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: dForm INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 2 ) CHARACTER ( 240 ), INTENT ( in ) :: scalarChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh TYPE ( SEMQuad ) :: controlGeometry TYPE ( EquationParser ) :: feq ( 1 : 2 ), dfeqChar TYPE ( MappedVector2D ) :: f TYPE ( MappedVector2D ) :: workVector TYPE ( MappedScalar2D ) :: dfInterp , dfActual , dfError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , j , ivar , row , col , iside error = 0 IF ( dForm == selfStrongForm ) THEN msg = 'Formulation Type : Strong Form' ELSEIF ( dForm == selfWeakDGForm ) THEN msg = 'Formulation Type : Weak DG Form' ELSEIF ( dForm == selfWeakCGForm ) THEN msg = 'Formulation Type : Weak CG Form' ENDIF INFO ( TRIM ( msg )) msg = 'Number of elements : ' // Int2Str ( nElem ) msg = 'Number of elements : ' // Int2Str ( nElem * nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfInterp % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create work objects CALL workVector % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create the equation parser object DO row = 1 , 2 feq ( row ) = EquationParser ( vectorChar ( row ), ( / 'x' , 'y' / )) ENDDO dfeqChar = EquationParser ( scalarChar , ( / 'x' , 'y' / )) ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree DO row = 1 , 2 f % interior % hostData ( row , i , j , ivar , iel ) = & feq ( row ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO dfActual % interior % hostData ( i , j , ivar , iel ) = & dfeqChar % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO DO iside = 1 , 4 DO row = 1 , 2 f % boundary % hostData ( row , j , ivar , iside , iel ) = & feq ( row ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 2 , j , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % Divergence ( workVector , controlGeometry , dfInterp , dForm , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL dfInterp % UpdateHost ( ) END IF #endif dfError = dfActual - dfInterp ! Calculate Absolute Maximum Error maxErrors = dfError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL workVector % Free () CALL dfInterp % Free () CALL dfActual % Free () CALL dfError % Free () END SUBROUTINE VectorDivergence2D_Test SUBROUTINE TensorInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& tensorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"TensorInterp2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: tensorChar ( 1 : 2 , 1 : 2 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh , targetMesh TYPE ( SEMQuad ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: tensorEq ( 1 : 2 , 1 : 2 ) TYPE ( Tensor2D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: nel , iel , jel INTEGER :: i , j , ivar INTEGER :: row , col nel = nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the target mesh and geometry CALL targetMesh % UniformBlockMesh ( tqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL targetGeometry % GenerateFromMesh ( targetMesh , tqType , tqType , tqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fInterp % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO col = 1 , 2 DO row = 1 , 2 tensorEq ( row , col ) = EquationParser ( TRIM ( tensorChar ( row , col )), ( / 'x' , 'y' / )) ENDDO ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree DO col = 1 , 2 DO row = 1 , 2 f % interior % hostData ( row , col , i , j , ivar , iel ) = & tensorEq ( row , col ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ! Load the target function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , tqDegree DO i = 0 , tqDegree DO col = 1 , 2 DO row = 1 , 2 fActual % interior % hostData ( row , col , i , j , ivar , iel ) = & tensorEq ( row , col ) % Evaluate ( targetGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % GridInterp ( fInterp , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL fInterp % UpdateHost () END IF #endif fError = fActual - fInterp ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL targetMesh % Free () CALL targetGeometry % Free () CALL f % Free () CALL fInterp % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE TensorInterp2D_Test SUBROUTINE TensorBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& tensorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"TensorBoundaryInterp2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: tensorChar ( 1 : 2 , 1 : 2 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh TYPE ( SEMQuad ) :: controlGeometry TYPE ( EquationParser ) :: tensorEq ( 1 : 2 , 1 : 2 ) TYPE ( Tensor2D ) :: f , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar , 1 : 4 ) INTEGER :: nel , iel , jel INTEGER :: i , j , ivar , iside INTEGER :: row , col nel = nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO col = 1 , 2 DO row = 1 , 2 tensorEq ( row , col ) = EquationParser ( TRIM ( tensorChar ( row , col )), ( / 'x' , 'y' / )) ENDDO ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree DO col = 1 , 2 DO row = 1 , 2 f % interior % hostData ( row , col , i , j , ivar , iel ) = & tensorEq ( row , col ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO DO iside = 1 , 4 DO col = 1 , 2 DO row = 1 , 2 fActual % boundary % hostData ( row , col , j , ivar , iside , iel ) = & tensorEq ( row , col ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 2 , j , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % BoundaryInterp ( gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateHost () END IF #endif fError = fActual - f ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxBoundary ( ) DO iside = 1 , 4 msg = \"Numerical Error : \" // TRIM ( Int2Str ( iSide )) // Float2Str ( maxErrors ( 1 , iSide )) IF ( maxErrors ( 1 , iSide ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) msg = \"Status : [FAIL]\" ERROR ( TRIM ( msg )) ELSE INFO ( TRIM ( msg )) msg = \"Status : [PASS]\" INFO ( TRIM ( msg )) END IF ENDDO ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE TensorBoundaryInterp2D_Test SUBROUTINE ScalarInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& functionChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarInterp3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: functionChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh , targetMesh TYPE ( SEMHex ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: feq TYPE ( Scalar3D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: nel , iel INTEGER :: i , j , k , ivar nel = nElem * nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the target mesh and geometry CALL targetMesh % UniformBlockMesh ( tqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL targetGeometry % GenerateFromMesh ( targetMesh , tqType , tqType , tqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fInterp % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object feq = EquationParser ( functionChar , ( / 'x' , 'y' , 'z' / )) ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree f % interior % hostData ( i , j , k , ivar , iel ) = & feq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ! Load the target function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , tqDegree DO j = 0 , tqDegree DO i = 0 , tqDegree fActual % interior % hostData ( i , j , k , ivar , iel ) = & feq % Evaluate ( targetGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % GridInterp ( fInterp , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL fInterp % UpdateHost () END IF #endif fError = fActual - fInterp ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL targetMesh % Free () CALL targetGeometry % Free () CALL f % Free () CALL fInterp % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE ScalarInterp3D_Test SUBROUTINE ScalarBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& functionChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarBoundaryInterp3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: functionChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh , targetMesh TYPE ( SEMHex ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: feq TYPE ( Scalar3D ) :: f , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar , 1 : 6 ) INTEGER :: nel , iel INTEGER :: i , j , k , ivar , iside nel = nElem * nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object feq = EquationParser ( functionChar , ( / 'x' , 'y' , 'z' / )) ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree f % interior % hostData ( i , j , k , ivar , iel ) = & feq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO DO iside = 1 , 6 fActual % boundary % hostData ( j , k , ivar , iside , iel ) = & feq % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 3 , j , k , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % BoundaryInterp ( gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateHost () END IF #endif fError = fActual - f ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxBoundary ( ) DO iside = 1 , 6 msg = \"Numerical Error : \" // TRIM ( Int2Str ( iSide )) // Float2Str ( maxErrors ( 1 , iSide )) IF ( maxErrors ( 1 , iSide ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) msg = \"Status : [FAIL]\" ERROR ( TRIM ( msg )) ELSE INFO ( TRIM ( msg )) msg = \"Status : [PASS]\" INFO ( TRIM ( msg )) END IF ENDDO ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE ScalarBoundaryInterp3D_Test SUBROUTINE ScalarGradient3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nvar ,& fChar , gradientChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarGradient3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: dForm INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: fChar CHARACTER ( 240 ), INTENT ( in ) :: gradientChar ( 1 : 3 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh TYPE ( SEMHex ) :: controlGeometry TYPE ( EquationParser ) :: feq , gxeq , gyeq , gzeq TYPE ( MappedScalar3D ) :: f TYPE ( MappedTensor3D ) :: workTensor TYPE ( MappedVector3D ) :: dfInterp , dfActual , dfError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , j , k , ivar , iside error = 0 IF ( dForm == selfStrongForm ) THEN msg = 'Formulation Type : Strong Form' ELSEIF ( dForm == selfWeakDGForm ) THEN msg = 'Formulation Type : Weak DG Form' ELSEIF ( dForm == selfWeakCGForm ) THEN msg = 'Formulation Type : Weak CG Form' ENDIF INFO ( TRIM ( msg )) msg = 'Number of elements : ' // Int2Str ( nElem ) msg = 'Number of elements : ' // Int2Str ( nElem * nElem * nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL workTensor % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfInterp % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create the equation parser object feq = EquationParser ( fChar , ( / 'x' , 'y' , 'z' / )) gxeq = EquationParser ( gradientChar ( 1 ), ( / 'x' , 'y' , 'z' / )) gyeq = EquationParser ( gradientChar ( 2 ), ( / 'x' , 'y' , 'z' / )) gzeq = EquationParser ( gradientChar ( 3 ), ( / 'x' , 'y' , 'z' / )) ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree f % interior % hostData ( i , j , k , ivar , iel ) = & feq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) dfActual % interior % hostData ( 1 , i , j , k , ivar , iel ) = & gxeq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) dfActual % interior % hostData ( 2 , i , j , k , ivar , iel ) = & gyeq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) dfActual % interior % hostData ( 3 , i , j , k , ivar , iel ) = & gzeq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO DO iside = 1 , 6 f % boundary % hostData ( j , k , ivar , iside , iel ) = & feq % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 3 , j , k , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % Gradient ( workTensor , controlGeometry , dfInterp , dForm , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL dfInterp % UpdateHost () END IF #endif dfError = dfActual - dfInterp ! Calculate Absolute Maximum Error maxErrors = dfError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL workTensor % Free () CALL dfInterp % Free () CALL dfActual % Free () CALL dfError % Free () END SUBROUTINE ScalarGradient3D_Test SUBROUTINE VectorInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& vectorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorInterp3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 3 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh , targetMesh TYPE ( SEMHex ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: vEq ( 1 : 3 ) TYPE ( Vector3D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: nel , iel INTEGER :: i , j , k , ivar , idir nel = nElem * nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the target mesh and geometry CALL targetMesh % UniformBlockMesh ( tqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL targetGeometry % GenerateFromMesh ( targetMesh , tqType , tqType , tqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fInterp % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO idir = 1 , 3 vEq ( idir ) = EquationParser ( vectorChar ( idir ), ( / 'x' , 'y' , 'z' / )) ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree DO idir = 1 , 3 f % interior % hostData ( idir , i , j , k , ivar , iel ) = & vEq ( idir ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ! Load the target function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , tqDegree DO j = 0 , tqDegree DO i = 0 , tqDegree DO idir = 1 , 3 fActual % interior % hostData ( idir , i , j , k , ivar , iel ) = & vEq ( idir ) % Evaluate ( targetGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % GridInterp ( fInterp , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL fInterp % UpdateHost () END IF #endif fError = fActual - fInterp ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL targetMesh % Free () CALL targetGeometry % Free () CALL f % Free () CALL fInterp % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE VectorInterp3D_Test SUBROUTINE VectorBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& vectorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorBoundaryInterp3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 3 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh TYPE ( SEMHex ) :: controlGeometry TYPE ( EquationParser ) :: vEq ( 1 : 3 ) TYPE ( Vector3D ) :: f , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar , 1 : 6 ) INTEGER :: nel , iel INTEGER :: i , j , k , ivar , iside , idir nel = nElem * nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO idir = 1 , 3 vEq ( idir ) = EquationParser ( vectorChar ( idir ), ( / 'x' , 'y' , 'z' / )) ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree DO idir = 1 , 3 f % interior % hostData ( idir , i , j , k , ivar , iel ) = & vEq ( idir ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO DO iside = 1 , 6 DO idir = 1 , 3 fActual % boundary % hostData ( idir , j , k , ivar , iside , iel ) = & vEq ( idir ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 3 , j , k , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % BoundaryInterp ( gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateHost () END IF #endif fError = fActual - f ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxBoundary ( ) DO iside = 1 , 6 msg = \"Numerical Error : \" // TRIM ( Int2Str ( iSide )) // Float2Str ( maxErrors ( 1 , iSide )) IF ( maxErrors ( 1 , iSide ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) msg = \"Status : [FAIL]\" ERROR ( TRIM ( msg )) ELSE INFO ( TRIM ( msg )) msg = \"Status : [PASS]\" INFO ( TRIM ( msg )) END IF ENDDO ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE VectorBoundaryInterp3D_Test SUBROUTINE VectorGradient3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nvar ,& vectorChar , tensorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorGradient3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: dForm INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 3 ) CHARACTER ( 240 ), INTENT ( in ) :: tensorChar ( 1 : 3 , 1 : 3 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh TYPE ( SEMHex ) :: controlGeometry TYPE ( EquationParser ) :: feq ( 1 : 3 ), dfeqChar ( 1 : 3 , 1 : 3 ) TYPE ( MappedVector3D ) :: f TYPE ( MappedScalar3D ) :: workScalar TYPE ( MappedVector3D ) :: workVector TYPE ( MappedTensor3D ) :: workTensor TYPE ( MappedTensor3D ) :: dfInterp , dfActual , dfError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , j , k , ivar , row , col , iside error = 0 IF ( dForm == selfStrongForm ) THEN msg = 'Formulation Type : Strong Form' ELSEIF ( dForm == selfWeakDGForm ) THEN msg = 'Formulation Type : Weak DG Form' ELSEIF ( dForm == selfWeakCGForm ) THEN msg = 'Formulation Type : Weak CG Form' ENDIF INFO ( TRIM ( msg )) msg = 'Number of elements : ' // Int2Str ( nElem ) msg = 'Number of elements : ' // Int2Str ( nElem * nElem * nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfInterp % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create work objects CALL workScalar % Init ( cqDegree , cqType , tqDegree , tqType , 3 * nvar , controlGeometry % nElem ) CALL workVector % Init ( cqDegree , cqType , tqDegree , tqType , 3 * nvar , controlGeometry % nElem ) CALL workTensor % Init ( cqDegree , cqType , tqDegree , tqType , 3 * nvar , controlGeometry % nElem ) ! Create the equation parser object DO row = 1 , 3 feq ( row ) = EquationParser ( vectorChar ( row ), ( / 'x' , 'y' , 'z' / )) ENDDO DO col = 1 , 3 DO row = 1 , 3 dfeqChar ( row , col ) = EquationParser ( tensorChar ( row , col ), ( / 'x' , 'y' , 'z' / )) ENDDO ENDDO ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree DO row = 1 , 3 f % interior % hostData ( row , i , j , k , ivar , iel ) = & feq ( row ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO DO col = 1 , 3 DO row = 1 , 3 dfActual % interior % hostData ( row , col , i , j , k , ivar , iel ) = & dfeqChar ( row , col ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO DO iside = 1 , 6 DO row = 1 , 3 f % boundary % hostData ( row , j , k , ivar , iside , iel ) = & feq ( row ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 3 , j , k , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % Gradient ( workScalar , workVector , workTensor , controlGeometry , dfInterp , dForm , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL dfInterp % UpdateHost () END IF #endif dfError = dfActual - dfInterp !PRINT*, dfError % interior % hostData ! Calculate Absolute Maximum Error maxErrors = dfError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL workScalar % Free () CALL workVector % Free () CALL workTensor % Free () CALL dfInterp % Free () CALL dfActual % Free () CALL dfError % Free () END SUBROUTINE VectorGradient3D_Test SUBROUTINE VectorDivergence3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nvar ,& vectorChar , scalarChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorDivergence3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: dForm INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 3 ) CHARACTER ( 240 ), INTENT ( in ) :: scalarChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh TYPE ( SEMHex ) :: controlGeometry TYPE ( EquationParser ) :: feq ( 1 : 3 ), dfeqChar TYPE ( MappedVector3D ) :: f TYPE ( MappedVector3D ) :: workVector TYPE ( MappedScalar3D ) :: dfInterp , dfActual , dfError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , j , k , ivar , idir , iside error = 0 IF ( dForm == selfStrongForm ) THEN msg = 'Formulation Type : Strong Form' ELSEIF ( dForm == selfWeakDGForm ) THEN msg = 'Formulation Type : Weak DG Form' ELSEIF ( dForm == selfWeakCGForm ) THEN msg = 'Formulation Type : Weak CG Form' ENDIF INFO ( TRIM ( msg )) msg = 'Number of elements : ' // Int2Str ( nElem * nElem * nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfInterp % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create work objects CALL workVector % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create the equation parser object DO idir = 1 , 3 feq ( idir ) = EquationParser ( vectorChar ( idir ), ( / 'x' , 'y' , 'z' / )) ENDDO dfeqChar = EquationParser ( scalarChar , ( / 'x' , 'y' , 'z' / )) ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree DO idir = 1 , 3 f % interior % hostData ( idir , i , j , k , ivar , iel ) = & feq ( idir ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO dfActual % interior % hostData ( i , j , k , ivar , iel ) = & dfeqChar % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO DO iside = 1 , 6 DO idir = 1 , 3 f % boundary % hostData ( idir , j , k , ivar , iside , iel ) = & feq ( idir ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 3 , j , k , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation DO i = 1 , 1000 CALL f % Divergence ( workVector , controlGeometry , dfInterp , dForm , gpuAccel ) END DO #ifdef GPU IF ( gpuAccel ) THEN CALL dfInterp % UpdateHost () END IF #endif dfError = dfActual - dfInterp ! Calculate Absolute Maximum Error maxErrors = dfError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL workVector % Free () CALL dfInterp % Free () CALL dfActual % Free () CALL dfError % Free () END SUBROUTINE VectorDivergence3D_Test SUBROUTINE TensorInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& tensorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"TensorInterp3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: tensorChar ( 1 : 3 , 1 : 3 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh , targetMesh TYPE ( SEMHex ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: tensorEq ( 1 : 3 , 1 : 3 ) TYPE ( Tensor3D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: nel , iel INTEGER :: i , j , k , ivar INTEGER :: row , col nel = nElem * nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the target mesh and geometry CALL targetMesh % UniformBlockMesh ( tqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL targetGeometry % GenerateFromMesh ( targetMesh , tqType , tqType , tqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fInterp % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO col = 1 , 3 DO row = 1 , 3 tensorEq ( row , col ) = EquationParser ( TRIM ( tensorChar ( row , col )), ( / 'x' , 'y' , 'z' / )) ENDDO ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree DO col = 1 , 3 DO row = 1 , 3 f % interior % hostData ( row , col , i , j , k , ivar , iel ) = & tensorEq ( row , col ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ! Load the target function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , tqDegree DO j = 0 , tqDegree DO i = 0 , tqDegree DO col = 1 , 3 DO row = 1 , 3 fActual % interior % hostData ( row , col , i , j , k , ivar , iel ) = & tensorEq ( row , col ) % Evaluate ( targetGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % GridInterp ( fInterp , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL fInterp % UpdateHost () END IF #endif fError = fActual - fInterp ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL targetMesh % Free () CALL targetGeometry % Free () CALL f % Free () CALL fInterp % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE TensorInterp3D_Test SUBROUTINE TensorBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& tensorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"TensorBoundaryInterp3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: tensorChar ( 1 : 3 , 1 : 3 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh TYPE ( SEMHex ) :: controlGeometry TYPE ( EquationParser ) :: tensorEq ( 1 : 3 , 1 : 3 ) TYPE ( Tensor3D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar , 1 : 6 ) INTEGER :: nel , iel INTEGER :: i , j , k , ivar , iside INTEGER :: row , col nel = nElem * nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO col = 1 , 3 DO row = 1 , 3 tensorEq ( row , col ) = EquationParser ( TRIM ( tensorChar ( row , col )), ( / 'x' , 'y' , 'z' / )) ENDDO ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree DO col = 1 , 3 DO row = 1 , 3 f % interior % hostData ( row , col , i , j , k , ivar , iel ) = & tensorEq ( row , col ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO DO iside = 1 , 6 DO col = 1 , 3 DO row = 1 , 3 fActual % boundary % hostData ( row , col , j , k , ivar , iside , iel ) = & tensorEq ( row , col ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 3 , j , k , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % BoundaryInterp ( gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateHost () END IF #endif fError = fActual - f ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxBoundary ( ) DO iside = 1 , 6 msg = \"Numerical Error : \" // TRIM ( Int2Str ( iSide )) // Float2Str ( maxErrors ( 1 , iSide )) IF ( maxErrors ( 1 , iSide ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) msg = \"Status : [FAIL]\" ERROR ( TRIM ( msg )) ELSE INFO ( TRIM ( msg )) msg = \"Status : [PASS]\" INFO ( TRIM ( msg )) END IF ENDDO ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE TensorBoundaryInterp3D_Test END MODULE SELF_Tests","tags":"","loc":"sourcefile/self_tests.f90.html"},{"title":"SELF_Memory.f90 – SELF","text":"This file depends on sourcefile~~self_memory.f90~~EfferentGraph sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_constants.f90 SELF_Constants.f90 sourcefile~self_memory.f90->sourcefile~self_constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~self_memory.f90~~AfferentGraph sourcefile~self_memory.f90 SELF_Memory.f90 sourcefile~self_tests.f90 SELF_Tests.f90 sourcefile~self_tests.f90->sourcefile~self_memory.f90 sourcefile~self_lagrange.f90 SELF_Lagrange.f90 sourcefile~self_tests.f90->sourcefile~self_lagrange.f90 sourcefile~self_data.f90 SELF_Data.f90 sourcefile~self_tests.f90->sourcefile~self_data.f90 sourcefile~self_mesh.f90 SELF_Mesh.f90 sourcefile~self_tests.f90->sourcefile~self_mesh.f90 sourcefile~self_mappeddata.f90 SELF_MappedData.f90 sourcefile~self_tests.f90->sourcefile~self_mappeddata.f90 sourcefile~self_lagrange.f90->sourcefile~self_memory.f90 sourcefile~self.f90 SELF.f90 sourcefile~self.f90->sourcefile~self_tests.f90 sourcefile~self_geometry.f90 SELF_Geometry.f90 sourcefile~self_geometry.f90->sourcefile~self_lagrange.f90 sourcefile~self_geometry.f90->sourcefile~self_data.f90 sourcefile~self_geometry.f90->sourcefile~self_mesh.f90 sourcefile~self_data.f90->sourcefile~self_lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_lagrange.f90 sourcefile~self_mesh.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_lagrange.f90 sourcefile~self_mappeddata.f90->sourcefile~self_geometry.f90 sourcefile~self_mappeddata.f90->sourcefile~self_data.f90 sourcefile~self_mappeddata.f90->sourcefile~self_mesh.f90 sourcefile~self_mpilayer.f90 SELF_MPILayer.f90 sourcefile~self_mpilayer.f90->sourcefile~self_data.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mesh.f90 sourcefile~self_mpilayer.f90->sourcefile~self_mappeddata.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules SELF_Memory Source Code SELF_Memory.f90 Source Code MODULE SELF_Memory USE SELF_Constants #ifdef GPU USE hipfort USE hipfort_check #endif USE ISO_FORTRAN_ENV USE ISO_C_BINDING IMPLICIT NONE TYPE hfReal_r1 !! Data type for storing one-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r1 PROCEDURE , PUBLIC :: Free => Free_hfReal_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r1 END TYPE hfReal_r1 TYPE hfReal_r2 !! Data type for storing two-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r2 PROCEDURE , PUBLIC :: Free => Free_hfReal_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r2 END TYPE hfReal_r2 TYPE hfReal_r3 !! Data type for storing three-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r3 PROCEDURE , PUBLIC :: Free => Free_hfReal_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r3 END TYPE hfReal_r3 TYPE hfReal_r4 !! Data type for storing four-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r4 PROCEDURE , PUBLIC :: Free => Free_hfReal_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r4 END TYPE hfReal_r4 TYPE hfReal_r5 !! Data type for storing five-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r5 PROCEDURE , PUBLIC :: Free => Free_hfReal_r5 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r5 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r5 END TYPE hfReal_r5 TYPE hfReal_r6 !! Data type for storing one-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r6 PROCEDURE , PUBLIC :: Free => Free_hfReal_r6 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r6 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r6 END TYPE hfReal_r6 TYPE hfReal_r7 !! Data type for storing seven-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r7 PROCEDURE , PUBLIC :: Free => Free_hfReal_r7 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r7 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r7 END TYPE hfReal_r7 TYPE hfInt32_r1 !! Data type for storing one-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r1 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r1 END TYPE hfInt32_r1 TYPE hfInt32_r2 !! Data type for storing two-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r2 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r2 END TYPE hfInt32_r2 TYPE hfInt32_r3 !! Data type for storing three-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r3 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r3 END TYPE hfInt32_r3 TYPE hfInt32_r4 !! Data type for storing four-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r4 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r4 END TYPE hfInt32_r4 TYPE hfInt32_r5 !! Data type for storing five-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r5 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r5 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r5 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r5 END TYPE hfInt32_r5 TYPE hfInt32_r6 !! Data type for storing six-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r6 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r6 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r6 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r6 END TYPE hfInt32_r6 TYPE hfInt32_r7 !! Data type for storing seven-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r7 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r7 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r7 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r7 END TYPE hfInt32_r7 TYPE hfInt64_r1 !! Data type for storing one-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r1 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r1 END TYPE hfInt64_r1 TYPE hfInt64_r2 !! Data type for storing two-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r2 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r2 END TYPE hfInt64_r2 TYPE hfInt64_r3 !! Data type for storing three-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r3 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r3 END TYPE hfInt64_r3 TYPE hfInt64_r4 !! Data type for storing four-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r4 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r4 END TYPE hfInt64_r4 TYPE hfInt64_r5 !! Data type for storing five-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r5 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r5 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r5 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r5 END TYPE hfInt64_r5 TYPE hfInt64_r6 !! Data type for storing six-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r6 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r6 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r6 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r6 END TYPE hfInt64_r6 TYPE hfInt64_r7 !! Data type for storing seven-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r7 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r7 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r7 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r7 END TYPE hfInt64_r7 CONTAINS SUBROUTINE Alloc_hfReal_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfReal_r1 SUBROUTINE Alloc_hfReal_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfReal_r2 SUBROUTINE Alloc_hfReal_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfReal_r3 SUBROUTINE Alloc_hfReal_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfReal_r4 SUBROUTINE Alloc_hfReal_r5 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 5 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 5 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfReal_r5 SUBROUTINE Alloc_hfReal_r6 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 6 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 6 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfReal_r6 SUBROUTINE Alloc_hfReal_r7 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 7 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 7 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ), & loBound ( 7 ): upBound ( 7 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfReal_r7 SUBROUTINE Alloc_hfInt32_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt32_r1 SUBROUTINE Alloc_hfInt32_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt32_r2 SUBROUTINE Alloc_hfInt32_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt32_r3 SUBROUTINE Alloc_hfInt32_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt32_r4 SUBROUTINE Alloc_hfInt32_r5 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 5 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 5 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt32_r5 SUBROUTINE Alloc_hfInt32_r6 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 6 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 6 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt32_r6 SUBROUTINE Alloc_hfInt32_r7 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 7 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 7 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ), & loBound ( 7 ): upBound ( 7 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt32_r7 SUBROUTINE Alloc_hfInt64_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt64_r1 SUBROUTINE Alloc_hfInt64_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt64_r2 SUBROUTINE Alloc_hfInt64_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt64_r3 SUBROUTINE Alloc_hfInt64_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt64_r4 SUBROUTINE Alloc_hfInt64_r5 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 5 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 5 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt64_r5 SUBROUTINE Alloc_hfInt64_r6 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 6 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 6 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt64_r6 SUBROUTINE Alloc_hfInt64_r7 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 7 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 7 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ), & loBound ( 7 ): upBound ( 7 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt64_r7 SUBROUTINE Free_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfReal_r1 SUBROUTINE Free_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfReal_r2 SUBROUTINE Free_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfReal_r3 SUBROUTINE Free_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfReal_r4 SUBROUTINE Free_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfReal_r5 SUBROUTINE Free_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfReal_r6 SUBROUTINE Free_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfReal_r7 SUBROUTINE Free_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt32_r1 SUBROUTINE Free_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt32_r2 SUBROUTINE Free_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt32_r3 SUBROUTINE Free_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt32_r4 SUBROUTINE Free_hfInt32_r5 ( this ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt32_r5 SUBROUTINE Free_hfInt32_r6 ( this ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt32_r6 SUBROUTINE Free_hfInt32_r7 ( this ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt32_r7 SUBROUTINE Free_hfInt64_r1 ( this ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt64_r1 SUBROUTINE Free_hfInt64_r2 ( this ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt64_r2 SUBROUTINE Free_hfInt64_r3 ( this ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt64_r3 SUBROUTINE Free_hfInt64_r4 ( this ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt64_r4 SUBROUTINE Free_hfInt64_r5 ( this ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt64_r5 SUBROUTINE Free_hfInt64_r6 ( this ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt64_r6 SUBROUTINE Free_hfInt64_r7 ( this ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt64_r7 SUBROUTINE UpdateHost_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfReal_r1 SUBROUTINE UpdateHost_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfReal_r2 SUBROUTINE UpdateHost_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfReal_r3 SUBROUTINE UpdateHost_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfReal_r4 SUBROUTINE UpdateHost_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfReal_r5 SUBROUTINE UpdateHost_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfReal_r6 SUBROUTINE UpdateHost_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfReal_r7 SUBROUTINE UpdateHost_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt32_r1 SUBROUTINE UpdateHost_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt32_r2 SUBROUTINE UpdateHost_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt32_r3 SUBROUTINE UpdateHost_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt32_r4 SUBROUTINE UpdateHost_hfInt32_r5 ( this ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt32_r5 SUBROUTINE UpdateHost_hfInt32_r6 ( this ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt32_r6 SUBROUTINE UpdateHost_hfInt32_r7 ( this ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt32_r7 SUBROUTINE UpdateHost_hfInt64_r1 ( this ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt64_r1 SUBROUTINE UpdateHost_hfInt64_r2 ( this ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt64_r2 SUBROUTINE UpdateHost_hfInt64_r3 ( this ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt64_r3 SUBROUTINE UpdateHost_hfInt64_r4 ( this ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt64_r4 SUBROUTINE UpdateHost_hfInt64_r5 ( this ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt64_r5 SUBROUTINE UpdateHost_hfInt64_r6 ( this ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt64_r6 SUBROUTINE UpdateHost_hfInt64_r7 ( this ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt64_r7 SUBROUTINE UpdateDevice_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfReal_r1 SUBROUTINE UpdateDevice_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfReal_r2 SUBROUTINE UpdateDevice_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfReal_r3 SUBROUTINE UpdateDevice_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfReal_r4 SUBROUTINE UpdateDevice_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfReal_r5 SUBROUTINE UpdateDevice_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfReal_r6 SUBROUTINE UpdateDevice_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfReal_r7 SUBROUTINE UpdateDevice_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt32_r1 SUBROUTINE UpdateDevice_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt32_r2 SUBROUTINE UpdateDevice_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt32_r3 SUBROUTINE UpdateDevice_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt32_r4 SUBROUTINE UpdateDevice_hfInt32_r5 ( this ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt32_r5 SUBROUTINE UpdateDevice_hfInt32_r6 ( this ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt32_r6 SUBROUTINE UpdateDevice_hfInt32_r7 ( this ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt32_r7 SUBROUTINE UpdateDevice_hfInt64_r1 ( this ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt64_r1 SUBROUTINE UpdateDevice_hfInt64_r2 ( this ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt64_r2 SUBROUTINE UpdateDevice_hfInt64_r3 ( this ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt64_r3 SUBROUTINE UpdateDevice_hfInt64_r4 ( this ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt64_r4 SUBROUTINE UpdateDevice_hfInt64_r5 ( this ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt64_r5 SUBROUTINE UpdateDevice_hfInt64_r6 ( this ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt64_r6 SUBROUTINE UpdateDevice_hfInt64_r7 ( this ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt64_r7 END MODULE SELF_Memory","tags":"","loc":"sourcefile/self_memory.f90.html"},{"title":"SELF_Data.cpp – SELF","text":"Contents Source Code SELF_Data.cpp Source Code #include <hip/hip_runtime.h> #include \"SELF_HIP_Macros.h\" /* // Template __global__ void Template_{1D|2D|3D}_gpu( , int N, int nVar){ size_t iVar = hipBlockIdx_x; size_t iEl = hipBlockIdx_y; size_t i = hipThreadIdx_x; size_t j = hipThreadIdx_y; size_t k = hipThreadIdx_z; // How to access scalars f[SC_1D_INDEX(i,iVar,iEl,N,nVar)]; f[SC_2D_INDEX(i,j,iVar,iEl,N,nVar)]; f[SC_3D_INDEX(i,j,k,iVar,iEl,N,nVar)]; // How to access vectors (2d) f[VE_2D_INDEX(1,i,j,iVar,iEl,N,nVar)]; f[VE_2D_INDEX(2,i,j,iVar,iEl,N,nVar)]; // How to access vectors (3d) f[VE_3D_INDEX(1,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(2,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(3,i,j,k,iVar,iEl,N,nVar)]; // How to access tensors (2d) f[TE_2D_INDEX(1,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(1,2,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,2,i,j,iVar,iEl,N,nVar)]; // How to access tensors (3d) f[TE_3D_INDEX(1,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,3,i,j,k,iVar,iEl,N,nVar)]; } extern \"C\" { void Template_{1D|2D|3D}_gpu_wrapper(int N, int nVar) { hipLaunchKernelGGL((Template_{1D|2D|3D}_gpu), dim3(nVar,nEl,1), dim3(N+1,N+1,N+1), 0, 0,  N, M, nVar); } } */ __global__ void Determinant_Tensor2D_gpu ( real * tensor , real * detTensor , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; detTensor [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] = tensor [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , N , nVar )] * tensor [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , N , nVar )] - tensor [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )] * tensor [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )]; } extern \"C\" { void Determinant_Tensor2D_gpu_wrapper ( real ** tensor , real ** detTensor , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( Determinant_Tensor2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * tensor , * detTensor , N , nVar ); } } __global__ void Determinant_Tensor3D_gpu ( real * tensor , real * detTensor , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; detTensor [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 1 , 1 , i , j , k , iVar , iEl , N , nVar )] * ( tensor [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , N , nVar )] * tensor [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , N , nVar )] - tensor [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )] * tensor [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )]) - tensor [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , N , nVar )] * ( tensor [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )] * tensor [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , N , nVar )] - tensor [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] * tensor [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )]) + tensor [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , N , nVar )] * ( tensor [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )] * tensor [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )] - tensor [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] * tensor [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , N , nVar )]); } extern \"C\" { void Determinant_Tensor3D_gpu_wrapper ( real ** tensor , real ** detTensor , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( Determinant_Tensor3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * tensor , * detTensor , N , nVar ); } }","tags":"","loc":"sourcefile/self_data.cpp.html"},{"title":"SELF_Lagrange.cpp – SELF","text":"Contents Source Code SELF_Lagrange.cpp Source Code #include <hip/hip_runtime.h> #include \"SELF_HIP_Macros.h\" /* // Template __global__ void Template_{1D|2D|3D}_gpu( , int N, int nVar, int nEl){ size_t iVar = hipBlockIdx_x; size_t iEl = hipBlockIdx_y; size_t i = hipThreadIdx_x; size_t j = hipThreadIdx_y; size_t k = hipThreadIdx_z; // How to access scalars f[SC_1D_INDEX(i,iVar,iEl,N,nVar)]; f[SC_2D_INDEX(i,j,iVar,iEl,N,nVar)]; f[SC_3D_INDEX(i,j,k,iVar,iEl,N,nVar)]; // How to access vectors (2d) f[VE_2D_INDEX(1,i,j,iVar,iEl,N,nVar)]; f[VE_2D_INDEX(2,i,j,iVar,iEl,N,nVar)]; // How to access vectors (3d) f[VE_3D_INDEX(1,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(2,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(3,i,j,k,iVar,iEl,N,nVar)]; // How to access tensors (2d) f[TE_2D_INDEX(1,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(1,2,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,2,i,j,iVar,iEl,N,nVar)]; // How to access tensors (3d) f[TE_3D_INDEX(1,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,3,i,j,k,iVar,iEl,N,nVar)]; } extern \"C\" { void Template_{1D|2D|3D}_gpu_wrapper(int N, int nVar, int nEl) { hipLaunchKernelGGL((Template_{1D|2D|3D}_gpu), dim3(nVar,nEl,1), dim3(N+1,N+1,N+1), 0, 0,  N, M, nVar); } } */ // ScalarGridInterp_1D // __global__ void ScalarGridInterp_1D_gpu ( real * iMatrix , real * f , real * fInterp , int N , int M , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; real fm = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fm += f [ SC_1D_INDEX ( ii , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; } fInterp [ SC_1D_INDEX ( i , iVar , iEl , M , nVar )] = fm ; } extern \"C\" { void ScalarGridInterp_1D_gpu_wrapper ( real ** iMatrix , real ** f , real ** fInterp , int N , int M , int nVar , int nEl ) { hipLaunchKernelGGL (( ScalarGridInterp_1D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( M + 1 , 1 , 1 ), 0 , 0 , * iMatrix , * f , * fInterp , N , M , nVar ); } } // ScalarGridInterp_2D // __global__ void ScalarGridInterp_2D_gpu ( real * iMatrix , real * f , real * fInterp , int N , int M , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; real fij = 0.0 ; real fi = 0.0 ; for ( int jj = 0 ; jj < N + 1 ; jj ++ ) { fi = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fi += f [ SC_2D_INDEX ( ii , jj , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; } fij += fi * iMatrix [ jj + j * ( N + 1 )]; } fInterp [ SC_2D_INDEX ( i , j , iVar , iEl , M , nVar )] = fij ; } extern \"C\" { void ScalarGridInterp_2D_gpu_wrapper ( real ** iMatrix , real ** f , real ** fInterp , int N , int M , int nVar , int nEl ) { hipLaunchKernelGGL (( ScalarGridInterp_2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( M + 1 , M + 1 , 1 ), 0 , 0 , * iMatrix , * f , * fInterp , N , M , nVar ); } } // VectorGridInterp_2D // __global__ void VectorGridInterp_2D_gpu ( real * iMatrix , real * f , real * fInterp , int N , int M , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; real fij [ 2 ] = { 0.0 }; real fi [ 2 ] = { 0.0 }; for ( int jj = 0 ; jj < N + 1 ; jj ++ ) { fi [ 0 ] = 0.0 ; fi [ 1 ] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fi [ 0 ] += f [ VE_2D_INDEX ( 1 , ii , jj , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 1 ] += f [ VE_2D_INDEX ( 2 , ii , jj , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; } fij [ 0 ] += fi [ 0 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 1 ] += fi [ 1 ] * iMatrix [ jj + j * ( N + 1 )]; } fInterp [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , M , nVar )] = fij [ 0 ]; fInterp [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , M , nVar )] = fij [ 1 ]; } extern \"C\" { void VectorGridInterp_2D_gpu_wrapper ( real ** iMatrix , real ** f , real ** fInterp , int N , int M , int nVar , int nEl ) { hipLaunchKernelGGL (( VectorGridInterp_2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( M + 1 , M + 1 , 1 ), 0 , 0 , * iMatrix , * f , * fInterp , N , M , nVar ); } } // TensorGridInterp_2D // __global__ void TensorGridInterp_2D_gpu ( real * iMatrix , real * f , real * fInterp , int N , int M , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; real fij [ 4 ] = { 0.0 }; real fi [ 4 ] = { 0.0 }; for ( int jj = 0 ; jj < N + 1 ; jj ++ ) { fi [ 0 ] = 0.0 ; fi [ 1 ] = 0.0 ; fi [ 2 ] = 0.0 ; fi [ 3 ] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fi [ 0 ] += f [ TE_2D_INDEX ( 1 , 1 , ii , jj , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 1 ] += f [ TE_2D_INDEX ( 2 , 1 , ii , jj , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 2 ] += f [ TE_2D_INDEX ( 1 , 2 , ii , jj , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 3 ] += f [ TE_2D_INDEX ( 2 , 2 , ii , jj , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; } fij [ 0 ] += fi [ 0 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 1 ] += fi [ 1 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 2 ] += fi [ 2 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 3 ] += fi [ 3 ] * iMatrix [ jj + j * ( N + 1 )]; } fInterp [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , M , nVar )] = fij [ 0 ]; fInterp [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , M , nVar )] = fij [ 1 ]; fInterp [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , M , nVar )] = fij [ 2 ]; fInterp [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , M , nVar )] = fij [ 3 ]; } extern \"C\" { void TensorGridInterp_2D_gpu_wrapper ( real ** iMatrix , real ** f , real ** fInterp , int N , int M , int nVar , int nEl ) { hipLaunchKernelGGL (( TensorGridInterp_2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( M + 1 , M + 1 , 1 ), 0 , 0 , * iMatrix , * f , * fInterp , N , M , nVar ); } } // ScalarGridInterp_3D // __global__ void ScalarGridInterp_3D_gpu ( real * iMatrix , real * f , real * fInterp , int N , int M , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; real fijk = 0.0 ; real fij = 0.0 ; real fi = 0.0 ; for ( int kk = 0 ; kk < N + 1 ; kk ++ ) { fij = 0.0 ; for ( int jj = 0 ; jj < N + 1 ; jj ++ ) { fi = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fi += f [ SC_3D_INDEX ( ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; } fij += fi * iMatrix [ jj + j * ( N + 1 )]; } fijk += fij * iMatrix [ kk + k * ( N + 1 )]; } fInterp [ SC_3D_INDEX ( i , j , k , iVar , iEl , M , nVar )] = fijk ; } extern \"C\" { void ScalarGridInterp_3D_gpu_wrapper ( real ** iMatrix , real ** f , real ** fInterp , int N , int M , int nVar , int nEl ) { hipLaunchKernelGGL (( ScalarGridInterp_3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( M + 1 , M + 1 , M + 1 ), 0 , 0 , * iMatrix , * f , * fInterp , N , M , nVar ); } } // VectorGridInterp_3D // __global__ void VectorGridInterp_3D_gpu ( real * iMatrix , real * f , real * fInterp , int N , int M , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; real fijk [ 3 ] = { 0.0 }; real fij [ 3 ] = { 0.0 }; real fi [ 3 ] = { 0.0 }; for ( int kk = 0 ; kk < N + 1 ; kk ++ ) { fij [ 0 ] = 0.0 ; fij [ 1 ] = 0.0 ; fij [ 2 ] = 0.0 ; for ( int jj = 0 ; jj < N + 1 ; jj ++ ) { fi [ 0 ] = 0.0 ; fi [ 1 ] = 0.0 ; fi [ 2 ] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fi [ 0 ] += f [ VE_3D_INDEX ( 1 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 1 ] += f [ VE_3D_INDEX ( 2 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 2 ] += f [ VE_3D_INDEX ( 3 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; } fij [ 0 ] += fi [ 0 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 1 ] += fi [ 1 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 2 ] += fi [ 2 ] * iMatrix [ jj + j * ( N + 1 )]; } fijk [ 0 ] += fij [ 0 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 1 ] += fij [ 1 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 2 ] += fij [ 2 ] * iMatrix [ kk + k * ( N + 1 )]; } fInterp [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 0 ]; fInterp [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 1 ]; fInterp [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 2 ]; } extern \"C\" { void VectorGridInterp_3D_gpu_wrapper ( real ** iMatrix , real ** f , real ** fInterp , int N , int M , int nVar , int nEl ) { hipLaunchKernelGGL (( VectorGridInterp_3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( M + 1 , M + 1 , M + 1 ), 0 , 0 , * iMatrix , * f , * fInterp , N , M , nVar ); } } // TensorGridInterp_3D // __global__ void TensorGridInterp_3D_gpu ( real * iMatrix , real * f , real * fInterp , int N , int M , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; real fijk [ 9 ] = { 0.0 }; real fij [ 9 ] = { 0.0 }; real fi [ 9 ] = { 0.0 }; for ( int kk = 0 ; kk < N + 1 ; kk ++ ) { fij [ 0 ] = 0.0 ; fij [ 1 ] = 0.0 ; fij [ 2 ] = 0.0 ; fij [ 3 ] = 0.0 ; fij [ 4 ] = 0.0 ; fij [ 5 ] = 0.0 ; fij [ 6 ] = 0.0 ; fij [ 7 ] = 0.0 ; fij [ 8 ] = 0.0 ; for ( int jj = 0 ; jj < N + 1 ; jj ++ ) { fi [ 0 ] = 0.0 ; fi [ 1 ] = 0.0 ; fi [ 2 ] = 0.0 ; fi [ 3 ] = 0.0 ; fi [ 4 ] = 0.0 ; fi [ 5 ] = 0.0 ; fi [ 6 ] = 0.0 ; fi [ 7 ] = 0.0 ; fi [ 8 ] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fi [ 0 ] += f [ TE_3D_INDEX ( 1 , 1 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 1 ] += f [ TE_3D_INDEX ( 2 , 1 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 2 ] += f [ TE_3D_INDEX ( 3 , 1 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 3 ] += f [ TE_3D_INDEX ( 1 , 2 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 4 ] += f [ TE_3D_INDEX ( 2 , 2 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 5 ] += f [ TE_3D_INDEX ( 3 , 2 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 6 ] += f [ TE_3D_INDEX ( 1 , 3 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 7 ] += f [ TE_3D_INDEX ( 2 , 3 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; fi [ 8 ] += f [ TE_3D_INDEX ( 3 , 3 , ii , jj , kk , iVar , iEl , N , nVar )] * iMatrix [ ii + i * ( N + 1 )]; } fij [ 0 ] += fi [ 0 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 1 ] += fi [ 1 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 2 ] += fi [ 2 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 3 ] += fi [ 3 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 4 ] += fi [ 4 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 5 ] += fi [ 5 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 6 ] += fi [ 6 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 7 ] += fi [ 7 ] * iMatrix [ jj + j * ( N + 1 )]; fij [ 8 ] += fi [ 8 ] * iMatrix [ jj + j * ( N + 1 )]; } fijk [ 0 ] += fij [ 0 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 1 ] += fij [ 1 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 2 ] += fij [ 2 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 3 ] += fij [ 3 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 4 ] += fij [ 4 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 5 ] += fij [ 5 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 6 ] += fij [ 6 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 7 ] += fij [ 7 ] * iMatrix [ kk + k * ( N + 1 )]; fijk [ 8 ] += fij [ 8 ] * iMatrix [ kk + k * ( N + 1 )]; } fInterp [ TE_3D_INDEX ( 1 , 1 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 0 ]; fInterp [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 1 ]; fInterp [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 2 ]; fInterp [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 3 ]; fInterp [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 4 ]; fInterp [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 5 ]; fInterp [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 6 ]; fInterp [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 7 ]; fInterp [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , M , nVar )] = fijk [ 8 ]; } extern \"C\" { void TensorGridInterp_3D_gpu_wrapper ( real ** iMatrix , real ** f , real ** fInterp , int N , int M , int nVar , int nEl ) { hipLaunchKernelGGL (( TensorGridInterp_3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( M + 1 , M + 1 , M + 1 ), 0 , 0 , * iMatrix , * f , * fInterp , N , M , nVar ); } } // ScalarBoundaryInterp_1D // __global__ void ScalarBoundaryInterp_1D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t bid = hipThreadIdx_x ; real fb = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fb += f [ SC_1D_INDEX ( ii , iVar , iEl , N , nVar )] * bMatrix [ ii + bid * ( N + 1 )]; } fBound [ SCB_1D_INDEX ( iVar , bid , iEl , N , nVar )] = fb ; } extern \"C\" { void ScalarBoundaryInterp_1D_gpu_wrapper ( real ** bMatrix , real ** f , real ** fBound , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( ScalarBoundaryInterp_1D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( 2 , 1 , 1 ), 0 , 0 , * bMatrix , * f , * fBound , N , nVar ); } } // ScalarBoundaryInterp_2D // __global__ void ScalarBoundaryInterp_2D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; real fb [ 4 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fb [ 0 ] += f [ SC_2D_INDEX ( i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 1 ] += f [ SC_2D_INDEX ( ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 2 ] += f [ SC_2D_INDEX ( i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 3 ] += f [ SC_2D_INDEX ( ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West } fBound [ SCB_2D_INDEX ( i , iVar , 1 , iEl , N , nVar )] = fb [ 0 ]; fBound [ SCB_2D_INDEX ( i , iVar , 2 , iEl , N , nVar )] = fb [ 1 ]; fBound [ SCB_2D_INDEX ( i , iVar , 3 , iEl , N , nVar )] = fb [ 2 ]; fBound [ SCB_2D_INDEX ( i , iVar , 4 , iEl , N , nVar )] = fb [ 3 ]; } extern \"C\" { void ScalarBoundaryInterp_2D_gpu_wrapper ( real ** bMatrix , real ** f , real ** fBound , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( ScalarBoundaryInterp_2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 , * bMatrix , * f , * fBound , N , nVar ); } } // VectorBoundaryInterp_2D // __global__ void VectorBoundaryInterp_2D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t idir = hipThreadIdx_x + 1 ; size_t i = hipThreadIdx_y ; real fb [ 4 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fb [ 0 ] += f [ VE_2D_INDEX ( idir , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 1 ] += f [ VE_2D_INDEX ( idir , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 2 ] += f [ VE_2D_INDEX ( idir , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 3 ] += f [ VE_2D_INDEX ( idir , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West } fBound [ VEB_2D_INDEX ( idir , i , iVar , 1 , iEl , N , nVar )] = fb [ 0 ]; fBound [ VEB_2D_INDEX ( idir , i , iVar , 2 , iEl , N , nVar )] = fb [ 1 ]; fBound [ VEB_2D_INDEX ( idir , i , iVar , 3 , iEl , N , nVar )] = fb [ 2 ]; fBound [ VEB_2D_INDEX ( idir , i , iVar , 4 , iEl , N , nVar )] = fb [ 3 ]; } extern \"C\" { void VectorBoundaryInterp_2D_gpu_wrapper ( real ** bMatrix , real ** f , real ** fBound , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( VectorBoundaryInterp_2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( 2 , N + 1 , 1 ), 0 , 0 , * bMatrix , * f , * fBound , N , nVar ); } } // TensorBoundaryInterp_2D // __global__ void TensorBoundaryInterp_2D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; real fb [ 16 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fb [ 0 ] += f [ TE_2D_INDEX ( 1 , 1 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 1 ] += f [ TE_2D_INDEX ( 1 , 1 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 2 ] += f [ TE_2D_INDEX ( 1 , 1 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 3 ] += f [ TE_2D_INDEX ( 1 , 1 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West fb [ 4 ] += f [ TE_2D_INDEX ( 2 , 1 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 5 ] += f [ TE_2D_INDEX ( 2 , 1 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 6 ] += f [ TE_2D_INDEX ( 2 , 1 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 7 ] += f [ TE_2D_INDEX ( 2 , 1 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West fb [ 8 ] += f [ TE_2D_INDEX ( 1 , 2 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 9 ] += f [ TE_2D_INDEX ( 1 , 2 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 10 ] += f [ TE_2D_INDEX ( 1 , 2 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 11 ] += f [ TE_2D_INDEX ( 1 , 2 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West fb [ 12 ] += f [ TE_2D_INDEX ( 2 , 2 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 13 ] += f [ TE_2D_INDEX ( 2 , 2 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 14 ] += f [ TE_2D_INDEX ( 2 , 2 , i , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 15 ] += f [ TE_2D_INDEX ( 2 , 2 , ii , i , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West } fBound [ TEB_2D_INDEX ( 1 , 1 , i , iVar , 1 , iEl , N , nVar )] = fb [ 0 ]; fBound [ TEB_2D_INDEX ( 1 , 1 , i , iVar , 2 , iEl , N , nVar )] = fb [ 1 ]; fBound [ TEB_2D_INDEX ( 1 , 1 , i , iVar , 3 , iEl , N , nVar )] = fb [ 2 ]; fBound [ TEB_2D_INDEX ( 1 , 1 , i , iVar , 4 , iEl , N , nVar )] = fb [ 3 ]; fBound [ TEB_2D_INDEX ( 2 , 1 , i , iVar , 1 , iEl , N , nVar )] = fb [ 4 ]; fBound [ TEB_2D_INDEX ( 2 , 1 , i , iVar , 2 , iEl , N , nVar )] = fb [ 5 ]; fBound [ TEB_2D_INDEX ( 2 , 1 , i , iVar , 3 , iEl , N , nVar )] = fb [ 6 ]; fBound [ TEB_2D_INDEX ( 2 , 1 , i , iVar , 4 , iEl , N , nVar )] = fb [ 7 ]; fBound [ TEB_2D_INDEX ( 1 , 2 , i , iVar , 1 , iEl , N , nVar )] = fb [ 8 ]; fBound [ TEB_2D_INDEX ( 1 , 2 , i , iVar , 2 , iEl , N , nVar )] = fb [ 9 ]; fBound [ TEB_2D_INDEX ( 1 , 2 , i , iVar , 3 , iEl , N , nVar )] = fb [ 10 ]; fBound [ TEB_2D_INDEX ( 1 , 2 , i , iVar , 4 , iEl , N , nVar )] = fb [ 11 ]; fBound [ TEB_2D_INDEX ( 2 , 2 , i , iVar , 1 , iEl , N , nVar )] = fb [ 12 ]; fBound [ TEB_2D_INDEX ( 2 , 2 , i , iVar , 2 , iEl , N , nVar )] = fb [ 13 ]; fBound [ TEB_2D_INDEX ( 2 , 2 , i , iVar , 3 , iEl , N , nVar )] = fb [ 14 ]; fBound [ TEB_2D_INDEX ( 2 , 2 , i , iVar , 4 , iEl , N , nVar )] = fb [ 15 ]; } extern \"C\" { void TensorBoundaryInterp_2D_gpu_wrapper ( real ** bMatrix , real ** f , real ** fBound , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( TensorBoundaryInterp_2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 , * bMatrix , * f , * fBound , N , nVar ); } } // ScalarBoundaryInterp_3D // __global__ void ScalarBoundaryInterp_3D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; real fb [ 6 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fb [ 0 ] += f [ SC_3D_INDEX ( i , j , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // Bottom fb [ 1 ] += f [ SC_3D_INDEX ( i , ii , j , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 2 ] += f [ SC_3D_INDEX ( ii , i , j , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 3 ] += f [ SC_3D_INDEX ( i , ii , j , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 4 ] += f [ SC_3D_INDEX ( ii , i , j , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West fb [ 5 ] += f [ SC_3D_INDEX ( i , j , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // Top } fBound [ SCB_3D_INDEX ( i , j , iVar , 1 , iEl , N , nVar )] = fb [ 0 ]; fBound [ SCB_3D_INDEX ( i , j , iVar , 2 , iEl , N , nVar )] = fb [ 1 ]; fBound [ SCB_3D_INDEX ( i , j , iVar , 3 , iEl , N , nVar )] = fb [ 2 ]; fBound [ SCB_3D_INDEX ( i , j , iVar , 4 , iEl , N , nVar )] = fb [ 3 ]; fBound [ SCB_3D_INDEX ( i , j , iVar , 5 , iEl , N , nVar )] = fb [ 4 ]; fBound [ SCB_3D_INDEX ( i , j , iVar , 6 , iEl , N , nVar )] = fb [ 5 ]; } extern \"C\" { void ScalarBoundaryInterp_3D_gpu_wrapper ( real ** bMatrix , real ** f , real ** fBound , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( ScalarBoundaryInterp_3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * bMatrix , * f , * fBound , N , nVar ); } } // VectorBoundaryInterp_3D // __global__ void VectorBoundaryInterp_3D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t idir = hipThreadIdx_x + 1 ; size_t i = hipThreadIdx_y ; size_t j = hipThreadIdx_z ; real fb [ 6 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fb [ 0 ] += f [ VE_3D_INDEX ( idir , i , j , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // Bottom fb [ 1 ] += f [ VE_3D_INDEX ( idir , i , ii , j , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fb [ 2 ] += f [ VE_3D_INDEX ( idir , ii , i , j , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fb [ 3 ] += f [ VE_3D_INDEX ( idir , i , ii , j , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fb [ 4 ] += f [ VE_3D_INDEX ( idir , ii , i , j , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West fb [ 5 ] += f [ VE_3D_INDEX ( idir , i , j , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // Top } fBound [ VEB_3D_INDEX ( idir , i , j , iVar , 1 , iEl , N , nVar )] = fb [ 0 ]; fBound [ VEB_3D_INDEX ( idir , i , j , iVar , 2 , iEl , N , nVar )] = fb [ 1 ]; fBound [ VEB_3D_INDEX ( idir , i , j , iVar , 3 , iEl , N , nVar )] = fb [ 2 ]; fBound [ VEB_3D_INDEX ( idir , i , j , iVar , 4 , iEl , N , nVar )] = fb [ 3 ]; fBound [ VEB_3D_INDEX ( idir , i , j , iVar , 5 , iEl , N , nVar )] = fb [ 4 ]; fBound [ VEB_3D_INDEX ( idir , i , j , iVar , 6 , iEl , N , nVar )] = fb [ 5 ]; } extern \"C\" { void VectorBoundaryInterp_3D_gpu_wrapper ( real ** bMatrix , real ** f , real ** fBound , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( VectorBoundaryInterp_3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( 3 , N + 1 , N + 1 ), 0 , 0 , * bMatrix , * f , * fBound , N , nVar ); } } // TensorBoundaryInterp_3D // __global__ void TensorBoundaryInterp_3D_gpu ( real * bMatrix , real * f , real * fBound , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; for ( int col = 1 ; col <= 3 ; col ++ ){ for ( int row = 1 ; row <= 3 ; row ++ ){ fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 1 , iEl , N , nVar )] = 0.0 ; fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 2 , iEl , N , nVar )] = 0.0 ; fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 3 , iEl , N , nVar )] = 0.0 ; fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 4 , iEl , N , nVar )] = 0.0 ; fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 5 , iEl , N , nVar )] = 0.0 ; fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 6 , iEl , N , nVar )] = 0.0 ; } } for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { for ( int col = 1 ; col <= 3 ; col ++ ){ for ( int row = 1 ; row <= 3 ; row ++ ){ fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 1 , iEl , N , nVar )] += f [ TE_3D_INDEX ( row , col , i , j , ii , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // Bottom fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 2 , iEl , N , nVar )] += f [ TE_3D_INDEX ( row , col , i , ii , j , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // South fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 3 , iEl , N , nVar )] += f [ TE_3D_INDEX ( row , col , ii , i , j , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // East fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 4 , iEl , N , nVar )] += f [ TE_3D_INDEX ( row , col , i , ii , j , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // North fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 5 , iEl , N , nVar )] += f [ TE_3D_INDEX ( row , col , ii , i , j , iVar , iEl , N , nVar )] * bMatrix [ ii ]; // West fBound [ TEB_3D_INDEX ( row , col , i , j , iVar , 6 , iEl , N , nVar )] += f [ TE_3D_INDEX ( row , col , i , j , ii , iVar , iEl , N , nVar )] * bMatrix [ ii + ( N + 1 )]; // Top } } } } extern \"C\" { void TensorBoundaryInterp_3D_gpu_wrapper ( real ** bMatrix , real ** f , real ** fBound , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( TensorBoundaryInterp_3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * bMatrix , * f , * fBound , N , nVar ); } } // Derivative_1D // __global__ void Derivative_1D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; real fm = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fm += f [ SC_1D_INDEX ( ii , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; } df [ SC_1D_INDEX ( i , iVar , iEl , N , nVar )] = fm ; } extern \"C\" { void Derivative_1D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( Derivative_1D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 , * dMatrix , * f , * df , N , nVar ); } } // DGDerivative_1D // __global__ void DGDerivative_1D_gpu ( real * dMatrix , real * bMatrix , real * qWeight , real * f , real * bf , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; real fm = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fm += f [ SC_1D_INDEX ( ii , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; } fm += ( bMatrix [ i + ( N + 1 )] * bf [ SCB_1D_INDEX ( iVar , 1 , iEl , N , nVar )] - bMatrix [ i ] * bf [ SCB_1D_INDEX ( iVar , 0 , iEl , N , nVar )]) / qWeight [ i ]; df [ SC_1D_INDEX ( i , iVar , iEl , N , nVar )] = fm ; } extern \"C\" { void DGDerivative_1D_gpu_wrapper ( real ** dMatrix , real ** bMatrix , real ** qWeight , real ** f , real ** bf , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( DGDerivative_1D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 , * dMatrix , * bMatrix , * qWeight , * f , * bf , * df , N , nVar ); } } // ScalarGradient_2D // __global__ void ScalarGradient_2D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; real fs = 0.0 ; real fp = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fs += f [ SC_2D_INDEX ( ii , j , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; fp += f [ SC_2D_INDEX ( i , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; } df [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] = fs ; df [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] = fp ; } extern \"C\" { void ScalarGradient_2D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( ScalarGradient_2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * dMatrix , * f , * df , N , nVar ); } } __global__ void ScalarDGGradient_2D_gpu ( real * dgMatrix , real * bMatrix , real * qWeights , real * f , real * bf , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; real fs = 0.0 ; real fp = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { fs += f [ SC_2D_INDEX ( ii , j , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )]; fp += f [ SC_2D_INDEX ( i , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )]; } fs += ( bf [ SCB_2D_INDEX ( j , iVar , 2 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] - bf [ SCB_2D_INDEX ( j , iVar , 4 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ]; fp += ( bf [ SCB_2D_INDEX ( i , iVar , 3 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] - bf [ SCB_2D_INDEX ( i , iVar , 1 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ]; df [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] = fs ; df [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] = fp ; } extern \"C\" { void ScalarDGGradient_2D_gpu_wrapper ( real ** dgMatrix , real ** bMatrix , real ** qWeights , real ** f , real ** bf , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( ScalarDGGradient_2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * dgMatrix , * bMatrix , * qWeights , * f , * bf , * df , N , nVar ); } } // VectorGradient_2D // __global__ void VectorGradient_2D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; real dfloc [ 4 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { dfloc [ 0 ] += f [ VE_2D_INDEX ( 1 , ii , j , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; dfloc [ 1 ] += f [ VE_2D_INDEX ( 2 , ii , j , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; dfloc [ 2 ] += f [ VE_2D_INDEX ( 1 , i , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; dfloc [ 3 ] += f [ VE_2D_INDEX ( 2 , i , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; } df [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , N , nVar )] = dfloc [ 0 ]; df [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )] = dfloc [ 1 ]; df [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )] = dfloc [ 2 ]; df [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , N , nVar )] = dfloc [ 3 ]; } extern \"C\" { void VectorGradient_2D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( VectorGradient_2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * dMatrix , * f , * df , N , nVar ); } } // VectorDGGradient_2D // __global__ void VectorDGGradient_2D_gpu ( real * dgMatrix , real * bMatrix , real * qWeights , real * f , real * bf , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; real dfloc [ 4 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { dfloc [ 0 ] += f [ VE_2D_INDEX ( 1 , ii , j , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )]; dfloc [ 1 ] += f [ VE_2D_INDEX ( 2 , ii , j , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )]; dfloc [ 2 ] += f [ VE_2D_INDEX ( 1 , i , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )]; dfloc [ 3 ] += f [ VE_2D_INDEX ( 2 , i , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )]; } dfloc [ 0 ] += ( bf [ VEB_2D_INDEX ( 1 , j , iVar , 2 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] - bf [ VEB_2D_INDEX ( 1 , j , iVar , 4 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ]; dfloc [ 1 ] += ( bf [ VEB_2D_INDEX ( 2 , j , iVar , 2 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] - bf [ VEB_2D_INDEX ( 2 , j , iVar , 4 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ]; dfloc [ 2 ] += ( bf [ VEB_2D_INDEX ( 1 , i , iVar , 3 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] - bf [ VEB_2D_INDEX ( 1 , i , iVar , 1 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ]; dfloc [ 3 ] += ( bf [ VEB_2D_INDEX ( 2 , i , iVar , 3 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] - bf [ VEB_2D_INDEX ( 2 , i , iVar , 1 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ]; df [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , N , nVar )] = dfloc [ 0 ]; df [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )] = dfloc [ 1 ]; df [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )] = dfloc [ 2 ]; df [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , N , nVar )] = dfloc [ 3 ]; } extern \"C\" { void VectorDGGradient_2D_gpu_wrapper ( real ** dMatrix , real ** bMatrix , real ** qWeights , real ** f , real ** bf , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( VectorDGGradient_2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * dMatrix , * bMatrix , * qWeights , * f , * bf , * df , N , nVar ); } } // VectorDivergence_2D // __global__ void VectorDivergence_2D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; real dfloc = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { dfloc += f [ VE_2D_INDEX ( 1 , ii , j , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )] + f [ VE_2D_INDEX ( 2 , i , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; } df [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] = dfloc ; } extern \"C\" { void VectorDivergence_2D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( VectorDivergence_2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * dMatrix , * f , * df , N , nVar ); } } // VectorDGDivergence_2D // __global__ void VectorDGDivergence_2D_gpu ( real * dgMatrix , real * bMatrix , real * qWeights , real * f , real * bf , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; df [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { df [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] += f [ VE_2D_INDEX ( 1 , ii , j , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )] + f [ VE_2D_INDEX ( 2 , i , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )]; } df [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] += ( bf [ VEB_2D_INDEX ( 1 , j , iVar , 2 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] + bf [ VEB_2D_INDEX ( 1 , j , iVar , 4 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ] + ( bf [ VEB_2D_INDEX ( 2 , i , iVar , 3 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] + bf [ VEB_2D_INDEX ( 2 , i , iVar , 1 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ]; } extern \"C\" { void VectorDGDivergence_2D_gpu_wrapper ( real ** dgMatrix , real ** bMatrix , real ** qWeights , real ** f , real ** bf , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( VectorDGDivergence_2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * dgMatrix , * bMatrix , * qWeights , * f , * bf , * df , N , nVar ); } } // VectorCurl_2D // __global__ void VectorCurl_2D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; real dfloc = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { dfloc += f [ VE_2D_INDEX ( 2 , i , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )] - f [ VE_2D_INDEX ( 1 , ii , j , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; } df [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] = dfloc ; } extern \"C\" { void VectorCurl_2D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( VectorCurl_2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * dMatrix , * f , * df , N , nVar ); } } // TensorDivergence_2D // __global__ void TensorDivergence_2D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; real df1 = 0.0 ; real df2 = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { df1 += f [ TE_2D_INDEX ( 1 , 1 , ii , j , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )] + f [ TE_2D_INDEX ( 2 , 1 , i , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; df2 += f [ TE_2D_INDEX ( 1 , 2 , ii , j , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )] + f [ TE_2D_INDEX ( 2 , 2 , i , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; } df [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] = df1 ; df [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] = df2 ; } extern \"C\" { void TensorDivergence_2D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( TensorDivergence_2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * dMatrix , * f , * df , N , nVar ); } } // TensorDGDivergence_2D // __global__ void TensorDGDivergence_2D_gpu ( real * dgMatrix , real * bMatrix , real * qWeights , real * f , real * bf , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; df [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] = 0.0 ; df [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { df [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] += f [ TE_2D_INDEX ( 1 , 1 , ii , j , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )] + f [ TE_2D_INDEX ( 2 , 1 , i , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )]; df [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] += f [ TE_2D_INDEX ( 1 , 2 , ii , j , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )] + f [ TE_2D_INDEX ( 2 , 2 , i , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )]; } df [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] += ( bf [ TEB_2D_INDEX ( 1 , 1 , j , iVar , 2 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] + bf [ TEB_2D_INDEX ( 1 , 1 , j , iVar , 4 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ] + ( bf [ TEB_2D_INDEX ( 2 , 1 , i , iVar , 3 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] + bf [ TEB_2D_INDEX ( 2 , 1 , i , iVar , 1 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ]; df [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] += ( bf [ TEB_2D_INDEX ( 1 , 2 , j , iVar , 2 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] + bf [ TEB_2D_INDEX ( 1 , 2 , j , iVar , 4 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ] + ( bf [ TEB_2D_INDEX ( 2 , 2 , i , iVar , 3 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] + bf [ TEB_2D_INDEX ( 2 , 2 , i , iVar , 1 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ]; } extern \"C\" { void TensorDGDivergence_2D_gpu_wrapper ( real ** dgMatrix , real ** bMatrix , real ** qWeights , real ** f , real ** bf , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( TensorDGDivergence_2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * dgMatrix , * bMatrix , * qWeights , * f , * bf , * df , N , nVar ); } } // ScalarGradient_3D // __global__ void ScalarGradient_3D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; real dfloc [ 3 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { dfloc [ 0 ] += f [ SC_3D_INDEX ( ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; dfloc [ 1 ] += f [ SC_3D_INDEX ( i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; dfloc [ 2 ] += f [ SC_3D_INDEX ( i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; } df [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 0 ]; df [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 1 ]; df [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 2 ]; } extern \"C\" { void ScalarGradient_3D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( ScalarGradient_3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * dMatrix , * f , * df , N , nVar ); } } // VectorGradient_3D // __global__ void VectorGradient_3D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; real dfloc [ 9 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { dfloc [ 0 ] += f [ VE_3D_INDEX ( 1 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; dfloc [ 1 ] += f [ VE_3D_INDEX ( 2 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; dfloc [ 2 ] += f [ VE_3D_INDEX ( 3 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; dfloc [ 3 ] += f [ VE_3D_INDEX ( 1 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; dfloc [ 4 ] += f [ VE_3D_INDEX ( 2 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; dfloc [ 5 ] += f [ VE_3D_INDEX ( 3 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )]; dfloc [ 6 ] += f [ VE_3D_INDEX ( 1 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; dfloc [ 7 ] += f [ VE_3D_INDEX ( 2 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; dfloc [ 8 ] += f [ VE_3D_INDEX ( 3 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; } df [ TE_3D_INDEX ( 1 , 1 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 0 ]; df [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 1 ]; df [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 2 ]; df [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 3 ]; df [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 4 ]; df [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 5 ]; df [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 6 ]; df [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 7 ]; df [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 8 ]; } extern \"C\" { void VectorGradient_3D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( VectorGradient_3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * dMatrix , * f , * df , N , nVar ); } } // VectorDivergence_3D // __global__ void VectorDivergence_3D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; df [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { df [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] += f [ VE_3D_INDEX ( 1 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )] + f [ VE_3D_INDEX ( 2 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )] + f [ VE_3D_INDEX ( 3 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; } } extern \"C\" { void VectorDivergence_3D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( VectorDivergence_3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * dMatrix , * f , * df , N , nVar ); } } // VectorDGDivergence_3D // __global__ void VectorDGDivergence_3D_gpu ( real * dgMatrix , real * bMatrix , real * qWeights , real * f , real * bf , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; df [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { df [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] += f [ VE_3D_INDEX ( 1 , ii , j , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )] + f [ VE_3D_INDEX ( 2 , i , ii , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )] + f [ VE_3D_INDEX ( 3 , i , j , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + k * ( N + 1 )]; } df [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] += ( bf [ VEB_3D_INDEX ( 1 , j , k , iVar , 3 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] + bf [ VEB_3D_INDEX ( 1 , j , k , iVar , 5 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ] + ( bf [ VEB_3D_INDEX ( 2 , i , k , iVar , 4 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] + bf [ VEB_3D_INDEX ( 2 , i , k , iVar , 2 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ] + ( bf [ VEB_3D_INDEX ( 3 , i , j , iVar , 6 , iEl , N , nVar )] * bMatrix [ k + ( N + 1 )] + bf [ VEB_3D_INDEX ( 3 , i , j , iVar , 1 , iEl , N , nVar )] * bMatrix [ k ]) / qWeights [ k ]; } extern \"C\" { void VectorDGDivergence_3D_gpu_wrapper ( real ** dgMatrix , real ** bMatrix , real ** qWeights , real ** f , real ** bf , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( VectorDGDivergence_3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * dgMatrix , * bMatrix , * qWeights , * f , * bf , * df , N , nVar ); } } // VectorCurl_3D // __global__ void VectorCurl_3D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; real dfloc [ 3 ] = { 0.0 }; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { dfloc [ 0 ] += f [ VE_3D_INDEX ( 3 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )] - f [ VE_3D_INDEX ( 2 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; dfloc [ 1 ] += f [ VE_3D_INDEX ( 1 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )] - f [ VE_3D_INDEX ( 3 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; dfloc [ 2 ] += f [ VE_3D_INDEX ( 2 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )] - f [ VE_3D_INDEX ( 1 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )]; } df [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 0 ]; df [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 1 ]; df [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] = dfloc [ 2 ]; } extern \"C\" { void VectorCurl_3D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( VectorCurl_3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * dMatrix , * f , * df , N , nVar ); } } // TensorDivergence_3D // __global__ void TensorDivergence_3D_gpu ( real * dMatrix , real * f , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; real df1 = 0.0 ; real df2 = 0.0 ; real df3 = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { df1 += f [ TE_3D_INDEX ( 1 , 1 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )] + f [ TE_3D_INDEX ( 2 , 1 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )] + f [ TE_3D_INDEX ( 3 , 1 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; df2 += f [ TE_3D_INDEX ( 1 , 2 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )] + f [ TE_3D_INDEX ( 2 , 2 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )] + f [ TE_3D_INDEX ( 3 , 2 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; df3 += f [ TE_3D_INDEX ( 1 , 3 , ii , j , k , iVar , iEl , N , nVar )] * dMatrix [ ii + i * ( N + 1 )] + f [ TE_3D_INDEX ( 2 , 3 , i , ii , k , iVar , iEl , N , nVar )] * dMatrix [ ii + j * ( N + 1 )] + f [ TE_3D_INDEX ( 3 , 3 , i , j , ii , iVar , iEl , N , nVar )] * dMatrix [ ii + k * ( N + 1 )]; } df [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] = df1 ; df [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] = df2 ; df [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] = df3 ; } extern \"C\" { void TensorDivergence_3D_gpu_wrapper ( real ** dMatrix , real ** f , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( TensorDivergence_3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * dMatrix , * f , * df , N , nVar ); } } // TensorDGDivergence_3D // __global__ void TensorDGDivergence_3D_gpu ( real * dgMatrix , real * bMatrix , real * qWeights , real * f , real * bf , real * df , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; df [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] = 0.0 ; df [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] = 0.0 ; df [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] = 0.0 ; for ( int ii = 0 ; ii < N + 1 ; ii ++ ) { df [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] += f [ TE_3D_INDEX ( 1 , 1 , ii , j , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )] + f [ TE_3D_INDEX ( 2 , 1 , i , ii , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )] + f [ TE_3D_INDEX ( 3 , 1 , i , j , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + k * ( N + 1 )]; df [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] += f [ TE_3D_INDEX ( 1 , 2 , ii , j , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )] + f [ TE_3D_INDEX ( 2 , 2 , i , ii , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )] + f [ TE_3D_INDEX ( 3 , 2 , i , j , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + k * ( N + 1 )]; df [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] += f [ TE_3D_INDEX ( 1 , 3 , ii , j , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + i * ( N + 1 )] + f [ TE_3D_INDEX ( 2 , 3 , i , ii , k , iVar , iEl , N , nVar )] * dgMatrix [ ii + j * ( N + 1 )] + f [ TE_3D_INDEX ( 3 , 3 , i , j , ii , iVar , iEl , N , nVar )] * dgMatrix [ ii + k * ( N + 1 )]; } df [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] += ( bf [ TEB_3D_INDEX ( 1 , 1 , j , k , iVar , 3 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] + bf [ TEB_3D_INDEX ( 1 , 1 , j , k , iVar , 5 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ] + ( bf [ TEB_3D_INDEX ( 2 , 1 , i , k , iVar , 4 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] + bf [ TEB_3D_INDEX ( 2 , 1 , i , k , iVar , 2 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ] + ( bf [ TEB_3D_INDEX ( 3 , 1 , i , j , iVar , 6 , iEl , N , nVar )] * bMatrix [ k + ( N + 1 )] + bf [ TEB_3D_INDEX ( 3 , 1 , i , j , iVar , 1 , iEl , N , nVar )] * bMatrix [ k ]) / qWeights [ k ]; df [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] += ( bf [ TEB_3D_INDEX ( 1 , 2 , j , k , iVar , 3 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] + bf [ TEB_3D_INDEX ( 1 , 2 , j , k , iVar , 5 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ] + ( bf [ TEB_3D_INDEX ( 2 , 2 , i , k , iVar , 4 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] + bf [ TEB_3D_INDEX ( 2 , 2 , i , k , iVar , 2 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ] + ( bf [ TEB_3D_INDEX ( 3 , 2 , i , j , iVar , 6 , iEl , N , nVar )] * bMatrix [ k + ( N + 1 )] + bf [ TEB_3D_INDEX ( 3 , 2 , i , j , iVar , 1 , iEl , N , nVar )] * bMatrix [ k ]) / qWeights [ k ]; df [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] += ( bf [ TEB_3D_INDEX ( 1 , 3 , j , k , iVar , 3 , iEl , N , nVar )] * bMatrix [ i + ( N + 1 )] + bf [ TEB_3D_INDEX ( 1 , 3 , j , k , iVar , 5 , iEl , N , nVar )] * bMatrix [ i ]) / qWeights [ i ] + ( bf [ TEB_3D_INDEX ( 2 , 3 , i , k , iVar , 4 , iEl , N , nVar )] * bMatrix [ j + ( N + 1 )] + bf [ TEB_3D_INDEX ( 2 , 3 , i , k , iVar , 2 , iEl , N , nVar )] * bMatrix [ j ]) / qWeights [ j ] + ( bf [ TEB_3D_INDEX ( 3 , 3 , i , j , iVar , 6 , iEl , N , nVar )] * bMatrix [ k + ( N + 1 )] + bf [ TEB_3D_INDEX ( 3 , 3 , i , j , iVar , 1 , iEl , N , nVar )] * bMatrix [ k ]) / qWeights [ k ]; } extern \"C\" { void TensorDGDivergence_3D_gpu_wrapper ( real ** dgMatrix , real ** bMatrix , real ** qWeights , real ** f , real ** bf , real ** df , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( TensorDGDivergence_3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * dgMatrix , * bMatrix , * qWeights , * f , * bf , * df , N , nVar ); } }","tags":"","loc":"sourcefile/self_lagrange.cpp.html"},{"title":"SELF_MappedData.cpp – SELF","text":"Contents Source Code SELF_MappedData.cpp Source Code #include <hip/hip_runtime.h> #include \"SELF_HIP_Macros.h\" /* // Template __global__ void Template_{1D|2D|3D}_gpu( , int N, int nVar){ size_t iVar = hipBlockIdx_x; size_t iEl = hipBlockIdx_y; size_t i = hipThreadIdx_x; size_t j = hipThreadIdx_y; size_t k = hipThreadIdx_z; // How to access scalars f[SC_1D_INDEX(i,iVar,iEl,N,nVar)]; f[SC_2D_INDEX(i,j,iVar,iEl,N,nVar)]; f[SC_3D_INDEX(i,j,k,iVar,iEl,N,nVar)]; // How to access vectors (2d) f[VE_2D_INDEX(1,i,j,iVar,iEl,N,nVar)]; f[VE_2D_INDEX(2,i,j,iVar,iEl,N,nVar)]; // How to access vectors (3d) f[VE_3D_INDEX(1,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(2,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(3,i,j,k,iVar,iEl,N,nVar)]; // How to access tensors (2d) f[TE_2D_INDEX(1,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(1,2,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,2,i,j,iVar,iEl,N,nVar)]; // How to access tensors (3d) f[TE_3D_INDEX(1,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,3,i,j,k,iVar,iEl,N,nVar)]; } extern \"C\" { void Template_{1D|2D|3D}_gpu_wrapper(int N, int nVar) { hipLaunchKernelGGL((Template_{1D|2D|3D}_gpu), dim3(nVar,nEl,1), dim3(N+1,N+1,N+1), 0, 0,  N, M, nVar); } } */ // JacobianWeight_MappedScalar1D_gpu __global__ void JacobianWeight_MappedScalar1D_gpu ( real * scalar , real * dxds , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; scalar [ SC_1D_INDEX ( i , iVar , iEl , N , nVar )] = scalar [ SC_1D_INDEX ( i , iVar , iEl , N , nVar )] / dxds [ SC_1D_INDEX ( i , 0 , iEl , N , 1 )]; } extern \"C\" { void JacobianWeight_MappedScalar1D_gpu_wrapper ( real ** scalar , real ** dxds , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( JacobianWeight_MappedScalar1D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 , * scalar , * dxds , N , nVar ); } } // JacobianWeight_MappedScalar2D_gpu __global__ void JacobianWeight_MappedScalar2D_gpu ( real * scalar , real * jacobian , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; scalar [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] = scalar [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] / jacobian [ SC_2D_INDEX ( i , j , 0 , iEl , N , 1 )]; } extern \"C\" { void JacobianWeight_MappedScalar2D_gpu_wrapper ( real ** scalar , real ** jacobian , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( JacobianWeight_MappedScalar2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * scalar , * jacobian , N , nVar ); } } // JacobianWeight_MappedScalar3D_gpu __global__ void JacobianWeight_MappedScalar3D_gpu ( real * scalar , real * jacobian , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] = scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; } extern \"C\" { void JacobianWeight_MappedScalar3D_gpu_wrapper ( real ** scalar , real ** jacobian , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( JacobianWeight_MappedScalar3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * scalar , * jacobian , N , nVar ); } } // ContravariantWeight_MappedScalar2D_gpu __global__ void ContravariantWeight_MappedScalar2D_gpu ( real * scalar , real * workTensor , real * dsdx , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; workTensor [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , N , nVar )] = dsdx [ TE_2D_INDEX ( 1 , 1 , i , j , 0 , iEl , N , 1 )] * scalar [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )]; workTensor [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )] = dsdx [ TE_2D_INDEX ( 1 , 2 , i , j , 0 , iEl , N , 1 )] * scalar [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )]; workTensor [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )] = dsdx [ TE_2D_INDEX ( 2 , 1 , i , j , 0 , iEl , N , 1 )] * scalar [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )]; workTensor [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , N , nVar )] = dsdx [ TE_2D_INDEX ( 2 , 2 , i , j , 0 , iEl , N , 1 )] * scalar [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )]; } extern \"C\" { void ContravariantWeight_MappedScalar2D_gpu_wrapper ( real ** scalar , real ** workTensor , real ** dsdx , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( ContravariantWeight_MappedScalar2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * scalar , * workTensor , * dsdx , N , nVar ); } } // ContravariantWeightBoundary_MappedScalar2D_gpu __global__ void ContravariantWeightBoundary_MappedScalar2D_gpu ( real * scalar , real * workTensor , real * dsdx , int N , int nVar ){ size_t iSide = hipBlockIdx_x + 1 ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t iVar = hipThreadIdx_y ; workTensor [ TEB_2D_INDEX ( 1 , 1 , i , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_2D_INDEX ( 1 , 1 , i , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_2D_INDEX ( i , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_2D_INDEX ( 2 , 1 , i , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_2D_INDEX ( 1 , 2 , i , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_2D_INDEX ( i , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_2D_INDEX ( 1 , 2 , i , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_2D_INDEX ( 2 , 1 , i , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_2D_INDEX ( i , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_2D_INDEX ( 2 , 2 , i , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_2D_INDEX ( 2 , 2 , i , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_2D_INDEX ( i , iVar , iSide , iEl , N , nVar )]; } extern \"C\" { void ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper ( real ** scalar , real ** workTensor , real ** dsdx , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( ContravariantWeightBoundary_MappedScalar2D_gpu ), dim3 ( 4 , nEl , 1 ), dim3 ( N + 1 , nVar , 1 ), 0 , 0 , * scalar , * workTensor , * dsdx , N , nVar ); } } // ContravariantWeight_MappedScalar3D_gpu __global__ void ContravariantWeight_MappedScalar3D_gpu ( real * scalar , real * workTensor , real * dsdx , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; workTensor [ TE_3D_INDEX ( 1 , 1 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; workTensor [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] * scalar [ SC_3D_INDEX ( i , j , k , iVar , iEl , N , nVar )]; } extern \"C\" { void ContravariantWeight_MappedScalar3D_gpu_wrapper ( real ** scalar , real ** workTensor , real ** dsdx , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( ContravariantWeight_MappedScalar3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * scalar , * workTensor , * dsdx , N , nVar ); } } // ContravariantWeightBoundary_MappedScalar3D_gpu __global__ void ContravariantWeightBoundary_MappedScalar3D_gpu ( real * scalar , real * workTensor , real * dsdx , int N , int nVar ){ size_t iSide = hipBlockIdx_x + 1 ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t iVar = hipThreadIdx_z ; workTensor [ TEB_3D_INDEX ( 1 , 1 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 1 , 1 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 2 , 1 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 1 , 2 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 3 , 1 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 1 , 3 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 1 , 2 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 2 , 1 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 2 , 2 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 2 , 2 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 3 , 2 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 2 , 3 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 1 , 3 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 3 , 1 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 2 , 3 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 3 , 2 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; workTensor [ TEB_3D_INDEX ( 3 , 3 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 3 , 3 , i , j , 0 , iSide , iEl , N , 1 )] * scalar [ SCB_3D_INDEX ( i , j , iVar , iSide , iEl , N , nVar )]; } extern \"C\" { void ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper ( real ** scalar , real ** workTensor , real ** dsdx , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( ContravariantWeightBoundary_MappedScalar3D_gpu ), dim3 ( 6 , nEl , 1 ), dim3 ( N + 1 , N + 1 , nVar ), 0 , 0 , * scalar , * workTensor , * dsdx , N , nVar ); } } // ContravariantProjection_MappedVector2D_gpu __global__ void ContravariantProjection_MappedVector2D_gpu ( real * physVector , real * compVector , real * dsdx , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; compVector [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] = dsdx [ TE_2D_INDEX ( 1 , 1 , i , j , 0 , iEl , N , 1 )] * physVector [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] + dsdx [ TE_2D_INDEX ( 2 , 1 , i , j , 0 , iEl , N , 1 )] * physVector [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )]; compVector [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] = dsdx [ TE_2D_INDEX ( 1 , 2 , i , j , 0 , iEl , N , 1 )] * physVector [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] + dsdx [ TE_2D_INDEX ( 2 , 2 , i , j , 0 , iEl , N , 1 )] * physVector [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )]; } extern \"C\" { void ContravariantProjection_MappedVector2D_gpu_wrapper ( real ** physVector , real ** compVector , real ** dsdx , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( ContravariantProjection_MappedVector2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * physVector , * compVector , * dsdx , N , nVar ); } } __global__ void ContravariantProjectionBoundary_MappedVector2D_gpu ( real * physVector , real * compVector , real * dsdx , int N , int nVar ){ size_t iSide = hipBlockIdx_x + 1 ; size_t iVar = hipBlockIdx_y ; size_t iEl = hipBlockIdx_z ; size_t i = hipThreadIdx_x ; compVector [ VEB_2D_INDEX ( 1 , i , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_2D_INDEX ( 1 , 1 , i , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_2D_INDEX ( 1 , i , iVar , iSide , iEl , N , nVar )] + dsdx [ TEB_2D_INDEX ( 2 , 1 , i , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_2D_INDEX ( 2 , i , iVar , iSide , iEl , N , nVar )]; compVector [ VEB_2D_INDEX ( 2 , i , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_2D_INDEX ( 1 , 2 , i , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_2D_INDEX ( 1 , i , iVar , iSide , iEl , N , nVar )] + dsdx [ TEB_2D_INDEX ( 2 , 2 , i , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_2D_INDEX ( 2 , i , iVar , iSide , iEl , N , nVar )]; } extern \"C\" { void ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper ( real ** physVector , real ** compVector , real ** dsdx , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( ContravariantProjectionBoundary_MappedVector2D_gpu ), dim3 ( 4 , nVar , nEl ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 , * physVector , * compVector , * dsdx , N , nVar ); } } // JacobianWeight_MappedVector2D_gpu __global__ void JacobianWeight_MappedVector2D_gpu ( real * vector , real * jacobian , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; vector [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] = vector [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )] / jacobian [ SC_2D_INDEX ( i , j , 0 , iEl , N , 1 )]; vector [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] = vector [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )] / jacobian [ SC_2D_INDEX ( i , j , 0 , iEl , N , 1 )]; } extern \"C\" { void JacobianWeight_MappedVector2D_gpu_wrapper ( real ** vector , real ** jacobian , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( JacobianWeight_MappedVector2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * vector , * jacobian , N , nVar ); } } // ContravariantProjection_MappedVector3D_gpu __global__ void ContravariantProjection_MappedVector3D_gpu ( real * physVector , real * compVector , real * dsdx , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; compVector [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] + dsdx [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] + dsdx [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )]; compVector [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] + dsdx [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] + dsdx [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )]; compVector [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] = dsdx [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] + dsdx [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] + dsdx [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] * physVector [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )]; } extern \"C\" { void ContravariantProjection_MappedVector3D_gpu_wrapper ( real ** physVector , real ** compVector , real ** dsdx , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( ContravariantProjection_MappedVector3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * physVector , * compVector , * dsdx , N , nVar ); } } __global__ void ContravariantProjectionBoundary_MappedVector3D_gpu ( real * physVector , real * compVector , real * dsdx , int N , int nVar ){ size_t iSide = hipBlockIdx_x + 1 ; size_t iVar = hipBlockIdx_y ; size_t iEl = hipBlockIdx_z ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; compVector [ VEB_3D_INDEX ( 1 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 1 , 1 , i , j , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_3D_INDEX ( 1 , i , j , iVar , iSide , iEl , N , nVar )] + dsdx [ TEB_3D_INDEX ( 2 , 1 , i , j , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_3D_INDEX ( 2 , i , j , iVar , iSide , iEl , N , nVar )] + dsdx [ TEB_3D_INDEX ( 3 , 1 , i , j , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_3D_INDEX ( 3 , i , j , iVar , iSide , iEl , N , nVar )]; compVector [ VEB_3D_INDEX ( 2 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 1 , 2 , i , j , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_3D_INDEX ( 1 , i , j , iVar , iSide , iEl , N , nVar )] + dsdx [ TEB_3D_INDEX ( 2 , 2 , i , j , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_3D_INDEX ( 2 , i , j , iVar , iSide , iEl , N , nVar )] + dsdx [ TEB_3D_INDEX ( 3 , 2 , i , j , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_3D_INDEX ( 3 , i , j , iVar , iSide , iEl , N , nVar )]; compVector [ VEB_3D_INDEX ( 3 , i , j , iVar , iSide , iEl , N , nVar )] = dsdx [ TEB_3D_INDEX ( 1 , 3 , i , j , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_3D_INDEX ( 1 , i , j , iVar , iSide , iEl , N , nVar )] + dsdx [ TEB_3D_INDEX ( 2 , 3 , i , j , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_3D_INDEX ( 2 , i , j , iVar , iSide , iEl , N , nVar )] + dsdx [ TEB_3D_INDEX ( 3 , 3 , i , j , 0 , iSide , iEl , N , 1 )] * physVector [ VEB_3D_INDEX ( 3 , i , j , iVar , iSide , iEl , N , nVar )]; } extern \"C\" { void ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper ( real ** physVector , real ** compVector , real ** dsdx , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( ContravariantProjectionBoundary_MappedVector3D_gpu ), dim3 ( 6 , nVar , nEl ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * physVector , * compVector , * dsdx , N , nVar ); } } // JacobianWeight_MappedVector3D_gpu __global__ void JacobianWeight_MappedVector3D_gpu ( real * vector , real * jacobian , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; vector [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; vector [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; vector [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; } extern \"C\" { void JacobianWeight_MappedVector3D_gpu_wrapper ( real ** vector , real ** jacobian , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( JacobianWeight_MappedVector3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * vector , * jacobian , N , nVar ); } } // JacobianWeight_MappedTensor2D_gpu __global__ void JacobianWeight_MappedTensor2D_gpu ( real * tensor , real * jacobian , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; tensor [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , N , nVar )] = tensor [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , N , nVar )] / jacobian [ SC_2D_INDEX ( i , j , 0 , iEl , N , 1 )]; tensor [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )] = tensor [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )] / jacobian [ SC_2D_INDEX ( i , j , 0 , iEl , N , 1 )]; tensor [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )] = tensor [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )] / jacobian [ SC_2D_INDEX ( i , j , 0 , iEl , N , 1 )]; tensor [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , N , nVar )] = tensor [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , N , nVar )] / jacobian [ SC_2D_INDEX ( i , j , 0 , iEl , N , 1 )]; } extern \"C\" { void JacobianWeight_MappedTensor2D_gpu_wrapper ( real ** tensor , real ** jacobian , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( JacobianWeight_MappedTensor2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * tensor , * jacobian , N , nVar ); } } // JacobianWeight_MappedTensor3D_gpu __global__ void JacobianWeight_MappedTensor3D_gpu ( real * tensor , real * jacobian , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; tensor [ TE_3D_INDEX ( 1 , 1 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 1 , 1 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; tensor [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , N , nVar )] = tensor [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , N , nVar )] / jacobian [ SC_3D_INDEX ( i , j , k , 0 , iEl , N , 1 )]; } extern \"C\" { void JacobianWeight_MappedTensor3D_gpu_wrapper ( real ** tensor , real ** jacobian , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( JacobianWeight_MappedTensor3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * tensor , * jacobian , N , nVar ); } } // CalculateCurl_MappedTensor2D_gpu __global__ void CalculateCurl_MappedTensor2D_gpu ( real * dfdx , real * curlf , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; curlf [ SC_2D_INDEX ( i , j , iVar , iEl , N , nVar )] = dfdx [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )] - dfdx [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )]; } extern \"C\" { void CalculateCurl_MappedTensor2D_gpu_wrapper ( real ** dfdx , real ** curlf , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( JacobianWeight_MappedTensor2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * dfdx , * curlf , N , nVar ); } } // CalculateCurl_MappedTensor3D_gpu __global__ void CalculateCurl_MappedTensor3D_gpu ( real * dfdx , real * curlf , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; curlf [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )] = dfdx [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )] - dfdx [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )]; curlf [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )] = dfdx [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] - dfdx [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , N , nVar )]; curlf [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )] = dfdx [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , N , nVar )] - dfdx [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )]; } extern \"C\" { void CalculateCurl_MappedTensor3D_gpu_wrapper ( real ** dfdx , real ** curlf , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( JacobianWeight_MappedTensor3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * dfdx , * curlf , N , nVar ); } } // MapTo support routines __global__ void MapToScalar_MappedVector2D_gpu ( real * scalar , real * vector , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t jVar = 2 * ( iVar ); scalar [ SC_2D_INDEX ( i , j , jVar , iEl , N , nVar * 2 )] = vector [ VE_2D_INDEX ( 1 , i , j , iVar , iEl , N , nVar )]; jVar += 1 ; scalar [ SC_2D_INDEX ( i , j , jVar , iEl , N , nVar * 2 )] = vector [ VE_2D_INDEX ( 2 , i , j , iVar , iEl , N , nVar )]; } extern \"C\" { void MapToScalar_MappedVector2D_gpu_wrapper ( real ** scalar , real ** vector , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( MapToScalar_MappedVector2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * scalar , * vector , N , nVar ); } } __global__ void MapToScalarBoundary_MappedVector2D_gpu ( real * scalar , real * vector , int N , int nVar ){ size_t iSide = hipBlockIdx_x + 1 ; size_t iVar = hipBlockIdx_y ; size_t iEl = hipBlockIdx_z ; size_t j = hipThreadIdx_x ; size_t jVar = 2 * ( iVar ); scalar [ SCB_2D_INDEX ( j , jVar , iSide , iEl , N , nVar * 2 )] = vector [ VEB_2D_INDEX ( 1 , j , iVar , iSide , iEl , N , nVar )]; jVar += 1 ; scalar [ SCB_2D_INDEX ( j , jVar , iSide , iEl , N , nVar * 2 )] = vector [ VEB_2D_INDEX ( 2 , j , iVar , iSide , iEl , N , nVar )]; } extern \"C\" { void MapToScalarBoundary_MappedVector2D_gpu_wrapper ( real ** scalar , real ** vector , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( MapToScalarBoundary_MappedVector2D_gpu ), dim3 ( 4 , nVar , nEl ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 , * scalar , * vector , N , nVar ); } } __global__ void MapToTensor_MappedVector2D_gpu ( real * tensor , real * vector , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t jVar = 2 * ( iVar ); tensor [ TE_2D_INDEX ( 1 , 1 , i , j , iVar , iEl , N , nVar )] = vector [ VE_2D_INDEX ( 1 , i , j , jVar , iEl , N , nVar * 2 )]; tensor [ TE_2D_INDEX ( 1 , 2 , i , j , iVar , iEl , N , nVar )] = vector [ VE_2D_INDEX ( 2 , i , j , jVar , iEl , N , nVar * 2 )]; jVar += 1 ; tensor [ TE_2D_INDEX ( 2 , 1 , i , j , iVar , iEl , N , nVar )] = vector [ VE_2D_INDEX ( 1 , i , j , jVar , iEl , N , nVar * 2 )]; tensor [ TE_2D_INDEX ( 2 , 2 , i , j , iVar , iEl , N , nVar )] = vector [ VE_2D_INDEX ( 2 , i , j , jVar , iEl , N , nVar * 2 )]; } extern \"C\" { void MapToTensor_MappedVector2D_gpu_wrapper ( real ** tensor , real ** vector , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( MapToTensor_MappedVector2D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * tensor , * vector , N , nVar ); } } __global__ void MapToTensorBoundary_MappedVector2D_gpu ( real * tensor , real * vector , int N , int nVar ){ size_t iSide = hipBlockIdx_x + 1 ; size_t iVar = hipBlockIdx_y ; size_t iEl = hipBlockIdx_z ; size_t j = hipThreadIdx_x ; size_t jVar = 2 * ( iVar ); tensor [ TEB_2D_INDEX ( 1 , 1 , j , iVar , iSide , iEl , N , nVar )] = vector [ VEB_2D_INDEX ( 1 , j , jVar , iSide , iEl , N , nVar * 2 )]; tensor [ TEB_2D_INDEX ( 1 , 2 , j , iVar , iSide , iEl , N , nVar )] = vector [ VEB_2D_INDEX ( 2 , j , jVar , iSide , iEl , N , nVar * 2 )]; jVar += 1 ; tensor [ TEB_2D_INDEX ( 2 , 1 , j , iVar , iSide , iEl , N , nVar )] = vector [ VEB_2D_INDEX ( 1 , j , jVar , iSide , iEl , N , nVar * 2 )]; tensor [ TEB_2D_INDEX ( 2 , 2 , j , iVar , iSide , iEl , N , nVar )] = vector [ VEB_2D_INDEX ( 2 , j , jVar , iSide , iEl , N , nVar * 2 )]; } extern \"C\" { void MapToTensorBoundary_MappedVector2D_gpu_wrapper ( real ** tensor , real ** vector , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( MapToTensorBoundary_MappedVector2D_gpu ), dim3 ( 4 , nVar , nEl ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 , * tensor , * vector , N , nVar ); } } __global__ void MapToScalar_MappedVector3D_gpu ( real * scalar , real * vector , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; size_t jVar = 3 * ( iVar ); scalar [ SC_3D_INDEX ( i , j , k , jVar , iEl , N , nVar * 3 )] = vector [ VE_3D_INDEX ( 1 , i , j , k , iVar , iEl , N , nVar )]; jVar += 1 ; scalar [ SC_3D_INDEX ( i , j , k , jVar , iEl , N , nVar * 3 )] = vector [ VE_3D_INDEX ( 2 , i , j , k , iVar , iEl , N , nVar )]; jVar += 1 ; scalar [ SC_3D_INDEX ( i , j , k , jVar , iEl , N , nVar * 3 )] = vector [ VE_3D_INDEX ( 3 , i , j , k , iVar , iEl , N , nVar )]; } extern \"C\" { void MapToScalar_MappedVector3D_gpu_wrapper ( real ** scalar , real ** vector , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( MapToScalar_MappedVector3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * scalar , * vector , N , nVar ); } } __global__ void MapToScalarBoundary_MappedVector3D_gpu ( real * scalar , real * vector , int N , int nVar ){ size_t iSide = hipBlockIdx_x + 1 ; size_t iEl = hipBlockIdx_y ; size_t j = hipThreadIdx_x ; size_t k = hipThreadIdx_y ; size_t iVar = hipThreadIdx_z ; size_t jVar = 3 * ( iVar ); scalar [ SCB_3D_INDEX ( j , k , jVar , iSide , iEl , N , nVar * 3 )] = vector [ VEB_3D_INDEX ( 1 , j , k , iVar , iSide , iEl , N , nVar )]; jVar += 1 ; scalar [ SCB_3D_INDEX ( j , k , jVar , iSide , iEl , N , nVar * 3 )] = vector [ VEB_3D_INDEX ( 2 , j , k , iVar , iSide , iEl , N , nVar )]; jVar += 1 ; scalar [ SCB_3D_INDEX ( j , k , jVar , iSide , iEl , N , nVar * 3 )] = vector [ VEB_3D_INDEX ( 3 , j , k , iVar , iSide , iEl , N , nVar )]; } extern \"C\" { void MapToScalarBoundary_MappedVector3D_gpu_wrapper ( real ** scalar , real ** vector , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( MapToScalarBoundary_MappedVector3D_gpu ), dim3 ( 6 , nEl , 1 ), dim3 ( N + 1 , N + 1 , nVar ), 0 , 0 , * scalar , * vector , N , nVar ); } } __global__ void MapToTensor_MappedVector3D_gpu ( real * tensor , real * vector , int N , int nVar ){ size_t iVar = hipBlockIdx_x ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; size_t jVar = 3 * ( iVar ); tensor [ TE_3D_INDEX ( 1 , 1 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 1 , i , j , k , jVar , iEl , N , nVar * 3 )]; tensor [ TE_3D_INDEX ( 1 , 2 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 2 , i , j , k , jVar , iEl , N , nVar * 3 )]; tensor [ TE_3D_INDEX ( 1 , 3 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 3 , i , j , k , jVar , iEl , N , nVar * 3 )]; jVar += 1 ; tensor [ TE_3D_INDEX ( 2 , 1 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 1 , i , j , k , jVar , iEl , N , nVar * 3 )]; tensor [ TE_3D_INDEX ( 2 , 2 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 2 , i , j , k , jVar , iEl , N , nVar * 3 )]; tensor [ TE_3D_INDEX ( 2 , 3 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 3 , i , j , k , jVar , iEl , N , nVar * 3 )]; jVar += 1 ; tensor [ TE_3D_INDEX ( 3 , 1 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 1 , i , j , k , jVar , iEl , N , nVar * 3 )]; tensor [ TE_3D_INDEX ( 3 , 2 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 2 , i , j , k , jVar , iEl , N , nVar * 3 )]; tensor [ TE_3D_INDEX ( 3 , 3 , i , j , k , iVar , iEl , N , nVar )] = vector [ VE_3D_INDEX ( 3 , i , j , k , jVar , iEl , N , nVar * 3 )]; } extern \"C\" { void MapToTensor_MappedVector3D_gpu_wrapper ( real ** tensor , real ** vector , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( MapToTensor_MappedVector3D_gpu ), dim3 ( nVar , nEl , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * tensor , * vector , N , nVar ); } } __global__ void MapToTensorBoundary_MappedVector3D_gpu ( real * tensor , real * vector , int N , int nVar ){ size_t iSide = hipBlockIdx_x + 1 ; size_t iEl = hipBlockIdx_y ; size_t j = hipThreadIdx_x ; size_t k = hipThreadIdx_x ; size_t iVar = hipThreadIdx_z ; size_t jVar = 3 * ( iVar ); tensor [ TEB_3D_INDEX ( 1 , 1 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 1 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; tensor [ TEB_3D_INDEX ( 1 , 2 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 2 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; tensor [ TEB_3D_INDEX ( 1 , 3 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 3 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; jVar += 1 ; tensor [ TEB_3D_INDEX ( 2 , 1 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 1 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; tensor [ TEB_3D_INDEX ( 2 , 2 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 2 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; tensor [ TEB_3D_INDEX ( 2 , 3 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 3 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; jVar += 1 ; tensor [ TEB_3D_INDEX ( 3 , 1 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 1 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; tensor [ TEB_3D_INDEX ( 3 , 2 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 2 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; tensor [ TEB_3D_INDEX ( 3 , 3 , j , k , iVar , iSide , iEl , N , nVar )] = vector [ VEB_3D_INDEX ( 3 , j , k , jVar , iSide , iEl , N , nVar * 3 )]; } extern \"C\" { void MapToTensorBoundary_MappedVector3D_gpu_wrapper ( real ** tensor , real ** vector , int N , int nVar , int nEl ) { hipLaunchKernelGGL (( MapToTensorBoundary_MappedVector3D_gpu ), dim3 ( 6 , nEl , 1 ), dim3 ( N + 1 , N + 1 , nVar ), 0 , 0 , * tensor , * vector , N , nVar ); } }","tags":"","loc":"sourcefile/self_mappeddata.cpp.html"},{"title":"SELF_Geometry.cpp – SELF","text":"Contents Source Code SELF_Geometry.cpp Source Code #include <hip/hip_runtime.h> #include <math.h> #include \"SELF_HIP_Macros.h\" /* // Template __global__ void Template_{1D|2D|3D}_gpu( , int N, int nVar){ size_t iVar = hipBlockIdx_x; size_t iEl = hipBlockIdx_y; size_t i = hipThreadIdx_x; size_t j = hipThreadIdx_y; size_t k = hipThreadIdx_z; // How to access scalars f[SC_1D_INDEX(i,iVar,iEl,N,nVar)]; f[SC_2D_INDEX(i,j,iVar,iEl,N,nVar)]; f[SC_3D_INDEX(i,j,k,iVar,iEl,N,nVar)]; // How to access vectors (2d) f[VE_2D_INDEX(1,i,j,iVar,iEl,N,nVar)]; f[VE_2D_INDEX(2,i,j,iVar,iEl,N,nVar)]; // How to access vectors (3d) f[VE_3D_INDEX(1,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(2,i,j,k,iVar,iEl,N,nVar)]; f[VE_3D_INDEX(3,i,j,k,iVar,iEl,N,nVar)]; // How to access tensors (2d) f[TE_2D_INDEX(1,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,1,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(1,2,i,j,iVar,iEl,N,nVar)]; f[TE_2D_INDEX(2,2,i,j,iVar,iEl,N,nVar)]; // How to access tensors (3d) f[TE_3D_INDEX(1,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,1,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,2,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(1,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(2,3,i,j,k,iVar,iEl,N,nVar)]; f[TE_3D_INDEX(3,3,i,j,k,iVar,iEl,N,nVar)]; } extern \"C\" { void Template_{1D|2D|3D}_gpu_wrapper(int N, int nVar) { hipLaunchKernelGGL((Template_{1D|2D|3D}_gpu), dim3(nVar,nEl,1), dim3(N+1,N+1,N+1), 0, 0,  N, M, nVar); } } */ /* __global__ void CalculateContravariantBasis_SEMQuad_gpu(real *scalar, real *dxds, int N, int nVar){ size_t iVar = hipBlockIdx_x; size_t iEl = hipBlockIdx_y; size_t i = hipThreadIdx_x; size_t j = hipThreadIdx_y; scalar[SC_1D_INDEX(i,iVar,iEl,N,nVar)] = scalar[SC_1D_INDEX(i,iVar,iEl,N,nVar)]/ dxds[SC_1D_INDEX(i,0,iEl,N,1)]; } extern \"C\" { void CalculateContravariantBasis_SEMQuad_gpu_wrapper(int N, int nVar) { hipLaunchKernelGGL((CalculateContravariantBasis_SEMQuad_gpu), dim3(nVar,nEl,1), dim3(N+1,N+1,1), 0, 0,  N); } } */ __global__ void CalculateContravariantBasis_SEMQuad_gpu ( real * dxds , real * dsdx , int N ){ size_t iEl = hipBlockIdx_x ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; // Ja1 dsdx [ TE_2D_INDEX ( 1 , 1 , i , j , 0 , iEl , N , 1 )] = dxds [ TE_2D_INDEX ( 2 , 2 , i , j , 0 , iEl , N , 1 )]; dsdx [ TE_2D_INDEX ( 2 , 1 , i , j , 0 , iEl , N , 1 )] = - dxds [ TE_2D_INDEX ( 1 , 2 , i , j , 0 , iEl , N , 1 )]; // Ja2 dsdx [ TE_2D_INDEX ( 1 , 2 , i , j , 0 , iEl , N , 1 )] = - dxds [ TE_2D_INDEX ( 2 , 1 , i , j , 0 , iEl , N , 1 )]; dsdx [ TE_2D_INDEX ( 2 , 2 , i , j , 0 , iEl , N , 1 )] = dxds [ TE_2D_INDEX ( 1 , 1 , i , j , 0 , iEl , N , 1 )]; } extern \"C\" { void CalculateContravariantBasis_SEMQuad_gpu_wrapper ( real ** dxds , real ** dsdx , int N , int nEl ) { hipLaunchKernelGGL (( CalculateContravariantBasis_SEMQuad_gpu ), dim3 ( nEl , 1 , 1 ), dim3 ( N + 1 , N + 1 ), 0 , 0 , * dxds , * dsdx , N ); } } __global__ void AdjustBoundaryContravariantBasis_SEMQuad_gpu ( real * dsdx , real * J , int N ){ size_t iSide = hipBlockIdx_x + 1 ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; real fac = fabs ( J [ SCB_2D_INDEX ( i , iSide , 0 , iEl , N , 1 )]) / J [ SCB_2D_INDEX ( i , iSide , 0 , iEl , N , 1 )]; if ( iSide == 4 || iSide == 1 ){ fac = - fac ; } for ( int row = 1 ; row <= 2 ; row ++ ){ for ( int col = 1 ; col <= 2 ; col ++ ){ dsdx [ TEB_2D_INDEX ( row , col , i , 0 , iSide , iEl , N , 1 )] = fac * dsdx [ TEB_2D_INDEX ( row , col , i , 0 , iSide , iEl , N , 1 )]; } } } extern \"C\" { void AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper ( real ** dsdx , real ** J , int N , int nEl ) { hipLaunchKernelGGL (( AdjustBoundaryContravariantBasis_SEMQuad_gpu ), dim3 ( 4 , nEl , 1 ), dim3 ( N + 1 , 1 , 1 ), 0 , 0 , * dsdx , * J , N ); } } __global__ void CalculateContravariantBasis_SEMHex_gpu ( real * dxds , real * dsdx , int N ){ size_t iEl = hipBlockIdx_x ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; size_t k = hipThreadIdx_z ; // Ja1 dsdx [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )]; dsdx [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )]; dsdx [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )]; // Ja2 dsdx [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )]; dsdx [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )]; dsdx [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )]; // Ja3 dsdx [ TE_3D_INDEX ( 1 , 3 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )]; dsdx [ TE_3D_INDEX ( 2 , 3 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 3 , 1 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 3 , 2 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )]; dsdx [ TE_3D_INDEX ( 3 , 3 , i , j , k , 0 , iEl , N , 1 )] = dxds [ TE_3D_INDEX ( 1 , 1 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 2 , 2 , i , j , k , 0 , iEl , N , 1 )] - dxds [ TE_3D_INDEX ( 2 , 1 , i , j , k , 0 , iEl , N , 1 )] * dxds [ TE_3D_INDEX ( 1 , 2 , i , j , k , 0 , iEl , N , 1 )]; } extern \"C\" { void CalculateContravariantBasis_SEMHex_gpu_wrapper ( real ** dxds , real ** dsdx , int N , int nEl ) { hipLaunchKernelGGL (( CalculateContravariantBasis_SEMHex_gpu ), dim3 ( nEl , 1 , 1 ), dim3 ( N + 1 , N + 1 , N + 1 ), 0 , 0 , * dxds , * dsdx , N ); } } __global__ void AdjustBoundaryContravariantBasis_SEMHex_gpu ( real * dsdx , real * J , int N ){ size_t iSide = hipBlockIdx_x + 1 ; size_t iEl = hipBlockIdx_y ; size_t i = hipThreadIdx_x ; size_t j = hipThreadIdx_y ; real fac = fabs ( J [ SCB_3D_INDEX ( i , j , iSide , 0 , iEl , N , 1 )]) / J [ SCB_3D_INDEX ( i , j , iSide , 0 , iEl , N , 1 )]; if ( iSide == 5 || iSide == 1 || iSide == 2 ){ fac = - fac ; } for ( int row = 1 ; row <= 3 ; row ++ ){ for ( int col = 1 ; col <= 3 ; col ++ ){ dsdx [ TEB_3D_INDEX ( row , col , i , j , 0 , iSide , iEl , N , 1 )] = fac * dsdx [ TEB_3D_INDEX ( row , col , i , j , 0 , iSide , iEl , N , 1 )]; } } } extern \"C\" { void AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper ( real ** dsdx , real ** J , int N , int nEl ) { hipLaunchKernelGGL (( AdjustBoundaryContravariantBasis_SEMHex_gpu ), dim3 ( 6 , nEl , 1 ), dim3 ( N + 1 , N + 1 , 1 ), 0 , 0 , * dsdx , * J , N ); } }","tags":"","loc":"sourcefile/self_geometry.cpp.html"},{"title":"Scalar1D – SELF ","text":"type, public :: Scalar1D Inherits type~~scalar1d~~InheritsGraph type~scalar1d Scalar1D Lagrange Lagrange type~scalar1d->Lagrange interp hfReal_r3 hfReal_r3 type~scalar1d->hfReal_r3 interior, boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N boundary controlType interior interp nElem nVar targetType Type-Bound Procedures ASSIGNMENT(=) AbsMaxBoundary AbsMaxInterior Add_Scalar1D BoundaryInterp Derivative Derivative_Scalar1D Equals_Scalar1D Free GridInterp Init OPERATOR(+) OPERATOR(-) Subtract_Scalar1D UpdateDevice UpdateHost Source Code Scalar1D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r3), public :: boundary integer, public :: controlType type(hfReal_r3), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Scalar1D public subroutine Equals_Scalar1D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFOut type( Scalar1D ), intent(in) :: SELFin procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Scalar1D public function AbsMaxBoundary_Scalar1D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar1D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:2) procedure, public :: AbsMaxInterior => AbsMaxInterior_Scalar1D public function AbsMaxInterior_Scalar1D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar1D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) procedure, private, PASS(SELFa) :: Add_Scalar1D public function Add_Scalar1D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D public subroutine BoundaryInterp_Scalar1D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel generic, public :: Derivative => Derivative_Scalar1D public subroutine Derivative_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Derivative_Scalar1D public subroutine Derivative_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private, PASS(SELFOut) :: Equals_Scalar1D public subroutine Equals_Scalar1D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFOut type( Scalar1D ), intent(in) :: SELFin procedure, public :: Free => Free_Scalar1D public subroutine Free_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage procedure, public :: GridInterp => GridInterp_Scalar1D public subroutine GridInterp_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Scalar1D public subroutine Init_Scalar1D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: OPERATOR(+) => Add_Scalar1D public function Add_Scalar1D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) generic, public :: OPERATOR(-) => Subtract_Scalar1D public function Subtract_Scalar1D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) procedure, private, PASS(SELFa) :: Subtract_Scalar1D public function Subtract_Scalar1D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) procedure, public :: UpdateDevice => UpdateDevice_Scalar1D public subroutine UpdateDevice_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Scalar1D public subroutine UpdateHost_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage Source Code TYPE , PUBLIC :: Scalar1D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r3 ) :: interior TYPE ( hfReal_r3 ) :: boundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar1D PROCEDURE , PUBLIC :: Free => Free_Scalar1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar1D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar1D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar1D GENERIC , PUBLIC :: Derivative => Derivative_Scalar1D PROCEDURE , PRIVATE :: Derivative_Scalar1D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar1D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar1D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Scalar1D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Scalar1D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Scalar1D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Scalar1D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Scalar1D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Scalar1D END TYPE Scalar1D","tags":"","loc":"type/scalar1d.html"},{"title":"Scalar2D – SELF ","text":"type, public :: Scalar2D Inherits type~~scalar2d~~InheritsGraph type~scalar2d Scalar2D Lagrange Lagrange type~scalar2d->Lagrange interp hfReal_r4 hfReal_r4 type~scalar2d->hfReal_r4 interior, boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N boundary controlType interior interp nElem nVar targetType Type-Bound Procedures ASSIGNMENT(=) AbsMaxBoundary AbsMaxInterior Add_Scalar2D BoundaryInterp Equals_Scalar2D Free Gradient Gradient_Scalar2D GridInterp Init OPERATOR(+) OPERATOR(-) Subtract_Scalar2D UpdateDevice UpdateHost Source Code Scalar2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r4), public :: boundary integer, public :: controlType type(hfReal_r4), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Scalar2D public subroutine Equals_Scalar2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFOut type( Scalar2D ), intent(in) :: SELFin procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Scalar2D public function AbsMaxBoundary_Scalar2D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar2D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:4) procedure, public :: AbsMaxInterior => AbsMaxInterior_Scalar2D public function AbsMaxInterior_Scalar2D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar2D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) procedure, private, PASS(SELFa) :: Add_Scalar2D public function Add_Scalar2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D public subroutine BoundaryInterp_Scalar2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, private, PASS(SELFOut) :: Equals_Scalar2D public subroutine Equals_Scalar2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFOut type( Scalar2D ), intent(in) :: SELFin procedure, public :: Free => Free_Scalar2D public subroutine Free_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Scalar2D public subroutine Gradient_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Gradient_Scalar2D public subroutine Gradient_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Scalar2D public subroutine GridInterp_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Scalar2D public subroutine Init_Scalar2D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: OPERATOR(+) => Add_Scalar2D public function Add_Scalar2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) generic, public :: OPERATOR(-) => Subtract_Scalar2D public function Subtract_Scalar2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) procedure, private, PASS(SELFa) :: Subtract_Scalar2D public function Subtract_Scalar2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) procedure, public :: UpdateDevice => UpdateDevice_Scalar2D public subroutine UpdateDevice_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Scalar2D public subroutine UpdateHost_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage Source Code TYPE , PUBLIC :: Scalar2D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r4 ) :: interior TYPE ( hfReal_r4 ) :: boundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar2D PROCEDURE , PUBLIC :: Free => Free_Scalar2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar2D GENERIC , PUBLIC :: Gradient => Gradient_Scalar2D PROCEDURE , PRIVATE :: Gradient_Scalar2D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar2D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar2D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Scalar2D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Scalar2D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Scalar2D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Scalar2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Scalar2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Scalar2D END TYPE Scalar2D","tags":"","loc":"type/scalar2d.html"},{"title":"Scalar3D – SELF ","text":"type, public :: Scalar3D Inherits type~~scalar3d~~InheritsGraph type~scalar3d Scalar3D Lagrange Lagrange type~scalar3d->Lagrange interp hfReal_r5 hfReal_r5 type~scalar3d->hfReal_r5 interior, boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N boundary controlType interior interp nElem nVar targetType Type-Bound Procedures ASSIGNMENT(=) AbsMaxBoundary AbsMaxInterior Add_Scalar3D BoundaryInterp Equals_Scalar3D Free Gradient Gradient_Scalar3D GridInterp Init OPERATOR(+) OPERATOR(-) Subtract_Scalar3D UpdateDevice UpdateHost Source Code Scalar3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r5), public :: boundary integer, public :: controlType type(hfReal_r5), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Scalar3D public subroutine Equals_Scalar3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFOut type( Scalar3D ), intent(in) :: SELFin procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Scalar3D public function AbsMaxBoundary_Scalar3D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar3D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:6) procedure, public :: AbsMaxInterior => AbsMaxInterior_Scalar3D public function AbsMaxInterior_Scalar3D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar3D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) procedure, private, PASS(SELFa) :: Add_Scalar3D public function Add_Scalar3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D public subroutine BoundaryInterp_Scalar3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, private, PASS(SELFOut) :: Equals_Scalar3D public subroutine Equals_Scalar3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFOut type( Scalar3D ), intent(in) :: SELFin procedure, public :: Free => Free_Scalar3D public subroutine Free_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Scalar3D public subroutine Gradient_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Gradient_Scalar3D public subroutine Gradient_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Scalar3D public subroutine GridInterp_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Scalar3D public subroutine Init_Scalar3D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: OPERATOR(+) => Add_Scalar3D public function Add_Scalar3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) generic, public :: OPERATOR(-) => Subtract_Scalar3D public function Subtract_Scalar3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) procedure, private, PASS(SELFa) :: Subtract_Scalar3D public function Subtract_Scalar3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) procedure, public :: UpdateDevice => UpdateDevice_Scalar3D public subroutine UpdateDevice_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Scalar3D public subroutine UpdateHost_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage Source Code TYPE , PUBLIC :: Scalar3D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r5 ) :: interior TYPE ( hfReal_r5 ) :: boundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Scalar3D PROCEDURE , PUBLIC :: Free => Free_Scalar3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Scalar3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Scalar3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Scalar3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Scalar3D GENERIC , PUBLIC :: Gradient => Gradient_Scalar3D PROCEDURE , PRIVATE :: Gradient_Scalar3D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Scalar3D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Scalar3D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Scalar3D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Scalar3D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Scalar3D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Scalar3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Scalar3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Scalar3D END TYPE Scalar3D","tags":"","loc":"type/scalar3d.html"},{"title":"Tensor2D – SELF ","text":"type, public :: Tensor2D Inherits type~~tensor2d~~InheritsGraph type~tensor2d Tensor2D Lagrange Lagrange type~tensor2d->Lagrange interp hfReal_r6 hfReal_r6 type~tensor2d->hfReal_r6 interior, boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N boundary controlType interior interp nElem nVar targetType Type-Bound Procedures ASSIGNMENT(=) AbsMaxBoundary AbsMaxInterior Add_Tensor2D BoundaryInterp Determinant Divergence Divergence_Tensor2D Equals_Tensor2D Free GridInterp Init OPERATOR(+) OPERATOR(-) Subtract_Tensor2D UpdateDevice UpdateHost Source Code Tensor2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r6), public :: boundary integer, public :: controlType type(hfReal_r6), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Tensor2D public subroutine Equals_Tensor2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFOut type( Tensor2D ), intent(in) :: SELFin procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Tensor2D public function AbsMaxBoundary_Tensor2D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor2D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar,1:4) procedure, public :: AbsMaxInterior => AbsMaxInterior_Tensor2D public function AbsMaxInterior_Tensor2D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor2D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar) procedure, private, PASS(SELFa) :: Add_Tensor2D public function Add_Tensor2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) procedure, public :: BoundaryInterp => BoundaryInterp_Tensor2D public subroutine BoundaryInterp_Tensor2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, public :: Determinant => Determinant_Tensor2D public subroutine Determinant_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_Tensor2D public subroutine Divergence_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Divergence_Tensor2D public subroutine Divergence_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private, PASS(SELFOut) :: Equals_Tensor2D public subroutine Equals_Tensor2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFOut type( Tensor2D ), intent(in) :: SELFin procedure, public :: Free => Free_Tensor2D public subroutine Free_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage procedure, public :: GridInterp => GridInterp_Tensor2D public subroutine GridInterp_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Tensor2D public subroutine Init_Tensor2D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: OPERATOR(+) => Add_Tensor2D public function Add_Tensor2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) generic, public :: OPERATOR(-) => Subtract_Tensor2D public function Subtract_Tensor2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) procedure, private, PASS(SELFa) :: Subtract_Tensor2D public function Subtract_Tensor2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) procedure, public :: UpdateDevice => UpdateDevice_Tensor2D public subroutine UpdateDevice_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Tensor2D public subroutine UpdateHost_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage Source Code TYPE , PUBLIC :: Tensor2D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r6 ) :: interior TYPE ( hfReal_r6 ) :: boundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Tensor2D PROCEDURE , PUBLIC :: Free => Free_Tensor2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Tensor2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Tensor2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Tensor2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Tensor2D PROCEDURE , PUBLIC :: Determinant => Determinant_Tensor2D GENERIC , PUBLIC :: Divergence => Divergence_Tensor2D PROCEDURE , PRIVATE :: Divergence_Tensor2D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Tensor2D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Tensor2D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Tensor2D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Tensor2D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Tensor2D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Tensor2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Tensor2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Tensor2D END TYPE Tensor2D","tags":"","loc":"type/tensor2d.html"},{"title":"Tensor3D – SELF ","text":"type, public :: Tensor3D Inherits type~~tensor3d~~InheritsGraph type~tensor3d Tensor3D Lagrange Lagrange type~tensor3d->Lagrange interp hfReal_r7 hfReal_r7 type~tensor3d->hfReal_r7 interior, boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N boundary controlType interior interp nElem nVar targetType Type-Bound Procedures ASSIGNMENT(=) AbsMaxBoundary AbsMaxInterior Add_Tensor3D BoundaryInterp Determinant Divergence Divergence_Tensor3D Equals_Tensor3D Free GridInterp Init OPERATOR(+) OPERATOR(-) Subtract_Tensor3D UpdateDevice UpdateHost Source Code Tensor3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r7), public :: boundary integer, public :: controlType type(hfReal_r7), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Tensor3D public subroutine Equals_Tensor3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFOut type( Tensor3D ), intent(in) :: SELFin procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Tensor3D public function AbsMaxBoundary_Tensor3D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor3D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar,1:6) procedure, public :: AbsMaxInterior => AbsMaxInterior_Tensor3D public function AbsMaxInterior_Tensor3D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor3D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar) procedure, private, PASS(SELFa) :: Add_Tensor3D public function Add_Tensor3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) procedure, public :: BoundaryInterp => BoundaryInterp_Tensor3D public subroutine BoundaryInterp_Tensor3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel procedure, public :: Determinant => Determinant_Tensor3D public subroutine Determinant_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_Tensor3D public subroutine Divergence_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Divergence_Tensor3D public subroutine Divergence_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private, PASS(SELFOut) :: Equals_Tensor3D public subroutine Equals_Tensor3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFOut type( Tensor3D ), intent(in) :: SELFin procedure, public :: Free => Free_Tensor3D public subroutine Free_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage procedure, public :: GridInterp => GridInterp_Tensor3D public subroutine GridInterp_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Tensor3D public subroutine Init_Tensor3D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: OPERATOR(+) => Add_Tensor3D public function Add_Tensor3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) generic, public :: OPERATOR(-) => Subtract_Tensor3D public function Subtract_Tensor3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) procedure, private, PASS(SELFa) :: Subtract_Tensor3D public function Subtract_Tensor3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) procedure, public :: UpdateDevice => UpdateDevice_Tensor3D public subroutine UpdateDevice_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Tensor3D public subroutine UpdateHost_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage Source Code TYPE , PUBLIC :: Tensor3D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r7 ) :: interior TYPE ( hfReal_r7 ) :: boundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Tensor3D PROCEDURE , PUBLIC :: Free => Free_Tensor3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Tensor3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Tensor3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Tensor3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Tensor3D PROCEDURE , PUBLIC :: Determinant => Determinant_Tensor3D GENERIC , PUBLIC :: Divergence => Divergence_Tensor3D PROCEDURE , PRIVATE :: Divergence_Tensor3D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Tensor3D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Tensor3D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Tensor3D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Tensor3D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Tensor3D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Tensor3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Tensor3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Tensor3D END TYPE Tensor3D","tags":"","loc":"type/tensor3d.html"},{"title":"Vector2D – SELF ","text":"type, public :: Vector2D Inherits type~~vector2d~~InheritsGraph type~vector2d Vector2D Lagrange Lagrange type~vector2d->Lagrange interp hfReal_r5 hfReal_r5 type~vector2d->hfReal_r5 interior, boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N boundary controlType interior interp nElem nVar targetType Type-Bound Procedures ASSIGNMENT(=) AbsMaxBoundary AbsMaxInterior Add_Vector2D BoundaryInterp Curl Curl_Vector2D Divergence Divergence_Vector2D Equals_Vector2D Free Gradient Gradient_Vector2D GridInterp Init OPERATOR(+) OPERATOR(-) Subtract_Vector2D UpdateDevice UpdateHost Source Code Vector2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r5), public :: boundary integer, public :: controlType type(hfReal_r5), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Vector2D public subroutine Equals_Vector2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFOut type( Vector2D ), intent(in) :: SELFin procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Vector2D public function AbsMaxBoundary_Vector2D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector2D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar,1:4) procedure, public :: AbsMaxInterior => AbsMaxInterior_Vector2D public function AbsMaxInterior_Vector2D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector2D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar) procedure, private, PASS(SELFa) :: Add_Vector2D public function Add_Vector2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D public subroutine BoundaryInterp_Vector2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel generic, public :: Curl => Curl_Vector2D public subroutine Curl_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Curl_Vector2D public subroutine Curl_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_Vector2D public subroutine Divergence_Vector2D (SELFStorage, SELFOut, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Divergence_Vector2D public subroutine Divergence_Vector2D (SELFStorage, SELFOut, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private, PASS(SELFOut) :: Equals_Vector2D public subroutine Equals_Vector2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFOut type( Vector2D ), intent(in) :: SELFin procedure, public :: Free => Free_Vector2D public subroutine Free_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Vector2D public subroutine Gradient_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Gradient_Vector2D public subroutine Gradient_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Vector2D public subroutine GridInterp_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Vector2D public subroutine Init_Vector2D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: OPERATOR(+) => Add_Vector2D public function Add_Vector2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) generic, public :: OPERATOR(-) => Subtract_Vector2D public function Subtract_Vector2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) procedure, private, PASS(SELFa) :: Subtract_Vector2D public function Subtract_Vector2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) procedure, public :: UpdateDevice => UpdateDevice_Vector2D public subroutine UpdateDevice_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Vector2D public subroutine UpdateHost_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage Source Code TYPE , PUBLIC :: Vector2D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r5 ) :: interior TYPE ( hfReal_r5 ) :: boundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Vector2D PROCEDURE , PUBLIC :: Free => Free_Vector2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Vector2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Vector2D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Vector2D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Vector2D GENERIC , PUBLIC :: Gradient => Gradient_Vector2D PROCEDURE , PRIVATE :: Gradient_Vector2D GENERIC , PUBLIC :: Divergence => Divergence_Vector2D PROCEDURE , PRIVATE :: Divergence_Vector2D GENERIC , PUBLIC :: Curl => Curl_Vector2D PROCEDURE , PRIVATE :: Curl_Vector2D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Vector2D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Vector2D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Vector2D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Vector2D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Vector2D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Vector2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Vector2D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Vector2D END TYPE Vector2D","tags":"","loc":"type/vector2d.html"},{"title":"Vector3D – SELF ","text":"type, public :: Vector3D Inherits type~~vector3d~~InheritsGraph type~vector3d Vector3D Lagrange Lagrange type~vector3d->Lagrange interp hfReal_r6 hfReal_r6 type~vector3d->hfReal_r6 interior, boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N boundary controlType interior interp nElem nVar targetType Type-Bound Procedures ASSIGNMENT(=) AbsMaxBoundary AbsMaxInterior Add_Vector3D BoundaryInterp Curl Curl_Vector3D Divergence Divergence_Vector3D Equals_Vector3D Free Gradient Gradient_Vector3D GridInterp Init OPERATOR(+) OPERATOR(-) Subtract_Vector3D UpdateDevice UpdateHost Source Code Vector3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r6), public :: boundary integer, public :: controlType type(hfReal_r6), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Vector3D public subroutine Equals_Vector3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFOut type( Vector3D ), intent(in) :: SELFin procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Vector3D public function AbsMaxBoundary_Vector3D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector3D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar,1:6) procedure, public :: AbsMaxInterior => AbsMaxInterior_Vector3D public function AbsMaxInterior_Vector3D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector3D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar) procedure, private, PASS(SELFa) :: Add_Vector3D public function Add_Vector3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D public subroutine BoundaryInterp_Vector3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel generic, public :: Curl => Curl_Vector3D public subroutine Curl_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Curl_Vector3D public subroutine Curl_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_Vector3D public subroutine Divergence_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Divergence_Vector3D public subroutine Divergence_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private, PASS(SELFOut) :: Equals_Vector3D public subroutine Equals_Vector3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFOut type( Vector3D ), intent(in) :: SELFin procedure, public :: Free => Free_Vector3D public subroutine Free_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage generic, public :: Gradient => Gradient_Vector3D public subroutine Gradient_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, private :: Gradient_Vector3D public subroutine Gradient_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: GridInterp => GridInterp_Vector3D public subroutine GridInterp_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel procedure, public :: Init => Init_Vector3D public subroutine Init_Vector3D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem generic, public :: OPERATOR(+) => Add_Vector3D public function Add_Vector3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) generic, public :: OPERATOR(-) => Subtract_Vector3D public function Subtract_Vector3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) procedure, private, PASS(SELFa) :: Subtract_Vector3D public function Subtract_Vector3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) procedure, public :: UpdateDevice => UpdateDevice_Vector3D public subroutine UpdateDevice_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage procedure, public :: UpdateHost => UpdateHost_Vector3D public subroutine UpdateHost_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage Source Code TYPE , PUBLIC :: Vector3D INTEGER :: N INTEGER :: M INTEGER :: nVar INTEGER :: nElem INTEGER :: controlType INTEGER :: targetType TYPE ( Lagrange ) :: interp TYPE ( hfReal_r6 ) :: interior TYPE ( hfReal_r6 ) :: boundary CONTAINS PROCEDURE , PUBLIC :: Init => Init_Vector3D PROCEDURE , PUBLIC :: Free => Free_Vector3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Vector3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Vector3D PROCEDURE , PUBLIC :: BoundaryInterp => BoundaryInterp_Vector3D PROCEDURE , PUBLIC :: GridInterp => GridInterp_Vector3D GENERIC , PUBLIC :: Gradient => Gradient_Vector3D PROCEDURE , PRIVATE :: Gradient_Vector3D GENERIC , PUBLIC :: Divergence => Divergence_Vector3D PROCEDURE , PRIVATE :: Divergence_Vector3D GENERIC , PUBLIC :: Curl => Curl_Vector3D PROCEDURE , PRIVATE :: Curl_Vector3D PROCEDURE , PUBLIC :: AbsMaxInterior => AbsMaxInterior_Vector3D PROCEDURE , PUBLIC :: AbsMaxBoundary => AbsMaxBoundary_Vector3D GENERIC , PUBLIC :: ASSIGNMENT ( = ) => Equals_Vector3D GENERIC , PUBLIC :: OPERATOR ( + ) => Add_Vector3D GENERIC , PUBLIC :: OPERATOR ( - ) => Subtract_Vector3D PROCEDURE , PRIVATE , PASS ( SELFOut ) :: Equals_Vector3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Add_Vector3D PROCEDURE , PRIVATE , PASS ( SELFa ) :: Subtract_Vector3D END TYPE Vector3D","tags":"","loc":"type/vector3d.html"},{"title":"Geometry1D – SELF ","text":"type, public :: Geometry1D Inherits type~~geometry1d~~InheritsGraph type~geometry1d Geometry1D Scalar1D Scalar1D type~geometry1d->Scalar1D x, dxds Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cqType dxds nElem tqType x Type-Bound Procedures CalculateMetricTerms Free GenerateFromMesh Init UpdateDevice UpdateHost Source Code Geometry1D Components Type Visibility Attributes Name Initial integer, public :: cqType type(Scalar1D), public :: dxds integer, public :: nElem integer, public :: tqType type(Scalar1D), public :: x Type-Bound Procedures procedure, public :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D public subroutine CalculateMetricTerms_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom procedure, public :: Free => Free_Geometry1D public subroutine Free_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom procedure, public :: GenerateFromMesh => GenerateFromMesh_Geometry1D public subroutine GenerateFromMesh_Geometry1D (myGeom, mesh, cqType, tqType, cqDegree, tqDegree) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom type(Mesh1D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree procedure, public :: Init => Init_Geometry1D public subroutine Init_Geometry1D (myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem procedure, public :: UpdateDevice => UpdateDevice_Geometry1D public subroutine UpdateDevice_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom procedure, public :: UpdateHost => UpdateHost_Geometry1D public subroutine UpdateHost_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Source Code TYPE , PUBLIC :: Geometry1D INTEGER :: cqType ! Control Quadrature Type INTEGER :: tqType ! Target Quadrature Type INTEGER :: nElem TYPE ( Scalar1D ) :: x ! Physical Positions TYPE ( Scalar1D ) :: dxds ! Conversion from computational to physical space CONTAINS PROCEDURE , PUBLIC :: Init => Init_Geometry1D PROCEDURE , PUBLIC :: Free => Free_Geometry1D PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_Geometry1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Geometry1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Geometry1D PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D END TYPE Geometry1D","tags":"","loc":"type/geometry1d.html"},{"title":"SEMHex – SELF ","text":"type, public :: SEMHex Inherits type~~semhex~~InheritsGraph type~semhex SEMHex Vector3D Vector3D type~semhex->Vector3D x Tensor3D Tensor3D type~semhex->Tensor3D dxds, dsdx Scalar3D Scalar3D type~semhex->Scalar3D J Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables J cqType dsdx dxds nElem tqType x Type-Bound Procedures CalculateContravariantBasis CalculateMetricTerms Free GenerateFromMesh Init UpdateDevice UpdateHost Source Code SEMHex Components Type Visibility Attributes Name Initial type(Scalar3D), public :: J integer, public :: cqType type(Tensor3D), public :: dsdx type(Tensor3D), public :: dxds integer, public :: nElem integer, public :: tqType type(Vector3D), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex public subroutine CalculateContravariantBasis_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMHex public subroutine CalculateMetricTerms_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom procedure, public :: Free => Free_SEMHex public subroutine Free_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMHex public subroutine GenerateFromMesh_SEMHex (myGeom, mesh, cqType, tqType, cqDegree, tqDegree) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom type(Mesh3D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree procedure, public :: Init => Init_SEMHex public subroutine Init_SEMHex (myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem procedure, public :: UpdateDevice => UpdateDevice_SEMHex public subroutine UpdateDevice_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom procedure, public :: UpdateHost => UpdateHost_SEMHex public subroutine UpdateHost_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Source Code TYPE , PUBLIC :: SEMHex INTEGER :: cqType ! Control Quadrature Type INTEGER :: tqType ! Target Quadrature Type INTEGER :: nElem TYPE ( Vector3D ) :: x ! Physical positions TYPE ( Tensor3D ) :: dxds ! Covariant basis vectors TYPE ( Tensor3D ) :: dsdx ! Contavariant basis vectors TYPE ( Scalar3D ) :: J ! Jacobian of the transformation CONTAINS PROCEDURE , PUBLIC :: Init => Init_SEMHex PROCEDURE , PUBLIC :: Free => Free_SEMHex PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_SEMHex PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_SEMHex PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_SEMHex PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_SEMHex PROCEDURE , PRIVATE :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex END TYPE SEMHex","tags":"","loc":"type/semhex.html"},{"title":"SEMQuad – SELF ","text":"type, public :: SEMQuad Inherits type~~semquad~~InheritsGraph type~semquad SEMQuad Vector2D Vector2D type~semquad->Vector2D x Tensor2D Tensor2D type~semquad->Tensor2D dxds, dsdx Scalar2D Scalar2D type~semquad->Scalar2D J Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables J cqType dsdx dxds nElem tqType x Type-Bound Procedures CalculateContravariantBasis CalculateMetricTerms Free GenerateFromMesh Init UpdateDevice UpdateHost Source Code SEMQuad Components Type Visibility Attributes Name Initial type(Scalar2D), public :: J integer, public :: cqType type(Tensor2D), public :: dsdx type(Tensor2D), public :: dxds integer, public :: nElem integer, public :: tqType type(Vector2D), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad public subroutine CalculateContravariantBasis_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad public subroutine CalculateMetricTerms_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom procedure, public :: Free => Free_SEMQuad public subroutine Free_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMQuad public subroutine GenerateFromMesh_SEMQuad (myGeom, mesh, cqType, tqType, cqDegree, tqDegree) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom type(Mesh2D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree procedure, public :: Init => Init_SEMQuad public subroutine Init_SEMQuad (myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem procedure, public :: UpdateDevice => UpdateDevice_SEMQuad public subroutine UpdateDevice_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom procedure, public :: UpdateHost => UpdateHost_SEMQuad public subroutine UpdateHost_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Source Code TYPE , PUBLIC :: SEMQuad INTEGER :: cqType ! Control Quadrature Type INTEGER :: tqType ! Target Quadrature Type INTEGER :: nElem TYPE ( Vector2D ) :: x ! Physical positions TYPE ( Tensor2D ) :: dxds ! Covariant basis vectors TYPE ( Tensor2D ) :: dsdx ! Contavariant basis vectors TYPE ( Scalar2D ) :: J ! Jacobian of the transformation CONTAINS PROCEDURE , PUBLIC :: Init => Init_SEMQuad PROCEDURE , PUBLIC :: Free => Free_SEMQuad PROCEDURE , PUBLIC :: GenerateFromMesh => GenerateFromMesh_SEMQuad PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_SEMQuad PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_SEMQuad PROCEDURE , PUBLIC :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad PROCEDURE , PRIVATE :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad END TYPE SEMQuad","tags":"","loc":"type/semquad.html"},{"title":"Lagrange – SELF ","text":"type, public :: Lagrange A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions.\n The Lagrange data-structure stores the information necessary to interpolate between two\n sets of grid-points and to estimate the derivative of data at native grid points. Routines for\n multidimensional interpolation are based on the tensor product of 1-D interpolants. It is\n assumed that the polynomial degree (and the interpolation nodes) are the same in each direction.\n This assumption permits the storage of only one array of interpolation nodes and barycentric\n weights and is what allows this data structure to be flexible. Inherits type~~lagrange~~InheritsGraph type~lagrange Lagrange hfReal_r1 hfReal_r1 type~lagrange->hfReal_r1 controlPoints, targetPoints, bWeights, qWeights hfReal_r2 hfReal_r2 type~lagrange->hfReal_r2 iMatrix, dMatrix, dgMatrix, bMatrix Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables M N bMatrix bWeights controlPoints dMatrix dgMatrix iMatrix qWeights targetPoints Type-Bound Procedures CalculateBarycentricWeights CalculateDerivativeMatrix CalculateInterpolationMatrix CalculateLagrangePolynomials DGDerivative_1D DGDerivative_1D_cpu DGDerivative_1D_gpu Derivative_1D Derivative_1D_cpu Derivative_1D_gpu Free Init ScalarBoundaryInterp_1D ScalarBoundaryInterp_1D_cpu ScalarBoundaryInterp_1D_gpu ScalarBoundaryInterp_2D ScalarBoundaryInterp_2D_cpu ScalarBoundaryInterp_2D_gpu ScalarBoundaryInterp_3D ScalarBoundaryInterp_3D_cpu ScalarBoundaryInterp_3D_gpu ScalarDGGradient_2D ScalarDGGradient_2D_cpu ScalarDGGradient_2D_gpu ScalarGradient_2D ScalarGradient_2D_cpu ScalarGradient_2D_gpu ScalarGradient_3D ScalarGradient_3D_cpu ScalarGradient_3D_gpu ScalarGridInterp_1D ScalarGridInterp_1D_cpu ScalarGridInterp_1D_gpu ScalarGridInterp_2D ScalarGridInterp_2D_cpu ScalarGridInterp_2D_gpu ScalarGridInterp_3D ScalarGridInterp_3D_cpu ScalarGridInterp_3D_gpu TensorBoundaryInterp_2D TensorBoundaryInterp_2D_cpu TensorBoundaryInterp_2D_gpu TensorBoundaryInterp_3D TensorBoundaryInterp_3D_cpu TensorBoundaryInterp_3D_gpu TensorDGDivergence_2D TensorDGDivergence_2D_cpu TensorDGDivergence_2D_gpu TensorDGDivergence_3D TensorDGDivergence_3D_cpu TensorDGDivergence_3D_gpu TensorDivergence_2D TensorDivergence_2D_cpu TensorDivergence_2D_gpu TensorDivergence_3D TensorDivergence_3D_cpu TensorDivergence_3D_gpu TensorGridInterp_2D TensorGridInterp_2D_cpu TensorGridInterp_2D_gpu TensorGridInterp_3D TensorGridInterp_3D_cpu TensorGridInterp_3D_gpu UpdateDevice UpdateHost VectorBoundaryInterp_2D VectorBoundaryInterp_2D_cpu VectorBoundaryInterp_2D_gpu VectorBoundaryInterp_3D VectorBoundaryInterp_3D_cpu VectorBoundaryInterp_3D_gpu VectorCurl_2D VectorCurl_2D_cpu VectorCurl_2D_gpu VectorCurl_3D VectorCurl_3D_cpu VectorCurl_3D_gpu VectorDGDivergence_2D VectorDGDivergence_2D_cpu VectorDGDivergence_2D_gpu VectorDGDivergence_3D VectorDGDivergence_3D_cpu VectorDGDivergence_3D_gpu VectorDGGradient_2D VectorDGGradient_2D_cpu VectorDGGradient_2D_gpu VectorDivergence_2D VectorDivergence_2D_cpu VectorDivergence_2D_gpu VectorDivergence_3D VectorDivergence_3D_cpu VectorDivergence_3D_gpu VectorGradient_2D VectorGradient_2D_cpu VectorGradient_2D_gpu VectorGradient_3D VectorGradient_3D_cpu VectorGradient_3D_gpu VectorGridInterp_2D VectorGridInterp_2D_cpu VectorGridInterp_2D_gpu VectorGridInterp_3D VectorGridInterp_3D_cpu VectorGridInterp_3D_gpu Source Code Lagrange Components Type Visibility Attributes Name Initial integer, public :: M The number of target points. integer, public :: N The number of control points. type(hfReal_r2), public :: bMatrix The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. type(hfReal_r1), public :: bWeights The barycentric weights that are calculated from the controlPoints and used for interpolation. type(hfReal_r1), public :: controlPoints The set of nodes in one dimension where data is known. \n To create higher dimension interpolation and differentiation operators, structured grids in two and three\n dimensions are created by tensor products of the controlPoints. This design decision implies that all \n spectral element methods supported by the Lagrange class have the same polynomial degree in each \n computational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto,\n Legendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over \n the domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of \n these quadrature types or uniform points on [-1,1]. type(hfReal_r2), public :: dMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The \n dMatrix is based on a strong form of the derivative. type(hfReal_r2), public :: dgMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based\n on a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. type(hfReal_r2), public :: iMatrix The interpolation matrix (transpose) for mapping data from the control grid to the target grid. type(hfReal_r1), public :: qWeights The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints \n provided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss, \n Chebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant . type(hfReal_r1), public :: targetPoints The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation \n and differentiation operators, structured grids in two and three dimensions are created by tensor products of \n the targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1]\n (computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. Type-Bound Procedures procedure, private :: CalculateBarycentricWeights public subroutine CalculateBarycentricWeights (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly procedure, private :: CalculateDerivativeMatrix public subroutine CalculateDerivativeMatrix (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly procedure, private :: CalculateInterpolationMatrix public subroutine CalculateInterpolationMatrix (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly procedure, private :: CalculateLagrangePolynomials public function CalculateLagrangePolynomials (myPoly, sE) result(lAtS) Arguments Type Intent Optional Attributes Name class( Lagrange ) :: myPoly real(kind=prec) :: sE Return Value real(kind=prec)\n  (0:myPoly%N) generic, public :: DGDerivative_1D => DGDerivative_1D_cpu , DGDerivative_1D_gpu public subroutine DGDerivative_1D_cpu (myPoly, f, bf, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:nVariables,1:2,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine DGDerivative_1D_gpu (myPoly, f_dev, bf_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: DGDerivative_1D_cpu public subroutine DGDerivative_1D_cpu (myPoly, f, bf, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:nVariables,1:2,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: DGDerivative_1D_gpu public subroutine DGDerivative_1D_gpu (myPoly, f_dev, bf_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: Derivative_1D => Derivative_1D_cpu , Derivative_1D_gpu public subroutine Derivative_1D_cpu (myPoly, f, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine Derivative_1D_gpu (myPoly, f_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: Derivative_1D_cpu public subroutine Derivative_1D_cpu (myPoly, f, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: Derivative_1D_gpu public subroutine Derivative_1D_gpu (myPoly, f_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, public :: Free => Free_Lagrange public subroutine Free_Lagrange (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly procedure, public :: Init => Init_Lagrange public subroutine Init_Lagrange (myPoly, N, controlNodeType, M, targetNodeType) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(out) :: myPoly integer, intent(in) :: N integer, intent(in) :: controlNodeType integer, intent(in) :: M integer, intent(in) :: targetNodeType generic, public :: ScalarBoundaryInterp_1D => ScalarBoundaryInterp_1D_cpu , ScalarBoundaryInterp_1D_gpu public subroutine ScalarBoundaryInterp_1D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:nVariables,1:2,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_1D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_1D_cpu public subroutine ScalarBoundaryInterp_1D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:nVariables,1:2,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_1D_gpu public subroutine ScalarBoundaryInterp_1D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarBoundaryInterp_2D => ScalarBoundaryInterp_2D_cpu , ScalarBoundaryInterp_2D_gpu public subroutine ScalarBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_2D_cpu public subroutine ScalarBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_2D_gpu public subroutine ScalarBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarBoundaryInterp_3D => ScalarBoundaryInterp_3D_cpu , ScalarBoundaryInterp_3D_gpu public subroutine ScalarBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_3D_cpu public subroutine ScalarBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarBoundaryInterp_3D_gpu public subroutine ScalarBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarDGGradient_2D => ScalarDGGradient_2D_cpu , ScalarDGGradient_2D_gpu public subroutine ScalarDGGradient_2D_cpu (myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarDGGradient_2D_gpu (myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarDGGradient_2D_cpu public subroutine ScalarDGGradient_2D_cpu (myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarDGGradient_2D_gpu public subroutine ScalarDGGradient_2D_gpu (myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarGradient_2D => ScalarGradient_2D_cpu , ScalarGradient_2D_gpu public subroutine ScalarGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGradient_2D_cpu public subroutine ScalarGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGradient_2D_gpu public subroutine ScalarGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarGradient_3D => ScalarGradient_3D_cpu , ScalarGradient_3D_gpu public subroutine ScalarGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGradient_3D_cpu public subroutine ScalarGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGradient_3D_gpu public subroutine ScalarGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarGridInterp_1D => ScalarGridInterp_1D_cpu , ScalarGridInterp_1D_gpu public subroutine ScalarGridInterp_1D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGridInterp_1D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGridInterp_1D_cpu public subroutine ScalarGridInterp_1D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGridInterp_1D_gpu public subroutine ScalarGridInterp_1D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarGridInterp_2D => ScalarGridInterp_2D_cpu , ScalarGridInterp_2D_gpu public subroutine ScalarGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fNew (0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGridInterp_2D_cpu public subroutine ScalarGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fNew (0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGridInterp_2D_gpu public subroutine ScalarGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: ScalarGridInterp_3D => ScalarGridInterp_3D_cpu , ScalarGridInterp_3D_gpu public subroutine ScalarGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGridInterp_3D_cpu public subroutine ScalarGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: ScalarGridInterp_3D_gpu public subroutine ScalarGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorBoundaryInterp_2D => TensorBoundaryInterp_2D_cpu , TensorBoundaryInterp_2D_gpu public subroutine TensorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorBoundaryInterp_2D_cpu public subroutine TensorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorBoundaryInterp_2D_gpu public subroutine TensorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorBoundaryInterp_3D => TensorBoundaryInterp_3D_cpu , TensorBoundaryInterp_3D_gpu public subroutine TensorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorBoundaryInterp_3D_cpu public subroutine TensorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorBoundaryInterp_3D_gpu public subroutine TensorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorDGDivergence_2D => TensorDGDivergence_2D_cpu , TensorDGDivergence_2D_gpu public subroutine TensorDGDivergence_2D_cpu (myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDGDivergence_2D_gpu (myPoly, f_dev, bf_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDGDivergence_2D_cpu public subroutine TensorDGDivergence_2D_cpu (myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDGDivergence_2D_gpu public subroutine TensorDGDivergence_2D_gpu (myPoly, f_dev, bf_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorDGDivergence_3D => TensorDGDivergence_3D_cpu , TensorDGDivergence_3D_gpu public subroutine TensorDGDivergence_3D_cpu (myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDGDivergence_3D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDGDivergence_3D_cpu public subroutine TensorDGDivergence_3D_cpu (myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDGDivergence_3D_gpu public subroutine TensorDGDivergence_3D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorDivergence_2D => TensorDivergence_2D_cpu , TensorDivergence_2D_gpu public subroutine TensorDivergence_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDivergence_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDivergence_2D_cpu public subroutine TensorDivergence_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDivergence_2D_gpu public subroutine TensorDivergence_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorDivergence_3D => TensorDivergence_3D_cpu , TensorDivergence_3D_gpu public subroutine TensorDivergence_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDivergence_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDivergence_3D_cpu public subroutine TensorDivergence_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorDivergence_3D_gpu public subroutine TensorDivergence_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorGridInterp_2D => TensorGridInterp_2D_cpu , TensorGridInterp_2D_gpu public subroutine TensorGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fNew (1:2,1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorGridInterp_2D_cpu public subroutine TensorGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fNew (1:2,1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorGridInterp_2D_gpu public subroutine TensorGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: TensorGridInterp_3D => TensorGridInterp_3D_cpu , TensorGridInterp_3D_gpu public subroutine TensorGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorGridInterp_3D_cpu public subroutine TensorGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: TensorGridInterp_3D_gpu public subroutine TensorGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, public :: UpdateDevice => UpdateDevice_Lagrange public subroutine UpdateDevice_Lagrange (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly procedure, public :: UpdateHost => UpdateHost_Lagrange public subroutine UpdateHost_Lagrange (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly generic, public :: VectorBoundaryInterp_2D => VectorBoundaryInterp_2D_cpu , VectorBoundaryInterp_2D_gpu public subroutine VectorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorBoundaryInterp_2D_cpu public subroutine VectorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorBoundaryInterp_2D_gpu public subroutine VectorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorBoundaryInterp_3D => VectorBoundaryInterp_3D_cpu , VectorBoundaryInterp_3D_gpu public subroutine VectorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorBoundaryInterp_3D_cpu public subroutine VectorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorBoundaryInterp_3D_gpu public subroutine VectorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorCurl_2D => VectorCurl_2D_cpu , VectorCurl_2D_gpu public subroutine VectorCurl_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorCurl_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorCurl_2D_cpu public subroutine VectorCurl_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorCurl_2D_gpu public subroutine VectorCurl_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorCurl_3D => VectorCurl_3D_cpu , VectorCurl_3D_gpu public subroutine VectorCurl_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorCurl_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorCurl_3D_cpu public subroutine VectorCurl_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorCurl_3D_gpu public subroutine VectorCurl_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorDGDivergence_2D => VectorDGDivergence_2D_cpu , VectorDGDivergence_2D_gpu public subroutine VectorDGDivergence_2D_cpu (myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_2D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGDivergence_2D_cpu public subroutine VectorDGDivergence_2D_cpu (myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGDivergence_2D_gpu public subroutine VectorDGDivergence_2D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorDGDivergence_3D => VectorDGDivergence_3D_cpu , VectorDGDivergence_3D_gpu public subroutine VectorDGDivergence_3D_cpu (myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_3D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGDivergence_3D_cpu public subroutine VectorDGDivergence_3D_cpu (myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGDivergence_3D_gpu public subroutine VectorDGDivergence_3D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorDGGradient_2D => VectorDGGradient_2D_cpu , VectorDGGradient_2D_gpu public subroutine VectorDGGradient_2D_cpu (myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGGradient_2D_gpu (myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGGradient_2D_cpu public subroutine VectorDGGradient_2D_cpu (myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDGGradient_2D_gpu public subroutine VectorDGGradient_2D_gpu (myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorDivergence_2D => VectorDivergence_2D_cpu , VectorDivergence_2D_gpu public subroutine VectorDivergence_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDivergence_2D_cpu public subroutine VectorDivergence_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDivergence_2D_gpu public subroutine VectorDivergence_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorDivergence_3D => VectorDivergence_3D_cpu , VectorDivergence_3D_gpu public subroutine VectorDivergence_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDivergence_3D_cpu public subroutine VectorDivergence_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorDivergence_3D_gpu public subroutine VectorDivergence_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorGradient_2D => VectorGradient_2D_cpu , VectorGradient_2D_gpu public subroutine VectorGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGradient_2D_cpu public subroutine VectorGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGradient_2D_gpu public subroutine VectorGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorGradient_3D => VectorGradient_3D_cpu , VectorGradient_3D_gpu public subroutine VectorGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGradient_3D_cpu public subroutine VectorGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGradient_3D_gpu public subroutine VectorGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorGridInterp_2D => VectorGridInterp_2D_cpu , VectorGridInterp_2D_gpu public subroutine VectorGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fNew (1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGridInterp_2D_cpu public subroutine VectorGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fNew (1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGridInterp_2D_gpu public subroutine VectorGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements generic, public :: VectorGridInterp_3D => VectorGridInterp_3D_cpu , VectorGridInterp_3D_gpu public subroutine VectorGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGridInterp_3D_cpu public subroutine VectorGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements procedure, private :: VectorGridInterp_3D_gpu public subroutine VectorGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Source Code TYPE , PUBLIC :: Lagrange !! A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions. !! The Lagrange data-structure stores the information necessary to interpolate between two !! sets of grid-points and to estimate the derivative of data at native grid points. Routines for !! multidimensional interpolation are based on the tensor product of 1-D interpolants. It is !! assumed that the polynomial degree (and the interpolation nodes) are the same in each direction. !! This assumption permits the storage of only one array of interpolation nodes and barycentric !! weights and is what allows this data structure to be flexible. INTEGER :: N !! The number of control points. INTEGER :: M !! The number of target points. TYPE ( hfReal_r1 ) :: controlPoints !! The set of nodes in one dimension where data is known. !! To create higher dimension interpolation and differentiation operators, structured grids in two and three !! dimensions are created by tensor products of the controlPoints. This design decision implies that all !! spectral element methods supported by the Lagrange class have the same polynomial degree in each !! computational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto, !! Legendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over !! the domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of !! these quadrature types or uniform points on [-1,1]. TYPE ( hfReal_r1 ) :: targetPoints !! The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation !! and differentiation operators, structured grids in two and three dimensions are created by tensor products of !! the targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1] !! (computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. TYPE ( hfReal_r1 ) :: bWeights !! The barycentric weights that are calculated from the controlPoints and used for interpolation. TYPE ( hfReal_r1 ) :: qWeights !! The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints !! provided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss, !! Chebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant !! dx = \\frac{2.0}{N+1}. TYPE ( hfReal_r2 ) :: iMatrix !! The interpolation matrix (transpose) for mapping data from the control grid to the target grid. TYPE ( hfReal_r2 ) :: dMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The !! dMatrix is based on a strong form of the derivative. TYPE ( hfReal_r2 ) :: dgMatrix !! The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based !! on a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. TYPE ( hfReal_r2 ) :: bMatrix !! The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. CONTAINS PROCEDURE , PUBLIC :: Init => Init_Lagrange PROCEDURE , PUBLIC :: Free => Free_Lagrange PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Lagrange PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Lagrange GENERIC , PUBLIC :: ScalarGridInterp_1D => ScalarGridInterp_1D_cpu , ScalarGridInterp_1D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_1D_cpu , ScalarGridInterp_1D_gpu GENERIC , PUBLIC :: ScalarGridInterp_2D => ScalarGridInterp_2D_cpu , ScalarGridInterp_2D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_2D_cpu , ScalarGridInterp_2D_gpu GENERIC , PUBLIC :: VectorGridInterp_2D => VectorGridInterp_2D_cpu , VectorGridInterp_2D_gpu PROCEDURE , PRIVATE :: VectorGridInterp_2D_cpu , VectorGridInterp_2D_gpu GENERIC , PUBLIC :: TensorGridInterp_2D => TensorGridInterp_2D_cpu , TensorGridInterp_2D_gpu PROCEDURE , PRIVATE :: TensorGridInterp_2D_cpu , TensorGridInterp_2D_gpu GENERIC , PUBLIC :: ScalarGridInterp_3D => ScalarGridInterp_3D_cpu , ScalarGridInterp_3D_gpu PROCEDURE , PRIVATE :: ScalarGridInterp_3D_cpu , ScalarGridInterp_3D_gpu GENERIC , PUBLIC :: VectorGridInterp_3D => VectorGridInterp_3D_cpu , VectorGridInterp_3D_gpu PROCEDURE , PRIVATE :: VectorGridInterp_3D_cpu , VectorGridInterp_3D_gpu GENERIC , PUBLIC :: TensorGridInterp_3D => TensorGridInterp_3D_cpu , TensorGridInterp_3D_gpu PROCEDURE , PRIVATE :: TensorGridInterp_3D_cpu , TensorGridInterp_3D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_1D => ScalarBoundaryInterp_1D_cpu , ScalarBoundaryInterp_1D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_1D_cpu , ScalarBoundaryInterp_1D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_2D => ScalarBoundaryInterp_2D_cpu , ScalarBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_2D_cpu , ScalarBoundaryInterp_2D_gpu GENERIC , PUBLIC :: VectorBoundaryInterp_2D => VectorBoundaryInterp_2D_cpu , VectorBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: VectorBoundaryInterp_2D_cpu , VectorBoundaryInterp_2D_gpu GENERIC , PUBLIC :: TensorBoundaryInterp_2D => TensorBoundaryInterp_2D_cpu , TensorBoundaryInterp_2D_gpu PROCEDURE , PRIVATE :: TensorBoundaryInterp_2D_cpu , TensorBoundaryInterp_2D_gpu GENERIC , PUBLIC :: ScalarBoundaryInterp_3D => ScalarBoundaryInterp_3D_cpu , ScalarBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: ScalarBoundaryInterp_3D_cpu , ScalarBoundaryInterp_3D_gpu GENERIC , PUBLIC :: VectorBoundaryInterp_3D => VectorBoundaryInterp_3D_cpu , VectorBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: VectorBoundaryInterp_3D_cpu , VectorBoundaryInterp_3D_gpu GENERIC , PUBLIC :: TensorBoundaryInterp_3D => TensorBoundaryInterp_3D_cpu , TensorBoundaryInterp_3D_gpu PROCEDURE , PRIVATE :: TensorBoundaryInterp_3D_cpu , TensorBoundaryInterp_3D_gpu GENERIC , PUBLIC :: Derivative_1D => Derivative_1D_cpu , Derivative_1D_gpu PROCEDURE , PRIVATE :: Derivative_1D_cpu , Derivative_1D_gpu GENERIC , PUBLIC :: DGDerivative_1D => DGDerivative_1D_cpu , DGDerivative_1D_gpu PROCEDURE , PRIVATE :: DGDerivative_1D_cpu , DGDerivative_1D_gpu GENERIC , PUBLIC :: ScalarGradient_2D => ScalarGradient_2D_cpu , ScalarGradient_2D_gpu PROCEDURE , PRIVATE :: ScalarGradient_2D_cpu , ScalarGradient_2D_gpu GENERIC , PUBLIC :: ScalarDGGradient_2D => ScalarDGGradient_2D_cpu , ScalarDGGradient_2D_gpu PROCEDURE , PRIVATE :: ScalarDGGradient_2D_cpu , ScalarDGGradient_2D_gpu GENERIC , PUBLIC :: VectorGradient_2D => VectorGradient_2D_cpu , VectorGradient_2D_gpu PROCEDURE , PRIVATE :: VectorGradient_2D_cpu , VectorGradient_2D_gpu GENERIC , PUBLIC :: VectorDGGradient_2D => VectorDGGradient_2D_cpu , VectorDGGradient_2D_gpu PROCEDURE , PRIVATE :: VectorDGGradient_2D_cpu , VectorDGGradient_2D_gpu GENERIC , PUBLIC :: VectorDivergence_2D => VectorDivergence_2D_cpu , VectorDivergence_2D_gpu PROCEDURE , PRIVATE :: VectorDivergence_2D_cpu , VectorDivergence_2D_gpu GENERIC , PUBLIC :: VectorDGDivergence_2D => VectorDGDivergence_2D_cpu , VectorDGDivergence_2D_gpu PROCEDURE , PRIVATE :: VectorDGDivergence_2D_cpu , VectorDGDivergence_2D_gpu GENERIC , PUBLIC :: VectorCurl_2D => VectorCurl_2D_cpu , VectorCurl_2D_gpu PROCEDURE , PRIVATE :: VectorCurl_2D_cpu , VectorCurl_2D_gpu GENERIC , PUBLIC :: TensorDivergence_2D => TensorDivergence_2D_cpu , TensorDivergence_2D_gpu PROCEDURE , PRIVATE :: TensorDivergence_2D_cpu , TensorDivergence_2D_gpu GENERIC , PUBLIC :: TensorDGDivergence_2D => TensorDGDivergence_2D_cpu , TensorDGDivergence_2D_gpu PROCEDURE , PRIVATE :: TensorDGDivergence_2D_cpu , TensorDGDivergence_2D_gpu GENERIC , PUBLIC :: ScalarGradient_3D => ScalarGradient_3D_cpu , ScalarGradient_3D_gpu PROCEDURE , PRIVATE :: ScalarGradient_3D_cpu , ScalarGradient_3D_gpu GENERIC , PUBLIC :: VectorGradient_3D => VectorGradient_3D_cpu , VectorGradient_3D_gpu PROCEDURE , PRIVATE :: VectorGradient_3D_cpu , VectorGradient_3D_gpu GENERIC , PUBLIC :: VectorDivergence_3D => VectorDivergence_3D_cpu , VectorDivergence_3D_gpu PROCEDURE , PRIVATE :: VectorDivergence_3D_cpu , VectorDivergence_3D_gpu GENERIC , PUBLIC :: VectorDGDivergence_3D => VectorDGDivergence_3D_cpu , VectorDGDivergence_3D_gpu PROCEDURE , PRIVATE :: VectorDGDivergence_3D_cpu , VectorDGDivergence_3D_gpu GENERIC , PUBLIC :: VectorCurl_3D => VectorCurl_3D_cpu , VectorCurl_3D_gpu PROCEDURE , PRIVATE :: VectorCurl_3D_cpu , VectorCurl_3D_gpu GENERIC , PUBLIC :: TensorDivergence_3D => TensorDivergence_3D_cpu , TensorDivergence_3D_gpu PROCEDURE , PRIVATE :: TensorDivergence_3D_cpu , TensorDivergence_3D_gpu GENERIC , PUBLIC :: TensorDGDivergence_3D => TensorDGDivergence_3D_cpu , TensorDGDivergence_3D_gpu PROCEDURE , PRIVATE :: TensorDGDivergence_3D_cpu , TensorDGDivergence_3D_gpu PROCEDURE , PRIVATE :: CalculateBarycentricWeights PROCEDURE , PRIVATE :: CalculateInterpolationMatrix PROCEDURE , PRIVATE :: CalculateDerivativeMatrix PROCEDURE , PRIVATE :: CalculateLagrangePolynomials END TYPE Lagrange","tags":"","loc":"type/lagrange.html"},{"title":"MappedScalar1D – SELF ","text":"type, public, EXTENDS(Scalar1D) :: MappedScalar1D Contents Type-Bound Procedures Derivative Derivative_MappedScalar1D JacobianWeight Source Code MappedScalar1D Type-Bound Procedures generic, public :: Derivative => Derivative_MappedScalar1D public subroutine Derivative_MappedScalar1D (scalar, geometry, dF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: scalar type(Geometry1D), intent(in) :: geometry type( MappedScalar1D ), intent(inout) :: dF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Derivative_MappedScalar1D public subroutine Derivative_MappedScalar1D (scalar, geometry, dF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: scalar type(Geometry1D), intent(in) :: geometry type( MappedScalar1D ), intent(inout) :: dF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: JacobianWeight => JacobianWeight_MappedScalar1D public subroutine JacobianWeight_MappedScalar1D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar type(Geometry1D), intent(in) :: geometry logical, intent(in) :: gpuAccel Source Code TYPE , EXTENDS ( Scalar1D ), PUBLIC :: MappedScalar1D CONTAINS GENERIC , PUBLIC :: Derivative => Derivative_MappedScalar1D PROCEDURE , PRIVATE :: Derivative_MappedScalar1D PROCEDURE , PRIVATE :: JacobianWeight => JacobianWeight_MappedScalar1D END TYPE MappedScalar1D","tags":"","loc":"type/mappedscalar1d.html"},{"title":"MappedScalar2D – SELF ","text":"type, public, EXTENDS(Scalar2D) :: MappedScalar2D Contents Type-Bound Procedures ContravariantWeight Gradient Gradient_MappedScalar2D JacobianWeight Source Code MappedScalar2D Type-Bound Procedures procedure, private :: ContravariantWeight => ContravariantWeight_MappedScalar2D public subroutine ContravariantWeight_MappedScalar2D (scalar, geometry, workTensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type(SEMQuad), intent(in) :: geometry type( MappedTensor2D ), intent(inout) :: workTensor logical, intent(in) :: gpuAccel generic, public :: Gradient => Gradient_MappedScalar2D public subroutine Gradient_MappedScalar2D (scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Gradient_MappedScalar2D public subroutine Gradient_MappedScalar2D (scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: JacobianWeight => JacobianWeight_MappedScalar2D public subroutine JacobianWeight_MappedScalar2D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel Source Code TYPE , EXTENDS ( Scalar2D ), PUBLIC :: MappedScalar2D CONTAINS GENERIC , PUBLIC :: Gradient => Gradient_MappedScalar2D PROCEDURE , PRIVATE :: Gradient_MappedScalar2D PROCEDURE , PRIVATE :: ContravariantWeight => ContravariantWeight_MappedScalar2D PROCEDURE , PRIVATE :: JacobianWeight => JacobianWeight_MappedScalar2D END TYPE MappedScalar2D","tags":"","loc":"type/mappedscalar2d.html"},{"title":"MappedScalar3D – SELF ","text":"type, public, EXTENDS(Scalar3D) :: MappedScalar3D Contents Type-Bound Procedures ContravariantWeight Gradient Gradient_MappedScalar3D JacobianWeight Source Code MappedScalar3D Type-Bound Procedures procedure, private :: ContravariantWeight => ContravariantWeight_MappedScalar3D public subroutine ContravariantWeight_MappedScalar3D (scalar, geometry, workTensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type(SEMHex), intent(in) :: geometry type( MappedTensor3D ), intent(inout) :: workTensor logical, intent(in) :: gpuAccel generic, public :: Gradient => Gradient_MappedScalar3D public subroutine Gradient_MappedScalar3D (scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Gradient_MappedScalar3D public subroutine Gradient_MappedScalar3D (scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: JacobianWeight => JacobianWeight_MappedScalar3D public subroutine JacobianWeight_MappedScalar3D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel Source Code TYPE , EXTENDS ( Scalar3D ), PUBLIC :: MappedScalar3D CONTAINS GENERIC , PUBLIC :: Gradient => Gradient_MappedScalar3D PROCEDURE , PRIVATE :: Gradient_MappedScalar3D PROCEDURE , PRIVATE :: ContravariantWeight => ContravariantWeight_MappedScalar3D PROCEDURE , PRIVATE :: JacobianWeight => JacobianWeight_MappedScalar3D END TYPE MappedScalar3D","tags":"","loc":"type/mappedscalar3d.html"},{"title":"MappedTensor2D – SELF ","text":"type, public, EXTENDS(Tensor2D) :: MappedTensor2D Contents Type-Bound Procedures JacobianWeight Source Code MappedTensor2D Type-Bound Procedures procedure, private :: JacobianWeight => JacobianWeight_MappedTensor2D public subroutine JacobianWeight_MappedTensor2D (tensor, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel Source Code TYPE , EXTENDS ( Tensor2D ), PUBLIC :: MappedTensor2D CONTAINS ! !    GENERIC,PUBLIC :: Divergence => Divergence_MappedTensor2D !    PROCEDURE,PRIVATE :: Divergence_MappedTensor2D PROCEDURE , PRIVATE :: JacobianWeight => JacobianWeight_MappedTensor2D END TYPE MappedTensor2D","tags":"","loc":"type/mappedtensor2d.html"},{"title":"MappedTensor3D – SELF ","text":"type, public, EXTENDS(Tensor3D) :: MappedTensor3D Contents Type-Bound Procedures JacobianWeight Source Code MappedTensor3D Type-Bound Procedures procedure, private :: JacobianWeight => JacobianWeight_MappedTensor3D public subroutine JacobianWeight_MappedTensor3D (tensor, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel Source Code TYPE , EXTENDS ( Tensor3D ), PUBLIC :: MappedTensor3D CONTAINS ! !    GENERIC,PUBLIC :: Divergence => Divergence_MappedTensor3D !    PROCEDURE,PRIVATE :: Divergence_MappedTensor3D PROCEDURE , PRIVATE :: JacobianWeight => JacobianWeight_MappedTensor3D END TYPE MappedTensor3D","tags":"","loc":"type/mappedtensor3d.html"},{"title":"MappedVector2D – SELF ","text":"type, public, EXTENDS(Vector2D) :: MappedVector2D Contents Type-Bound Procedures ContravariantProjection Divergence Divergence_MappedVector2D Gradient Gradient_MappedVector2D JacobianWeight MapToScalar MapToTensor Source Code MappedVector2D Type-Bound Procedures procedure, private :: ContravariantProjection => ContravariantProjection_MappedVector2D public subroutine ContravariantProjection_MappedVector2D (physVector, geometry, compVector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: physVector type(SEMQuad), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: compVector logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_MappedVector2D public subroutine Divergence_MappedVector2D (physVector, compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: physVector type( MappedVector2D ), intent(inout) :: compVector type(SEMQuad), intent(in) :: geometry type( MappedScalar2D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Divergence_MappedVector2D public subroutine Divergence_MappedVector2D (physVector, compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: physVector type( MappedVector2D ), intent(inout) :: compVector type(SEMQuad), intent(in) :: geometry type( MappedScalar2D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel generic, public :: Gradient => Gradient_MappedVector2D public subroutine Gradient_MappedVector2D (vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedScalar2D ), intent(inout) :: workScalar type( MappedVector2D ), intent(inout) :: workVector type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedTensor2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Gradient_MappedVector2D public subroutine Gradient_MappedVector2D (vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedScalar2D ), intent(inout) :: workScalar type( MappedVector2D ), intent(inout) :: workVector type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedTensor2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: JacobianWeight => JacobianWeight_MappedVector2D public subroutine JacobianWeight_MappedVector2D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel procedure, private :: MapToScalar => MapToScalar_MappedVector2D public subroutine MapToScalar_MappedVector2D (vector, scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedScalar2D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel procedure, private :: MapToTensor => MapToTensor_MappedVector2D public subroutine MapToTensor_MappedVector2D (vector, tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedTensor2D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel Source Code TYPE , EXTENDS ( Vector2D ), PUBLIC :: MappedVector2D CONTAINS GENERIC , PUBLIC :: Divergence => Divergence_MappedVector2D GENERIC , PUBLIC :: Gradient => Gradient_MappedVector2D !    GENERIC,PUBLIC :: Curl => Curl_MappedVector2D PROCEDURE , PRIVATE :: Divergence_MappedVector2D PROCEDURE , PRIVATE :: Gradient_MappedVector2D !    PROCEDURE,PRIVATE :: Curl_MappedVector2D PROCEDURE , PRIVATE :: ContravariantProjection => ContravariantProjection_MappedVector2D PROCEDURE , PRIVATE :: JacobianWeight => JacobianWeight_MappedVector2D PROCEDURE , PRIVATE :: MapToScalar => MapToScalar_MappedVector2D PROCEDURE , PRIVATE :: MapToTensor => MapToTensor_MappedVector2D END TYPE MappedVector2D","tags":"","loc":"type/mappedvector2d.html"},{"title":"MappedVector3D – SELF ","text":"type, public, EXTENDS(Vector3D) :: MappedVector3D Contents Type-Bound Procedures ContravariantProjection Divergence Divergence_MappedVector3D Gradient Gradient_MappedVector3D JacobianWeight MapToScalar MapToTensor Source Code MappedVector3D Type-Bound Procedures procedure, private :: ContravariantProjection => ContravariantProjection_MappedVector3D public subroutine ContravariantProjection_MappedVector3D (physVector, geometry, compVector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: physVector type(SEMHex), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: compVector logical, intent(in) :: gpuAccel generic, public :: Divergence => Divergence_MappedVector3D public subroutine Divergence_MappedVector3D (physVector, compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: physVector type( MappedVector3D ), intent(inout) :: compVector type(SEMHex), intent(in) :: geometry type( MappedScalar3D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Divergence_MappedVector3D public subroutine Divergence_MappedVector3D (physVector, compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: physVector type( MappedVector3D ), intent(inout) :: compVector type(SEMHex), intent(in) :: geometry type( MappedScalar3D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel generic, public :: Gradient => Gradient_MappedVector3D public subroutine Gradient_MappedVector3D (vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedScalar3D ), intent(inout) :: workScalar type( MappedVector3D ), intent(inout) :: workVector type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedTensor3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: Gradient_MappedVector3D public subroutine Gradient_MappedVector3D (vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedScalar3D ), intent(inout) :: workScalar type( MappedVector3D ), intent(inout) :: workVector type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedTensor3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel procedure, private :: JacobianWeight => JacobianWeight_MappedVector3D public subroutine JacobianWeight_MappedVector3D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel procedure, private :: MapToScalar => MapToScalar_MappedVector3D public subroutine MapToScalar_MappedVector3D (vector, scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedScalar3D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel procedure, private :: MapToTensor => MapToTensor_MappedVector3D public subroutine MapToTensor_MappedVector3D (vector, tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedTensor3D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel Source Code TYPE , EXTENDS ( Vector3D ), PUBLIC :: MappedVector3D CONTAINS GENERIC , PUBLIC :: Divergence => Divergence_MappedVector3D !    GENERIC,PUBLIC :: Curl => Curl_MappedVector3D GENERIC , PUBLIC :: Gradient => Gradient_MappedVector3D PROCEDURE , PRIVATE :: Divergence_MappedVector3D !    PROCEDURE,PRIVATE :: Curl_MappedVector3D PROCEDURE , PRIVATE :: Gradient_MappedVector3D PROCEDURE , PRIVATE :: ContravariantProjection => ContravariantProjection_MappedVector3D PROCEDURE , PRIVATE :: JacobianWeight => JacobianWeight_MappedVector3D PROCEDURE , PRIVATE :: MapToScalar => MapToScalar_MappedVector3D PROCEDURE , PRIVATE :: MapToTensor => MapToTensor_MappedVector3D END TYPE MappedVector3D","tags":"","loc":"type/mappedvector3d.html"},{"title":"Mesh1D – SELF ","text":"type, public :: Mesh1D Inherits type~~mesh1d~~InheritsGraph type~mesh1d Mesh1D hfInt32_r2 hfInt32_r2 type~mesh1d->hfInt32_r2 elemInfo, BCType hfReal_r1 hfReal_r1 type~mesh1d->hfReal_r1 nodeCoords, globalNodeIDs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables BCNames BCType elemInfo globalNodeIDs nBCs nCornerNodes nElem nGeo nNodes nUniqueNodes nodeCoords Type-Bound Procedures Free Init UniformBlockMesh UpdateDevice UpdateHost Source Code Mesh1D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type(hfInt32_r2), public :: BCType type(hfInt32_r2), public :: elemInfo type(hfReal_r1), public :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nNodes integer, public :: nUniqueNodes type(hfReal_r1), public :: nodeCoords Type-Bound Procedures procedure, public :: Free => Free_Mesh1D public subroutine Free_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh procedure, public :: Init => Init_Mesh1D public subroutine Init_Mesh1D (myMesh, nGeo, nElem, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nNodes integer, intent(in) :: nBCs procedure, public :: UniformBlockMesh => UniformBlockMesh_Mesh1D public subroutine UniformBlockMesh_Mesh1D (myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem real(kind=prec), intent(in) :: x (1:2) procedure, public :: UpdateDevice => UpdateDevice_Mesh1D public subroutine UpdateDevice_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh procedure, public :: UpdateHost => UpdateHost_Mesh1D public subroutine UpdateHost_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh Source Code TYPE , PUBLIC :: Mesh1D INTEGER :: nGeo INTEGER :: nElem INTEGER :: nNodes INTEGER :: nCornerNodes INTEGER :: nUniqueNodes INTEGER :: nBCs TYPE ( hfInt32_r2 ) :: elemInfo TYPE ( hfReal_r1 ) :: nodeCoords TYPE ( hfReal_r1 ) :: globalNodeIDs TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh1D PROCEDURE , PUBLIC :: Free => Free_Mesh1D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh1D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh1D PROCEDURE , PUBLIC :: UniformBlockMesh => UniformBlockMesh_Mesh1D END TYPE Mesh1D","tags":"","loc":"type/mesh1d.html"},{"title":"Mesh2D – SELF ","text":"type, public :: Mesh2D Inherits type~~mesh2d~~InheritsGraph type~mesh2d Mesh2D hfInt32_r2 hfInt32_r2 type~mesh2d->hfInt32_r2 elemInfo, sideInfo, CGNSSideMap, curveNodeMap, curveNodeMapInv, BCType hfReal_r2 hfReal_r2 type~mesh2d->hfReal_r2 nodeCoords hfReal_r1 hfReal_r1 type~mesh2d->hfReal_r1 globalNodeIDs hfInt32_r1 hfInt32_r1 type~mesh2d->hfInt32_r1 CGNSCornerMap Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables BCNames BCType CGNSCornerMap CGNSSideMap curveNodeMap curveNodeMapInv elemInfo globalNodeIDs nBCs nCornerNodes nElem nGeo nNodes nSides nUniqueNodes nUniqueSides nodeCoords sideInfo Type-Bound Procedures Free Init UniformBlockMesh UpdateDevice UpdateHost Source Code Mesh2D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type(hfInt32_r2), public :: BCType type(hfInt32_r1), public :: CGNSCornerMap type(hfInt32_r2), public :: CGNSSideMap type(hfInt32_r2), public :: curveNodeMap type(hfInt32_r2), public :: curveNodeMapInv type(hfInt32_r2), public :: elemInfo type(hfReal_r1), public :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides type(hfReal_r2), public :: nodeCoords type(hfInt32_r2), public :: sideInfo Type-Bound Procedures procedure, public :: Free => Free_Mesh2D public subroutine Free_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh procedure, public :: Init => Init_Mesh2D public subroutine Init_Mesh2D (myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs procedure, public :: UniformBlockMesh => UniformBlockMesh_Mesh2D public subroutine UniformBlockMesh_Mesh2D (myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem (1:2) real(kind=prec), intent(in) :: x (1:4) procedure, public :: UpdateDevice => UpdateDevice_Mesh2D public subroutine UpdateDevice_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh procedure, public :: UpdateHost => UpdateHost_Mesh2D public subroutine UpdateHost_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh Source Code TYPE , PUBLIC :: Mesh2D INTEGER :: nGeo INTEGER :: nElem INTEGER :: nNodes INTEGER :: nSides INTEGER :: nCornerNodes INTEGER :: nUniqueNodes INTEGER :: nUniqueSides INTEGER :: nBCs TYPE ( hfInt32_r2 ) :: elemInfo TYPE ( hfInt32_r2 ) :: sideInfo TYPE ( hfReal_r2 ) :: nodeCoords TYPE ( hfReal_r1 ) :: globalNodeIDs TYPE ( hfInt32_r1 ) :: CGNSCornerMap TYPE ( hfInt32_r2 ) :: CGNSSideMap TYPE ( hfInt32_r2 ) :: curveNodeMap TYPE ( hfInt32_r2 ) :: curveNodeMapInv TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh2D PROCEDURE , PUBLIC :: Free => Free_Mesh2D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh2D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh2D PROCEDURE , PUBLIC :: UniformBlockMesh => UniformBlockMesh_Mesh2D !    PROCEDURE, PUBLIC :: GenerateConnectivity => GenerateConnectivity_Mesh2D END TYPE Mesh2D","tags":"","loc":"type/mesh2d.html"},{"title":"Mesh3D – SELF ","text":"type, public :: Mesh3D Inherits type~~mesh3d~~InheritsGraph type~mesh3d Mesh3D hfInt32_r2 hfInt32_r2 type~mesh3d->hfInt32_r2 elemInfo, sideInfo, CGNSSideMap, curveNodeMap, BCType hfReal_r2 hfReal_r2 type~mesh3d->hfReal_r2 nodeCoords hfReal_r1 hfReal_r1 type~mesh3d->hfReal_r1 globalNodeIDs hfInt32_r1 hfInt32_r1 type~mesh3d->hfInt32_r1 CGNSCornerMap hfInt32_r3 hfInt32_r3 type~mesh3d->hfInt32_r3 curveNodeMapInv Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables BCNames BCType CGNSCornerMap CGNSSideMap curveNodeMap curveNodeMapInv elemInfo globalNodeIDs nBCs nCornerNodes nElem nGeo nNodes nSides nUniqueNodes nUniqueSides nodeCoords sideInfo Type-Bound Procedures Free Init UniformBlockMesh UpdateDevice UpdateHost Source Code Mesh3D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type(hfInt32_r2), public :: BCType type(hfInt32_r1), public :: CGNSCornerMap type(hfInt32_r2), public :: CGNSSideMap type(hfInt32_r2), public :: curveNodeMap type(hfInt32_r3), public :: curveNodeMapInv type(hfInt32_r2), public :: elemInfo type(hfReal_r1), public :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides type(hfReal_r2), public :: nodeCoords type(hfInt32_r2), public :: sideInfo Type-Bound Procedures procedure, public :: Free => Free_Mesh3D public subroutine Free_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh procedure, public :: Init => Init_Mesh3D public subroutine Init_Mesh3D (myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs procedure, public :: UniformBlockMesh => UniformBlockMesh_Mesh3D public subroutine UniformBlockMesh_Mesh3D (myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem (1:3) real(kind=prec), intent(in) :: x (1:6) procedure, public :: UpdateDevice => UpdateDevice_Mesh3D public subroutine UpdateDevice_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh procedure, public :: UpdateHost => UpdateHost_Mesh3D public subroutine UpdateHost_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh Source Code TYPE , PUBLIC :: Mesh3D INTEGER :: nGeo INTEGER :: nElem INTEGER :: nNodes INTEGER :: nSides INTEGER :: nCornerNodes INTEGER :: nUniqueNodes INTEGER :: nUniqueSides INTEGER :: nBCs TYPE ( hfInt32_r2 ) :: elemInfo TYPE ( hfInt32_r2 ) :: sideInfo TYPE ( hfReal_r2 ) :: nodeCoords TYPE ( hfReal_r1 ) :: globalNodeIDs TYPE ( hfInt32_r1 ) :: CGNSCornerMap TYPE ( hfInt32_r2 ) :: CGNSSideMap TYPE ( hfInt32_r2 ) :: curveNodeMap TYPE ( hfInt32_r3 ) :: curveNodeMapInv TYPE ( hfInt32_r2 ) :: BCType CHARACTER ( LEN = 255 ), ALLOCATABLE :: BCNames (:) CONTAINS PROCEDURE , PUBLIC :: Init => Init_Mesh3D PROCEDURE , PUBLIC :: Free => Free_Mesh3D PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_Mesh3D PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_Mesh3D PROCEDURE , PUBLIC :: UniformBlockMesh => UniformBlockMesh_Mesh3D !      PROCEDURE, PUBLIC :: LoadHOPRMesh => LoadHOPRMesh_3D ! !      PROCEDURE, PUBLIC :: Read_CGNSMesh !      PROCEDURE, PUBLIC :: Read_UCDMesh !      PROCEDURE, PUBLIC :: Read_TrellisUCDMesh ! !    PROCEDURE, PUBLIC :: GenerateConnectivity => GenerateConnectivity_Mesh3D END TYPE Mesh3D","tags":"","loc":"type/mesh3d.html"},{"title":"hfInt32_r1 – SELF ","text":"type, public :: hfInt32_r1 Data type for storing one-dimensional int32 arrays on the host and the device Inherits type~~hfint32_r1~~InheritsGraph type~hfint32_r1 hfInt32_r1 c_ptr c_ptr type~hfint32_r1->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r1 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r1 public subroutine Alloc_hfInt32_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound procedure, public :: Free => Free_hfInt32_r1 public subroutine Free_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r1 public subroutine UpdateDevice_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r1 public subroutine UpdateHost_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this Source Code TYPE hfInt32_r1 !! Data type for storing one-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r1 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r1 END TYPE hfInt32_r1","tags":"","loc":"type/hfint32_r1.html"},{"title":"hfInt32_r2 – SELF ","text":"type, public :: hfInt32_r2 Data type for storing two-dimensional int32 arrays on the host and the device Inherits type~~hfint32_r2~~InheritsGraph type~hfint32_r2 hfInt32_r2 c_ptr c_ptr type~hfint32_r2->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r2 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r2 public subroutine Alloc_hfInt32_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) procedure, public :: Free => Free_hfInt32_r2 public subroutine Free_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r2 public subroutine UpdateDevice_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r2 public subroutine UpdateHost_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this Source Code TYPE hfInt32_r2 !! Data type for storing two-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r2 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r2 END TYPE hfInt32_r2","tags":"","loc":"type/hfint32_r2.html"},{"title":"hfInt32_r3 – SELF ","text":"type, public :: hfInt32_r3 Data type for storing three-dimensional int32 arrays on the host and the device Inherits type~~hfint32_r3~~InheritsGraph type~hfint32_r3 hfInt32_r3 c_ptr c_ptr type~hfint32_r3->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r3 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r3 public subroutine Alloc_hfInt32_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) procedure, public :: Free => Free_hfInt32_r3 public subroutine Free_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r3 public subroutine UpdateDevice_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r3 public subroutine UpdateHost_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this Source Code TYPE hfInt32_r3 !! Data type for storing three-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r3 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r3 END TYPE hfInt32_r3","tags":"","loc":"type/hfint32_r3.html"},{"title":"hfInt32_r4 – SELF ","text":"type, public :: hfInt32_r4 Data type for storing four-dimensional int32 arrays on the host and the device Inherits type~~hfint32_r4~~InheritsGraph type~hfint32_r4 hfInt32_r4 c_ptr c_ptr type~hfint32_r4->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r4 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r4 public subroutine Alloc_hfInt32_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) procedure, public :: Free => Free_hfInt32_r4 public subroutine Free_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r4 public subroutine UpdateDevice_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r4 public subroutine UpdateHost_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this Source Code TYPE hfInt32_r4 !! Data type for storing four-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r4 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r4 END TYPE hfInt32_r4","tags":"","loc":"type/hfint32_r4.html"},{"title":"hfInt32_r5 – SELF ","text":"type, public :: hfInt32_r5 Data type for storing five-dimensional int32 arrays on the host and the device Inherits type~~hfint32_r5~~InheritsGraph type~hfint32_r5 hfInt32_r5 c_ptr c_ptr type~hfint32_r5->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r5 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r5 public subroutine Alloc_hfInt32_r5 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) procedure, public :: Free => Free_hfInt32_r5 public subroutine Free_hfInt32_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r5 public subroutine UpdateDevice_hfInt32_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r5 public subroutine UpdateHost_hfInt32_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this Source Code TYPE hfInt32_r5 !! Data type for storing five-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r5 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r5 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r5 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r5 END TYPE hfInt32_r5","tags":"","loc":"type/hfint32_r5.html"},{"title":"hfInt32_r6 – SELF ","text":"type, public :: hfInt32_r6 Data type for storing six-dimensional int32 arrays on the host and the device Inherits type~~hfint32_r6~~InheritsGraph type~hfint32_r6 hfInt32_r6 c_ptr c_ptr type~hfint32_r6->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r6 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r6 public subroutine Alloc_hfInt32_r6 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) procedure, public :: Free => Free_hfInt32_r6 public subroutine Free_hfInt32_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r6 public subroutine UpdateDevice_hfInt32_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r6 public subroutine UpdateHost_hfInt32_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this Source Code TYPE hfInt32_r6 !! Data type for storing six-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r6 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r6 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r6 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r6 END TYPE hfInt32_r6","tags":"","loc":"type/hfint32_r6.html"},{"title":"hfInt32_r7 – SELF ","text":"type, public :: hfInt32_r7 Data type for storing seven-dimensional int32 arrays on the host and the device Inherits type~~hfint32_r7~~InheritsGraph type~hfint32_r7 hfInt32_r7 c_ptr c_ptr type~hfint32_r7->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt32_r7 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r7 public subroutine Alloc_hfInt32_r7 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) procedure, public :: Free => Free_hfInt32_r7 public subroutine Free_hfInt32_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r7 public subroutine UpdateDevice_hfInt32_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt32_r7 public subroutine UpdateHost_hfInt32_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this Source Code TYPE hfInt32_r7 !! Data type for storing seven-dimensional int32 arrays on the host and the device INTEGER ( int32 ), POINTER :: hostData (:,:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt32_r7 PROCEDURE , PUBLIC :: Free => Free_hfInt32_r7 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt32_r7 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt32_r7 END TYPE hfInt32_r7","tags":"","loc":"type/hfint32_r7.html"},{"title":"hfInt64_r1 – SELF ","text":"type, public :: hfInt64_r1 Data type for storing one-dimensional int64 arrays on the host and the device Inherits type~~hfint64_r1~~InheritsGraph type~hfint64_r1 hfInt64_r1 c_ptr c_ptr type~hfint64_r1->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt64_r1 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r1 public subroutine Alloc_hfInt64_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound procedure, public :: Free => Free_hfInt64_r1 public subroutine Free_hfInt64_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r1 public subroutine UpdateDevice_hfInt64_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt64_r1 public subroutine UpdateHost_hfInt64_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this Source Code TYPE hfInt64_r1 !! Data type for storing one-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r1 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r1 END TYPE hfInt64_r1","tags":"","loc":"type/hfint64_r1.html"},{"title":"hfInt64_r2 – SELF ","text":"type, public :: hfInt64_r2 Data type for storing two-dimensional int64 arrays on the host and the device Inherits type~~hfint64_r2~~InheritsGraph type~hfint64_r2 hfInt64_r2 c_ptr c_ptr type~hfint64_r2->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt64_r2 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r2 public subroutine Alloc_hfInt64_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) procedure, public :: Free => Free_hfInt64_r2 public subroutine Free_hfInt64_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r2 public subroutine UpdateDevice_hfInt64_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt64_r2 public subroutine UpdateHost_hfInt64_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this Source Code TYPE hfInt64_r2 !! Data type for storing two-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r2 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r2 END TYPE hfInt64_r2","tags":"","loc":"type/hfint64_r2.html"},{"title":"hfInt64_r3 – SELF ","text":"type, public :: hfInt64_r3 Data type for storing three-dimensional int64 arrays on the host and the device Inherits type~~hfint64_r3~~InheritsGraph type~hfint64_r3 hfInt64_r3 c_ptr c_ptr type~hfint64_r3->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt64_r3 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r3 public subroutine Alloc_hfInt64_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) procedure, public :: Free => Free_hfInt64_r3 public subroutine Free_hfInt64_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r3 public subroutine UpdateDevice_hfInt64_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt64_r3 public subroutine UpdateHost_hfInt64_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this Source Code TYPE hfInt64_r3 !! Data type for storing three-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r3 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r3 END TYPE hfInt64_r3","tags":"","loc":"type/hfint64_r3.html"},{"title":"hfInt64_r4 – SELF ","text":"type, public :: hfInt64_r4 Data type for storing four-dimensional int64 arrays on the host and the device Inherits type~~hfint64_r4~~InheritsGraph type~hfint64_r4 hfInt64_r4 c_ptr c_ptr type~hfint64_r4->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt64_r4 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r4 public subroutine Alloc_hfInt64_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) procedure, public :: Free => Free_hfInt64_r4 public subroutine Free_hfInt64_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r4 public subroutine UpdateDevice_hfInt64_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt64_r4 public subroutine UpdateHost_hfInt64_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this Source Code TYPE hfInt64_r4 !! Data type for storing four-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r4 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r4 END TYPE hfInt64_r4","tags":"","loc":"type/hfint64_r4.html"},{"title":"hfInt64_r5 – SELF ","text":"type, public :: hfInt64_r5 Data type for storing five-dimensional int64 arrays on the host and the device Inherits type~~hfint64_r5~~InheritsGraph type~hfint64_r5 hfInt64_r5 c_ptr c_ptr type~hfint64_r5->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt64_r5 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r5 public subroutine Alloc_hfInt64_r5 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) procedure, public :: Free => Free_hfInt64_r5 public subroutine Free_hfInt64_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r5 public subroutine UpdateDevice_hfInt64_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt64_r5 public subroutine UpdateHost_hfInt64_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this Source Code TYPE hfInt64_r5 !! Data type for storing five-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r5 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r5 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r5 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r5 END TYPE hfInt64_r5","tags":"","loc":"type/hfint64_r5.html"},{"title":"hfInt64_r6 – SELF ","text":"type, public :: hfInt64_r6 Data type for storing six-dimensional int64 arrays on the host and the device Inherits type~~hfint64_r6~~InheritsGraph type~hfint64_r6 hfInt64_r6 c_ptr c_ptr type~hfint64_r6->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt64_r6 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r6 public subroutine Alloc_hfInt64_r6 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) procedure, public :: Free => Free_hfInt64_r6 public subroutine Free_hfInt64_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r6 public subroutine UpdateDevice_hfInt64_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt64_r6 public subroutine UpdateHost_hfInt64_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this Source Code TYPE hfInt64_r6 !! Data type for storing six-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r6 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r6 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r6 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r6 END TYPE hfInt64_r6","tags":"","loc":"type/hfint64_r6.html"},{"title":"hfInt64_r7 – SELF ","text":"type, public :: hfInt64_r7 Data type for storing seven-dimensional int64 arrays on the host and the device Inherits type~~hfint64_r7~~InheritsGraph type~hfint64_r7 hfInt64_r7 c_ptr c_ptr type~hfint64_r7->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfInt64_r7 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r7 public subroutine Alloc_hfInt64_r7 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) procedure, public :: Free => Free_hfInt64_r7 public subroutine Free_hfInt64_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r7 public subroutine UpdateDevice_hfInt64_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfInt64_r7 public subroutine UpdateHost_hfInt64_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this Source Code TYPE hfInt64_r7 !! Data type for storing seven-dimensional int64 arrays on the host and the device INTEGER ( int64 ), POINTER :: hostData (:,:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfInt64_r7 PROCEDURE , PUBLIC :: Free => Free_hfInt64_r7 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfInt64_r7 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfInt64_r7 END TYPE hfInt64_r7","tags":"","loc":"type/hfint64_r7.html"},{"title":"hfReal_r1 – SELF ","text":"type, public :: hfReal_r1 Data type for storing one-dimensional real arrays on the host and the device Inherits type~~hfreal_r1~~InheritsGraph type~hfreal_r1 hfReal_r1 c_ptr c_ptr type~hfreal_r1->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r1 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r1 public subroutine Alloc_hfReal_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound procedure, public :: Free => Free_hfReal_r1 public subroutine Free_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r1 public subroutine UpdateDevice_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r1 public subroutine UpdateHost_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this Source Code TYPE hfReal_r1 !! Data type for storing one-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r1 PROCEDURE , PUBLIC :: Free => Free_hfReal_r1 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r1 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r1 END TYPE hfReal_r1","tags":"","loc":"type/hfreal_r1.html"},{"title":"hfReal_r2 – SELF ","text":"type, public :: hfReal_r2 Data type for storing two-dimensional real arrays on the host and the device Inherits type~~hfreal_r2~~InheritsGraph type~hfreal_r2 hfReal_r2 c_ptr c_ptr type~hfreal_r2->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r2 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r2 public subroutine Alloc_hfReal_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) procedure, public :: Free => Free_hfReal_r2 public subroutine Free_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r2 public subroutine UpdateDevice_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r2 public subroutine UpdateHost_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this Source Code TYPE hfReal_r2 !! Data type for storing two-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r2 PROCEDURE , PUBLIC :: Free => Free_hfReal_r2 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r2 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r2 END TYPE hfReal_r2","tags":"","loc":"type/hfreal_r2.html"},{"title":"hfReal_r3 – SELF ","text":"type, public :: hfReal_r3 Data type for storing three-dimensional real arrays on the host and the device Inherits type~~hfreal_r3~~InheritsGraph type~hfreal_r3 hfReal_r3 c_ptr c_ptr type~hfreal_r3->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r3 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r3 public subroutine Alloc_hfReal_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) procedure, public :: Free => Free_hfReal_r3 public subroutine Free_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r3 public subroutine UpdateDevice_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r3 public subroutine UpdateHost_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this Source Code TYPE hfReal_r3 !! Data type for storing three-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r3 PROCEDURE , PUBLIC :: Free => Free_hfReal_r3 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r3 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r3 END TYPE hfReal_r3","tags":"","loc":"type/hfreal_r3.html"},{"title":"hfReal_r4 – SELF ","text":"type, public :: hfReal_r4 Data type for storing four-dimensional real arrays on the host and the device Inherits type~~hfreal_r4~~InheritsGraph type~hfreal_r4 hfReal_r4 c_ptr c_ptr type~hfreal_r4->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r4 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r4 public subroutine Alloc_hfReal_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) procedure, public :: Free => Free_hfReal_r4 public subroutine Free_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r4 public subroutine UpdateDevice_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r4 public subroutine UpdateHost_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this Source Code TYPE hfReal_r4 !! Data type for storing four-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r4 PROCEDURE , PUBLIC :: Free => Free_hfReal_r4 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r4 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r4 END TYPE hfReal_r4","tags":"","loc":"type/hfreal_r4.html"},{"title":"hfReal_r5 – SELF ","text":"type, public :: hfReal_r5 Data type for storing five-dimensional real arrays on the host and the device Inherits type~~hfreal_r5~~InheritsGraph type~hfreal_r5 hfReal_r5 c_ptr c_ptr type~hfreal_r5->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r5 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r5 public subroutine Alloc_hfReal_r5 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) procedure, public :: Free => Free_hfReal_r5 public subroutine Free_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r5 public subroutine UpdateDevice_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r5 public subroutine UpdateHost_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this Source Code TYPE hfReal_r5 !! Data type for storing five-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r5 PROCEDURE , PUBLIC :: Free => Free_hfReal_r5 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r5 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r5 END TYPE hfReal_r5","tags":"","loc":"type/hfreal_r5.html"},{"title":"hfReal_r6 – SELF ","text":"type, public :: hfReal_r6 Data type for storing one-dimensional real arrays on the host and the device Inherits type~~hfreal_r6~~InheritsGraph type~hfreal_r6 hfReal_r6 c_ptr c_ptr type~hfreal_r6->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r6 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r6 public subroutine Alloc_hfReal_r6 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) procedure, public :: Free => Free_hfReal_r6 public subroutine Free_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r6 public subroutine UpdateDevice_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r6 public subroutine UpdateHost_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this Source Code TYPE hfReal_r6 !! Data type for storing one-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r6 PROCEDURE , PUBLIC :: Free => Free_hfReal_r6 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r6 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r6 END TYPE hfReal_r6","tags":"","loc":"type/hfreal_r6.html"},{"title":"hfReal_r7 – SELF ","text":"type, public :: hfReal_r7 Data type for storing seven-dimensional real arrays on the host and the device Inherits type~~hfreal_r7~~InheritsGraph type~hfreal_r7 hfReal_r7 c_ptr c_ptr type~hfreal_r7->c_ptr deviceData Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables deviceData hostData Type-Bound Procedures Alloc Free UpdateDevice UpdateHost Source Code hfReal_r7 Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r7 public subroutine Alloc_hfReal_r7 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) procedure, public :: Free => Free_hfReal_r7 public subroutine Free_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this procedure, public :: UpdateDevice => UpdateDevice_hfReal_r7 public subroutine UpdateDevice_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this procedure, public :: UpdateHost => UpdateHost_hfReal_r7 public subroutine UpdateHost_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this Source Code TYPE hfReal_r7 !! Data type for storing seven-dimensional real arrays on the host and the device REAL ( prec ), POINTER :: hostData (:,:,:,:,:,:,:) TYPE ( c_ptr ) :: deviceData CONTAINS PROCEDURE , PUBLIC :: Alloc => Alloc_hfReal_r7 PROCEDURE , PUBLIC :: Free => Free_hfReal_r7 PROCEDURE , PUBLIC :: UpdateHost => UpdateHost_hfReal_r7 PROCEDURE , PUBLIC :: UpdateDevice => UpdateDevice_hfReal_r7 END TYPE hfReal_r7","tags":"","loc":"type/hfreal_r7.html"},{"title":"Parse_CLI – SELF","text":"subroutine Parse_CLI(cli) Arguments Type Intent Optional Attributes Name type(COMMAND_LINE_INTERFACE), intent(out) :: cli Called by proc~~parse_cli~~CalledByGraph proc~parse_cli Parse_CLI program~self SELF program~self->proc~parse_cli Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Parse_CLI Source Code SUBROUTINE Parse_CLI ( cli ) IMPLICIT NONE TYPE ( COMMAND_LINE_INTERFACE ), INTENT ( out ) :: cli CALL cli % init ( progname = \"self\" , & version = \"v0.0.0\" , & description = \"Spectral Element Libraries in Fortran (SELF)\" , & license = \"ANTI-CAPITALIST SOFTWARE LICENSE (v 1.4)\" , & authors = \"Joseph Schoonover (Fluid Numerics LLC)\" ) CALL cli % add ( switch = \"--control-degree\" , & switch_ab = \"-c\" , & help = \"The polynomial degree of the control points.\" // NEW_LINE ( \"A\" ), & def = \"2\" , & required = . FALSE .) CALL cli % add ( switch = \"--target-degree\" , & switch_ab = \"-t\" , & help = \"The polynomial degree for the target points for interpolation.\" // NEW_LINE ( \"A\" ), & def = \"7\" , & required = . FALSE .) CALL cli % add ( switch = \"--control-quadrature\" , & switch_ab = \"-cq\" , & def = \"gauss\" , & help = \"The quadrature type for control points.\" // NEW_LINE ( \"A\" ), & choices = \"gauss, gauss-lobatto, uniform\" , & required = . FALSE .) CALL cli % add ( switch = \"--target-quadrature\" , & switch_ab = \"-tq\" , & def = \"gauss\" , & help = \"The quadrature type for target points.\" // NEW_LINE ( \"A\" ), & choices = \"gauss, gauss-lobatto, uniform\" , & required = . FALSE .) CALL cli % add ( switch = \"--nvar\" , & switch_ab = \"-nv\" , & help = \"The number of functions used to simulate increased workloads.\" // NEW_LINE ( \"A\" ), & def = \"5\" , & required = . FALSE .) CALL cli % add ( switch = \"--nelements\" , & switch_ab = \"-ne\" , & help = \"The number of elements to use on the test mesh. \" // & \"In multi-dimensions, the number of elements in each direction.\" // NEW_LINE ( \"A\" ), & def = \"10\" , & required = . FALSE .) CALL cli % add ( switch = \"--gpu-accel\" , & switch_ab = \"-gpu\" , & help = \"Boolean flag for enabling or disabling GPU acceleration in tests.\" // NEW_LINE ( \"A\" ), & def = \"false\" , & choices = \"true,false\" , & required = . FALSE .) CALL cli % add ( switch = \"--tolerance\" , & switch_ab = \"-tol\" , & help = \"Tolerance to use for determining if a test passes.\" // NEW_LINE ( \"A\" ), & def = \"1.0E-5\" , & required = . FALSE .) CALL cli % add ( switch = \"--derivative-type\" , & switch_ab = \"-dtype\" , & help = \"Flag to choose the type of derivative operator (weak/strong).\" // NEW_LINE ( \"A\" ), & def = \"strong\" , & choices = \"strong,dg\" , & required = . FALSE .) CALL cli % add ( switch = \"--function\" , & switch_ab = \"-f\" , & help = \"Function to interpolate from control points to target points\" // NEW_LINE ( \"A\" ), & def = \"f=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--derivative\" , & switch_ab = \"-df\" , & help = \"Derivative of the test function; used for estimating errors.\" // NEW_LINE ( \"A\" ), & def = \"df=0.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--vector-x\" , & switch_ab = \"-vx\" , & help = \"x-component of the vector function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"vx=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--vector-y\" , & switch_ab = \"-vy\" , & help = \"y-component of the vector function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"vy=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--vector-z\" , & switch_ab = \"-vz\" , & help = \"z-component of the vector function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"vz=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-11\" , & switch_ab = \"-t11\" , & help = \"Row 1 column 1 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t11=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-12\" , & switch_ab = \"-t12\" , & help = \"Row 1 column 2 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t12=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-13\" , & switch_ab = \"-t13\" , & help = \"Row 1 column 3 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t13=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-21\" , & switch_ab = \"-t21\" , & help = \"Row 2 column 1 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t21=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-22\" , & switch_ab = \"-t22\" , & help = \"Row 2 column 2 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t22=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-23\" , & switch_ab = \"-t23\" , & help = \"Row 2 column 3 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t23=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-31\" , & switch_ab = \"-t31\" , & help = \"Row 3 column 1 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t31=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-32\" , & switch_ab = \"-t32\" , & help = \"Row 3 column 2 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t32=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-33\" , & switch_ab = \"-t33\" , & help = \"Row 2 column 3 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t33=1.0\" , & required = . FALSE .) CALL cli % add_group ( group = \"ci-test\" , & description = \"Run all CI-Tests\" ) CALL cli % add_group ( group = \"blockmesh_1d\" , & description = \"Block Mesh generation in 1D\" ) CALL cli % add_group ( group = \"blockmesh_2d\" , & description = \"Block Mesh generation in 2D\" ) CALL cli % add_group ( group = \"blockmesh_3d\" , & description = \"Block Mesh generation in 3D\" ) CALL cli % add_group ( group = \"s1d_interp\" , & description = \"Scalar 1D Grid Interpolation\" ) CALL cli % add_group ( group = \"s2d_interp\" , & description = \"Scalar 2D Grid Interpolation\" ) CALL cli % add_group ( group = \"s3d_interp\" , & description = \"Scalar 3D Grid Interpolation\" ) CALL cli % add_group ( group = \"v2d_interp\" , & description = \"Vector 2D Grid Interpolation\" ) CALL cli % add_group ( group = \"v3d_interp\" , & description = \"Vector 3D Grid Interpolation\" ) CALL cli % add_group ( group = \"t2d_interp\" , & description = \"Tensor 2D Grid Interpolation\" ) CALL cli % add_group ( group = \"t3d_interp\" , & description = \"Tensor 3D Grid Interpolation\" ) CALL cli % add_group ( group = \"s1d_binterp\" , & description = \"Scalar 1D Boundary interpolation\" ) CALL cli % add_group ( group = \"s2d_binterp\" , & description = \"Scalar 2D Boundary interpolation\" ) CALL cli % add_group ( group = \"s3d_binterp\" , & description = \"Scalar 3D Boundary interpolation\" ) CALL cli % add_group ( group = \"v2d_binterp\" , & description = \"Vector 2D Boundary interpolation\" ) CALL cli % add_group ( group = \"v3d_binterp\" , & description = \"Vector 3D Boundary interpolation\" ) CALL cli % add_group ( group = \"t2d_binterp\" , & description = \"Tensor 2D Boundary interpolation\" ) CALL cli % add_group ( group = \"t3d_binterp\" , & description = \"Tensor 3D Boundary interpolation\" ) CALL cli % add_group ( group = \"s1d_derivative\" , & description = \"Scalar 1D Derivative\" ) CALL cli % add_group ( group = \"s2d_gradient\" , & description = \"Scalar 2D Gradient\" ) CALL cli % add_group ( group = \"s3d_gradient\" , & description = \"Scalar 3D Gradient\" ) CALL cli % add_group ( group = \"v2d_gradient\" , & description = \"Vector 2D Gradient\" ) CALL cli % add_group ( group = \"v2d_divergence\" , & description = \"Vector 2D Divergence\" ) CALL cli % add_group ( group = \"v2d_curl\" , & description = \"Vector 2D Curl\" ) CALL cli % add_group ( group = \"v3d_gradient\" , & description = \"Vector 3D Gradient\" ) CALL cli % add_group ( group = \"v3d_divergence\" , & description = \"Vector 3D Divergence\" ) CALL cli % add_group ( group = \"v3d_curl\" , & description = \"Vector 3D Curl\" ) CALL cli % parse () END SUBROUTINE Parse_CLI","tags":"","loc":"proc/parse_cli.html"},{"title":"AbsMaxBoundary_Scalar1D – SELF","text":"public function AbsMaxBoundary_Scalar1D(scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar1D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:2) Contents Source Code AbsMaxBoundary_Scalar1D Source Code FUNCTION AbsMaxBoundary_Scalar1D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar1D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar , 1 : 2 ) ! Local INTEGER :: iEl , iVar , iSide absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iSide = 1 , 2 DO iVar = 1 , scalar % nVar absMax ( iVar , iSide ) = MAX ( ABS ( scalar % boundary % hostData ( iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END FUNCTION AbsMaxBoundary_Scalar1D","tags":"","loc":"proc/absmaxboundary_scalar1d.html"},{"title":"AbsMaxBoundary_Scalar2D – SELF","text":"public function AbsMaxBoundary_Scalar2D(scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar2D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:4) Contents Source Code AbsMaxBoundary_Scalar2D Source Code FUNCTION AbsMaxBoundary_Scalar2D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar2D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar , 1 : 4 ) ! Local INTEGER :: iEl , iVar , i , iSide absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iSide = 1 , 4 DO iVar = 1 , scalar % nVar DO i = 0 , scalar % N absMax ( iVar , iSide ) = MAX ( ABS ( scalar % boundary % hostData ( i , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Scalar2D","tags":"","loc":"proc/absmaxboundary_scalar2d.html"},{"title":"AbsMaxBoundary_Scalar3D – SELF","text":"public function AbsMaxBoundary_Scalar3D(scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar3D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:6) Contents Source Code AbsMaxBoundary_Scalar3D Source Code FUNCTION AbsMaxBoundary_Scalar3D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar3D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar , 1 : 6 ) ! Local INTEGER :: iEl , iVar , i , j , iSide absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iSide = 1 , 6 DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N absMax ( iVar , iSide ) = MAX ( ABS ( scalar % boundary % hostData ( i , j , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Scalar3D","tags":"","loc":"proc/absmaxboundary_scalar3d.html"},{"title":"AbsMaxBoundary_Tensor2D – SELF","text":"public function AbsMaxBoundary_Tensor2D(tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor2D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar,1:4) Contents Source Code AbsMaxBoundary_Tensor2D Source Code FUNCTION AbsMaxBoundary_Tensor2D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor2D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar , 1 : 4 ) ! Local INTEGER :: iEl , iVar , i , iSide , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iSide = 1 , 4 DO iVar = 1 , tensor % nVar DO i = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 absMax ( iVar , iSide ) = MAX ( ABS ( tensor % boundary % hostData ( row , col , i , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Tensor2D","tags":"","loc":"proc/absmaxboundary_tensor2d.html"},{"title":"AbsMaxBoundary_Tensor3D – SELF","text":"public function AbsMaxBoundary_Tensor3D(tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor3D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar,1:6) Contents Source Code AbsMaxBoundary_Tensor3D Source Code FUNCTION AbsMaxBoundary_Tensor3D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor3D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar , 1 : 6 ) ! Local INTEGER :: iEl , iVar , i , j , iSide , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iSide = 1 , 6 DO iVar = 1 , tensor % nVar DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 absMax ( iVar , iSide ) = MAX ( ABS ( tensor % boundary % hostData ( row , col , i , j , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Tensor3D","tags":"","loc":"proc/absmaxboundary_tensor3d.html"},{"title":"AbsMaxBoundary_Vector2D – SELF","text":"public function AbsMaxBoundary_Vector2D(vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector2D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar,1:4) Contents Source Code AbsMaxBoundary_Vector2D Source Code FUNCTION AbsMaxBoundary_Vector2D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector2D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar , 1 : 4 ) ! Local INTEGER :: iEl , iVar , i , iDir , iSide absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iSide = 1 , 4 DO iVar = 1 , vector % nVar DO i = 0 , vector % N DO iDir = 1 , 2 absMax ( iVar , iSide ) = MAX ( ABS ( vector % boundary % hostData ( iDir , i , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Vector2D","tags":"","loc":"proc/absmaxboundary_vector2d.html"},{"title":"AbsMaxBoundary_Vector3D – SELF","text":"public function AbsMaxBoundary_Vector3D(vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector3D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar,1:6) Contents Source Code AbsMaxBoundary_Vector3D Source Code FUNCTION AbsMaxBoundary_Vector3D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector3D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar , 1 : 6 ) ! Local INTEGER :: iEl , iVar , i , j , iSide , iDir absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iSide = 1 , 6 DO iVar = 1 , vector % nVar DO j = 0 , vector % N DO i = 0 , vector % N DO iDir = 1 , 3 absMax ( iVar , iSide ) = MAX ( ABS ( vector % boundary % hostData ( iDir , i , j , iVar , iSide , iEl )), absMax ( iVar , iSide )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxBoundary_Vector3D","tags":"","loc":"proc/absmaxboundary_vector3d.html"},{"title":"AbsMaxInterior_Scalar1D – SELF","text":"public function AbsMaxInterior_Scalar1D(scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar1D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) Contents Source Code AbsMaxInterior_Scalar1D Source Code FUNCTION AbsMaxInterior_Scalar1D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar1D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar ) ! Local INTEGER :: iEl , iVar , i absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO i = 0 , scalar % N absMax ( iVar ) = MAX ( ABS ( scalar % interior % hostData ( i , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END FUNCTION AbsMaxInterior_Scalar1D","tags":"","loc":"proc/absmaxinterior_scalar1d.html"},{"title":"AbsMaxInterior_Scalar2D – SELF","text":"public function AbsMaxInterior_Scalar2D(scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar2D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) Contents Source Code AbsMaxInterior_Scalar2D Source Code FUNCTION AbsMaxInterior_Scalar2D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar2D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar ) ! Local INTEGER :: iEl , iVar , i , j absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N absMax ( iVar ) = MAX ( ABS ( scalar % interior % hostData ( i , j , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Scalar2D","tags":"","loc":"proc/absmaxinterior_scalar2d.html"},{"title":"AbsMaxInterior_Scalar3D – SELF","text":"public function AbsMaxInterior_Scalar3D(scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar3D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) Contents Source Code AbsMaxInterior_Scalar3D Source Code FUNCTION AbsMaxInterior_Scalar3D ( scalar ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Scalar3D ) :: scalar REAL ( prec ) :: absMax ( 1 : scalar % nVar ) ! Local INTEGER :: iEl , iVar , i , j , k absMax = 0.0_prec DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N DO i = 0 , scalar % N absMax ( iVar ) = MAX ( ABS ( scalar % interior % hostData ( i , j , k , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Scalar3D","tags":"","loc":"proc/absmaxinterior_scalar3d.html"},{"title":"AbsMaxInterior_Tensor2D – SELF","text":"public function AbsMaxInterior_Tensor2D(tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor2D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar) Contents Source Code AbsMaxInterior_Tensor2D Source Code FUNCTION AbsMaxInterior_Tensor2D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor2D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar ) ! Local INTEGER :: iEl , iVar , i , j , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 absMax ( iVar ) = MAX ( ABS ( tensor % interior % hostData ( row , col , i , j , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Tensor2D","tags":"","loc":"proc/absmaxinterior_tensor2d.html"},{"title":"AbsMaxInterior_Tensor3D – SELF","text":"public function AbsMaxInterior_Tensor3D(tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor3D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar) Contents Source Code AbsMaxInterior_Tensor3D Source Code FUNCTION AbsMaxInterior_Tensor3D ( tensor ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Tensor3D ) :: tensor REAL ( prec ) :: absMax ( 1 : tensor % nVar ) ! Local INTEGER :: iEl , iVar , i , j , k , row , col absMax = 0.0_prec DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO k = 0 , tensor % N DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 absMax ( iVar ) = MAX ( ABS ( tensor % interior % hostData ( row , col , i , j , k , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Tensor3D","tags":"","loc":"proc/absmaxinterior_tensor3d.html"},{"title":"AbsMaxInterior_Vector2D – SELF","text":"public function AbsMaxInterior_Vector2D(vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector2D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar) Contents Source Code AbsMaxInterior_Vector2D Source Code FUNCTION AbsMaxInterior_Vector2D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector2D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar ) ! Local INTEGER :: iEl , iVar , i , j , iDir absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO j = 0 , vector % N DO i = 0 , vector % N DO iDir = 1 , 2 absMax ( iVar ) = MAX ( ABS ( vector % interior % hostData ( iDir , i , j , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Vector2D","tags":"","loc":"proc/absmaxinterior_vector2d.html"},{"title":"AbsMaxInterior_Vector3D – SELF","text":"public function AbsMaxInterior_Vector3D(vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector3D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar) Contents Source Code AbsMaxInterior_Vector3D Source Code FUNCTION AbsMaxInterior_Vector3D ( vector ) RESULT ( absMax ) IMPLICIT NONE CLASS ( Vector3D ) :: vector REAL ( prec ) :: absMax ( 1 : vector % nVar ) ! Local INTEGER :: iEl , iVar , i , j , k , iDir absMax = 0.0_prec DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO k = 0 , vector % N DO j = 0 , vector % N DO i = 0 , vector % N DO iDir = 1 , 3 absMax ( iVar ) = MAX ( ABS ( vector % interior % hostData ( iDir , i , j , k , iVar , iEl )), absMax ( iVar )) END DO END DO END DO END DO END DO END DO END FUNCTION AbsMaxInterior_Vector3D","tags":"","loc":"proc/absmaxinterior_vector3d.html"},{"title":"Add_Scalar1D – SELF","text":"public function Add_Scalar1D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) Contents Source Code Add_Scalar1D Source Code FUNCTION Add_Scalar1D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar1D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Scalar1D","tags":"","loc":"proc/add_scalar1d.html"},{"title":"Add_Scalar2D – SELF","text":"public function Add_Scalar2D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) Contents Source Code Add_Scalar2D Source Code FUNCTION Add_Scalar2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Scalar2D","tags":"","loc":"proc/add_scalar2d.html"},{"title":"Add_Scalar3D – SELF","text":"public function Add_Scalar3D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) Contents Source Code Add_Scalar3D Source Code FUNCTION Add_Scalar3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Scalar3D","tags":"","loc":"proc/add_scalar3d.html"},{"title":"Add_Tensor2D – SELF","text":"public function Add_Tensor2D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) Contents Source Code Add_Tensor2D Source Code FUNCTION Add_Tensor2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Tensor2D","tags":"","loc":"proc/add_tensor2d.html"},{"title":"Add_Tensor3D – SELF","text":"public function Add_Tensor3D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) Contents Source Code Add_Tensor3D Source Code FUNCTION Add_Tensor3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Tensor3D","tags":"","loc":"proc/add_tensor3d.html"},{"title":"Add_Vector2D – SELF","text":"public function Add_Vector2D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) Contents Source Code Add_Vector2D Source Code FUNCTION Add_Vector2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Vector2D","tags":"","loc":"proc/add_vector2d.html"},{"title":"Add_Vector3D – SELF","text":"public function Add_Vector3D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) Contents Source Code Add_Vector3D Source Code FUNCTION Add_Vector3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData + & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData + & SELFb % boundary % hostData END FUNCTION Add_Vector3D","tags":"","loc":"proc/add_vector3d.html"},{"title":"Subtract_Scalar1D – SELF","text":"public function Subtract_Scalar1D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) Contents Source Code Subtract_Scalar1D Source Code FUNCTION Subtract_Scalar1D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar1D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Scalar1D","tags":"","loc":"proc/subtract_scalar1d.html"},{"title":"Subtract_Scalar2D – SELF","text":"public function Subtract_Scalar2D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) Contents Source Code Subtract_Scalar2D Source Code FUNCTION Subtract_Scalar2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Scalar2D","tags":"","loc":"proc/subtract_scalar2d.html"},{"title":"Subtract_Scalar3D – SELF","text":"public function Subtract_Scalar3D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) Contents Source Code Subtract_Scalar3D Source Code FUNCTION Subtract_Scalar3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Scalar3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Scalar3D","tags":"","loc":"proc/subtract_scalar3d.html"},{"title":"Subtract_Tensor2D – SELF","text":"public function Subtract_Tensor2D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) Contents Source Code Subtract_Tensor2D Source Code FUNCTION Subtract_Tensor2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Tensor2D","tags":"","loc":"proc/subtract_tensor2d.html"},{"title":"Subtract_Tensor3D – SELF","text":"public function Subtract_Tensor3D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) Contents Source Code Subtract_Tensor3D Source Code FUNCTION Subtract_Tensor3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Tensor3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Tensor3D","tags":"","loc":"proc/subtract_tensor3d.html"},{"title":"Subtract_Vector2D – SELF","text":"public function Subtract_Vector2D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) Contents Source Code Subtract_Vector2D Source Code FUNCTION Subtract_Vector2D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector2D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Vector2D","tags":"","loc":"proc/subtract_vector2d.html"},{"title":"Subtract_Vector3D – SELF","text":"public function Subtract_Vector3D(SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) Contents Source Code Subtract_Vector3D Source Code FUNCTION Subtract_Vector3D ( SELFa , SELFb ) RESULT ( SELFOut ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFa , SELFb TYPE ( Vector3D ) :: SELFOut CALL SELFOut % Init ( SELFa % N , & SELFa % controlType , & SELFa % M , & SELFa % targetType , & SELFa % nVar , & SELFa % nElem ) SELFOut % interior % hostData = SELFa % interior % hostData - & SELFb % interior % hostData SELFOut % boundary % hostData = SELFa % boundary % hostData - & SELFb % boundary % hostData END FUNCTION Subtract_Vector3D","tags":"","loc":"proc/subtract_vector3d.html"},{"title":"BoundaryInterp_Scalar1D – SELF","text":"public subroutine BoundaryInterp_Scalar1D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Scalar1D Source Code SUBROUTINE BoundaryInterp_Scalar1D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_1D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_1D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar1D","tags":"","loc":"proc/boundaryinterp_scalar1d.html"},{"title":"BoundaryInterp_Scalar2D – SELF","text":"public subroutine BoundaryInterp_Scalar2D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Scalar2D Source Code SUBROUTINE BoundaryInterp_Scalar2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar2D","tags":"","loc":"proc/boundaryinterp_scalar2d.html"},{"title":"BoundaryInterp_Scalar3D – SELF","text":"public subroutine BoundaryInterp_Scalar3D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Scalar3D Source Code SUBROUTINE BoundaryInterp_Scalar3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Scalar3D","tags":"","loc":"proc/boundaryinterp_scalar3d.html"},{"title":"BoundaryInterp_Tensor2D – SELF","text":"public subroutine BoundaryInterp_Tensor2D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Tensor2D Source Code SUBROUTINE BoundaryInterp_Tensor2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Tensor2D","tags":"","loc":"proc/boundaryinterp_tensor2d.html"},{"title":"BoundaryInterp_Tensor3D – SELF","text":"public subroutine BoundaryInterp_Tensor3D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Tensor3D Source Code SUBROUTINE BoundaryInterp_Tensor3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Tensor3D","tags":"","loc":"proc/boundaryinterp_tensor3d.html"},{"title":"BoundaryInterp_Vector2D – SELF","text":"public subroutine BoundaryInterp_Vector2D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Vector2D Source Code SUBROUTINE BoundaryInterp_Vector2D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorBoundaryInterp_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorBoundaryInterp_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Vector2D","tags":"","loc":"proc/boundaryinterp_vector2d.html"},{"title":"BoundaryInterp_Vector3D – SELF","text":"public subroutine BoundaryInterp_Vector3D(SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel Contents Source Code BoundaryInterp_Vector3D Source Code SUBROUTINE BoundaryInterp_Vector3D ( SELFStorage , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorBoundaryInterp_3D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorBoundaryInterp_3D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE BoundaryInterp_Vector3D","tags":"","loc":"proc/boundaryinterp_vector3d.html"},{"title":"Curl_Vector2D – SELF","text":"public subroutine Curl_Vector2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Curl_Vector2D Source Code SUBROUTINE Curl_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorCurl_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorCurl_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Curl_Vector2D","tags":"","loc":"proc/curl_vector2d.html"},{"title":"Curl_Vector3D – SELF","text":"public subroutine Curl_Vector3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Curl_Vector3D Source Code SUBROUTINE Curl_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorCurl_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorCurl_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Curl_Vector3D","tags":"","loc":"proc/curl_vector3d.html"},{"title":"Derivative_Scalar1D – SELF","text":"public subroutine Derivative_Scalar1D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Derivative_Scalar1D Source Code SUBROUTINE Derivative_Scalar1D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar1D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % Derivative_1D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % Derivative_1D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) ENDIF END SUBROUTINE Derivative_Scalar1D","tags":"","loc":"proc/derivative_scalar1d.html"},{"title":"Determinant_Tensor2D – SELF","text":"public subroutine Determinant_Tensor2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Calls proc~~determinant_tensor2d~~CallsGraph proc~determinant_tensor2d Determinant_Tensor2D interface~determinant_tensor2d_gpu_wrapper Determinant_Tensor2D_gpu_wrapper proc~determinant_tensor2d->interface~determinant_tensor2d_gpu_wrapper warning warning proc~determinant_tensor2d->warning Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Determinant_Tensor2D Source Code SUBROUTINE Determinant_Tensor2D ( SELFStorage , SELFout , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"Determinant_Tensor2D\" IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL Determinant_Tensor2D_gpu_wrapper ( SELFStorage % interior % deviceData , & SELFOut % interior % deviceData , & SELFStorage % N , & SELFStorage % nVar , & SELFStorage % nElem ) #else msg = \"GPU Acceleration currently not enabled in SELF\" WARNING ( msg ) #endif ELSE DO iEl = 1 , SELFStorage % nElem DO iVar = 1 , SELFStorage % nVar DO j = 0 , SELFStorage % N DO i = 0 , SELFStorage % N SELFOut % interior % hostData ( i , j , iVar , iEl ) = SELFStorage % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) END DO END DO END DO END DO ENDIF END SUBROUTINE Determinant_Tensor2D","tags":"","loc":"proc/determinant_tensor2d.html"},{"title":"Determinant_Tensor3D – SELF","text":"public subroutine Determinant_Tensor3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Calls proc~~determinant_tensor3d~~CallsGraph proc~determinant_tensor3d Determinant_Tensor3D interface~determinant_tensor3d_gpu_wrapper Determinant_Tensor3D_gpu_wrapper proc~determinant_tensor3d->interface~determinant_tensor3d_gpu_wrapper warning warning proc~determinant_tensor3d->warning Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Determinant_Tensor3D Source Code SUBROUTINE Determinant_Tensor3D ( SELFStorage , SELFOut , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"Determinant_Tensor3D\" IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL Determinant_Tensor3D_gpu_wrapper ( SELFStorage % interior % deviceData , & SELFOut % interior % deviceData , & SELFStorage % N , & SELFStorage % nVar , & SELFStorage % nElem ) #else msg = \"GPU Acceleration currently not enabled in SELF\" WARNING ( msg ) #endif ELSE DO iEl = 1 , SELFStorage % nElem DO iVar = 1 , SELFStorage % nVar DO k = 0 , SELFStorage % N DO j = 0 , SELFStorage % N DO i = 0 , SELFStorage % N SELFOut % interior % hostData ( i , j , k , iVar , iEl ) = & SELFStorage % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl )) - & SELFStorage % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl )) + & SELFStorage % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) * & ( SELFStorage % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) - & SELFStorage % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) * & SELFStorage % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl )) END DO END DO END DO END DO END DO ENDIF END SUBROUTINE Determinant_Tensor3D","tags":"","loc":"proc/determinant_tensor3d.html"},{"title":"Divergence_Tensor2D – SELF","text":"public subroutine Divergence_Tensor2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Divergence_Tensor2D Source Code SUBROUTINE Divergence_Tensor2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorDivergence_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorDivergence_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Divergence_Tensor2D","tags":"","loc":"proc/divergence_tensor2d.html"},{"title":"Divergence_Tensor3D – SELF","text":"public subroutine Divergence_Tensor3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Divergence_Tensor3D Source Code SUBROUTINE Divergence_Tensor3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorDivergence_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorDivergence_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Divergence_Tensor3D","tags":"","loc":"proc/divergence_tensor3d.html"},{"title":"Divergence_Vector2D – SELF","text":"public subroutine Divergence_Vector2D(SELFStorage, SELFOut, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Divergence_Vector2D Source Code SUBROUTINE Divergence_Vector2D ( SELFStorage , SELFOut , dForm , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDGDivergence_2D ( SELFStorage % interior % deviceData , & SELFStorage % boundary % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDGDivergence_2D ( SELFStorage % interior % hostData , & SELFStorage % boundary % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDivergence_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDivergence_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END IF END SUBROUTINE Divergence_Vector2D","tags":"","loc":"proc/divergence_vector2d.html"},{"title":"Divergence_Vector3D – SELF","text":"public subroutine Divergence_Vector3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Divergence_Vector3D Source Code SUBROUTINE Divergence_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorDivergence_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorDivergence_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Divergence_Vector3D","tags":"","loc":"proc/divergence_vector3d.html"},{"title":"Equals_Scalar1D – SELF","text":"public subroutine Equals_Scalar1D(SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFOut type( Scalar1D ), intent(in) :: SELFin Contents Source Code Equals_Scalar1D Source Code SUBROUTINE Equals_Scalar1D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFOut TYPE ( Scalar1D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Scalar1D","tags":"","loc":"proc/equals_scalar1d.html"},{"title":"Equals_Scalar2D – SELF","text":"public subroutine Equals_Scalar2D(SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFOut type( Scalar2D ), intent(in) :: SELFin Contents Source Code Equals_Scalar2D Source Code SUBROUTINE Equals_Scalar2D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFOut TYPE ( Scalar2D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Scalar2D","tags":"","loc":"proc/equals_scalar2d.html"},{"title":"Equals_Scalar3D – SELF","text":"public subroutine Equals_Scalar3D(SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFOut type( Scalar3D ), intent(in) :: SELFin Contents Source Code Equals_Scalar3D Source Code SUBROUTINE Equals_Scalar3D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFOut TYPE ( Scalar3D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Scalar3D","tags":"","loc":"proc/equals_scalar3d.html"},{"title":"Equals_Tensor2D – SELF","text":"public subroutine Equals_Tensor2D(SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFOut type( Tensor2D ), intent(in) :: SELFin Contents Source Code Equals_Tensor2D Source Code SUBROUTINE Equals_Tensor2D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFOut TYPE ( Tensor2D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Tensor2D","tags":"","loc":"proc/equals_tensor2d.html"},{"title":"Equals_Tensor3D – SELF","text":"public subroutine Equals_Tensor3D(SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFOut type( Tensor3D ), intent(in) :: SELFin Contents Source Code Equals_Tensor3D Source Code SUBROUTINE Equals_Tensor3D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFOut TYPE ( Tensor3D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Tensor3D","tags":"","loc":"proc/equals_tensor3d.html"},{"title":"Equals_Vector2D – SELF","text":"public subroutine Equals_Vector2D(SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFOut type( Vector2D ), intent(in) :: SELFin Contents Source Code Equals_Vector2D Source Code SUBROUTINE Equals_Vector2D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFOut TYPE ( Vector2D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Vector2D","tags":"","loc":"proc/equals_vector2d.html"},{"title":"Equals_Vector3D – SELF","text":"public subroutine Equals_Vector3D(SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFOut type( Vector3D ), intent(in) :: SELFin Contents Source Code Equals_Vector3D Source Code SUBROUTINE Equals_Vector3D ( SELFOut , SELFin ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFOut TYPE ( Vector3D ), INTENT ( in ) :: SELFin SELFOut % interior % hostData = SELFin % interior % hostData SELFOut % boundary % hostData = SELFin % boundary % hostData END SUBROUTINE Equals_Vector3D","tags":"","loc":"proc/equals_vector3d.html"},{"title":"Free_Scalar1D – SELF","text":"public subroutine Free_Scalar1D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage Contents Source Code Free_Scalar1D Source Code SUBROUTINE Free_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () END SUBROUTINE Free_Scalar1D","tags":"","loc":"proc/free_scalar1d.html"},{"title":"Free_Scalar2D – SELF","text":"public subroutine Free_Scalar2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage Contents Source Code Free_Scalar2D Source Code SUBROUTINE Free_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () END SUBROUTINE Free_Scalar2D","tags":"","loc":"proc/free_scalar2d.html"},{"title":"Free_Scalar3D – SELF","text":"public subroutine Free_Scalar3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage Contents Source Code Free_Scalar3D Source Code SUBROUTINE Free_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () END SUBROUTINE Free_Scalar3D","tags":"","loc":"proc/free_scalar3d.html"},{"title":"Free_Tensor2D – SELF","text":"public subroutine Free_Tensor2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage Contents Source Code Free_Tensor2D Source Code SUBROUTINE Free_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () END SUBROUTINE Free_Tensor2D","tags":"","loc":"proc/free_tensor2d.html"},{"title":"Free_Tensor3D – SELF","text":"public subroutine Free_Tensor3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage Contents Source Code Free_Tensor3D Source Code SUBROUTINE Free_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () END SUBROUTINE Free_Tensor3D","tags":"","loc":"proc/free_tensor3d.html"},{"title":"Free_Vector2D – SELF","text":"public subroutine Free_Vector2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage Contents Source Code Free_Vector2D Source Code SUBROUTINE Free_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () END SUBROUTINE Free_Vector2D","tags":"","loc":"proc/free_vector2d.html"},{"title":"Free_Vector3D – SELF","text":"public subroutine Free_Vector3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage Contents Source Code Free_Vector3D Source Code SUBROUTINE Free_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage SELFStorage % N = 0 SELFStorage % nVar = 0 SELFStorage % nElem = 0 CALL SELFStorage % interp % Free () CALL SELFStorage % interior % Free () CALL SELFStorage % boundary % Free () END SUBROUTINE Free_Vector3D","tags":"","loc":"proc/free_vector3d.html"},{"title":"Gradient_Scalar2D – SELF","text":"public subroutine Gradient_Scalar2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Gradient_Scalar2D Source Code SUBROUTINE Gradient_Scalar2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGradient_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGradient_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Scalar2D","tags":"","loc":"proc/gradient_scalar2d.html"},{"title":"Gradient_Scalar3D – SELF","text":"public subroutine Gradient_Scalar3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Gradient_Scalar3D Source Code SUBROUTINE Gradient_Scalar3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGradient_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGradient_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Scalar3D","tags":"","loc":"proc/gradient_scalar3d.html"},{"title":"Gradient_Vector2D – SELF","text":"public subroutine Gradient_Vector2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Gradient_Vector2D Source Code SUBROUTINE Gradient_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGradient_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGradient_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Vector2D","tags":"","loc":"proc/gradient_vector2d.html"},{"title":"Gradient_Vector3D – SELF","text":"public subroutine Gradient_Vector3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code Gradient_Vector3D Source Code SUBROUTINE Gradient_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGradient_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGradient_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE Gradient_Vector3D","tags":"","loc":"proc/gradient_vector3d.html"},{"title":"GridInterp_Scalar1D – SELF","text":"public subroutine GridInterp_Scalar1D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Scalar1D Source Code SUBROUTINE GridInterp_Scalar1D ( SELFStorage , SELFout , gpuAccel ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar1D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_1D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_1D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar1D","tags":"","loc":"proc/gridinterp_scalar1d.html"},{"title":"GridInterp_Scalar2D – SELF","text":"public subroutine GridInterp_Scalar2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Scalar2D Source Code SUBROUTINE GridInterp_Scalar2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar2D","tags":"","loc":"proc/gridinterp_scalar2d.html"},{"title":"GridInterp_Scalar3D – SELF","text":"public subroutine GridInterp_Scalar3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Scalar3D Source Code SUBROUTINE GridInterp_Scalar3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( in ) :: SELFStorage TYPE ( Scalar3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % ScalarGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % ScalarGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Scalar3D","tags":"","loc":"proc/gridinterp_scalar3d.html"},{"title":"GridInterp_Tensor2D – SELF","text":"public subroutine GridInterp_Tensor2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Tensor2D Source Code SUBROUTINE GridInterp_Tensor2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Tensor2D","tags":"","loc":"proc/gridinterp_tensor2d.html"},{"title":"GridInterp_Tensor3D – SELF","text":"public subroutine GridInterp_Tensor3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Tensor3D Source Code SUBROUTINE GridInterp_Tensor3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( in ) :: SELFStorage TYPE ( Tensor3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % TensorGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % TensorGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Tensor3D","tags":"","loc":"proc/gridinterp_tensor3d.html"},{"title":"GridInterp_Vector2D – SELF","text":"public subroutine GridInterp_Vector2D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Vector2D Source Code SUBROUTINE GridInterp_Vector2D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( in ) :: SELFStorage TYPE ( Vector2D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGridInterp_2D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGridInterp_2D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Vector2D","tags":"","loc":"proc/gridinterp_vector2d.html"},{"title":"GridInterp_Vector3D – SELF","text":"public subroutine GridInterp_Vector3D(SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel Contents Source Code GridInterp_Vector3D Source Code SUBROUTINE GridInterp_Vector3D ( SELFStorage , SELFOut , gpuAccel ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( in ) :: SELFStorage TYPE ( Vector3D ), INTENT ( inout ) :: SELFOut LOGICAL , INTENT ( in ) :: gpuAccel IF ( gpuAccel ) THEN CALL SELFStorage % interp % VectorGridInterp_3D ( SELFStorage % interior % deviceData , & SELFout % interior % deviceData , & SELFStorage % nVar , & SELFStorage % nElem ) ELSE CALL SELFStorage % interp % VectorGridInterp_3D ( SELFStorage % interior % hostData , & SELFout % interior % hostData , & SELFStorage % nVar , & SELFStorage % nElem ) END IF END SUBROUTINE GridInterp_Vector3D","tags":"","loc":"proc/gridinterp_vector3d.html"},{"title":"Init_Scalar1D – SELF","text":"public subroutine Init_Scalar1D(SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar1D Source Code SUBROUTINE Init_Scalar1D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 1 , 1 / ), & upBound = ( / N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 1 / ), & upBound = ( / nVar , 2 , nElem / )) END SUBROUTINE Init_Scalar1D","tags":"","loc":"proc/init_scalar1d.html"},{"title":"Init_Scalar2D – SELF","text":"public subroutine Init_Scalar2D(SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar2D Source Code SUBROUTINE Init_Scalar2D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 0 , 1 , 1 / ), & upBound = ( / N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 0 , 1 , 1 , 1 / ), & upBound = ( / N , nVar , 4 , nElem / )) END SUBROUTINE Init_Scalar2D","tags":"","loc":"proc/init_scalar2d.html"},{"title":"Init_Scalar3D – SELF","text":"public subroutine Init_Scalar3D(SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Scalar3D Source Code SUBROUTINE Init_Scalar3D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / N , N , nVar , 6 , nElem / )) END SUBROUTINE Init_Scalar3D","tags":"","loc":"proc/init_scalar3d.html"},{"title":"Init_Tensor2D – SELF","text":"public subroutine Init_Tensor2D(SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Tensor2D Source Code SUBROUTINE Init_Tensor2D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , 2 , N , nVar , 4 , nElem / )) END SUBROUTINE Init_Tensor2D","tags":"","loc":"proc/init_tensor2d.html"},{"title":"Init_Tensor3D – SELF","text":"public subroutine Init_Tensor3D(SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Tensor3D Source Code SUBROUTINE Init_Tensor3D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , 3 , N , N , nVar , 6 , nElem / )) END SUBROUTINE Init_Tensor3D","tags":"","loc":"proc/init_tensor3d.html"},{"title":"Init_Vector2D – SELF","text":"public subroutine Init_Vector2D(SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Vector2D Source Code SUBROUTINE Init_Vector2D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 / ), & upBound = ( / 2 , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 0 , 1 , 1 , 1 / ), & upBound = ( / 2 , N , nVar , 4 , nElem / )) END SUBROUTINE Init_Vector2D","tags":"","loc":"proc/init_vector2d.html"},{"title":"Init_Vector3D – SELF","text":"public subroutine Init_Vector3D(SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem Contents Source Code Init_Vector3D Source Code SUBROUTINE Init_Vector3D ( SELFStorage , N , quadratureType , M , targetNodeType , nVar , nElem ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( out ) :: SELFStorage INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: quadratureType INTEGER , INTENT ( in ) :: M INTEGER , INTENT ( in ) :: targetNodeType INTEGER , INTENT ( in ) :: nVar INTEGER , INTENT ( in ) :: nElem SELFStorage % N = N SELFStorage % M = M SELFStorage % nVar = nVar SELFStorage % nElem = nElem SELFStorage % controlType = quadratureType SELFStorage % targetType = targetNodeType CALL SELFStorage % interp % Init ( N = N , & controlNodeType = quadratureType , & M = M , & targetNodeType = targetNodeType ) CALL SELFStorage % interior % Alloc ( loBound = ( / 1 , 0 , 0 , 0 , 1 , 1 / ), & upBound = ( / 3 , N , N , N , nVar , nElem / )) CALL SELFStorage % boundary % Alloc ( loBound = ( / 1 , 0 , 0 , 1 , 1 , 1 / ), & upBound = ( / 3 , N , N , nVar , 6 , nElem / )) END SUBROUTINE Init_Vector3D","tags":"","loc":"proc/init_vector3d.html"},{"title":"UpdateDevice_Scalar1D – SELF","text":"public subroutine UpdateDevice_Scalar1D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Scalar1D Source Code SUBROUTINE UpdateDevice_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Scalar1D","tags":"","loc":"proc/updatedevice_scalar1d.html"},{"title":"UpdateDevice_Scalar2D – SELF","text":"public subroutine UpdateDevice_Scalar2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Scalar2D Source Code SUBROUTINE UpdateDevice_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Scalar2D","tags":"","loc":"proc/updatedevice_scalar2d.html"},{"title":"UpdateDevice_Scalar3D – SELF","text":"public subroutine UpdateDevice_Scalar3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Scalar3D Source Code SUBROUTINE UpdateDevice_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Scalar3D","tags":"","loc":"proc/updatedevice_scalar3d.html"},{"title":"UpdateDevice_Tensor2D – SELF","text":"public subroutine UpdateDevice_Tensor2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Tensor2D Source Code SUBROUTINE UpdateDevice_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Tensor2D","tags":"","loc":"proc/updatedevice_tensor2d.html"},{"title":"UpdateDevice_Tensor3D – SELF","text":"public subroutine UpdateDevice_Tensor3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Tensor3D Source Code SUBROUTINE UpdateDevice_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Tensor3D","tags":"","loc":"proc/updatedevice_tensor3d.html"},{"title":"UpdateDevice_Vector2D – SELF","text":"public subroutine UpdateDevice_Vector2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Vector2D Source Code SUBROUTINE UpdateDevice_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Vector2D","tags":"","loc":"proc/updatedevice_vector2d.html"},{"title":"UpdateDevice_Vector3D – SELF","text":"public subroutine UpdateDevice_Vector3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage Contents Source Code UpdateDevice_Vector3D Source Code SUBROUTINE UpdateDevice_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateDevice () CALL SELFStorage % interior % UpdateDevice () CALL SELFStorage % boundary % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Vector3D","tags":"","loc":"proc/updatedevice_vector3d.html"},{"title":"UpdateHost_Scalar1D – SELF","text":"public subroutine UpdateHost_Scalar1D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Scalar1D Source Code SUBROUTINE UpdateHost_Scalar1D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar1D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () #endif END SUBROUTINE UpdateHost_Scalar1D","tags":"","loc":"proc/updatehost_scalar1d.html"},{"title":"UpdateHost_Scalar2D – SELF","text":"public subroutine UpdateHost_Scalar2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Scalar2D Source Code SUBROUTINE UpdateHost_Scalar2D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar2D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () #endif END SUBROUTINE UpdateHost_Scalar2D","tags":"","loc":"proc/updatehost_scalar2d.html"},{"title":"UpdateHost_Scalar3D – SELF","text":"public subroutine UpdateHost_Scalar3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Scalar3D Source Code SUBROUTINE UpdateHost_Scalar3D ( SELFStorage ) IMPLICIT NONE CLASS ( Scalar3D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () #endif END SUBROUTINE UpdateHost_Scalar3D","tags":"","loc":"proc/updatehost_scalar3d.html"},{"title":"UpdateHost_Tensor2D – SELF","text":"public subroutine UpdateHost_Tensor2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Tensor2D Source Code SUBROUTINE UpdateHost_Tensor2D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor2D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () #endif END SUBROUTINE UpdateHost_Tensor2D","tags":"","loc":"proc/updatehost_tensor2d.html"},{"title":"UpdateHost_Tensor3D – SELF","text":"public subroutine UpdateHost_Tensor3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Tensor3D Source Code SUBROUTINE UpdateHost_Tensor3D ( SELFStorage ) IMPLICIT NONE CLASS ( Tensor3D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () #endif END SUBROUTINE UpdateHost_Tensor3D","tags":"","loc":"proc/updatehost_tensor3d.html"},{"title":"UpdateHost_Vector2D – SELF","text":"public subroutine UpdateHost_Vector2D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Vector2D Source Code SUBROUTINE UpdateHost_Vector2D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector2D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () #endif END SUBROUTINE UpdateHost_Vector2D","tags":"","loc":"proc/updatehost_vector2d.html"},{"title":"UpdateHost_Vector3D – SELF","text":"public subroutine UpdateHost_Vector3D(SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage Contents Source Code UpdateHost_Vector3D Source Code SUBROUTINE UpdateHost_Vector3D ( SELFStorage ) IMPLICIT NONE CLASS ( Vector3D ), INTENT ( inout ) :: SELFStorage #ifdef GPU CALL SELFStorage % interp % UpdateHost () CALL SELFStorage % interior % UpdateHost () CALL SELFStorage % boundary % UpdateHost () #endif END SUBROUTINE UpdateHost_Vector3D","tags":"","loc":"proc/updatehost_vector3d.html"},{"title":"Determinant_Tensor2D_gpu_wrapper – SELF","text":"interface Called by interface~~determinant_tensor2d_gpu_wrapper~~CalledByGraph interface~determinant_tensor2d_gpu_wrapper Determinant_Tensor2D_gpu_wrapper proc~determinant_tensor2d Determinant_Tensor2D proc~determinant_tensor2d->interface~determinant_tensor2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine Determinant_Tensor2D_gpu_wrapper(tensor_dev, detTensor_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor_dev type(c_ptr) :: detTensor_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/determinant_tensor2d_gpu_wrapper.html"},{"title":"Determinant_Tensor3D_gpu_wrapper – SELF","text":"interface Called by interface~~determinant_tensor3d_gpu_wrapper~~CalledByGraph interface~determinant_tensor3d_gpu_wrapper Determinant_Tensor3D_gpu_wrapper proc~determinant_tensor3d Determinant_Tensor3D proc~determinant_tensor3d->interface~determinant_tensor3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine Determinant_Tensor3D_gpu_wrapper(tensor_dev, detTensor_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor_dev type(c_ptr) :: detTensor_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/determinant_tensor3d_gpu_wrapper.html"},{"title":"CalculateContravariantBasis_SEMHex – SELF","text":"public subroutine CalculateContravariantBasis_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Calls proc~~calculatecontravariantbasis_semhex~~CallsGraph proc~calculatecontravariantbasis_semhex CalculateContravariantBasis_SEMHex interface~adjustboundarycontravariantbasis_semhex_gpu_wrapper AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper proc~calculatecontravariantbasis_semhex->interface~adjustboundarycontravariantbasis_semhex_gpu_wrapper interface~calculatecontravariantbasis_semhex_gpu_wrapper CalculateContravariantBasis_SEMHex_gpu_wrapper proc~calculatecontravariantbasis_semhex->interface~calculatecontravariantbasis_semhex_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code CalculateContravariantBasis_SEMHex Source Code SUBROUTINE CalculateContravariantBasis_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom ! Local INTEGER :: iEl , i , j , k REAL ( prec ) :: fac #ifdef GPU CALL CalculateContravariantBasis_SEMHex_gpu_wrapper ( myGeom % dxds % interior % deviceData , & myGeom % dsdx % interior % deviceData , & myGeom % dxds % N , & myGeom % dxds % nElem ) ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . TRUE .) CALL AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper ( myGeom % dsdx % boundary % deviceData , & myGeom % J % boundary % deviceData , & myGeom % J % N , & myGeom % J % nElem ) #else ! Now calculate the contravariant basis vectors ! In this convention, dsdx(j,i) is contravariant vector i, component j ! To project onto contravariant vector i, dot vector along the first dimension DO iEl = 1 , myGeom % nElem DO k = 0 , myGeom % dxds % N DO j = 0 , myGeom % dxds % N DO i = 0 , myGeom % dxds % N ! Ja1 myGeom % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) ! Ja2 myGeom % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) ! Ja3 myGeom % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) myGeom % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) = & myGeom % dxds % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) - & myGeom % dxds % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & myGeom % dxds % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) END DO END DO END DO END DO ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . FALSE .) ! Now, modify the sign of dsdx so that ! myGeom % dsdx % boundary is equal to the outward pointing normal vector DO iEl = 1 , myGeom % nElem DO k = 1 , 6 DO j = 0 , myGeom % J % N DO i = 0 , myGeom % J % N IF ( k == selfSide3D_Top . OR . k == selfSide3D_East . OR . k == selfSide3D_North ) THEN fac = SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , j , 1 , k , iEl )) ELSE fac = - SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , j , 1 , k , iEl )) END IF myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 3 , 1 : 3 , i , j , 1 , k , iEl ) END DO END DO END DO END DO #endif END SUBROUTINE CalculateContravariantBasis_SEMHex","tags":"","loc":"proc/calculatecontravariantbasis_semhex.html"},{"title":"CalculateContravariantBasis_SEMQuad – SELF","text":"public subroutine CalculateContravariantBasis_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Calls proc~~calculatecontravariantbasis_semquad~~CallsGraph proc~calculatecontravariantbasis_semquad CalculateContravariantBasis_SEMQuad interface~adjustboundarycontravariantbasis_semquad_gpu_wrapper AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper proc~calculatecontravariantbasis_semquad->interface~adjustboundarycontravariantbasis_semquad_gpu_wrapper interface~calculatecontravariantbasis_semquad_gpu_wrapper CalculateContravariantBasis_SEMQuad_gpu_wrapper proc~calculatecontravariantbasis_semquad->interface~calculatecontravariantbasis_semquad_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code CalculateContravariantBasis_SEMQuad Source Code SUBROUTINE CalculateContravariantBasis_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom ! Local INTEGER :: iEl , i , j , k REAL ( prec ) :: fac #ifdef GPU CALL CalculateContravariantBasis_SEMQuad_gpu_wrapper ( myGeom % dxds % interior % deviceData , & myGeom % dsdx % interior % deviceData , & myGeom % dxds % N , & myGeom % dxds % nElem ) ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . TRUE .) CALL AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper ( myGeom % dsdx % boundary % deviceData , & myGeom % J % boundary % deviceData , & myGeom % J % N , & myGeom % J % nElem ) #else ! Now calculate the contravariant basis vectors ! In this convention, dsdx(j,i) is contravariant vector i, component j ! To project onto contravariant vector i, dot vector along the first dimension DO iEl = 1 , myGeom % nElem DO j = 0 , myGeom % dxds % N DO i = 0 , myGeom % dxds % N myGeom % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iEl ) = myGeom % dxds % interior % hostData ( 2 , 2 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iEl ) = - myGeom % dxds % interior % hostData ( 1 , 2 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iEl ) = - myGeom % dxds % interior % hostData ( 2 , 1 , i , j , 1 , iEl ) myGeom % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iEl ) = myGeom % dxds % interior % hostData ( 1 , 1 , i , j , 1 , iEl ) END DO END DO END DO ! Interpolate the contravariant tensor to the boundaries CALL myGeom % dsdx % BoundaryInterp ( gpuAccel = . FALSE .) ! Now, modify the sign of dsdx so that ! myGeom % dsdx % boundary is equal to the outward pointing normal vector DO iEl = 1 , myGeom % nElem DO k = 1 , 4 DO i = 0 , myGeom % J % N IF ( k == selfSide2D_East . OR . k == selfSide2D_North ) THEN fac = SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , 1 , k , iEl )) ELSE fac = - SIGN ( 1.0_prec , myGeom % J % boundary % hostData ( i , 1 , k , iEl )) END IF myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 : 2 , i , 1 , k , iEl ) = & fac * myGeom % dsdx % boundary % hostData ( 1 : 2 , 1 : 2 , i , 1 , k , iEl ) END DO END DO END DO #endif END SUBROUTINE CalculateContravariantBasis_SEMQuad","tags":"","loc":"proc/calculatecontravariantbasis_semquad.html"},{"title":"CalculateMetricTerms_Geometry1D – SELF","text":"public subroutine CalculateMetricTerms_Geometry1D(myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Contents Source Code CalculateMetricTerms_Geometry1D Source Code SUBROUTINE CalculateMetricTerms_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % Derivative ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % UpdateDevice () END SUBROUTINE CalculateMetricTerms_Geometry1D","tags":"","loc":"proc/calculatemetricterms_geometry1d.html"},{"title":"CalculateMetricTerms_SEMHex – SELF","text":"public subroutine CalculateMetricTerms_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code CalculateMetricTerms_SEMHex Source Code SUBROUTINE CalculateMetricTerms_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . TRUE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . TRUE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . TRUE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . TRUE .) CALL myGeom % CalculateContravariantBasis () #else CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . FALSE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateContravariantBasis () #endif END SUBROUTINE CalculateMetricTerms_SEMHex","tags":"","loc":"proc/calculatemetricterms_semhex.html"},{"title":"CalculateMetricTerms_SEMQuad – SELF","text":"public subroutine CalculateMetricTerms_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code CalculateMetricTerms_SEMQuad Source Code SUBROUTINE CalculateMetricTerms_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . TRUE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . TRUE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . TRUE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . TRUE .) CALL myGeom % CalculateContravariantBasis () #else CALL myGeom % x % Gradient ( myGeom % dxds , gpuAccel = . FALSE .) CALL myGeom % dxds % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % dxds % Determinant ( myGeom % J , gpuAccel = . FALSE .) CALL myGeom % J % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateContravariantBasis () #endif END SUBROUTINE CalculateMetricTerms_SEMQuad","tags":"","loc":"proc/calculatemetricterms_semquad.html"},{"title":"Free_Geometry1D – SELF","text":"public subroutine Free_Geometry1D(myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Contents Source Code Free_Geometry1D Source Code SUBROUTINE Free_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () END SUBROUTINE Free_Geometry1D","tags":"","loc":"proc/free_geometry1d.html"},{"title":"Free_SEMHex – SELF","text":"public subroutine Free_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code Free_SEMHex Source Code SUBROUTINE Free_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () CALL myGeom % dsdx % Free () CALL myGeom % J % Free () END SUBROUTINE Free_SEMHex","tags":"","loc":"proc/free_semhex.html"},{"title":"Free_SEMQuad – SELF","text":"public subroutine Free_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code Free_SEMQuad Source Code SUBROUTINE Free_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom CALL myGeom % x % Free () CALL myGeom % dxds % Free () CALL myGeom % dsdx % Free () CALL myGeom % J % Free () END SUBROUTINE Free_SEMQuad","tags":"","loc":"proc/free_semquad.html"},{"title":"GenerateFromMesh_Geometry1D – SELF","text":"public subroutine GenerateFromMesh_Geometry1D(myGeom, mesh, cqType, tqType, cqDegree, tqDegree) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom type(Mesh1D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree Contents Source Code GenerateFromMesh_Geometry1D Source Code SUBROUTINE GenerateFromMesh_Geometry1D ( myGeom , mesh , cqType , tqType , cqDegree , tqDegree ) ! Generates the geometry for a 1-D mesh ( set of line segments ) ! Assumes that mesh is using Gauss-Lobatto quadrature and the degree is given by mesh % nGeo IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( out ) :: myGeom TYPE ( Mesh1D ), INTENT ( in ) :: mesh INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree ! Local INTEGER :: iel , i , nid TYPE ( Scalar1D ) :: xMesh CALL myGeom % Init ( cqType , tqType , cqDegree , tqDegree , mesh % nElem ) ! Create a scalar1D class to map from nGeo,Gauss-Lobatto grid to ! cqDegree, cqType grid CALL xMesh % Init ( mesh % nGeo , GAUSS_LOBATTO , & cqDegree , cqType , & 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 DO iel = 1 , mesh % nElem DO i = 0 , mesh % nGeo xMesh % interior % hostData ( i , 1 , iel ) = mesh % nodeCoords % hostData ( nid ) nid = nid + 1 END DO END DO ! Interpolate from the mesh nodeCoords to the geometry (Possibly not gauss_lobatto quadrature) CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () CALL myGeom % UpdateDevice () CALL xMesh % Free () END SUBROUTINE GenerateFromMesh_Geometry1D","tags":"","loc":"proc/generatefrommesh_geometry1d.html"},{"title":"GenerateFromMesh_SEMHex – SELF","text":"public subroutine GenerateFromMesh_SEMHex(myGeom, mesh, cqType, tqType, cqDegree, tqDegree) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom type(Mesh3D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree Contents Source Code GenerateFromMesh_SEMHex Source Code SUBROUTINE GenerateFromMesh_SEMHex ( myGeom , mesh , cqType , tqType , cqDegree , tqDegree ) ! Assumes that !  * mesh is using Gauss-Lobatto quadrature !  * the degree is given by mesh % nGeo !  * mesh only has quadrilateral elements ! IMPLICIT NONE CLASS ( SEMHex ), INTENT ( out ) :: myGeom TYPE ( Mesh3D ), INTENT ( in ) :: mesh INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree ! Local INTEGER :: iel , jel , kel , elid INTEGER :: i , j , k , nid TYPE ( Vector3D ) :: xMesh CALL myGeom % Init ( cqType , tqType , cqDegree , tqDegree , mesh % nElem ) ! Create a scalar1D class to map from nGeo,Gauss-Lobatto grid to ! cqDegree, cqType grid CALL xMesh % Init ( mesh % nGeo , GAUSS_LOBATTO , & cqDegree , cqType , & 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 DO iel = 1 , mesh % nElem DO k = 0 , mesh % nGeo DO j = 0 , mesh % nGeo DO i = 0 , mesh % nGeo xMesh % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) = mesh % nodeCoords % hostData ( 1 : 3 , nid ) nid = nid + 1 END DO END DO END DO END DO ! Interpolate from the mesh nodeCoords to the geometry (Possibly not gauss_lobatto quadrature) CALL xMesh % UpdateDevice () #ifdef GPU CALL xMesh % GridInterp ( myGeom % x ,. TRUE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . TRUE .) CALL myGeom % CalculateMetricTerms () CALL myGeom % UpdateHost () #else CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () #endif CALL xMesh % Free () END SUBROUTINE GenerateFromMesh_SEMHex","tags":"","loc":"proc/generatefrommesh_semhex.html"},{"title":"GenerateFromMesh_SEMQuad – SELF","text":"public subroutine GenerateFromMesh_SEMQuad(myGeom, mesh, cqType, tqType, cqDegree, tqDegree) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom type(Mesh2D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree Contents Source Code GenerateFromMesh_SEMQuad Source Code SUBROUTINE GenerateFromMesh_SEMQuad ( myGeom , mesh , cqType , tqType , cqDegree , tqDegree ) ! Assumes that !  * mesh is using Gauss-Lobatto quadrature !  * the degree is given by mesh % nGeo !  * mesh only has quadrilateral elements ! IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( out ) :: myGeom TYPE ( Mesh2D ), INTENT ( in ) :: mesh INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree ! Local INTEGER :: iel , jel , elid INTEGER :: i , j , nid TYPE ( Vector2D ) :: xMesh CALL myGeom % Init ( cqType , tqType , cqDegree , tqDegree , mesh % nElem ) ! Create a scalar1D class to map from nGeo,Gauss-Lobatto grid to ! cqDegree, cqType grid CALL xMesh % Init ( mesh % nGeo , GAUSS_LOBATTO , & cqDegree , cqType , & 1 , mesh % nElem ) ! Set the element internal mesh locations nid = 1 DO iel = 1 , mesh % nElem DO j = 0 , mesh % nGeo DO i = 0 , mesh % nGeo xMesh % interior % hostData ( 1 : 2 , i , j , 1 , iel ) = mesh % nodeCoords % hostData ( 1 : 2 , nid ) nid = nid + 1 END DO END DO END DO #ifdef GPU CALL xMesh % UpdateDevice () CALL xMesh % GridInterp ( myGeom % x ,. TRUE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . TRUE .) CALL myGeom % CalculateMetricTerms () CALL myGeom % UpdateHost () #else CALL xMesh % GridInterp ( myGeom % x ,. FALSE .) CALL myGeom % x % BoundaryInterp ( gpuAccel = . FALSE .) CALL myGeom % CalculateMetricTerms () #endif CALL xMesh % Free () END SUBROUTINE GenerateFromMesh_SEMQuad","tags":"","loc":"proc/generatefrommesh_semquad.html"},{"title":"Init_Geometry1D – SELF","text":"public subroutine Init_Geometry1D(myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem Contents Source Code Init_Geometry1D Source Code SUBROUTINE Init_Geometry1D ( myGeom , cqType , tqType , cqDegree , tqDegree , nElem ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( out ) :: myGeom INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem myGeom % cqType = cqType myGeom % tqType = tqType myGeom % nElem = nElem CALL myGeom % x % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_Geometry1D","tags":"","loc":"proc/init_geometry1d.html"},{"title":"Init_SEMHex – SELF","text":"public subroutine Init_SEMHex(myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem Contents Source Code Init_SEMHex Source Code SUBROUTINE Init_SEMHex ( myGeom , cqType , tqType , cqDegree , tqDegree , nElem ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( out ) :: myGeom INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem myGeom % cqType = cqType myGeom % tqType = tqType myGeom % nElem = nElem CALL myGeom % x % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dsdx % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % J % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_SEMHex","tags":"","loc":"proc/init_semhex.html"},{"title":"Init_SEMQuad – SELF","text":"public subroutine Init_SEMQuad(myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem Contents Source Code Init_SEMQuad Source Code SUBROUTINE Init_SEMQuad ( myGeom , cqType , tqType , cqDegree , tqDegree , nElem ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( out ) :: myGeom INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem myGeom % cqType = cqType myGeom % tqType = tqType myGeom % nElem = nElem CALL myGeom % x % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dxds % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % dsdx % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) CALL myGeom % J % Init ( N = cqDegree , & quadratureType = cqType , & M = tqDegree , & targetNodeType = tqType , & nVar = 1 , & nElem = nElem ) END SUBROUTINE Init_SEMQuad","tags":"","loc":"proc/init_semquad.html"},{"title":"UpdateDevice_Geometry1D – SELF","text":"public subroutine UpdateDevice_Geometry1D(myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Contents Source Code UpdateDevice_Geometry1D Source Code SUBROUTINE UpdateDevice_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Geometry1D","tags":"","loc":"proc/updatedevice_geometry1d.html"},{"title":"UpdateDevice_SEMHex – SELF","text":"public subroutine UpdateDevice_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code UpdateDevice_SEMHex Source Code SUBROUTINE UpdateDevice_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () CALL myGeom % dsdx % UpdateDevice () CALL myGeom % J % UpdateDevice () #endif END SUBROUTINE UpdateDevice_SEMHex","tags":"","loc":"proc/updatedevice_semhex.html"},{"title":"UpdateDevice_SEMQuad – SELF","text":"public subroutine UpdateDevice_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code UpdateDevice_SEMQuad Source Code SUBROUTINE UpdateDevice_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % UpdateDevice () CALL myGeom % dxds % UpdateDevice () CALL myGeom % dsdx % UpdateDevice () CALL myGeom % J % UpdateDevice () #endif END SUBROUTINE UpdateDevice_SEMQuad","tags":"","loc":"proc/updatedevice_semquad.html"},{"title":"UpdateHost_Geometry1D – SELF","text":"public subroutine UpdateHost_Geometry1D(myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom Contents Source Code UpdateHost_Geometry1D Source Code SUBROUTINE UpdateHost_Geometry1D ( myGeom ) IMPLICIT NONE CLASS ( Geometry1D ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () #endif END SUBROUTINE UpdateHost_Geometry1D","tags":"","loc":"proc/updatehost_geometry1d.html"},{"title":"UpdateHost_SEMHex – SELF","text":"public subroutine UpdateHost_SEMHex(myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom Contents Source Code UpdateHost_SEMHex Source Code SUBROUTINE UpdateHost_SEMHex ( myGeom ) IMPLICIT NONE CLASS ( SEMHex ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () CALL myGeom % dsdx % UpdateHost () CALL myGeom % J % UpdateHost () #endif END SUBROUTINE UpdateHost_SEMHex","tags":"","loc":"proc/updatehost_semhex.html"},{"title":"UpdateHost_SEMQuad – SELF","text":"public subroutine UpdateHost_SEMQuad(myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom Contents Source Code UpdateHost_SEMQuad Source Code SUBROUTINE UpdateHost_SEMQuad ( myGeom ) IMPLICIT NONE CLASS ( SEMQuad ), INTENT ( inout ) :: myGeom #ifdef GPU CALL myGeom % x % UpdateHost () CALL myGeom % dxds % UpdateHost () CALL myGeom % dsdx % UpdateHost () CALL myGeom % J % UpdateHost () #endif END SUBROUTINE UpdateHost_SEMQuad","tags":"","loc":"proc/updatehost_semquad.html"},{"title":"AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper – SELF","text":"interface Called by interface~~adjustboundarycontravariantbasis_semhex_gpu_wrapper~~CalledByGraph interface~adjustboundarycontravariantbasis_semhex_gpu_wrapper AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper proc~calculatecontravariantbasis_semhex CalculateContravariantBasis_SEMHex proc~calculatecontravariantbasis_semhex->interface~adjustboundarycontravariantbasis_semhex_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper(dsdx, J, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dsdx type(c_ptr) :: J integer, VALUE :: N integer, VALUE :: nEl","tags":"","loc":"interface/adjustboundarycontravariantbasis_semhex_gpu_wrapper.html"},{"title":"AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper – SELF","text":"interface Called by interface~~adjustboundarycontravariantbasis_semquad_gpu_wrapper~~CalledByGraph interface~adjustboundarycontravariantbasis_semquad_gpu_wrapper AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper proc~calculatecontravariantbasis_semquad CalculateContravariantBasis_SEMQuad proc~calculatecontravariantbasis_semquad->interface~adjustboundarycontravariantbasis_semquad_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper(dsdx, J, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dsdx type(c_ptr) :: J integer, VALUE :: N integer, VALUE :: nEl","tags":"","loc":"interface/adjustboundarycontravariantbasis_semquad_gpu_wrapper.html"},{"title":"CalculateContravariantBasis_SEMHex_gpu_wrapper – SELF","text":"interface Called by interface~~calculatecontravariantbasis_semhex_gpu_wrapper~~CalledByGraph interface~calculatecontravariantbasis_semhex_gpu_wrapper CalculateContravariantBasis_SEMHex_gpu_wrapper proc~calculatecontravariantbasis_semhex CalculateContravariantBasis_SEMHex proc~calculatecontravariantbasis_semhex->interface~calculatecontravariantbasis_semhex_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine CalculateContravariantBasis_SEMHex_gpu_wrapper(dxds, dsdx, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dxds type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nEl","tags":"","loc":"interface/calculatecontravariantbasis_semhex_gpu_wrapper.html"},{"title":"CalculateContravariantBasis_SEMQuad_gpu_wrapper – SELF","text":"interface Called by interface~~calculatecontravariantbasis_semquad_gpu_wrapper~~CalledByGraph interface~calculatecontravariantbasis_semquad_gpu_wrapper CalculateContravariantBasis_SEMQuad_gpu_wrapper proc~calculatecontravariantbasis_semquad CalculateContravariantBasis_SEMQuad proc~calculatecontravariantbasis_semquad->interface~calculatecontravariantbasis_semquad_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine CalculateContravariantBasis_SEMQuad_gpu_wrapper(dxds, dsdx, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dxds type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nEl","tags":"","loc":"interface/calculatecontravariantbasis_semquad_gpu_wrapper.html"},{"title":"CalculateLagrangePolynomials – SELF","text":"public function CalculateLagrangePolynomials(myPoly, sE) result(lAtS) Arguments Type Intent Optional Attributes Name class( Lagrange ) :: myPoly real(kind=prec) :: sE Return Value real(kind=prec)\n  (0:myPoly%N) Calls proc~~calculatelagrangepolynomials~~CallsGraph proc~calculatelagrangepolynomials CalculateLagrangePolynomials proc~almostequal AlmostEqual proc~calculatelagrangepolynomials->proc~almostequal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code CalculateLagrangePolynomials Source Code FUNCTION CalculateLagrangePolynomials ( myPoly , sE ) RESULT ( lAtS ) IMPLICIT NONE CLASS ( Lagrange ) :: myPoly REAL ( prec ) :: sE REAL ( prec ) :: lAtS ( 0 : myPoly % N ) ! Local INTEGER :: j LOGICAL :: xMatchesNode REAL ( real64 ) :: temp1 , temp2 REAL ( real64 ) :: sELocal REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: lS ( 0 : myPoly % N ) sELocal = REAL ( sE , real64 ) DO j = 0 , myPoly % N controlPoints ( j ) = REAL ( myPoly % controlPoints % hostData ( j ), real64 ) bWeights ( j ) = REAL ( myPoly % bWeights % hostData ( j ), real64 ) END DO xMatchesNode = . FALSE . DO j = 0 , myPoly % N lS ( j ) = 0.0_real64 IF ( AlmostEqual ( sELocal , controlPoints ( j ))) THEN lS ( j ) = 1.0_real64 xMatchesNode = . TRUE . END IF END DO IF ( xMatchesNode ) THEN RETURN END IF temp1 = 0.0_real64 DO j = 0 , myPoly % N temp2 = bWeights ( j ) / ( sE - controlPoints ( j )) lS ( j ) = temp2 temp1 = temp1 + temp2 END DO lS = lS / temp1 DO j = 0 , myPoly % N lAtS ( j ) = REAL ( lS ( j ), prec ) ENDDO END FUNCTION CalculateLagrangePolynomials","tags":"","loc":"proc/calculatelagrangepolynomials.html"},{"title":"CalculateBarycentricWeights – SELF","text":"public subroutine CalculateBarycentricWeights(myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Contents Source Code CalculateBarycentricWeights Source Code SUBROUTINE CalculateBarycentricWeights ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: i , j REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) DO i = 0 , myPoly % N bWeights ( i ) = 1.0_real64 controlPoints ( i ) = REAL ( myPoly % controlPoints % hostData ( i ), real64 ) END DO ! Computes the product w_k = w_k*(s_k - s_j), k /= j DO j = 1 , myPoly % N DO i = 0 , j - 1 bWeights ( i ) = bWeights ( i ) * ( controlPoints ( i ) - controlPoints ( j )) bWeights ( j ) = bWeights ( j ) * ( controlPoints ( j ) - controlPoints ( i )) END DO END DO DO j = 0 , myPoly % N bWeights ( j ) = 1.0_prec / bWeights ( j ) myPoly % bWeights % hostData ( j ) = REAL ( bWeights ( j ), prec ) END DO END SUBROUTINE CalculateBarycentricWeights","tags":"","loc":"proc/calculatebarycentricweights.html"},{"title":"CalculateDerivativeMatrix – SELF","text":"public subroutine CalculateDerivativeMatrix(myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Contents Source Code CalculateDerivativeMatrix Source Code SUBROUTINE CalculateDerivativeMatrix ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: row , col REAL ( real64 ) :: dmat ( 0 : myPoly % N , 0 : myPoly % N ) REAL ( real64 ) :: dgmat ( 0 : myPoly % N , 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: qWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) DO row = 0 , myPoly % N bWeights ( row ) = REAL ( myPoly % bWeights % hostData ( row ), real64 ) qWeights ( row ) = REAL ( myPoly % qWeights % hostData ( row ), real64 ) controlPoints ( row ) = REAL ( myPoly % controlPoints % hostData ( row ), real64 ) END DO DO row = 0 , myPoly % N dmat ( row , row ) = 0.0_prec DO col = 0 , myPoly % N IF (. NOT . ( col == row )) THEN dmat ( row , col ) = bWeights ( col ) / & ( bWeights ( row ) * & ( controlPoints ( row ) - & controlPoints ( col ))) dmat ( row , row ) = dmat ( row , row ) - dmat ( row , col ) END IF END DO END DO DO row = 0 , myPoly % N DO col = 0 , myPoly % N dgmat ( row , col ) = - dmat ( col , row ) * & qWeights ( col ) / & qWeights ( row ) ENDDO ENDDO DO row = 0 , myPoly % N DO col = 0 , myPoly % N myPoly % dMatrix % hostData ( row , col ) = REAL ( dmat ( col , row ), prec ) myPoly % dgMatrix % hostData ( row , col ) = REAL ( dgmat ( col , row ), prec ) ENDDO ENDDO END SUBROUTINE CalculateDerivativeMatrix","tags":"","loc":"proc/calculatederivativematrix.html"},{"title":"CalculateInterpolationMatrix – SELF","text":"public subroutine CalculateInterpolationMatrix(myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Calls proc~~calculateinterpolationmatrix~~CallsGraph proc~calculateinterpolationmatrix CalculateInterpolationMatrix proc~almostequal AlmostEqual proc~calculateinterpolationmatrix->proc~almostequal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code CalculateInterpolationMatrix Source Code SUBROUTINE CalculateInterpolationMatrix ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly ! Local INTEGER :: row , col LOGICAL :: rowHasMatch REAL ( real64 ) :: temp1 , temp2 REAL ( real64 ) :: iMatrix ( 0 : myPoly % M , 0 : myPoly % N ) REAL ( real64 ) :: bWeights ( 0 : myPoly % N ) REAL ( real64 ) :: controlPoints ( 0 : myPoly % N ) REAL ( real64 ) :: targetPoints ( 0 : myPoly % M ) DO col = 0 , myPoly % N controlPoints ( col ) = REAL ( myPoly % controlPoints % hostData ( col ), real64 ) bWeights ( col ) = REAL ( myPoly % bWeights % hostData ( col ), real64 ) END DO DO row = 0 , myPoly % M targetPoints ( row ) = REAL ( myPoly % targetPoints % hostData ( row ), real64 ) END DO DO row = 0 , myPoly % M rowHasMatch = . FALSE . DO col = 0 , myPoly % N iMatrix ( row , col ) = 0.0_real64 IF ( AlmostEqual ( targetPoints ( row ), controlPoints ( col ))) THEN rowHasMatch = . TRUE . iMatrix ( row , col ) = 1.0_real64 END IF END DO IF (. NOT . ( rowHasMatch )) THEN temp1 = 0.0_real64 DO col = 0 , myPoly % N temp2 = bWeights ( col ) / & ( targetPoints ( row ) - & controlPoints ( col )) iMatrix ( row , col ) = temp2 temp1 = temp1 + temp2 END DO DO col = 0 , myPoly % N iMatrix ( row , col ) = iMatrix ( row , col ) / temp1 END DO END IF END DO DO row = 0 , myPoly % M DO col = 0 , myPoly % N myPoly % iMatrix % hostData ( col , row ) = REAL ( iMatrix ( row , col ), prec ) ENDDO ENDDO END SUBROUTINE CalculateInterpolationMatrix","tags":"","loc":"proc/calculateinterpolationmatrix.html"},{"title":"DGDerivative_1D_cpu – SELF","text":"public subroutine DGDerivative_1D_cpu(myPoly, f, bf, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:nVariables,1:2,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code DGDerivative_1D_cpu Source Code SUBROUTINE DGDerivative_1D_cpu ( myPoly , f , bf , df , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : nVariables , 1 : 2 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: df ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N ! Interior Derivative Matrix Application df ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO ! Boundary Contribution df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + ( bf ( iVar , 2 , iEl ) * myPoly % bMatrix % hostData ( i , 1 ) - & bf ( iVar , 1 , iEl ) * myPoly % bMatrix % hostData ( i , 0 )) / & myPoly % qWeights % hostData ( i ) END DO END DO END DO END SUBROUTINE DGDerivative_1D_cpu","tags":"","loc":"proc/dgderivative_1d_cpu.html"},{"title":"DGDerivative_1D_gpu – SELF","text":"public subroutine DGDerivative_1D_gpu(myPoly, f_dev, bf_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~dgderivative_1d_gpu~~CallsGraph proc~dgderivative_1d_gpu DGDerivative_1D_gpu interface~dgderivative_1d_gpu_wrapper DGDerivative_1D_gpu_wrapper proc~dgderivative_1d_gpu->interface~dgderivative_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code DGDerivative_1D_gpu Source Code SUBROUTINE DGDerivative_1D_gpu ( myPoly , f_dev , bf_dev , df_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: df_dev #ifdef GPU CALL DGDerivative_1D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bf_dev , df_dev , & myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE DGDerivative_1D_gpu","tags":"","loc":"proc/dgderivative_1d_gpu.html"},{"title":"Derivative_1D_cpu – SELF","text":"public subroutine Derivative_1D_cpu(myPoly, f, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code Derivative_1D_cpu Source Code SUBROUTINE Derivative_1D_cpu ( myPoly , f , df , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: df ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N df ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N df ( i , iVar , iEl ) = df ( i , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO END DO END DO END DO END SUBROUTINE Derivative_1D_cpu","tags":"","loc":"proc/derivative_1d_cpu.html"},{"title":"Derivative_1D_gpu – SELF","text":"public subroutine Derivative_1D_gpu(myPoly, f_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~derivative_1d_gpu~~CallsGraph proc~derivative_1d_gpu Derivative_1D_gpu interface~derivative_1d_gpu_wrapper Derivative_1D_gpu_wrapper proc~derivative_1d_gpu->interface~derivative_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Derivative_1D_gpu Source Code SUBROUTINE Derivative_1D_gpu ( myPoly , f_dev , df_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: df_dev #ifdef GPU CALL Derivative_1D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , df_dev , & myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE Derivative_1D_gpu","tags":"","loc":"proc/derivative_1d_gpu.html"},{"title":"Free_Lagrange – SELF","text":"public subroutine Free_Lagrange(myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Contents Source Code Free_Lagrange Source Code SUBROUTINE Free_Lagrange ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly CALL myPoly % controlPoints % Free () CALL myPoly % targetPoints % Free () CALL myPoly % bWeights % Free () CALL myPoly % qWeights % Free () CALL myPoly % iMatrix % Free () CALL myPoly % dMatrix % Free () CALL myPoly % dgMatrix % Free () CALL myPoly % bMatrix % Free () END SUBROUTINE Free_Lagrange","tags":"","loc":"proc/free_lagrange.html"},{"title":"Init_Lagrange – SELF","text":"public subroutine Init_Lagrange(myPoly, N, controlNodeType, M, targetNodeType) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(out) :: myPoly integer, intent(in) :: N integer, intent(in) :: controlNodeType integer, intent(in) :: M integer, intent(in) :: targetNodeType Calls proc~~init_lagrange~~CallsGraph proc~init_lagrange Init_Lagrange proc~legendrequadrature LegendreQuadrature proc~init_lagrange->proc~legendrequadrature proc~uniformpoints UniformPoints proc~init_lagrange->proc~uniformpoints proc~legendregausslobatto LegendreGaussLobatto proc~legendrequadrature->proc~legendregausslobatto proc~legendregauss LegendreGauss proc~legendrequadrature->proc~legendregauss proc~legendreqandl LegendreQandL proc~legendregausslobatto->proc~legendreqandl proc~legendrepolynomial LegendrePolynomial proc~legendregauss->proc~legendrepolynomial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Init_Lagrange Source Code SUBROUTINE Init_Lagrange ( myPoly , N , controlNodeType , M , targetNodeType ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( out ) :: myPoly INTEGER , INTENT ( in ) :: N , M INTEGER , INTENT ( in ) :: controlNodeType , targetNodeType ! Local REAL ( prec ) :: q ( 0 : M ) myPoly % N = N myPoly % M = M CALL myPoly % controlPoints % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % targetPoints % Alloc ( loBound = 0 , & upBound = M ) CALL myPoly % bWeights % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % qWeights % Alloc ( loBound = 0 , & upBound = N ) CALL myPoly % iMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , M / )) CALL myPoly % dMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , N / )) CALL myPoly % dgMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , N / )) CALL myPoly % bMatrix % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / N , 1 / )) IF ( controlNodeType == GAUSS . OR . controlNodeType == GAUSS_LOBATTO ) THEN CALL LegendreQuadrature ( N , & myPoly % controlPoints % hostData , & myPoly % qWeights % hostData , & controlNodeType ) ELSEIF ( controlNodeType == UNIFORM ) THEN myPoly % controlPoints % hostData = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , N ) myPoly % qWeights % hostData = 2.0_prec / REAL ( N , prec ) END IF ! Target Points IF ( targetNodeType == GAUSS . OR . targetNodeType == GAUSS_LOBATTO ) THEN CALL LegendreQuadrature ( M , & myPoly % targetPoints % hostData , & q , & targetNodeType ) ELSEIF ( targetNodeType == UNIFORM ) THEN myPoly % targetPoints % hostData = UniformPoints ( - 1.0_prec , 1.0_prec , 0 , M ) END IF CALL myPoly % CalculateBarycentricWeights () CALL myPoly % CalculateInterpolationMatrix () CALL myPoly % CalculateDerivativeMatrix () myPoly % bMatrix % hostData ( 0 : N , 0 ) = myPoly % CalculateLagrangePolynomials ( - 1.0_prec ) myPoly % bMatrix % hostData ( 0 : N , 1 ) = myPoly % CalculateLagrangePolynomials ( 1.0_prec ) CALL myPoly % UpdateDevice () END SUBROUTINE Init_Lagrange","tags":"","loc":"proc/init_lagrange.html"},{"title":"ScalarBoundaryInterp_1D_cpu – SELF","text":"public subroutine ScalarBoundaryInterp_1D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:nVariables,1:2,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarBoundaryInterp_1D_cpu Source Code SUBROUTINE ScalarBoundaryInterp_1D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : nVariables , 1 : 2 , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables fb ( 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , iVar , iEl ) ! West fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , iVar , iEl ) ! East END DO fBound ( iVar , 1 : 2 , iEl ) = fb ( 1 : 2 ) END DO END DO END SUBROUTINE ScalarBoundaryInterp_1D_cpu","tags":"","loc":"proc/scalarboundaryinterp_1d_cpu.html"},{"title":"ScalarBoundaryInterp_1D_gpu – SELF","text":"public subroutine ScalarBoundaryInterp_1D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalarboundaryinterp_1d_gpu~~CallsGraph proc~scalarboundaryinterp_1d_gpu ScalarBoundaryInterp_1D_gpu interface~scalarboundaryinterp_1d_gpu_wrapper ScalarBoundaryInterp_1D_gpu_wrapper proc~scalarboundaryinterp_1d_gpu->interface~scalarboundaryinterp_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarBoundaryInterp_1D_gpu Source Code SUBROUTINE ScalarBoundaryInterp_1D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound #ifdef GPU CALL ScalarBoundaryInterp_1D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) #endif END SUBROUTINE ScalarBoundaryInterp_1D_gpu","tags":"","loc":"proc/scalarboundaryinterp_1d_gpu.html"},{"title":"ScalarBoundaryInterp_2D_cpu – SELF","text":"public subroutine ScalarBoundaryInterp_2D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarBoundaryInterp_2D_cpu Source Code SUBROUTINE ScalarBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , ii , iVar , iEl ) ! South fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , i , iVar , iEl ) ! East fb ( 3 ) = fb ( 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , ii , iVar , iEl ) ! North fb ( 4 ) = fb ( 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , i , iVar , iEl ) ! West END DO fBound ( i , iVar , 1 : 4 , iEl ) = fb ( 1 : 4 ) END DO END DO END DO END SUBROUTINE ScalarBoundaryInterp_2D_cpu","tags":"","loc":"proc/scalarboundaryinterp_2d_cpu.html"},{"title":"ScalarBoundaryInterp_2D_gpu – SELF","text":"public subroutine ScalarBoundaryInterp_2D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalarboundaryinterp_2d_gpu~~CallsGraph proc~scalarboundaryinterp_2d_gpu ScalarBoundaryInterp_2D_gpu interface~scalarboundaryinterp_2d_gpu_wrapper ScalarBoundaryInterp_2D_gpu_wrapper proc~scalarboundaryinterp_2d_gpu->interface~scalarboundaryinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarBoundaryInterp_2D_gpu Source Code SUBROUTINE ScalarBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound #ifdef GPU CALL ScalarBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) #endif END SUBROUTINE ScalarBoundaryInterp_2D_gpu","tags":"","loc":"proc/scalarboundaryinterp_2d_gpu.html"},{"title":"ScalarBoundaryInterp_3D_cpu – SELF","text":"public subroutine ScalarBoundaryInterp_3D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarBoundaryInterp_3D_cpu Source Code SUBROUTINE ScalarBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl REAL ( prec ) :: fb ( 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N fb ( 1 ) = fb ( 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , j , ii , iVar , iEl ) ! Bottom fb ( 2 ) = fb ( 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( i , ii , j , iVar , iEl ) ! South fb ( 3 ) = fb ( 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( ii , i , j , iVar , iEl ) ! East fb ( 4 ) = fb ( 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , ii , j , iVar , iEl ) ! North fb ( 5 ) = fb ( 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( ii , i , j , iVar , iEl ) ! West fb ( 6 ) = fb ( 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( i , j , ii , iVar , iEl ) ! Top END DO fBound ( i , j , iVar , 1 : 6 , iEl ) = fb ( 1 : 6 ) END DO END DO END DO END DO END SUBROUTINE ScalarBoundaryInterp_3D_cpu","tags":"","loc":"proc/scalarboundaryinterp_3d_cpu.html"},{"title":"ScalarBoundaryInterp_3D_gpu – SELF","text":"public subroutine ScalarBoundaryInterp_3D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalarboundaryinterp_3d_gpu~~CallsGraph proc~scalarboundaryinterp_3d_gpu ScalarBoundaryInterp_3D_gpu interface~scalarboundaryinterp_3d_gpu_wrapper ScalarBoundaryInterp_3D_gpu_wrapper proc~scalarboundaryinterp_3d_gpu->interface~scalarboundaryinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarBoundaryInterp_3D_gpu Source Code SUBROUTINE ScalarBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound #ifdef GPU CALL ScalarBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) #endif END SUBROUTINE ScalarBoundaryInterp_3D_gpu","tags":"","loc":"proc/scalarboundaryinterp_3d_gpu.html"},{"title":"ScalarDGGradient_2D_cpu – SELF","text":"public subroutine ScalarDGGradient_2D_cpu(myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarDGGradient_2D_cpu Source Code SUBROUTINE ScalarDGGradient_2D_cpu ( myPoly , f , bf , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = gradF ( 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( ii , j , iVar , iEl ) gradF ( 2 , i , j , iVar , iEl ) = gradF ( 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , j ) * f ( i , ii , iVar , iEl ) END DO ! Boundary Contribution gradF ( 1 , i , j , iVar , iEl ) = gradF ( 1 , i , j , iVar , iEl ) + ( bf ( j , iVar , 2 , iEl ) * myPoly % bMatrix % hostData ( i , 1 ) + & bf ( j , iVar , 4 , iEl ) * myPoly % bMatrix % hostData ( i , 0 )) / & myPoly % qWeights % hostData ( i ) gradF ( 2 , i , j , iVar , iEl ) = gradF ( 2 , i , j , iVar , iEl ) + ( bf ( i , iVar , 3 , iEl ) * myPoly % bMatrix % hostData ( j , 1 ) + & bf ( i , iVar , 1 , iEl ) * myPoly % bMatrix % hostData ( j , 0 )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE ScalarDGGradient_2D_cpu","tags":"","loc":"proc/scalardggradient_2d_cpu.html"},{"title":"ScalarDGGradient_2D_gpu – SELF","text":"public subroutine ScalarDGGradient_2D_gpu(myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalardggradient_2d_gpu~~CallsGraph proc~scalardggradient_2d_gpu ScalarDGGradient_2D_gpu interface~scalardggradient_2d_gpu_wrapper ScalarDGGradient_2D_gpu_wrapper proc~scalardggradient_2d_gpu->interface~scalardggradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarDGGradient_2D_gpu Source Code SUBROUTINE ScalarDGGradient_2D_gpu ( myPoly , f_dev , bf_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL ScalarDGGradient_2D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bf_dev , gradF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE ScalarDGGradient_2D_gpu","tags":"","loc":"proc/scalardggradient_2d_gpu.html"},{"title":"ScalarGradient_2D_cpu – SELF","text":"public subroutine ScalarGradient_2D_cpu(myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarGradient_2D_cpu Source Code SUBROUTINE ScalarGradient_2D_cpu ( myPoly , f , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , i , j , iVar , iEl ) = gradF ( 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , j , iVar , iEl ) gradF ( 2 , i , j , iVar , iEl ) = gradF ( 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE ScalarGradient_2D_cpu","tags":"","loc":"proc/scalargradient_2d_cpu.html"},{"title":"ScalarGradient_2D_gpu – SELF","text":"public subroutine ScalarGradient_2D_gpu(myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalargradient_2d_gpu~~CallsGraph proc~scalargradient_2d_gpu ScalarGradient_2D_gpu interface~scalargradient_2d_gpu_wrapper ScalarGradient_2D_gpu_wrapper proc~scalargradient_2d_gpu->interface~scalargradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarGradient_2D_gpu Source Code SUBROUTINE ScalarGradient_2D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL ScalarGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE ScalarGradient_2D_gpu","tags":"","loc":"proc/scalargradient_2d_gpu.html"},{"title":"ScalarGradient_3D_cpu – SELF","text":"public subroutine ScalarGradient_3D_cpu(myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarGradient_3D_cpu Source Code SUBROUTINE ScalarGradient_3D_cpu ( myPoly , f , gradF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , i , j , k , iVar , iEl ) = gradF ( 1 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( ii , j , k , iVar , iEl ) gradF ( 2 , i , j , k , iVar , iEl ) = gradF ( 2 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( i , ii , k , iVar , iEl ) gradF ( 3 , i , j , k , iVar , iEl ) = gradF ( 3 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , k ) * f ( i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE ScalarGradient_3D_cpu","tags":"","loc":"proc/scalargradient_3d_cpu.html"},{"title":"ScalarGradient_3D_gpu – SELF","text":"public subroutine ScalarGradient_3D_gpu(myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalargradient_3d_gpu~~CallsGraph proc~scalargradient_3d_gpu ScalarGradient_3D_gpu interface~scalargradient_3d_gpu_wrapper ScalarGradient_3D_gpu_wrapper proc~scalargradient_3d_gpu->interface~scalargradient_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarGradient_3D_gpu Source Code SUBROUTINE ScalarGradient_3D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL ScalarGradient_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE ScalarGradient_3D_gpu","tags":"","loc":"proc/scalargradient_3d_gpu.html"},{"title":"ScalarGridInterp_1D_cpu – SELF","text":"public subroutine ScalarGridInterp_1D_cpu(myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarGridInterp_1D_cpu Source Code SUBROUTINE ScalarGridInterp_1D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iVar , iEl , i , ii DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % M fInterp ( i , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N fInterp ( i , iVar , iEl ) = fInterp ( i , iVar , iEl ) + myPoly % iMatrix % hostData ( ii , i ) * f ( ii , iVar , iEl ) END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_1D_cpu","tags":"","loc":"proc/scalargridinterp_1d_cpu.html"},{"title":"ScalarGridInterp_1D_gpu – SELF","text":"public subroutine ScalarGridInterp_1D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalargridinterp_1d_gpu~~CallsGraph proc~scalargridinterp_1d_gpu ScalarGridInterp_1D_gpu interface~scalargridinterp_1d_gpu_wrapper ScalarGridInterp_1D_gpu_wrapper proc~scalargridinterp_1d_gpu->interface~scalargridinterp_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarGridInterp_1D_gpu Source Code SUBROUTINE ScalarGridInterp_1D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev #ifdef GPU CALL ScalarGridInterp_1D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) #endif END SUBROUTINE ScalarGridInterp_1D_gpu","tags":"","loc":"proc/scalargridinterp_1d_gpu.html"},{"title":"ScalarGridInterp_2D_cpu – SELF","text":"public subroutine ScalarGridInterp_2D_cpu(myPoly, f, fNew, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fNew (0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarGridInterp_2D_cpu Source Code SUBROUTINE ScalarGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fNew ( 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , jj , p , iEl , iVar REAL ( prec ) :: fi , fij DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fij = 0.0_prec DO jj = 0 , myPoly % N fi = 0.0_prec DO ii = 0 , myPoly % N fi = fi + f ( ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij = fij + fi * myPoly % iMatrix % hostData ( jj , j ) END DO fNew ( i , j , iVar , iEl ) = fij END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_2D_cpu","tags":"","loc":"proc/scalargridinterp_2d_cpu.html"},{"title":"ScalarGridInterp_2D_gpu – SELF","text":"public subroutine ScalarGridInterp_2D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalargridinterp_2d_gpu~~CallsGraph proc~scalargridinterp_2d_gpu ScalarGridInterp_2D_gpu interface~scalargridinterp_2d_gpu_wrapper ScalarGridInterp_2D_gpu_wrapper proc~scalargridinterp_2d_gpu->interface~scalargridinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarGridInterp_2D_gpu Source Code SUBROUTINE ScalarGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev #ifdef GPU CALL ScalarGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) #endif END SUBROUTINE ScalarGridInterp_2D_gpu","tags":"","loc":"proc/scalargridinterp_2d_gpu.html"},{"title":"ScalarGridInterp_3D_cpu – SELF","text":"public subroutine ScalarGridInterp_3D_cpu(myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code ScalarGridInterp_3D_cpu Source Code SUBROUTINE ScalarGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi , fij , fijk DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fijk = 0.0_prec DO kk = 0 , myPoly % N fij = 0.0_prec DO jj = 0 , myPoly % N fi = 0.0_prec DO ii = 0 , myPoly % N fi = fi + f ( ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij = fij + fi * myPoly % iMatrix % hostData ( jj , j ) END DO fijk = fijk + fij * myPoly % iMatrix % hostData ( kk , k ) END DO fInterp ( i , j , k , iVar , iEl ) = fijk END DO END DO END DO END DO END DO END SUBROUTINE ScalarGridInterp_3D_cpu","tags":"","loc":"proc/scalargridinterp_3d_cpu.html"},{"title":"ScalarGridInterp_3D_gpu – SELF","text":"public subroutine ScalarGridInterp_3D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~scalargridinterp_3d_gpu~~CallsGraph proc~scalargridinterp_3d_gpu ScalarGridInterp_3D_gpu interface~scalargridinterp_3d_gpu_wrapper ScalarGridInterp_3D_gpu_wrapper proc~scalargridinterp_3d_gpu->interface~scalargridinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarGridInterp_3D_gpu Source Code SUBROUTINE ScalarGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev #ifdef GPU CALL ScalarGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) #endif END SUBROUTINE ScalarGridInterp_3D_gpu","tags":"","loc":"proc/scalargridinterp_3d_gpu.html"},{"title":"TensorBoundaryInterp_2D_cpu – SELF","text":"public subroutine TensorBoundaryInterp_2D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorBoundaryInterp_2D_cpu Source Code SUBROUTINE TensorBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , jdir , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 , 1 : 2 , 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 2 , 1 : 2 , 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N DO jdir = 1 , 2 DO idir = 1 , 2 fb ( idir , jdir , 1 ) = fb ( idir , jdir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , ii , iVar , iEl ) ! South fb ( idir , jdir , 2 ) = fb ( idir , jdir , 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , ii , i , iVar , iEl ) ! East fb ( idir , jdir , 3 ) = fb ( idir , jdir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , ii , iVar , iEl ) ! North fb ( idir , jdir , 4 ) = fb ( idir , jdir , 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , ii , i , iVar , iEl ) ! West END DO END DO END DO DO jdir = 1 , 2 DO idir = 1 , 2 fBound ( idir , jdir , i , iVar , 1 : 4 , iEl ) = fb ( idir , jdir , 1 : 4 ) END DO END DO END DO END DO END DO END SUBROUTINE TensorBoundaryInterp_2D_cpu","tags":"","loc":"proc/tensorboundaryinterp_2d_cpu.html"},{"title":"TensorBoundaryInterp_2D_gpu – SELF","text":"public subroutine TensorBoundaryInterp_2D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~tensorboundaryinterp_2d_gpu~~CallsGraph proc~tensorboundaryinterp_2d_gpu TensorBoundaryInterp_2D_gpu interface~tensorboundaryinterp_2d_gpu_wrapper TensorBoundaryInterp_2D_gpu_wrapper proc~tensorboundaryinterp_2d_gpu->interface~tensorboundaryinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorBoundaryInterp_2D_gpu Source Code SUBROUTINE TensorBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound #ifdef GPU CALL TensorBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) #endif END SUBROUTINE TensorBoundaryInterp_2D_gpu","tags":"","loc":"proc/tensorboundaryinterp_2d_gpu.html"},{"title":"TensorBoundaryInterp_3D_cpu – SELF","text":"public subroutine TensorBoundaryInterp_3D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorBoundaryInterp_3D_cpu Source Code SUBROUTINE TensorBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , jdir , iVar , iEl REAL ( prec ) :: fb ( 1 : 3 , 1 : 3 , 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 3 , 1 : 3 , 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N DO jdir = 1 , 3 DO idir = 1 , 3 fb ( idir , jdir , 1 ) = fb ( idir , jdir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , j , ii , iVar , iEl ) ! Bottom fb ( idir , jdir , 2 ) = fb ( idir , jdir , 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , i , ii , j , iVar , iEl ) ! South fb ( idir , jdir , 3 ) = fb ( idir , jdir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , ii , i , j , iVar , iEl ) ! East fb ( idir , jdir , 4 ) = fb ( idir , jdir , 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , ii , j , iVar , iEl ) ! North fb ( idir , jdir , 5 ) = fb ( idir , jdir , 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , jdir , ii , i , j , iVar , iEl ) ! West fb ( idir , jdir , 6 ) = fb ( idir , jdir , 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , jdir , i , j , ii , iVar , iEl ) ! Top END DO END DO END DO DO jdir = 1 , 3 DO idir = 1 , 3 fBound ( idir , jdir , i , j , iVar , 1 : 6 , iEl ) = fb ( idir , jdir , 1 : 6 ) END DO END DO END DO END DO END DO END DO END SUBROUTINE TensorBoundaryInterp_3D_cpu","tags":"","loc":"proc/tensorboundaryinterp_3d_cpu.html"},{"title":"TensorBoundaryInterp_3D_gpu – SELF","text":"public subroutine TensorBoundaryInterp_3D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~tensorboundaryinterp_3d_gpu~~CallsGraph proc~tensorboundaryinterp_3d_gpu TensorBoundaryInterp_3D_gpu interface~tensorboundaryinterp_3d_gpu_wrapper TensorBoundaryInterp_3D_gpu_wrapper proc~tensorboundaryinterp_3d_gpu->interface~tensorboundaryinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorBoundaryInterp_3D_gpu Source Code SUBROUTINE TensorBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound #ifdef GPU CALL TensorBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) #endif END SUBROUTINE TensorBoundaryInterp_3D_gpu","tags":"","loc":"proc/tensorboundaryinterp_3d_gpu.html"},{"title":"TensorDGDivergence_2D_cpu – SELF","text":"public subroutine TensorDGDivergence_2D_cpu(myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorDGDivergence_2D_cpu Source Code SUBROUTINE TensorDGDivergence_2D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = dF ( 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , iVar , iEl ) dF ( 2 , i , j , iVar , iEl ) = dF ( 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , iVar , iEl ) END DO dF ( 1 , i , j , iVar , iEl ) = dF ( 1 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 1 , 1 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 1 , 1 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 2 , 1 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 2 , 1 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) dF ( 2 , i , j , iVar , iEl ) = dF ( 2 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 1 , 2 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 1 , 2 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 2 , 2 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 2 , 2 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE TensorDGDivergence_2D_cpu","tags":"","loc":"proc/tensordgdivergence_2d_cpu.html"},{"title":"TensorDGDivergence_2D_gpu – SELF","text":"public subroutine TensorDGDivergence_2D_gpu(myPoly, f_dev, bf_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~tensordgdivergence_2d_gpu~~CallsGraph proc~tensordgdivergence_2d_gpu TensorDGDivergence_2D_gpu interface~tensordgdivergence_2d_gpu_wrapper TensorDGDivergence_2D_gpu_wrapper proc~tensordgdivergence_2d_gpu->interface~tensordgdivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorDGDivergence_2D_gpu Source Code SUBROUTINE TensorDGDivergence_2D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL TensorDGDivergence_2D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE TensorDGDivergence_2D_gpu","tags":"","loc":"proc/tensordgdivergence_2d_gpu.html"},{"title":"TensorDGDivergence_3D_cpu – SELF","text":"public subroutine TensorDGDivergence_3D_cpu(myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorDGDivergence_3D_cpu Source Code SUBROUTINE TensorDGDivergence_3D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bF ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , 1 , i , j , ii , iVar , iEl ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , 2 , i , j , ii , iVar , iEl ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , 3 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , 3 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , 3 , i , j , ii , iVar , iEl ) END DO dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , 1 , j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , 1 , j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , 1 , i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , 1 , i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( 3 , 1 , i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( 3 , 1 , i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , 2 , j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , 2 , j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , 2 , i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , 2 , i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( 3 , 2 , i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( 3 , 2 , i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , 3 , j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , 3 , j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , 3 , i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , 3 , i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( 3 , 3 , i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( 3 , 3 , i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) END DO END DO END DO END DO END DO END SUBROUTINE TensorDGDivergence_3D_cpu","tags":"","loc":"proc/tensordgdivergence_3d_cpu.html"},{"title":"TensorDGDivergence_3D_gpu – SELF","text":"public subroutine TensorDGDivergence_3D_gpu(myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~tensordgdivergence_3d_gpu~~CallsGraph proc~tensordgdivergence_3d_gpu TensorDGDivergence_3D_gpu interface~tensordgdivergence_3d_gpu_wrapper TensorDGDivergence_3D_gpu_wrapper proc~tensordgdivergence_3d_gpu->interface~tensordgdivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorDGDivergence_3D_gpu Source Code SUBROUTINE TensorDGDivergence_3D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL TensorDGDivergence_3D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE TensorDGDivergence_3D_gpu","tags":"","loc":"proc/tensordgdivergence_3d_gpu.html"},{"title":"TensorDivergence_2D_cpu – SELF","text":"public subroutine TensorDivergence_2D_cpu(myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorDivergence_2D_cpu Source Code SUBROUTINE TensorDivergence_2D_cpu ( myPoly , f , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , iVar , iEl ) = dF ( 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , iVar , iEl ) dF ( 2 , i , j , iVar , iEl ) = dF ( 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE TensorDivergence_2D_cpu","tags":"","loc":"proc/tensordivergence_2d_cpu.html"},{"title":"TensorDivergence_2D_gpu – SELF","text":"public subroutine TensorDivergence_2D_gpu(myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~tensordivergence_2d_gpu~~CallsGraph proc~tensordivergence_2d_gpu TensorDivergence_2D_gpu interface~tensordivergence_2d_gpu_wrapper TensorDivergence_2D_gpu_wrapper proc~tensordivergence_2d_gpu->interface~tensordivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorDivergence_2D_gpu Source Code SUBROUTINE TensorDivergence_2D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL TensorDivergence_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE TensorDivergence_2D_gpu","tags":"","loc":"proc/tensordivergence_2d_gpu.html"},{"title":"TensorDivergence_3D_cpu – SELF","text":"public subroutine TensorDivergence_3D_cpu(myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorDivergence_3D_cpu Source Code SUBROUTINE TensorDivergence_3D_cpu ( myPoly , f , dF , nVariables , nElements ) ! Note that the divergence is taken over the first dimension (row dimension) of the tensor matrix IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 1 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 1 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , 1 , i , j , ii , iVar , iEl ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 2 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 2 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , 2 , i , j , ii , iVar , iEl ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , 3 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , 3 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , 3 , i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE TensorDivergence_3D_cpu","tags":"","loc":"proc/tensordivergence_3d_cpu.html"},{"title":"TensorDivergence_3D_gpu – SELF","text":"public subroutine TensorDivergence_3D_gpu(myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~tensordivergence_3d_gpu~~CallsGraph proc~tensordivergence_3d_gpu TensorDivergence_3D_gpu interface~tensordivergence_3d_gpu_wrapper TensorDivergence_3D_gpu_wrapper proc~tensordivergence_3d_gpu->interface~tensordivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorDivergence_3D_gpu Source Code SUBROUTINE TensorDivergence_3D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL TensorDivergence_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE TensorDivergence_3D_gpu","tags":"","loc":"proc/tensordivergence_3d_gpu.html"},{"title":"TensorGridInterp_2D_cpu – SELF","text":"public subroutine TensorGridInterp_2D_cpu(myPoly, f, fNew, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fNew (1:2,1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorGridInterp_2D_cpu Source Code SUBROUTINE TensorGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fNew ( 1 : 2 , 1 : 2 , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , jj , p , iEl , iVar REAL ( prec ) :: fi ( 1 : 2 , 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fNew ( 1 : 2 , 1 : 2 , i , j , iVar , iEl ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 2 , 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 2 , 1 : 2 ) = fi ( 1 : 2 , 1 : 2 ) + f ( 1 : 2 , 1 : 2 , ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fNew ( 1 : 2 , 1 : 2 , i , j , iVar , iEl ) = fNew ( 1 : 2 , 1 : 2 , i , j , iVar , iEl ) + fi ( 1 : 2 , 1 : 2 ) * myPoly % iMatrix % hostData ( jj , j ) END DO END DO END DO END DO END DO END SUBROUTINE TensorGridInterp_2D_cpu","tags":"","loc":"proc/tensorgridinterp_2d_cpu.html"},{"title":"TensorGridInterp_2D_gpu – SELF","text":"public subroutine TensorGridInterp_2D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~tensorgridinterp_2d_gpu~~CallsGraph proc~tensorgridinterp_2d_gpu TensorGridInterp_2D_gpu interface~tensorgridinterp_2d_gpu_wrapper TensorGridInterp_2D_gpu_wrapper proc~tensorgridinterp_2d_gpu->interface~tensorgridinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorGridInterp_2D_gpu Source Code SUBROUTINE TensorGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev #ifdef GPU CALL TensorGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) #endif END SUBROUTINE TensorGridInterp_2D_gpu","tags":"","loc":"proc/tensorgridinterp_2d_gpu.html"},{"title":"TensorGridInterp_3D_cpu – SELF","text":"public subroutine TensorGridInterp_3D_cpu(myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code TensorGridInterp_3D_cpu Source Code SUBROUTINE TensorGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 1 : 3 , 1 : 3 , 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi ( 1 : 3 , 1 : 3 ), fij ( 1 : 3 , 1 : 3 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fInterp ( 1 : 3 , 1 : 3 , i , j , k , iVar , iEl ) = 0.0_prec DO kk = 0 , myPoly % N fij ( 1 : 3 , 1 : 3 ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 3 , 1 : 3 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 3 , 1 : 3 ) = fi ( 1 : 3 , 1 : 3 ) + f ( 1 : 3 , 1 : 3 , ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij ( 1 : 3 , 1 : 3 ) = fij ( 1 : 3 , 1 : 3 ) + fi ( 1 : 3 , 1 : 3 ) * myPoly % iMatrix % hostData ( jj , j ) END DO fInterp ( 1 : 3 , 1 : 3 , i , j , k , iVar , iEl ) = fInterp ( 1 : 3 , 1 : 3 , i , j , k , iVar , iEl ) + & fij ( 1 : 3 , 1 : 3 ) * myPoly % iMatrix % hostData ( kk , k ) END DO END DO END DO END DO END DO END DO END SUBROUTINE TensorGridInterp_3D_cpu","tags":"","loc":"proc/tensorgridinterp_3d_cpu.html"},{"title":"TensorGridInterp_3D_gpu – SELF","text":"public subroutine TensorGridInterp_3D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~tensorgridinterp_3d_gpu~~CallsGraph proc~tensorgridinterp_3d_gpu TensorGridInterp_3D_gpu interface~tensorgridinterp_3d_gpu_wrapper TensorGridInterp_3D_gpu_wrapper proc~tensorgridinterp_3d_gpu->interface~tensorgridinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorGridInterp_3D_gpu Source Code SUBROUTINE TensorGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev #ifdef GPU CALL TensorGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) #endif END SUBROUTINE TensorGridInterp_3D_gpu","tags":"","loc":"proc/tensorgridinterp_3d_gpu.html"},{"title":"UpdateDevice_Lagrange – SELF","text":"public subroutine UpdateDevice_Lagrange(myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Contents Source Code UpdateDevice_Lagrange Source Code SUBROUTINE UpdateDevice_Lagrange ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly #ifdef GPU CALL myPoly % controlPoints % UpdateDevice () CALL myPoly % targetPoints % UpdateDevice () CALL myPoly % bWeights % UpdateDevice () CALL myPoly % qWeights % UpdateDevice () CALL myPoly % iMatrix % UpdateDevice () CALL myPoly % dMatrix % UpdateDevice () CALL myPoly % dgMatrix % UpdateDevice () CALL myPoly % bMatrix % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Lagrange","tags":"","loc":"proc/updatedevice_lagrange.html"},{"title":"UpdateHost_Lagrange – SELF","text":"public subroutine UpdateHost_Lagrange(myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly Contents Source Code UpdateHost_Lagrange Source Code SUBROUTINE UpdateHost_Lagrange ( myPoly ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( inout ) :: myPoly #ifdef GPU CALL myPoly % controlPoints % UpdateHost () CALL myPoly % targetPoints % UpdateHost () CALL myPoly % bWeights % UpdateHost () CALL myPoly % qWeights % UpdateHost () CALL myPoly % iMatrix % UpdateHost () CALL myPoly % dMatrix % UpdateHost () CALL myPoly % dgMatrix % UpdateHost () CALL myPoly % bMatrix % UpdateHost () #endif END SUBROUTINE UpdateHost_Lagrange","tags":"","loc":"proc/updatehost_lagrange.html"},{"title":"VectorBoundaryInterp_2D_cpu – SELF","text":"public subroutine VectorBoundaryInterp_2D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorBoundaryInterp_2D_cpu Source Code SUBROUTINE VectorBoundaryInterp_2D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , iVar , iEl REAL ( prec ) :: fb ( 1 : 2 , 1 : 4 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO i = 0 , myPoly % N fb ( 1 : 2 , 1 : 4 ) = 0.0_prec DO ii = 0 , myPoly % N DO idir = 1 , 2 fb ( idir , 1 ) = fb ( idir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , ii , iVar , iEl ) ! South fb ( idir , 2 ) = fb ( idir , 2 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , ii , i , iVar , iEl ) ! East fb ( idir , 3 ) = fb ( idir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , ii , iVar , iEl ) ! North fb ( idir , 4 ) = fb ( idir , 4 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , ii , i , iVar , iEl ) ! West END DO END DO DO idir = 1 , 2 fBound ( idir , i , iVar , 1 : 4 , iEl ) = fb ( idir , 1 : 4 ) END DO END DO END DO END DO END SUBROUTINE VectorBoundaryInterp_2D_cpu","tags":"","loc":"proc/vectorboundaryinterp_2d_cpu.html"},{"title":"VectorBoundaryInterp_2D_gpu – SELF","text":"public subroutine VectorBoundaryInterp_2D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectorboundaryinterp_2d_gpu~~CallsGraph proc~vectorboundaryinterp_2d_gpu VectorBoundaryInterp_2D_gpu interface~vectorboundaryinterp_2d_gpu_wrapper VectorBoundaryInterp_2D_gpu_wrapper proc~vectorboundaryinterp_2d_gpu->interface~vectorboundaryinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorBoundaryInterp_2D_gpu Source Code SUBROUTINE VectorBoundaryInterp_2D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound #ifdef GPU CALL VectorBoundaryInterp_2D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) #endif END SUBROUTINE VectorBoundaryInterp_2D_gpu","tags":"","loc":"proc/vectorboundaryinterp_2d_gpu.html"},{"title":"VectorBoundaryInterp_3D_cpu – SELF","text":"public subroutine VectorBoundaryInterp_3D_cpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorBoundaryInterp_3D_cpu Source Code SUBROUTINE VectorBoundaryInterp_3D_cpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fBound ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) ! Local INTEGER :: i , j , ii , idir , iVar , iEl REAL ( prec ) :: fb ( 1 : 3 , 1 : 6 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N fb ( 1 : 3 , 1 : 6 ) = 0.0_prec DO ii = 0 , myPoly % N DO idir = 1 , 3 fb ( idir , 1 ) = fb ( idir , 1 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , j , ii , iVar , iEl ) ! Bottom fb ( idir , 2 ) = fb ( idir , 2 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , i , ii , j , iVar , iEl ) ! South fb ( idir , 3 ) = fb ( idir , 3 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , ii , i , j , iVar , iEl ) ! East fb ( idir , 4 ) = fb ( idir , 4 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , ii , j , iVar , iEl ) ! North fb ( idir , 5 ) = fb ( idir , 5 ) + myPoly % bMatrix % hostData ( ii , 0 ) * f ( idir , ii , i , j , iVar , iEl ) ! West fb ( idir , 6 ) = fb ( idir , 6 ) + myPoly % bMatrix % hostData ( ii , 1 ) * f ( idir , i , j , ii , iVar , iEl ) ! Top END DO END DO DO idir = 1 , 3 fBound ( idir , i , j , iVar , 1 : 6 , iEl ) = fb ( idir , 1 : 6 ) END DO END DO END DO END DO END DO END SUBROUTINE VectorBoundaryInterp_3D_cpu","tags":"","loc":"proc/vectorboundaryinterp_3d_cpu.html"},{"title":"VectorBoundaryInterp_3D_gpu – SELF","text":"public subroutine VectorBoundaryInterp_3D_gpu(myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectorboundaryinterp_3d_gpu~~CallsGraph proc~vectorboundaryinterp_3d_gpu VectorBoundaryInterp_3D_gpu interface~vectorboundaryinterp_3d_gpu_wrapper VectorBoundaryInterp_3D_gpu_wrapper proc~vectorboundaryinterp_3d_gpu->interface~vectorboundaryinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorBoundaryInterp_3D_gpu Source Code SUBROUTINE VectorBoundaryInterp_3D_gpu ( myPoly , f , fBound , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f TYPE ( c_ptr ), INTENT ( out ) :: fBound #ifdef GPU CALL VectorBoundaryInterp_3D_gpu_wrapper ( myPoly % bMatrix % deviceData , & f , fBound , myPoly % N , nVariables , nElements ) #endif END SUBROUTINE VectorBoundaryInterp_3D_gpu","tags":"","loc":"proc/vectorboundaryinterp_3d_gpu.html"},{"title":"VectorCurl_2D_cpu – SELF","text":"public subroutine VectorCurl_2D_cpu(myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorCurl_2D_cpu Source Code SUBROUTINE VectorCurl_2D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE VectorCurl_2D_cpu","tags":"","loc":"proc/vectorcurl_2d_cpu.html"},{"title":"VectorCurl_2D_gpu – SELF","text":"public subroutine VectorCurl_2D_gpu(myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectorcurl_2d_gpu~~CallsGraph proc~vectorcurl_2d_gpu VectorCurl_2D_gpu interface~vectorcurl_2d_gpu_wrapper VectorCurl_2D_gpu_wrapper proc~vectorcurl_2d_gpu->interface~vectorcurl_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorCurl_2D_gpu Source Code SUBROUTINE VectorCurl_2D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorCurl_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorCurl_2D_gpu","tags":"","loc":"proc/vectorcurl_2d_gpu.html"},{"title":"VectorCurl_3D_cpu – SELF","text":"public subroutine VectorCurl_3D_cpu(myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorCurl_3D_cpu Source Code SUBROUTINE VectorCurl_3D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 2 , i , j , k , iVar , iEl ) = 0.0_prec dF ( 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( 1 , i , j , k , iVar , iEl ) = dF ( 1 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 3 , i , ii , k , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , k ) * f ( 2 , i , j , ii , iVar , iEl ) dF ( 2 , i , j , k , iVar , iEl ) = dF ( 2 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , k ) * f ( 1 , i , j , ii , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , i ) * f ( 3 , ii , j , k , iVar , iEl ) dF ( 3 , i , j , k , iVar , iEl ) = dF ( 3 , i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , k , iVar , iEl ) - & myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , k , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorCurl_3D_cpu","tags":"","loc":"proc/vectorcurl_3d_cpu.html"},{"title":"VectorCurl_3D_gpu – SELF","text":"public subroutine VectorCurl_3D_gpu(myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectorcurl_3d_gpu~~CallsGraph proc~vectorcurl_3d_gpu VectorCurl_3D_gpu interface~vectorcurl_3d_gpu_wrapper VectorCurl_3D_gpu_wrapper proc~vectorcurl_3d_gpu->interface~vectorcurl_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorCurl_3D_gpu Source Code SUBROUTINE VectorCurl_3D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorCurl_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorCurl_3D_gpu","tags":"","loc":"proc/vectorcurl_3d_gpu.html"},{"title":"VectorDGDivergence_2D_cpu – SELF","text":"public subroutine VectorDGDivergence_2D_cpu(myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDGDivergence_2D_cpu Source Code SUBROUTINE VectorDGDivergence_2D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Assumes bF is the vector component in the direction normal to the boundary IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bF ( 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE VectorDGDivergence_2D_cpu","tags":"","loc":"proc/vectordgdivergence_2d_cpu.html"},{"title":"VectorDGDivergence_2D_gpu – SELF","text":"public subroutine VectorDGDivergence_2D_gpu(myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectordgdivergence_2d_gpu~~CallsGraph proc~vectordgdivergence_2d_gpu VectorDGDivergence_2D_gpu interface~vectordgdivergence_2d_gpu_wrapper VectorDGDivergence_2D_gpu_wrapper proc~vectordgdivergence_2d_gpu->interface~vectordgdivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorDGDivergence_2D_gpu Source Code SUBROUTINE VectorDGDivergence_2D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorDGDivergence_2D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorDGDivergence_2D_gpu","tags":"","loc":"proc/vectordgdivergence_2d_gpu.html"},{"title":"VectorDGDivergence_3D_cpu – SELF","text":"public subroutine VectorDGDivergence_3D_cpu(myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDGDivergence_3D_cpu Source Code SUBROUTINE VectorDGDivergence_3D_cpu ( myPoly , f , bF , dF , nVariables , nElements ) ! Assumes bF is the vector component in the direction normal to the element boundaries IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : 6 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) + & myPoly % dgMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bF ( 1 , j , k , iVar , 3 , iEl ) + & ! east myPoly % bMatrix % hostData ( i , 0 ) * bF ( 1 , j , k , iVar , 5 , iEl )) / & ! west myPoly % qWeights % hostData ( i ) + & ( myPoly % bMatrix % hostData ( j , 1 ) * bF ( 2 , i , k , iVar , 4 , iEl ) + & ! north myPoly % bMatrix % hostData ( j , 0 ) * bF ( 2 , i , k , iVar , 2 , iEl )) / & ! south myPoly % qWeights % hostData ( j ) + & ( myPoly % bMatrix % hostData ( k , 1 ) * bF ( 3 , i , j , iVar , 6 , iEl ) + & ! top myPoly % bMatrix % hostData ( k , 0 ) * bF ( 3 , i , j , iVar , 1 , iEl )) / & ! bottom myPoly % qWeights % hostData ( k ) END DO END DO END DO END DO END DO END SUBROUTINE VectorDGDivergence_3D_cpu","tags":"","loc":"proc/vectordgdivergence_3d_cpu.html"},{"title":"VectorDGDivergence_3D_gpu – SELF","text":"public subroutine VectorDGDivergence_3D_gpu(myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectordgdivergence_3d_gpu~~CallsGraph proc~vectordgdivergence_3d_gpu VectorDGDivergence_3D_gpu interface~vectordgdivergence_3d_gpu_wrapper VectorDGDivergence_3D_gpu_wrapper proc~vectordgdivergence_3d_gpu->interface~vectordgdivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorDGDivergence_3D_gpu Source Code SUBROUTINE VectorDGDivergence_3D_gpu ( myPoly , f_dev , bF_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bF_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorDGDivergence_3D_gpu_wrapper ( myPoly % dgMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bF_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorDGDivergence_3D_gpu","tags":"","loc":"proc/vectordgdivergence_3d_gpu.html"},{"title":"VectorDGGradient_2D_cpu – SELF","text":"public subroutine VectorDGGradient_2D_cpu(myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDGGradient_2D_cpu Source Code SUBROUTINE VectorDGGradient_2D_cpu ( myPoly , f , bf , gradF , nVariables , nElements ) ! ! Input : Vector(1:2,...) ! Output : Tensor(1:2,1:2,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( in ) :: bf ( 1 : 2 , 0 : myPoly % N , 1 : nVariables , 1 : 4 , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 1 , 2 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = gradF ( 1 , 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) gradF ( 2 , 1 , i , j , iVar , iEl ) = gradF ( 2 , 1 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , i ) * f ( 2 , ii , j , iVar , iEl ) gradF ( 1 , 2 , i , j , iVar , iEl ) = gradF ( 1 , 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , j ) * f ( 1 , i , ii , iVar , iEl ) gradF ( 2 , 2 , i , j , iVar , iEl ) = gradF ( 2 , 2 , i , j , iVar , iEl ) + myPoly % dgMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO gradF ( 1 , 1 , i , j , iVar , iEl ) = gradF ( 1 , 1 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 1 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 1 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) gradF ( 2 , 1 , i , j , iVar , iEl ) = gradF ( 2 , 1 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( i , 1 ) * bf ( 2 , j , iVar , 2 , iEl ) + & myPoly % bMatrix % hostData ( i , 0 ) * bf ( 2 , j , iVar , 4 , iEl )) / & myPoly % qWeights % hostData ( i ) gradF ( 1 , 2 , i , j , iVar , iEl ) = gradF ( 1 , 2 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 1 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 1 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) gradF ( 2 , 2 , i , j , iVar , iEl ) = gradF ( 2 , 2 , i , j , iVar , iEl ) + ( myPoly % bMatrix % hostData ( j , 1 ) * bf ( 2 , i , iVar , 3 , iEl ) + & myPoly % bMatrix % hostData ( j , 0 ) * bf ( 2 , i , iVar , 1 , iEl )) / & myPoly % qWeights % hostData ( j ) END DO END DO END DO END DO END SUBROUTINE VectorDGGradient_2D_cpu","tags":"","loc":"proc/vectordggradient_2d_cpu.html"},{"title":"VectorDGGradient_2D_gpu – SELF","text":"public subroutine VectorDGGradient_2D_gpu(myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectordggradient_2d_gpu~~CallsGraph proc~vectordggradient_2d_gpu VectorDGGradient_2D_gpu interface~vectordggradient_2d_gpu_wrapper VectorDGGradient_2D_gpu_wrapper proc~vectordggradient_2d_gpu->interface~vectordggradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorDGGradient_2D_gpu Source Code SUBROUTINE VectorDGGradient_2D_gpu ( myPoly , f_dev , bf_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( in ) :: bf_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorDGGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & myPoly % bMatrix % deviceData , & myPoly % qWeights % deviceData , & f_dev , bf_dev , gradF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorDGGradient_2D_gpu","tags":"","loc":"proc/vectordggradient_2d_gpu.html"},{"title":"VectorDivergence_2D_cpu – SELF","text":"public subroutine VectorDivergence_2D_cpu(myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDivergence_2D_cpu Source Code SUBROUTINE VectorDivergence_2D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , iVar , iEl ) = dF ( i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE VectorDivergence_2D_cpu","tags":"","loc":"proc/vectordivergence_2d_cpu.html"},{"title":"VectorDivergence_2D_gpu – SELF","text":"public subroutine VectorDivergence_2D_gpu(myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectordivergence_2d_gpu~~CallsGraph proc~vectordivergence_2d_gpu VectorDivergence_2D_gpu interface~vectordivergence_2d_gpu_wrapper VectorDivergence_2D_gpu_wrapper proc~vectordivergence_2d_gpu->interface~vectordivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorDivergence_2D_gpu Source Code SUBROUTINE VectorDivergence_2D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorDivergence_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorDivergence_2D_gpu","tags":"","loc":"proc/vectordivergence_2d_gpu.html"},{"title":"VectorDivergence_3D_cpu – SELF","text":"public subroutine VectorDivergence_3D_cpu(myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorDivergence_3D_cpu Source Code SUBROUTINE VectorDivergence_3D_cpu ( myPoly , f , dF , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: dF ( 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N dF ( i , j , k , iVar , iEl ) = dF ( i , j , k , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorDivergence_3D_cpu","tags":"","loc":"proc/vectordivergence_3d_cpu.html"},{"title":"VectorDivergence_3D_gpu – SELF","text":"public subroutine VectorDivergence_3D_gpu(myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectordivergence_3d_gpu~~CallsGraph proc~vectordivergence_3d_gpu VectorDivergence_3D_gpu interface~vectordivergence_3d_gpu_wrapper VectorDivergence_3D_gpu_wrapper proc~vectordivergence_3d_gpu->interface~vectordivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorDivergence_3D_gpu Source Code SUBROUTINE VectorDivergence_3D_gpu ( myPoly , f_dev , dF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: dF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorDivergence_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , dF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorDivergence_3D_gpu","tags":"","loc":"proc/vectordivergence_3d_gpu.html"},{"title":"VectorGradient_2D_cpu – SELF","text":"public subroutine VectorGradient_2D_cpu(myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorGradient_2D_cpu Source Code SUBROUTINE VectorGradient_2D_cpu ( myPoly , f , gradF , nVariables , nElements ) ! ! Input : Vector(1:2,...) ! Output : Tensor(1:2,1:2,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 2 , 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 1 , i , j , iVar , iEl ) = 0.0_prec gradF ( 1 , 2 , i , j , iVar , iEl ) = 0.0_prec gradF ( 2 , 2 , i , j , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , 1 , i , j , iVar , iEl ) = gradF ( 1 , 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , iVar , iEl ) gradF ( 2 , 1 , i , j , iVar , iEl ) = gradF ( 2 , 1 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , iVar , iEl ) gradF ( 1 , 2 , i , j , iVar , iEl ) = gradF ( 1 , 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , iVar , iEl ) gradF ( 2 , 2 , i , j , iVar , iEl ) = gradF ( 2 , 2 , i , j , iVar , iEl ) + myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , iVar , iEl ) END DO END DO END DO END DO END DO END SUBROUTINE VectorGradient_2D_cpu","tags":"","loc":"proc/vectorgradient_2d_cpu.html"},{"title":"VectorGradient_2D_gpu – SELF","text":"public subroutine VectorGradient_2D_gpu(myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectorgradient_2d_gpu~~CallsGraph proc~vectorgradient_2d_gpu VectorGradient_2D_gpu interface~vectorgradient_2d_gpu_wrapper VectorGradient_2D_gpu_wrapper proc~vectorgradient_2d_gpu->interface~vectorgradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorGradient_2D_gpu Source Code SUBROUTINE VectorGradient_2D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorGradient_2D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorGradient_2D_gpu","tags":"","loc":"proc/vectorgradient_2d_gpu.html"},{"title":"VectorGradient_3D_cpu – SELF","text":"public subroutine VectorGradient_3D_cpu(myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorGradient_3D_cpu Source Code SUBROUTINE VectorGradient_3D_cpu ( myPoly , f , gradF , nVariables , nElements ) ! ! Input : Vector(1:3,...) ! Output : Tensor(1:3,1:3,....) !          > Tensor(1,1) = d/ds1( Vector(1,...) ) !          > Tensor(2,1) = d/ds1( Vector(2,...) ) !          > Tensor(3,1) = d/ds1( Vector(3,...) ) !          > Tensor(1,2) = d/ds2( Vector(1,...) ) !          > Tensor(2,2) = d/ds2( Vector(2,...) ) !          > Tensor(3,2) = d/ds2( Vector(3,...) ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: gradF ( 1 : 3 , 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , k , ii , iVar , iEl DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % N DO j = 0 , myPoly % N DO i = 0 , myPoly % N gradF ( 1 , 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , 1 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 1 , 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , 2 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 1 , 3 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 2 , 3 , i , j , k , iVar , iEl ) = 0.0_prec gradF ( 3 , 3 , i , j , k , iVar , iEl ) = 0.0_prec DO ii = 0 , myPoly % N gradF ( 1 , 1 , i , j , k , iVar , iEl ) = gradF ( 1 , 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 1 , ii , j , k , iVar , iEl ) gradF ( 2 , 1 , i , j , k , iVar , iEl ) = gradF ( 2 , 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 2 , ii , j , k , iVar , iEl ) gradF ( 3 , 1 , i , j , k , iVar , iEl ) = gradF ( 3 , 1 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , i ) * f ( 3 , ii , j , k , iVar , iEl ) gradF ( 1 , 2 , i , j , k , iVar , iEl ) = gradF ( 1 , 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 1 , i , ii , k , iVar , iEl ) gradF ( 2 , 2 , i , j , k , iVar , iEl ) = gradF ( 2 , 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 2 , i , ii , k , iVar , iEl ) gradF ( 3 , 2 , i , j , k , iVar , iEl ) = gradF ( 3 , 2 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , j ) * f ( 3 , i , ii , k , iVar , iEl ) gradF ( 1 , 3 , i , j , k , iVar , iEl ) = gradF ( 1 , 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 1 , i , j , ii , iVar , iEl ) gradF ( 2 , 3 , i , j , k , iVar , iEl ) = gradF ( 2 , 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 2 , i , j , ii , iVar , iEl ) gradF ( 3 , 3 , i , j , k , iVar , iEl ) = gradF ( 3 , 3 , i , j , k , iVar , iEl ) + & myPoly % dMatrix % hostData ( ii , k ) * f ( 3 , i , j , ii , iVar , iEl ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorGradient_3D_cpu","tags":"","loc":"proc/vectorgradient_3d_cpu.html"},{"title":"VectorGradient_3D_gpu – SELF","text":"public subroutine VectorGradient_3D_gpu(myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectorgradient_3d_gpu~~CallsGraph proc~vectorgradient_3d_gpu VectorGradient_3D_gpu interface~vectorgradient_3d_gpu_wrapper VectorGradient_3D_gpu_wrapper proc~vectorgradient_3d_gpu->interface~vectorgradient_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorGradient_3D_gpu Source Code SUBROUTINE VectorGradient_3D_gpu ( myPoly , f_dev , gradF_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: gradF_dev ! Local INTEGER :: i , j , ii , iVar , iEl #ifdef GPU CALL VectorGradient_3D_gpu_wrapper ( myPoly % dMatrix % deviceData , & f_dev , gradF_dev , myPoly % N , & nVariables , nElements ) #endif END SUBROUTINE VectorGradient_3D_gpu","tags":"","loc":"proc/vectorgradient_3d_gpu.html"},{"title":"VectorGridInterp_2D_cpu – SELF","text":"public subroutine VectorGridInterp_2D_cpu(myPoly, f, fNew, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fNew (1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorGridInterp_2D_cpu Source Code SUBROUTINE VectorGridInterp_2D_cpu ( myPoly , f , fNew , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 2 , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fNew ( 1 : 2 , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: i , j , ii , jj , p , iEl , iVar REAL ( prec ) :: fi ( 1 : 2 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO j = 0 , myPoly % M DO i = 0 , myPoly % M fNew ( 1 , i , j , iVar , iEl ) = 0.0_prec fNew ( 2 , i , j , iVar , iEl ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 2 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 2 ) = fi ( 1 : 2 ) + f ( 1 : 2 , ii , jj , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fNew ( 1 : 2 , i , j , iVar , iEl ) = fNew ( 1 : 2 , i , j , iVar , iEl ) + fi ( 1 : 2 ) * myPoly % iMatrix % hostData ( jj , j ) END DO END DO END DO END DO END DO END SUBROUTINE VectorGridInterp_2D_cpu","tags":"","loc":"proc/vectorgridinterp_2d_cpu.html"},{"title":"VectorGridInterp_2D_gpu – SELF","text":"public subroutine VectorGridInterp_2D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectorgridinterp_2d_gpu~~CallsGraph proc~vectorgridinterp_2d_gpu VectorGridInterp_2D_gpu interface~vectorgridinterp_2d_gpu_wrapper VectorGridInterp_2D_gpu_wrapper proc~vectorgridinterp_2d_gpu->interface~vectorgridinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorGridInterp_2D_gpu Source Code SUBROUTINE VectorGridInterp_2D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev #ifdef GPU CALL VectorGridInterp_2D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) #endif END SUBROUTINE VectorGridInterp_2D_gpu","tags":"","loc":"proc/vectorgridinterp_2d_gpu.html"},{"title":"VectorGridInterp_3D_cpu – SELF","text":"public subroutine VectorGridInterp_3D_cpu(myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements Contents Source Code VectorGridInterp_3D_cpu Source Code SUBROUTINE VectorGridInterp_3D_cpu ( myPoly , f , fInterp , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements REAL ( prec ), INTENT ( in ) :: f ( 1 : 3 , 0 : myPoly % N , 0 : myPoly % N , 0 : myPoly % N , 1 : nVariables , 1 : nElements ) REAL ( prec ), INTENT ( out ) :: fInterp ( 1 : 3 , 0 : myPoly % M , 0 : myPoly % M , 0 : myPoly % M , 1 : nVariables , 1 : nElements ) ! Local INTEGER :: iEl , iVar , i , j , k , ii , jj , kk REAL ( prec ) :: fi ( 1 : 3 ), fij ( 1 : 3 ) DO iEl = 1 , nElements DO iVar = 1 , nVariables DO k = 0 , myPoly % M DO j = 0 , myPoly % M DO i = 0 , myPoly % M fInterp ( 1 : 3 , i , j , k , iVar , iEl ) = 0.0_prec DO kk = 0 , myPoly % N fij ( 1 : 3 ) = 0.0_prec DO jj = 0 , myPoly % N fi ( 1 : 3 ) = 0.0_prec DO ii = 0 , myPoly % N fi ( 1 : 3 ) = fi ( 1 : 3 ) + f ( 1 : 3 , ii , jj , kk , iVar , iEl ) * myPoly % iMatrix % hostData ( ii , i ) END DO fij ( 1 : 3 ) = fij ( 1 : 3 ) + fi ( 1 : 3 ) * myPoly % iMatrix % hostData ( jj , j ) END DO fInterp ( 1 : 3 , i , j , k , iVar , iEl ) = fInterp ( 1 : 3 , i , j , k , iVar , iEl ) + fij ( 1 : 3 ) * myPoly % iMatrix % hostData ( kk , k ) END DO END DO END DO END DO END DO END DO END SUBROUTINE VectorGridInterp_3D_cpu","tags":"","loc":"proc/vectorgridinterp_3d_cpu.html"},{"title":"VectorGridInterp_3D_gpu – SELF","text":"public subroutine VectorGridInterp_3D_gpu(myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements Calls proc~~vectorgridinterp_3d_gpu~~CallsGraph proc~vectorgridinterp_3d_gpu VectorGridInterp_3D_gpu interface~vectorgridinterp_3d_gpu_wrapper VectorGridInterp_3D_gpu_wrapper proc~vectorgridinterp_3d_gpu->interface~vectorgridinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorGridInterp_3D_gpu Source Code SUBROUTINE VectorGridInterp_3D_gpu ( myPoly , f_dev , fInterp_dev , nVariables , nElements ) IMPLICIT NONE CLASS ( Lagrange ), INTENT ( in ) :: myPoly INTEGER , INTENT ( in ) :: nVariables , nElements TYPE ( c_ptr ), INTENT ( in ) :: f_dev TYPE ( c_ptr ), INTENT ( out ) :: fInterp_dev #ifdef GPU CALL VectorGridInterp_3D_gpu_wrapper ( myPoly % iMatrix % deviceData , & f_dev , fInterp_dev , & myPoly % N , myPoly % M , & nVariables , nElements ) #endif END SUBROUTINE VectorGridInterp_3D_gpu","tags":"","loc":"proc/vectorgridinterp_3d_gpu.html"},{"title":"DGDerivative_1D_gpu_wrapper – SELF","text":"interface Called by interface~~dgderivative_1d_gpu_wrapper~~CalledByGraph interface~dgderivative_1d_gpu_wrapper DGDerivative_1D_gpu_wrapper proc~dgderivative_1d_gpu DGDerivative_1D_gpu proc~dgderivative_1d_gpu->interface~dgderivative_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine DGDerivative_1D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/dgderivative_1d_gpu_wrapper.html"},{"title":"Derivative_1D_gpu_wrapper – SELF","text":"interface Called by interface~~derivative_1d_gpu_wrapper~~CalledByGraph interface~derivative_1d_gpu_wrapper Derivative_1D_gpu_wrapper proc~derivative_1d_gpu Derivative_1D_gpu proc~derivative_1d_gpu->interface~derivative_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine Derivative_1D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/derivative_1d_gpu_wrapper.html"},{"title":"ScalarBoundaryInterp_1D_gpu_wrapper – SELF","text":"interface Called by interface~~scalarboundaryinterp_1d_gpu_wrapper~~CalledByGraph interface~scalarboundaryinterp_1d_gpu_wrapper ScalarBoundaryInterp_1D_gpu_wrapper proc~scalarboundaryinterp_1d_gpu ScalarBoundaryInterp_1D_gpu proc~scalarboundaryinterp_1d_gpu->interface~scalarboundaryinterp_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarBoundaryInterp_1D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/scalarboundaryinterp_1d_gpu_wrapper.html"},{"title":"ScalarBoundaryInterp_2D_gpu_wrapper – SELF","text":"interface Called by interface~~scalarboundaryinterp_2d_gpu_wrapper~~CalledByGraph interface~scalarboundaryinterp_2d_gpu_wrapper ScalarBoundaryInterp_2D_gpu_wrapper proc~scalarboundaryinterp_2d_gpu ScalarBoundaryInterp_2D_gpu proc~scalarboundaryinterp_2d_gpu->interface~scalarboundaryinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/scalarboundaryinterp_2d_gpu_wrapper.html"},{"title":"ScalarBoundaryInterp_3D_gpu_wrapper – SELF","text":"interface Called by interface~~scalarboundaryinterp_3d_gpu_wrapper~~CalledByGraph interface~scalarboundaryinterp_3d_gpu_wrapper ScalarBoundaryInterp_3D_gpu_wrapper proc~scalarboundaryinterp_3d_gpu ScalarBoundaryInterp_3D_gpu proc~scalarboundaryinterp_3d_gpu->interface~scalarboundaryinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/scalarboundaryinterp_3d_gpu_wrapper.html"},{"title":"ScalarDGGradient_2D_gpu_wrapper – SELF","text":"interface Called by interface~~scalardggradient_2d_gpu_wrapper~~CalledByGraph interface~scalardggradient_2d_gpu_wrapper ScalarDGGradient_2D_gpu_wrapper proc~scalardggradient_2d_gpu ScalarDGGradient_2D_gpu proc~scalardggradient_2d_gpu->interface~scalardggradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarDGGradient_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/scalardggradient_2d_gpu_wrapper.html"},{"title":"ScalarGradient_2D_gpu_wrapper – SELF","text":"interface Called by interface~~scalargradient_2d_gpu_wrapper~~CalledByGraph interface~scalargradient_2d_gpu_wrapper ScalarGradient_2D_gpu_wrapper proc~scalargradient_2d_gpu ScalarGradient_2D_gpu proc~scalargradient_2d_gpu->interface~scalargradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarGradient_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/scalargradient_2d_gpu_wrapper.html"},{"title":"ScalarGradient_3D_gpu_wrapper – SELF","text":"interface Called by interface~~scalargradient_3d_gpu_wrapper~~CalledByGraph interface~scalargradient_3d_gpu_wrapper ScalarGradient_3D_gpu_wrapper proc~scalargradient_3d_gpu ScalarGradient_3D_gpu proc~scalargradient_3d_gpu->interface~scalargradient_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarGradient_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/scalargradient_3d_gpu_wrapper.html"},{"title":"ScalarGridInterp_1D_gpu_wrapper – SELF","text":"interface Called by interface~~scalargridinterp_1d_gpu_wrapper~~CalledByGraph interface~scalargridinterp_1d_gpu_wrapper ScalarGridInterp_1D_gpu_wrapper proc~scalargridinterp_1d_gpu ScalarGridInterp_1D_gpu proc~scalargridinterp_1d_gpu->interface~scalargridinterp_1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarGridInterp_1D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer, VALUE :: N integer, VALUE :: M integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/scalargridinterp_1d_gpu_wrapper.html"},{"title":"ScalarGridInterp_2D_gpu_wrapper – SELF","text":"interface Called by interface~~scalargridinterp_2d_gpu_wrapper~~CalledByGraph interface~scalargridinterp_2d_gpu_wrapper ScalarGridInterp_2D_gpu_wrapper proc~scalargridinterp_2d_gpu ScalarGridInterp_2D_gpu proc~scalargridinterp_2d_gpu->interface~scalargridinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer, VALUE :: N integer, VALUE :: M integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/scalargridinterp_2d_gpu_wrapper.html"},{"title":"ScalarGridInterp_3D_gpu_wrapper – SELF","text":"interface Called by interface~~scalargridinterp_3d_gpu_wrapper~~CalledByGraph interface~scalargridinterp_3d_gpu_wrapper ScalarGridInterp_3D_gpu_wrapper proc~scalargridinterp_3d_gpu ScalarGridInterp_3D_gpu proc~scalargridinterp_3d_gpu->interface~scalargridinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ScalarGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer, VALUE :: N integer, VALUE :: M integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/scalargridinterp_3d_gpu_wrapper.html"},{"title":"TensorBoundaryInterp_2D_gpu_wrapper – SELF","text":"interface Called by interface~~tensorboundaryinterp_2d_gpu_wrapper~~CalledByGraph interface~tensorboundaryinterp_2d_gpu_wrapper TensorBoundaryInterp_2D_gpu_wrapper proc~tensorboundaryinterp_2d_gpu TensorBoundaryInterp_2D_gpu proc~tensorboundaryinterp_2d_gpu->interface~tensorboundaryinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/tensorboundaryinterp_2d_gpu_wrapper.html"},{"title":"TensorBoundaryInterp_3D_gpu_wrapper – SELF","text":"interface Called by interface~~tensorboundaryinterp_3d_gpu_wrapper~~CalledByGraph interface~tensorboundaryinterp_3d_gpu_wrapper TensorBoundaryInterp_3D_gpu_wrapper proc~tensorboundaryinterp_3d_gpu TensorBoundaryInterp_3D_gpu proc~tensorboundaryinterp_3d_gpu->interface~tensorboundaryinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/tensorboundaryinterp_3d_gpu_wrapper.html"},{"title":"TensorDGDivergence_2D_gpu_wrapper – SELF","text":"interface Called by interface~~tensordgdivergence_2d_gpu_wrapper~~CalledByGraph interface~tensordgdivergence_2d_gpu_wrapper TensorDGDivergence_2D_gpu_wrapper proc~tensordgdivergence_2d_gpu TensorDGDivergence_2D_gpu proc~tensordgdivergence_2d_gpu->interface~tensordgdivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorDGDivergence_2D_gpu_wrapper(dMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/tensordgdivergence_2d_gpu_wrapper.html"},{"title":"TensorDGDivergence_3D_gpu_wrapper – SELF","text":"interface Called by interface~~tensordgdivergence_3d_gpu_wrapper~~CalledByGraph interface~tensordgdivergence_3d_gpu_wrapper TensorDGDivergence_3D_gpu_wrapper proc~tensordgdivergence_3d_gpu TensorDGDivergence_3D_gpu proc~tensordgdivergence_3d_gpu->interface~tensordgdivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorDGDivergence_3D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/tensordgdivergence_3d_gpu_wrapper.html"},{"title":"TensorDivergence_2D_gpu_wrapper – SELF","text":"interface Called by interface~~tensordivergence_2d_gpu_wrapper~~CalledByGraph interface~tensordivergence_2d_gpu_wrapper TensorDivergence_2D_gpu_wrapper proc~tensordivergence_2d_gpu TensorDivergence_2D_gpu proc~tensordivergence_2d_gpu->interface~tensordivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorDivergence_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/tensordivergence_2d_gpu_wrapper.html"},{"title":"TensorDivergence_3D_gpu_wrapper – SELF","text":"interface Called by interface~~tensordivergence_3d_gpu_wrapper~~CalledByGraph interface~tensordivergence_3d_gpu_wrapper TensorDivergence_3D_gpu_wrapper proc~tensordivergence_3d_gpu TensorDivergence_3D_gpu proc~tensordivergence_3d_gpu->interface~tensordivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorDivergence_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/tensordivergence_3d_gpu_wrapper.html"},{"title":"TensorGridInterp_2D_gpu_wrapper – SELF","text":"interface Called by interface~~tensorgridinterp_2d_gpu_wrapper~~CalledByGraph interface~tensorgridinterp_2d_gpu_wrapper TensorGridInterp_2D_gpu_wrapper proc~tensorgridinterp_2d_gpu TensorGridInterp_2D_gpu proc~tensorgridinterp_2d_gpu->interface~tensorgridinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer, VALUE :: N integer, VALUE :: M integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/tensorgridinterp_2d_gpu_wrapper.html"},{"title":"TensorGridInterp_3D_gpu_wrapper – SELF","text":"interface Called by interface~~tensorgridinterp_3d_gpu_wrapper~~CalledByGraph interface~tensorgridinterp_3d_gpu_wrapper TensorGridInterp_3D_gpu_wrapper proc~tensorgridinterp_3d_gpu TensorGridInterp_3D_gpu proc~tensorgridinterp_3d_gpu->interface~tensorgridinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine TensorGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer, VALUE :: N integer, VALUE :: M integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/tensorgridinterp_3d_gpu_wrapper.html"},{"title":"VectorBoundaryInterp_2D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorboundaryinterp_2d_gpu_wrapper~~CalledByGraph interface~vectorboundaryinterp_2d_gpu_wrapper VectorBoundaryInterp_2D_gpu_wrapper proc~vectorboundaryinterp_2d_gpu VectorBoundaryInterp_2D_gpu proc~vectorboundaryinterp_2d_gpu->interface~vectorboundaryinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/vectorboundaryinterp_2d_gpu_wrapper.html"},{"title":"VectorBoundaryInterp_3D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorboundaryinterp_3d_gpu_wrapper~~CalledByGraph interface~vectorboundaryinterp_3d_gpu_wrapper VectorBoundaryInterp_3D_gpu_wrapper proc~vectorboundaryinterp_3d_gpu VectorBoundaryInterp_3D_gpu proc~vectorboundaryinterp_3d_gpu->interface~vectorboundaryinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/vectorboundaryinterp_3d_gpu_wrapper.html"},{"title":"VectorCurl_2D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorcurl_2d_gpu_wrapper~~CalledByGraph interface~vectorcurl_2d_gpu_wrapper VectorCurl_2D_gpu_wrapper proc~vectorcurl_2d_gpu VectorCurl_2D_gpu proc~vectorcurl_2d_gpu->interface~vectorcurl_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorCurl_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/vectorcurl_2d_gpu_wrapper.html"},{"title":"VectorCurl_3D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorcurl_3d_gpu_wrapper~~CalledByGraph interface~vectorcurl_3d_gpu_wrapper VectorCurl_3D_gpu_wrapper proc~vectorcurl_3d_gpu VectorCurl_3D_gpu proc~vectorcurl_3d_gpu->interface~vectorcurl_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorCurl_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/vectorcurl_3d_gpu_wrapper.html"},{"title":"VectorDGDivergence_2D_gpu_wrapper – SELF","text":"interface Called by interface~~vectordgdivergence_2d_gpu_wrapper~~CalledByGraph interface~vectordgdivergence_2d_gpu_wrapper VectorDGDivergence_2D_gpu_wrapper proc~vectordgdivergence_2d_gpu VectorDGDivergence_2D_gpu proc~vectordgdivergence_2d_gpu->interface~vectordgdivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorDGDivergence_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/vectordgdivergence_2d_gpu_wrapper.html"},{"title":"VectorDGDivergence_3D_gpu_wrapper – SELF","text":"interface Called by interface~~vectordgdivergence_3d_gpu_wrapper~~CalledByGraph interface~vectordgdivergence_3d_gpu_wrapper VectorDGDivergence_3D_gpu_wrapper proc~vectordgdivergence_3d_gpu VectorDGDivergence_3D_gpu proc~vectordgdivergence_3d_gpu->interface~vectordgdivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorDGDivergence_3D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/vectordgdivergence_3d_gpu_wrapper.html"},{"title":"VectorDGGradient_2D_gpu_wrapper – SELF","text":"interface Called by interface~~vectordggradient_2d_gpu_wrapper~~CalledByGraph interface~vectordggradient_2d_gpu_wrapper VectorDGGradient_2D_gpu_wrapper proc~vectordggradient_2d_gpu VectorDGGradient_2D_gpu proc~vectordggradient_2d_gpu->interface~vectordggradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorDGGradient_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/vectordggradient_2d_gpu_wrapper.html"},{"title":"VectorDivergence_2D_gpu_wrapper – SELF","text":"interface Called by interface~~vectordivergence_2d_gpu_wrapper~~CalledByGraph interface~vectordivergence_2d_gpu_wrapper VectorDivergence_2D_gpu_wrapper proc~vectordivergence_2d_gpu VectorDivergence_2D_gpu proc~vectordivergence_2d_gpu->interface~vectordivergence_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorDivergence_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/vectordivergence_2d_gpu_wrapper.html"},{"title":"VectorDivergence_3D_gpu_wrapper – SELF","text":"interface Called by interface~~vectordivergence_3d_gpu_wrapper~~CalledByGraph interface~vectordivergence_3d_gpu_wrapper VectorDivergence_3D_gpu_wrapper proc~vectordivergence_3d_gpu VectorDivergence_3D_gpu proc~vectordivergence_3d_gpu->interface~vectordivergence_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorDivergence_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/vectordivergence_3d_gpu_wrapper.html"},{"title":"VectorGradient_2D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorgradient_2d_gpu_wrapper~~CalledByGraph interface~vectorgradient_2d_gpu_wrapper VectorGradient_2D_gpu_wrapper proc~vectorgradient_2d_gpu VectorGradient_2D_gpu proc~vectorgradient_2d_gpu->interface~vectorgradient_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorGradient_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/vectorgradient_2d_gpu_wrapper.html"},{"title":"VectorGradient_3D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorgradient_3d_gpu_wrapper~~CalledByGraph interface~vectorgradient_3d_gpu_wrapper VectorGradient_3D_gpu_wrapper proc~vectorgradient_3d_gpu VectorGradient_3D_gpu proc~vectorgradient_3d_gpu->interface~vectorgradient_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorGradient_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/vectorgradient_3d_gpu_wrapper.html"},{"title":"VectorGridInterp_2D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorgridinterp_2d_gpu_wrapper~~CalledByGraph interface~vectorgridinterp_2d_gpu_wrapper VectorGridInterp_2D_gpu_wrapper proc~vectorgridinterp_2d_gpu VectorGridInterp_2D_gpu proc~vectorgridinterp_2d_gpu->interface~vectorgridinterp_2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer, VALUE :: N integer, VALUE :: M integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/vectorgridinterp_2d_gpu_wrapper.html"},{"title":"VectorGridInterp_3D_gpu_wrapper – SELF","text":"interface Called by interface~~vectorgridinterp_3d_gpu_wrapper~~CalledByGraph interface~vectorgridinterp_3d_gpu_wrapper VectorGridInterp_3D_gpu_wrapper proc~vectorgridinterp_3d_gpu VectorGridInterp_3D_gpu proc~vectorgridinterp_3d_gpu->interface~vectorgridinterp_3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine VectorGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer, VALUE :: N integer, VALUE :: M integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/vectorgridinterp_3d_gpu_wrapper.html"},{"title":"SELF_CalculateRankDistributions – SELF","text":"public subroutine SELF_CalculateRankDistributions(nObj, nRanks, objBounds) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nObj integer, intent(in) :: nRanks integer, intent(out) :: objBounds (1:2,0:nRanks-1) Contents Source Code SELF_CalculateRankDistributions Source Code SUBROUTINE SELF_CalculateRankDistributions ( nObj , nRanks , objBounds ) #undef __FUNC__ #define __FUNC__ SELF_CalculateRankDistributions IMPLICIT NONE INTEGER , INTENT ( in ) :: nObj INTEGER , INTENT ( in ) :: nRanks INTEGER , INTENT ( out ) :: objBounds ( 1 : 2 , 0 : nRanks - 1 ) ! Local INTEGER :: rank , nObjPerRank , remainder , lastUpperBound nObjPerRank = nObj / nRanks remainder = nObj - nObjPerRank * nRanks lastUpperBound = 0 DO rank = 0 , nRanks - 1 objBounds ( 1 , rank ) = 1 + lastUpperBound IF ( rank < remainder ) THEN objBounds ( 2 , rank ) = objBounds ( 1 , rank ) + nObjPerRank + 1 ELSE objBounds ( 2 , rank ) = objBounds ( 1 , rank ) + nObjPerRank END IF lastUpperBound = objBounds ( 2 , rank ) !   INFO( 'Rank '//TRIM(Int2Str(rank))//& !         ' [lower,upper/total] = '//& !         TRIM(Int2Str(objBounds(1,rank)))//','//& !         TRIM(Int2Str(objBounds(2,rank)))//'/'//& !         TRIM(Int2Str(nObj)) ) END DO END SUBROUTINE SELF_CalculateRankDistributions","tags":"","loc":"proc/self_calculaterankdistributions.html"},{"title":"ContravariantProjection_MappedVector2D – SELF","text":"public subroutine ContravariantProjection_MappedVector2D(physVector, geometry, compVector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: physVector type(SEMQuad), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: compVector logical, intent(in) :: gpuAccel Calls proc~~contravariantprojection_mappedvector2d~~CallsGraph proc~contravariantprojection_mappedvector2d ContravariantProjection_MappedVector2D interface~contravariantprojection_mappedvector2d_gpu_wrapper ContravariantProjection_MappedVector2D_gpu_wrapper proc~contravariantprojection_mappedvector2d->interface~contravariantprojection_mappedvector2d_gpu_wrapper warning warning proc~contravariantprojection_mappedvector2d->warning interface~contravariantprojectionboundary_mappedvector2d_gpu_wrapper ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper proc~contravariantprojection_mappedvector2d->interface~contravariantprojectionboundary_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ContravariantProjection_MappedVector2D Source Code SUBROUTINE ContravariantProjection_MappedVector2D ( physVector , geometry , compVector , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantProjection_MappedVector2D\" ! Takes a vector that has physical space coordinate directions (x,y,z) and projects the vector ! into the the contravariant basis vector directions. Keep in mind that the contravariant basis ! vectors are really the Jacobian weighted contravariant basis vectors IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: physVector TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel TYPE ( MappedVector2D ), INTENT ( inout ) :: compVector ! Local INTEGER :: i , j , ivar , iel , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL ContravariantProjection_MappedVector2D_gpu_wrapper ( physVector % interior % deviceData , & compVector % interior % deviceData , & geometry % dsdx % interior % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) CALL ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper ( physVector % boundary % deviceData , & compVector % boundary % deviceData , & geometry % dsdx % boundary % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE ! Assume that tensor(j,i) is vector i, component j ! => dot product is done along first dimension ! to project onto computational space DO iel = 1 , physVector % nElem DO ivar = 1 , physVector % nVar DO j = 0 , physVector % N DO i = 0 , physVector % N compVector % interior % hostData ( 1 , i , j , ivar , iel ) = & geometry % dsdx % interior % hostData ( 1 , 1 , i , j , 1 , iel ) * & physVector % interior % hostData ( 1 , i , j , ivar , iel ) + & geometry % dsdx % interior % hostData ( 2 , 1 , i , j , 1 , iel ) * & physVector % interior % hostData ( 2 , i , j , ivar , iel ) compVector % interior % hostData ( 2 , i , j , ivar , iel ) = & geometry % dsdx % interior % hostData ( 1 , 2 , i , j , 1 , iel ) * & physVector % interior % hostData ( 1 , i , j , ivar , iel ) + & geometry % dsdx % interior % hostData ( 2 , 2 , i , j , 1 , iel ) * & physVector % interior % hostData ( 2 , i , j , ivar , iel ) END DO END DO END DO END DO ! Boundary Terms DO iel = 1 , physVector % nElem DO iside = 1 , 4 DO ivar = 1 , physVector % nVar DO j = 0 , physVector % N compVector % boundary % hostData ( 1 , j , ivar , iside , iel ) = & geometry % dsdx % boundary % hostData ( 1 , 1 , j , 1 , iside , iel ) * & physVector % boundary % hostData ( 1 , j , ivar , iside , iel ) + & geometry % dsdx % boundary % hostData ( 2 , 1 , j , 1 , iside , iel ) * & physVector % boundary % hostData ( 2 , j , ivar , iside , iel ) compVector % boundary % hostData ( 2 , j , ivar , iside , iel ) = & geometry % dsdx % boundary % hostData ( 1 , 2 , j , 1 , iside , iel ) * & physVector % boundary % hostData ( 1 , j , ivar , iside , iel ) + & geometry % dsdx % boundary % hostData ( 2 , 2 , j , 1 , iside , iel ) * & physVector % boundary % hostData ( 2 , j , ivar , iside , iel ) ENDDO ENDDO ENDDO ENDDO END IF END SUBROUTINE ContravariantProjection_MappedVector2D","tags":"","loc":"proc/contravariantprojection_mappedvector2d.html"},{"title":"ContravariantProjection_MappedVector3D – SELF","text":"public subroutine ContravariantProjection_MappedVector3D(physVector, geometry, compVector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: physVector type(SEMHex), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: compVector logical, intent(in) :: gpuAccel Calls proc~~contravariantprojection_mappedvector3d~~CallsGraph proc~contravariantprojection_mappedvector3d ContravariantProjection_MappedVector3D interface~contravariantprojection_mappedvector3d_gpu_wrapper ContravariantProjection_MappedVector3D_gpu_wrapper proc~contravariantprojection_mappedvector3d->interface~contravariantprojection_mappedvector3d_gpu_wrapper interface~contravariantprojectionboundary_mappedvector3d_gpu_wrapper ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper proc~contravariantprojection_mappedvector3d->interface~contravariantprojectionboundary_mappedvector3d_gpu_wrapper warning warning proc~contravariantprojection_mappedvector3d->warning Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ContravariantProjection_MappedVector3D Source Code SUBROUTINE ContravariantProjection_MappedVector3D ( physVector , geometry , compVector , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantProjection_MappedVector3D\" ! Takes a vector that has physical space coordinate directions (x,y,z) and projects the vector ! into the the contravariant basis vector directions. Keep in mind that the contravariant basis ! vectors are really the Jacobian weighted contravariant basis vectors IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: physVector TYPE ( MappedVector3D ), INTENT ( inout ) :: compVector TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: i , j , k , iVar , iEl , iDir , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL ContravariantProjection_MappedVector3D_gpu_wrapper ( physVector % interior % deviceData , & compVector % interior % deviceData , & geometry % dsdx % interior % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) CALL ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper ( physVector % boundary % deviceData , & compVector % boundary % deviceData , & geometry % dsdx % boundary % deviceData , & physVector % N , & physVector % nVar , & physVector % nElem ) #else msg = \"GPU Acceleration currently not enabled in SELF\" WARNING ( msg ) #endif ELSE ! Assume that tensor(j,i) is vector i, component j ! => dot product is done along first dimension to ! project onto computational space DO iEl = 1 , physVector % nElem DO iVar = 1 , physVector % nVar DO k = 0 , physVector % N DO j = 0 , physVector % N DO i = 0 , physVector % N compVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) compVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) compVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) = & geometry % dsdx % interior % hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 1 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 2 , i , j , k , iVar , iEl ) + & geometry % dsdx % interior % hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & physVector % interior % hostData ( 3 , i , j , k , iVar , iEl ) END DO END DO END DO END DO END DO ! Boundary Terms DO iEl = 1 , physVector % nElem DO iside = 1 , 6 DO iVar = 1 , physVector % nVar DO k = 0 , physVector % N DO j = 0 , physVector % N compVector % boundary % hostData ( 1 , j , k , iVar , iside , iEl ) = & geometry % dsdx % boundary % hostData ( 1 , 1 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 1 , j , k , iVar , iside , iEl ) + & geometry % dsdx % boundary % hostData ( 2 , 1 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 2 , j , k , iVar , iside , iEl ) + & geometry % dsdx % boundary % hostData ( 3 , 1 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 3 , j , k , iVar , iside , iEl ) compVector % boundary % hostData ( 2 , j , k , iVar , iside , iEl ) = & geometry % dsdx % boundary % hostData ( 1 , 2 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 1 , j , k , iVar , iside , iEl ) + & geometry % dsdx % boundary % hostData ( 2 , 2 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 2 , j , k , iVar , iside , iEl ) + & geometry % dsdx % boundary % hostData ( 3 , 2 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 3 , j , k , iVar , iside , iEl ) compVector % boundary % hostData ( 3 , j , k , iVar , iside , iEl ) = & geometry % dsdx % boundary % hostData ( 1 , 3 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 1 , j , k , iVar , iside , iEl ) + & geometry % dsdx % boundary % hostData ( 2 , 3 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 2 , j , k , iVar , iside , iEl ) + & geometry % dsdx % boundary % hostData ( 3 , 3 , j , k , 1 , iside , iEl ) * & physVector % boundary % hostData ( 3 , j , k , iVar , iside , iEl ) ENDDO ENDDO ENDDO ENDDO ENDDO END IF END SUBROUTINE ContravariantProjection_MappedVector3D","tags":"","loc":"proc/contravariantprojection_mappedvector3d.html"},{"title":"ContravariantWeight_MappedScalar2D – SELF","text":"public subroutine ContravariantWeight_MappedScalar2D(scalar, geometry, workTensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type(SEMQuad), intent(in) :: geometry type( MappedTensor2D ), intent(inout) :: workTensor logical, intent(in) :: gpuAccel Calls proc~~contravariantweight_mappedscalar2d~~CallsGraph proc~contravariantweight_mappedscalar2d ContravariantWeight_MappedScalar2D warning warning proc~contravariantweight_mappedscalar2d->warning interface~contravariantweightboundary_mappedscalar2d_gpu_wrapper ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper proc~contravariantweight_mappedscalar2d->interface~contravariantweightboundary_mappedscalar2d_gpu_wrapper interface~contravariantweight_mappedscalar2d_gpu_wrapper ContravariantWeight_MappedScalar2D_gpu_wrapper proc~contravariantweight_mappedscalar2d->interface~contravariantweight_mappedscalar2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ContravariantWeight_MappedScalar2D Source Code SUBROUTINE ContravariantWeight_MappedScalar2D ( scalar , geometry , workTensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantWeight_MappedScalar2D\" IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( in ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel TYPE ( MappedTensor2D ), INTENT ( inout ) :: workTensor ! Local INTEGER :: i , j , iVar , iEl , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL ContravariantWeight_MappedScalar2D_gpu_wrapper ( scalar % interior % deviceData , & workTensor % interior % deviceData , & geometry % dsdx % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) CALL ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper ( scalar % boundary % deviceData , & workTensor % boundary % deviceData , & geometry % dsdx % boundary % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N workTensor % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 1 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) workTensor % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 2 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) workTensor % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 1 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) workTensor % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 2 , i , j , 1 , iEl ) * & scalar % interior % hostData ( i , j , iVar , iEl ) END DO END DO END DO END DO ! Boundary Terms DO iEl = 1 , scalar % nElem DO iside = 1 , 4 DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N workTensor % boundary % hostData ( 1 , 1 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 1 , j , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 1 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 2 , j , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , iVar , iside , iEl ) workTensor % boundary % hostData ( 1 , 2 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 1 , j , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 2 , j , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 2 , j , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , iVar , iside , iEl ) ENDDO ENDDO ENDDO ENDDO END IF END SUBROUTINE ContravariantWeight_MappedScalar2D","tags":"","loc":"proc/contravariantweight_mappedscalar2d.html"},{"title":"ContravariantWeight_MappedScalar3D – SELF","text":"public subroutine ContravariantWeight_MappedScalar3D(scalar, geometry, workTensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type(SEMHex), intent(in) :: geometry type( MappedTensor3D ), intent(inout) :: workTensor logical, intent(in) :: gpuAccel Calls proc~~contravariantweight_mappedscalar3d~~CallsGraph proc~contravariantweight_mappedscalar3d ContravariantWeight_MappedScalar3D interface~contravariantweightboundary_mappedscalar3d_gpu_wrapper ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper proc~contravariantweight_mappedscalar3d->interface~contravariantweightboundary_mappedscalar3d_gpu_wrapper warning warning proc~contravariantweight_mappedscalar3d->warning interface~contravariantweight_mappedscalar3d_gpu_wrapper ContravariantWeight_MappedScalar3D_gpu_wrapper proc~contravariantweight_mappedscalar3d->interface~contravariantweight_mappedscalar3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ContravariantWeight_MappedScalar3D Source Code SUBROUTINE ContravariantWeight_MappedScalar3D ( scalar , geometry , workTensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"ContravariantWeight_MappedScalar3D\" IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( in ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel TYPE ( MappedTensor3D ), INTENT ( inout ) :: workTensor ! Local INTEGER :: i , j , k , iVar , iEl , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL ContravariantWeight_MappedScalar3D_gpu_wrapper ( scalar % interior % deviceData , & workTensor % interior % deviceData , & geometry % dsdx % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) CALL ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper ( scalar % boundary % deviceData , & workTensor % boundary % deviceData , & geometry % dsdx % boundary % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N DO i = 0 , scalar % N ! Get the x-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 1 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 2 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 1 , 3 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) ! Get the y-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 1 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 2 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 2 , 3 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) ! Get the z-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 3 , 1 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 3 , 2 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) workTensor % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) = geometry % dsdx % interior % & hostData ( 3 , 3 , i , j , k , 1 , iEl ) * & scalar % interior % hostData ( i , j , k , iVar , iEl ) END DO END DO END DO END DO END DO ! Boundary Term DO iEl = 1 , scalar % nElem DO iside = 1 , 6 DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N ! Get the x-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % boundary % hostData ( 1 , 1 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 1 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 1 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 2 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 3 , 1 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 1 , 3 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) ! Get the y-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % boundary % hostData ( 1 , 2 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 1 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 2 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 2 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 3 , 2 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 2 , 3 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) ! Get the z-component of the Jacobian weighted ! contravariant basis vectors multipled by the scalar workTensor % boundary % hostData ( 1 , 3 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 3 , 1 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 2 , 3 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 3 , 2 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) workTensor % boundary % hostData ( 3 , 3 , j , k , iVar , iside , iEl ) = geometry % dsdx % boundary % & hostData ( 3 , 3 , j , k , 1 , iside , iEl ) * & scalar % boundary % hostData ( j , k , iVar , iside , iEl ) ENDDO ENDDO ENDDO ENDDO ENDDO END IF END SUBROUTINE ContravariantWeight_MappedScalar3D","tags":"","loc":"proc/contravariantweight_mappedscalar3d.html"},{"title":"Derivative_MappedScalar1D – SELF","text":"public subroutine Derivative_MappedScalar1D(scalar, geometry, dF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: scalar type(Geometry1D), intent(in) :: geometry type( MappedScalar1D ), intent(inout) :: dF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Derivative_MappedScalar1D Source Code SUBROUTINE Derivative_MappedScalar1D ( scalar , geometry , dF , dForm , gpuAccel ) ! Strong Form Operator ! ! Calculates the gradient of a scalar 1D function using the conservative form of the ! mapped gradient operator ! ! df/dx =  d\\xi/dx( df/d\\xi ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( in ) :: scalar TYPE ( Geometry1D ), INTENT ( in ) :: geometry TYPE ( MappedScalar1D ), INTENT ( inout ) :: dF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL scalar % interp % DGDerivative_1D ( scalar % interior % deviceData , & scalar % boundary % deviceData , & df % interior % deviceData , & scalar % nVar , & scalar % nElem ) ELSE CALL scalar % interp % DGDerivative_1D ( scalar % interior % hostData , & scalar % boundary % hostData , & df % interior % hostData , & scalar % nVar , & scalar % nElem ) END IF ELSEIF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL scalar % interp % Derivative_1D ( scalar % interior % deviceData , & df % interior % deviceData , & scalar % nVar , & scalar % nElem ) ELSE CALL scalar % interp % Derivative_1D ( scalar % interior % hostData , & df % interior % hostData , & scalar % nVar , & scalar % nElem ) END IF ENDIF CALL df % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Derivative_MappedScalar1D","tags":"","loc":"proc/derivative_mappedscalar1d.html"},{"title":"Divergence_MappedVector2D – SELF","text":"public subroutine Divergence_MappedVector2D(physVector, compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: physVector type( MappedVector2D ), intent(inout) :: compVector type(SEMQuad), intent(in) :: geometry type( MappedScalar2D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Divergence_MappedVector2D Source Code SUBROUTINE Divergence_MappedVector2D ( physVector , compVector , geometry , divVector , dForm , gpuAccel ) ! Strong Form Operator ! ! DG Weak Form Operator ! IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: physVector TYPE ( MappedVector2D ), INTENT ( inout ) :: compVector TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedScalar2D ), INTENT ( inout ) :: divVector INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL physVector % ContravariantProjection ( geometry , compVector , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDGDivergence_2D ( compVector % interior % deviceData , & compVector % boundary % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDGDivergence_2D ( compVector % interior % hostData , & compVector % boundary % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) ENDIF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDivergence_2D ( compVector % interior % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDivergence_2D ( compVector % interior % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) ENDIF END IF CALL divVector % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Divergence_MappedVector2D","tags":"","loc":"proc/divergence_mappedvector2d.html"},{"title":"Divergence_MappedVector3D – SELF","text":"public subroutine Divergence_MappedVector3D(physVector, compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: physVector type( MappedVector3D ), intent(inout) :: compVector type(SEMHex), intent(in) :: geometry type( MappedScalar3D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Divergence_MappedVector3D Source Code SUBROUTINE Divergence_MappedVector3D ( physVector , compVector , geometry , divVector , dForm , gpuAccel ) ! IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: physVector TYPE ( MappedVector3D ), INTENT ( inout ) :: compVector TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedScalar3D ), INTENT ( inout ) :: divVector INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL physVector % ContravariantProjection ( geometry , compVector , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDGDivergence_3D ( compVector % interior % deviceData , & compVector % boundary % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDGDivergence_3D ( compVector % interior % hostData , & compVector % boundary % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) ENDIF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL compVector % interp % VectorDivergence_3D ( compVector % interior % deviceData , & divVector % interior % deviceData , & compVector % nvar , & compVector % nelem ) ELSE CALL compVector % interp % VectorDivergence_3D ( compVector % interior % hostData , & divVector % interior % hostData , & compVector % nvar , & compVector % nelem ) ENDIF END IF CALL divVector % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Divergence_MappedVector3D","tags":"","loc":"proc/divergence_mappedvector3d.html"},{"title":"Gradient_MappedScalar2D – SELF","text":"public subroutine Gradient_MappedScalar2D(scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Gradient_MappedScalar2D Source Code SUBROUTINE Gradient_MappedScalar2D ( scalar , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator - (Conservative Form) ! ! Calculates the gradient of a scalar 2D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( in ) :: scalar TYPE ( MappedTensor2D ), INTENT ( inout ) :: workTensor TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedVector2D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL scalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSEIF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ENDIF CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedScalar2D","tags":"","loc":"proc/gradient_mappedscalar2d.html"},{"title":"Gradient_MappedScalar3D – SELF","text":"public subroutine Gradient_MappedScalar3D(scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Gradient_MappedScalar3D Source Code SUBROUTINE Gradient_MappedScalar3D ( scalar , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator ! ! Calculates the gradient of a scalar 3D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( in ) :: scalar TYPE ( MappedTensor3D ), INTENT ( inout ) :: workTensor TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedVector3D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL scalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % deviceData , & gradF % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % hostData , & gradF % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF END IF CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedScalar3D","tags":"","loc":"proc/gradient_mappedscalar3d.html"},{"title":"Gradient_MappedVector2D – SELF","text":"public subroutine Gradient_MappedVector2D(vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedScalar2D ), intent(inout) :: workScalar type( MappedVector2D ), intent(inout) :: workVector type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedTensor2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Gradient_MappedVector2D Source Code SUBROUTINE Gradient_MappedVector2D ( vector , workScalar , workVector , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator - (Conservative Form) ! ! Calculates the gradient of a scalar 2D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: vector TYPE ( MappedScalar2D ), INTENT ( inout ) :: workScalar ! (scalar) nvar = 2*nvar TYPE ( MappedVector2D ), INTENT ( inout ) :: workVector ! (scalar) nvar = 2*nvar TYPE ( MappedTensor2D ), INTENT ( inout ) :: workTensor ! (tensor) nvar = 2*nvar TYPE ( SEMQuad ), INTENT ( in ) :: geometry TYPE ( MappedTensor2D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL vector % MapToScalar ( workScalar , gpuAccel ) CALL workScalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_2D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_2D ( workTensor % interior % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF END IF CALL workVector % MapToTensor ( gradF , gpuAccel ) CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedVector2D","tags":"","loc":"proc/gradient_mappedvector2d.html"},{"title":"Gradient_MappedVector3D – SELF","text":"public subroutine Gradient_MappedVector3D(vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedScalar3D ), intent(inout) :: workScalar type( MappedVector3D ), intent(inout) :: workVector type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedTensor3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel Contents Source Code Gradient_MappedVector3D Source Code SUBROUTINE Gradient_MappedVector3D ( vector , workScalar , workVector , workTensor , geometry , gradF , dForm , gpuAccel ) ! Strong Form Operator - (Conservative Form) ! ! Calculates the gradient of a scalar 3D function using the conservative form of the ! mapped gradient operator ! ! \\grad_{phys}( f ) =  (1 / J)*(\\partial / \\partial \\xi_i ( J\\vec{a}_i f ) ! ! where the sum over i is implied. IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: vector TYPE ( MappedScalar3D ), INTENT ( inout ) :: workScalar ! (scalar) nvar = 3*nvar TYPE ( MappedVector3D ), INTENT ( inout ) :: workVector ! (vector) nvar = 3*nvar TYPE ( MappedTensor3D ), INTENT ( inout ) :: workTensor ! (tensor) nvar = 3*nvar TYPE ( SEMHex ), INTENT ( in ) :: geometry TYPE ( MappedTensor3D ), INTENT ( inout ) :: gradF INTEGER , INTENT ( in ) :: dForm LOGICAL , INTENT ( in ) :: gpuAccel CALL vector % MapToScalar ( workScalar , gpuAccel ) CALL workScalar % ContravariantWeight ( geometry , workTensor , gpuAccel ) IF ( dForm == selfWeakDGForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % deviceData , & workTensor % boundary % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDGDivergence_3D ( workTensor % interior % hostData , & workTensor % boundary % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF ELSE IF ( dForm == selfStrongForm ) THEN IF ( gpuAccel ) THEN CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % deviceData , & workVector % interior % deviceData , & workTensor % nVar , & workTensor % nElem ) ELSE CALL workTensor % interp % TensorDivergence_3D ( workTensor % interior % hostData , & workVector % interior % hostData , & workTensor % nVar , & workTensor % nElem ) END IF END IF CALL workVector % MapToTensor ( gradF , gpuAccel ) CALL gradF % JacobianWeight ( geometry , gpuAccel ) END SUBROUTINE Gradient_MappedVector3D","tags":"","loc":"proc/gradient_mappedvector3d.html"},{"title":"JacobianWeight_MappedScalar1D – SELF","text":"public subroutine JacobianWeight_MappedScalar1D(scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar type(Geometry1D), intent(in) :: geometry logical, intent(in) :: gpuAccel Calls proc~~jacobianweight_mappedscalar1d~~CallsGraph proc~jacobianweight_mappedscalar1d JacobianWeight_MappedScalar1D warning warning proc~jacobianweight_mappedscalar1d->warning interface~jacobianweight_mappedscalar1d_gpu_wrapper JacobianWeight_MappedScalar1D_gpu_wrapper proc~jacobianweight_mappedscalar1d->interface~jacobianweight_mappedscalar1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code JacobianWeight_MappedScalar1D Source Code SUBROUTINE JacobianWeight_MappedScalar1D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar1D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar1D ), INTENT ( inout ) :: scalar TYPE ( Geometry1D ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL JacobianWeight_MappedScalar1D_gpu_wrapper ( scalar % interior % deviceData , & geometry % dxds % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO i = 0 , scalar % N scalar % interior % hostData ( i , iVar , iEl ) = scalar % interior % hostData ( i , iVar , iEl ) / & geometry % dxds % interior % hostData ( i , 1 , iEl ) ENDDO ENDDO ENDDO ENDIF END SUBROUTINE JacobianWeight_MappedScalar1D","tags":"","loc":"proc/jacobianweight_mappedscalar1d.html"},{"title":"JacobianWeight_MappedScalar2D – SELF","text":"public subroutine JacobianWeight_MappedScalar2D(scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel Calls proc~~jacobianweight_mappedscalar2d~~CallsGraph proc~jacobianweight_mappedscalar2d JacobianWeight_MappedScalar2D interface~jacobianweight_mappedscalar2d_gpu_wrapper JacobianWeight_MappedScalar2D_gpu_wrapper proc~jacobianweight_mappedscalar2d->interface~jacobianweight_mappedscalar2d_gpu_wrapper warning warning proc~jacobianweight_mappedscalar2d->warning Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code JacobianWeight_MappedScalar2D Source Code SUBROUTINE JacobianWeight_MappedScalar2D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar2D ), INTENT ( inout ) :: scalar TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL JacobianWeight_MappedScalar2D_gpu_wrapper ( scalar % interior % deviceData , & geometry % J % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % interior % hostData ( i , j , iVar , iEl ) = scalar % interior % hostData ( i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE JacobianWeight_MappedScalar2D","tags":"","loc":"proc/jacobianweight_mappedscalar2d.html"},{"title":"JacobianWeight_MappedScalar3D – SELF","text":"public subroutine JacobianWeight_MappedScalar3D(scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel Calls proc~~jacobianweight_mappedscalar3d~~CallsGraph proc~jacobianweight_mappedscalar3d JacobianWeight_MappedScalar3D interface~jacobianweight_mappedscalar3d_gpu_wrapper JacobianWeight_MappedScalar3D_gpu_wrapper proc~jacobianweight_mappedscalar3d->interface~jacobianweight_mappedscalar3d_gpu_wrapper warning warning proc~jacobianweight_mappedscalar3d->warning Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code JacobianWeight_MappedScalar3D Source Code SUBROUTINE JacobianWeight_MappedScalar3D ( scalar , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedScalar3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedScalar3D ), INTENT ( inout ) :: scalar TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL JacobianWeight_MappedScalar3D_gpu_wrapper ( scalar % interior % deviceData , & geometry % J % interior % deviceData , & scalar % N , & scalar % nVar , & scalar % nElem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , scalar % nElem DO iVar = 1 , scalar % nVar DO k = 0 , scalar % N DO j = 0 , scalar % N DO i = 0 , scalar % N scalar % interior % hostData ( i , j , k , iVar , iEl ) = scalar % interior % hostData ( i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE JacobianWeight_MappedScalar3D","tags":"","loc":"proc/jacobianweight_mappedscalar3d.html"},{"title":"JacobianWeight_MappedTensor2D – SELF","text":"public subroutine JacobianWeight_MappedTensor2D(tensor, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel Calls proc~~jacobianweight_mappedtensor2d~~CallsGraph proc~jacobianweight_mappedtensor2d JacobianWeight_MappedTensor2D interface~jacobianweight_mappedtensor2d_gpu_wrapper JacobianWeight_MappedTensor2D_gpu_wrapper proc~jacobianweight_mappedtensor2d->interface~jacobianweight_mappedtensor2d_gpu_wrapper warning warning proc~jacobianweight_mappedtensor2d->warning Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code JacobianWeight_MappedTensor2D Source Code SUBROUTINE JacobianWeight_MappedTensor2D ( tensor , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedTensor2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedTensor2D ), INTENT ( inout ) :: tensor TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL JacobianWeight_MappedTensor2D_gpu_wrapper ( tensor % interior % deviceData , & geometry % J % interior % deviceData , & tensor % N , & tensor % nVar , & tensor % nElem ) #else msg = \"GPU Acceleration currently not enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) = tensor % interior % hostData ( 1 , 1 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) tensor % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) = tensor % interior % hostData ( 2 , 1 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) tensor % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) = tensor % interior % hostData ( 1 , 2 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) tensor % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) = tensor % interior % hostData ( 2 , 2 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE JacobianWeight_MappedTensor2D","tags":"","loc":"proc/jacobianweight_mappedtensor2d.html"},{"title":"JacobianWeight_MappedTensor3D – SELF","text":"public subroutine JacobianWeight_MappedTensor3D(tensor, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel Calls proc~~jacobianweight_mappedtensor3d~~CallsGraph proc~jacobianweight_mappedtensor3d JacobianWeight_MappedTensor3D interface~jacobianweight_mappedtensor3d_gpu_wrapper JacobianWeight_MappedTensor3D_gpu_wrapper proc~jacobianweight_mappedtensor3d->interface~jacobianweight_mappedtensor3d_gpu_wrapper warning warning proc~jacobianweight_mappedtensor3d->warning Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code JacobianWeight_MappedTensor3D Source Code SUBROUTINE JacobianWeight_MappedTensor3D ( tensor , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedTensor3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedTensor3D ), INTENT ( inout ) :: tensor TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL JacobianWeight_MappedTensor3D_gpu_wrapper ( tensor % interior % deviceData , & geometry % J % interior % deviceData , & tensor % N , & tensor % nVar , & tensor % nElem ) #else msg = \"GPU Acceleration currently not enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , tensor % nElem DO iVar = 1 , tensor % nVar DO k = 0 , tensor % N DO j = 0 , tensor % N DO i = 0 , tensor % N tensor % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 1 , 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 2 , 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 3 , 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 1 , 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 2 , 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 3 , 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 1 , 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 2 , 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) tensor % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) = tensor % interior % hostData ( 3 , 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE JacobianWeight_MappedTensor3D","tags":"","loc":"proc/jacobianweight_mappedtensor3d.html"},{"title":"JacobianWeight_MappedVector2D – SELF","text":"public subroutine JacobianWeight_MappedVector2D(vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel Calls proc~~jacobianweight_mappedvector2d~~CallsGraph proc~jacobianweight_mappedvector2d JacobianWeight_MappedVector2D interface~jacobianweight_mappedvector2d_gpu_wrapper JacobianWeight_MappedVector2D_gpu_wrapper proc~jacobianweight_mappedvector2d->interface~jacobianweight_mappedvector2d_gpu_wrapper warning warning proc~jacobianweight_mappedvector2d->warning Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code JacobianWeight_MappedVector2D Source Code SUBROUTINE JacobianWeight_MappedVector2D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedVector2D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( inout ) :: vector TYPE ( SEMQuad ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL JacobianWeight_MappedVector2D_gpu_wrapper ( vector % interior % deviceData , & geometry % J % interior % deviceData , & vector % N , & vector % nVar , & vector % nElem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO j = 0 , vector % N DO i = 0 , vector % N vector % interior % hostData ( 1 , i , j , iVar , iEl ) = vector % interior % hostData ( 1 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) vector % interior % hostData ( 2 , i , j , iVar , iEl ) = vector % interior % hostData ( 2 , i , j , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , 1 , iEl ) ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE JacobianWeight_MappedVector2D","tags":"","loc":"proc/jacobianweight_mappedvector2d.html"},{"title":"JacobianWeight_MappedVector3D – SELF","text":"public subroutine JacobianWeight_MappedVector3D(vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel Calls proc~~jacobianweight_mappedvector3d~~CallsGraph proc~jacobianweight_mappedvector3d JacobianWeight_MappedVector3D interface~jacobianweight_mappedvector3d_gpu_wrapper JacobianWeight_MappedVector3D_gpu_wrapper proc~jacobianweight_mappedvector3d->interface~jacobianweight_mappedvector3d_gpu_wrapper warning warning proc~jacobianweight_mappedvector3d->warning Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code JacobianWeight_MappedVector3D Source Code SUBROUTINE JacobianWeight_MappedVector3D ( vector , geometry , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"JacobianWeight_MappedVector3D\" ! Applies the inverse jacobian IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( inout ) :: vector TYPE ( SEMHex ), INTENT ( in ) :: geometry LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: iEl , iVar , i , j , k CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL JacobianWeight_MappedVector3D_gpu_wrapper ( vector % interior % deviceData , & geometry % J % interior % deviceData , & vector % N , & vector % nVar , & vector % nElem ) #else msg = \"GPU Acceleration currently not enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iEl = 1 , vector % nElem DO iVar = 1 , vector % nVar DO k = 0 , vector % N DO j = 0 , vector % N DO i = 0 , vector % N vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 1 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 2 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) = vector % interior % hostData ( 3 , i , j , k , iVar , iEl ) / & geometry % J % interior % hostData ( i , j , k , 1 , iEl ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE JacobianWeight_MappedVector3D","tags":"","loc":"proc/jacobianweight_mappedvector3d.html"},{"title":"MapToScalar_MappedVector2D – SELF","text":"public subroutine MapToScalar_MappedVector2D(vector, scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedScalar2D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel Calls proc~~maptoscalar_mappedvector2d~~CallsGraph proc~maptoscalar_mappedvector2d MapToScalar_MappedVector2D warning warning proc~maptoscalar_mappedvector2d->warning interface~maptoscalarboundary_mappedvector2d_gpu_wrapper MapToScalarBoundary_MappedVector2D_gpu_wrapper proc~maptoscalar_mappedvector2d->interface~maptoscalarboundary_mappedvector2d_gpu_wrapper interface~maptoscalar_mappedvector2d_gpu_wrapper MapToScalar_MappedVector2D_gpu_wrapper proc~maptoscalar_mappedvector2d->interface~maptoscalar_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code MapToScalar_MappedVector2D Source Code SUBROUTINE MapToScalar_MappedVector2D ( vector , scalar , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToScalar_MappedVector2D\" IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: vector TYPE ( MappedScalar2D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , i , j , ivar , jvar , iel , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL MapToScalar_MappedVector2D_gpu_wrapper ( scalar % interior % deviceData ,& vector % interior % deviceData ,& vector % N , & vector % nVar , & vector % nelem ) CALL MapToScalarBoundary_MappedVector2D_gpu_wrapper ( scalar % boundary % deviceData ,& vector % boundary % deviceData ,& vector % N , & vector % nVar , & vector % nelem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iel = 1 , vector % nelem DO ivar = 1 , vector % nvar DO j = 0 , vector % N DO i = 0 , vector % N DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) scalar % interior % hostData ( i , j , jvar , iel ) = vector % interior % hostData ( row , i , j , ivar , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ! Boundary Terms DO iel = 1 , vector % nelem DO iside = 1 , 4 DO ivar = 1 , vector % nvar DO j = 0 , vector % N DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) scalar % boundary % hostData ( j , jvar , iside , iel ) = vector % boundary % hostData ( row , j , ivar , iside , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE MapToScalar_MappedVector2D","tags":"","loc":"proc/maptoscalar_mappedvector2d.html"},{"title":"MapToScalar_MappedVector3D – SELF","text":"public subroutine MapToScalar_MappedVector3D(vector, scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedScalar3D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel Calls proc~~maptoscalar_mappedvector3d~~CallsGraph proc~maptoscalar_mappedvector3d MapToScalar_MappedVector3D interface~maptoscalarboundary_mappedvector3d_gpu_wrapper MapToScalarBoundary_MappedVector3D_gpu_wrapper proc~maptoscalar_mappedvector3d->interface~maptoscalarboundary_mappedvector3d_gpu_wrapper interface~maptoscalar_mappedvector3d_gpu_wrapper MapToScalar_MappedVector3D_gpu_wrapper proc~maptoscalar_mappedvector3d->interface~maptoscalar_mappedvector3d_gpu_wrapper warning warning proc~maptoscalar_mappedvector3d->warning Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code MapToScalar_MappedVector3D Source Code SUBROUTINE MapToScalar_MappedVector3D ( vector , scalar , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToScalar_MappedVector3D\" IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: vector TYPE ( MappedScalar3D ), INTENT ( inout ) :: scalar LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , i , j , k , ivar , jvar , iel , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL MapToScalar_MappedVector3D_gpu_wrapper ( scalar % interior % deviceData ,& vector % interior % deviceData ,& vector % N , & vector % nVar , & vector % nelem ) CALL MapToScalarBoundary_MappedVector3D_gpu_wrapper ( scalar % boundary % deviceData ,& vector % boundary % deviceData ,& vector % N , & vector % nVar , & vector % nelem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iel = 1 , vector % nelem DO ivar = 1 , vector % nvar DO k = 0 , vector % N DO j = 0 , vector % N DO i = 0 , vector % N DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) scalar % interior % hostData ( i , j , k , jvar , iel ) = vector % interior % hostData ( row , i , j , k , ivar , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ! Boundary Terms DO iel = 1 , vector % nelem DO iside = 1 , 6 DO ivar = 1 , vector % nvar DO k = 0 , vector % N DO j = 0 , vector % N DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) scalar % boundary % hostData ( j , k , jvar , iside , iel ) = vector % boundary % hostData ( row , j , k , ivar , iside , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE MapToScalar_MappedVector3D","tags":"","loc":"proc/maptoscalar_mappedvector3d.html"},{"title":"MapToTensor_MappedVector2D – SELF","text":"public subroutine MapToTensor_MappedVector2D(vector, tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedTensor2D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel Calls proc~~maptotensor_mappedvector2d~~CallsGraph proc~maptotensor_mappedvector2d MapToTensor_MappedVector2D warning warning proc~maptotensor_mappedvector2d->warning interface~maptotensorboundary_mappedvector2d_gpu_wrapper MapToTensorBoundary_MappedVector2D_gpu_wrapper proc~maptotensor_mappedvector2d->interface~maptotensorboundary_mappedvector2d_gpu_wrapper interface~maptotensor_mappedvector2d_gpu_wrapper MapToTensor_MappedVector2D_gpu_wrapper proc~maptotensor_mappedvector2d->interface~maptotensor_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code MapToTensor_MappedVector2D Source Code SUBROUTINE MapToTensor_MappedVector2D ( vector , tensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToTensor_MappedVector2D\" IMPLICIT NONE CLASS ( MappedVector2D ), INTENT ( in ) :: vector TYPE ( MappedTensor2D ), INTENT ( inout ) :: tensor LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , col , i , j , ivar , jvar , iel , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL MapToTensor_MappedVector2D_gpu_wrapper ( tensor % interior % deviceData ,& vector % interior % deviceData ,& tensor % N , & tensor % nVar , & tensor % nelem ) CALL MapToTensorBoundary_MappedVector2D_gpu_wrapper ( tensor % boundary % deviceData ,& vector % boundary % deviceData ,& tensor % N , & tensor % nVar , & tensor % nelem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iel = 1 , tensor % nelem DO ivar = 1 , tensor % nvar DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) tensor % interior % hostData ( row , col , i , j , ivar , iel ) = vector % interior % hostData ( col , i , j , jvar , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ! Boundary Terms DO iel = 1 , tensor % nelem DO iside = 1 , 4 DO ivar = 1 , tensor % nvar DO j = 0 , tensor % N DO col = 1 , 2 DO row = 1 , 2 jvar = row + 2 * ( ivar - 1 ) tensor % boundary % hostData ( row , col , j , ivar , iside , iel ) = vector % boundary % hostData ( col , j , jvar , iside , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE MapToTensor_MappedVector2D","tags":"","loc":"proc/maptotensor_mappedvector2d.html"},{"title":"MapToTensor_MappedVector3D – SELF","text":"public subroutine MapToTensor_MappedVector3D(vector, tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedTensor3D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel Calls proc~~maptotensor_mappedvector3d~~CallsGraph proc~maptotensor_mappedvector3d MapToTensor_MappedVector3D interface~maptotensor_mappedvector3d_gpu_wrapper MapToTensor_MappedVector3D_gpu_wrapper proc~maptotensor_mappedvector3d->interface~maptotensor_mappedvector3d_gpu_wrapper warning warning proc~maptotensor_mappedvector3d->warning interface~maptotensorboundary_mappedvector3d_gpu_wrapper MapToTensorBoundary_MappedVector3D_gpu_wrapper proc~maptotensor_mappedvector3d->interface~maptotensorboundary_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code MapToTensor_MappedVector3D Source Code SUBROUTINE MapToTensor_MappedVector3D ( vector , tensor , gpuAccel ) #undef __FUNC__ #define __FUNC__ \"MapToTensor_MappedVector3D\" IMPLICIT NONE CLASS ( MappedVector3D ), INTENT ( in ) :: vector TYPE ( MappedTensor3D ), INTENT ( inout ) :: tensor LOGICAL , INTENT ( in ) :: gpuAccel ! Local INTEGER :: row , col , i , j , k , ivar , jvar , iel , iside CHARACTER ( 100 ) :: msg IF ( gpuAccel ) THEN #ifdef GPU CALL MapToTensor_MappedVector3D_gpu_wrapper ( tensor % interior % deviceData ,& vector % interior % deviceData ,& tensor % N , & tensor % nVar , & tensor % nelem ) CALL MapToTensorBoundary_MappedVector3D_gpu_wrapper ( tensor % boundary % deviceData ,& vector % boundary % deviceData ,& tensor % N , & tensor % nVar , & tensor % nelem ) #else msg = \"GPU Acceleration is not currently enabled in SELF.\" WARNING ( msg ) #endif ELSE DO iel = 1 , tensor % nelem DO ivar = 1 , tensor % nvar DO k = 0 , tensor % N DO j = 0 , tensor % N DO i = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) tensor % interior % hostData ( row , col , i , j , k , ivar , iel ) = vector % interior % hostData ( col , i , j , k , jvar , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ! Boundary Terms DO iel = 1 , tensor % nelem DO iside = 1 , 6 DO ivar = 1 , tensor % nvar DO k = 0 , tensor % N DO j = 0 , tensor % N DO col = 1 , 3 DO row = 1 , 3 jvar = row + 3 * ( ivar - 1 ) tensor % boundary % hostData ( row , col , j , k , ivar , iside , iel ) = vector % boundary % hostData ( col , j , k , jvar , iside , iel ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDIF END SUBROUTINE MapToTensor_MappedVector3D","tags":"","loc":"proc/maptotensor_mappedvector3d.html"},{"title":"ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantprojectionboundary_mappedvector2d_gpu_wrapper~~CalledByGraph interface~contravariantprojectionboundary_mappedvector2d_gpu_wrapper ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper proc~contravariantprojection_mappedvector2d ContravariantProjection_MappedVector2D proc~contravariantprojection_mappedvector2d->interface~contravariantprojectionboundary_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/contravariantprojectionboundary_mappedvector2d_gpu_wrapper.html"},{"title":"ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantprojectionboundary_mappedvector3d_gpu_wrapper~~CalledByGraph interface~contravariantprojectionboundary_mappedvector3d_gpu_wrapper ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper proc~contravariantprojection_mappedvector3d ContravariantProjection_MappedVector3D proc~contravariantprojection_mappedvector3d->interface~contravariantprojectionboundary_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/contravariantprojectionboundary_mappedvector3d_gpu_wrapper.html"},{"title":"ContravariantProjection_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantprojection_mappedvector2d_gpu_wrapper~~CalledByGraph interface~contravariantprojection_mappedvector2d_gpu_wrapper ContravariantProjection_MappedVector2D_gpu_wrapper proc~contravariantprojection_mappedvector2d ContravariantProjection_MappedVector2D proc~contravariantprojection_mappedvector2d->interface~contravariantprojection_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantProjection_MappedVector2D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/contravariantprojection_mappedvector2d_gpu_wrapper.html"},{"title":"ContravariantProjection_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantprojection_mappedvector3d_gpu_wrapper~~CalledByGraph interface~contravariantprojection_mappedvector3d_gpu_wrapper ContravariantProjection_MappedVector3D_gpu_wrapper proc~contravariantprojection_mappedvector3d ContravariantProjection_MappedVector3D proc~contravariantprojection_mappedvector3d->interface~contravariantprojection_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantProjection_MappedVector3D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/contravariantprojection_mappedvector3d_gpu_wrapper.html"},{"title":"ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantweightboundary_mappedscalar2d_gpu_wrapper~~CalledByGraph interface~contravariantweightboundary_mappedscalar2d_gpu_wrapper ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper proc~contravariantweight_mappedscalar2d ContravariantWeight_MappedScalar2D proc~contravariantweight_mappedscalar2d->interface~contravariantweightboundary_mappedscalar2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/contravariantweightboundary_mappedscalar2d_gpu_wrapper.html"},{"title":"ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantweightboundary_mappedscalar3d_gpu_wrapper~~CalledByGraph interface~contravariantweightboundary_mappedscalar3d_gpu_wrapper ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper proc~contravariantweight_mappedscalar3d ContravariantWeight_MappedScalar3D proc~contravariantweight_mappedscalar3d->interface~contravariantweightboundary_mappedscalar3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/contravariantweightboundary_mappedscalar3d_gpu_wrapper.html"},{"title":"ContravariantWeight_MappedScalar2D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantweight_mappedscalar2d_gpu_wrapper~~CalledByGraph interface~contravariantweight_mappedscalar2d_gpu_wrapper ContravariantWeight_MappedScalar2D_gpu_wrapper proc~contravariantweight_mappedscalar2d ContravariantWeight_MappedScalar2D proc~contravariantweight_mappedscalar2d->interface~contravariantweight_mappedscalar2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantWeight_MappedScalar2D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/contravariantweight_mappedscalar2d_gpu_wrapper.html"},{"title":"ContravariantWeight_MappedScalar3D_gpu_wrapper – SELF","text":"interface Called by interface~~contravariantweight_mappedscalar3d_gpu_wrapper~~CalledByGraph interface~contravariantweight_mappedscalar3d_gpu_wrapper ContravariantWeight_MappedScalar3D_gpu_wrapper proc~contravariantweight_mappedscalar3d ContravariantWeight_MappedScalar3D proc~contravariantweight_mappedscalar3d->interface~contravariantweight_mappedscalar3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine ContravariantWeight_MappedScalar3D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/contravariantweight_mappedscalar3d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedScalar1D_gpu_wrapper – SELF","text":"interface Called by interface~~jacobianweight_mappedscalar1d_gpu_wrapper~~CalledByGraph interface~jacobianweight_mappedscalar1d_gpu_wrapper JacobianWeight_MappedScalar1D_gpu_wrapper proc~jacobianweight_mappedscalar1d JacobianWeight_MappedScalar1D proc~jacobianweight_mappedscalar1d->interface~jacobianweight_mappedscalar1d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine JacobianWeight_MappedScalar1D_gpu_wrapper(scalar, dxds, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: dxds integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedscalar1d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedScalar2D_gpu_wrapper – SELF","text":"interface Called by interface~~jacobianweight_mappedscalar2d_gpu_wrapper~~CalledByGraph interface~jacobianweight_mappedscalar2d_gpu_wrapper JacobianWeight_MappedScalar2D_gpu_wrapper proc~jacobianweight_mappedscalar2d JacobianWeight_MappedScalar2D proc~jacobianweight_mappedscalar2d->interface~jacobianweight_mappedscalar2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine JacobianWeight_MappedScalar2D_gpu_wrapper(scalar, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: jacobian integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedscalar2d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedScalar3D_gpu_wrapper – SELF","text":"interface Called by interface~~jacobianweight_mappedscalar3d_gpu_wrapper~~CalledByGraph interface~jacobianweight_mappedscalar3d_gpu_wrapper JacobianWeight_MappedScalar3D_gpu_wrapper proc~jacobianweight_mappedscalar3d JacobianWeight_MappedScalar3D proc~jacobianweight_mappedscalar3d->interface~jacobianweight_mappedscalar3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine JacobianWeight_MappedScalar3D_gpu_wrapper(scalar, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: jacobian integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedscalar3d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedTensor2D_gpu_wrapper – SELF","text":"interface Called by interface~~jacobianweight_mappedtensor2d_gpu_wrapper~~CalledByGraph interface~jacobianweight_mappedtensor2d_gpu_wrapper JacobianWeight_MappedTensor2D_gpu_wrapper proc~jacobianweight_mappedtensor2d JacobianWeight_MappedTensor2D proc~jacobianweight_mappedtensor2d->interface~jacobianweight_mappedtensor2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine JacobianWeight_MappedTensor2D_gpu_wrapper(tensor, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: jacobian integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedtensor2d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedTensor3D_gpu_wrapper – SELF","text":"interface Called by interface~~jacobianweight_mappedtensor3d_gpu_wrapper~~CalledByGraph interface~jacobianweight_mappedtensor3d_gpu_wrapper JacobianWeight_MappedTensor3D_gpu_wrapper proc~jacobianweight_mappedtensor3d JacobianWeight_MappedTensor3D proc~jacobianweight_mappedtensor3d->interface~jacobianweight_mappedtensor3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine JacobianWeight_MappedTensor3D_gpu_wrapper(tensor, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: jacobian integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedtensor3d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~jacobianweight_mappedvector2d_gpu_wrapper~~CalledByGraph interface~jacobianweight_mappedvector2d_gpu_wrapper JacobianWeight_MappedVector2D_gpu_wrapper proc~jacobianweight_mappedvector2d JacobianWeight_MappedVector2D proc~jacobianweight_mappedvector2d->interface~jacobianweight_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine JacobianWeight_MappedVector2D_gpu_wrapper(vector, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: jacobian integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedvector2d_gpu_wrapper.html"},{"title":"JacobianWeight_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~jacobianweight_mappedvector3d_gpu_wrapper~~CalledByGraph interface~jacobianweight_mappedvector3d_gpu_wrapper JacobianWeight_MappedVector3D_gpu_wrapper proc~jacobianweight_mappedvector3d JacobianWeight_MappedVector3D proc~jacobianweight_mappedvector3d->interface~jacobianweight_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine JacobianWeight_MappedVector3D_gpu_wrapper(vector, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: jacobian integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/jacobianweight_mappedvector3d_gpu_wrapper.html"},{"title":"MapToScalarBoundary_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~maptoscalarboundary_mappedvector2d_gpu_wrapper~~CalledByGraph interface~maptoscalarboundary_mappedvector2d_gpu_wrapper MapToScalarBoundary_MappedVector2D_gpu_wrapper proc~maptoscalar_mappedvector2d MapToScalar_MappedVector2D proc~maptoscalar_mappedvector2d->interface~maptoscalarboundary_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToScalarBoundary_MappedVector2D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/maptoscalarboundary_mappedvector2d_gpu_wrapper.html"},{"title":"MapToScalarBoundary_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~maptoscalarboundary_mappedvector3d_gpu_wrapper~~CalledByGraph interface~maptoscalarboundary_mappedvector3d_gpu_wrapper MapToScalarBoundary_MappedVector3D_gpu_wrapper proc~maptoscalar_mappedvector3d MapToScalar_MappedVector3D proc~maptoscalar_mappedvector3d->interface~maptoscalarboundary_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToScalarBoundary_MappedVector3D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/maptoscalarboundary_mappedvector3d_gpu_wrapper.html"},{"title":"MapToScalar_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~maptoscalar_mappedvector2d_gpu_wrapper~~CalledByGraph interface~maptoscalar_mappedvector2d_gpu_wrapper MapToScalar_MappedVector2D_gpu_wrapper proc~maptoscalar_mappedvector2d MapToScalar_MappedVector2D proc~maptoscalar_mappedvector2d->interface~maptoscalar_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToScalar_MappedVector2D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/maptoscalar_mappedvector2d_gpu_wrapper.html"},{"title":"MapToScalar_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~maptoscalar_mappedvector3d_gpu_wrapper~~CalledByGraph interface~maptoscalar_mappedvector3d_gpu_wrapper MapToScalar_MappedVector3D_gpu_wrapper proc~maptoscalar_mappedvector3d MapToScalar_MappedVector3D proc~maptoscalar_mappedvector3d->interface~maptoscalar_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToScalar_MappedVector3D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/maptoscalar_mappedvector3d_gpu_wrapper.html"},{"title":"MapToTensorBoundary_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~maptotensorboundary_mappedvector2d_gpu_wrapper~~CalledByGraph interface~maptotensorboundary_mappedvector2d_gpu_wrapper MapToTensorBoundary_MappedVector2D_gpu_wrapper proc~maptotensor_mappedvector2d MapToTensor_MappedVector2D proc~maptotensor_mappedvector2d->interface~maptotensorboundary_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToTensorBoundary_MappedVector2D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/maptotensorboundary_mappedvector2d_gpu_wrapper.html"},{"title":"MapToTensorBoundary_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~maptotensorboundary_mappedvector3d_gpu_wrapper~~CalledByGraph interface~maptotensorboundary_mappedvector3d_gpu_wrapper MapToTensorBoundary_MappedVector3D_gpu_wrapper proc~maptotensor_mappedvector3d MapToTensor_MappedVector3D proc~maptotensor_mappedvector3d->interface~maptotensorboundary_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToTensorBoundary_MappedVector3D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/maptotensorboundary_mappedvector3d_gpu_wrapper.html"},{"title":"MapToTensor_MappedVector2D_gpu_wrapper – SELF","text":"interface Called by interface~~maptotensor_mappedvector2d_gpu_wrapper~~CalledByGraph interface~maptotensor_mappedvector2d_gpu_wrapper MapToTensor_MappedVector2D_gpu_wrapper proc~maptotensor_mappedvector2d MapToTensor_MappedVector2D proc~maptotensor_mappedvector2d->interface~maptotensor_mappedvector2d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToTensor_MappedVector2D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/maptotensor_mappedvector2d_gpu_wrapper.html"},{"title":"MapToTensor_MappedVector3D_gpu_wrapper – SELF","text":"interface Called by interface~~maptotensor_mappedvector3d_gpu_wrapper~~CalledByGraph interface~maptotensor_mappedvector3d_gpu_wrapper MapToTensor_MappedVector3D_gpu_wrapper proc~maptotensor_mappedvector3d MapToTensor_MappedVector3D proc~maptotensor_mappedvector3d->interface~maptotensor_mappedvector3d_gpu_wrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. public subroutine MapToTensor_MappedVector3D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl","tags":"","loc":"interface/maptotensor_mappedvector3d_gpu_wrapper.html"},{"title":"Free_Mesh1D – SELF","text":"public subroutine Free_Mesh1D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh Contents Source Code Free_Mesh1D Source Code SUBROUTINE Free_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nNodes = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % elemInfo % Free () CALL myMesh % nodeCoords % Free () CALL myMesh % globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh1D","tags":"","loc":"proc/free_mesh1d.html"},{"title":"Free_Mesh2D – SELF","text":"public subroutine Free_Mesh2D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh Contents Source Code Free_Mesh2D Source Code SUBROUTINE Free_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nNodes = 0 myMesh % nSides = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % elemInfo % Free () CALL myMesh % sideInfo % Free () CALL myMesh % nodeCoords % Free () CALL myMesh % CGNSCornerMap % Free () CALL myMesh % globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh2D","tags":"","loc":"proc/free_mesh2d.html"},{"title":"Free_Mesh3D – SELF","text":"public subroutine Free_Mesh3D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh Contents Source Code Free_Mesh3D Source Code SUBROUTINE Free_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh myMesh % nElem = 0 myMesh % nSides = 0 myMesh % nNodes = 0 myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = 0 CALL myMesh % elemInfo % Free () CALL myMesh % sideInfo % Free () CALL myMesh % nodeCoords % Free () CALL myMesh % CGNSCornerMap % Free () CALL myMesh % globalNodeIDs % Free () CALL myMesh % BCType % Free () DEALLOCATE ( myMesh % BCNames ) END SUBROUTINE Free_Mesh3D","tags":"","loc":"proc/free_mesh3d.html"},{"title":"Init_Mesh1D – SELF","text":"public subroutine Init_Mesh1D(myMesh, nGeo, nElem, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nNodes integer, intent(in) :: nBCs Contents Source Code Init_Mesh1D Source Code SUBROUTINE Init_Mesh1D ( myMesh , nGeo , nElem , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs myMesh % nGeo = nGeo myMesh % nElem = nElem myMesh % nNodes = nNodes myMesh % nCornerNodes = nElem * 2 myMesh % nUniqueNodes = 0 myMesh % nBCs = nBCs CALL myMesh % elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nElem / )) CALL myMesh % nodeCoords % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % globalNodeIDs % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) END SUBROUTINE Init_Mesh1D","tags":"","loc":"proc/init_mesh1d.html"},{"title":"Init_Mesh2D – SELF","text":"public subroutine Init_Mesh2D(myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs Contents Source Code Init_Mesh2D Source Code SUBROUTINE Init_Mesh2D ( myMesh , nGeo , nElem , nSides , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nSides INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs ! Local INTEGER :: i , j , l myMesh % nGeo = nGeo myMesh % nElem = nElem myMesh % nNodes = nNodes myMesh % nSides = nSides myMesh % nCornerNodes = 0 myMesh % nUniqueNodes = 0 myMesh % nUniqueSides = 0 myMesh % nBCs = nBCs CALL myMesh % elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nElem / )) CALL myMesh % sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nSides / )) CALL myMesh % nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , nNodes / )) CALL myMesh % globalNodeIDs % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % CGNSCornerMap % Alloc ( loBound = 1 , & upBound = 4 ) CALL myMesh % CGNSSideMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 2 , 4 / )) CALL myMesh % curveNodeMap % Alloc ( loBound = ( / 1 , 1 / ),& upBound = ( / 2 ,( nGeo + 1 ) ** 2 / )) CALL myMesh % curveNodeMapInv % Alloc ( loBound = ( / 0 , 0 / ), & upBound = ( / nGeo , nGeo / )) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation myMesh % CGNSCornerMap % hostData ( 1 ) = 1 myMesh % CGNSCornerMap % hostData ( 2 ) = nGeo + 1 myMesh % CGNSCornerMap % hostData ( 3 ) = ( nGeo + 1 ) ** 2 myMesh % CGNSCornerMap % hostData ( 4 ) = nGeo * ( nGeo + 1 ) + 1 DO j = 0 , nGeo DO i = 0 , nGeo l = l + 1 myMesh % curveNodeMap % hostData ( 1 : 2 , l ) = ( / i , j / ) myMesh % curveNodeMapInv % hostData ( i , j ) = l ENDDO ENDDO ! Maps from local corner node id to CGNS side myMesh % CGNSSideMap % hostData ( 1 : 2 , 1 ) = ( / 1 , 2 / ) myMesh % CGNSSideMap % hostData ( 1 : 2 , 2 ) = ( / 2 , 3 / ) myMesh % CGNSSideMap % hostData ( 1 : 2 , 3 ) = ( / 4 , 3 / ) myMesh % CGNSSideMap % hostData ( 1 : 2 , 4 ) = ( / 1 , 4 / ) END SUBROUTINE Init_Mesh2D","tags":"","loc":"proc/init_mesh2d.html"},{"title":"Init_Mesh3D – SELF","text":"public subroutine Init_Mesh3D(myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs Contents Source Code Init_Mesh3D Source Code SUBROUTINE Init_Mesh3D ( myMesh , nGeo , nElem , nSides , nNodes , nBCs ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nSides INTEGER , INTENT ( in ) :: nNodes INTEGER , INTENT ( in ) :: nBCs ! Local INTEGER :: i , j , k , l myMesh % nElem = nElem myMesh % nGeo = nGeo myMesh % nSides = nSides myMesh % nNodes = nNodes myMesh % nCornerNodes = 0 myMesh % nUniqueSides = 0 myMesh % nUniqueNodes = 0 myMesh % nBCs = nBCs CALL myMesh % elemInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 6 , nElem / )) CALL myMesh % sideInfo % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 5 , nSides / )) CALL myMesh % nodeCoords % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 , nNodes / )) CALL myMesh % globalNodeIDs % Alloc ( loBound = 1 , & upBound = nNodes ) CALL myMesh % CGNSCornerMap % Alloc ( loBound = 1 , & upBound = 8 ) CALL myMesh % CGNSSideMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , 6 / )) CALL myMesh % curveNodeMap % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 3 ,( nGeo + 1 ) ** 3 / )) CALL myMesh % curveNodeMapInv % Alloc ( loBound = ( / 0 , 0 , 0 / ), & upBound = ( / nGeo , nGeo , nGeo / )) CALL myMesh % BCType % Alloc ( loBound = ( / 1 , 1 / ), & upBound = ( / 4 , nBCs / )) ALLOCATE ( myMesh % BCNames ( 1 : nBCs )) ! Create lookup tables to assist with connectivity generation myMesh % CGNSCornerMap % hostData ( 1 ) = 1 myMesh % CGNSCornerMap % hostData ( 2 ) = nGeo + 1 myMesh % CGNSCornerMap % hostData ( 3 ) = ( nGeo + 1 ) ** 2 myMesh % CGNSCornerMap % hostData ( 4 ) = nGeo * ( nGeo + 1 ) + 1 myMesh % CGNSCornerMap % hostData ( 5 ) = nGeo * ( nGeo + 1 ) ** 2 + 1 myMesh % CGNSCornerMap % hostData ( 6 ) = nGeo * ( nGeo + 1 ) ** 2 + ( nGeo + 1 ) myMesh % CGNSCornerMap % hostData ( 7 ) = ( nGeo + 1 ) ** 3 myMesh % CGNSCornerMap % hostData ( 8 ) = nGeo * ( nGeo + 1 ) * ( nGeo + 2 ) + 1 DO k = 0 , nGeo DO j = 0 , nGeo DO i = 0 , nGeo l = l + 1 myMesh % curveNodeMap % hostData ( 1 : 3 , l ) = ( / i , j , k / ) myMesh % curveNodeMapInv % hostData ( i , j , k ) = l ENDDO ENDDO ENDDO ! Maps from local corner node id to CGNS side myMesh % CGNSSideMap % hostData ( 1 : 4 , 1 ) = ( / 1 , 4 , 3 , 2 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 2 ) = ( / 1 , 2 , 6 , 5 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 3 ) = ( / 2 , 3 , 7 , 6 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 4 ) = ( / 3 , 4 , 8 , 7 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 5 ) = ( / 1 , 5 , 8 , 4 / ) myMesh % CGNSSideMap % hostData ( 1 : 4 , 6 ) = ( / 5 , 6 , 7 , 8 / ) END SUBROUTINE Init_Mesh3D","tags":"","loc":"proc/init_mesh3d.html"},{"title":"UniformBlockMesh_Mesh1D – SELF","text":"public subroutine UniformBlockMesh_Mesh1D(myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem real(kind=prec), intent(in) :: x (1:2) Calls proc~~uniformblockmesh_mesh1d~~CallsGraph proc~uniformblockmesh_mesh1d UniformBlockMesh_Mesh1D proc~uniformpoints UniformPoints proc~uniformblockmesh_mesh1d->proc~uniformpoints Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UniformBlockMesh_Mesh1D Source Code SUBROUTINE UniformBlockMesh_Mesh1D ( myMesh , nGeo , nElem , x ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem REAL ( prec ), INTENT ( in ) :: x ( 1 : 2 ) ! Local INTEGER :: iel INTEGER :: nid , nNodes INTEGER :: i REAL ( prec ) :: xU ( 1 : nElem + 1 ) TYPE ( Scalar1D ) :: xLinear TYPE ( Scalar1D ) :: xGeo nNodes = nElem * ( nGeo + 1 ) CALL myMesh % Init ( nGeo , nElem , nNodes , 2 ) ! Set the nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem + 1 ) ! Create a linear interpolant to interpolate to nGeo grid CALL xLinear % Init ( 1 , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nElem ) CALL xGeo % Init ( nGeo , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nElem ) DO iel = 1 , nElem xLinear % interior % hostData ( 0 : 1 , 1 , iel ) = xU ( iel : iel + 1 ) END DO CALL xLinear % GridInterp ( xGeo ,. FALSE .) ! Set the element information nid = 1 DO iel = 1 , nElem myMesh % eleminfo % hostData ( 1 , iel ) = selfLineLinear ! Element Type myMesh % eleminfo % hostData ( 2 , iel ) = 1 ! Element Zone myMesh % eleminfo % hostData ( 3 , iel ) = nid ! Node Index Start DO i = 0 , nGeo myMesh % nodeCoords % hostData ( nid ) = xGeo % interior % hostData ( i , 1 , iel ) nid = nid + 1 END DO myMesh % eleminfo % hostData ( 4 , iel ) = nid - 1 ! Node Index End END DO CALL myMesh % UpdateDevice () CALL xLinear % Free () CALL xGeo % Free () END SUBROUTINE UniformBlockMesh_Mesh1D","tags":"","loc":"proc/uniformblockmesh_mesh1d.html"},{"title":"UniformBlockMesh_Mesh2D – SELF","text":"public subroutine UniformBlockMesh_Mesh2D(myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem (1:2) real(kind=prec), intent(in) :: x (1:4) Calls proc~~uniformblockmesh_mesh2d~~CallsGraph proc~uniformblockmesh_mesh2d UniformBlockMesh_Mesh2D proc~uniformpoints UniformPoints proc~uniformblockmesh_mesh2d->proc~uniformpoints Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UniformBlockMesh_Mesh2D Source Code SUBROUTINE UniformBlockMesh_Mesh2D ( myMesh , nGeo , nElem , x ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem ( 1 : 2 ) REAL ( prec ), INTENT ( in ) :: x ( 1 : 4 ) ! Local INTEGER :: iel , jel , nEl , elid INTEGER :: sid , nid , nNodes INTEGER :: nSides INTEGER :: i , j REAL ( prec ) :: xU ( 1 : nElem ( 1 ) + 1 ) REAL ( prec ) :: yU ( 1 : nElem ( 2 ) + 1 ) TYPE ( Vector2D ) :: xLinear TYPE ( Vector2D ) :: xGeo nEl = nElem ( 1 ) * nElem ( 2 ) nNodes = nel * ( nGeo + 1 ) * ( nGeo + 1 ) nSides = ( nElem ( 1 ) + 1 ) * nElem ( 2 ) + ( nElem ( 2 ) + 1 ) * nElem ( 1 ) CALL myMesh % Init ( nGeo , nEl , nSides , nNodes , 1 ) ! Set the nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem ( 1 ) + 1 ) yU = UniformPoints ( x ( 3 ), x ( 4 ), 1 , nElem ( 2 ) + 1 ) ! Create a linear interpolant to interpolate to nGeo grid CALL xLinear % Init ( 1 , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) CALL xGeo % Init ( nGeo , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) elid = 1 DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) ! x component xLinear % interior % hostData ( 1 , 0 : 1 , 0 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 1 , 1 , elid ) = xU ( iel : iel + 1 ) ! y component xLinear % interior % hostData ( 2 , 0 , 0 : 1 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 1 , 0 : 1 , 1 , elid ) = yU ( jel : jel + 1 ) ! Incremenent the element ID elid = elid + 1 END DO END DO CALL xLinear % GridInterp ( xGeo ,. FALSE .) ! Set the element information nid = 1 sid = 0 elid = 1 DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) myMesh % eleminfo % hostData ( 1 , iel ) = selfQuadLinear ! Element Type myMesh % eleminfo % hostData ( 2 , iel ) = 1 ! Element Zone myMesh % eleminfo % hostData ( 3 , iel ) = sid ! Side Index Start sid = sid + 4 myMesh % eleminfo % hostData ( 4 , iel ) = sid ! Side Index End myMesh % eleminfo % hostData ( 5 , iel ) = nid - 1 ! Node Index Start DO j = 0 , nGeo DO i = 0 , nGeo myMesh % nodeCoords % hostData ( 1 : 2 , nid ) = xGeo % interior % hostData ( 1 : 2 , i , j , 1 , elid ) nid = nid + 1 END DO END DO myMesh % eleminfo % hostData ( 6 , iel ) = nid ! Node Index End elid = elid + 1 END DO END DO CALL myMesh % UpdateDevice () CALL xLinear % Free () CALL xGeo % Free () END SUBROUTINE UniformBlockMesh_Mesh2D","tags":"","loc":"proc/uniformblockmesh_mesh2d.html"},{"title":"UniformBlockMesh_Mesh3D – SELF","text":"public subroutine UniformBlockMesh_Mesh3D(myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem (1:3) real(kind=prec), intent(in) :: x (1:6) Calls proc~~uniformblockmesh_mesh3d~~CallsGraph proc~uniformblockmesh_mesh3d UniformBlockMesh_Mesh3D proc~uniformpoints UniformPoints proc~uniformblockmesh_mesh3d->proc~uniformpoints Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UniformBlockMesh_Mesh3D Source Code SUBROUTINE UniformBlockMesh_Mesh3D ( myMesh , nGeo , nElem , x ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( out ) :: myMesh INTEGER , INTENT ( in ) :: nGeo INTEGER , INTENT ( in ) :: nElem ( 1 : 3 ) REAL ( prec ), INTENT ( in ) :: x ( 1 : 6 ) ! Local INTEGER :: iel , jel , kel , nEl , elid INTEGER :: sid , nid , nNodes INTEGER :: nSides INTEGER :: i , j , k REAL ( prec ) :: xU ( 1 : nElem ( 1 ) + 1 ) REAL ( prec ) :: yU ( 1 : nElem ( 2 ) + 1 ) REAL ( prec ) :: zU ( 1 : nElem ( 3 ) + 1 ) TYPE ( Vector3D ) :: xLinear TYPE ( Vector3D ) :: xGeo nEl = nElem ( 1 ) * nElem ( 2 ) * nElem ( 3 ) nNodes = nel * ( nGeo + 1 ) * ( nGeo + 1 ) * ( nGeo + 1 ) nSides = ( nElem ( 1 ) + 1 ) * nElem ( 2 ) * nElem ( 3 ) + & ( nElem ( 2 ) + 1 ) * nElem ( 1 ) * nElem ( 3 ) + & ( nElem ( 3 ) + 1 ) * nElem ( 1 ) * nElem ( 2 ) CALL myMesh % Init ( nGeo , nEl , nSides , nNodes , 1 ) ! Set the nodeCoords xU = UniformPoints ( x ( 1 ), x ( 2 ), 1 , nElem ( 1 ) + 1 ) yU = UniformPoints ( x ( 3 ), x ( 4 ), 1 , nElem ( 2 ) + 1 ) zU = UniformPoints ( x ( 5 ), x ( 6 ), 1 , nElem ( 3 ) + 1 ) ! Create a linear interpolant to interpolate to nGeo grid CALL xLinear % Init ( 1 , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) CALL xGeo % Init ( nGeo , GAUSS_LOBATTO , & nGeo , GAUSS_LOBATTO , & 1 , nEl ) elid = 1 DO kel = 1 , nElem ( 3 ) DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) ! x component xLinear % interior % hostData ( 1 , 0 : 1 , 0 , 0 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 1 , 0 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 0 , 1 , 1 , elid ) = xU ( iel : iel + 1 ) xLinear % interior % hostData ( 1 , 0 : 1 , 1 , 1 , 1 , elid ) = xU ( iel : iel + 1 ) ! y component xLinear % interior % hostData ( 2 , 0 , 0 : 1 , 0 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 1 , 0 : 1 , 0 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 0 , 0 : 1 , 1 , 1 , elid ) = yU ( jel : jel + 1 ) xLinear % interior % hostData ( 2 , 1 , 0 : 1 , 1 , 1 , elid ) = yU ( jel : jel + 1 ) ! z component xLinear % interior % hostData ( 3 , 0 , 0 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) xLinear % interior % hostData ( 3 , 1 , 0 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) xLinear % interior % hostData ( 3 , 0 , 1 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) xLinear % interior % hostData ( 3 , 1 , 1 , 0 : 1 , 1 , elid ) = zU ( kel : kel + 1 ) ! Incremenent the element ID elid = elid + 1 END DO END DO END DO CALL xLinear % GridInterp ( xGeo ,. FALSE .) ! Set the element information nid = 1 sid = 0 elid = 1 DO kel = 1 , nElem ( 3 ) DO jel = 1 , nElem ( 2 ) DO iel = 1 , nElem ( 1 ) myMesh % eleminfo % hostData ( 1 , iel ) = selfQuadLinear ! Element Type myMesh % eleminfo % hostData ( 2 , iel ) = 1 ! Element Zone myMesh % eleminfo % hostData ( 3 , iel ) = sid ! Side Index Start sid = sid + 6 myMesh % eleminfo % hostData ( 4 , iel ) = sid ! Side Index End myMesh % eleminfo % hostData ( 5 , iel ) = nid - 1 ! Node Index Start DO k = 0 , nGeo DO j = 0 , nGeo DO i = 0 , nGeo myMesh % nodeCoords % hostData ( 1 : 3 , nid ) = xGeo % interior % hostData ( 1 : 3 , i , j , k , 1 , elid ) nid = nid + 1 END DO END DO END DO myMesh % eleminfo % hostData ( 6 , iel ) = nid ! Node Index End elid = elid + 1 END DO END DO END DO ! TO DO: Add Side information ! CALL myMesh % UpdateDevice () CALL xLinear % Free () CALL xGeo % Free () END SUBROUTINE UniformBlockMesh_Mesh3D","tags":"","loc":"proc/uniformblockmesh_mesh3d.html"},{"title":"UpdateDevice_Mesh1D – SELF","text":"public subroutine UpdateDevice_Mesh1D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh Contents Source Code UpdateDevice_Mesh1D Source Code SUBROUTINE UpdateDevice_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh #ifdef GPU CALL myMesh % elemInfo % UpdateDevice () CALL myMesh % nodeCoords % UpdateDevice () CALL myMesh % globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Mesh1D","tags":"","loc":"proc/updatedevice_mesh1d.html"},{"title":"UpdateDevice_Mesh2D – SELF","text":"public subroutine UpdateDevice_Mesh2D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh Contents Source Code UpdateDevice_Mesh2D Source Code SUBROUTINE UpdateDevice_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh #ifdef GPU CALL myMesh % elemInfo % UpdateDevice () CALL myMesh % sideInfo % UpdateDevice () CALL myMesh % nodeCoords % UpdateDevice () CALL myMesh % globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Mesh2D","tags":"","loc":"proc/updatedevice_mesh2d.html"},{"title":"UpdateDevice_Mesh3D – SELF","text":"public subroutine UpdateDevice_Mesh3D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh Contents Source Code UpdateDevice_Mesh3D Source Code SUBROUTINE UpdateDevice_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh #ifdef GPU CALL myMesh % elemInfo % UpdateDevice () CALL myMesh % sideInfo % UpdateDevice () CALL myMesh % nodeCoords % UpdateDevice () CALL myMesh % globalNodeIDs % UpdateDevice () CALL myMesh % BCType % UpdateDevice () #endif END SUBROUTINE UpdateDevice_Mesh3D","tags":"","loc":"proc/updatedevice_mesh3d.html"},{"title":"UpdateHost_Mesh1D – SELF","text":"public subroutine UpdateHost_Mesh1D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh Contents Source Code UpdateHost_Mesh1D Source Code SUBROUTINE UpdateHost_Mesh1D ( myMesh ) IMPLICIT NONE CLASS ( Mesh1D ), INTENT ( inout ) :: myMesh #ifdef GPU CALL myMesh % elemInfo % UpdateHost () CALL myMesh % nodeCoords % UpdateHost () CALL myMesh % globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () #endif END SUBROUTINE UpdateHost_Mesh1D","tags":"","loc":"proc/updatehost_mesh1d.html"},{"title":"UpdateHost_Mesh2D – SELF","text":"public subroutine UpdateHost_Mesh2D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh Contents Source Code UpdateHost_Mesh2D Source Code SUBROUTINE UpdateHost_Mesh2D ( myMesh ) IMPLICIT NONE CLASS ( Mesh2D ), INTENT ( inout ) :: myMesh #ifdef GPU CALL myMesh % elemInfo % UpdateHost () CALL myMesh % sideInfo % UpdateHost () CALL myMesh % nodeCoords % UpdateHost () CALL myMesh % globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () #endif END SUBROUTINE UpdateHost_Mesh2D","tags":"","loc":"proc/updatehost_mesh2d.html"},{"title":"UpdateHost_Mesh3D – SELF","text":"public subroutine UpdateHost_Mesh3D(myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh Contents Source Code UpdateHost_Mesh3D Source Code SUBROUTINE UpdateHost_Mesh3D ( myMesh ) IMPLICIT NONE CLASS ( Mesh3D ), INTENT ( inout ) :: myMesh #ifdef GPU CALL myMesh % elemInfo % UpdateHost () CALL myMesh % sideInfo % UpdateHost () CALL myMesh % nodeCoords % UpdateHost () CALL myMesh % globalNodeIDs % UpdateHost () CALL myMesh % BCType % UpdateHost () #endif END SUBROUTINE UpdateHost_Mesh3D","tags":"","loc":"proc/updatehost_mesh3d.html"},{"title":"ChebyshevGauss – SELF","text":"private subroutine ChebyshevGauss(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Called by proc~~chebyshevgauss~~CalledByGraph proc~chebyshevgauss ChebyshevGauss proc~chebyshevquadrature ChebyshevQuadrature proc~chebyshevquadrature->proc~chebyshevgauss Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ChebyshevGauss Source Code SUBROUTINE ChebyshevGauss ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local INTEGER :: j DO j = 0 , N weights ( j ) = pi / ( REAL ( N , real64 ) + 1.0_real64 ) nodes ( j ) = - cos ( 0.5_real64 * ( 2.0_real64 * REAL ( j , real64 ) + 1.0_real64 ) * weights ( j )) END DO END SUBROUTINE ChebyshevGauss","tags":"","loc":"proc/chebyshevgauss.html"},{"title":"ChebyshevGaussLobatto – SELF","text":"private subroutine ChebyshevGaussLobatto(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Called by proc~~chebyshevgausslobatto~~CalledByGraph proc~chebyshevgausslobatto ChebyshevGaussLobatto proc~chebyshevquadrature ChebyshevQuadrature proc~chebyshevquadrature->proc~chebyshevgausslobatto Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ChebyshevGaussLobatto Source Code SUBROUTINE ChebyshevGaussLobatto ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! LOCAL INTEGER :: j DO j = 0 , N weights ( j ) = pi / REAL ( N , real64 ) nodes ( j ) = - cos ( REAL ( j , real64 ) * weights ( j )) END DO weights ( 0 ) = weights ( 0 ) * 0.5_real64 weights ( N ) = weights ( N ) * 0.5_real64 END SUBROUTINE ChebyshevGaussLobatto","tags":"","loc":"proc/chebyshevgausslobatto.html"},{"title":"ChebyshevQuadrature – SELF","text":"public subroutine ChebyshevQuadrature(N, QuadType, nodes, weights) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: QuadType real(kind=real64), intent(out) :: nodes (0:N) real(kind=real64), intent(out) :: weights (0:N) Calls proc~~chebyshevquadrature~~CallsGraph proc~chebyshevquadrature ChebyshevQuadrature proc~chebyshevgauss ChebyshevGauss proc~chebyshevquadrature->proc~chebyshevgauss proc~chebyshevgausslobatto ChebyshevGaussLobatto proc~chebyshevquadrature->proc~chebyshevgausslobatto Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ChebyshevQuadrature Source Code SUBROUTINE ChebyshevQuadrature ( N , quadType , nodes , weights ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N REAL ( real64 ), INTENT ( out ) :: nodes ( 0 : N ) REAL ( real64 ), INTENT ( out ) :: weights ( 0 : N ) INTEGER , INTENT ( in ) :: QuadType ! Local REAL ( real64 ) :: nodesLocal ( 0 : N ) REAL ( real64 ) :: weightsLocal ( 0 : N ) INTEGER :: i IF ( QuadType == GAUSS_LOBATTO ) then CALL ChebyshevGaussLobatto ( N , nodesLocal , weightsLocal ) ELSEIF ( QuadType == GAUSS ) then CALL ChebyshevGauss ( N , nodesLocal , weightsLocal ) END IF DO i = 0 , N nodes ( i ) = REAL ( nodesLocal ( i ), prec ) weights ( i ) = REAL ( weightsLocal ( i ), prec ) ENDDO END SUBROUTINE ChebyshevQuadrature","tags":"","loc":"proc/chebyshevquadrature.html"},{"title":"LegendreGauss – SELF","text":"private subroutine LegendreGauss(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Calls proc~~legendregauss~~CallsGraph proc~legendregauss LegendreGauss proc~legendrepolynomial LegendrePolynomial proc~legendregauss->proc~legendrepolynomial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~legendregauss~~CalledByGraph proc~legendregauss LegendreGauss proc~legendrequadrature LegendreQuadrature proc~legendrequadrature->proc~legendregauss proc~init_lagrange Init_Lagrange proc~init_lagrange->proc~legendrequadrature Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code LegendreGauss Source Code SUBROUTINE LegendreGauss ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local REAL ( real64 ) :: nodes_local ( 0 : N ) REAL ( real64 ) :: weights_local ( 0 : N ) REAL ( real64 ) :: lN1 , dlN1 REAL ( real64 ) :: delta INTEGER :: j , kIt IF ( N == 0 ) then nodes_local ( 0 ) = 0.0_real64 weights_local ( 0 ) = 2.0_real64 ELSEIF ( N == 1 ) then nodes_local ( 0 ) = - SQRT ( 1.0_real64 / 3.0_real64 ) weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = - nodes ( 0 ) weights_local ( 1 ) = weights ( 0 ) ELSE DO j = 0 , (( N + 1 ) / 2 ) nodes_local ( j ) = - cos (( 2.0_real64 * REAL ( j , real64 ) + 1.0_real64 ) * pi / ( 2.0_real64 * REAL ( N , real64 ) + 1.0_real64 )) DO kIt = 1 , newtonMax CALL LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) delta = - lN1 / dlN1 nodes_local ( j ) = nodes_local ( j ) + delta IF ( abs ( delta ) <= TOL * nodes_local ( j )) EXIT END DO CALL LegendrePolynomial ( N + 1 , nodes_local ( j ), lN1 , dlN1 ) weights_local ( j ) = 2.0_real64 / (( 1.0_real64 - nodes_local ( j ) * nodes_local ( j )) * dlN1 * dlN1 ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) END DO END IF IF ( MOD ( REAL ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) then CALL LegendrePolynomial ( N + 1 , 0.0_real64 , lN1 , dlN1 ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0 / ( dlN1 * dlN1 ) END IF DO j = 0 , N nodes ( j ) = REAL ( nodes_local ( j ), real64 ) weights ( j ) = REAL ( weights_local ( j ), real64 ) END DO END SUBROUTINE LegendreGauss","tags":"","loc":"proc/legendregauss.html"},{"title":"LegendreGaussLobatto – SELF","text":"private subroutine LegendreGaussLobatto(N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) Calls proc~~legendregausslobatto~~CallsGraph proc~legendregausslobatto LegendreGaussLobatto proc~legendreqandl LegendreQandL proc~legendregausslobatto->proc~legendreqandl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~legendregausslobatto~~CalledByGraph proc~legendregausslobatto LegendreGaussLobatto proc~legendrequadrature LegendreQuadrature proc~legendrequadrature->proc~legendregausslobatto proc~init_lagrange Init_Lagrange proc~init_lagrange->proc~legendrequadrature Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code LegendreGaussLobatto Source Code SUBROUTINE LegendreGaussLobatto ( N , nodes , weights ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: nodes ( 0 : N ) REAL ( real64 ) :: weights ( 0 : N ) ! Local REAL ( real64 ) :: nodes_local ( 0 : N ) REAL ( real64 ) :: weights_local ( 0 : N ) REAL ( real64 ) :: delta , q , qprime , lN INTEGER :: j , kIt IF ( N == 1 ) then nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 1.0_real64 nodes_local ( 1 ) = 1.0_real64 weights_local ( 1 ) = 1.0_real64 ELSE nodes_local ( 0 ) = - 1.0_real64 weights_local ( 0 ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 )) nodes_local ( N ) = 1.0_real64 weights_local ( N ) = weights_local ( 0 ) DO j = 1 , (( N + 1 ) / 2 - 1 ) nodes_local ( j ) = - COS (( REAL ( j , real64 ) + 0.25_real64 ) * pi / REAL ( N , real64 ) - & 3.0_real64 / ( 8.0_real64 * REAL ( N , real64 ) * pi * ( REAL ( j , real64 ) + 0.25_real64 ))) DO kIt = 1 , newtonMax CALL LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) delta = - q / qprime nodes_local ( j ) = nodes_local ( j ) + delta IF ( ABS ( delta ) <= TOL * nodes_local ( j )) EXIT END DO CALL LegendreQandL ( N , nodes_local ( j ), q , qprime , lN ) weights_local ( j ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 ) * lN * lN ) weights_local ( N - j ) = weights_local ( j ) nodes_local ( N - j ) = - nodes_local ( j ) END DO END IF IF ( MOD ( REAL ( N , real64 ), 2.0_real64 ) == 0.0_real64 ) THEN CALL LegendreQandL ( N , 0.0_real64 , q , qprime , lN ) nodes_local ( N / 2 ) = 0.0_real64 weights_local ( N / 2 ) = 2.0_real64 / ( REAL ( N , real64 ) * ( REAL ( N , real64 ) + 1.0_real64 ) * lN * lN ) END IF DO j = 0 , N nodes ( j ) = REAL ( nodes_local ( j ), real64 ) weights ( j ) = REAL ( weights_local ( j ), real64 ) END DO END SUBROUTINE LegendreGaussLobatto","tags":"","loc":"proc/legendregausslobatto.html"},{"title":"LegendrePolynomial – SELF","text":"public subroutine LegendrePolynomial(N, x, lAtX, dLdxAtX) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: lAtX real(kind=real64) :: dLdxAtX Called by proc~~legendrepolynomial~~CalledByGraph proc~legendrepolynomial LegendrePolynomial proc~legendregauss LegendreGauss proc~legendregauss->proc~legendrepolynomial proc~legendrequadrature LegendreQuadrature proc~legendrequadrature->proc~legendregauss proc~init_lagrange Init_Lagrange proc~init_lagrange->proc~legendrequadrature Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code LegendrePolynomial Source Code SUBROUTINE LegendrePolynomial ( N , x , lAtX , dLdxAtX ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: x REAL ( real64 ) :: lAtX , dLdxAtX ! Local REAL ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 INTEGER :: i IF ( N == 0 ) then lAtX = 1.0_real64 dLdxAtX = 0.0_real64 ELSEIF ( N == 1 ) then lAtX = x dLdxAtX = 1.0_real64 ELSE lnM2 = 1.0_real64 lnM1 = x dlnM2 = 0.0_real64 dlnM1 = 1.0_real64 DO i = 2 , N lAtX = (( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * x * lnM1 - & ( REAL ( i , real64 ) - 1.0_real64 ) * lnM2 ) / ( REAL ( i , real64 )) dldxAtX = dlnM2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lnM1 lnM2 = lnM1 lnM1 = lAtX dlnM2 = dlnM1 dlnM1 = dldxAtX END DO END IF END SUBROUTINE LegendrePolynomial","tags":"","loc":"proc/legendrepolynomial.html"},{"title":"LegendreQandL – SELF","text":"private subroutine LegendreQandL(N, x, q, qprime, lN) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: q real(kind=real64) :: qprime real(kind=real64) :: lN Called by proc~~legendreqandl~~CalledByGraph proc~legendreqandl LegendreQandL proc~legendregausslobatto LegendreGaussLobatto proc~legendregausslobatto->proc~legendreqandl proc~legendrequadrature LegendreQuadrature proc~legendrequadrature->proc~legendregausslobatto proc~init_lagrange Init_Lagrange proc~init_lagrange->proc~legendrequadrature Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code LegendreQandL Source Code SUBROUTINE LegendreQandL ( N , x , q , qprime , lN ) IMPLICIT NONE INTEGER :: N REAL ( real64 ) :: x REAL ( real64 ) :: lN , q , qprime ! Local REAL ( real64 ) :: lNm1 , lNm2 , dlNm1 , dlNm2 , dlN , lN1 , dlN1 INTEGER :: i lNm2 = 1.0_real64 lNm1 = x dlNm2 = 0.0_real64 dlNm1 = 1.0_real64 DO i = 2 , N lN = ( 2.0_real64 * i - 1.0_real64 ) / ( REAL ( i , real64 )) * x * lNm1 - ( REAL ( i , real64 ) - 1.0_real64 ) / ( REAL ( i , real64 )) * lNm2 dlN = dlNm2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lNm1 lNm2 = lNm1 lNm1 = lN dlNm2 = dlNm1 dlNm1 = dlN END DO i = N + 1 lN1 = ( 2.0_real64 * i - 1.0_real64 ) / ( REAL ( i , real64 )) * x * lN - ( REAL ( i , real64 ) - 1.0_real64 ) / ( REAL ( i , real64 )) * lNm2 dlN1 = dlNm2 + ( 2.0_real64 * REAL ( i , real64 ) - 1.0_real64 ) * lNm1 q = lN1 - lNm2 qprime = dlN1 - dlNm2 END SUBROUTINE LegendreQandL","tags":"","loc":"proc/legendreqandl.html"},{"title":"LegendreQuadrature – SELF","text":"public subroutine LegendreQuadrature(N, nodes, weights, QuadType) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=prec), intent(out) :: nodes (0:N) real(kind=prec), intent(out) :: weights (0:N) integer, intent(in) :: QuadType Calls proc~~legendrequadrature~~CallsGraph proc~legendrequadrature LegendreQuadrature proc~legendregausslobatto LegendreGaussLobatto proc~legendrequadrature->proc~legendregausslobatto proc~legendregauss LegendreGauss proc~legendrequadrature->proc~legendregauss proc~legendreqandl LegendreQandL proc~legendregausslobatto->proc~legendreqandl proc~legendrepolynomial LegendrePolynomial proc~legendregauss->proc~legendrepolynomial Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~legendrequadrature~~CalledByGraph proc~legendrequadrature LegendreQuadrature proc~init_lagrange Init_Lagrange proc~init_lagrange->proc~legendrequadrature Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code LegendreQuadrature Source Code SUBROUTINE LegendreQuadrature ( N , nodes , weights , QuadType ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N REAL ( prec ), INTENT ( out ) :: nodes ( 0 : N ) REAL ( prec ), INTENT ( out ) :: weights ( 0 : N ) INTEGER , INTENT ( in ) :: QuadType ! Local REAL ( real64 ) :: nodesLocal ( 0 : N ) REAL ( real64 ) :: weightsLocal ( 0 : N ) INTEGER :: i IF ( QuadType == GAUSS_LOBATTO ) THEN CALL LegendreGaussLobatto ( N , nodesLocal , weightsLocal ) ELSEIF ( QuadType == GAUSS ) THEN CALL LegendreGauss ( N , nodesLocal , weightsLocal ) END IF DO i = 0 , N nodes ( i ) = REAL ( nodesLocal ( i ), prec ) weights ( i ) = REAL ( weightsLocal ( i ), prec ) ENDDO END SUBROUTINE LegendreQuadrature","tags":"","loc":"proc/legendrequadrature.html"},{"title":"AlmostEqual – SELF","text":"public function AlmostEqual(a, b) result(AisB) \\addtogroup SELF_SupportRoutines\n @{\n \\fn AlmostEqual\n Compares two floating point numbers and determines if they are equal (to machine precision). This function is from Alg. 139 on pg. 359 of D.A. Kopriva, 2009, \"Implementing Spectral Element\n    Methods for Scientists and Engineers\" Usage : Logical :: AisB REAL (prec) :: a, b .... AisB = AlmostEqual( a, b ) Parameters : in a REAL(prec) scalar in b REAL(prec) scalar in AisB Logical .TRUE. IF a=b to machine precision .FALSE. otherwise @} Arguments Type Intent Optional Attributes Name real(kind=real64) :: a real(kind=real64) :: b Return Value logical Called by proc~~almostequal~~CalledByGraph proc~almostequal AlmostEqual proc~calculateinterpolationmatrix CalculateInterpolationMatrix proc~calculateinterpolationmatrix->proc~almostequal proc~calculatelagrangepolynomials CalculateLagrangePolynomials proc~calculatelagrangepolynomials->proc~almostequal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code AlmostEqual Source Code FUNCTION AlmostEqual ( a , b ) RESULT ( AisB ) IMPLICIT NONE REAL ( real64 ) :: a , b LOGICAL :: AisB IF ( a == 0.0_real64 . OR . b == 0.0_real64 ) THEN IF ( ABS ( a - b ) <= EPSILON ( 1.0_real64 )) THEN AisB = . TRUE . ELSE AisB = . FALSE . END IF ELSE IF (( abs ( a - b ) <= EPSILON ( 1.0_real64 ) * abs ( a )) . OR . ( abs ( a - b ) <= EPSILON ( 1.0_real64 ) * abs ( b ))) THEN AisB = . TRUE . ELSE AisB = . FALSE . END IF END IF END FUNCTION AlmostEqual","tags":"","loc":"proc/almostequal.html"},{"title":"CompareArray – SELF","text":"public function CompareArray(arrayOne, arrayTwo, N) result(arraysMatch) \\addtogroup SELF_SupportRoutines\n @{\n \\fn CompareArray\n Compares to INTEGER arrays and determines if they are identical. A logical is returned that specifies whether or not two arrays are identical. To determine\n if the two arrays are identical, the sum of the difference between each element in the input\n array is calculated. If the arrays are identical, each contribution to the sum is zero and hence\n the sum is zero. If the sum is non-zero, the arrays are distinct. This routine is used in the \\ref HexMeshClass module. A face of an element in an unstructured\n mesh is identified by its four corner nodes. When identifying unique faces in an unstructured\n mesh, we need to determine if two elements share a face. This can be accomplished by comparing\n the four corner nodes (from each element) that define each face. Usage : INTEGER :: N INTEGER :: arrayOne(1:N) INTEGER :: arrayTwo(1:N) LOGICAL :: arraysMatch .... arraysMatch = CompareArray( arrayOne, arrayTwo, N ) Parameters : in arrayOne(1:N) INTEGER in arrayTwo(1:N) INTEGER in N INTEGER out arraysMatch INTEGER @} Arguments Type Intent Optional Attributes Name integer :: arrayOne (1:N) integer :: arrayTwo (1:N) integer :: N Return Value logical Contents Source Code CompareArray Source Code FUNCTION CompareArray ( arrayOne , arrayTwo , N ) RESULT ( arraysMatch ) IMPLICIT NONE INTEGER :: N INTEGER :: arrayOne ( 1 : N ), arrayTwo ( 1 : N ) LOGICAL :: arraysMatch ! LOCAL INTEGER :: i , theSumOfDiffs theSumOfDiffs = 0 DO i = 1 , N theSumOfDiffs = theSumOfDiffs + arrayOne ( i ) - arrayTwo ( i ) END DO IF ( theSumOfDiffs == 0 ) THEN arraysMatch = . TRUE . ELSE arraysMatch = . FALSE . END IF END FUNCTION CompareArray","tags":"","loc":"proc/comparearray.html"},{"title":"Determinant – SELF","text":"public recursive function Determinant(A, N) result(D) \\addtogroup SELF_SupportRoutines\n @{\n \\fn Determinant\n A recursive function that calculates the determinant of an \\f$ N\\times N \\f$ matrix. This function is used in the functions \\ref invert_2x2 and \\ref invert_3x3 This function depends on Function \\ref getminor Usage : INTEGER :: N REAL (prec) :: A(1:N,1:N), D .... D = Determinant( A, N ) Parameters : in A(1:N,1:N) REAL(prec) Square matrix in N INTEGER Dimension of the matrix out detA REAL(prec) The determinant of the matrix @} Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:N,1:N) integer :: N Return Value real(kind=prec) Calls proc~~determinant~~CallsGraph proc~determinant Determinant proc~getminor GetMinor proc~determinant->proc~getminor proc~determinant->proc~determinant Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~determinant~~CalledByGraph proc~determinant Determinant proc~determinant->proc~determinant proc~invert_3x3 Invert_3x3 proc~invert_3x3->proc~determinant proc~invert_2x2 Invert_2x2 proc~invert_2x2->proc~determinant Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Determinant Source Code RECURSIVE FUNCTION Determinant ( A , N ) RESULT ( D ) IMPLICIT NONE INTEGER :: N REAL ( prec ) :: A ( 1 : N , 1 : N ) REAL ( prec ) :: D ! LOCAL REAL ( prec ) :: M ( 1 : N - 1 , 1 : N - 1 ) INTEGER :: j IF ( N == 2 ) THEN D = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) RETURN ELSE D = 0.0_prec DO j = 1 , N M = GetMinor ( A , 1 , j , N ) D = D + ( - 1.0_prec ) ** ( j + 1 ) * A ( 1 , j ) * Determinant ( M , N - 1 ) END DO END IF END FUNCTION Determinant","tags":"","loc":"proc/determinant.html"},{"title":"Float2Str – SELF","text":"public function Float2Str(aNumber) result(aString) Arguments Type Intent Optional Attributes Name real(kind=prec) :: aNumber Return Value character(len=12) Called by proc~~float2str~~CalledByGraph proc~float2str Float2Str proc~vectorinterp2d_test VectorInterp2D_Test proc~vectorinterp2d_test->proc~float2str proc~vectordivergence2d_test VectorDivergence2D_Test proc~vectordivergence2d_test->proc~float2str proc~vectorinterp3d_test VectorInterp3D_Test proc~vectorinterp3d_test->proc~float2str proc~blockmesh3d_test BlockMesh3D_Test proc~blockmesh3d_test->proc~float2str proc~tensorinterp3d_test TensorInterp3D_Test proc~tensorinterp3d_test->proc~float2str proc~vectorboundaryinterp2d_test VectorBoundaryInterp2D_Test proc~vectorboundaryinterp2d_test->proc~float2str proc~tensorboundaryinterp2d_test TensorBoundaryInterp2D_Test proc~tensorboundaryinterp2d_test->proc~float2str proc~scalarboundaryinterp2d_test ScalarBoundaryInterp2D_Test proc~scalarboundaryinterp2d_test->proc~float2str proc~vectorgradient2d_test VectorGradient2D_Test proc~vectorgradient2d_test->proc~float2str proc~tensorboundaryinterp3d_test TensorBoundaryInterp3D_Test proc~tensorboundaryinterp3d_test->proc~float2str proc~blockmesh1d_test BlockMesh1D_Test proc~blockmesh1d_test->proc~float2str proc~scalarboundaryinterp3d_test ScalarBoundaryInterp3D_Test proc~scalarboundaryinterp3d_test->proc~float2str proc~tensorinterp2d_test TensorInterp2D_Test proc~tensorinterp2d_test->proc~float2str proc~vectorgradient3d_test VectorGradient3D_Test proc~vectorgradient3d_test->proc~float2str proc~scalarinterp3d_test ScalarInterp3D_Test proc~scalarinterp3d_test->proc~float2str proc~scalargradient2d_test ScalarGradient2D_Test proc~scalargradient2d_test->proc~float2str proc~scalarboundaryinterp1d_test ScalarBoundaryInterp1D_Test proc~scalarboundaryinterp1d_test->proc~float2str proc~scalarinterp1d_test ScalarInterp1D_Test proc~scalarinterp1d_test->proc~float2str proc~scalarinterp2d_test ScalarInterp2D_Test proc~scalarinterp2d_test->proc~float2str proc~vectorboundaryinterp3d_test VectorBoundaryInterp3D_Test proc~vectorboundaryinterp3d_test->proc~float2str proc~vectordivergence3d_test VectorDivergence3D_Test proc~vectordivergence3d_test->proc~float2str proc~scalarderivative1d_test ScalarDerivative1D_Test proc~scalarderivative1d_test->proc~float2str proc~scalargradient3d_test ScalarGradient3D_Test proc~scalargradient3d_test->proc~float2str proc~blockmesh2d_test BlockMesh2D_Test proc~blockmesh2d_test->proc~float2str program~self SELF program~self->proc~vectorinterp3d_test program~self->proc~blockmesh3d_test program~self->proc~tensorinterp3d_test program~self->proc~scalarboundaryinterp2d_test program~self->proc~tensorboundaryinterp3d_test program~self->proc~blockmesh1d_test program~self->proc~scalarboundaryinterp3d_test program~self->proc~vectorgradient3d_test program~self->proc~scalarinterp3d_test program~self->proc~scalarboundaryinterp1d_test program~self->proc~scalarinterp1d_test program~self->proc~scalarinterp2d_test program~self->proc~vectorboundaryinterp3d_test program~self->proc~vectordivergence3d_test program~self->proc~scalarderivative1d_test program~self->proc~scalargradient3d_test program~self->proc~blockmesh2d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Float2Str Source Code FUNCTION Float2Str ( aNumber ) RESULT ( aString ) IMPLICIT NONE REAL ( prec ) :: aNumber CHARACTER ( 12 ) :: aString WRITE ( aString , '(E12.4)' ) aNumber END FUNCTION Float2Str","tags":"","loc":"proc/float2str.html"},{"title":"FloorCURT – SELF","text":"public function FloorCURT(x) result(curtX) Arguments Type Intent Optional Attributes Name integer :: x Return Value integer Contents Source Code FloorCURT Source Code FUNCTION FloorCURT ( x ) RESULT ( curtX ) INTEGER :: x , curtX ! Local INTEGER :: i , res IF ( x == 0 . OR . x == 1 ) THEN curtX = x ELSE res = 1 i = 1 DO WHILE ( res <= x ) i = i + 1 res = i * i * i END DO curtX = i - 1 END IF END FUNCTION FloorCURT","tags":"","loc":"proc/floorcurt.html"},{"title":"FloorSQRT – SELF","text":"public function FloorSQRT(x) result(sqrtX) Arguments Type Intent Optional Attributes Name integer :: x Return Value integer Contents Source Code FloorSQRT Source Code FUNCTION FloorSQRT ( x ) RESULT ( sqrtX ) INTEGER :: x , sqrtX ! Local INTEGER :: i , res IF ( x == 0 . OR . x == 1 ) THEN sqrtX = x ELSE res = 1 i = 1 DO WHILE ( res <= x ) i = i + 1 res = i * i END DO sqrtX = i - 1 END IF END FUNCTION FloorSQRT","tags":"","loc":"proc/floorsqrt.html"},{"title":"GetMinor – SELF","text":"public function GetMinor(A, i, j, N) result(M) \\addtogroup SELF_SupportRoutines\n @{\n \\fn GetMinor\n Returns the submatrix obtained by removing a given row and column of the input matrix. The minor of a matrix is used in calculating the determinant of a matrix. Usage : INTEGER :: i, j, N REAL (prec) :: A(1:N,1:N), M(1:N-1,1:N-1) .... M = GetMinor( A, i, j, N ) Usage : TYPE (DataType) :: this .... CALL this % RoutineName( Inputs/Outputs ) Parameters : in A(1:N,1:N) REAL(prec) Square matrix in i INTEGER The row that is removed from A to form the minor of A in j INTEGER The column that is removed from A to form the minor of A in N INTEGER The dimension of A in M(1:N-1,1:N-1) REAL(prec) The (i,j) minor of A @} Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:N,1:N) integer :: i integer :: j integer :: N Return Value real(kind=prec)\n  (1:N-1,1:N-1) Called by proc~~getminor~~CalledByGraph proc~getminor GetMinor proc~determinant Determinant proc~determinant->proc~getminor proc~determinant->proc~determinant proc~invert_3x3 Invert_3x3 proc~invert_3x3->proc~determinant proc~invert_2x2 Invert_2x2 proc~invert_2x2->proc~determinant Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code GetMinor Source Code FUNCTION GetMinor ( A , i , j , N ) RESULT ( M ) IMPLICIT NONE INTEGER :: i , j , N REAL ( prec ) :: A ( 1 : N , 1 : N ) REAL ( prec ) :: M ( 1 : N - 1 , 1 : N - 1 ) ! LOCAL INTEGER :: row , col INTEGER :: thisRow , thisCol thisRow = 0 DO row = 1 , N ! loop over the rows of A IF ( row /= i ) THEN thisRow = thisRow + 1 thisCol = 0 DO col = 1 , N ! loop over the columns of A IF ( col /= j ) THEN thisCol = thisCol + 1 M ( thisRow , thisCol ) = A ( row , col ) END IF END DO ! col, loop over the columns of A END IF END DO ! row, loop over the rows of A END FUNCTION GetMinor","tags":"","loc":"proc/getminor.html"},{"title":"Int2Str – SELF","text":"public function Int2Str(aNumber) result(aString) Arguments Type Intent Optional Attributes Name integer :: aNumber Return Value character(len=12) Called by proc~~int2str~~CalledByGraph proc~int2str Int2Str proc~vectorinterp2d_test VectorInterp2D_Test proc~vectorinterp2d_test->proc~int2str proc~vectordivergence2d_test VectorDivergence2D_Test proc~vectordivergence2d_test->proc~int2str proc~vectorinterp3d_test VectorInterp3D_Test proc~vectorinterp3d_test->proc~int2str proc~blockmesh3d_test BlockMesh3D_Test proc~blockmesh3d_test->proc~int2str proc~tensorinterp3d_test TensorInterp3D_Test proc~tensorinterp3d_test->proc~int2str proc~vectorboundaryinterp2d_test VectorBoundaryInterp2D_Test proc~vectorboundaryinterp2d_test->proc~int2str proc~tensorboundaryinterp2d_test TensorBoundaryInterp2D_Test proc~tensorboundaryinterp2d_test->proc~int2str proc~scalarboundaryinterp2d_test ScalarBoundaryInterp2D_Test proc~scalarboundaryinterp2d_test->proc~int2str proc~vectorgradient2d_test VectorGradient2D_Test proc~vectorgradient2d_test->proc~int2str proc~tensorboundaryinterp3d_test TensorBoundaryInterp3D_Test proc~tensorboundaryinterp3d_test->proc~int2str proc~blockmesh1d_test BlockMesh1D_Test proc~blockmesh1d_test->proc~int2str proc~scalarboundaryinterp3d_test ScalarBoundaryInterp3D_Test proc~scalarboundaryinterp3d_test->proc~int2str proc~tensorinterp2d_test TensorInterp2D_Test proc~tensorinterp2d_test->proc~int2str proc~vectorgradient3d_test VectorGradient3D_Test proc~vectorgradient3d_test->proc~int2str proc~scalarinterp3d_test ScalarInterp3D_Test proc~scalarinterp3d_test->proc~int2str proc~scalargradient2d_test ScalarGradient2D_Test proc~scalargradient2d_test->proc~int2str proc~scalarboundaryinterp1d_test ScalarBoundaryInterp1D_Test proc~scalarboundaryinterp1d_test->proc~int2str proc~scalarinterp1d_test ScalarInterp1D_Test proc~scalarinterp1d_test->proc~int2str proc~scalarinterp2d_test ScalarInterp2D_Test proc~scalarinterp2d_test->proc~int2str proc~vectorboundaryinterp3d_test VectorBoundaryInterp3D_Test proc~vectorboundaryinterp3d_test->proc~int2str proc~vectordivergence3d_test VectorDivergence3D_Test proc~vectordivergence3d_test->proc~int2str proc~scalarderivative1d_test ScalarDerivative1D_Test proc~scalarderivative1d_test->proc~int2str proc~scalargradient3d_test ScalarGradient3D_Test proc~scalargradient3d_test->proc~int2str proc~blockmesh2d_test BlockMesh2D_Test proc~blockmesh2d_test->proc~int2str program~self SELF program~self->proc~vectorinterp3d_test program~self->proc~blockmesh3d_test program~self->proc~tensorinterp3d_test program~self->proc~scalarboundaryinterp2d_test program~self->proc~tensorboundaryinterp3d_test program~self->proc~blockmesh1d_test program~self->proc~scalarboundaryinterp3d_test program~self->proc~vectorgradient3d_test program~self->proc~scalarinterp3d_test program~self->proc~scalarboundaryinterp1d_test program~self->proc~scalarinterp1d_test program~self->proc~scalarinterp2d_test program~self->proc~vectorboundaryinterp3d_test program~self->proc~vectordivergence3d_test program~self->proc~scalarderivative1d_test program~self->proc~scalargradient3d_test program~self->proc~blockmesh2d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Int2Str Source Code FUNCTION Int2Str ( aNumber ) RESULT ( aString ) IMPLICIT NONE INTEGER :: aNumber CHARACTER ( 12 ) :: aString WRITE ( aString , '(I9)' ) aNumber END FUNCTION Int2Str","tags":"","loc":"proc/int2str.html"},{"title":"InvertSpectralOpMatrix – SELF","text":"public function InvertSpectralOpMatrix(A, N) result(Ainv) Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (0:N,0:N) integer :: N Return Value real(kind=prec)\n  (0:N,0:N) Contents Source Code InvertSpectralOpMatrix Source Code FUNCTION InvertSpectralOpMatrix ( A , N ) RESULT ( Ainv ) ! Inverts an (N+1)x(N+1) matrix using a polynomial representation of the ! inverse IMPLICIT NONE INTEGER :: N REAL ( prec ) :: A ( 0 : N , 0 : N ) REAL ( prec ) :: Ainv ( 0 : N , 0 : N ) ! Local INTEGER :: row , col , j , iter REAL ( prec ) :: I ( 0 : N , 0 : N ) REAL ( prec ) :: Ainv_ij , maxChange Ainv = 0.0_prec I = 0.0_prec DO row = 0 , N Ainv ( row , row ) = 1.0_prec I ( row , row ) = 1.0_prec END DO DO iter = 1 , maxInverseIters maxChange = 0.0_prec DO col = 0 , N DO row = 0 , N Ainv_ij = 0.0_prec DO j = 0 , N Ainv_ij = Ainv_ij + Ainv ( j , col ) * ( I ( row , j ) - A ( row , j )) END DO maxChange = MAX ( ABS ( Ainv ( row , col ) - Ainv_ij ), maxChange ) Ainv ( row , col ) = Ainv_ij END DO END DO IF ( maxChange <= tolerance ) THEN PRINT * , ' InvertSpectralOpMatrix : Converged in ' , iter , ' iterations.' EXIT END IF END DO IF ( maxChange > tolerance ) THEN PRINT * , 'InvertSpectralOpMatrix : Did not converge.' , maxChange END IF END FUNCTION InvertSpectralOpMatrix","tags":"","loc":"proc/invertspectralopmatrix.html"},{"title":"Invert_2x2 – SELF","text":"public function Invert_2x2(A) result(Ainv) \\addtogroup SELF_SupportRoutines\n @{\n \\fn Invert_2x2\n  Computes the inverse of a 2x2 matrix using Kramer's rule. This Function depends on \\ref determinant Usage : REAL (prec) :: A(1:2,1:2), Ainv(1:2,1:2) .... Ainv = Invert_2x2( A ) Parameters : in A(1:2,1:2) REAL(prec) Real 2x2 matrix in Ainv(1:2,1:2) REAL(prec) Real 2x2 matrix, inverse of A @} Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:2,1:2) Return Value real(kind=prec)\n  (1:2,1:2) Calls proc~~invert_2x2~~CallsGraph proc~invert_2x2 Invert_2x2 proc~determinant Determinant proc~invert_2x2->proc~determinant proc~getminor GetMinor proc~determinant->proc~getminor proc~determinant->proc~determinant Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Invert_2x2 Source Code FUNCTION Invert_2x2 ( A ) RESULT ( Ainv ) IMPLICIT NONE REAL ( prec ) :: A ( 1 : 2 , 1 : 2 ) REAL ( prec ) :: Ainv ( 1 : 2 , 1 : 2 ) ! LOCAL REAL ( prec ) :: detA detA = Determinant ( A , 2 ) Ainv ( 1 , 1 ) = A ( 2 , 2 ) / detA Ainv ( 2 , 2 ) = A ( 1 , 1 ) / detA Ainv ( 1 , 2 ) = - A ( 1 , 2 ) / detA Ainv ( 2 , 1 ) = - A ( 2 , 1 ) / detA END FUNCTION Invert_2x2","tags":"","loc":"proc/invert_2x2.html"},{"title":"Invert_3x3 – SELF","text":"public function Invert_3x3(A) result(Ainv) \\addtogroup SELF_SupportRoutines\n @{\n \\fn Invert_3x3\n  Computes the inverse of a 3x3 matrix using Kramer's rule. This Function depends on \\ref determinant Usage : REAL (prec) :: A(1:3,1:3), Ainv(1:3,1:3) .... Ainv = Invert_3x3( A ) Parameters : in A(1:3,1:3) REAL(prec) Real 3x3 matrix in Ainv(1:3,1:3) REAL(prec) Real 3x3 matrix, inverse of A @} Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:3,1:3) Return Value real(kind=prec)\n  (1:3,1:3) Calls proc~~invert_3x3~~CallsGraph proc~invert_3x3 Invert_3x3 proc~determinant Determinant proc~invert_3x3->proc~determinant proc~getminor GetMinor proc~determinant->proc~getminor proc~determinant->proc~determinant Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Invert_3x3 Source Code FUNCTION Invert_3x3 ( A ) RESULT ( Ainv ) ! ! =============================================================================================== ! IMPLICIT NONE REAL ( prec ) :: A ( 1 : 3 , 1 : 3 ) REAL ( prec ) :: Ainv ( 1 : 3 , 1 : 3 ) ! LOCAL REAL ( prec ) :: detA REAL ( prec ) :: submat ( 1 : 2 , 1 : 2 ) REAL ( prec ) :: detSubmat detA = Determinant ( A , 3 ) ! Row 1 column 1 of inverse (use submatrix neglecting row 1 and column 1 of A) submat = A ( 2 : 3 , 2 : 3 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 1 , 1 ) = detSubmat / detA ! Row 1 column 2 of inverse (use submatrix neglecting row 2 and column 1 of A) submat = A ( 1 : 3 : 2 , 2 : 3 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 1 , 2 ) = - detSubmat / detA ! Row 1 column 3 of inverse (use submatrix neglecting row 3 and column 1 of A) submat = A ( 1 : 2 , 2 : 3 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 1 , 3 ) = detSubmat / detA ! Row 2 column 1 of inverse (use submatrix neglecting row 1 and column 2 of A) submat = A ( 2 : 3 , 1 : 3 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 2 , 1 ) = - detSubmat / detA ! Row 2 column 2 of inverse (use submatrix neglecting row 2 and column 2 of A) submat = A ( 1 : 3 : 2 , 1 : 3 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 2 , 2 ) = detSubmat / detA ! Row 2 column 3 of inverse (use submatrix neglecting row 3 and column 2 of A) submat = A ( 1 : 2 , 1 : 3 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 2 , 3 ) = - detSubmat / detA ! Row 3 column 1 of inverse (use submatrix neglecting row 1 and column 3 of A) submat = A ( 2 : 3 , 1 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 3 , 1 ) = detSubmat / detA ! Row 3 column 2 of inverse (use submatrix neglecting row 2 and column 3 of A) submat = A ( 1 : 3 : 2 , 1 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 3 , 2 ) = - detSubmat / detA ! Row 3 column 3 of inverse (use submatrix neglecting row 3 and column 3 of A) submat = A ( 1 : 2 , 1 : 2 ) detSubmat = Determinant ( submat , 2 ) Ainv ( 3 , 3 ) = detSubmat / detA END FUNCTION Invert_3x3","tags":"","loc":"proc/invert_3x3.html"},{"title":"IsInf – SELF","text":"public function IsInf(a) Arguments Type Intent Optional Attributes Name real(kind=prec) :: a Return Value logical Contents Source Code IsInf Source Code LOGICAL FUNCTION IsInf ( a ) IMPLICIT NONE REAL ( prec ) :: a IF ( a > HUGE ( prec )) THEN IsInf = . TRUE . ELSE IsInf = . FALSE . END IF RETURN END FUNCTION IsInf","tags":"","loc":"proc/isinf.html"},{"title":"IsNaN – SELF","text":"public function IsNaN(a) Arguments Type Intent Optional Attributes Name real(kind=prec) :: a Return Value logical Contents Source Code IsNaN Source Code LOGICAL FUNCTION IsNaN ( a ) IMPLICIT NONE REAL ( prec ) :: a IF ( a . ne . a ) THEN IsNaN = . TRUE . ELSE IsNaN = . FALSE . END IF RETURN END FUNCTION IsNaN","tags":"","loc":"proc/isnan.html"},{"title":"NewUnit – SELF","text":"public function NewUnit(thisunit) \\addtogroup SELF_SupportRoutines\n @{\n \\fn NewUnit\n Returns a file unit identifier that is currently not in use. Usage : INTEGER :: thisUnit .... OPEN ( UNIT=NewUnit(thisUnit), FILE=filename) Parameters : out thisunit INTEGER File unit that is not in use @} Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: thisunit Return Value integer Contents Source Code NewUnit Source Code INTEGER FUNCTION NewUnit ( thisunit ) IMPLICIT NONE INTEGER , INTENT ( out ), OPTIONAL :: thisunit ! Local INTEGER , PARAMETER :: unitMin = 100 , unitMax = 1000 LOGICAL :: isopened INTEGER :: iUnit newunit = - 1 DO iUnit = unitMin , unitMax ! Check to see IF this UNIT is opened INQUIRE ( UNIT = iUnit , opened = isopened ) IF (. not . isopened ) THEN newunit = iUnit EXIT END IF END DO IF ( PRESENT ( thisunit )) thisunit = newunit END FUNCTION NewUnit","tags":"","loc":"proc/newunit.html"},{"title":"TimeStamp – SELF","text":"public function TimeStamp(time, units) result(timeStampString) Arguments Type Intent Optional Attributes Name real(kind=prec) :: time character(len=1) :: units Return Value character(len=13) Contents Source Code TimeStamp Source Code FUNCTION TimeStamp ( time , units ) RESULT ( timeStampString ) IMPLICIT NONE REAL ( prec ) :: time CHARACTER ( 1 ) :: units CHARACTER ( 13 ) :: timeStampString ! Local INTEGER :: day , minute , hour , second , millisecond CHARACTER ( 4 ) :: dayStamp CHARACTER ( 2 ) :: hourStamp , minuteStamp , secondStamp CHARACTER ( 3 ) :: milliSecondStamp REAL ( real64 ) :: time_real64 time_real64 = REAL ( time , real64 ) ! Units in \"seconds\" IF ( units ( 1 : 1 ) == 's' ) THEN ! Obtain the day day = INT ( time_real64 / 8640 0.0_real64 ) hour = INT (( time_real64 & - 8640 0.0_real64 * day ) / 360 0.0_real64 ) minute = INT (( time_real64 & - 360 0.0_real64 * hour & - 8640 0.0_real64 * day ) / 6 0.0_real64 ) second = INT (( time_real64 & - 6 0.0_real64 * minute & - 360 0.0_real64 * hour & - 8640 0.0_real64 * day )) milliSecond = NINT ((( time_real64 & - 6 0.0_real64 * minute & - 360 0.0_real64 * hour & - 8640 0.0_real64 * day ) & - REAL ( second , real64 )) * 100 0.0_real64 ) WRITE ( dayStamp , '(I4.4)' ) day WRITE ( hourStamp , '(I2.2)' ) hour WRITE ( minuteStamp , '(I2.2)' ) minute WRITE ( secondStamp , '(I2.2)' ) second WRITE ( milliSecondStamp , '(I3.3)' ) millisecond timeStampString = dayStamp // hourStamp // minuteStamp // secondStamp // milliSecondStamp ! minutes ELSEIF ( units ( 1 : 1 ) == 'm' ) THEN ! hours ELSEIF ( units ( 1 : 1 ) == 'h' ) THEN END IF END FUNCTION TimeStamp","tags":"","loc":"proc/timestamp.html"},{"title":"UniformPoints – SELF","text":"public function UniformPoints(a, b, firstInd, lastInd) result(xU) \\addtogroup SELF_SupportRoutines\n @{\n \\fn UniformPoints\n Generates a REAL(prec) array of N points evenly spaced between two points. Usage : REAL (prec) :: a REAL (prec) :: b REAL (prec) :: xU(0:N) INTEGER :: N .... xU = UniformPoints( a, b, N ) Parameters : in a REAL(prec) Starting point of the interval in b REAL(prec) Ending point of the interval in N INTEGER The number of points in the interval \\f$[a,b]\\f$ in xU(0:N) REAL(prec) Array of evenly spaced points in the interval \\f$[a,b]\\f$ @} Arguments Type Intent Optional Attributes Name real(kind=prec) :: a real(kind=prec) :: b integer :: firstInd integer :: lastInd Return Value real(kind=prec)\n  (firstInd:lastInd) Called by proc~~uniformpoints~~CalledByGraph proc~uniformpoints UniformPoints proc~init_lagrange Init_Lagrange proc~init_lagrange->proc~uniformpoints proc~uniformblockmesh_mesh1d UniformBlockMesh_Mesh1D proc~uniformblockmesh_mesh1d->proc~uniformpoints proc~uniformblockmesh_mesh2d UniformBlockMesh_Mesh2D proc~uniformblockmesh_mesh2d->proc~uniformpoints proc~uniformblockmesh_mesh3d UniformBlockMesh_Mesh3D proc~uniformblockmesh_mesh3d->proc~uniformpoints Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UniformPoints Source Code FUNCTION UniformPoints ( a , b , firstInd , lastInd ) RESULT ( xU ) IMPLICIT NONE REAL ( prec ) :: a , b INTEGER :: firstInd , lastInd REAL ( prec ) :: xU ( firstInd : lastInd ) ! LOCAL REAL ( prec ) :: dx INTEGER :: i dx = ( b - a ) / REAL (( lastInd - firstInd ), prec ) DO i = firstInd , lastInd xU ( i ) = a + dx * REAL ( i - firstInd , prec ) END DO END FUNCTION UniformPoints","tags":"","loc":"proc/uniformpoints.html"},{"title":"UpperCase – SELF","text":"public function UpperCase(str) result(Upper) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=LEN(str)) Called by proc~~uppercase~~CalledByGraph proc~uppercase UpperCase program~self SELF program~self->proc~uppercase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpperCase Source Code FUNCTION UpperCase ( str ) RESULT ( upper ) Implicit None CHARACTER ( * ), INTENT ( In ) :: str CHARACTER ( LEN ( str )) :: Upper INTEGER :: ic , i CHARACTER ( 27 ), PARAMETER :: cap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ ' CHARACTER ( 27 ), PARAMETER :: low = 'abcdefghijklmnopqrstuvwxyz ' DO i = 1 , LEN ( str ) ic = INDEX ( low , str ( i : i )) IF ( ic > 0 ) THEN Upper ( i : i ) = cap ( ic : ic ) ELSE Upper ( i : i ) = str ( i : i ) END IF END DO END FUNCTION UpperCase","tags":"","loc":"proc/uppercase.html"},{"title":"ForwardShift – SELF","text":"public subroutine ForwardShift(myArray, N) \\addtogroup SELF_SupportRoutines\n @{\n \\fn ForwardShift\n Shift an array integers by one index forward, moving the last index to the first. Shifts the array entries as follows : myArray(1) <-- myArray(N) myArray(2) <-- myArray(1) myArray(3) <-- myArray(2) Usage : INTEGER :: N INTEGER :: myArray(1:N) .... CALL ForwardShift( myArray, N ) Parameters : in/out myArray(1:N) INTEGER On output , the input array with elements shifted forward by\n                         one index. in N INTEGER The number of elements in the array @} Arguments Type Intent Optional Attributes Name integer, intent(inout) :: myArray (1:N) integer, intent(in) :: N Contents Source Code ForwardShift Source Code SUBROUTINE ForwardShift ( myArray , N ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( inout ) :: myArray ( 1 : N ) ! LOCAL INTEGER :: temp ( 1 : N ) temp = myArray myArray ( 1 ) = temp ( N ) myArray ( 2 : N ) = temp ( 1 : N - 1 ) END SUBROUTINE ForwardShift","tags":"","loc":"proc/forwardshift.html"},{"title":"InsertionSort – SELF","text":"public subroutine InsertionSort(inArray, outArray, N) \\addtogroup SELF_SupportRoutines\n @{\n \\fn InsertionSort\n Sorts an array of integers from smallest to largest using the insertion-sort algorithm. Usage : INTEGER :: N INTEGER :: inArray(1:N) INTEGER :: outArray(1:N) .... CALL InsertionSort( inArray, outArray, N ) Parameters : in N INTEGER The number of elements in the input and output arrays in inArray(1:N) INTEGER Array of unsorted integers. out outArray INTEGER Array of integers, sorted from most negative to most positive numbers. @} Arguments Type Intent Optional Attributes Name integer, intent(in) :: inArray (1:N) integer, intent(out) :: outArray (1:N) integer, intent(in) :: N Contents Source Code InsertionSort Source Code SUBROUTINE InsertionSort ( inArray , outArray , N ) IMPLICIT NONE INTEGER , INTENT ( in ) :: N INTEGER , INTENT ( in ) :: inArray ( 1 : N ) INTEGER , INTENT ( out ) :: outArray ( 1 : N ) ! LOCAL INTEGER :: i , j INTEGER :: temp outArray = inArray DO i = 2 , N j = i DO WHILE ( j > 1 ) IF ( outArray ( j - 1 ) > outArray ( j )) THEN !Swap outArray(j) outArray(j-1) temp = outArray ( j ) outArray ( j ) = outArray ( j - 1 ) outArray ( j - 1 ) = temp j = j - 1 ELSE EXIT END IF END DO END DO END SUBROUTINE InsertionSort","tags":"","loc":"proc/insertionsort.html"},{"title":"ReverseArray – SELF","text":"public subroutine ReverseArray(myArray, low, high) \\addtogroup SELF_SupportRoutines\n @{\n \\fn ReverseArray\n Reverses the order of a REAL(prec) array. Usage : REAL (prec) :: myArray(low:high) INTEGER :: low, high .... CALL ReverseArray( myArray, low, high ) Parameters : in/out myArray(low:high) REAL(prec) On output , the input array in reverse order . in low INTEGER Lower bound of the input and output arrays in high INTEGER Upper bound of the input and output arrays @} Arguments Type Intent Optional Attributes Name real(kind=prec), intent(inout) :: myArray (low:high) integer, intent(in) :: low integer, intent(in) :: high Contents Source Code ReverseArray Source Code SUBROUTINE ReverseArray ( myArray , low , high ) IMPLICIT NONE INTEGER , INTENT ( in ) :: low , high REAL ( prec ), INTENT ( inout ) :: myArray ( low : high ) ! LOCAL REAL ( prec ) :: temp ( low : high ) INTEGER :: i , j temp = myArray j = high DO i = low , high myArray ( i ) = temp ( j ) j = j - 1 END DO END SUBROUTINE ReverseArray","tags":"","loc":"proc/reversearray.html"},{"title":"SortAndSum – SELF","text":"public subroutine SortAndSum(myArray, low, high, arraysum) \\addtogroup SELF_SupportRoutines\n @{\n \\fn SortAndSum\n Computes the sum of an array by first sorting the array from smallest absolute value to largest\n absolute value. When computing the sum of an array of floating point values, round-off errors can be reduced\n by adding from the smallest to largest values. This subroutine depends on Subroutine \\ref sortarray Usage : REAL (prec) :: myArray(low:high) REAL (prec) :: arraySum INTEGER :: low, high .... CALL SortAndSum( myArray, low, high, arraySum ) Parameters : in/out myArray(low:high) REAL(prec) On input Unsorted array of floating point values On output Sorted array of floating point values, arranged in order\n                         of increasing absolute value. in low INTEGER Lower bound of the input and output arrays in high INTEGER Upper bound of the input and output arrays out arraySum REAL(prec) Sum of the array components. @} Arguments Type Intent Optional Attributes Name real(kind=prec), intent(inout) :: myArray (low:high) integer, intent(in) :: low integer, intent(in) :: high real(kind=prec), intent(out) :: arraysum Calls proc~~sortandsum~~CallsGraph proc~sortandsum SortAndSum proc~sortarray SortArray proc~sortandsum->proc~sortarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SortAndSum Source Code SUBROUTINE SortAndSum ( myArray , low , high , arraysum ) IMPLICIT NONE INTEGER , INTENT ( in ) :: low , high REAL ( prec ), INTENT ( inout ) :: myArray ( low : high ) REAL ( prec ), INTENT ( out ) :: arraysum ! LOCAL INTEGER :: ind CALL SortArray ( myArray , low , high ) arraysum = 0.0_prec DO ind = low , high arraysum = arraysum + myArray ( ind ) END DO END SUBROUTINE SortAndSum","tags":"","loc":"proc/sortandsum.html"},{"title":"SortArray – SELF","text":"public subroutine SortArray(myArray, low, high) \\addtogroup SELF_SupportRoutines\n @{\n \\fn SortArray\n Sorts a REAL(prec) array from smallest absolute value to largest absolute value. Usage : REAL (prec) :: myArray(low:high) INTEGER :: low, high .... CALL SortArray( myArray, low, high ) Parameters : in/out myArray(low:high) REAL(prec) On input Unsorted array of floating point values On output Sorted array of floating point values, arranged in order\n                         of increasing absolute value. in low INTEGER Lower bound of the input and output arrays in high INTEGER Upper bound of the input and output arrays @} Arguments Type Intent Optional Attributes Name real(kind=prec), intent(inout) :: myArray (low:high) integer, intent(in) :: low integer, intent(in) :: high Called by proc~~sortarray~~CalledByGraph proc~sortarray SortArray proc~sortandsum SortAndSum proc~sortandsum->proc~sortarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SortArray Source Code SUBROUTINE SortArray ( myArray , low , high ) IMPLICIT NONE INTEGER , INTENT ( in ) :: low , high REAL ( prec ), INTENT ( inout ) :: myArray ( low : high ) ! LOCAL INTEGER :: locOfMin INTEGER :: ind REAL ( prec ) :: temp DO ind = low , high - 1 locOfMin = MINLOC ( abs ( myArray ( ind : high )), 1 ) + low - 1 + ind temp = myArray ( ind ) myArray ( ind ) = myArray ( locOfMin ) myArray ( locOfMin ) = temp END DO END SUBROUTINE SortArray","tags":"","loc":"proc/sortarray.html"},{"title":"BlockMesh1D_Test – SELF","text":"public subroutine BlockMesh1D_Test(cqType, tqType, cqDegree, tqDegree, nElem, tolerance, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem real(kind=prec), intent(in) :: tolerance integer, intent(out) :: error Calls proc~~blockmesh1d_test~~CallsGraph proc~blockmesh1d_test BlockMesh1D_Test proc~int2str Int2Str proc~blockmesh1d_test->proc~int2str info info proc~blockmesh1d_test->info proc~float2str Float2Str proc~blockmesh1d_test->proc~float2str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~blockmesh1d_test~~CalledByGraph proc~blockmesh1d_test BlockMesh1D_Test program~self SELF program~self->proc~blockmesh1d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code BlockMesh1D_Test Source Code SUBROUTINE BlockMesh1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , tolerance , error ) #undef __FUNC__ #define __FUNC__ \"BlockMesh1D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem REAL ( prec ), INTENT ( in ) :: tolerance INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh1D ) :: mesh TYPE ( Geometry1D ) :: geometry REAL ( prec ) :: expect_dxds , dxds_error , expect_boundx , boundx_error INTEGER :: iel , i error = 0 INFO ( 'Number of elements : ' // Int2Str ( nElem )) INFO ( 'Control point degree : ' // Int2Str ( cqDegree )) INFO ( 'Target point degree : ' // Int2Str ( tqDegree )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) CALL mesh % UniformBlockMesh ( cqDegree , nElem , ( / 0.0_prec , 1.0_prec / )) ! Create the geometry CALL geometry % GenerateFromMesh ( mesh , cqType , tqType , cqDegree , tqDegree ) ! Verify the mesh expect_dxds = ( 1.0_prec / REAL ( nElem , prec )) / 2.0_prec ! Calculate error in metric terms dxds_error = 0.0_prec DO iel = 1 , nElem DO i = 0 , cqDegree dxds_error = MAX ( dxds_error , ABS ( geometry % dxds % interior % hostData ( i , 1 , iel ) - expect_dxds )) END DO END DO ! Calculate error in boundary interpolation boundx_error = 0.0_prec DO iel = 1 , nElem i = mesh % eleminfo % hostData ( 3 , iel ) expect_boundx = mesh % nodeCoords % hostData ( i ) boundx_error = MAX ( boundx_error , ABS ( geometry % x % boundary % hostData ( 1 , 1 , iel ) - expect_boundx )) i = mesh % eleminfo % hostData ( 4 , iel ) expect_boundx = mesh % nodeCoords % hostData ( i ) boundx_error = MAX ( boundx_error , ABS ( geometry % x % boundary % hostData ( 1 , 2 , iel ) - expect_boundx )) END DO CALL mesh % Free () CALL geometry % Free () msg = \"Numerical Error (dx/ds) : \" // Float2Str ( dxds_error ) IF ( dxds_error > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF msg = \"Numerical Error (xBound) : \" // Float2Str ( boundx_error ) IF ( boundx_error > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF END SUBROUTINE BlockMesh1D_Test","tags":"","loc":"proc/blockmesh1d_test.html"},{"title":"BlockMesh2D_Test – SELF","text":"public subroutine BlockMesh2D_Test(cqType, tqType, cqDegree, tqDegree, nElem, tolerance, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem real(kind=prec), intent(in) :: tolerance integer, intent(out) :: error Calls proc~~blockmesh2d_test~~CallsGraph proc~blockmesh2d_test BlockMesh2D_Test proc~int2str Int2Str proc~blockmesh2d_test->proc~int2str info info proc~blockmesh2d_test->info proc~float2str Float2Str proc~blockmesh2d_test->proc~float2str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~blockmesh2d_test~~CalledByGraph proc~blockmesh2d_test BlockMesh2D_Test program~self SELF program~self->proc~blockmesh2d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code BlockMesh2D_Test Source Code SUBROUTINE BlockMesh2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , tolerance , error ) #undef __FUNC__ #define __FUNC__ \"BlockMesh2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem REAL ( prec ), INTENT ( in ) :: tolerance INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: mesh TYPE ( SEMQuad ) :: geometry REAL ( prec ) :: expect_dxds ( 1 : 2 , 1 : 2 ), dxds_error ( 1 : 2 , 1 : 2 ) REAL ( prec ) :: expect_J , J_error INTEGER :: iel , jel , i , j INTEGER :: row , col error = 0 INFO ( 'Number of elements : ' // Int2Str ( nElem * nElem )) INFO ( 'Control point degree : ' // Int2Str ( cqDegree )) INFO ( 'Target point degree : ' // Int2Str ( tqDegree )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) CALL mesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) ! Create the geometry CALL geometry % GenerateFromMesh ( mesh , cqType , tqType , cqDegree , tqDegree ) ! Verify the mesh expect_dxds ( 1 , 1 ) = ( 1.0_prec / REAL ( nElem , prec )) / 2.0_prec expect_dxds ( 1 , 2 ) = 0.0_prec expect_dxds ( 2 , 1 ) = 0.0_prec expect_dxds ( 2 , 2 ) = ( 1.0_prec / REAL ( nElem , prec )) / 2.0_prec expect_J = expect_dxds ( 1 , 1 ) * expect_dxds ( 2 , 2 ) ! Calculate error in metric terms dxds_error = 0.0_prec DO iel = 1 , nElem DO j = 0 , cqDegree DO i = 0 , cqDegree DO col = 1 , 2 DO row = 1 , 2 dxds_error ( row , col ) = MAX ( dxds_error ( row , col ), & ABS ( geometry % dxds % & interior % hostData ( row , col , i , j , 1 , iel ) - & expect_dxds ( row , col ))) END DO END DO J_error = MAX ( J_error , ABS ( geometry % J % & interior % hostData ( i , j , 1 , iel ) - & expect_J )) END DO END DO END DO CALL mesh % Free () CALL geometry % Free () DO col = 1 , 2 DO row = 1 , 2 msg = \"Numerical Error (dx/ds) (\" // & TRIM ( Int2Str ( row )) // \",\" // & TRIM ( Int2Str ( col )) // \") : \" // & Float2Str ( dxds_error ( row , col )) IF ( dxds_error ( row , col ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF END DO END DO msg = \"Numerical Error (Jacobian) : \" // Float2Str ( J_error ) IF ( J_error > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF END SUBROUTINE BlockMesh2D_Test","tags":"","loc":"proc/blockmesh2d_test.html"},{"title":"BlockMesh3D_Test – SELF","text":"public subroutine BlockMesh3D_Test(cqType, tqType, cqDegree, tqDegree, nElem, tolerance, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem real(kind=prec), intent(in) :: tolerance integer, intent(out) :: error Calls proc~~blockmesh3d_test~~CallsGraph proc~blockmesh3d_test BlockMesh3D_Test proc~int2str Int2Str proc~blockmesh3d_test->proc~int2str proc~float2str Float2Str proc~blockmesh3d_test->proc~float2str info info proc~blockmesh3d_test->info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~blockmesh3d_test~~CalledByGraph proc~blockmesh3d_test BlockMesh3D_Test program~self SELF program~self->proc~blockmesh3d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code BlockMesh3D_Test Source Code SUBROUTINE BlockMesh3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , tolerance , error ) #undef __FUNC__ #define __FUNC__ \"BlockMesh3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem REAL ( prec ), INTENT ( in ) :: tolerance INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: mesh TYPE ( SEMHex ) :: geometry REAL ( prec ) :: expect_dxds ( 1 : 3 , 1 : 3 ), dxds_error ( 1 : 3 , 1 : 3 ) REAL ( prec ) :: expect_J , J_error INTEGER :: iel , jel , kel , i , j , k INTEGER :: row , col error = 0 msg = 'Number of elements : ' // Int2Str ( nElem * nElem * nElem ) INFO ( TRIM ( msg )) INFO ( 'Control point degree : ' // Int2Str ( cqDegree )) INFO ( 'Target point degree : ' // Int2Str ( tqDegree )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) CALL mesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) ! Create the geometry CALL geometry % GenerateFromMesh ( mesh , cqType , tqType , cqDegree , tqDegree ) ! Verify the mesh expect_dxds ( 1 , 1 ) = ( 1.0_prec / REAL ( nElem , prec )) / 2.0_prec expect_dxds ( 1 , 2 ) = 0.0_prec expect_dxds ( 1 , 3 ) = 0.0_prec expect_dxds ( 2 , 1 ) = 0.0_prec expect_dxds ( 2 , 2 ) = ( 1.0_prec / REAL ( nElem , prec )) / 2.0_prec expect_dxds ( 2 , 3 ) = 0.0_prec expect_dxds ( 3 , 1 ) = 0.0_prec expect_dxds ( 3 , 2 ) = 0.0_prec expect_dxds ( 3 , 3 ) = ( 1.0_prec / REAL ( nElem , prec )) / 2.0_prec expect_J = expect_dxds ( 1 , 1 ) * expect_dxds ( 2 , 2 ) * expect_dxds ( 3 , 3 ) ! Calculate error in metric terms dxds_error = 0.0_prec J_error = 0.0_prec DO iel = 1 , nElem DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree DO col = 1 , 3 DO row = 1 , 3 dxds_error ( row , col ) = MAX ( dxds_error ( row , col ), & ABS ( geometry % dxds % & interior % hostData ( row , col , i , j , k , 1 , iel ) - & expect_dxds ( row , col ))) END DO END DO J_error = MAX ( J_error , ABS ( geometry % J % & interior % hostData ( i , j , k , 1 , iel ) - & expect_J )) END DO END DO END DO END DO CALL mesh % Free () CALL geometry % Free () DO col = 1 , 3 DO row = 1 , 3 msg = \"Numerical Error (dx/ds) (\" // & TRIM ( Int2Str ( row )) // \",\" // & TRIM ( Int2Str ( col )) // \") : \" // & Float2Str ( dxds_error ( row , col )) IF ( dxds_error ( row , col ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF END DO END DO msg = \"Numerical Error (Jacobian) : \" // Float2Str ( J_error ) IF ( J_error > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF END SUBROUTINE BlockMesh3D_Test","tags":"","loc":"proc/blockmesh3d_test.html"},{"title":"ScalarBoundaryInterp1D_Test – SELF","text":"public subroutine ScalarBoundaryInterp1D_Test(cqType, tqType, cqDegree, tqDegree, nElem, nVar, functionChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: functionChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~scalarboundaryinterp1d_test~~CallsGraph proc~scalarboundaryinterp1d_test ScalarBoundaryInterp1D_Test proc~int2str Int2Str proc~scalarboundaryinterp1d_test->proc~int2str equationparser equationparser proc~scalarboundaryinterp1d_test->equationparser proc~float2str Float2Str proc~scalarboundaryinterp1d_test->proc~float2str info info proc~scalarboundaryinterp1d_test->info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~scalarboundaryinterp1d_test~~CalledByGraph proc~scalarboundaryinterp1d_test ScalarBoundaryInterp1D_Test program~self SELF program~self->proc~scalarboundaryinterp1d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarBoundaryInterp1D_Test Source Code SUBROUTINE ScalarBoundaryInterp1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& functionChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarBoundaryInterp1D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: functionChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh1D ) :: controlMesh TYPE ( Geometry1D ) :: controlGeometry TYPE ( EquationParser ) :: feq TYPE ( Scalar1D ) :: f , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar , 1 : 2 ) INTEGER :: iel , i , ivar , iSide error = 0 msg = 'Number of elements : ' // Int2Str ( nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , nElem ,( / 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) CALL fActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) CALL fError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) ! Create the equation parser object feq = EquationParser ( functionChar , ( / 'x' / )) ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO i = 0 , cqDegree f % interior % hostData ( i , ivar , iel ) = & feq % Evaluate ( ( / controlGeometry % x % interior % hostData ( i , 1 , iel ) / ) ) ENDDO ! Right Boundary fActual % boundary % hostData ( ivar , 1 , iel ) = & feq % Evaluate ( ( / controlGeometry % x % boundary % hostData ( 1 , 1 , iel ) / ) ) ! Right boundary fActual % boundary % hostData ( ivar , 2 , iel ) = & feq % Evaluate ( ( / controlGeometry % x % boundary % hostData ( 1 , 2 , iel ) / ) ) ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % BoundaryInterp ( gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateHost () END IF #endif fError = fActual - f ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxBoundary ( ) DO iSide = 1 , 2 msg = \"Numerical Error : \" // TRIM ( Int2Str ( iSide )) // Float2Str ( maxErrors ( 1 , iSide )) IF ( maxErrors ( 1 , iSide ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) msg = \"Status : [FAIL]\" ERROR ( TRIM ( msg )) ELSE INFO ( TRIM ( msg )) msg = \"Status : [PASS]\" INFO ( TRIM ( msg )) END IF ENDDO ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE ScalarBoundaryInterp1D_Test","tags":"","loc":"proc/scalarboundaryinterp1d_test.html"},{"title":"ScalarBoundaryInterp2D_Test – SELF","text":"public subroutine ScalarBoundaryInterp2D_Test(cqType, tqType, cqDegree, tqDegree, nElem, nVar, functionChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: functionChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~scalarboundaryinterp2d_test~~CallsGraph proc~scalarboundaryinterp2d_test ScalarBoundaryInterp2D_Test proc~int2str Int2Str proc~scalarboundaryinterp2d_test->proc~int2str equationparser equationparser proc~scalarboundaryinterp2d_test->equationparser proc~float2str Float2Str proc~scalarboundaryinterp2d_test->proc~float2str info info proc~scalarboundaryinterp2d_test->info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~scalarboundaryinterp2d_test~~CalledByGraph proc~scalarboundaryinterp2d_test ScalarBoundaryInterp2D_Test program~self SELF program~self->proc~scalarboundaryinterp2d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarBoundaryInterp2D_Test Source Code SUBROUTINE ScalarBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& functionChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarBoundaryInterp2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: functionChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh TYPE ( SEMQuad ) :: controlGeometry TYPE ( EquationParser ) :: feq TYPE ( Scalar2D ) :: f , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar , 1 : 4 ) INTEGER :: nel , iel , jel INTEGER :: i , j , ivar , iside nel = nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object feq = EquationParser ( functionChar , ( / 'x' , 'y' / )) ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree f % interior % hostData ( i , j , ivar , iel ) = & feq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO DO iside = 1 , 4 fActual % boundary % hostData ( j , ivar , iside , iel ) = & feq % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 2 , j , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % BoundaryInterp ( gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateHost () END IF #endif fError = fActual - f ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxBoundary ( ) DO iside = 1 , 4 msg = \"Numerical Error : \" // TRIM ( Int2Str ( iSide )) // Float2Str ( maxErrors ( 1 , iSide )) IF ( maxErrors ( 1 , iSide ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) msg = \"Status : [FAIL]\" ERROR ( TRIM ( msg )) ELSE INFO ( TRIM ( msg )) msg = \"Status : [PASS]\" INFO ( TRIM ( msg )) END IF ENDDO ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE ScalarBoundaryInterp2D_Test","tags":"","loc":"proc/scalarboundaryinterp2d_test.html"},{"title":"ScalarBoundaryInterp3D_Test – SELF","text":"public subroutine ScalarBoundaryInterp3D_Test(cqType, tqType, cqDegree, tqDegree, nElem, nVar, functionChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: functionChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~scalarboundaryinterp3d_test~~CallsGraph proc~scalarboundaryinterp3d_test ScalarBoundaryInterp3D_Test proc~int2str Int2Str proc~scalarboundaryinterp3d_test->proc~int2str equationparser equationparser proc~scalarboundaryinterp3d_test->equationparser proc~float2str Float2Str proc~scalarboundaryinterp3d_test->proc~float2str info info proc~scalarboundaryinterp3d_test->info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~scalarboundaryinterp3d_test~~CalledByGraph proc~scalarboundaryinterp3d_test ScalarBoundaryInterp3D_Test program~self SELF program~self->proc~scalarboundaryinterp3d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarBoundaryInterp3D_Test Source Code SUBROUTINE ScalarBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& functionChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarBoundaryInterp3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: functionChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh , targetMesh TYPE ( SEMHex ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: feq TYPE ( Scalar3D ) :: f , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar , 1 : 6 ) INTEGER :: nel , iel INTEGER :: i , j , k , ivar , iside nel = nElem * nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object feq = EquationParser ( functionChar , ( / 'x' , 'y' , 'z' / )) ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree f % interior % hostData ( i , j , k , ivar , iel ) = & feq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO DO iside = 1 , 6 fActual % boundary % hostData ( j , k , ivar , iside , iel ) = & feq % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 3 , j , k , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % BoundaryInterp ( gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateHost () END IF #endif fError = fActual - f ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxBoundary ( ) DO iside = 1 , 6 msg = \"Numerical Error : \" // TRIM ( Int2Str ( iSide )) // Float2Str ( maxErrors ( 1 , iSide )) IF ( maxErrors ( 1 , iSide ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) msg = \"Status : [FAIL]\" ERROR ( TRIM ( msg )) ELSE INFO ( TRIM ( msg )) msg = \"Status : [PASS]\" INFO ( TRIM ( msg )) END IF ENDDO ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE ScalarBoundaryInterp3D_Test","tags":"","loc":"proc/scalarboundaryinterp3d_test.html"},{"title":"ScalarDerivative1D_Test – SELF","text":"public subroutine ScalarDerivative1D_Test(cqType, tqType, cqDegree, tqDegree, dForm, nElem, nVar, fChar, dfChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: dForm integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: fChar character(len=*), intent(in) :: dfChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~scalarderivative1d_test~~CallsGraph proc~scalarderivative1d_test ScalarDerivative1D_Test proc~int2str Int2Str proc~scalarderivative1d_test->proc~int2str info info proc~scalarderivative1d_test->info equationparser equationparser proc~scalarderivative1d_test->equationparser proc~float2str Float2Str proc~scalarderivative1d_test->proc~float2str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~scalarderivative1d_test~~CalledByGraph proc~scalarderivative1d_test ScalarDerivative1D_Test program~self SELF program~self->proc~scalarderivative1d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarDerivative1D_Test Source Code SUBROUTINE ScalarDerivative1D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nvar ,& fChar , dfChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarDerivative1D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: dForm INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: fChar CHARACTER ( * ), INTENT ( in ) :: dfChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh1D ) :: controlMesh TYPE ( Geometry1D ) :: controlGeometry TYPE ( EquationParser ) :: feq , dfeq TYPE ( MappedScalar1D ) :: f , dfInterp , dfActual , dfError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , ivar error = 0 IF ( dForm == selfStrongForm ) THEN msg = 'Formulation Type : Strong Form' ELSEIF ( dForm == selfWeakDGForm ) THEN msg = 'Formulation Type : Weak DG Form' ELSEIF ( dForm == selfWeakCGForm ) THEN msg = 'Formulation Type : Weak CG Form' ENDIF INFO ( TRIM ( msg )) msg = 'Number of elements : ' // Int2Str ( nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , nElem ,( / 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) CALL dfInterp % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) CALL dfActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) CALL dfError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) ! Create the equation parser object feq = EquationParser ( fChar , ( / 'x' / )) dfeq = EquationParser ( dfChar , ( / 'x' / )) ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO i = 0 , cqDegree f % interior % hostData ( i , ivar , iel ) = & feq % Evaluate ( ( / controlGeometry % x % interior % hostData ( i , 1 , iel ) / ) ) dfActual % interior % hostData ( i , ivar , iel ) = & dfeq % Evaluate ( ( / controlGeometry % x % interior % hostData ( i , 1 , iel ) / ) ) ENDDO ! Left Boundary f % boundary % hostData ( ivar , 1 , iel ) = & feq % Evaluate ( ( / controlGeometry % x % boundary % hostData ( 1 , 1 , iel ) / ) ) ! Right boundary f % boundary % hostData ( ivar , 2 , iel ) = & feq % Evaluate ( ( / controlGeometry % x % boundary % hostData ( 1 , 2 , iel ) / ) ) ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % Derivative ( controlGeometry , dfInterp , dForm , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL dfInterp % UpdateHost () END IF #endif dfError = dfActual - dfInterp ! Calculate Absolute Maximum Error maxErrors = dfError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL dfInterp % Free () CALL dfActual % Free () CALL dfError % Free () END SUBROUTINE ScalarDerivative1D_Test","tags":"","loc":"proc/scalarderivative1d_test.html"},{"title":"ScalarGradient2D_Test – SELF","text":"public subroutine ScalarGradient2D_Test(cqType, tqType, cqDegree, tqDegree, dForm, nElem, nVar, fChar, gradientChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: dForm integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: fChar character(len=240), intent(in) :: gradientChar (1:2) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~scalargradient2d_test~~CallsGraph proc~scalargradient2d_test ScalarGradient2D_Test proc~int2str Int2Str proc~scalargradient2d_test->proc~int2str info info proc~scalargradient2d_test->info equationparser equationparser proc~scalargradient2d_test->equationparser proc~float2str Float2Str proc~scalargradient2d_test->proc~float2str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarGradient2D_Test Source Code SUBROUTINE ScalarGradient2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nvar ,& fChar , gradientChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarGradient2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: dForm INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: fChar CHARACTER ( 240 ), INTENT ( in ) :: gradientChar ( 1 : 2 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh TYPE ( SEMQuad ) :: controlGeometry TYPE ( EquationParser ) :: feq , gxeq , gyeq TYPE ( MappedScalar2D ) :: f TYPE ( MappedTensor2D ) :: workTensor TYPE ( MappedVector2D ) :: dfInterp , dfActual , dfError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , j , ivar , iside error = 0 IF ( dForm == selfStrongForm ) THEN msg = 'Formulation Type : Strong Form' ELSEIF ( dForm == selfWeakDGForm ) THEN msg = 'Formulation Type : Weak DG Form' ELSEIF ( dForm == selfWeakCGForm ) THEN msg = 'Formulation Type : Weak CG Form' ENDIF INFO ( TRIM ( msg )) msg = 'Number of elements : ' // Int2Str ( nElem ) msg = 'Number of elements : ' // Int2Str ( nElem * nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL workTensor % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfInterp % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create the equation parser object feq = EquationParser ( fChar , ( / 'x' , 'y' / )) gxeq = EquationParser ( gradientChar ( 1 ), ( / 'x' , 'y' / )) gyeq = EquationParser ( gradientChar ( 2 ), ( / 'x' , 'y' / )) ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree f % interior % hostData ( i , j , ivar , iel ) = & feq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) dfActual % interior % hostData ( 1 , i , j , ivar , iel ) = & gxeq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) dfActual % interior % hostData ( 2 , i , j , ivar , iel ) = & gyeq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO DO iside = 1 , 4 f % boundary % hostData ( j , ivar , iside , iel ) = & feq % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 2 , j , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % Gradient ( workTensor , controlGeometry , dfInterp , dForm , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL dfInterp % UpdateHost () END IF #endif dfError = dfActual - dfInterp ! Calculate Absolute Maximum Error maxErrors = dfError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL workTensor % Free () CALL dfInterp % Free () CALL dfActual % Free () CALL dfError % Free () END SUBROUTINE ScalarGradient2D_Test","tags":"","loc":"proc/scalargradient2d_test.html"},{"title":"ScalarGradient3D_Test – SELF","text":"public subroutine ScalarGradient3D_Test(cqType, tqType, cqDegree, tqDegree, dForm, nElem, nVar, fChar, gradientChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: dForm integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: fChar character(len=240), intent(in) :: gradientChar (1:3) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~scalargradient3d_test~~CallsGraph proc~scalargradient3d_test ScalarGradient3D_Test proc~int2str Int2Str proc~scalargradient3d_test->proc~int2str info info proc~scalargradient3d_test->info equationparser equationparser proc~scalargradient3d_test->equationparser proc~float2str Float2Str proc~scalargradient3d_test->proc~float2str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~scalargradient3d_test~~CalledByGraph proc~scalargradient3d_test ScalarGradient3D_Test program~self SELF program~self->proc~scalargradient3d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarGradient3D_Test Source Code SUBROUTINE ScalarGradient3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nvar ,& fChar , gradientChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarGradient3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: dForm INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: fChar CHARACTER ( 240 ), INTENT ( in ) :: gradientChar ( 1 : 3 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh TYPE ( SEMHex ) :: controlGeometry TYPE ( EquationParser ) :: feq , gxeq , gyeq , gzeq TYPE ( MappedScalar3D ) :: f TYPE ( MappedTensor3D ) :: workTensor TYPE ( MappedVector3D ) :: dfInterp , dfActual , dfError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , j , k , ivar , iside error = 0 IF ( dForm == selfStrongForm ) THEN msg = 'Formulation Type : Strong Form' ELSEIF ( dForm == selfWeakDGForm ) THEN msg = 'Formulation Type : Weak DG Form' ELSEIF ( dForm == selfWeakCGForm ) THEN msg = 'Formulation Type : Weak CG Form' ENDIF INFO ( TRIM ( msg )) msg = 'Number of elements : ' // Int2Str ( nElem ) msg = 'Number of elements : ' // Int2Str ( nElem * nElem * nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL workTensor % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfInterp % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create the equation parser object feq = EquationParser ( fChar , ( / 'x' , 'y' , 'z' / )) gxeq = EquationParser ( gradientChar ( 1 ), ( / 'x' , 'y' , 'z' / )) gyeq = EquationParser ( gradientChar ( 2 ), ( / 'x' , 'y' , 'z' / )) gzeq = EquationParser ( gradientChar ( 3 ), ( / 'x' , 'y' , 'z' / )) ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree f % interior % hostData ( i , j , k , ivar , iel ) = & feq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) dfActual % interior % hostData ( 1 , i , j , k , ivar , iel ) = & gxeq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) dfActual % interior % hostData ( 2 , i , j , k , ivar , iel ) = & gyeq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) dfActual % interior % hostData ( 3 , i , j , k , ivar , iel ) = & gzeq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO DO iside = 1 , 6 f % boundary % hostData ( j , k , ivar , iside , iel ) = & feq % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 3 , j , k , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % Gradient ( workTensor , controlGeometry , dfInterp , dForm , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL dfInterp % UpdateHost () END IF #endif dfError = dfActual - dfInterp ! Calculate Absolute Maximum Error maxErrors = dfError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL workTensor % Free () CALL dfInterp % Free () CALL dfActual % Free () CALL dfError % Free () END SUBROUTINE ScalarGradient3D_Test","tags":"","loc":"proc/scalargradient3d_test.html"},{"title":"ScalarInterp1D_Test – SELF","text":"public subroutine ScalarInterp1D_Test(cqType, tqType, cqDegree, tqDegree, nElem, nVar, functionChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: functionChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~scalarinterp1d_test~~CallsGraph proc~scalarinterp1d_test ScalarInterp1D_Test proc~int2str Int2Str proc~scalarinterp1d_test->proc~int2str equationparser equationparser proc~scalarinterp1d_test->equationparser proc~float2str Float2Str proc~scalarinterp1d_test->proc~float2str info info proc~scalarinterp1d_test->info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~scalarinterp1d_test~~CalledByGraph proc~scalarinterp1d_test ScalarInterp1D_Test program~self SELF program~self->proc~scalarinterp1d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarInterp1D_Test Source Code SUBROUTINE ScalarInterp1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar , functionChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarInterp1D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: functionChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh1D ) :: controlMesh , targetMesh TYPE ( Geometry1D ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: feq TYPE ( Scalar1D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , ivar error = 0 msg = 'Number of elements : ' // Int2Str ( nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , nElem ,( / 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the target mesh and geometry CALL targetMesh % UniformBlockMesh ( tqDegree , nElem ,( / 0.0_prec , 1.0_prec / )) CALL targetGeometry % GenerateFromMesh ( targetMesh , tqType , tqType , tqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nElem ) CALL fInterp % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nElem ) CALL fActual % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nElem ) CALL fError % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nElem ) ! Create the equation parser object feq = EquationParser ( functionChar , ( / 'x' / )) ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO i = 0 , cqDegree f % interior % hostData ( i , ivar , iel ) = & feq % Evaluate ( ( / controlGeometry % x % interior % hostData ( i , 1 , iel ) / ) ) ENDDO ENDDO ENDDO ! Load the target function DO iel = 1 , targetGeometry % nElem DO ivar = 1 , nvar DO i = 0 , tqDegree fActual % interior % hostData ( i , ivar , iel ) = & feq % Evaluate ( ( / targetGeometry % x % interior % hostData ( i , 1 , iel ) / ) ) ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % GridInterp ( fInterp , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL fInterp % UpdateHost () END IF #endif fError = fActual - fInterp ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL targetMesh % Free () CALL targetGeometry % Free () CALL f % Free () CALL fInterp % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE ScalarInterp1D_Test","tags":"","loc":"proc/scalarinterp1d_test.html"},{"title":"ScalarInterp2D_Test – SELF","text":"public subroutine ScalarInterp2D_Test(cqType, tqType, cqDegree, tqDegree, nElem, nVar, functionChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: functionChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~scalarinterp2d_test~~CallsGraph proc~scalarinterp2d_test ScalarInterp2D_Test proc~int2str Int2Str proc~scalarinterp2d_test->proc~int2str equationparser equationparser proc~scalarinterp2d_test->equationparser proc~float2str Float2Str proc~scalarinterp2d_test->proc~float2str info info proc~scalarinterp2d_test->info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~scalarinterp2d_test~~CalledByGraph proc~scalarinterp2d_test ScalarInterp2D_Test program~self SELF program~self->proc~scalarinterp2d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarInterp2D_Test Source Code SUBROUTINE ScalarInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& functionChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarInterp2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: functionChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh , targetMesh TYPE ( SEMQuad ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: feq TYPE ( Scalar2D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: nel , iel , jel INTEGER :: i , j , ivar nel = nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the target mesh and geometry CALL targetMesh % UniformBlockMesh ( tqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL targetGeometry % GenerateFromMesh ( targetMesh , tqType , tqType , tqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fInterp % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object feq = EquationParser ( functionChar , ( / 'x' , 'y' / )) ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree f % interior % hostData ( i , j , ivar , iel ) = & feq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ! Load the target function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , tqDegree DO i = 0 , tqDegree fActual % interior % hostData ( i , j , ivar , iel ) = & feq % Evaluate ( targetGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % GridInterp ( fInterp , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL fInterp % UpdateHost () END IF #endif fError = fActual - fInterp ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL targetMesh % Free () CALL targetGeometry % Free () CALL f % Free () CALL fInterp % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE ScalarInterp2D_Test","tags":"","loc":"proc/scalarinterp2d_test.html"},{"title":"ScalarInterp3D_Test – SELF","text":"public subroutine ScalarInterp3D_Test(cqType, tqType, cqDegree, tqDegree, nElem, nVar, functionChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: functionChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~scalarinterp3d_test~~CallsGraph proc~scalarinterp3d_test ScalarInterp3D_Test proc~int2str Int2Str proc~scalarinterp3d_test->proc~int2str equationparser equationparser proc~scalarinterp3d_test->equationparser proc~float2str Float2Str proc~scalarinterp3d_test->proc~float2str info info proc~scalarinterp3d_test->info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~scalarinterp3d_test~~CalledByGraph proc~scalarinterp3d_test ScalarInterp3D_Test program~self SELF program~self->proc~scalarinterp3d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ScalarInterp3D_Test Source Code SUBROUTINE ScalarInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& functionChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"ScalarInterp3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( * ), INTENT ( in ) :: functionChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh , targetMesh TYPE ( SEMHex ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: feq TYPE ( Scalar3D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: nel , iel INTEGER :: i , j , k , ivar nel = nElem * nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the target mesh and geometry CALL targetMesh % UniformBlockMesh ( tqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL targetGeometry % GenerateFromMesh ( targetMesh , tqType , tqType , tqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fInterp % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object feq = EquationParser ( functionChar , ( / 'x' , 'y' , 'z' / )) ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree f % interior % hostData ( i , j , k , ivar , iel ) = & feq % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ! Load the target function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , tqDegree DO j = 0 , tqDegree DO i = 0 , tqDegree fActual % interior % hostData ( i , j , k , ivar , iel ) = & feq % Evaluate ( targetGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % GridInterp ( fInterp , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL fInterp % UpdateHost () END IF #endif fError = fActual - fInterp ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL targetMesh % Free () CALL targetGeometry % Free () CALL f % Free () CALL fInterp % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE ScalarInterp3D_Test","tags":"","loc":"proc/scalarinterp3d_test.html"},{"title":"TensorBoundaryInterp2D_Test – SELF","text":"public subroutine TensorBoundaryInterp2D_Test(cqType, tqType, cqDegree, tqDegree, nElem, nVar, tensorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: tensorChar (1:2,1:2) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~tensorboundaryinterp2d_test~~CallsGraph proc~tensorboundaryinterp2d_test TensorBoundaryInterp2D_Test proc~int2str Int2Str proc~tensorboundaryinterp2d_test->proc~int2str equationparser equationparser proc~tensorboundaryinterp2d_test->equationparser proc~float2str Float2Str proc~tensorboundaryinterp2d_test->proc~float2str info info proc~tensorboundaryinterp2d_test->info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorBoundaryInterp2D_Test Source Code SUBROUTINE TensorBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& tensorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"TensorBoundaryInterp2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: tensorChar ( 1 : 2 , 1 : 2 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh TYPE ( SEMQuad ) :: controlGeometry TYPE ( EquationParser ) :: tensorEq ( 1 : 2 , 1 : 2 ) TYPE ( Tensor2D ) :: f , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar , 1 : 4 ) INTEGER :: nel , iel , jel INTEGER :: i , j , ivar , iside INTEGER :: row , col nel = nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO col = 1 , 2 DO row = 1 , 2 tensorEq ( row , col ) = EquationParser ( TRIM ( tensorChar ( row , col )), ( / 'x' , 'y' / )) ENDDO ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree DO col = 1 , 2 DO row = 1 , 2 f % interior % hostData ( row , col , i , j , ivar , iel ) = & tensorEq ( row , col ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO DO iside = 1 , 4 DO col = 1 , 2 DO row = 1 , 2 fActual % boundary % hostData ( row , col , j , ivar , iside , iel ) = & tensorEq ( row , col ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 2 , j , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % BoundaryInterp ( gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateHost () END IF #endif fError = fActual - f ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxBoundary ( ) DO iside = 1 , 4 msg = \"Numerical Error : \" // TRIM ( Int2Str ( iSide )) // Float2Str ( maxErrors ( 1 , iSide )) IF ( maxErrors ( 1 , iSide ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) msg = \"Status : [FAIL]\" ERROR ( TRIM ( msg )) ELSE INFO ( TRIM ( msg )) msg = \"Status : [PASS]\" INFO ( TRIM ( msg )) END IF ENDDO ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE TensorBoundaryInterp2D_Test","tags":"","loc":"proc/tensorboundaryinterp2d_test.html"},{"title":"TensorBoundaryInterp3D_Test – SELF","text":"public subroutine TensorBoundaryInterp3D_Test(cqType, tqType, cqDegree, tqDegree, nElem, nVar, tensorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: tensorChar (1:3,1:3) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~tensorboundaryinterp3d_test~~CallsGraph proc~tensorboundaryinterp3d_test TensorBoundaryInterp3D_Test proc~int2str Int2Str proc~tensorboundaryinterp3d_test->proc~int2str equationparser equationparser proc~tensorboundaryinterp3d_test->equationparser proc~float2str Float2Str proc~tensorboundaryinterp3d_test->proc~float2str info info proc~tensorboundaryinterp3d_test->info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~tensorboundaryinterp3d_test~~CalledByGraph proc~tensorboundaryinterp3d_test TensorBoundaryInterp3D_Test program~self SELF program~self->proc~tensorboundaryinterp3d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorBoundaryInterp3D_Test Source Code SUBROUTINE TensorBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& tensorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"TensorBoundaryInterp3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: tensorChar ( 1 : 3 , 1 : 3 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh TYPE ( SEMHex ) :: controlGeometry TYPE ( EquationParser ) :: tensorEq ( 1 : 3 , 1 : 3 ) TYPE ( Tensor3D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar , 1 : 6 ) INTEGER :: nel , iel INTEGER :: i , j , k , ivar , iside INTEGER :: row , col nel = nElem * nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO col = 1 , 3 DO row = 1 , 3 tensorEq ( row , col ) = EquationParser ( TRIM ( tensorChar ( row , col )), ( / 'x' , 'y' , 'z' / )) ENDDO ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree DO col = 1 , 3 DO row = 1 , 3 f % interior % hostData ( row , col , i , j , k , ivar , iel ) = & tensorEq ( row , col ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO DO iside = 1 , 6 DO col = 1 , 3 DO row = 1 , 3 fActual % boundary % hostData ( row , col , j , k , ivar , iside , iel ) = & tensorEq ( row , col ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 3 , j , k , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % BoundaryInterp ( gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateHost () END IF #endif fError = fActual - f ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxBoundary ( ) DO iside = 1 , 6 msg = \"Numerical Error : \" // TRIM ( Int2Str ( iSide )) // Float2Str ( maxErrors ( 1 , iSide )) IF ( maxErrors ( 1 , iSide ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) msg = \"Status : [FAIL]\" ERROR ( TRIM ( msg )) ELSE INFO ( TRIM ( msg )) msg = \"Status : [PASS]\" INFO ( TRIM ( msg )) END IF ENDDO ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE TensorBoundaryInterp3D_Test","tags":"","loc":"proc/tensorboundaryinterp3d_test.html"},{"title":"TensorInterp2D_Test – SELF","text":"public subroutine TensorInterp2D_Test(cqType, tqType, cqDegree, tqDegree, nElem, nVar, tensorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: tensorChar (1:2,1:2) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~tensorinterp2d_test~~CallsGraph proc~tensorinterp2d_test TensorInterp2D_Test proc~int2str Int2Str proc~tensorinterp2d_test->proc~int2str equationparser equationparser proc~tensorinterp2d_test->equationparser proc~float2str Float2Str proc~tensorinterp2d_test->proc~float2str info info proc~tensorinterp2d_test->info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorInterp2D_Test Source Code SUBROUTINE TensorInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& tensorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"TensorInterp2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: tensorChar ( 1 : 2 , 1 : 2 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh , targetMesh TYPE ( SEMQuad ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: tensorEq ( 1 : 2 , 1 : 2 ) TYPE ( Tensor2D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: nel , iel , jel INTEGER :: i , j , ivar INTEGER :: row , col nel = nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the target mesh and geometry CALL targetMesh % UniformBlockMesh ( tqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL targetGeometry % GenerateFromMesh ( targetMesh , tqType , tqType , tqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fInterp % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO col = 1 , 2 DO row = 1 , 2 tensorEq ( row , col ) = EquationParser ( TRIM ( tensorChar ( row , col )), ( / 'x' , 'y' / )) ENDDO ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree DO col = 1 , 2 DO row = 1 , 2 f % interior % hostData ( row , col , i , j , ivar , iel ) = & tensorEq ( row , col ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ! Load the target function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , tqDegree DO i = 0 , tqDegree DO col = 1 , 2 DO row = 1 , 2 fActual % interior % hostData ( row , col , i , j , ivar , iel ) = & tensorEq ( row , col ) % Evaluate ( targetGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % GridInterp ( fInterp , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL fInterp % UpdateHost () END IF #endif fError = fActual - fInterp ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL targetMesh % Free () CALL targetGeometry % Free () CALL f % Free () CALL fInterp % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE TensorInterp2D_Test","tags":"","loc":"proc/tensorinterp2d_test.html"},{"title":"TensorInterp3D_Test – SELF","text":"public subroutine TensorInterp3D_Test(cqType, tqType, cqDegree, tqDegree, nElem, nVar, tensorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: tensorChar (1:3,1:3) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~tensorinterp3d_test~~CallsGraph proc~tensorinterp3d_test TensorInterp3D_Test proc~int2str Int2Str proc~tensorinterp3d_test->proc~int2str equationparser equationparser proc~tensorinterp3d_test->equationparser proc~float2str Float2Str proc~tensorinterp3d_test->proc~float2str info info proc~tensorinterp3d_test->info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~tensorinterp3d_test~~CalledByGraph proc~tensorinterp3d_test TensorInterp3D_Test program~self SELF program~self->proc~tensorinterp3d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code TensorInterp3D_Test Source Code SUBROUTINE TensorInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& tensorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"TensorInterp3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: tensorChar ( 1 : 3 , 1 : 3 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh , targetMesh TYPE ( SEMHex ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: tensorEq ( 1 : 3 , 1 : 3 ) TYPE ( Tensor3D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: nel , iel INTEGER :: i , j , k , ivar INTEGER :: row , col nel = nElem * nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the target mesh and geometry CALL targetMesh % UniformBlockMesh ( tqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL targetGeometry % GenerateFromMesh ( targetMesh , tqType , tqType , tqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fInterp % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO col = 1 , 3 DO row = 1 , 3 tensorEq ( row , col ) = EquationParser ( TRIM ( tensorChar ( row , col )), ( / 'x' , 'y' , 'z' / )) ENDDO ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree DO col = 1 , 3 DO row = 1 , 3 f % interior % hostData ( row , col , i , j , k , ivar , iel ) = & tensorEq ( row , col ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ! Load the target function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , tqDegree DO j = 0 , tqDegree DO i = 0 , tqDegree DO col = 1 , 3 DO row = 1 , 3 fActual % interior % hostData ( row , col , i , j , k , ivar , iel ) = & tensorEq ( row , col ) % Evaluate ( targetGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % GridInterp ( fInterp , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL fInterp % UpdateHost () END IF #endif fError = fActual - fInterp ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL targetMesh % Free () CALL targetGeometry % Free () CALL f % Free () CALL fInterp % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE TensorInterp3D_Test","tags":"","loc":"proc/tensorinterp3d_test.html"},{"title":"VectorBoundaryInterp2D_Test – SELF","text":"public subroutine VectorBoundaryInterp2D_Test(cqType, tqType, cqDegree, tqDegree, nElem, nVar, vectorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:2) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~vectorboundaryinterp2d_test~~CallsGraph proc~vectorboundaryinterp2d_test VectorBoundaryInterp2D_Test proc~int2str Int2Str proc~vectorboundaryinterp2d_test->proc~int2str equationparser equationparser proc~vectorboundaryinterp2d_test->equationparser proc~float2str Float2Str proc~vectorboundaryinterp2d_test->proc~float2str info info proc~vectorboundaryinterp2d_test->info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorBoundaryInterp2D_Test Source Code SUBROUTINE VectorBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& vectorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorBoundaryInterp2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 2 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh TYPE ( SEMQuad ) :: controlGeometry TYPE ( EquationParser ) :: vEq ( 1 : 2 ) TYPE ( Vector2D ) :: f , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar , 1 : 4 ) INTEGER :: nel , iel , jel INTEGER :: i , j , ivar , iside , idir nel = nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO idir = 1 , 2 vEq ( idir ) = EquationParser ( vectorChar ( idir ), ( / 'x' , 'y' / )) ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree DO idir = 1 , 2 f % interior % hostData ( idir , i , j , ivar , iel ) = & vEq ( idir ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO DO iside = 1 , 4 DO idir = 1 , 2 fActual % boundary % hostData ( idir , j , ivar , iside , iel ) = & vEq ( idir ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 2 , j , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ! Run the grid interpolation #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif CALL f % BoundaryInterp ( gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateHost () END IF #endif fError = fActual - f ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxBoundary ( ) DO iside = 1 , 4 msg = \"Numerical Error : \" // TRIM ( Int2Str ( iSide )) // Float2Str ( maxErrors ( 1 , iSide )) IF ( maxErrors ( 1 , iSide ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) msg = \"Status : [FAIL]\" ERROR ( TRIM ( msg )) ELSE INFO ( TRIM ( msg )) msg = \"Status : [PASS]\" INFO ( TRIM ( msg )) END IF ENDDO ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE VectorBoundaryInterp2D_Test","tags":"","loc":"proc/vectorboundaryinterp2d_test.html"},{"title":"VectorBoundaryInterp3D_Test – SELF","text":"public subroutine VectorBoundaryInterp3D_Test(cqType, tqType, cqDegree, tqDegree, nElem, nVar, vectorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:3) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~vectorboundaryinterp3d_test~~CallsGraph proc~vectorboundaryinterp3d_test VectorBoundaryInterp3D_Test proc~int2str Int2Str proc~vectorboundaryinterp3d_test->proc~int2str equationparser equationparser proc~vectorboundaryinterp3d_test->equationparser proc~float2str Float2Str proc~vectorboundaryinterp3d_test->proc~float2str info info proc~vectorboundaryinterp3d_test->info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vectorboundaryinterp3d_test~~CalledByGraph proc~vectorboundaryinterp3d_test VectorBoundaryInterp3D_Test program~self SELF program~self->proc~vectorboundaryinterp3d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorBoundaryInterp3D_Test Source Code SUBROUTINE VectorBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& vectorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorBoundaryInterp3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 3 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh TYPE ( SEMHex ) :: controlGeometry TYPE ( EquationParser ) :: vEq ( 1 : 3 ) TYPE ( Vector3D ) :: f , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar , 1 : 6 ) INTEGER :: nel , iel INTEGER :: i , j , k , ivar , iside , idir nel = nElem * nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO idir = 1 , 3 vEq ( idir ) = EquationParser ( vectorChar ( idir ), ( / 'x' , 'y' , 'z' / )) ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree DO idir = 1 , 3 f % interior % hostData ( idir , i , j , k , ivar , iel ) = & vEq ( idir ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO DO iside = 1 , 6 DO idir = 1 , 3 fActual % boundary % hostData ( idir , j , k , ivar , iside , iel ) = & vEq ( idir ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 3 , j , k , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % BoundaryInterp ( gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateHost () END IF #endif fError = fActual - f ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxBoundary ( ) DO iside = 1 , 6 msg = \"Numerical Error : \" // TRIM ( Int2Str ( iSide )) // Float2Str ( maxErrors ( 1 , iSide )) IF ( maxErrors ( 1 , iSide ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) msg = \"Status : [FAIL]\" ERROR ( TRIM ( msg )) ELSE INFO ( TRIM ( msg )) msg = \"Status : [PASS]\" INFO ( TRIM ( msg )) END IF ENDDO ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE VectorBoundaryInterp3D_Test","tags":"","loc":"proc/vectorboundaryinterp3d_test.html"},{"title":"VectorDivergence2D_Test – SELF","text":"public subroutine VectorDivergence2D_Test(cqType, tqType, cqDegree, tqDegree, dForm, nElem, nVar, vectorChar, scalarChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: dForm integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:2) character(len=240), intent(in) :: scalarChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~vectordivergence2d_test~~CallsGraph proc~vectordivergence2d_test VectorDivergence2D_Test proc~int2str Int2Str proc~vectordivergence2d_test->proc~int2str info info proc~vectordivergence2d_test->info equationparser equationparser proc~vectordivergence2d_test->equationparser proc~float2str Float2Str proc~vectordivergence2d_test->proc~float2str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorDivergence2D_Test Source Code SUBROUTINE VectorDivergence2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nvar ,& vectorChar , scalarChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorDivergence2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: dForm INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 2 ) CHARACTER ( 240 ), INTENT ( in ) :: scalarChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh TYPE ( SEMQuad ) :: controlGeometry TYPE ( EquationParser ) :: feq ( 1 : 2 ), dfeqChar TYPE ( MappedVector2D ) :: f TYPE ( MappedVector2D ) :: workVector TYPE ( MappedScalar2D ) :: dfInterp , dfActual , dfError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , j , ivar , row , col , iside error = 0 IF ( dForm == selfStrongForm ) THEN msg = 'Formulation Type : Strong Form' ELSEIF ( dForm == selfWeakDGForm ) THEN msg = 'Formulation Type : Weak DG Form' ELSEIF ( dForm == selfWeakCGForm ) THEN msg = 'Formulation Type : Weak CG Form' ENDIF INFO ( TRIM ( msg )) msg = 'Number of elements : ' // Int2Str ( nElem ) msg = 'Number of elements : ' // Int2Str ( nElem * nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfInterp % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create work objects CALL workVector % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create the equation parser object DO row = 1 , 2 feq ( row ) = EquationParser ( vectorChar ( row ), ( / 'x' , 'y' / )) ENDDO dfeqChar = EquationParser ( scalarChar , ( / 'x' , 'y' / )) ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree DO row = 1 , 2 f % interior % hostData ( row , i , j , ivar , iel ) = & feq ( row ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO dfActual % interior % hostData ( i , j , ivar , iel ) = & dfeqChar % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO DO iside = 1 , 4 DO row = 1 , 2 f % boundary % hostData ( row , j , ivar , iside , iel ) = & feq ( row ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 2 , j , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % Divergence ( workVector , controlGeometry , dfInterp , dForm , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL dfInterp % UpdateHost ( ) END IF #endif dfError = dfActual - dfInterp ! Calculate Absolute Maximum Error maxErrors = dfError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL workVector % Free () CALL dfInterp % Free () CALL dfActual % Free () CALL dfError % Free () END SUBROUTINE VectorDivergence2D_Test","tags":"","loc":"proc/vectordivergence2d_test.html"},{"title":"VectorDivergence3D_Test – SELF","text":"public subroutine VectorDivergence3D_Test(cqType, tqType, cqDegree, tqDegree, dForm, nElem, nVar, vectorChar, scalarChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: dForm integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:3) character(len=240), intent(in) :: scalarChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~vectordivergence3d_test~~CallsGraph proc~vectordivergence3d_test VectorDivergence3D_Test proc~int2str Int2Str proc~vectordivergence3d_test->proc~int2str info info proc~vectordivergence3d_test->info equationparser equationparser proc~vectordivergence3d_test->equationparser proc~float2str Float2Str proc~vectordivergence3d_test->proc~float2str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vectordivergence3d_test~~CalledByGraph proc~vectordivergence3d_test VectorDivergence3D_Test program~self SELF program~self->proc~vectordivergence3d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorDivergence3D_Test Source Code SUBROUTINE VectorDivergence3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nvar ,& vectorChar , scalarChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorDivergence3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: dForm INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 3 ) CHARACTER ( 240 ), INTENT ( in ) :: scalarChar REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh TYPE ( SEMHex ) :: controlGeometry TYPE ( EquationParser ) :: feq ( 1 : 3 ), dfeqChar TYPE ( MappedVector3D ) :: f TYPE ( MappedVector3D ) :: workVector TYPE ( MappedScalar3D ) :: dfInterp , dfActual , dfError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , j , k , ivar , idir , iside error = 0 IF ( dForm == selfStrongForm ) THEN msg = 'Formulation Type : Strong Form' ELSEIF ( dForm == selfWeakDGForm ) THEN msg = 'Formulation Type : Weak DG Form' ELSEIF ( dForm == selfWeakCGForm ) THEN msg = 'Formulation Type : Weak CG Form' ENDIF INFO ( TRIM ( msg )) msg = 'Number of elements : ' // Int2Str ( nElem * nElem * nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfInterp % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create work objects CALL workVector % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create the equation parser object DO idir = 1 , 3 feq ( idir ) = EquationParser ( vectorChar ( idir ), ( / 'x' , 'y' , 'z' / )) ENDDO dfeqChar = EquationParser ( scalarChar , ( / 'x' , 'y' , 'z' / )) ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree DO idir = 1 , 3 f % interior % hostData ( idir , i , j , k , ivar , iel ) = & feq ( idir ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO dfActual % interior % hostData ( i , j , k , ivar , iel ) = & dfeqChar % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO DO iside = 1 , 6 DO idir = 1 , 3 f % boundary % hostData ( idir , j , k , ivar , iside , iel ) = & feq ( idir ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 3 , j , k , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation DO i = 1 , 1000 CALL f % Divergence ( workVector , controlGeometry , dfInterp , dForm , gpuAccel ) END DO #ifdef GPU IF ( gpuAccel ) THEN CALL dfInterp % UpdateHost () END IF #endif dfError = dfActual - dfInterp ! Calculate Absolute Maximum Error maxErrors = dfError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL workVector % Free () CALL dfInterp % Free () CALL dfActual % Free () CALL dfError % Free () END SUBROUTINE VectorDivergence3D_Test","tags":"","loc":"proc/vectordivergence3d_test.html"},{"title":"VectorGradient2D_Test – SELF","text":"public subroutine VectorGradient2D_Test(cqType, tqType, cqDegree, tqDegree, dForm, nElem, nVar, vectorChar, tensorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: dForm integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:2) character(len=240), intent(in) :: tensorChar (1:2,1:2) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~vectorgradient2d_test~~CallsGraph proc~vectorgradient2d_test VectorGradient2D_Test proc~int2str Int2Str proc~vectorgradient2d_test->proc~int2str info info proc~vectorgradient2d_test->info equationparser equationparser proc~vectorgradient2d_test->equationparser proc~float2str Float2Str proc~vectorgradient2d_test->proc~float2str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorGradient2D_Test Source Code SUBROUTINE VectorGradient2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nvar ,& vectorChar , tensorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorGradient2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: dForm INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 2 ) CHARACTER ( 240 ), INTENT ( in ) :: tensorChar ( 1 : 2 , 1 : 2 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh TYPE ( SEMQuad ) :: controlGeometry TYPE ( EquationParser ) :: feq ( 1 : 2 ), dfeqChar ( 1 : 2 , 1 : 2 ) TYPE ( MappedVector2D ) :: f TYPE ( MappedScalar2D ) :: workScalar TYPE ( MappedVector2D ) :: workVector TYPE ( MappedTensor2D ) :: workTensor TYPE ( MappedTensor2D ) :: dfInterp , dfActual , dfError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , j , ivar , row , col , iside error = 0 IF ( dForm == selfStrongForm ) THEN msg = 'Formulation Type : Strong Form' ELSEIF ( dForm == selfWeakDGForm ) THEN msg = 'Formulation Type : Weak DG Form' ELSEIF ( dForm == selfWeakCGForm ) THEN msg = 'Formulation Type : Weak CG Form' ENDIF INFO ( TRIM ( msg )) msg = 'Number of elements : ' // Int2Str ( nElem ) msg = 'Number of elements : ' // Int2Str ( nElem * nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfInterp % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create work objects CALL workScalar % Init ( cqDegree , cqType , tqDegree , tqType , 2 * nvar , controlGeometry % nElem ) CALL workVector % Init ( cqDegree , cqType , tqDegree , tqType , 2 * nvar , controlGeometry % nElem ) CALL workTensor % Init ( cqDegree , cqType , tqDegree , tqType , 2 * nvar , controlGeometry % nElem ) ! Create the equation parser object DO row = 1 , 2 feq ( row ) = EquationParser ( vectorChar ( row ), ( / 'x' , 'y' / )) ENDDO DO col = 1 , 2 DO row = 1 , 2 dfeqChar ( row , col ) = EquationParser ( tensorChar ( row , col ), ( / 'x' , 'y' / )) ENDDO ENDDO ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree DO row = 1 , 2 f % interior % hostData ( row , i , j , ivar , iel ) = & feq ( row ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO DO col = 1 , 2 DO row = 1 , 2 dfActual % interior % hostData ( row , col , i , j , ivar , iel ) = & dfeqChar ( row , col ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO DO iside = 1 , 4 DO row = 1 , 2 f % boundary % hostData ( row , j , ivar , iside , iel ) = & fEq ( row ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 2 , j , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % Gradient ( workScalar , workVector , workTensor , controlGeometry , dfInterp , dForm , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL dfInterp % UpdateHost () END IF #endif dfError = dfActual - dfInterp ! Calculate Absolute Maximum Error maxErrors = dfError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL workScalar % Free () CALL workVector % Free () CALL workTensor % Free () CALL dfInterp % Free () CALL dfActual % Free () CALL dfError % Free () END SUBROUTINE VectorGradient2D_Test","tags":"","loc":"proc/vectorgradient2d_test.html"},{"title":"VectorGradient3D_Test – SELF","text":"public subroutine VectorGradient3D_Test(cqType, tqType, cqDegree, tqDegree, dForm, nElem, nVar, vectorChar, tensorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: dForm integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:3) character(len=240), intent(in) :: tensorChar (1:3,1:3) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~vectorgradient3d_test~~CallsGraph proc~vectorgradient3d_test VectorGradient3D_Test proc~int2str Int2Str proc~vectorgradient3d_test->proc~int2str info info proc~vectorgradient3d_test->info equationparser equationparser proc~vectorgradient3d_test->equationparser proc~float2str Float2Str proc~vectorgradient3d_test->proc~float2str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vectorgradient3d_test~~CalledByGraph proc~vectorgradient3d_test VectorGradient3D_Test program~self SELF program~self->proc~vectorgradient3d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorGradient3D_Test Source Code SUBROUTINE VectorGradient3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nvar ,& vectorChar , tensorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorGradient3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: dForm INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 3 ) CHARACTER ( 240 ), INTENT ( in ) :: tensorChar ( 1 : 3 , 1 : 3 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh TYPE ( SEMHex ) :: controlGeometry TYPE ( EquationParser ) :: feq ( 1 : 3 ), dfeqChar ( 1 : 3 , 1 : 3 ) TYPE ( MappedVector3D ) :: f TYPE ( MappedScalar3D ) :: workScalar TYPE ( MappedVector3D ) :: workVector TYPE ( MappedTensor3D ) :: workTensor TYPE ( MappedTensor3D ) :: dfInterp , dfActual , dfError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: iel , i , j , k , ivar , row , col , iside error = 0 IF ( dForm == selfStrongForm ) THEN msg = 'Formulation Type : Strong Form' ELSEIF ( dForm == selfWeakDGForm ) THEN msg = 'Formulation Type : Weak DG Form' ELSEIF ( dForm == selfWeakCGForm ) THEN msg = 'Formulation Type : Weak CG Form' ENDIF INFO ( TRIM ( msg )) msg = 'Number of elements : ' // Int2Str ( nElem ) msg = 'Number of elements : ' // Int2Str ( nElem * nElem * nElem ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) msg = 'Error tolerance : ' // Float2Str ( tolerance ) INFO ( TRIM ( msg )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfInterp % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfActual % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) CALL dfError % Init ( cqDegree , cqType , tqDegree , tqType , nvar , controlGeometry % nElem ) ! Create work objects CALL workScalar % Init ( cqDegree , cqType , tqDegree , tqType , 3 * nvar , controlGeometry % nElem ) CALL workVector % Init ( cqDegree , cqType , tqDegree , tqType , 3 * nvar , controlGeometry % nElem ) CALL workTensor % Init ( cqDegree , cqType , tqDegree , tqType , 3 * nvar , controlGeometry % nElem ) ! Create the equation parser object DO row = 1 , 3 feq ( row ) = EquationParser ( vectorChar ( row ), ( / 'x' , 'y' , 'z' / )) ENDDO DO col = 1 , 3 DO row = 1 , 3 dfeqChar ( row , col ) = EquationParser ( tensorChar ( row , col ), ( / 'x' , 'y' , 'z' / )) ENDDO ENDDO ! Load the control function DO iel = 1 , controlGeometry % nElem DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree DO row = 1 , 3 f % interior % hostData ( row , i , j , k , ivar , iel ) = & feq ( row ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO DO col = 1 , 3 DO row = 1 , 3 dfActual % interior % hostData ( row , col , i , j , k , ivar , iel ) = & dfeqChar ( row , col ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO DO iside = 1 , 6 DO row = 1 , 3 f % boundary % hostData ( row , j , k , ivar , iside , iel ) = & feq ( row ) % Evaluate ( controlGeometry % x % boundary % hostData ( 1 : 3 , j , k , 1 , iside , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % Gradient ( workScalar , workVector , workTensor , controlGeometry , dfInterp , dForm , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL dfInterp % UpdateHost () END IF #endif dfError = dfActual - dfInterp !PRINT*, dfError % interior % hostData ! Calculate Absolute Maximum Error maxErrors = dfError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL f % Free () CALL workScalar % Free () CALL workVector % Free () CALL workTensor % Free () CALL dfInterp % Free () CALL dfActual % Free () CALL dfError % Free () END SUBROUTINE VectorGradient3D_Test","tags":"","loc":"proc/vectorgradient3d_test.html"},{"title":"VectorInterp2D_Test – SELF","text":"public subroutine VectorInterp2D_Test(cqType, tqType, cqDegree, tqDegree, nElem, nVar, vectorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:2) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~vectorinterp2d_test~~CallsGraph proc~vectorinterp2d_test VectorInterp2D_Test proc~int2str Int2Str proc~vectorinterp2d_test->proc~int2str equationparser equationparser proc~vectorinterp2d_test->equationparser proc~float2str Float2Str proc~vectorinterp2d_test->proc~float2str info info proc~vectorinterp2d_test->info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorInterp2D_Test Source Code SUBROUTINE VectorInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& vectorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorInterp2D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 2 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh2D ) :: controlMesh , targetMesh TYPE ( SEMQuad ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: vEq ( 1 : 2 ) TYPE ( Vector2D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: nel , iel , jel INTEGER :: i , j , ivar , idir nel = nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the target mesh and geometry CALL targetMesh % UniformBlockMesh ( tqDegree , & ( / nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL targetGeometry % GenerateFromMesh ( targetMesh , tqType , tqType , tqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fInterp % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO idir = 1 , 2 vEq ( idir ) = EquationParser ( vectorChar ( idir ), ( / 'x' , 'y' / )) ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , cqDegree DO i = 0 , cqDegree DO idir = 1 , 2 f % interior % hostData ( idir , i , j , ivar , iel ) = & vEq ( idir ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ! Load the target function DO iel = 1 , nel DO ivar = 1 , nvar DO j = 0 , tqDegree DO i = 0 , tqDegree DO idir = 1 , 2 fActual % interior % hostData ( idir , i , j , ivar , iel ) = & vEq ( idir ) % Evaluate ( targetGeometry % x % interior % hostData ( 1 : 2 , i , j , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % GridInterp ( fInterp , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL fInterp % UpdateHost () END IF #endif fError = fActual - fInterp ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL targetMesh % Free () CALL targetGeometry % Free () CALL f % Free () CALL fInterp % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE VectorInterp2D_Test","tags":"","loc":"proc/vectorinterp2d_test.html"},{"title":"VectorInterp3D_Test – SELF","text":"public subroutine VectorInterp3D_Test(cqType, tqType, cqDegree, tqDegree, nElem, nVar, vectorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:3) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error Calls proc~~vectorinterp3d_test~~CallsGraph proc~vectorinterp3d_test VectorInterp3D_Test proc~int2str Int2Str proc~vectorinterp3d_test->proc~int2str equationparser equationparser proc~vectorinterp3d_test->equationparser proc~float2str Float2Str proc~vectorinterp3d_test->proc~float2str info info proc~vectorinterp3d_test->info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vectorinterp3d_test~~CalledByGraph proc~vectorinterp3d_test VectorInterp3D_Test program~self SELF program~self->proc~vectorinterp3d_test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code VectorInterp3D_Test Source Code SUBROUTINE VectorInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nvar ,& vectorChar , tolerance , gpuAccel , error ) #undef __FUNC__ #define __FUNC__ \"VectorInterp3D_Test\" IMPLICIT NONE INTEGER , INTENT ( in ) :: cqType INTEGER , INTENT ( in ) :: tqType INTEGER , INTENT ( in ) :: cqDegree INTEGER , INTENT ( in ) :: tqDegree INTEGER , INTENT ( in ) :: nElem INTEGER , INTENT ( in ) :: nVar CHARACTER ( 240 ), INTENT ( in ) :: vectorChar ( 1 : 3 ) REAL ( prec ), INTENT ( in ) :: tolerance LOGICAL , INTENT ( in ) :: gpuAccel INTEGER , INTENT ( out ) :: error ! Local CHARACTER ( 240 ) :: msg TYPE ( Mesh3D ) :: controlMesh , targetMesh TYPE ( SEMHex ) :: controlGeometry , targetGeometry TYPE ( EquationParser ) :: vEq ( 1 : 3 ) TYPE ( Vector3D ) :: f , fInterp , fActual , fError REAL ( prec ) :: maxErrors ( 1 : nvar ) INTEGER :: nel , iel INTEGER :: i , j , k , ivar , idir nel = nElem * nElem * nElem error = 0 msg = 'Number of elements : ' // Int2Str ( nEl ) INFO ( TRIM ( msg )) msg = 'Number of control points : ' // Int2Str ( cqDegree ) INFO ( TRIM ( msg )) msg = 'Number of target points : ' // Int2Str ( tqDegree ) INFO ( TRIM ( msg )) msg = 'Number of variables : ' // Int2Str ( nvar ) INFO ( TRIM ( msg )) INFO ( 'Error tolerance : ' // Float2Str ( tolerance )) ! Create the control mesh and geometry CALL controlMesh % UniformBlockMesh ( cqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL controlGeometry % GenerateFromMesh ( controlMesh , cqType , tqType , cqDegree , tqDegree ) ! Create the target mesh and geometry CALL targetMesh % UniformBlockMesh ( tqDegree , & ( / nElem , nElem , nElem / ), & ( / 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec , & 0.0_prec , 1.0_prec / )) CALL targetGeometry % GenerateFromMesh ( targetMesh , tqType , tqType , tqDegree , tqDegree ) ! Create the scalar1d objects CALL f % Init ( cqDegree , cqType , tqDegree , tqType , nvar , nEl ) CALL fInterp % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fActual % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) CALL fError % Init ( tqDegree , tqType , tqDegree , tqType , nvar , nEl ) ! Create the equation parser object DO idir = 1 , 3 vEq ( idir ) = EquationParser ( vectorChar ( idir ), ( / 'x' , 'y' , 'z' / )) ENDDO ! Load the control function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , cqDegree DO j = 0 , cqDegree DO i = 0 , cqDegree DO idir = 1 , 3 f % interior % hostData ( idir , i , j , k , ivar , iel ) = & vEq ( idir ) % Evaluate ( controlGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO ! Load the target function DO iel = 1 , nel DO ivar = 1 , nvar DO k = 0 , tqDegree DO j = 0 , tqDegree DO i = 0 , tqDegree DO idir = 1 , 3 fActual % interior % hostData ( idir , i , j , k , ivar , iel ) = & vEq ( idir ) % Evaluate ( targetGeometry % x % interior % hostData ( 1 : 3 , i , j , k , 1 , iel ) ) ENDDO ENDDO ENDDO ENDDO ENDDO ENDDO #ifdef GPU IF ( gpuAccel ) THEN CALL f % UpdateDevice () END IF #endif ! Run the grid interpolation CALL f % GridInterp ( fInterp , gpuAccel ) #ifdef GPU IF ( gpuAccel ) THEN CALL fInterp % UpdateHost () END IF #endif fError = fActual - fInterp ! Calculate Absolute Maximum Error maxErrors = fError % AbsMaxInterior ( ) msg = \"Numerical Error : \" // Float2Str ( maxErrors ( 1 )) IF ( maxErrors ( 1 ) > tolerance ) THEN error = error + 1 ERROR ( TRIM ( msg )) ERROR ( \"Status : [FAIL]\" ) ELSE INFO ( TRIM ( msg )) INFO ( \"Status : [PASS]\" ) END IF ! Clean up CALL controlMesh % Free () CALL controlGeometry % Free () CALL targetMesh % Free () CALL targetGeometry % Free () CALL f % Free () CALL fInterp % Free () CALL fActual % Free () CALL fError % Free () END SUBROUTINE VectorInterp3D_Test","tags":"","loc":"proc/vectorinterp3d_test.html"},{"title":"Alloc_hfInt32_r1 – SELF","text":"public subroutine Alloc_hfInt32_r1(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound Calls proc~~alloc_hfint32_r1~~CallsGraph proc~alloc_hfint32_r1 Alloc_hfInt32_r1 hipmalloc hipmalloc proc~alloc_hfint32_r1->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt32_r1 Source Code SUBROUTINE Alloc_hfInt32_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt32_r1","tags":"","loc":"proc/alloc_hfint32_r1.html"},{"title":"Alloc_hfInt32_r2 – SELF","text":"public subroutine Alloc_hfInt32_r2(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) Calls proc~~alloc_hfint32_r2~~CallsGraph proc~alloc_hfint32_r2 Alloc_hfInt32_r2 hipmalloc hipmalloc proc~alloc_hfint32_r2->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt32_r2 Source Code SUBROUTINE Alloc_hfInt32_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt32_r2","tags":"","loc":"proc/alloc_hfint32_r2.html"},{"title":"Alloc_hfInt32_r3 – SELF","text":"public subroutine Alloc_hfInt32_r3(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) Calls proc~~alloc_hfint32_r3~~CallsGraph proc~alloc_hfint32_r3 Alloc_hfInt32_r3 hipmalloc hipmalloc proc~alloc_hfint32_r3->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt32_r3 Source Code SUBROUTINE Alloc_hfInt32_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt32_r3","tags":"","loc":"proc/alloc_hfint32_r3.html"},{"title":"Alloc_hfInt32_r4 – SELF","text":"public subroutine Alloc_hfInt32_r4(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) Calls proc~~alloc_hfint32_r4~~CallsGraph proc~alloc_hfint32_r4 Alloc_hfInt32_r4 hipmalloc hipmalloc proc~alloc_hfint32_r4->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt32_r4 Source Code SUBROUTINE Alloc_hfInt32_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt32_r4","tags":"","loc":"proc/alloc_hfint32_r4.html"},{"title":"Alloc_hfInt32_r5 – SELF","text":"public subroutine Alloc_hfInt32_r5(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) Calls proc~~alloc_hfint32_r5~~CallsGraph proc~alloc_hfint32_r5 Alloc_hfInt32_r5 hipmalloc hipmalloc proc~alloc_hfint32_r5->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt32_r5 Source Code SUBROUTINE Alloc_hfInt32_r5 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 5 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 5 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt32_r5","tags":"","loc":"proc/alloc_hfint32_r5.html"},{"title":"Alloc_hfInt32_r6 – SELF","text":"public subroutine Alloc_hfInt32_r6(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) Calls proc~~alloc_hfint32_r6~~CallsGraph proc~alloc_hfint32_r6 Alloc_hfInt32_r6 hipmalloc hipmalloc proc~alloc_hfint32_r6->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt32_r6 Source Code SUBROUTINE Alloc_hfInt32_r6 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 6 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 6 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt32_r6","tags":"","loc":"proc/alloc_hfint32_r6.html"},{"title":"Alloc_hfInt32_r7 – SELF","text":"public subroutine Alloc_hfInt32_r7(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) Calls proc~~alloc_hfint32_r7~~CallsGraph proc~alloc_hfint32_r7 Alloc_hfInt32_r7 hipmalloc hipmalloc proc~alloc_hfint32_r7->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt32_r7 Source Code SUBROUTINE Alloc_hfInt32_r7 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 7 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 7 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ), & loBound ( 7 ): upBound ( 7 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt32_r7","tags":"","loc":"proc/alloc_hfint32_r7.html"},{"title":"Alloc_hfInt64_r1 – SELF","text":"public subroutine Alloc_hfInt64_r1(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound Calls proc~~alloc_hfint64_r1~~CallsGraph proc~alloc_hfint64_r1 Alloc_hfInt64_r1 hipmalloc hipmalloc proc~alloc_hfint64_r1->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt64_r1 Source Code SUBROUTINE Alloc_hfInt64_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt64_r1","tags":"","loc":"proc/alloc_hfint64_r1.html"},{"title":"Alloc_hfInt64_r2 – SELF","text":"public subroutine Alloc_hfInt64_r2(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) Calls proc~~alloc_hfint64_r2~~CallsGraph proc~alloc_hfint64_r2 Alloc_hfInt64_r2 hipmalloc hipmalloc proc~alloc_hfint64_r2->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt64_r2 Source Code SUBROUTINE Alloc_hfInt64_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt64_r2","tags":"","loc":"proc/alloc_hfint64_r2.html"},{"title":"Alloc_hfInt64_r3 – SELF","text":"public subroutine Alloc_hfInt64_r3(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) Calls proc~~alloc_hfint64_r3~~CallsGraph proc~alloc_hfint64_r3 Alloc_hfInt64_r3 hipmalloc hipmalloc proc~alloc_hfint64_r3->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt64_r3 Source Code SUBROUTINE Alloc_hfInt64_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt64_r3","tags":"","loc":"proc/alloc_hfint64_r3.html"},{"title":"Alloc_hfInt64_r4 – SELF","text":"public subroutine Alloc_hfInt64_r4(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) Calls proc~~alloc_hfint64_r4~~CallsGraph proc~alloc_hfint64_r4 Alloc_hfInt64_r4 hipmalloc hipmalloc proc~alloc_hfint64_r4->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt64_r4 Source Code SUBROUTINE Alloc_hfInt64_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt64_r4","tags":"","loc":"proc/alloc_hfint64_r4.html"},{"title":"Alloc_hfInt64_r5 – SELF","text":"public subroutine Alloc_hfInt64_r5(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) Calls proc~~alloc_hfint64_r5~~CallsGraph proc~alloc_hfint64_r5 Alloc_hfInt64_r5 hipmalloc hipmalloc proc~alloc_hfint64_r5->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt64_r5 Source Code SUBROUTINE Alloc_hfInt64_r5 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 5 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 5 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt64_r5","tags":"","loc":"proc/alloc_hfint64_r5.html"},{"title":"Alloc_hfInt64_r6 – SELF","text":"public subroutine Alloc_hfInt64_r6(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) Calls proc~~alloc_hfint64_r6~~CallsGraph proc~alloc_hfint64_r6 Alloc_hfInt64_r6 hipmalloc hipmalloc proc~alloc_hfint64_r6->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt64_r6 Source Code SUBROUTINE Alloc_hfInt64_r6 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 6 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 6 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt64_r6","tags":"","loc":"proc/alloc_hfint64_r6.html"},{"title":"Alloc_hfInt64_r7 – SELF","text":"public subroutine Alloc_hfInt64_r7(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) Calls proc~~alloc_hfint64_r7~~CallsGraph proc~alloc_hfint64_r7 Alloc_hfInt64_r7 hipmalloc hipmalloc proc~alloc_hfint64_r7->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfInt64_r7 Source Code SUBROUTINE Alloc_hfInt64_r7 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 7 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 7 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ), & loBound ( 7 ): upBound ( 7 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfInt64_r7","tags":"","loc":"proc/alloc_hfint64_r7.html"},{"title":"Alloc_hfReal_r1 – SELF","text":"public subroutine Alloc_hfReal_r1(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound Calls proc~~alloc_hfreal_r1~~CallsGraph proc~alloc_hfreal_r1 Alloc_hfReal_r1 hipmalloc hipmalloc proc~alloc_hfreal_r1->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfReal_r1 Source Code SUBROUTINE Alloc_hfReal_r1 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound INTEGER , INTENT ( in ) :: upBound ALLOCATE ( this % hostData ( loBound : upBound )) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfReal_r1","tags":"","loc":"proc/alloc_hfreal_r1.html"},{"title":"Alloc_hfReal_r2 – SELF","text":"public subroutine Alloc_hfReal_r2(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) Calls proc~~alloc_hfreal_r2~~CallsGraph proc~alloc_hfreal_r2 Alloc_hfReal_r2 hipmalloc hipmalloc proc~alloc_hfreal_r2->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfReal_r2 Source Code SUBROUTINE Alloc_hfReal_r2 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 2 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 2 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfReal_r2","tags":"","loc":"proc/alloc_hfreal_r2.html"},{"title":"Alloc_hfReal_r3 – SELF","text":"public subroutine Alloc_hfReal_r3(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) Calls proc~~alloc_hfreal_r3~~CallsGraph proc~alloc_hfreal_r3 Alloc_hfReal_r3 hipmalloc hipmalloc proc~alloc_hfreal_r3->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfReal_r3 Source Code SUBROUTINE Alloc_hfReal_r3 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 3 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 3 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfReal_r3","tags":"","loc":"proc/alloc_hfreal_r3.html"},{"title":"Alloc_hfReal_r4 – SELF","text":"public subroutine Alloc_hfReal_r4(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) Calls proc~~alloc_hfreal_r4~~CallsGraph proc~alloc_hfreal_r4 Alloc_hfReal_r4 hipmalloc hipmalloc proc~alloc_hfreal_r4->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfReal_r4 Source Code SUBROUTINE Alloc_hfReal_r4 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 4 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 4 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfReal_r4","tags":"","loc":"proc/alloc_hfreal_r4.html"},{"title":"Alloc_hfReal_r5 – SELF","text":"public subroutine Alloc_hfReal_r5(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) Calls proc~~alloc_hfreal_r5~~CallsGraph proc~alloc_hfreal_r5 Alloc_hfReal_r5 hipmalloc hipmalloc proc~alloc_hfreal_r5->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfReal_r5 Source Code SUBROUTINE Alloc_hfReal_r5 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 5 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 5 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfReal_r5","tags":"","loc":"proc/alloc_hfreal_r5.html"},{"title":"Alloc_hfReal_r6 – SELF","text":"public subroutine Alloc_hfReal_r6(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) Calls proc~~alloc_hfreal_r6~~CallsGraph proc~alloc_hfreal_r6 Alloc_hfReal_r6 hipmalloc hipmalloc proc~alloc_hfreal_r6->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfReal_r6 Source Code SUBROUTINE Alloc_hfReal_r6 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 6 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 6 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfReal_r6","tags":"","loc":"proc/alloc_hfreal_r6.html"},{"title":"Alloc_hfReal_r7 – SELF","text":"public subroutine Alloc_hfReal_r7(this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) Calls proc~~alloc_hfreal_r7~~CallsGraph proc~alloc_hfreal_r7 Alloc_hfReal_r7 hipmalloc hipmalloc proc~alloc_hfreal_r7->hipmalloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Alloc_hfReal_r7 Source Code SUBROUTINE Alloc_hfReal_r7 ( this , loBound , upBound ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( out ) :: this INTEGER , INTENT ( in ) :: loBound ( 1 : 7 ) INTEGER , INTENT ( in ) :: upBound ( 1 : 7 ) ALLOCATE ( this % hostData ( loBound ( 1 ): upBound ( 1 ), & loBound ( 2 ): upBound ( 2 ), & loBound ( 3 ): upBound ( 3 ), & loBound ( 4 ): upBound ( 4 ), & loBound ( 5 ): upBound ( 5 ), & loBound ( 6 ): upBound ( 6 ), & loBound ( 7 ): upBound ( 7 ))) #ifdef GPU CALL hipCheck ( hipMalloc ( this % deviceData , SIZEOF ( this % hostData ))) #endif END SUBROUTINE Alloc_hfReal_r7","tags":"","loc":"proc/alloc_hfreal_r7.html"},{"title":"Free_hfInt32_r1 – SELF","text":"public subroutine Free_hfInt32_r1(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this Calls proc~~free_hfint32_r1~~CallsGraph proc~free_hfint32_r1 Free_hfInt32_r1 hipfree hipfree proc~free_hfint32_r1->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt32_r1 Source Code SUBROUTINE Free_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt32_r1","tags":"","loc":"proc/free_hfint32_r1.html"},{"title":"Free_hfInt32_r2 – SELF","text":"public subroutine Free_hfInt32_r2(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this Calls proc~~free_hfint32_r2~~CallsGraph proc~free_hfint32_r2 Free_hfInt32_r2 hipfree hipfree proc~free_hfint32_r2->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt32_r2 Source Code SUBROUTINE Free_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt32_r2","tags":"","loc":"proc/free_hfint32_r2.html"},{"title":"Free_hfInt32_r3 – SELF","text":"public subroutine Free_hfInt32_r3(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this Calls proc~~free_hfint32_r3~~CallsGraph proc~free_hfint32_r3 Free_hfInt32_r3 hipfree hipfree proc~free_hfint32_r3->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt32_r3 Source Code SUBROUTINE Free_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt32_r3","tags":"","loc":"proc/free_hfint32_r3.html"},{"title":"Free_hfInt32_r4 – SELF","text":"public subroutine Free_hfInt32_r4(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this Calls proc~~free_hfint32_r4~~CallsGraph proc~free_hfint32_r4 Free_hfInt32_r4 hipfree hipfree proc~free_hfint32_r4->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt32_r4 Source Code SUBROUTINE Free_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt32_r4","tags":"","loc":"proc/free_hfint32_r4.html"},{"title":"Free_hfInt32_r5 – SELF","text":"public subroutine Free_hfInt32_r5(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this Calls proc~~free_hfint32_r5~~CallsGraph proc~free_hfint32_r5 Free_hfInt32_r5 hipfree hipfree proc~free_hfint32_r5->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt32_r5 Source Code SUBROUTINE Free_hfInt32_r5 ( this ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt32_r5","tags":"","loc":"proc/free_hfint32_r5.html"},{"title":"Free_hfInt32_r6 – SELF","text":"public subroutine Free_hfInt32_r6(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this Calls proc~~free_hfint32_r6~~CallsGraph proc~free_hfint32_r6 Free_hfInt32_r6 hipfree hipfree proc~free_hfint32_r6->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt32_r6 Source Code SUBROUTINE Free_hfInt32_r6 ( this ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt32_r6","tags":"","loc":"proc/free_hfint32_r6.html"},{"title":"Free_hfInt32_r7 – SELF","text":"public subroutine Free_hfInt32_r7(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this Calls proc~~free_hfint32_r7~~CallsGraph proc~free_hfint32_r7 Free_hfInt32_r7 hipfree hipfree proc~free_hfint32_r7->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt32_r7 Source Code SUBROUTINE Free_hfInt32_r7 ( this ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt32_r7","tags":"","loc":"proc/free_hfint32_r7.html"},{"title":"Free_hfInt64_r1 – SELF","text":"public subroutine Free_hfInt64_r1(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this Calls proc~~free_hfint64_r1~~CallsGraph proc~free_hfint64_r1 Free_hfInt64_r1 hipfree hipfree proc~free_hfint64_r1->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt64_r1 Source Code SUBROUTINE Free_hfInt64_r1 ( this ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt64_r1","tags":"","loc":"proc/free_hfint64_r1.html"},{"title":"Free_hfInt64_r2 – SELF","text":"public subroutine Free_hfInt64_r2(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this Calls proc~~free_hfint64_r2~~CallsGraph proc~free_hfint64_r2 Free_hfInt64_r2 hipfree hipfree proc~free_hfint64_r2->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt64_r2 Source Code SUBROUTINE Free_hfInt64_r2 ( this ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt64_r2","tags":"","loc":"proc/free_hfint64_r2.html"},{"title":"Free_hfInt64_r3 – SELF","text":"public subroutine Free_hfInt64_r3(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this Calls proc~~free_hfint64_r3~~CallsGraph proc~free_hfint64_r3 Free_hfInt64_r3 hipfree hipfree proc~free_hfint64_r3->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt64_r3 Source Code SUBROUTINE Free_hfInt64_r3 ( this ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt64_r3","tags":"","loc":"proc/free_hfint64_r3.html"},{"title":"Free_hfInt64_r4 – SELF","text":"public subroutine Free_hfInt64_r4(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this Calls proc~~free_hfint64_r4~~CallsGraph proc~free_hfint64_r4 Free_hfInt64_r4 hipfree hipfree proc~free_hfint64_r4->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt64_r4 Source Code SUBROUTINE Free_hfInt64_r4 ( this ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt64_r4","tags":"","loc":"proc/free_hfint64_r4.html"},{"title":"Free_hfInt64_r5 – SELF","text":"public subroutine Free_hfInt64_r5(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this Calls proc~~free_hfint64_r5~~CallsGraph proc~free_hfint64_r5 Free_hfInt64_r5 hipfree hipfree proc~free_hfint64_r5->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt64_r5 Source Code SUBROUTINE Free_hfInt64_r5 ( this ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt64_r5","tags":"","loc":"proc/free_hfint64_r5.html"},{"title":"Free_hfInt64_r6 – SELF","text":"public subroutine Free_hfInt64_r6(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this Calls proc~~free_hfint64_r6~~CallsGraph proc~free_hfint64_r6 Free_hfInt64_r6 hipfree hipfree proc~free_hfint64_r6->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt64_r6 Source Code SUBROUTINE Free_hfInt64_r6 ( this ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt64_r6","tags":"","loc":"proc/free_hfint64_r6.html"},{"title":"Free_hfInt64_r7 – SELF","text":"public subroutine Free_hfInt64_r7(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this Calls proc~~free_hfint64_r7~~CallsGraph proc~free_hfint64_r7 Free_hfInt64_r7 hipfree hipfree proc~free_hfint64_r7->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfInt64_r7 Source Code SUBROUTINE Free_hfInt64_r7 ( this ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfInt64_r7","tags":"","loc":"proc/free_hfint64_r7.html"},{"title":"Free_hfReal_r1 – SELF","text":"public subroutine Free_hfReal_r1(this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this Calls proc~~free_hfreal_r1~~CallsGraph proc~free_hfreal_r1 Free_hfReal_r1 hipfree hipfree proc~free_hfreal_r1->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfReal_r1 Source Code SUBROUTINE Free_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfReal_r1","tags":"","loc":"proc/free_hfreal_r1.html"},{"title":"Free_hfReal_r2 – SELF","text":"public subroutine Free_hfReal_r2(this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this Calls proc~~free_hfreal_r2~~CallsGraph proc~free_hfreal_r2 Free_hfReal_r2 hipfree hipfree proc~free_hfreal_r2->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfReal_r2 Source Code SUBROUTINE Free_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfReal_r2","tags":"","loc":"proc/free_hfreal_r2.html"},{"title":"Free_hfReal_r3 – SELF","text":"public subroutine Free_hfReal_r3(this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this Calls proc~~free_hfreal_r3~~CallsGraph proc~free_hfreal_r3 Free_hfReal_r3 hipfree hipfree proc~free_hfreal_r3->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfReal_r3 Source Code SUBROUTINE Free_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfReal_r3","tags":"","loc":"proc/free_hfreal_r3.html"},{"title":"Free_hfReal_r4 – SELF","text":"public subroutine Free_hfReal_r4(this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this Calls proc~~free_hfreal_r4~~CallsGraph proc~free_hfreal_r4 Free_hfReal_r4 hipfree hipfree proc~free_hfreal_r4->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfReal_r4 Source Code SUBROUTINE Free_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfReal_r4","tags":"","loc":"proc/free_hfreal_r4.html"},{"title":"Free_hfReal_r5 – SELF","text":"public subroutine Free_hfReal_r5(this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this Calls proc~~free_hfreal_r5~~CallsGraph proc~free_hfreal_r5 Free_hfReal_r5 hipfree hipfree proc~free_hfreal_r5->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfReal_r5 Source Code SUBROUTINE Free_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfReal_r5","tags":"","loc":"proc/free_hfreal_r5.html"},{"title":"Free_hfReal_r6 – SELF","text":"public subroutine Free_hfReal_r6(this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this Calls proc~~free_hfreal_r6~~CallsGraph proc~free_hfreal_r6 Free_hfReal_r6 hipfree hipfree proc~free_hfreal_r6->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfReal_r6 Source Code SUBROUTINE Free_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfReal_r6","tags":"","loc":"proc/free_hfreal_r6.html"},{"title":"Free_hfReal_r7 – SELF","text":"public subroutine Free_hfReal_r7(this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this Calls proc~~free_hfreal_r7~~CallsGraph proc~free_hfreal_r7 Free_hfReal_r7 hipfree hipfree proc~free_hfreal_r7->hipfree Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Free_hfReal_r7 Source Code SUBROUTINE Free_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this DEALLOCATE ( this % hostData ) #ifdef GPU CALL hipCheck ( hipFree ( this % deviceData )) #endif END SUBROUTINE Free_hfReal_r7","tags":"","loc":"proc/free_hfreal_r7.html"},{"title":"UpdateDevice_hfInt32_r1 – SELF","text":"public subroutine UpdateDevice_hfInt32_r1(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this Calls proc~~updatedevice_hfint32_r1~~CallsGraph proc~updatedevice_hfint32_r1 UpdateDevice_hfInt32_r1 hipmemcpy hipmemcpy proc~updatedevice_hfint32_r1->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt32_r1 Source Code SUBROUTINE UpdateDevice_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt32_r1","tags":"","loc":"proc/updatedevice_hfint32_r1.html"},{"title":"UpdateDevice_hfInt32_r2 – SELF","text":"public subroutine UpdateDevice_hfInt32_r2(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this Calls proc~~updatedevice_hfint32_r2~~CallsGraph proc~updatedevice_hfint32_r2 UpdateDevice_hfInt32_r2 hipmemcpy hipmemcpy proc~updatedevice_hfint32_r2->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt32_r2 Source Code SUBROUTINE UpdateDevice_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt32_r2","tags":"","loc":"proc/updatedevice_hfint32_r2.html"},{"title":"UpdateDevice_hfInt32_r3 – SELF","text":"public subroutine UpdateDevice_hfInt32_r3(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this Calls proc~~updatedevice_hfint32_r3~~CallsGraph proc~updatedevice_hfint32_r3 UpdateDevice_hfInt32_r3 hipmemcpy hipmemcpy proc~updatedevice_hfint32_r3->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt32_r3 Source Code SUBROUTINE UpdateDevice_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt32_r3","tags":"","loc":"proc/updatedevice_hfint32_r3.html"},{"title":"UpdateDevice_hfInt32_r4 – SELF","text":"public subroutine UpdateDevice_hfInt32_r4(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this Calls proc~~updatedevice_hfint32_r4~~CallsGraph proc~updatedevice_hfint32_r4 UpdateDevice_hfInt32_r4 hipmemcpy hipmemcpy proc~updatedevice_hfint32_r4->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt32_r4 Source Code SUBROUTINE UpdateDevice_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt32_r4","tags":"","loc":"proc/updatedevice_hfint32_r4.html"},{"title":"UpdateDevice_hfInt32_r5 – SELF","text":"public subroutine UpdateDevice_hfInt32_r5(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this Calls proc~~updatedevice_hfint32_r5~~CallsGraph proc~updatedevice_hfint32_r5 UpdateDevice_hfInt32_r5 hipmemcpy hipmemcpy proc~updatedevice_hfint32_r5->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt32_r5 Source Code SUBROUTINE UpdateDevice_hfInt32_r5 ( this ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt32_r5","tags":"","loc":"proc/updatedevice_hfint32_r5.html"},{"title":"UpdateDevice_hfInt32_r6 – SELF","text":"public subroutine UpdateDevice_hfInt32_r6(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this Calls proc~~updatedevice_hfint32_r6~~CallsGraph proc~updatedevice_hfint32_r6 UpdateDevice_hfInt32_r6 hipmemcpy hipmemcpy proc~updatedevice_hfint32_r6->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt32_r6 Source Code SUBROUTINE UpdateDevice_hfInt32_r6 ( this ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt32_r6","tags":"","loc":"proc/updatedevice_hfint32_r6.html"},{"title":"UpdateDevice_hfInt32_r7 – SELF","text":"public subroutine UpdateDevice_hfInt32_r7(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this Calls proc~~updatedevice_hfint32_r7~~CallsGraph proc~updatedevice_hfint32_r7 UpdateDevice_hfInt32_r7 hipmemcpy hipmemcpy proc~updatedevice_hfint32_r7->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt32_r7 Source Code SUBROUTINE UpdateDevice_hfInt32_r7 ( this ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt32_r7","tags":"","loc":"proc/updatedevice_hfint32_r7.html"},{"title":"UpdateDevice_hfInt64_r1 – SELF","text":"public subroutine UpdateDevice_hfInt64_r1(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this Calls proc~~updatedevice_hfint64_r1~~CallsGraph proc~updatedevice_hfint64_r1 UpdateDevice_hfInt64_r1 hipmemcpy hipmemcpy proc~updatedevice_hfint64_r1->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt64_r1 Source Code SUBROUTINE UpdateDevice_hfInt64_r1 ( this ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt64_r1","tags":"","loc":"proc/updatedevice_hfint64_r1.html"},{"title":"UpdateDevice_hfInt64_r2 – SELF","text":"public subroutine UpdateDevice_hfInt64_r2(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this Calls proc~~updatedevice_hfint64_r2~~CallsGraph proc~updatedevice_hfint64_r2 UpdateDevice_hfInt64_r2 hipmemcpy hipmemcpy proc~updatedevice_hfint64_r2->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt64_r2 Source Code SUBROUTINE UpdateDevice_hfInt64_r2 ( this ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt64_r2","tags":"","loc":"proc/updatedevice_hfint64_r2.html"},{"title":"UpdateDevice_hfInt64_r3 – SELF","text":"public subroutine UpdateDevice_hfInt64_r3(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this Calls proc~~updatedevice_hfint64_r3~~CallsGraph proc~updatedevice_hfint64_r3 UpdateDevice_hfInt64_r3 hipmemcpy hipmemcpy proc~updatedevice_hfint64_r3->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt64_r3 Source Code SUBROUTINE UpdateDevice_hfInt64_r3 ( this ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt64_r3","tags":"","loc":"proc/updatedevice_hfint64_r3.html"},{"title":"UpdateDevice_hfInt64_r4 – SELF","text":"public subroutine UpdateDevice_hfInt64_r4(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this Calls proc~~updatedevice_hfint64_r4~~CallsGraph proc~updatedevice_hfint64_r4 UpdateDevice_hfInt64_r4 hipmemcpy hipmemcpy proc~updatedevice_hfint64_r4->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt64_r4 Source Code SUBROUTINE UpdateDevice_hfInt64_r4 ( this ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt64_r4","tags":"","loc":"proc/updatedevice_hfint64_r4.html"},{"title":"UpdateDevice_hfInt64_r5 – SELF","text":"public subroutine UpdateDevice_hfInt64_r5(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this Calls proc~~updatedevice_hfint64_r5~~CallsGraph proc~updatedevice_hfint64_r5 UpdateDevice_hfInt64_r5 hipmemcpy hipmemcpy proc~updatedevice_hfint64_r5->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt64_r5 Source Code SUBROUTINE UpdateDevice_hfInt64_r5 ( this ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt64_r5","tags":"","loc":"proc/updatedevice_hfint64_r5.html"},{"title":"UpdateDevice_hfInt64_r6 – SELF","text":"public subroutine UpdateDevice_hfInt64_r6(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this Calls proc~~updatedevice_hfint64_r6~~CallsGraph proc~updatedevice_hfint64_r6 UpdateDevice_hfInt64_r6 hipmemcpy hipmemcpy proc~updatedevice_hfint64_r6->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt64_r6 Source Code SUBROUTINE UpdateDevice_hfInt64_r6 ( this ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt64_r6","tags":"","loc":"proc/updatedevice_hfint64_r6.html"},{"title":"UpdateDevice_hfInt64_r7 – SELF","text":"public subroutine UpdateDevice_hfInt64_r7(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this Calls proc~~updatedevice_hfint64_r7~~CallsGraph proc~updatedevice_hfint64_r7 UpdateDevice_hfInt64_r7 hipmemcpy hipmemcpy proc~updatedevice_hfint64_r7->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfInt64_r7 Source Code SUBROUTINE UpdateDevice_hfInt64_r7 ( this ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfInt64_r7","tags":"","loc":"proc/updatedevice_hfint64_r7.html"},{"title":"UpdateDevice_hfReal_r1 – SELF","text":"public subroutine UpdateDevice_hfReal_r1(this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this Calls proc~~updatedevice_hfreal_r1~~CallsGraph proc~updatedevice_hfreal_r1 UpdateDevice_hfReal_r1 hipmemcpy hipmemcpy proc~updatedevice_hfreal_r1->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfReal_r1 Source Code SUBROUTINE UpdateDevice_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfReal_r1","tags":"","loc":"proc/updatedevice_hfreal_r1.html"},{"title":"UpdateDevice_hfReal_r2 – SELF","text":"public subroutine UpdateDevice_hfReal_r2(this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this Calls proc~~updatedevice_hfreal_r2~~CallsGraph proc~updatedevice_hfreal_r2 UpdateDevice_hfReal_r2 hipmemcpy hipmemcpy proc~updatedevice_hfreal_r2->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfReal_r2 Source Code SUBROUTINE UpdateDevice_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfReal_r2","tags":"","loc":"proc/updatedevice_hfreal_r2.html"},{"title":"UpdateDevice_hfReal_r3 – SELF","text":"public subroutine UpdateDevice_hfReal_r3(this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this Calls proc~~updatedevice_hfreal_r3~~CallsGraph proc~updatedevice_hfreal_r3 UpdateDevice_hfReal_r3 hipmemcpy hipmemcpy proc~updatedevice_hfreal_r3->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfReal_r3 Source Code SUBROUTINE UpdateDevice_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfReal_r3","tags":"","loc":"proc/updatedevice_hfreal_r3.html"},{"title":"UpdateDevice_hfReal_r4 – SELF","text":"public subroutine UpdateDevice_hfReal_r4(this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this Calls proc~~updatedevice_hfreal_r4~~CallsGraph proc~updatedevice_hfreal_r4 UpdateDevice_hfReal_r4 hipmemcpy hipmemcpy proc~updatedevice_hfreal_r4->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfReal_r4 Source Code SUBROUTINE UpdateDevice_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfReal_r4","tags":"","loc":"proc/updatedevice_hfreal_r4.html"},{"title":"UpdateDevice_hfReal_r5 – SELF","text":"public subroutine UpdateDevice_hfReal_r5(this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this Calls proc~~updatedevice_hfreal_r5~~CallsGraph proc~updatedevice_hfreal_r5 UpdateDevice_hfReal_r5 hipmemcpy hipmemcpy proc~updatedevice_hfreal_r5->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfReal_r5 Source Code SUBROUTINE UpdateDevice_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfReal_r5","tags":"","loc":"proc/updatedevice_hfreal_r5.html"},{"title":"UpdateDevice_hfReal_r6 – SELF","text":"public subroutine UpdateDevice_hfReal_r6(this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this Calls proc~~updatedevice_hfreal_r6~~CallsGraph proc~updatedevice_hfreal_r6 UpdateDevice_hfReal_r6 hipmemcpy hipmemcpy proc~updatedevice_hfreal_r6->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfReal_r6 Source Code SUBROUTINE UpdateDevice_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfReal_r6","tags":"","loc":"proc/updatedevice_hfreal_r6.html"},{"title":"UpdateDevice_hfReal_r7 – SELF","text":"public subroutine UpdateDevice_hfReal_r7(this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this Calls proc~~updatedevice_hfreal_r7~~CallsGraph proc~updatedevice_hfreal_r7 UpdateDevice_hfReal_r7 hipmemcpy hipmemcpy proc~updatedevice_hfreal_r7->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateDevice_hfReal_r7 Source Code SUBROUTINE UpdateDevice_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( this % deviceData , & c_loc ( this % hostData ), & SIZEOF ( this % hostData ), & hipMemcpyHostToDevice )) #endif END SUBROUTINE UpdateDevice_hfReal_r7","tags":"","loc":"proc/updatedevice_hfreal_r7.html"},{"title":"UpdateHost_hfInt32_r1 – SELF","text":"public subroutine UpdateHost_hfInt32_r1(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this Calls proc~~updatehost_hfint32_r1~~CallsGraph proc~updatehost_hfint32_r1 UpdateHost_hfInt32_r1 hipmemcpy hipmemcpy proc~updatehost_hfint32_r1->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt32_r1 Source Code SUBROUTINE UpdateHost_hfInt32_r1 ( this ) IMPLICIT NONE CLASS ( hfInt32_r1 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt32_r1","tags":"","loc":"proc/updatehost_hfint32_r1.html"},{"title":"UpdateHost_hfInt32_r2 – SELF","text":"public subroutine UpdateHost_hfInt32_r2(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this Calls proc~~updatehost_hfint32_r2~~CallsGraph proc~updatehost_hfint32_r2 UpdateHost_hfInt32_r2 hipmemcpy hipmemcpy proc~updatehost_hfint32_r2->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt32_r2 Source Code SUBROUTINE UpdateHost_hfInt32_r2 ( this ) IMPLICIT NONE CLASS ( hfInt32_r2 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt32_r2","tags":"","loc":"proc/updatehost_hfint32_r2.html"},{"title":"UpdateHost_hfInt32_r3 – SELF","text":"public subroutine UpdateHost_hfInt32_r3(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this Calls proc~~updatehost_hfint32_r3~~CallsGraph proc~updatehost_hfint32_r3 UpdateHost_hfInt32_r3 hipmemcpy hipmemcpy proc~updatehost_hfint32_r3->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt32_r3 Source Code SUBROUTINE UpdateHost_hfInt32_r3 ( this ) IMPLICIT NONE CLASS ( hfInt32_r3 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt32_r3","tags":"","loc":"proc/updatehost_hfint32_r3.html"},{"title":"UpdateHost_hfInt32_r4 – SELF","text":"public subroutine UpdateHost_hfInt32_r4(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this Calls proc~~updatehost_hfint32_r4~~CallsGraph proc~updatehost_hfint32_r4 UpdateHost_hfInt32_r4 hipmemcpy hipmemcpy proc~updatehost_hfint32_r4->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt32_r4 Source Code SUBROUTINE UpdateHost_hfInt32_r4 ( this ) IMPLICIT NONE CLASS ( hfInt32_r4 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt32_r4","tags":"","loc":"proc/updatehost_hfint32_r4.html"},{"title":"UpdateHost_hfInt32_r5 – SELF","text":"public subroutine UpdateHost_hfInt32_r5(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this Calls proc~~updatehost_hfint32_r5~~CallsGraph proc~updatehost_hfint32_r5 UpdateHost_hfInt32_r5 hipmemcpy hipmemcpy proc~updatehost_hfint32_r5->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt32_r5 Source Code SUBROUTINE UpdateHost_hfInt32_r5 ( this ) IMPLICIT NONE CLASS ( hfInt32_r5 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt32_r5","tags":"","loc":"proc/updatehost_hfint32_r5.html"},{"title":"UpdateHost_hfInt32_r6 – SELF","text":"public subroutine UpdateHost_hfInt32_r6(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this Calls proc~~updatehost_hfint32_r6~~CallsGraph proc~updatehost_hfint32_r6 UpdateHost_hfInt32_r6 hipmemcpy hipmemcpy proc~updatehost_hfint32_r6->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt32_r6 Source Code SUBROUTINE UpdateHost_hfInt32_r6 ( this ) IMPLICIT NONE CLASS ( hfInt32_r6 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt32_r6","tags":"","loc":"proc/updatehost_hfint32_r6.html"},{"title":"UpdateHost_hfInt32_r7 – SELF","text":"public subroutine UpdateHost_hfInt32_r7(this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this Calls proc~~updatehost_hfint32_r7~~CallsGraph proc~updatehost_hfint32_r7 UpdateHost_hfInt32_r7 hipmemcpy hipmemcpy proc~updatehost_hfint32_r7->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt32_r7 Source Code SUBROUTINE UpdateHost_hfInt32_r7 ( this ) IMPLICIT NONE CLASS ( hfInt32_r7 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt32_r7","tags":"","loc":"proc/updatehost_hfint32_r7.html"},{"title":"UpdateHost_hfInt64_r1 – SELF","text":"public subroutine UpdateHost_hfInt64_r1(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this Calls proc~~updatehost_hfint64_r1~~CallsGraph proc~updatehost_hfint64_r1 UpdateHost_hfInt64_r1 hipmemcpy hipmemcpy proc~updatehost_hfint64_r1->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt64_r1 Source Code SUBROUTINE UpdateHost_hfInt64_r1 ( this ) IMPLICIT NONE CLASS ( hfInt64_r1 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt64_r1","tags":"","loc":"proc/updatehost_hfint64_r1.html"},{"title":"UpdateHost_hfInt64_r2 – SELF","text":"public subroutine UpdateHost_hfInt64_r2(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this Calls proc~~updatehost_hfint64_r2~~CallsGraph proc~updatehost_hfint64_r2 UpdateHost_hfInt64_r2 hipmemcpy hipmemcpy proc~updatehost_hfint64_r2->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt64_r2 Source Code SUBROUTINE UpdateHost_hfInt64_r2 ( this ) IMPLICIT NONE CLASS ( hfInt64_r2 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt64_r2","tags":"","loc":"proc/updatehost_hfint64_r2.html"},{"title":"UpdateHost_hfInt64_r3 – SELF","text":"public subroutine UpdateHost_hfInt64_r3(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this Calls proc~~updatehost_hfint64_r3~~CallsGraph proc~updatehost_hfint64_r3 UpdateHost_hfInt64_r3 hipmemcpy hipmemcpy proc~updatehost_hfint64_r3->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt64_r3 Source Code SUBROUTINE UpdateHost_hfInt64_r3 ( this ) IMPLICIT NONE CLASS ( hfInt64_r3 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt64_r3","tags":"","loc":"proc/updatehost_hfint64_r3.html"},{"title":"UpdateHost_hfInt64_r4 – SELF","text":"public subroutine UpdateHost_hfInt64_r4(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this Calls proc~~updatehost_hfint64_r4~~CallsGraph proc~updatehost_hfint64_r4 UpdateHost_hfInt64_r4 hipmemcpy hipmemcpy proc~updatehost_hfint64_r4->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt64_r4 Source Code SUBROUTINE UpdateHost_hfInt64_r4 ( this ) IMPLICIT NONE CLASS ( hfInt64_r4 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt64_r4","tags":"","loc":"proc/updatehost_hfint64_r4.html"},{"title":"UpdateHost_hfInt64_r5 – SELF","text":"public subroutine UpdateHost_hfInt64_r5(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this Calls proc~~updatehost_hfint64_r5~~CallsGraph proc~updatehost_hfint64_r5 UpdateHost_hfInt64_r5 hipmemcpy hipmemcpy proc~updatehost_hfint64_r5->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt64_r5 Source Code SUBROUTINE UpdateHost_hfInt64_r5 ( this ) IMPLICIT NONE CLASS ( hfInt64_r5 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt64_r5","tags":"","loc":"proc/updatehost_hfint64_r5.html"},{"title":"UpdateHost_hfInt64_r6 – SELF","text":"public subroutine UpdateHost_hfInt64_r6(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this Calls proc~~updatehost_hfint64_r6~~CallsGraph proc~updatehost_hfint64_r6 UpdateHost_hfInt64_r6 hipmemcpy hipmemcpy proc~updatehost_hfint64_r6->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt64_r6 Source Code SUBROUTINE UpdateHost_hfInt64_r6 ( this ) IMPLICIT NONE CLASS ( hfInt64_r6 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt64_r6","tags":"","loc":"proc/updatehost_hfint64_r6.html"},{"title":"UpdateHost_hfInt64_r7 – SELF","text":"public subroutine UpdateHost_hfInt64_r7(this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this Calls proc~~updatehost_hfint64_r7~~CallsGraph proc~updatehost_hfint64_r7 UpdateHost_hfInt64_r7 hipmemcpy hipmemcpy proc~updatehost_hfint64_r7->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfInt64_r7 Source Code SUBROUTINE UpdateHost_hfInt64_r7 ( this ) IMPLICIT NONE CLASS ( hfInt64_r7 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfInt64_r7","tags":"","loc":"proc/updatehost_hfint64_r7.html"},{"title":"UpdateHost_hfReal_r1 – SELF","text":"public subroutine UpdateHost_hfReal_r1(this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this Calls proc~~updatehost_hfreal_r1~~CallsGraph proc~updatehost_hfreal_r1 UpdateHost_hfReal_r1 hipmemcpy hipmemcpy proc~updatehost_hfreal_r1->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfReal_r1 Source Code SUBROUTINE UpdateHost_hfReal_r1 ( this ) IMPLICIT NONE CLASS ( hfReal_r1 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfReal_r1","tags":"","loc":"proc/updatehost_hfreal_r1.html"},{"title":"UpdateHost_hfReal_r2 – SELF","text":"public subroutine UpdateHost_hfReal_r2(this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this Calls proc~~updatehost_hfreal_r2~~CallsGraph proc~updatehost_hfreal_r2 UpdateHost_hfReal_r2 hipmemcpy hipmemcpy proc~updatehost_hfreal_r2->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfReal_r2 Source Code SUBROUTINE UpdateHost_hfReal_r2 ( this ) IMPLICIT NONE CLASS ( hfReal_r2 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfReal_r2","tags":"","loc":"proc/updatehost_hfreal_r2.html"},{"title":"UpdateHost_hfReal_r3 – SELF","text":"public subroutine UpdateHost_hfReal_r3(this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this Calls proc~~updatehost_hfreal_r3~~CallsGraph proc~updatehost_hfreal_r3 UpdateHost_hfReal_r3 hipmemcpy hipmemcpy proc~updatehost_hfreal_r3->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfReal_r3 Source Code SUBROUTINE UpdateHost_hfReal_r3 ( this ) IMPLICIT NONE CLASS ( hfReal_r3 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfReal_r3","tags":"","loc":"proc/updatehost_hfreal_r3.html"},{"title":"UpdateHost_hfReal_r4 – SELF","text":"public subroutine UpdateHost_hfReal_r4(this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this Calls proc~~updatehost_hfreal_r4~~CallsGraph proc~updatehost_hfreal_r4 UpdateHost_hfReal_r4 hipmemcpy hipmemcpy proc~updatehost_hfreal_r4->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfReal_r4 Source Code SUBROUTINE UpdateHost_hfReal_r4 ( this ) IMPLICIT NONE CLASS ( hfReal_r4 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfReal_r4","tags":"","loc":"proc/updatehost_hfreal_r4.html"},{"title":"UpdateHost_hfReal_r5 – SELF","text":"public subroutine UpdateHost_hfReal_r5(this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this Calls proc~~updatehost_hfreal_r5~~CallsGraph proc~updatehost_hfreal_r5 UpdateHost_hfReal_r5 hipmemcpy hipmemcpy proc~updatehost_hfreal_r5->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfReal_r5 Source Code SUBROUTINE UpdateHost_hfReal_r5 ( this ) IMPLICIT NONE CLASS ( hfReal_r5 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfReal_r5","tags":"","loc":"proc/updatehost_hfreal_r5.html"},{"title":"UpdateHost_hfReal_r6 – SELF","text":"public subroutine UpdateHost_hfReal_r6(this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this Calls proc~~updatehost_hfreal_r6~~CallsGraph proc~updatehost_hfreal_r6 UpdateHost_hfReal_r6 hipmemcpy hipmemcpy proc~updatehost_hfreal_r6->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfReal_r6 Source Code SUBROUTINE UpdateHost_hfReal_r6 ( this ) IMPLICIT NONE CLASS ( hfReal_r6 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfReal_r6","tags":"","loc":"proc/updatehost_hfreal_r6.html"},{"title":"UpdateHost_hfReal_r7 – SELF","text":"public subroutine UpdateHost_hfReal_r7(this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this Calls proc~~updatehost_hfreal_r7~~CallsGraph proc~updatehost_hfreal_r7 UpdateHost_hfReal_r7 hipmemcpy hipmemcpy proc~updatehost_hfreal_r7->hipmemcpy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code UpdateHost_hfReal_r7 Source Code SUBROUTINE UpdateHost_hfReal_r7 ( this ) IMPLICIT NONE CLASS ( hfReal_r7 ), INTENT ( inout ) :: this #ifdef GPU CALL hipCheck ( hipMemcpy ( c_loc ( this % hostData ), & this % deviceData , & SIZEOF ( this % hostData ), & hipMemcpyDeviceToHost )) #endif END SUBROUTINE UpdateHost_hfReal_r7","tags":"","loc":"proc/updatehost_hfreal_r7.html"},{"title":"SELF_Constants – SELF","text":"Uses iso_fortran_env module~~self_constants~~UsesGraph module~self_constants SELF_Constants iso_fortran_env iso_fortran_env module~self_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_constants~~UsedByGraph module~self_constants SELF_Constants module~self_lagrange SELF_Lagrange module~self_lagrange->module~self_constants module~self_supportroutines SELF_SupportRoutines module~self_lagrange->module~self_supportroutines module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_tests SELF_Tests module~self_tests->module~self_constants module~self_tests->module~self_lagrange module~self_tests->module~self_supportroutines module~self_mesh SELF_Mesh module~self_tests->module~self_mesh module~self_tests->module~self_quadrature module~self_mappeddata SELF_MappedData module~self_tests->module~self_mappeddata module~self_tests->module~self_memory module~self_data SELF_Data module~self_tests->module~self_data module~self_supportroutines->module~self_constants module~self_mesh->module~self_constants module~self_mesh->module~self_lagrange module~self_mesh->module~self_supportroutines module~self_mesh->module~self_data module~self_geometry SELF_Geometry module~self_geometry->module~self_constants module~self_geometry->module~self_lagrange module~self_geometry->module~self_supportroutines module~self_geometry->module~self_mesh module~self_geometry->module~self_data module~self_quadrature->module~self_constants program~self SELF program~self->module~self_constants program~self->module~self_tests program~self->module~self_supportroutines module~self_mappeddata->module~self_constants module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_mesh module~self_mappeddata->module~self_geometry module~self_mappeddata->module~self_data module~self_memory->module~self_constants module~self_data->module~self_constants module~self_data->module~self_lagrange module~self_mpilayer SELF_MPILayer module~self_mpilayer->module~self_mesh module~self_mpilayer->module~self_mappeddata module~self_mpilayer->module~self_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables CG DG GAUSS GAUSS_LOBATTO MsgFmt TOL UNIFORM daysToMonths daysToSeconds fillValue fillValueInt hoursToDays maxInverseIters minutesToHours monthsToYears nada newtonMax newtonTolerance pi prec prec rk3_a rk3_b rk3_g secondsToMinutes tolerance Variables Type Visibility Attributes Name Initial integer, public, parameter :: CG = 2001 integer, public, parameter :: DG = 2000 integer, public, parameter :: GAUSS = 1 integer, public, parameter :: GAUSS_LOBATTO = 2 character(len=6), public, parameter :: MsgFmt = '(2x,A)' real(kind=prec), public, parameter :: TOL = epsilon(1.0_prec) integer, public, parameter :: UNIFORM = 3 real(kind=prec), public, parameter :: daysToMonths = 12.0_prec/365.25_prec real(kind=prec), public, parameter :: daysToSeconds = 86400.0_prec real(kind=prec), public, parameter :: fillValue = -9999.99_prec integer, public, parameter :: fillValueInt = -99999 real(kind=prec), public, parameter :: hoursToDays = 1.0_prec/24.0_prec integer, public, parameter :: maxInverseIters = 1000 real(kind=prec), public, parameter :: minutesToHours = 1.0_prec/60.0_prec real(kind=prec), public, parameter :: monthsToYears = 1.0_prec/12.0_prec character(len=1), public, parameter :: nada = ' ' integer, public, parameter :: newtonMax = 500 real(kind=prec), public, parameter :: newtonTolerance = 10.0**(-8) real(kind=prec), public, parameter :: pi = 4.0_prec*atan(1.0_prec) integer, public, parameter :: prec = real64 integer, public, parameter :: prec = real32 real(kind=prec), public, parameter :: rk3_a (1:3) = (/0.0_prec, -5.0_prec/9.0_prec, -153.0_prec/128.0_prec/) real(kind=prec), public, parameter :: rk3_b (1:3) = (/0.0_prec, 1.0_prec/3.0_prec, 3.0_prec/4.0_prec/) real(kind=prec), public, parameter :: rk3_g (1:3) = (/1.0_prec/3.0_prec, 15.0_prec/16.0_prec, 8.0_prec/15.0_prec/) real(kind=prec), public, parameter :: secondsToMinutes = 1.0_prec/60.0_prec real(kind=prec), public, parameter :: tolerance = 10.0**(-10)","tags":"","loc":"module/self_constants.html"},{"title":"SELF_Data – SELF","text":"Uses SELF_Constants SELF_Lagrange iso_c_binding module~~self_data~~UsesGraph module~self_data SELF_Data module~self_lagrange SELF_Lagrange module~self_data->module~self_lagrange iso_c_binding iso_c_binding module~self_data->iso_c_binding module~self_constants SELF_Constants module~self_data->module~self_constants module~self_supportroutines SELF_SupportRoutines module~self_lagrange->module~self_supportroutines module~self_lagrange->iso_c_binding hipfort_check hipfort_check module~self_lagrange->hipfort_check module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort hipfort module~self_lagrange->hipfort iso_fortran_env iso_fortran_env module~self_lagrange->iso_fortran_env module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_lagrange->module~self_constants module~self_constants->iso_fortran_env module~self_supportroutines->iso_fortran_env module~self_supportroutines->module~self_constants module~self_quadrature->iso_fortran_env module~self_quadrature->module~self_constants module~self_memory->iso_c_binding module~self_memory->hipfort_check module~self_memory->hipfort module~self_memory->iso_fortran_env module~self_memory->module~self_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_data~~UsedByGraph module~self_data SELF_Data module~self_tests SELF_Tests module~self_tests->module~self_data module~self_mesh SELF_Mesh module~self_tests->module~self_mesh module~self_mappeddata SELF_MappedData module~self_tests->module~self_mappeddata module~self_mesh->module~self_data module~self_geometry SELF_Geometry module~self_geometry->module~self_data module~self_geometry->module~self_mesh module~self_mappeddata->module~self_data module~self_mappeddata->module~self_mesh module~self_mappeddata->module~self_geometry module~self_mpilayer SELF_MPILayer module~self_mpilayer->module~self_data module~self_mpilayer->module~self_mesh module~self_mpilayer->module~self_mappeddata program~self SELF program~self->module~self_tests Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables selfStrongForm selfWeakCGForm selfWeakDGForm Interfaces Determinant_Tensor2D_gpu_wrapper Determinant_Tensor3D_gpu_wrapper Derived Types Scalar1D Scalar2D Scalar3D Tensor2D Tensor3D Vector2D Vector3D Functions AbsMaxBoundary_Scalar1D AbsMaxBoundary_Scalar2D AbsMaxBoundary_Scalar3D AbsMaxBoundary_Tensor2D AbsMaxBoundary_Tensor3D AbsMaxBoundary_Vector2D AbsMaxBoundary_Vector3D AbsMaxInterior_Scalar1D AbsMaxInterior_Scalar2D AbsMaxInterior_Scalar3D AbsMaxInterior_Tensor2D AbsMaxInterior_Tensor3D AbsMaxInterior_Vector2D AbsMaxInterior_Vector3D Add_Scalar1D Add_Scalar2D Add_Scalar3D Add_Tensor2D Add_Tensor3D Add_Vector2D Add_Vector3D Subtract_Scalar1D Subtract_Scalar2D Subtract_Scalar3D Subtract_Tensor2D Subtract_Tensor3D Subtract_Vector2D Subtract_Vector3D Subroutines BoundaryInterp_Scalar1D BoundaryInterp_Scalar2D BoundaryInterp_Scalar3D BoundaryInterp_Tensor2D BoundaryInterp_Tensor3D BoundaryInterp_Vector2D BoundaryInterp_Vector3D Curl_Vector2D Curl_Vector3D Derivative_Scalar1D Determinant_Tensor2D Determinant_Tensor3D Divergence_Tensor2D Divergence_Tensor3D Divergence_Vector2D Divergence_Vector3D Equals_Scalar1D Equals_Scalar2D Equals_Scalar3D Equals_Tensor2D Equals_Tensor3D Equals_Vector2D Equals_Vector3D Free_Scalar1D Free_Scalar2D Free_Scalar3D Free_Tensor2D Free_Tensor3D Free_Vector2D Free_Vector3D Gradient_Scalar2D Gradient_Scalar3D Gradient_Vector2D Gradient_Vector3D GridInterp_Scalar1D GridInterp_Scalar2D GridInterp_Scalar3D GridInterp_Tensor2D GridInterp_Tensor3D GridInterp_Vector2D GridInterp_Vector3D Init_Scalar1D Init_Scalar2D Init_Scalar3D Init_Tensor2D Init_Tensor3D Init_Vector2D Init_Vector3D UpdateDevice_Scalar1D UpdateDevice_Scalar2D UpdateDevice_Scalar3D UpdateDevice_Tensor2D UpdateDevice_Tensor3D UpdateDevice_Vector2D UpdateDevice_Vector3D UpdateHost_Scalar1D UpdateHost_Scalar2D UpdateHost_Scalar3D UpdateHost_Tensor2D UpdateHost_Tensor3D UpdateHost_Vector2D UpdateHost_Vector3D Variables Type Visibility Attributes Name Initial integer, public, parameter :: selfStrongForm = 0 integer, public, parameter :: selfWeakCGForm = 2 integer, public, parameter :: selfWeakDGForm = 1 Interfaces interface public subroutine Determinant_Tensor2D_gpu_wrapper(tensor_dev, detTensor_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor_dev type(c_ptr) :: detTensor_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine Determinant_Tensor3D_gpu_wrapper(tensor_dev, detTensor_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor_dev type(c_ptr) :: detTensor_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl Derived Types type, public :: Scalar1D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r3), public :: boundary integer, public :: controlType type(hfReal_r3), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Scalar1D procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Scalar1D procedure, public :: AbsMaxInterior => AbsMaxInterior_Scalar1D procedure, private, PASS(SELFa) :: Add_Scalar1D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar1D generic, public :: Derivative => Derivative_Scalar1D procedure, private :: Derivative_Scalar1D procedure, private, PASS(SELFOut) :: Equals_Scalar1D procedure, public :: Free => Free_Scalar1D procedure, public :: GridInterp => GridInterp_Scalar1D procedure, public :: Init => Init_Scalar1D generic, public :: OPERATOR(+) => Add_Scalar1D generic, public :: OPERATOR(-) => Subtract_Scalar1D procedure, private, PASS(SELFa) :: Subtract_Scalar1D procedure, public :: UpdateDevice => UpdateDevice_Scalar1D procedure, public :: UpdateHost => UpdateHost_Scalar1D type, public :: Scalar2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r4), public :: boundary integer, public :: controlType type(hfReal_r4), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Scalar2D procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Scalar2D procedure, public :: AbsMaxInterior => AbsMaxInterior_Scalar2D procedure, private, PASS(SELFa) :: Add_Scalar2D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar2D procedure, private, PASS(SELFOut) :: Equals_Scalar2D procedure, public :: Free => Free_Scalar2D generic, public :: Gradient => Gradient_Scalar2D procedure, private :: Gradient_Scalar2D procedure, public :: GridInterp => GridInterp_Scalar2D procedure, public :: Init => Init_Scalar2D generic, public :: OPERATOR(+) => Add_Scalar2D generic, public :: OPERATOR(-) => Subtract_Scalar2D procedure, private, PASS(SELFa) :: Subtract_Scalar2D procedure, public :: UpdateDevice => UpdateDevice_Scalar2D procedure, public :: UpdateHost => UpdateHost_Scalar2D type, public :: Scalar3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r5), public :: boundary integer, public :: controlType type(hfReal_r5), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Scalar3D procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Scalar3D procedure, public :: AbsMaxInterior => AbsMaxInterior_Scalar3D procedure, private, PASS(SELFa) :: Add_Scalar3D procedure, public :: BoundaryInterp => BoundaryInterp_Scalar3D procedure, private, PASS(SELFOut) :: Equals_Scalar3D procedure, public :: Free => Free_Scalar3D generic, public :: Gradient => Gradient_Scalar3D procedure, private :: Gradient_Scalar3D procedure, public :: GridInterp => GridInterp_Scalar3D procedure, public :: Init => Init_Scalar3D generic, public :: OPERATOR(+) => Add_Scalar3D generic, public :: OPERATOR(-) => Subtract_Scalar3D procedure, private, PASS(SELFa) :: Subtract_Scalar3D procedure, public :: UpdateDevice => UpdateDevice_Scalar3D procedure, public :: UpdateHost => UpdateHost_Scalar3D type, public :: Tensor2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r6), public :: boundary integer, public :: controlType type(hfReal_r6), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Tensor2D procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Tensor2D procedure, public :: AbsMaxInterior => AbsMaxInterior_Tensor2D procedure, private, PASS(SELFa) :: Add_Tensor2D procedure, public :: BoundaryInterp => BoundaryInterp_Tensor2D procedure, public :: Determinant => Determinant_Tensor2D generic, public :: Divergence => Divergence_Tensor2D procedure, private :: Divergence_Tensor2D procedure, private, PASS(SELFOut) :: Equals_Tensor2D procedure, public :: Free => Free_Tensor2D procedure, public :: GridInterp => GridInterp_Tensor2D procedure, public :: Init => Init_Tensor2D generic, public :: OPERATOR(+) => Add_Tensor2D generic, public :: OPERATOR(-) => Subtract_Tensor2D procedure, private, PASS(SELFa) :: Subtract_Tensor2D procedure, public :: UpdateDevice => UpdateDevice_Tensor2D procedure, public :: UpdateHost => UpdateHost_Tensor2D type, public :: Tensor3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r7), public :: boundary integer, public :: controlType type(hfReal_r7), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Tensor3D procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Tensor3D procedure, public :: AbsMaxInterior => AbsMaxInterior_Tensor3D procedure, private, PASS(SELFa) :: Add_Tensor3D procedure, public :: BoundaryInterp => BoundaryInterp_Tensor3D procedure, public :: Determinant => Determinant_Tensor3D generic, public :: Divergence => Divergence_Tensor3D procedure, private :: Divergence_Tensor3D procedure, private, PASS(SELFOut) :: Equals_Tensor3D procedure, public :: Free => Free_Tensor3D procedure, public :: GridInterp => GridInterp_Tensor3D procedure, public :: Init => Init_Tensor3D generic, public :: OPERATOR(+) => Add_Tensor3D generic, public :: OPERATOR(-) => Subtract_Tensor3D procedure, private, PASS(SELFa) :: Subtract_Tensor3D procedure, public :: UpdateDevice => UpdateDevice_Tensor3D procedure, public :: UpdateHost => UpdateHost_Tensor3D type, public :: Vector2D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r5), public :: boundary integer, public :: controlType type(hfReal_r5), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Vector2D procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Vector2D procedure, public :: AbsMaxInterior => AbsMaxInterior_Vector2D procedure, private, PASS(SELFa) :: Add_Vector2D procedure, public :: BoundaryInterp => BoundaryInterp_Vector2D generic, public :: Curl => Curl_Vector2D procedure, private :: Curl_Vector2D generic, public :: Divergence => Divergence_Vector2D procedure, private :: Divergence_Vector2D procedure, private, PASS(SELFOut) :: Equals_Vector2D procedure, public :: Free => Free_Vector2D generic, public :: Gradient => Gradient_Vector2D procedure, private :: Gradient_Vector2D procedure, public :: GridInterp => GridInterp_Vector2D procedure, public :: Init => Init_Vector2D generic, public :: OPERATOR(+) => Add_Vector2D generic, public :: OPERATOR(-) => Subtract_Vector2D procedure, private, PASS(SELFa) :: Subtract_Vector2D procedure, public :: UpdateDevice => UpdateDevice_Vector2D procedure, public :: UpdateHost => UpdateHost_Vector2D type, public :: Vector3D Components Type Visibility Attributes Name Initial integer, public :: M integer, public :: N type(hfReal_r6), public :: boundary integer, public :: controlType type(hfReal_r6), public :: interior type(Lagrange), public :: interp integer, public :: nElem integer, public :: nVar integer, public :: targetType Type-Bound Procedures generic, public :: ASSIGNMENT(=) => Equals_Vector3D procedure, public :: AbsMaxBoundary => AbsMaxBoundary_Vector3D procedure, public :: AbsMaxInterior => AbsMaxInterior_Vector3D procedure, private, PASS(SELFa) :: Add_Vector3D procedure, public :: BoundaryInterp => BoundaryInterp_Vector3D generic, public :: Curl => Curl_Vector3D procedure, private :: Curl_Vector3D generic, public :: Divergence => Divergence_Vector3D procedure, private :: Divergence_Vector3D procedure, private, PASS(SELFOut) :: Equals_Vector3D procedure, public :: Free => Free_Vector3D generic, public :: Gradient => Gradient_Vector3D procedure, private :: Gradient_Vector3D procedure, public :: GridInterp => GridInterp_Vector3D procedure, public :: Init => Init_Vector3D generic, public :: OPERATOR(+) => Add_Vector3D generic, public :: OPERATOR(-) => Subtract_Vector3D procedure, private, PASS(SELFa) :: Subtract_Vector3D procedure, public :: UpdateDevice => UpdateDevice_Vector3D procedure, public :: UpdateHost => UpdateHost_Vector3D Functions public function AbsMaxBoundary_Scalar1D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar1D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:2) public function AbsMaxBoundary_Scalar2D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar2D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:4) public function AbsMaxBoundary_Scalar3D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar3D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar,1:6) public function AbsMaxBoundary_Tensor2D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor2D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar,1:4) public function AbsMaxBoundary_Tensor3D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor3D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar,1:6) public function AbsMaxBoundary_Vector2D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector2D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar,1:4) public function AbsMaxBoundary_Vector3D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector3D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar,1:6) public function AbsMaxInterior_Scalar1D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar1D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) public function AbsMaxInterior_Scalar2D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar2D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) public function AbsMaxInterior_Scalar3D (scalar) result(absMax) Arguments Type Intent Optional Attributes Name class( Scalar3D ) :: scalar Return Value real(kind=prec)\n  (1:scalar%nVar) public function AbsMaxInterior_Tensor2D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor2D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar) public function AbsMaxInterior_Tensor3D (tensor) result(absMax) Arguments Type Intent Optional Attributes Name class( Tensor3D ) :: tensor Return Value real(kind=prec)\n  (1:tensor%nVar) public function AbsMaxInterior_Vector2D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector2D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar) public function AbsMaxInterior_Vector3D (vector) result(absMax) Arguments Type Intent Optional Attributes Name class( Vector3D ) :: vector Return Value real(kind=prec)\n  (1:vector%nVar) public function Add_Scalar1D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) public function Add_Scalar2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) public function Add_Scalar3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) public function Add_Tensor2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) public function Add_Tensor3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) public function Add_Vector2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) public function Add_Vector3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) public function Subtract_Scalar1D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFa class( Scalar1D ), intent(in) :: SELFb Return Value type( Scalar1D ) public function Subtract_Scalar2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFa class( Scalar2D ), intent(in) :: SELFb Return Value type( Scalar2D ) public function Subtract_Scalar3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFa class( Scalar3D ), intent(in) :: SELFb Return Value type( Scalar3D ) public function Subtract_Tensor2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFa class( Tensor2D ), intent(in) :: SELFb Return Value type( Tensor2D ) public function Subtract_Tensor3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFa class( Tensor3D ), intent(in) :: SELFb Return Value type( Tensor3D ) public function Subtract_Vector2D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFa class( Vector2D ), intent(in) :: SELFb Return Value type( Vector2D ) public function Subtract_Vector3D (SELFa, SELFb) result(SELFOut) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFa class( Vector3D ), intent(in) :: SELFb Return Value type( Vector3D ) Subroutines public subroutine BoundaryInterp_Scalar1D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Scalar2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Scalar3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Tensor2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Tensor3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Vector2D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine BoundaryInterp_Vector3D (SELFStorage, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage logical, intent(in) :: gpuAccel public subroutine Curl_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Curl_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Derivative_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Determinant_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Determinant_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Divergence_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Divergence_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Divergence_Vector2D (SELFStorage, SELFOut, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Divergence_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Equals_Scalar1D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFOut type( Scalar1D ), intent(in) :: SELFin public subroutine Equals_Scalar2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFOut type( Scalar2D ), intent(in) :: SELFin public subroutine Equals_Scalar3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFOut type( Scalar3D ), intent(in) :: SELFin public subroutine Equals_Tensor2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFOut type( Tensor2D ), intent(in) :: SELFin public subroutine Equals_Tensor3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFOut type( Tensor3D ), intent(in) :: SELFin public subroutine Equals_Vector2D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFOut type( Vector2D ), intent(in) :: SELFin public subroutine Equals_Vector3D (SELFOut, SELFin) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFOut type( Vector3D ), intent(in) :: SELFin public subroutine Free_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage public subroutine Free_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage public subroutine Free_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage public subroutine Free_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage public subroutine Free_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage public subroutine Free_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage public subroutine Free_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage public subroutine Gradient_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Gradient_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Gradient_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Gradient_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Scalar1D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(in) :: SELFStorage type( Scalar1D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Scalar2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(in) :: SELFStorage type( Scalar2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Scalar3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(in) :: SELFStorage type( Scalar3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Tensor2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(in) :: SELFStorage type( Tensor2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Tensor3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(in) :: SELFStorage type( Tensor3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Vector2D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(in) :: SELFStorage type( Vector2D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine GridInterp_Vector3D (SELFStorage, SELFOut, gpuAccel) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(in) :: SELFStorage type( Vector3D ), intent(inout) :: SELFOut logical, intent(in) :: gpuAccel public subroutine Init_Scalar1D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Scalar2D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Scalar3D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Tensor2D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Tensor3D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Vector2D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine Init_Vector3D (SELFStorage, N, quadratureType, M, targetNodeType, nVar, nElem) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(out) :: SELFStorage integer, intent(in) :: N integer, intent(in) :: quadratureType integer, intent(in) :: M integer, intent(in) :: targetNodeType integer, intent(in) :: nVar integer, intent(in) :: nElem public subroutine UpdateDevice_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage public subroutine UpdateDevice_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Scalar1D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar1D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Scalar2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar2D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Scalar3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Scalar3D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Tensor2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor2D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Tensor3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Tensor3D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Vector2D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector2D ), intent(inout) :: SELFStorage public subroutine UpdateHost_Vector3D (SELFStorage) Arguments Type Intent Optional Attributes Name class( Vector3D ), intent(inout) :: SELFStorage","tags":"","loc":"module/self_data.html"},{"title":"SELF_Geometry – SELF","text":"Uses SELF_Constants SELF_Lagrange SELF_Data SELF_SupportRoutines SELF_Mesh module~~self_geometry~~UsesGraph module~self_geometry SELF_Geometry module~self_lagrange SELF_Lagrange module~self_geometry->module~self_lagrange module~self_mesh SELF_Mesh module~self_geometry->module~self_mesh module~self_supportroutines SELF_SupportRoutines module~self_geometry->module~self_supportroutines module~self_constants SELF_Constants module~self_geometry->module~self_constants module~self_data SELF_Data module~self_geometry->module~self_data module~self_lagrange->module~self_supportroutines iso_c_binding iso_c_binding module~self_lagrange->iso_c_binding hipfort_check hipfort_check module~self_lagrange->hipfort_check module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort hipfort module~self_lagrange->hipfort iso_fortran_env iso_fortran_env module~self_lagrange->iso_fortran_env module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_lagrange->module~self_constants module~self_mesh->module~self_lagrange module~self_mesh->module~self_supportroutines module~self_mesh->iso_c_binding module~self_mesh->module~self_constants module~self_mesh->module~self_data module~self_supportroutines->iso_fortran_env module~self_supportroutines->module~self_constants module~self_constants->iso_fortran_env module~self_data->module~self_lagrange module~self_data->iso_c_binding module~self_data->module~self_constants module~self_quadrature->iso_fortran_env module~self_quadrature->module~self_constants module~self_memory->iso_c_binding module~self_memory->hipfort_check module~self_memory->hipfort module~self_memory->iso_fortran_env module~self_memory->module~self_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_geometry~~UsedByGraph module~self_geometry SELF_Geometry module~self_mappeddata SELF_MappedData module~self_mappeddata->module~self_geometry module~self_tests SELF_Tests module~self_tests->module~self_mappeddata module~self_mpilayer SELF_MPILayer module~self_mpilayer->module~self_mappeddata program~self SELF program~self->module~self_tests Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper CalculateContravariantBasis_SEMHex_gpu_wrapper CalculateContravariantBasis_SEMQuad_gpu_wrapper Derived Types Geometry1D SEMHex SEMQuad Subroutines CalculateContravariantBasis_SEMHex CalculateContravariantBasis_SEMQuad CalculateMetricTerms_Geometry1D CalculateMetricTerms_SEMHex CalculateMetricTerms_SEMQuad Free_Geometry1D Free_SEMHex Free_SEMQuad GenerateFromMesh_Geometry1D GenerateFromMesh_SEMHex GenerateFromMesh_SEMQuad Init_Geometry1D Init_SEMHex Init_SEMQuad UpdateDevice_Geometry1D UpdateDevice_SEMHex UpdateDevice_SEMQuad UpdateHost_Geometry1D UpdateHost_SEMHex UpdateHost_SEMQuad Interfaces interface public subroutine AdjustBoundaryContravariantBasis_SEMHex_gpu_wrapper(dsdx, J, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dsdx type(c_ptr) :: J integer, VALUE :: N integer, VALUE :: nEl interface public subroutine AdjustBoundaryContravariantBasis_SEMQuad_gpu_wrapper(dsdx, J, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dsdx type(c_ptr) :: J integer, VALUE :: N integer, VALUE :: nEl interface public subroutine CalculateContravariantBasis_SEMHex_gpu_wrapper(dxds, dsdx, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dxds type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nEl interface public subroutine CalculateContravariantBasis_SEMQuad_gpu_wrapper(dxds, dsdx, N, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dxds type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nEl Derived Types type, public :: Geometry1D Components Type Visibility Attributes Name Initial integer, public :: cqType type(Scalar1D), public :: dxds integer, public :: nElem integer, public :: tqType type(Scalar1D), public :: x Type-Bound Procedures procedure, public :: CalculateMetricTerms => CalculateMetricTerms_Geometry1D procedure, public :: Free => Free_Geometry1D procedure, public :: GenerateFromMesh => GenerateFromMesh_Geometry1D procedure, public :: Init => Init_Geometry1D procedure, public :: UpdateDevice => UpdateDevice_Geometry1D procedure, public :: UpdateHost => UpdateHost_Geometry1D type, public :: SEMHex Components Type Visibility Attributes Name Initial type(Scalar3D), public :: J integer, public :: cqType type(Tensor3D), public :: dsdx type(Tensor3D), public :: dxds integer, public :: nElem integer, public :: tqType type(Vector3D), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMHex procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMHex procedure, public :: Free => Free_SEMHex procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMHex procedure, public :: Init => Init_SEMHex procedure, public :: UpdateDevice => UpdateDevice_SEMHex procedure, public :: UpdateHost => UpdateHost_SEMHex type, public :: SEMQuad Components Type Visibility Attributes Name Initial type(Scalar2D), public :: J integer, public :: cqType type(Tensor2D), public :: dsdx type(Tensor2D), public :: dxds integer, public :: nElem integer, public :: tqType type(Vector2D), public :: x Type-Bound Procedures procedure, private :: CalculateContravariantBasis => CalculateContravariantBasis_SEMQuad procedure, public :: CalculateMetricTerms => CalculateMetricTerms_SEMQuad procedure, public :: Free => Free_SEMQuad procedure, public :: GenerateFromMesh => GenerateFromMesh_SEMQuad procedure, public :: Init => Init_SEMQuad procedure, public :: UpdateDevice => UpdateDevice_SEMQuad procedure, public :: UpdateHost => UpdateHost_SEMQuad Subroutines public subroutine CalculateContravariantBasis_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine CalculateContravariantBasis_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine CalculateMetricTerms_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom public subroutine CalculateMetricTerms_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine CalculateMetricTerms_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine Free_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom public subroutine Free_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine Free_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine GenerateFromMesh_Geometry1D (myGeom, mesh, cqType, tqType, cqDegree, tqDegree) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom type(Mesh1D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree public subroutine GenerateFromMesh_SEMHex (myGeom, mesh, cqType, tqType, cqDegree, tqDegree) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom type(Mesh3D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree public subroutine GenerateFromMesh_SEMQuad (myGeom, mesh, cqType, tqType, cqDegree, tqDegree) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom type(Mesh2D), intent(in) :: mesh integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree public subroutine Init_Geometry1D (myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem public subroutine Init_SEMHex (myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem public subroutine Init_SEMQuad (myGeom, cqType, tqType, cqDegree, tqDegree, nElem) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(out) :: myGeom integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem public subroutine UpdateDevice_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom public subroutine UpdateDevice_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine UpdateDevice_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom public subroutine UpdateHost_Geometry1D (myGeom) Arguments Type Intent Optional Attributes Name class( Geometry1D ), intent(inout) :: myGeom public subroutine UpdateHost_SEMHex (myGeom) Arguments Type Intent Optional Attributes Name class( SEMHex ), intent(inout) :: myGeom public subroutine UpdateHost_SEMQuad (myGeom) Arguments Type Intent Optional Attributes Name class( SEMQuad ), intent(inout) :: myGeom","tags":"","loc":"module/self_geometry.html"},{"title":"SELF_Lagrange – SELF","text":"Uses iso_fortran_env SELF_Constants SELF_Memory SELF_SupportRoutines SELF_Quadrature hipfort hipfort_check iso_c_binding module~~self_lagrange~~UsesGraph module~self_lagrange SELF_Lagrange module~self_supportroutines SELF_SupportRoutines module~self_lagrange->module~self_supportroutines iso_c_binding iso_c_binding module~self_lagrange->iso_c_binding hipfort_check hipfort_check module~self_lagrange->hipfort_check module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort hipfort module~self_lagrange->hipfort iso_fortran_env iso_fortran_env module~self_lagrange->iso_fortran_env module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_constants SELF_Constants module~self_lagrange->module~self_constants module~self_supportroutines->iso_fortran_env module~self_supportroutines->module~self_constants module~self_quadrature->iso_fortran_env module~self_quadrature->module~self_constants module~self_memory->iso_c_binding module~self_memory->hipfort_check module~self_memory->hipfort module~self_memory->iso_fortran_env module~self_memory->module~self_constants module~self_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_lagrange~~UsedByGraph module~self_lagrange SELF_Lagrange module~self_tests SELF_Tests module~self_tests->module~self_lagrange module~self_mesh SELF_Mesh module~self_tests->module~self_mesh module~self_mappeddata SELF_MappedData module~self_tests->module~self_mappeddata module~self_data SELF_Data module~self_tests->module~self_data module~self_mesh->module~self_lagrange module~self_mesh->module~self_data module~self_geometry SELF_Geometry module~self_geometry->module~self_lagrange module~self_geometry->module~self_mesh module~self_geometry->module~self_data module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_mesh module~self_mappeddata->module~self_geometry module~self_mappeddata->module~self_data module~self_data->module~self_lagrange module~self_mpilayer SELF_MPILayer module~self_mpilayer->module~self_mesh module~self_mpilayer->module~self_mappeddata module~self_mpilayer->module~self_data program~self SELF program~self->module~self_tests Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces DGDerivative_1D_gpu_wrapper Derivative_1D_gpu_wrapper ScalarBoundaryInterp_1D_gpu_wrapper ScalarBoundaryInterp_2D_gpu_wrapper ScalarBoundaryInterp_3D_gpu_wrapper ScalarDGGradient_2D_gpu_wrapper ScalarGradient_2D_gpu_wrapper ScalarGradient_3D_gpu_wrapper ScalarGridInterp_1D_gpu_wrapper ScalarGridInterp_2D_gpu_wrapper ScalarGridInterp_3D_gpu_wrapper TensorBoundaryInterp_2D_gpu_wrapper TensorBoundaryInterp_3D_gpu_wrapper TensorDGDivergence_2D_gpu_wrapper TensorDGDivergence_3D_gpu_wrapper TensorDivergence_2D_gpu_wrapper TensorDivergence_3D_gpu_wrapper TensorGridInterp_2D_gpu_wrapper TensorGridInterp_3D_gpu_wrapper VectorBoundaryInterp_2D_gpu_wrapper VectorBoundaryInterp_3D_gpu_wrapper VectorCurl_2D_gpu_wrapper VectorCurl_3D_gpu_wrapper VectorDGDivergence_2D_gpu_wrapper VectorDGDivergence_3D_gpu_wrapper VectorDGGradient_2D_gpu_wrapper VectorDivergence_2D_gpu_wrapper VectorDivergence_3D_gpu_wrapper VectorGradient_2D_gpu_wrapper VectorGradient_3D_gpu_wrapper VectorGridInterp_2D_gpu_wrapper VectorGridInterp_3D_gpu_wrapper Derived Types Lagrange Functions CalculateLagrangePolynomials Subroutines CalculateBarycentricWeights CalculateDerivativeMatrix CalculateInterpolationMatrix DGDerivative_1D_cpu DGDerivative_1D_gpu Derivative_1D_cpu Derivative_1D_gpu Free_Lagrange Init_Lagrange ScalarBoundaryInterp_1D_cpu ScalarBoundaryInterp_1D_gpu ScalarBoundaryInterp_2D_cpu ScalarBoundaryInterp_2D_gpu ScalarBoundaryInterp_3D_cpu ScalarBoundaryInterp_3D_gpu ScalarDGGradient_2D_cpu ScalarDGGradient_2D_gpu ScalarGradient_2D_cpu ScalarGradient_2D_gpu ScalarGradient_3D_cpu ScalarGradient_3D_gpu ScalarGridInterp_1D_cpu ScalarGridInterp_1D_gpu ScalarGridInterp_2D_cpu ScalarGridInterp_2D_gpu ScalarGridInterp_3D_cpu ScalarGridInterp_3D_gpu TensorBoundaryInterp_2D_cpu TensorBoundaryInterp_2D_gpu TensorBoundaryInterp_3D_cpu TensorBoundaryInterp_3D_gpu TensorDGDivergence_2D_cpu TensorDGDivergence_2D_gpu TensorDGDivergence_3D_cpu TensorDGDivergence_3D_gpu TensorDivergence_2D_cpu TensorDivergence_2D_gpu TensorDivergence_3D_cpu TensorDivergence_3D_gpu TensorGridInterp_2D_cpu TensorGridInterp_2D_gpu TensorGridInterp_3D_cpu TensorGridInterp_3D_gpu UpdateDevice_Lagrange UpdateHost_Lagrange VectorBoundaryInterp_2D_cpu VectorBoundaryInterp_2D_gpu VectorBoundaryInterp_3D_cpu VectorBoundaryInterp_3D_gpu VectorCurl_2D_cpu VectorCurl_2D_gpu VectorCurl_3D_cpu VectorCurl_3D_gpu VectorDGDivergence_2D_cpu VectorDGDivergence_2D_gpu VectorDGDivergence_3D_cpu VectorDGDivergence_3D_gpu VectorDGGradient_2D_cpu VectorDGGradient_2D_gpu VectorDivergence_2D_cpu VectorDivergence_2D_gpu VectorDivergence_3D_cpu VectorDivergence_3D_gpu VectorGradient_2D_cpu VectorGradient_2D_gpu VectorGradient_3D_cpu VectorGradient_3D_gpu VectorGridInterp_2D_cpu VectorGridInterp_2D_gpu VectorGridInterp_3D_cpu VectorGridInterp_3D_gpu Interfaces interface public subroutine DGDerivative_1D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine Derivative_1D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ScalarBoundaryInterp_1D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ScalarBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ScalarBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ScalarDGGradient_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ScalarGradient_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ScalarGradient_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ScalarGridInterp_1D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer, VALUE :: N integer, VALUE :: M integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ScalarGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer, VALUE :: N integer, VALUE :: M integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ScalarGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer, VALUE :: N integer, VALUE :: M integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine TensorBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine TensorBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine TensorDGDivergence_2D_gpu_wrapper(dMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine TensorDGDivergence_3D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine TensorDivergence_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine TensorDivergence_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine TensorGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer, VALUE :: N integer, VALUE :: M integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine TensorGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer, VALUE :: N integer, VALUE :: M integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine VectorBoundaryInterp_2D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine VectorBoundaryInterp_3D_gpu_wrapper(bMatrix_dev, f_dev, fBound_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: bMatrix_dev type(c_ptr) :: f_dev type(c_ptr) :: fBound_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine VectorCurl_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine VectorCurl_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine VectorDGDivergence_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine VectorDGDivergence_3D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine VectorDGGradient_2D_gpu_wrapper(dgMatrixT_dev, bMatrix_dev, qWeights_dev, f_dev, bf_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dgMatrixT_dev type(c_ptr) :: bMatrix_dev type(c_ptr) :: qWeights_dev type(c_ptr) :: f_dev type(c_ptr) :: bf_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine VectorDivergence_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine VectorDivergence_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine VectorGradient_2D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine VectorGradient_3D_gpu_wrapper(dMatrixT_dev, f_dev, df_dev, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: dMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: df_dev integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine VectorGridInterp_2D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer, VALUE :: N integer, VALUE :: M integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine VectorGridInterp_3D_gpu_wrapper(iMatrixT_dev, f_dev, fInterp_dev, N, M, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: iMatrixT_dev type(c_ptr) :: f_dev type(c_ptr) :: fInterp_dev integer, VALUE :: N integer, VALUE :: M integer, VALUE :: nVar integer, VALUE :: nEl Derived Types type, public :: Lagrange A data structure for working with Lagrange Interpolating Polynomials in one, two, and three dimensions.\n The Lagrange data-structure stores the information necessary to interpolate between two\n sets of grid-points and to estimate the derivative of data at native grid points. Routines for\n multidimensional interpolation are based on the tensor product of 1-D interpolants. It is\n assumed that the polynomial degree (and the interpolation nodes) are the same in each direction.\n This assumption permits the storage of only one array of interpolation nodes and barycentric\n weights and is what allows this data structure to be flexible. Components Type Visibility Attributes Name Initial integer, public :: M The number of target points. integer, public :: N The number of control points. type(hfReal_r2), public :: bMatrix The boundary interpolation matrix that is used to map a grid of nodal values at the control points to the element boundaries. type(hfReal_r1), public :: bWeights The barycentric weights that are calculated from the controlPoints and used for interpolation. type(hfReal_r1), public :: controlPoints The set of nodes in one dimension where data is known. \n To create higher dimension interpolation and differentiation operators, structured grids in two and three\n dimensions are created by tensor products of the controlPoints. This design decision implies that all \n spectral element methods supported by the Lagrange class have the same polynomial degree in each \n computational/spatial dimension. In practice, the controlPoints are the Legendre-Gauss, Legendre-Gauss-Lobatto,\n Legendre-Gauss-Radau, Chebyshev-Gauss, Chebyshev-Gauss-Lobatto, or Chebyshev-Gauss-Radau quadrature points over \n the domain [-1,1] (computational space). The Init routine for this class restricts controlPoints to one of \n these quadrature types or uniform points on [-1,1]. type(hfReal_r2), public :: dMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The \n dMatrix is based on a strong form of the derivative. type(hfReal_r2), public :: dgMatrix The derivative matrix for mapping function nodal values to a nodal values of the derivative estimate. The dgMatrix is based\n on a weak form of the derivative. It must be used with bMatrix to account for boundary contributions in the weak form. type(hfReal_r2), public :: iMatrix The interpolation matrix (transpose) for mapping data from the control grid to the target grid. type(hfReal_r1), public :: qWeights The quadrature weights for discrete integration. The quadradture weights depend on the type of controlPoints \n provided; one of Legendre-Gauss, Legendre-Gauss-Lobatto, Legendre-Gauss-Radau, Chebyshev-Gauss, \n Chebyshev-Gauss-Lobatto, Chebyshev-Gauss Radau, or Uniform. If Uniform, the quadrature weights are constant . type(hfReal_r1), public :: targetPoints The set of nodes in one dimension where data is to be interpolated to. To create higher dimension interpolation \n and differentiation operators, structured grids in two and three dimensions are created by tensor products of \n the targetPoints. In practice, the targetPoints are set to a uniformly distributed set of points between [-1,1]\n (computational space) to allow for interpolation from unevenly spaced quadrature points to a plotting grid. Type-Bound Procedures procedure, private :: CalculateBarycentricWeights procedure, private :: CalculateDerivativeMatrix procedure, private :: CalculateInterpolationMatrix procedure, private :: CalculateLagrangePolynomials generic, public :: DGDerivative_1D => DGDerivative_1D_cpu, DGDerivative_1D_gpu procedure, private :: DGDerivative_1D_cpu procedure, private :: DGDerivative_1D_gpu generic, public :: Derivative_1D => Derivative_1D_cpu, Derivative_1D_gpu procedure, private :: Derivative_1D_cpu procedure, private :: Derivative_1D_gpu procedure, public :: Free => Free_Lagrange procedure, public :: Init => Init_Lagrange generic, public :: ScalarBoundaryInterp_1D => ScalarBoundaryInterp_1D_cpu, ScalarBoundaryInterp_1D_gpu procedure, private :: ScalarBoundaryInterp_1D_cpu procedure, private :: ScalarBoundaryInterp_1D_gpu generic, public :: ScalarBoundaryInterp_2D => ScalarBoundaryInterp_2D_cpu, ScalarBoundaryInterp_2D_gpu procedure, private :: ScalarBoundaryInterp_2D_cpu procedure, private :: ScalarBoundaryInterp_2D_gpu generic, public :: ScalarBoundaryInterp_3D => ScalarBoundaryInterp_3D_cpu, ScalarBoundaryInterp_3D_gpu procedure, private :: ScalarBoundaryInterp_3D_cpu procedure, private :: ScalarBoundaryInterp_3D_gpu generic, public :: ScalarDGGradient_2D => ScalarDGGradient_2D_cpu, ScalarDGGradient_2D_gpu procedure, private :: ScalarDGGradient_2D_cpu procedure, private :: ScalarDGGradient_2D_gpu generic, public :: ScalarGradient_2D => ScalarGradient_2D_cpu, ScalarGradient_2D_gpu procedure, private :: ScalarGradient_2D_cpu procedure, private :: ScalarGradient_2D_gpu generic, public :: ScalarGradient_3D => ScalarGradient_3D_cpu, ScalarGradient_3D_gpu procedure, private :: ScalarGradient_3D_cpu procedure, private :: ScalarGradient_3D_gpu generic, public :: ScalarGridInterp_1D => ScalarGridInterp_1D_cpu, ScalarGridInterp_1D_gpu procedure, private :: ScalarGridInterp_1D_cpu procedure, private :: ScalarGridInterp_1D_gpu generic, public :: ScalarGridInterp_2D => ScalarGridInterp_2D_cpu, ScalarGridInterp_2D_gpu procedure, private :: ScalarGridInterp_2D_cpu procedure, private :: ScalarGridInterp_2D_gpu generic, public :: ScalarGridInterp_3D => ScalarGridInterp_3D_cpu, ScalarGridInterp_3D_gpu procedure, private :: ScalarGridInterp_3D_cpu procedure, private :: ScalarGridInterp_3D_gpu generic, public :: TensorBoundaryInterp_2D => TensorBoundaryInterp_2D_cpu, TensorBoundaryInterp_2D_gpu procedure, private :: TensorBoundaryInterp_2D_cpu procedure, private :: TensorBoundaryInterp_2D_gpu generic, public :: TensorBoundaryInterp_3D => TensorBoundaryInterp_3D_cpu, TensorBoundaryInterp_3D_gpu procedure, private :: TensorBoundaryInterp_3D_cpu procedure, private :: TensorBoundaryInterp_3D_gpu generic, public :: TensorDGDivergence_2D => TensorDGDivergence_2D_cpu, TensorDGDivergence_2D_gpu procedure, private :: TensorDGDivergence_2D_cpu procedure, private :: TensorDGDivergence_2D_gpu generic, public :: TensorDGDivergence_3D => TensorDGDivergence_3D_cpu, TensorDGDivergence_3D_gpu procedure, private :: TensorDGDivergence_3D_cpu procedure, private :: TensorDGDivergence_3D_gpu generic, public :: TensorDivergence_2D => TensorDivergence_2D_cpu, TensorDivergence_2D_gpu procedure, private :: TensorDivergence_2D_cpu procedure, private :: TensorDivergence_2D_gpu generic, public :: TensorDivergence_3D => TensorDivergence_3D_cpu, TensorDivergence_3D_gpu procedure, private :: TensorDivergence_3D_cpu procedure, private :: TensorDivergence_3D_gpu generic, public :: TensorGridInterp_2D => TensorGridInterp_2D_cpu, TensorGridInterp_2D_gpu procedure, private :: TensorGridInterp_2D_cpu procedure, private :: TensorGridInterp_2D_gpu generic, public :: TensorGridInterp_3D => TensorGridInterp_3D_cpu, TensorGridInterp_3D_gpu procedure, private :: TensorGridInterp_3D_cpu procedure, private :: TensorGridInterp_3D_gpu procedure, public :: UpdateDevice => UpdateDevice_Lagrange procedure, public :: UpdateHost => UpdateHost_Lagrange generic, public :: VectorBoundaryInterp_2D => VectorBoundaryInterp_2D_cpu, VectorBoundaryInterp_2D_gpu procedure, private :: VectorBoundaryInterp_2D_cpu procedure, private :: VectorBoundaryInterp_2D_gpu generic, public :: VectorBoundaryInterp_3D => VectorBoundaryInterp_3D_cpu, VectorBoundaryInterp_3D_gpu procedure, private :: VectorBoundaryInterp_3D_cpu procedure, private :: VectorBoundaryInterp_3D_gpu generic, public :: VectorCurl_2D => VectorCurl_2D_cpu, VectorCurl_2D_gpu procedure, private :: VectorCurl_2D_cpu procedure, private :: VectorCurl_2D_gpu generic, public :: VectorCurl_3D => VectorCurl_3D_cpu, VectorCurl_3D_gpu procedure, private :: VectorCurl_3D_cpu procedure, private :: VectorCurl_3D_gpu generic, public :: VectorDGDivergence_2D => VectorDGDivergence_2D_cpu, VectorDGDivergence_2D_gpu procedure, private :: VectorDGDivergence_2D_cpu procedure, private :: VectorDGDivergence_2D_gpu generic, public :: VectorDGDivergence_3D => VectorDGDivergence_3D_cpu, VectorDGDivergence_3D_gpu procedure, private :: VectorDGDivergence_3D_cpu procedure, private :: VectorDGDivergence_3D_gpu generic, public :: VectorDGGradient_2D => VectorDGGradient_2D_cpu, VectorDGGradient_2D_gpu procedure, private :: VectorDGGradient_2D_cpu procedure, private :: VectorDGGradient_2D_gpu generic, public :: VectorDivergence_2D => VectorDivergence_2D_cpu, VectorDivergence_2D_gpu procedure, private :: VectorDivergence_2D_cpu procedure, private :: VectorDivergence_2D_gpu generic, public :: VectorDivergence_3D => VectorDivergence_3D_cpu, VectorDivergence_3D_gpu procedure, private :: VectorDivergence_3D_cpu procedure, private :: VectorDivergence_3D_gpu generic, public :: VectorGradient_2D => VectorGradient_2D_cpu, VectorGradient_2D_gpu procedure, private :: VectorGradient_2D_cpu procedure, private :: VectorGradient_2D_gpu generic, public :: VectorGradient_3D => VectorGradient_3D_cpu, VectorGradient_3D_gpu procedure, private :: VectorGradient_3D_cpu procedure, private :: VectorGradient_3D_gpu generic, public :: VectorGridInterp_2D => VectorGridInterp_2D_cpu, VectorGridInterp_2D_gpu procedure, private :: VectorGridInterp_2D_cpu procedure, private :: VectorGridInterp_2D_gpu generic, public :: VectorGridInterp_3D => VectorGridInterp_3D_cpu, VectorGridInterp_3D_gpu procedure, private :: VectorGridInterp_3D_cpu procedure, private :: VectorGridInterp_3D_gpu Functions public function CalculateLagrangePolynomials (myPoly, sE) result(lAtS) Arguments Type Intent Optional Attributes Name class( Lagrange ) :: myPoly real(kind=prec) :: sE Return Value real(kind=prec)\n  (0:myPoly%N) Subroutines public subroutine CalculateBarycentricWeights (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly public subroutine CalculateDerivativeMatrix (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly public subroutine CalculateInterpolationMatrix (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly public subroutine DGDerivative_1D_cpu (myPoly, f, bf, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:nVariables,1:2,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine DGDerivative_1D_gpu (myPoly, f_dev, bf_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine Derivative_1D_cpu (myPoly, f, df, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: df (0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine Derivative_1D_gpu (myPoly, f_dev, df_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: df_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine Free_Lagrange (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly public subroutine Init_Lagrange (myPoly, N, controlNodeType, M, targetNodeType) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(out) :: myPoly integer, intent(in) :: N integer, intent(in) :: controlNodeType integer, intent(in) :: M integer, intent(in) :: targetNodeType public subroutine ScalarBoundaryInterp_1D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:nVariables,1:2,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_1D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarDGGradient_2D_cpu (myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarDGGradient_2D_gpu (myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGridInterp_1D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGridInterp_1D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fNew (0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine ScalarGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDGDivergence_2D_cpu (myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDGDivergence_2D_gpu (myPoly, f_dev, bf_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDGDivergence_3D_cpu (myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (1:3,1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDGDivergence_3D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDivergence_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDivergence_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDivergence_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorDivergence_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fNew (1:2,1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine TensorGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine UpdateDevice_Lagrange (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly public subroutine UpdateHost_Lagrange (myPoly) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(inout) :: myPoly public subroutine VectorBoundaryInterp_2D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorBoundaryInterp_2D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorBoundaryInterp_3D_cpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fBound (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorBoundaryInterp_3D_gpu (myPoly, f, fBound, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f type(c_ptr), intent(out) :: fBound integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorCurl_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorCurl_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorCurl_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorCurl_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_2D_cpu (myPoly, f, bF, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bF (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_2D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_3D_cpu (myPoly, f, bf, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:3,0:myPoly%N,0:myPoly%N,1:nVariables,1:6,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGDivergence_3D_gpu (myPoly, f_dev, bF_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bF_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGGradient_2D_cpu (myPoly, f, bf, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(in) :: bf (1:2,0:myPoly%N,1:nVariables,1:4,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDGGradient_2D_gpu (myPoly, f_dev, bf_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(in) :: bf_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_2D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_2D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_3D_cpu (myPoly, f, dF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: dF (0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorDivergence_3D_gpu (myPoly, f_dev, dF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: dF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_2D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:2,1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_2D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_3D_cpu (myPoly, f, gradF, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: gradF (1:3,1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGradient_3D_gpu (myPoly, f_dev, gradF_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: gradF_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGridInterp_2D_cpu (myPoly, f, fNew, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:2,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fNew (1:2,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGridInterp_2D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGridInterp_3D_cpu (myPoly, f, fInterp, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly real(kind=prec), intent(in) :: f (1:3,0:myPoly%N,0:myPoly%N,0:myPoly%N,1:nVariables,1:nElements) real(kind=prec), intent(out) :: fInterp (1:3,0:myPoly%M,0:myPoly%M,0:myPoly%M,1:nVariables,1:nElements) integer, intent(in) :: nVariables integer, intent(in) :: nElements public subroutine VectorGridInterp_3D_gpu (myPoly, f_dev, fInterp_dev, nVariables, nElements) Arguments Type Intent Optional Attributes Name class( Lagrange ), intent(in) :: myPoly type(c_ptr), intent(in) :: f_dev type(c_ptr), intent(out) :: fInterp_dev integer, intent(in) :: nVariables integer, intent(in) :: nElements","tags":"","loc":"module/self_lagrange.html"},{"title":"SELF_MPILayer – SELF","text":"Uses SELF_Data SELF_MappedData SELF_Mesh module~~self_mpilayer~~UsesGraph module~self_mpilayer SELF_MPILayer module~self_mappeddata SELF_MappedData module~self_mpilayer->module~self_mappeddata module~self_mesh SELF_Mesh module~self_mpilayer->module~self_mesh module~self_data SELF_Data module~self_mpilayer->module~self_data module~self_lagrange SELF_Lagrange module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_mesh module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry iso_c_binding iso_c_binding module~self_mappeddata->iso_c_binding module~self_constants SELF_Constants module~self_mappeddata->module~self_constants module~self_mappeddata->module~self_data module~self_mesh->module~self_lagrange module~self_supportroutines SELF_SupportRoutines module~self_mesh->module~self_supportroutines module~self_mesh->iso_c_binding module~self_mesh->module~self_constants module~self_mesh->module~self_data module~self_data->module~self_lagrange module~self_data->iso_c_binding module~self_data->module~self_constants module~self_lagrange->module~self_supportroutines module~self_lagrange->iso_c_binding hipfort_check hipfort_check module~self_lagrange->hipfort_check module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort hipfort module~self_lagrange->hipfort iso_fortran_env iso_fortran_env module~self_lagrange->iso_fortran_env module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_lagrange->module~self_constants module~self_supportroutines->iso_fortran_env module~self_supportroutines->module~self_constants module~self_geometry->module~self_lagrange module~self_geometry->module~self_mesh module~self_geometry->module~self_supportroutines module~self_geometry->module~self_constants module~self_geometry->module~self_data module~self_constants->iso_fortran_env module~self_quadrature->iso_fortran_env module~self_quadrature->module~self_constants module~self_memory->iso_c_binding module~self_memory->hipfort_check module~self_memory->hipfort module~self_memory->iso_fortran_env module~self_memory->module~self_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines SELF_CalculateRankDistributions Subroutines public subroutine SELF_CalculateRankDistributions (nObj, nRanks, objBounds) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nObj integer, intent(in) :: nRanks integer, intent(out) :: objBounds (1:2,0:nRanks-1)","tags":"","loc":"module/self_mpilayer.html"},{"title":"SELF_MappedData – SELF","text":"Uses SELF_Constants SELF_Lagrange SELF_Data SELF_Mesh SELF_Geometry iso_c_binding module~~self_mappeddata~~UsesGraph module~self_mappeddata SELF_MappedData module~self_lagrange SELF_Lagrange module~self_mappeddata->module~self_lagrange module~self_mesh SELF_Mesh module~self_mappeddata->module~self_mesh module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry iso_c_binding iso_c_binding module~self_mappeddata->iso_c_binding module~self_constants SELF_Constants module~self_mappeddata->module~self_constants module~self_data SELF_Data module~self_mappeddata->module~self_data module~self_supportroutines SELF_SupportRoutines module~self_lagrange->module~self_supportroutines module~self_lagrange->iso_c_binding hipfort_check hipfort_check module~self_lagrange->hipfort_check module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort hipfort module~self_lagrange->hipfort iso_fortran_env iso_fortran_env module~self_lagrange->iso_fortran_env module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_lagrange->module~self_constants module~self_mesh->module~self_lagrange module~self_mesh->module~self_supportroutines module~self_mesh->iso_c_binding module~self_mesh->module~self_constants module~self_mesh->module~self_data module~self_geometry->module~self_lagrange module~self_geometry->module~self_mesh module~self_geometry->module~self_supportroutines module~self_geometry->module~self_constants module~self_geometry->module~self_data module~self_constants->iso_fortran_env module~self_data->module~self_lagrange module~self_data->iso_c_binding module~self_data->module~self_constants module~self_supportroutines->iso_fortran_env module~self_supportroutines->module~self_constants module~self_quadrature->iso_fortran_env module~self_quadrature->module~self_constants module~self_memory->iso_c_binding module~self_memory->hipfort_check module~self_memory->hipfort module~self_memory->iso_fortran_env module~self_memory->module~self_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_mappeddata~~UsedByGraph module~self_mappeddata SELF_MappedData module~self_tests SELF_Tests module~self_tests->module~self_mappeddata module~self_mpilayer SELF_MPILayer module~self_mpilayer->module~self_mappeddata program~self SELF program~self->module~self_tests Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper ContravariantProjection_MappedVector2D_gpu_wrapper ContravariantProjection_MappedVector3D_gpu_wrapper ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper ContravariantWeight_MappedScalar2D_gpu_wrapper ContravariantWeight_MappedScalar3D_gpu_wrapper JacobianWeight_MappedScalar1D_gpu_wrapper JacobianWeight_MappedScalar2D_gpu_wrapper JacobianWeight_MappedScalar3D_gpu_wrapper JacobianWeight_MappedTensor2D_gpu_wrapper JacobianWeight_MappedTensor3D_gpu_wrapper JacobianWeight_MappedVector2D_gpu_wrapper JacobianWeight_MappedVector3D_gpu_wrapper MapToScalarBoundary_MappedVector2D_gpu_wrapper MapToScalarBoundary_MappedVector3D_gpu_wrapper MapToScalar_MappedVector2D_gpu_wrapper MapToScalar_MappedVector3D_gpu_wrapper MapToTensorBoundary_MappedVector2D_gpu_wrapper MapToTensorBoundary_MappedVector3D_gpu_wrapper MapToTensor_MappedVector2D_gpu_wrapper MapToTensor_MappedVector3D_gpu_wrapper Derived Types MappedScalar1D MappedScalar2D MappedScalar3D MappedTensor2D MappedTensor3D MappedVector2D MappedVector3D Subroutines ContravariantProjection_MappedVector2D ContravariantProjection_MappedVector3D ContravariantWeight_MappedScalar2D ContravariantWeight_MappedScalar3D Derivative_MappedScalar1D Divergence_MappedVector2D Divergence_MappedVector3D Gradient_MappedScalar2D Gradient_MappedScalar3D Gradient_MappedVector2D Gradient_MappedVector3D JacobianWeight_MappedScalar1D JacobianWeight_MappedScalar2D JacobianWeight_MappedScalar3D JacobianWeight_MappedTensor2D JacobianWeight_MappedTensor3D JacobianWeight_MappedVector2D JacobianWeight_MappedVector3D MapToScalar_MappedVector2D MapToScalar_MappedVector3D MapToTensor_MappedVector2D MapToTensor_MappedVector3D Interfaces interface public subroutine ContravariantProjectionBoundary_MappedVector2D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ContravariantProjectionBoundary_MappedVector3D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ContravariantProjection_MappedVector2D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ContravariantProjection_MappedVector3D_gpu_wrapper(physVector, compVector, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: physVector type(c_ptr) :: compVector type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ContravariantWeightBoundary_MappedScalar2D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ContravariantWeightBoundary_MappedScalar3D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ContravariantWeight_MappedScalar2D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine ContravariantWeight_MappedScalar3D_gpu_wrapper(scalar, workTensor, dsdx, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: workTensor type(c_ptr) :: dsdx integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine JacobianWeight_MappedScalar1D_gpu_wrapper(scalar, dxds, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: dxds integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine JacobianWeight_MappedScalar2D_gpu_wrapper(scalar, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: jacobian integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine JacobianWeight_MappedScalar3D_gpu_wrapper(scalar, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: jacobian integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine JacobianWeight_MappedTensor2D_gpu_wrapper(tensor, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: jacobian integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine JacobianWeight_MappedTensor3D_gpu_wrapper(tensor, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: jacobian integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine JacobianWeight_MappedVector2D_gpu_wrapper(vector, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: jacobian integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine JacobianWeight_MappedVector3D_gpu_wrapper(vector, jacobian, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: vector type(c_ptr) :: jacobian integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine MapToScalarBoundary_MappedVector2D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine MapToScalarBoundary_MappedVector3D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine MapToScalar_MappedVector2D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine MapToScalar_MappedVector3D_gpu_wrapper(scalar, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: scalar type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine MapToTensorBoundary_MappedVector2D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine MapToTensorBoundary_MappedVector3D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine MapToTensor_MappedVector2D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl interface public subroutine MapToTensor_MappedVector3D_gpu_wrapper(tensor, vector, N, nVar, nEl) bind(c,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr) :: tensor type(c_ptr) :: vector integer, VALUE :: N integer, VALUE :: nVar integer, VALUE :: nEl Derived Types type, public, EXTENDS(Scalar1D) :: MappedScalar1D Type-Bound Procedures generic, public :: Derivative => Derivative_MappedScalar1D procedure, private :: Derivative_MappedScalar1D procedure, private :: JacobianWeight => JacobianWeight_MappedScalar1D type, public, EXTENDS(Scalar2D) :: MappedScalar2D Type-Bound Procedures procedure, private :: ContravariantWeight => ContravariantWeight_MappedScalar2D generic, public :: Gradient => Gradient_MappedScalar2D procedure, private :: Gradient_MappedScalar2D procedure, private :: JacobianWeight => JacobianWeight_MappedScalar2D type, public, EXTENDS(Scalar3D) :: MappedScalar3D Type-Bound Procedures procedure, private :: ContravariantWeight => ContravariantWeight_MappedScalar3D generic, public :: Gradient => Gradient_MappedScalar3D procedure, private :: Gradient_MappedScalar3D procedure, private :: JacobianWeight => JacobianWeight_MappedScalar3D type, public, EXTENDS(Tensor2D) :: MappedTensor2D Type-Bound Procedures procedure, private :: JacobianWeight => JacobianWeight_MappedTensor2D type, public, EXTENDS(Tensor3D) :: MappedTensor3D Type-Bound Procedures procedure, private :: JacobianWeight => JacobianWeight_MappedTensor3D type, public, EXTENDS(Vector2D) :: MappedVector2D Type-Bound Procedures procedure, private :: ContravariantProjection => ContravariantProjection_MappedVector2D generic, public :: Divergence => Divergence_MappedVector2D procedure, private :: Divergence_MappedVector2D generic, public :: Gradient => Gradient_MappedVector2D procedure, private :: Gradient_MappedVector2D procedure, private :: JacobianWeight => JacobianWeight_MappedVector2D procedure, private :: MapToScalar => MapToScalar_MappedVector2D procedure, private :: MapToTensor => MapToTensor_MappedVector2D type, public, EXTENDS(Vector3D) :: MappedVector3D Type-Bound Procedures procedure, private :: ContravariantProjection => ContravariantProjection_MappedVector3D generic, public :: Divergence => Divergence_MappedVector3D procedure, private :: Divergence_MappedVector3D generic, public :: Gradient => Gradient_MappedVector3D procedure, private :: Gradient_MappedVector3D procedure, private :: JacobianWeight => JacobianWeight_MappedVector3D procedure, private :: MapToScalar => MapToScalar_MappedVector3D procedure, private :: MapToTensor => MapToTensor_MappedVector3D Subroutines public subroutine ContravariantProjection_MappedVector2D (physVector, geometry, compVector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: physVector type(SEMQuad), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: compVector logical, intent(in) :: gpuAccel public subroutine ContravariantProjection_MappedVector3D (physVector, geometry, compVector, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: physVector type(SEMHex), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: compVector logical, intent(in) :: gpuAccel public subroutine ContravariantWeight_MappedScalar2D (scalar, geometry, workTensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type(SEMQuad), intent(in) :: geometry type( MappedTensor2D ), intent(inout) :: workTensor logical, intent(in) :: gpuAccel public subroutine ContravariantWeight_MappedScalar3D (scalar, geometry, workTensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type(SEMHex), intent(in) :: geometry type( MappedTensor3D ), intent(inout) :: workTensor logical, intent(in) :: gpuAccel public subroutine Derivative_MappedScalar1D (scalar, geometry, dF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(in) :: scalar type(Geometry1D), intent(in) :: geometry type( MappedScalar1D ), intent(inout) :: dF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Divergence_MappedVector2D (physVector, compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: physVector type( MappedVector2D ), intent(inout) :: compVector type(SEMQuad), intent(in) :: geometry type( MappedScalar2D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Divergence_MappedVector3D (physVector, compVector, geometry, divVector, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: physVector type( MappedVector3D ), intent(inout) :: compVector type(SEMHex), intent(in) :: geometry type( MappedScalar3D ), intent(inout) :: divVector integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Gradient_MappedScalar2D (scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(in) :: scalar type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedVector2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Gradient_MappedScalar3D (scalar, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(in) :: scalar type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedVector3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Gradient_MappedVector2D (vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedScalar2D ), intent(inout) :: workScalar type( MappedVector2D ), intent(inout) :: workVector type( MappedTensor2D ), intent(inout) :: workTensor type(SEMQuad), intent(in) :: geometry type( MappedTensor2D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine Gradient_MappedVector3D (vector, workScalar, workVector, workTensor, geometry, gradF, dForm, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedScalar3D ), intent(inout) :: workScalar type( MappedVector3D ), intent(inout) :: workVector type( MappedTensor3D ), intent(inout) :: workTensor type(SEMHex), intent(in) :: geometry type( MappedTensor3D ), intent(inout) :: gradF integer, intent(in) :: dForm logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedScalar1D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar1D ), intent(inout) :: scalar type(Geometry1D), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedScalar2D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar2D ), intent(inout) :: scalar type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedScalar3D (scalar, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedScalar3D ), intent(inout) :: scalar type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedTensor2D (tensor, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor2D ), intent(inout) :: tensor type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedTensor3D (tensor, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedTensor3D ), intent(inout) :: tensor type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedVector2D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(inout) :: vector type(SEMQuad), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine JacobianWeight_MappedVector3D (vector, geometry, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(inout) :: vector type(SEMHex), intent(in) :: geometry logical, intent(in) :: gpuAccel public subroutine MapToScalar_MappedVector2D (vector, scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedScalar2D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel public subroutine MapToScalar_MappedVector3D (vector, scalar, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedScalar3D ), intent(inout) :: scalar logical, intent(in) :: gpuAccel public subroutine MapToTensor_MappedVector2D (vector, tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector2D ), intent(in) :: vector type( MappedTensor2D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel public subroutine MapToTensor_MappedVector3D (vector, tensor, gpuAccel) Arguments Type Intent Optional Attributes Name class( MappedVector3D ), intent(in) :: vector type( MappedTensor3D ), intent(inout) :: tensor logical, intent(in) :: gpuAccel","tags":"","loc":"module/self_mappeddata.html"},{"title":"SELF_Mesh – SELF","text":"Uses SELF_Constants SELF_Lagrange SELF_Data SELF_SupportRoutines iso_c_binding module~~self_mesh~~UsesGraph module~self_mesh SELF_Mesh module~self_lagrange SELF_Lagrange module~self_mesh->module~self_lagrange module~self_supportroutines SELF_SupportRoutines module~self_mesh->module~self_supportroutines iso_c_binding iso_c_binding module~self_mesh->iso_c_binding module~self_constants SELF_Constants module~self_mesh->module~self_constants module~self_data SELF_Data module~self_mesh->module~self_data module~self_lagrange->module~self_supportroutines module~self_lagrange->iso_c_binding hipfort_check hipfort_check module~self_lagrange->hipfort_check module~self_quadrature SELF_Quadrature module~self_lagrange->module~self_quadrature hipfort hipfort module~self_lagrange->hipfort iso_fortran_env iso_fortran_env module~self_lagrange->iso_fortran_env module~self_memory SELF_Memory module~self_lagrange->module~self_memory module~self_lagrange->module~self_constants module~self_supportroutines->iso_fortran_env module~self_supportroutines->module~self_constants module~self_constants->iso_fortran_env module~self_data->module~self_lagrange module~self_data->iso_c_binding module~self_data->module~self_constants module~self_quadrature->iso_fortran_env module~self_quadrature->module~self_constants module~self_memory->iso_c_binding module~self_memory->hipfort_check module~self_memory->hipfort module~self_memory->iso_fortran_env module~self_memory->module~self_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_mesh~~UsedByGraph module~self_mesh SELF_Mesh module~self_geometry SELF_Geometry module~self_geometry->module~self_mesh module~self_mappeddata SELF_MappedData module~self_mappeddata->module~self_mesh module~self_mappeddata->module~self_geometry module~self_mpilayer SELF_MPILayer module~self_mpilayer->module~self_mesh module~self_mpilayer->module~self_mappeddata module~self_tests SELF_Tests module~self_tests->module~self_mesh module~self_tests->module~self_mappeddata program~self SELF program~self->module~self_tests Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables selfHexahedronBilinear selfHexahedronLinear selfHexahedronNonlinear selfLineLinear selfLineNonlinear selfMaxNodalValence2D selfMaxNodalValence3D selfMinNodalValence2D selfMinNodalValence3D selfPrismBilinear selfPrismLinear selfPrismNonlinear selfPyramidBilinear selfPyramidLinear selfPyramidNonlinear selfQuadBilinear selfQuadLinear selfQuadNonlinear selfSide2D_East selfSide2D_North selfSide2D_South selfSide2D_West selfSide3D_Bottom selfSide3D_East selfSide3D_North selfSide3D_South selfSide3D_Top selfSide3D_West selfTetrahedronLinear selfTetrahedronNonlinear selfTriangleLinear selfTriangleNonlinear Derived Types Mesh1D Mesh2D Mesh3D Subroutines Free_Mesh1D Free_Mesh2D Free_Mesh3D Init_Mesh1D Init_Mesh2D Init_Mesh3D UniformBlockMesh_Mesh1D UniformBlockMesh_Mesh2D UniformBlockMesh_Mesh3D UpdateDevice_Mesh1D UpdateDevice_Mesh2D UpdateDevice_Mesh3D UpdateHost_Mesh1D UpdateHost_Mesh2D UpdateHost_Mesh3D Variables Type Visibility Attributes Name Initial integer, public, parameter :: selfHexahedronBilinear = 118 integer, public, parameter :: selfHexahedronLinear = 108 integer, public, parameter :: selfHexahedronNonlinear = 208 integer, public, parameter :: selfLineLinear = 1 integer, public, parameter :: selfLineNonlinear = 2 integer, public, parameter :: selfMaxNodalValence2D = 6 integer, public, parameter :: selfMaxNodalValence3D = 10 integer, public, parameter :: selfMinNodalValence2D = 4 integer, public, parameter :: selfMinNodalValence3D = 8 integer, public, parameter :: selfPrismBilinear = 116 integer, public, parameter :: selfPrismLinear = 106 integer, public, parameter :: selfPrismNonlinear = 206 integer, public, parameter :: selfPyramidBilinear = 115 integer, public, parameter :: selfPyramidLinear = 105 integer, public, parameter :: selfPyramidNonlinear = 205 integer, public, parameter :: selfQuadBilinear = 14 integer, public, parameter :: selfQuadLinear = 4 integer, public, parameter :: selfQuadNonlinear = 24 integer, public, parameter :: selfSide2D_East = 2 integer, public, parameter :: selfSide2D_North = 3 integer, public, parameter :: selfSide2D_South = 1 integer, public, parameter :: selfSide2D_West = 4 integer, public, parameter :: selfSide3D_Bottom = 1 integer, public, parameter :: selfSide3D_East = 3 integer, public, parameter :: selfSide3D_North = 4 integer, public, parameter :: selfSide3D_South = 2 integer, public, parameter :: selfSide3D_Top = 6 integer, public, parameter :: selfSide3D_West = 5 integer, public, parameter :: selfTetrahedronLinear = 104 integer, public, parameter :: selfTetrahedronNonlinear = 204 integer, public, parameter :: selfTriangleLinear = 3 integer, public, parameter :: selfTriangleNonlinear = 23 Derived Types type, public :: Mesh1D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type(hfInt32_r2), public :: BCType type(hfInt32_r2), public :: elemInfo type(hfReal_r1), public :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nNodes integer, public :: nUniqueNodes type(hfReal_r1), public :: nodeCoords Type-Bound Procedures procedure, public :: Free => Free_Mesh1D procedure, public :: Init => Init_Mesh1D procedure, public :: UniformBlockMesh => UniformBlockMesh_Mesh1D procedure, public :: UpdateDevice => UpdateDevice_Mesh1D procedure, public :: UpdateHost => UpdateHost_Mesh1D type, public :: Mesh2D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type(hfInt32_r2), public :: BCType type(hfInt32_r1), public :: CGNSCornerMap type(hfInt32_r2), public :: CGNSSideMap type(hfInt32_r2), public :: curveNodeMap type(hfInt32_r2), public :: curveNodeMapInv type(hfInt32_r2), public :: elemInfo type(hfReal_r1), public :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides type(hfReal_r2), public :: nodeCoords type(hfInt32_r2), public :: sideInfo Type-Bound Procedures procedure, public :: Free => Free_Mesh2D procedure, public :: Init => Init_Mesh2D procedure, public :: UniformBlockMesh => UniformBlockMesh_Mesh2D procedure, public :: UpdateDevice => UpdateDevice_Mesh2D procedure, public :: UpdateHost => UpdateHost_Mesh2D type, public :: Mesh3D Components Type Visibility Attributes Name Initial character(len=255), public, ALLOCATABLE :: BCNames (:) type(hfInt32_r2), public :: BCType type(hfInt32_r1), public :: CGNSCornerMap type(hfInt32_r2), public :: CGNSSideMap type(hfInt32_r2), public :: curveNodeMap type(hfInt32_r3), public :: curveNodeMapInv type(hfInt32_r2), public :: elemInfo type(hfReal_r1), public :: globalNodeIDs integer, public :: nBCs integer, public :: nCornerNodes integer, public :: nElem integer, public :: nGeo integer, public :: nNodes integer, public :: nSides integer, public :: nUniqueNodes integer, public :: nUniqueSides type(hfReal_r2), public :: nodeCoords type(hfInt32_r2), public :: sideInfo Type-Bound Procedures procedure, public :: Free => Free_Mesh3D procedure, public :: Init => Init_Mesh3D procedure, public :: UniformBlockMesh => UniformBlockMesh_Mesh3D procedure, public :: UpdateDevice => UpdateDevice_Mesh3D procedure, public :: UpdateHost => UpdateHost_Mesh3D Subroutines public subroutine Free_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh public subroutine Free_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh public subroutine Free_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh public subroutine Init_Mesh1D (myMesh, nGeo, nElem, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nNodes integer, intent(in) :: nBCs public subroutine Init_Mesh2D (myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs public subroutine Init_Mesh3D (myMesh, nGeo, nElem, nSides, nNodes, nBCs) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem integer, intent(in) :: nSides integer, intent(in) :: nNodes integer, intent(in) :: nBCs public subroutine UniformBlockMesh_Mesh1D (myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem real(kind=prec), intent(in) :: x (1:2) public subroutine UniformBlockMesh_Mesh2D (myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem (1:2) real(kind=prec), intent(in) :: x (1:4) public subroutine UniformBlockMesh_Mesh3D (myMesh, nGeo, nElem, x) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(out) :: myMesh integer, intent(in) :: nGeo integer, intent(in) :: nElem (1:3) real(kind=prec), intent(in) :: x (1:6) public subroutine UpdateDevice_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh public subroutine UpdateDevice_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh public subroutine UpdateDevice_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh public subroutine UpdateHost_Mesh1D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh1D ), intent(inout) :: myMesh public subroutine UpdateHost_Mesh2D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh2D ), intent(inout) :: myMesh public subroutine UpdateHost_Mesh3D (myMesh) Arguments Type Intent Optional Attributes Name class( Mesh3D ), intent(inout) :: myMesh","tags":"","loc":"module/self_mesh.html"},{"title":"SELF_Quadrature – SELF","text":"Uses iso_fortran_env SELF_Constants module~~self_quadrature~~UsesGraph module~self_quadrature SELF_Quadrature iso_fortran_env iso_fortran_env module~self_quadrature->iso_fortran_env module~self_constants SELF_Constants module~self_quadrature->module~self_constants module~self_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_quadrature~~UsedByGraph module~self_quadrature SELF_Quadrature module~self_lagrange SELF_Lagrange module~self_lagrange->module~self_quadrature module~self_tests SELF_Tests module~self_tests->module~self_quadrature module~self_tests->module~self_lagrange module~self_mesh SELF_Mesh module~self_tests->module~self_mesh module~self_mappeddata SELF_MappedData module~self_tests->module~self_mappeddata module~self_data SELF_Data module~self_tests->module~self_data module~self_mesh->module~self_lagrange module~self_mesh->module~self_data module~self_geometry SELF_Geometry module~self_geometry->module~self_lagrange module~self_geometry->module~self_mesh module~self_geometry->module~self_data program~self SELF program~self->module~self_tests module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_mesh module~self_mappeddata->module~self_geometry module~self_mappeddata->module~self_data module~self_data->module~self_lagrange module~self_mpilayer SELF_MPILayer module~self_mpilayer->module~self_mesh module~self_mpilayer->module~self_mappeddata module~self_mpilayer->module~self_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines ChebyshevGauss ChebyshevGaussLobatto ChebyshevQuadrature LegendreGauss LegendreGaussLobatto LegendrePolynomial LegendreQandL LegendreQuadrature Subroutines private subroutine ChebyshevGauss (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) private subroutine ChebyshevGaussLobatto (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) public subroutine ChebyshevQuadrature (N, QuadType, nodes, weights) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: QuadType real(kind=real64), intent(out) :: nodes (0:N) real(kind=real64), intent(out) :: weights (0:N) private subroutine LegendreGauss (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) private subroutine LegendreGaussLobatto (N, nodes, weights) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: nodes (0:N) real(kind=real64) :: weights (0:N) public subroutine LegendrePolynomial (N, x, lAtX, dLdxAtX) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: lAtX real(kind=real64) :: dLdxAtX private subroutine LegendreQandL (N, x, q, qprime, lN) Arguments Type Intent Optional Attributes Name integer :: N real(kind=real64) :: x real(kind=real64) :: q real(kind=real64) :: qprime real(kind=real64) :: lN public subroutine LegendreQuadrature (N, nodes, weights, QuadType) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=prec), intent(out) :: nodes (0:N) real(kind=prec), intent(out) :: weights (0:N) integer, intent(in) :: QuadType","tags":"","loc":"module/self_quadrature.html"},{"title":"SELF_SupportRoutines – SELF","text":"\\file SELF_SupportRoutines.f90\n Contains the \\ref SELF_SupportRoutines module\n \\defgroup SELF_SupportRoutines SELF_SupportRoutines\n This module defines a set of general purpose routines. Uses iso_fortran_env SELF_Constants module~~self_supportroutines~~UsesGraph module~self_supportroutines SELF_SupportRoutines iso_fortran_env iso_fortran_env module~self_supportroutines->iso_fortran_env module~self_constants SELF_Constants module~self_supportroutines->module~self_constants module~self_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_supportroutines~~UsedByGraph module~self_supportroutines SELF_SupportRoutines module~self_lagrange SELF_Lagrange module~self_lagrange->module~self_supportroutines module~self_tests SELF_Tests module~self_tests->module~self_supportroutines module~self_tests->module~self_lagrange module~self_mesh SELF_Mesh module~self_tests->module~self_mesh module~self_mappeddata SELF_MappedData module~self_tests->module~self_mappeddata module~self_data SELF_Data module~self_tests->module~self_data module~self_mesh->module~self_supportroutines module~self_mesh->module~self_lagrange module~self_mesh->module~self_data module~self_geometry SELF_Geometry module~self_geometry->module~self_supportroutines module~self_geometry->module~self_lagrange module~self_geometry->module~self_mesh module~self_geometry->module~self_data program~self SELF program~self->module~self_supportroutines program~self->module~self_tests module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_mesh module~self_mappeddata->module~self_geometry module~self_mappeddata->module~self_data module~self_mpilayer SELF_MPILayer module~self_mpilayer->module~self_mesh module~self_mpilayer->module~self_mappeddata module~self_mpilayer->module~self_data module~self_data->module~self_lagrange Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions AlmostEqual CompareArray Determinant Float2Str FloorCURT FloorSQRT GetMinor Int2Str InvertSpectralOpMatrix Invert_2x2 Invert_3x3 IsInf IsNaN NewUnit TimeStamp UniformPoints UpperCase Subroutines ForwardShift InsertionSort ReverseArray SortAndSum SortArray Functions public function AlmostEqual (a, b) result(AisB) \\addtogroup SELF_SupportRoutines\n @{\n \\fn AlmostEqual\n Compares two floating point numbers and determines if they are equal (to machine precision). Read more… Arguments Type Intent Optional Attributes Name real(kind=real64) :: a real(kind=real64) :: b Return Value logical public function CompareArray (arrayOne, arrayTwo, N) result(arraysMatch) \\addtogroup SELF_SupportRoutines\n @{\n \\fn CompareArray\n Compares to INTEGER arrays and determines if they are identical. Read more… Arguments Type Intent Optional Attributes Name integer :: arrayOne (1:N) integer :: arrayTwo (1:N) integer :: N Return Value logical public recursive function Determinant (A, N) result(D) \\addtogroup SELF_SupportRoutines\n @{\n \\fn Determinant\n A recursive function that calculates the determinant of an \\f$ N\\times N \\f$ matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:N,1:N) integer :: N Return Value real(kind=prec) public function Float2Str (aNumber) result(aString) Arguments Type Intent Optional Attributes Name real(kind=prec) :: aNumber Return Value character(len=12) public function FloorCURT (x) result(curtX) Arguments Type Intent Optional Attributes Name integer :: x Return Value integer public function FloorSQRT (x) result(sqrtX) Arguments Type Intent Optional Attributes Name integer :: x Return Value integer public function GetMinor (A, i, j, N) result(M) \\addtogroup SELF_SupportRoutines\n @{\n \\fn GetMinor\n Returns the submatrix obtained by removing a given row and column of the input matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:N,1:N) integer :: i integer :: j integer :: N Return Value real(kind=prec)\n  (1:N-1,1:N-1) public function Int2Str (aNumber) result(aString) Arguments Type Intent Optional Attributes Name integer :: aNumber Return Value character(len=12) public function InvertSpectralOpMatrix (A, N) result(Ainv) Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (0:N,0:N) integer :: N Return Value real(kind=prec)\n  (0:N,0:N) public function Invert_2x2 (A) result(Ainv) \\addtogroup SELF_SupportRoutines\n @{\n \\fn Invert_2x2\n  Computes the inverse of a 2x2 matrix using Kramer's rule. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:2,1:2) Return Value real(kind=prec)\n  (1:2,1:2) public function Invert_3x3 (A) result(Ainv) \\addtogroup SELF_SupportRoutines\n @{\n \\fn Invert_3x3\n  Computes the inverse of a 3x3 matrix using Kramer's rule. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec) :: A (1:3,1:3) Return Value real(kind=prec)\n  (1:3,1:3) public function IsInf (a) Arguments Type Intent Optional Attributes Name real(kind=prec) :: a Return Value logical public function IsNaN (a) Arguments Type Intent Optional Attributes Name real(kind=prec) :: a Return Value logical public function NewUnit (thisunit) \\addtogroup SELF_SupportRoutines\n @{\n \\fn NewUnit\n Returns a file unit identifier that is currently not in use. Read more… Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: thisunit Return Value integer public function TimeStamp (time, units) result(timeStampString) Arguments Type Intent Optional Attributes Name real(kind=prec) :: time character(len=1) :: units Return Value character(len=13) public function UniformPoints (a, b, firstInd, lastInd) result(xU) \\addtogroup SELF_SupportRoutines\n @{\n \\fn UniformPoints\n Generates a REAL(prec) array of N points evenly spaced between two points. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec) :: a real(kind=prec) :: b integer :: firstInd integer :: lastInd Return Value real(kind=prec)\n  (firstInd:lastInd) public function UpperCase (str) result(Upper) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=LEN(str)) Subroutines public subroutine ForwardShift (myArray, N) \\addtogroup SELF_SupportRoutines\n @{\n \\fn ForwardShift\n Shift an array integers by one index forward, moving the last index to the first. Read more… Arguments Type Intent Optional Attributes Name integer, intent(inout) :: myArray (1:N) integer, intent(in) :: N public subroutine InsertionSort (inArray, outArray, N) \\addtogroup SELF_SupportRoutines\n @{\n \\fn InsertionSort\n Sorts an array of integers from smallest to largest using the insertion-sort algorithm. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: inArray (1:N) integer, intent(out) :: outArray (1:N) integer, intent(in) :: N public subroutine ReverseArray (myArray, low, high) \\addtogroup SELF_SupportRoutines\n @{\n \\fn ReverseArray\n Reverses the order of a REAL(prec) array. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec), intent(inout) :: myArray (low:high) integer, intent(in) :: low integer, intent(in) :: high public subroutine SortAndSum (myArray, low, high, arraysum) \\addtogroup SELF_SupportRoutines\n @{\n \\fn SortAndSum\n Computes the sum of an array by first sorting the array from smallest absolute value to largest\n absolute value. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec), intent(inout) :: myArray (low:high) integer, intent(in) :: low integer, intent(in) :: high real(kind=prec), intent(out) :: arraysum public subroutine SortArray (myArray, low, high) \\addtogroup SELF_SupportRoutines\n @{\n \\fn SortArray\n Sorts a REAL(prec) array from smallest absolute value to largest absolute value. Read more… Arguments Type Intent Optional Attributes Name real(kind=prec), intent(inout) :: myArray (low:high) integer, intent(in) :: low integer, intent(in) :: high","tags":"","loc":"module/self_supportroutines.html"},{"title":"SELF_Tests – SELF","text":"Uses SELF_Constants SELF_Memory SELF_SupportRoutines SELF_Quadrature SELF_Lagrange SELF_Data SELF_Mesh SELF_MappedData FEQParse module~~self_tests~~UsesGraph module~self_tests SELF_Tests module~self_lagrange SELF_Lagrange module~self_tests->module~self_lagrange module~self_supportroutines SELF_SupportRoutines module~self_tests->module~self_supportroutines module~self_mesh SELF_Mesh module~self_tests->module~self_mesh module~self_quadrature SELF_Quadrature module~self_tests->module~self_quadrature module~self_mappeddata SELF_MappedData module~self_tests->module~self_mappeddata module~self_memory SELF_Memory module~self_tests->module~self_memory module~self_constants SELF_Constants module~self_tests->module~self_constants FEQParse FEQParse module~self_tests->FEQParse module~self_data SELF_Data module~self_tests->module~self_data module~self_lagrange->module~self_supportroutines iso_c_binding iso_c_binding module~self_lagrange->iso_c_binding hipfort_check hipfort_check module~self_lagrange->hipfort_check module~self_lagrange->module~self_quadrature hipfort hipfort module~self_lagrange->hipfort iso_fortran_env iso_fortran_env module~self_lagrange->iso_fortran_env module~self_lagrange->module~self_memory module~self_lagrange->module~self_constants module~self_supportroutines->iso_fortran_env module~self_supportroutines->module~self_constants module~self_mesh->module~self_lagrange module~self_mesh->module~self_supportroutines module~self_mesh->iso_c_binding module~self_mesh->module~self_constants module~self_mesh->module~self_data module~self_quadrature->iso_fortran_env module~self_quadrature->module~self_constants module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_mesh module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry module~self_mappeddata->iso_c_binding module~self_mappeddata->module~self_constants module~self_mappeddata->module~self_data module~self_memory->iso_c_binding module~self_memory->hipfort_check module~self_memory->hipfort module~self_memory->iso_fortran_env module~self_memory->module~self_constants module~self_constants->iso_fortran_env module~self_data->module~self_lagrange module~self_data->iso_c_binding module~self_data->module~self_constants module~self_geometry->module~self_lagrange module~self_geometry->module~self_mesh module~self_geometry->module~self_supportroutines module~self_geometry->module~self_constants module~self_geometry->module~self_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_tests~~UsedByGraph module~self_tests SELF_Tests program~self SELF program~self->module~self_tests Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines BlockMesh1D_Test BlockMesh2D_Test BlockMesh3D_Test ScalarBoundaryInterp1D_Test ScalarBoundaryInterp2D_Test ScalarBoundaryInterp3D_Test ScalarDerivative1D_Test ScalarGradient2D_Test ScalarGradient3D_Test ScalarInterp1D_Test ScalarInterp2D_Test ScalarInterp3D_Test TensorBoundaryInterp2D_Test TensorBoundaryInterp3D_Test TensorInterp2D_Test TensorInterp3D_Test VectorBoundaryInterp2D_Test VectorBoundaryInterp3D_Test VectorDivergence2D_Test VectorDivergence3D_Test VectorGradient2D_Test VectorGradient3D_Test VectorInterp2D_Test VectorInterp3D_Test Subroutines public subroutine BlockMesh1D_Test (cqType, tqType, cqDegree, tqDegree, nElem, tolerance, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem real(kind=prec), intent(in) :: tolerance integer, intent(out) :: error public subroutine BlockMesh2D_Test (cqType, tqType, cqDegree, tqDegree, nElem, tolerance, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem real(kind=prec), intent(in) :: tolerance integer, intent(out) :: error public subroutine BlockMesh3D_Test (cqType, tqType, cqDegree, tqDegree, nElem, tolerance, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem real(kind=prec), intent(in) :: tolerance integer, intent(out) :: error public subroutine ScalarBoundaryInterp1D_Test (cqType, tqType, cqDegree, tqDegree, nElem, nVar, functionChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: functionChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine ScalarBoundaryInterp2D_Test (cqType, tqType, cqDegree, tqDegree, nElem, nVar, functionChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: functionChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine ScalarBoundaryInterp3D_Test (cqType, tqType, cqDegree, tqDegree, nElem, nVar, functionChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: functionChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine ScalarDerivative1D_Test (cqType, tqType, cqDegree, tqDegree, dForm, nElem, nVar, fChar, dfChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: dForm integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: fChar character(len=*), intent(in) :: dfChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine ScalarGradient2D_Test (cqType, tqType, cqDegree, tqDegree, dForm, nElem, nVar, fChar, gradientChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: dForm integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: fChar character(len=240), intent(in) :: gradientChar (1:2) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine ScalarGradient3D_Test (cqType, tqType, cqDegree, tqDegree, dForm, nElem, nVar, fChar, gradientChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: dForm integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: fChar character(len=240), intent(in) :: gradientChar (1:3) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine ScalarInterp1D_Test (cqType, tqType, cqDegree, tqDegree, nElem, nVar, functionChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: functionChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine ScalarInterp2D_Test (cqType, tqType, cqDegree, tqDegree, nElem, nVar, functionChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: functionChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine ScalarInterp3D_Test (cqType, tqType, cqDegree, tqDegree, nElem, nVar, functionChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=*), intent(in) :: functionChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine TensorBoundaryInterp2D_Test (cqType, tqType, cqDegree, tqDegree, nElem, nVar, tensorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: tensorChar (1:2,1:2) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine TensorBoundaryInterp3D_Test (cqType, tqType, cqDegree, tqDegree, nElem, nVar, tensorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: tensorChar (1:3,1:3) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine TensorInterp2D_Test (cqType, tqType, cqDegree, tqDegree, nElem, nVar, tensorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: tensorChar (1:2,1:2) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine TensorInterp3D_Test (cqType, tqType, cqDegree, tqDegree, nElem, nVar, tensorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: tensorChar (1:3,1:3) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine VectorBoundaryInterp2D_Test (cqType, tqType, cqDegree, tqDegree, nElem, nVar, vectorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:2) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine VectorBoundaryInterp3D_Test (cqType, tqType, cqDegree, tqDegree, nElem, nVar, vectorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:3) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine VectorDivergence2D_Test (cqType, tqType, cqDegree, tqDegree, dForm, nElem, nVar, vectorChar, scalarChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: dForm integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:2) character(len=240), intent(in) :: scalarChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine VectorDivergence3D_Test (cqType, tqType, cqDegree, tqDegree, dForm, nElem, nVar, vectorChar, scalarChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: dForm integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:3) character(len=240), intent(in) :: scalarChar real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine VectorGradient2D_Test (cqType, tqType, cqDegree, tqDegree, dForm, nElem, nVar, vectorChar, tensorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: dForm integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:2) character(len=240), intent(in) :: tensorChar (1:2,1:2) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine VectorGradient3D_Test (cqType, tqType, cqDegree, tqDegree, dForm, nElem, nVar, vectorChar, tensorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: dForm integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:3) character(len=240), intent(in) :: tensorChar (1:3,1:3) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine VectorInterp2D_Test (cqType, tqType, cqDegree, tqDegree, nElem, nVar, vectorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:2) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error public subroutine VectorInterp3D_Test (cqType, tqType, cqDegree, tqDegree, nElem, nVar, vectorChar, tolerance, gpuAccel, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: cqType integer, intent(in) :: tqType integer, intent(in) :: cqDegree integer, intent(in) :: tqDegree integer, intent(in) :: nElem integer, intent(in) :: nVar character(len=240), intent(in) :: vectorChar (1:3) real(kind=prec), intent(in) :: tolerance logical, intent(in) :: gpuAccel integer, intent(out) :: error","tags":"","loc":"module/self_tests.html"},{"title":"SELF_Memory – SELF","text":"Uses SELF_Constants hipfort hipfort_check iso_fortran_env iso_c_binding module~~self_memory~~UsesGraph module~self_memory SELF_Memory iso_c_binding iso_c_binding module~self_memory->iso_c_binding hipfort_check hipfort_check module~self_memory->hipfort_check hipfort hipfort module~self_memory->hipfort iso_fortran_env iso_fortran_env module~self_memory->iso_fortran_env module~self_constants SELF_Constants module~self_memory->module~self_constants module~self_constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~self_memory~~UsedByGraph module~self_memory SELF_Memory module~self_lagrange SELF_Lagrange module~self_lagrange->module~self_memory module~self_tests SELF_Tests module~self_tests->module~self_memory module~self_tests->module~self_lagrange module~self_mesh SELF_Mesh module~self_tests->module~self_mesh module~self_mappeddata SELF_MappedData module~self_tests->module~self_mappeddata module~self_data SELF_Data module~self_tests->module~self_data module~self_mesh->module~self_lagrange module~self_mesh->module~self_data module~self_geometry SELF_Geometry module~self_geometry->module~self_lagrange module~self_geometry->module~self_mesh module~self_geometry->module~self_data program~self SELF program~self->module~self_tests module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_mesh module~self_mappeddata->module~self_geometry module~self_mappeddata->module~self_data module~self_data->module~self_lagrange module~self_mpilayer SELF_MPILayer module~self_mpilayer->module~self_mesh module~self_mpilayer->module~self_mappeddata module~self_mpilayer->module~self_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Derived Types hfInt32_r1 hfInt32_r2 hfInt32_r3 hfInt32_r4 hfInt32_r5 hfInt32_r6 hfInt32_r7 hfInt64_r1 hfInt64_r2 hfInt64_r3 hfInt64_r4 hfInt64_r5 hfInt64_r6 hfInt64_r7 hfReal_r1 hfReal_r2 hfReal_r3 hfReal_r4 hfReal_r5 hfReal_r6 hfReal_r7 Subroutines Alloc_hfInt32_r1 Alloc_hfInt32_r2 Alloc_hfInt32_r3 Alloc_hfInt32_r4 Alloc_hfInt32_r5 Alloc_hfInt32_r6 Alloc_hfInt32_r7 Alloc_hfInt64_r1 Alloc_hfInt64_r2 Alloc_hfInt64_r3 Alloc_hfInt64_r4 Alloc_hfInt64_r5 Alloc_hfInt64_r6 Alloc_hfInt64_r7 Alloc_hfReal_r1 Alloc_hfReal_r2 Alloc_hfReal_r3 Alloc_hfReal_r4 Alloc_hfReal_r5 Alloc_hfReal_r6 Alloc_hfReal_r7 Free_hfInt32_r1 Free_hfInt32_r2 Free_hfInt32_r3 Free_hfInt32_r4 Free_hfInt32_r5 Free_hfInt32_r6 Free_hfInt32_r7 Free_hfInt64_r1 Free_hfInt64_r2 Free_hfInt64_r3 Free_hfInt64_r4 Free_hfInt64_r5 Free_hfInt64_r6 Free_hfInt64_r7 Free_hfReal_r1 Free_hfReal_r2 Free_hfReal_r3 Free_hfReal_r4 Free_hfReal_r5 Free_hfReal_r6 Free_hfReal_r7 UpdateDevice_hfInt32_r1 UpdateDevice_hfInt32_r2 UpdateDevice_hfInt32_r3 UpdateDevice_hfInt32_r4 UpdateDevice_hfInt32_r5 UpdateDevice_hfInt32_r6 UpdateDevice_hfInt32_r7 UpdateDevice_hfInt64_r1 UpdateDevice_hfInt64_r2 UpdateDevice_hfInt64_r3 UpdateDevice_hfInt64_r4 UpdateDevice_hfInt64_r5 UpdateDevice_hfInt64_r6 UpdateDevice_hfInt64_r7 UpdateDevice_hfReal_r1 UpdateDevice_hfReal_r2 UpdateDevice_hfReal_r3 UpdateDevice_hfReal_r4 UpdateDevice_hfReal_r5 UpdateDevice_hfReal_r6 UpdateDevice_hfReal_r7 UpdateHost_hfInt32_r1 UpdateHost_hfInt32_r2 UpdateHost_hfInt32_r3 UpdateHost_hfInt32_r4 UpdateHost_hfInt32_r5 UpdateHost_hfInt32_r6 UpdateHost_hfInt32_r7 UpdateHost_hfInt64_r1 UpdateHost_hfInt64_r2 UpdateHost_hfInt64_r3 UpdateHost_hfInt64_r4 UpdateHost_hfInt64_r5 UpdateHost_hfInt64_r6 UpdateHost_hfInt64_r7 UpdateHost_hfReal_r1 UpdateHost_hfReal_r2 UpdateHost_hfReal_r3 UpdateHost_hfReal_r4 UpdateHost_hfReal_r5 UpdateHost_hfReal_r6 UpdateHost_hfReal_r7 Derived Types type, public :: hfInt32_r1 Data type for storing one-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r1 procedure, public :: Free => Free_hfInt32_r1 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r1 procedure, public :: UpdateHost => UpdateHost_hfInt32_r1 type, public :: hfInt32_r2 Data type for storing two-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r2 procedure, public :: Free => Free_hfInt32_r2 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r2 procedure, public :: UpdateHost => UpdateHost_hfInt32_r2 type, public :: hfInt32_r3 Data type for storing three-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r3 procedure, public :: Free => Free_hfInt32_r3 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r3 procedure, public :: UpdateHost => UpdateHost_hfInt32_r3 type, public :: hfInt32_r4 Data type for storing four-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r4 procedure, public :: Free => Free_hfInt32_r4 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r4 procedure, public :: UpdateHost => UpdateHost_hfInt32_r4 type, public :: hfInt32_r5 Data type for storing five-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r5 procedure, public :: Free => Free_hfInt32_r5 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r5 procedure, public :: UpdateHost => UpdateHost_hfInt32_r5 type, public :: hfInt32_r6 Data type for storing six-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r6 procedure, public :: Free => Free_hfInt32_r6 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r6 procedure, public :: UpdateHost => UpdateHost_hfInt32_r6 type, public :: hfInt32_r7 Data type for storing seven-dimensional int32 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int32), public, POINTER :: hostData (:,:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt32_r7 procedure, public :: Free => Free_hfInt32_r7 procedure, public :: UpdateDevice => UpdateDevice_hfInt32_r7 procedure, public :: UpdateHost => UpdateHost_hfInt32_r7 type, public :: hfInt64_r1 Data type for storing one-dimensional int64 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r1 procedure, public :: Free => Free_hfInt64_r1 procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r1 procedure, public :: UpdateHost => UpdateHost_hfInt64_r1 type, public :: hfInt64_r2 Data type for storing two-dimensional int64 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r2 procedure, public :: Free => Free_hfInt64_r2 procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r2 procedure, public :: UpdateHost => UpdateHost_hfInt64_r2 type, public :: hfInt64_r3 Data type for storing three-dimensional int64 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r3 procedure, public :: Free => Free_hfInt64_r3 procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r3 procedure, public :: UpdateHost => UpdateHost_hfInt64_r3 type, public :: hfInt64_r4 Data type for storing four-dimensional int64 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r4 procedure, public :: Free => Free_hfInt64_r4 procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r4 procedure, public :: UpdateHost => UpdateHost_hfInt64_r4 type, public :: hfInt64_r5 Data type for storing five-dimensional int64 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r5 procedure, public :: Free => Free_hfInt64_r5 procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r5 procedure, public :: UpdateHost => UpdateHost_hfInt64_r5 type, public :: hfInt64_r6 Data type for storing six-dimensional int64 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r6 procedure, public :: Free => Free_hfInt64_r6 procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r6 procedure, public :: UpdateHost => UpdateHost_hfInt64_r6 type, public :: hfInt64_r7 Data type for storing seven-dimensional int64 arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData integer(kind=int64), public, POINTER :: hostData (:,:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfInt64_r7 procedure, public :: Free => Free_hfInt64_r7 procedure, public :: UpdateDevice => UpdateDevice_hfInt64_r7 procedure, public :: UpdateHost => UpdateHost_hfInt64_r7 type, public :: hfReal_r1 Data type for storing one-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r1 procedure, public :: Free => Free_hfReal_r1 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r1 procedure, public :: UpdateHost => UpdateHost_hfReal_r1 type, public :: hfReal_r2 Data type for storing two-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r2 procedure, public :: Free => Free_hfReal_r2 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r2 procedure, public :: UpdateHost => UpdateHost_hfReal_r2 type, public :: hfReal_r3 Data type for storing three-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r3 procedure, public :: Free => Free_hfReal_r3 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r3 procedure, public :: UpdateHost => UpdateHost_hfReal_r3 type, public :: hfReal_r4 Data type for storing four-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r4 procedure, public :: Free => Free_hfReal_r4 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r4 procedure, public :: UpdateHost => UpdateHost_hfReal_r4 type, public :: hfReal_r5 Data type for storing five-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r5 procedure, public :: Free => Free_hfReal_r5 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r5 procedure, public :: UpdateHost => UpdateHost_hfReal_r5 type, public :: hfReal_r6 Data type for storing one-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r6 procedure, public :: Free => Free_hfReal_r6 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r6 procedure, public :: UpdateHost => UpdateHost_hfReal_r6 type, public :: hfReal_r7 Data type for storing seven-dimensional real arrays on the host and the device Components Type Visibility Attributes Name Initial type(c_ptr), public :: deviceData real(kind=prec), public, POINTER :: hostData (:,:,:,:,:,:,:) Type-Bound Procedures procedure, public :: Alloc => Alloc_hfReal_r7 procedure, public :: Free => Free_hfReal_r7 procedure, public :: UpdateDevice => UpdateDevice_hfReal_r7 procedure, public :: UpdateHost => UpdateHost_hfReal_r7 Subroutines public subroutine Alloc_hfInt32_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound public subroutine Alloc_hfInt32_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) public subroutine Alloc_hfInt32_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) public subroutine Alloc_hfInt32_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) public subroutine Alloc_hfInt32_r5 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) public subroutine Alloc_hfInt32_r6 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) public subroutine Alloc_hfInt32_r7 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) public subroutine Alloc_hfInt64_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound public subroutine Alloc_hfInt64_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) public subroutine Alloc_hfInt64_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) public subroutine Alloc_hfInt64_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) public subroutine Alloc_hfInt64_r5 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) public subroutine Alloc_hfInt64_r6 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) public subroutine Alloc_hfInt64_r7 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) public subroutine Alloc_hfReal_r1 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(out) :: this integer, intent(in) :: loBound integer, intent(in) :: upBound public subroutine Alloc_hfReal_r2 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(out) :: this integer, intent(in) :: loBound (1:2) integer, intent(in) :: upBound (1:2) public subroutine Alloc_hfReal_r3 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(out) :: this integer, intent(in) :: loBound (1:3) integer, intent(in) :: upBound (1:3) public subroutine Alloc_hfReal_r4 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(out) :: this integer, intent(in) :: loBound (1:4) integer, intent(in) :: upBound (1:4) public subroutine Alloc_hfReal_r5 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(out) :: this integer, intent(in) :: loBound (1:5) integer, intent(in) :: upBound (1:5) public subroutine Alloc_hfReal_r6 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(out) :: this integer, intent(in) :: loBound (1:6) integer, intent(in) :: upBound (1:6) public subroutine Alloc_hfReal_r7 (this, loBound, upBound) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(out) :: this integer, intent(in) :: loBound (1:7) integer, intent(in) :: upBound (1:7) public subroutine Free_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this public subroutine Free_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this public subroutine Free_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this public subroutine Free_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this public subroutine Free_hfInt32_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this public subroutine Free_hfInt32_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this public subroutine Free_hfInt32_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this public subroutine Free_hfInt64_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this public subroutine Free_hfInt64_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this public subroutine Free_hfInt64_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this public subroutine Free_hfInt64_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this public subroutine Free_hfInt64_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this public subroutine Free_hfInt64_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this public subroutine Free_hfInt64_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this public subroutine Free_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this public subroutine Free_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this public subroutine Free_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this public subroutine Free_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this public subroutine Free_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this public subroutine Free_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this public subroutine Free_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this public subroutine UpdateDevice_hfInt32_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this public subroutine UpdateDevice_hfInt64_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this public subroutine UpdateDevice_hfInt64_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this public subroutine UpdateDevice_hfInt64_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this public subroutine UpdateDevice_hfInt64_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this public subroutine UpdateDevice_hfInt64_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this public subroutine UpdateDevice_hfInt64_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this public subroutine UpdateDevice_hfInt64_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this public subroutine UpdateDevice_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r1 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r2 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r3 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r4 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r5 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r6 ), intent(inout) :: this public subroutine UpdateHost_hfInt32_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt32_r7 ), intent(inout) :: this public subroutine UpdateHost_hfInt64_r1 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r1 ), intent(inout) :: this public subroutine UpdateHost_hfInt64_r2 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r2 ), intent(inout) :: this public subroutine UpdateHost_hfInt64_r3 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r3 ), intent(inout) :: this public subroutine UpdateHost_hfInt64_r4 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r4 ), intent(inout) :: this public subroutine UpdateHost_hfInt64_r5 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r5 ), intent(inout) :: this public subroutine UpdateHost_hfInt64_r6 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r6 ), intent(inout) :: this public subroutine UpdateHost_hfInt64_r7 (this) Arguments Type Intent Optional Attributes Name class( hfInt64_r7 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r1 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r1 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r2 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r2 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r3 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r3 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r4 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r4 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r5 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r5 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r6 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r6 ), intent(inout) :: this public subroutine UpdateHost_hfReal_r7 (this) Arguments Type Intent Optional Attributes Name class( hfReal_r7 ), intent(inout) :: this","tags":"","loc":"module/self_memory.html"},{"title":"SELF – SELF","text":"Uses SELF_Constants SELF_SupportRoutines SELF_Tests FLAP program~~self~~UsesGraph program~self SELF FLAP FLAP program~self->FLAP module~self_tests SELF_Tests program~self->module~self_tests module~self_supportroutines SELF_SupportRoutines program~self->module~self_supportroutines module~self_constants SELF_Constants program~self->module~self_constants module~self_lagrange SELF_Lagrange module~self_tests->module~self_lagrange module~self_tests->module~self_supportroutines module~self_mesh SELF_Mesh module~self_tests->module~self_mesh module~self_quadrature SELF_Quadrature module~self_tests->module~self_quadrature module~self_mappeddata SELF_MappedData module~self_tests->module~self_mappeddata module~self_memory SELF_Memory module~self_tests->module~self_memory module~self_tests->module~self_constants FEQParse FEQParse module~self_tests->FEQParse module~self_data SELF_Data module~self_tests->module~self_data iso_fortran_env iso_fortran_env module~self_supportroutines->iso_fortran_env module~self_supportroutines->module~self_constants module~self_constants->iso_fortran_env module~self_lagrange->module~self_supportroutines iso_c_binding iso_c_binding module~self_lagrange->iso_c_binding hipfort_check hipfort_check module~self_lagrange->hipfort_check module~self_lagrange->module~self_quadrature hipfort hipfort module~self_lagrange->hipfort module~self_lagrange->iso_fortran_env module~self_lagrange->module~self_memory module~self_lagrange->module~self_constants module~self_mesh->module~self_lagrange module~self_mesh->module~self_supportroutines module~self_mesh->iso_c_binding module~self_mesh->module~self_constants module~self_mesh->module~self_data module~self_quadrature->iso_fortran_env module~self_quadrature->module~self_constants module~self_mappeddata->module~self_lagrange module~self_mappeddata->module~self_mesh module~self_geometry SELF_Geometry module~self_mappeddata->module~self_geometry module~self_mappeddata->iso_c_binding module~self_mappeddata->module~self_constants module~self_mappeddata->module~self_data module~self_memory->iso_c_binding module~self_memory->hipfort_check module~self_memory->hipfort module~self_memory->iso_fortran_env module~self_memory->module~self_constants module~self_data->module~self_lagrange module~self_data->iso_c_binding module~self_data->module~self_constants module~self_geometry->module~self_lagrange module~self_geometry->module~self_mesh module~self_geometry->module~self_supportroutines module~self_geometry->module~self_constants module~self_geometry->module~self_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~self~~CallsGraph program~self SELF proc~scalarboundaryinterp1d_test ScalarBoundaryInterp1D_Test program~self->proc~scalarboundaryinterp1d_test proc~vectorgradient3d_test VectorGradient3D_Test program~self->proc~vectorgradient3d_test proc~vectorinterp3d_test VectorInterp3D_Test program~self->proc~vectorinterp3d_test proc~scalarinterp1d_test ScalarInterp1D_Test program~self->proc~scalarinterp1d_test proc~scalarinterp2d_test ScalarInterp2D_Test program~self->proc~scalarinterp2d_test proc~scalarboundaryinterp2d_test ScalarBoundaryInterp2D_Test program~self->proc~scalarboundaryinterp2d_test proc~tensorinterp3d_test TensorInterp3D_Test program~self->proc~tensorinterp3d_test proc~vectorboundaryinterp3d_test VectorBoundaryInterp3D_Test program~self->proc~vectorboundaryinterp3d_test proc~parse_cli Parse_CLI program~self->proc~parse_cli proc~vectordivergence3d_test VectorDivergence3D_Test program~self->proc~vectordivergence3d_test proc~blockmesh3d_test BlockMesh3D_Test program~self->proc~blockmesh3d_test proc~scalarderivative1d_test ScalarDerivative1D_Test program~self->proc~scalarderivative1d_test proc~scalargradient3d_test ScalarGradient3D_Test program~self->proc~scalargradient3d_test proc~scalarinterp3d_test ScalarInterp3D_Test program~self->proc~scalarinterp3d_test proc~tensorboundaryinterp3d_test TensorBoundaryInterp3D_Test program~self->proc~tensorboundaryinterp3d_test proc~blockmesh1d_test BlockMesh1D_Test program~self->proc~blockmesh1d_test proc~uppercase UpperCase program~self->proc~uppercase proc~scalarboundaryinterp3d_test ScalarBoundaryInterp3D_Test program~self->proc~scalarboundaryinterp3d_test proc~blockmesh2d_test BlockMesh2D_Test program~self->proc~blockmesh2d_test proc~int2str Int2Str proc~scalarboundaryinterp1d_test->proc~int2str equationparser equationparser proc~scalarboundaryinterp1d_test->equationparser proc~float2str Float2Str proc~scalarboundaryinterp1d_test->proc~float2str info info proc~scalarboundaryinterp1d_test->info proc~vectorgradient3d_test->proc~int2str proc~vectorgradient3d_test->info proc~vectorgradient3d_test->equationparser proc~vectorgradient3d_test->proc~float2str proc~vectorinterp3d_test->proc~int2str proc~vectorinterp3d_test->equationparser proc~vectorinterp3d_test->proc~float2str proc~vectorinterp3d_test->info proc~scalarinterp1d_test->proc~int2str proc~scalarinterp1d_test->equationparser proc~scalarinterp1d_test->proc~float2str proc~scalarinterp1d_test->info proc~scalarinterp2d_test->proc~int2str proc~scalarinterp2d_test->equationparser proc~scalarinterp2d_test->proc~float2str proc~scalarinterp2d_test->info proc~scalarboundaryinterp2d_test->proc~int2str proc~scalarboundaryinterp2d_test->equationparser proc~scalarboundaryinterp2d_test->proc~float2str proc~scalarboundaryinterp2d_test->info proc~vectorboundaryinterp3d_test->proc~int2str proc~vectorboundaryinterp3d_test->equationparser proc~vectorboundaryinterp3d_test->proc~float2str proc~vectorboundaryinterp3d_test->info proc~vectordivergence3d_test->proc~int2str proc~vectordivergence3d_test->info proc~vectordivergence3d_test->equationparser proc~vectordivergence3d_test->proc~float2str proc~blockmesh3d_test->proc~int2str proc~blockmesh3d_test->proc~float2str proc~blockmesh3d_test->info proc~scalarderivative1d_test->proc~int2str proc~scalarderivative1d_test->info proc~scalarderivative1d_test->equationparser proc~scalarderivative1d_test->proc~float2str proc~scalargradient3d_test->proc~int2str proc~scalargradient3d_test->info proc~scalargradient3d_test->equationparser proc~scalargradient3d_test->proc~float2str proc~scalarinterp3d_test->proc~int2str proc~scalarinterp3d_test->equationparser proc~scalarinterp3d_test->proc~float2str proc~scalarinterp3d_test->info proc~tensorboundaryinterp3d_test->proc~int2str proc~tensorboundaryinterp3d_test->equationparser proc~tensorboundaryinterp3d_test->proc~float2str proc~tensorboundaryinterp3d_test->info proc~blockmesh1d_test->proc~int2str proc~blockmesh1d_test->info proc~blockmesh1d_test->proc~float2str proc~tensorinterp3d_test->proc~int2str proc~tensorinterp3d_test->equationparser proc~tensorinterp3d_test->proc~float2str proc~tensorinterp3d_test->info proc~scalarboundaryinterp3d_test->proc~int2str proc~scalarboundaryinterp3d_test->equationparser proc~scalarboundaryinterp3d_test->proc~float2str proc~scalarboundaryinterp3d_test->info proc~blockmesh2d_test->proc~int2str proc~blockmesh2d_test->info proc~blockmesh2d_test->proc~float2str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cqDegree cqType cqTypeChar dForm dFormChar derivativeChar error errorCount errorTolerance functionChar gpuAccel gpuAccelChar nElem nVar self_cli tensorChar tqDegree tqType tqTypeChar vectorChar Subroutines Parse_CLI Source Code SELF Variables Type Attributes Name Initial integer :: cqDegree integer :: cqType character(len=20) :: cqTypeChar integer :: dForm character(len=10) :: dFormChar character(len=240) :: derivativeChar integer :: error integer :: errorCount real(kind=prec) :: errorTolerance character(len=240) :: functionChar logical :: gpuAccel character(len=5) :: gpuAccelChar integer :: nElem integer :: nVar type(COMMAND_LINE_INTERFACE) :: self_cli character(len=240) :: tensorChar (1:3,1:3) integer :: tqDegree integer :: tqType character(len=20) :: tqTypeChar character(len=240) :: vectorChar (1:3) Subroutines subroutine Parse_CLI (cli) Arguments Type Intent Optional Attributes Name type(COMMAND_LINE_INTERFACE), intent(out) :: cli Source Code PROGRAM SELF USE SELF_Constants USE SELF_SupportRoutines USE SELF_Tests USE FLAP IMPLICIT NONE TYPE ( COMMAND_LINE_INTERFACE ) :: self_cli CHARACTER ( 20 ) :: cqTypeChar CHARACTER ( 20 ) :: tqTypeChar CHARACTER ( 240 ) :: functionChar CHARACTER ( 240 ) :: derivativeChar CHARACTER ( 240 ) :: vectorChar ( 1 : 3 ) CHARACTER ( 240 ) :: tensorChar ( 1 : 3 , 1 : 3 ) CHARACTER ( 10 ) :: dFormChar CHARACTER ( 5 ) :: gpuAccelChar REAL ( prec ) :: errorTolerance INTEGER :: dForm INTEGER :: cqType INTEGER :: tqType INTEGER :: cqDegree INTEGER :: tqDegree INTEGER :: nElem INTEGER :: nVar INTEGER :: error INTEGER :: errorCount LOGICAL :: gpuAccel CALL Parse_CLI ( self_cli ) CALL self_cli % get ( val = cqTypeChar , switch = '--control-quadrature' ) CALL self_cli % get ( val = tqTypeChar , switch = '--target-quadrature' ) CALL self_cli % get ( val = cqDegree , switch = '--control-degree' ) CALL self_cli % get ( val = tqDegree , switch = '--target-degree' ) CALL self_cli % get ( val = nElem , switch = '--nelements' ) CALL self_cli % get ( val = nVar , switch = '--nvar' ) CALL self_cli % get ( val = functionChar , switch = '--function' ) CALL self_cli % get ( val = dFormChar , switch = '--derivative-type' ) CALL self_cli % get ( val = derivativeChar , switch = '--derivative' ) CALL self_cli % get ( val = gpuAccelChar , switch = '--gpu-accel' ) CALL self_cli % get ( val = vectorChar ( 1 ), switch = '--vector-x' ) CALL self_cli % get ( val = vectorChar ( 2 ), switch = '--vector-y' ) CALL self_cli % get ( val = vectorChar ( 3 ), switch = '--vector-z' ) CALL self_cli % get ( val = tensorChar ( 1 , 1 ), switch = '--tensor-11' ) CALL self_cli % get ( val = tensorChar ( 1 , 2 ), switch = '--tensor-12' ) CALL self_cli % get ( val = tensorChar ( 1 , 3 ), switch = '--tensor-13' ) CALL self_cli % get ( val = tensorChar ( 2 , 1 ), switch = '--tensor-21' ) CALL self_cli % get ( val = tensorChar ( 2 , 2 ), switch = '--tensor-22' ) CALL self_cli % get ( val = tensorChar ( 2 , 3 ), switch = '--tensor-23' ) CALL self_cli % get ( val = tensorChar ( 3 , 1 ), switch = '--tensor-31' ) CALL self_cli % get ( val = tensorChar ( 3 , 2 ), switch = '--tensor-32' ) CALL self_cli % get ( val = tensorChar ( 3 , 3 ), switch = '--tensor-33' ) CALL self_cli % get ( val = errorTolerance , switch = '--tolerance' ) IF ( TRIM ( UpperCase ( cqTypeChar )) == 'GAUSS' ) THEN cqType = GAUSS ELSEIF ( TRIM ( UpperCase ( cqTypeChar )) == 'GAUSS-LOBATTO' ) THEN cqType = GAUSS_LOBATTO ELSE PRINT * , 'Invalid Control Quadrature' STOP - 1 END IF IF ( TRIM ( UpperCase ( tqTypeChar )) == 'GAUSS' ) THEN tqType = GAUSS ELSEIF ( TRIM ( UpperCase ( tqTypeChar )) == 'GAUSS-LOBATTO' ) THEN tqType = GAUSS_LOBATTO ELSE PRINT * , 'Invalid Target Quadrature' STOP - 1 END IF IF ( TRIM ( UpperCase ( dFormChar )) == 'STRONG' ) THEN dForm = selfStrongForm ELSEIF ( TRIM ( UpperCase ( dFormChar )) == 'DG' ) THEN dForm = selfWeakDGForm ELSEIF ( TRIM ( UpperCase ( dFormChar )) == 'CG' ) THEN dForm = selfWeakCGForm ENDIF IF ( TRIM ( UpperCase ( gpuAccelChar )) == 'TRUE' ) THEN gpuAccel = . TRUE . ELSE gpuAccel = . FALSE . END IF errorCount = 0 IF ( self_cli % run_command ( group = \"ci-test\" )) THEN CALL BlockMesh1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , errorTolerance , error ) errorCount = errorCount + error CALL BlockMesh2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , errorTolerance , error ) errorCount = errorCount + error CALL BlockMesh3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , errorTolerance , error ) errorCount = errorCount + error CALL ScalarInterp1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar ( 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL TensorInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar ( 1 : 2 , 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL TensorInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarBoundaryInterp1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar ( 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL TensorBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar ( 1 : 2 , 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL TensorBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarDerivative1D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& functionChar , derivativeChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarGradient2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& functionChar , vectorChar ( 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL ScalarGradient3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& functionChar , vectorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorGradient2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& vectorChar ( 1 : 2 ), tensorChar ( 1 : 2 , 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorDivergence2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& vectorChar ( 1 : 2 ), functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorGradient3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& vectorChar , tensorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error CALL VectorDivergence3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& vectorChar , functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"blockmesh_1d\" )) THEN CALL BlockMesh1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , errorTolerance , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"blockmesh_2d\" )) THEN CALL BlockMesh2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , errorTolerance , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"blockmesh_3d\" )) THEN CALL BlockMesh3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , errorTolerance , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s1d_interp\" )) THEN CALL ScalarInterp1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s2d_interp\" )) THEN CALL ScalarInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s3d_interp\" )) THEN CALL ScalarInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v2d_interp\" )) THEN CALL VectorInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar ( 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"t2d_interp\" )) THEN CALL TensorInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar ( 1 : 2 , 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v3d_interp\" )) THEN CALL VectorInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"t3d_interp\" )) THEN CALL TensorInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s1d_binterp\" )) THEN CALL ScalarBoundaryInterp1D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s2d_binterp\" )) THEN CALL ScalarBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s3d_binterp\" )) THEN CALL ScalarBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v2d_binterp\" )) THEN CALL VectorBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar ( 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"t2d_binterp\" )) THEN CALL TensorBoundaryInterp2D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar ( 1 : 2 , 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v3d_binterp\" )) THEN CALL VectorBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& vectorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"t3d_binterp\" )) THEN CALL TensorBoundaryInterp3D_Test ( cqType , tqType , cqDegree , tqDegree , nElem , nVar ,& tensorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s1d_derivative\" )) THEN CALL ScalarDerivative1D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& functionChar , derivativeChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s2d_gradient\" )) THEN CALL ScalarGradient2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& functionChar , vectorChar ( 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"s3d_gradient\" )) THEN CALL ScalarGradient3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& functionChar , vectorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v2d_gradient\" )) THEN CALL VectorGradient2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& vectorChar ( 1 : 2 ), tensorChar ( 1 : 2 , 1 : 2 ), errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v2d_divergence\" )) THEN CALL VectorDivergence2D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& vectorChar ( 1 : 2 ), functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v3d_gradient\" )) THEN CALL VectorGradient3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar , vectorChar , tensorChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error ELSEIF ( self_cli % run_command ( group = \"v3d_divergence\" )) THEN CALL VectorDivergence3D_Test ( cqType , tqType , cqDegree , tqDegree , dForm , nElem , nVar ,& vectorChar , functionChar , errorTolerance , gpuAccel , error ) errorCount = errorCount + error END IF CALL self_cli % free () IF ( errorCount > 0 ) THEN STOP errorCount ENDIF CONTAINS SUBROUTINE Parse_CLI ( cli ) IMPLICIT NONE TYPE ( COMMAND_LINE_INTERFACE ), INTENT ( out ) :: cli CALL cli % init ( progname = \"self\" , & version = \"v0.0.0\" , & description = \"Spectral Element Libraries in Fortran (SELF)\" , & license = \"ANTI-CAPITALIST SOFTWARE LICENSE (v 1.4)\" , & authors = \"Joseph Schoonover (Fluid Numerics LLC)\" ) CALL cli % add ( switch = \"--control-degree\" , & switch_ab = \"-c\" , & help = \"The polynomial degree of the control points.\" // NEW_LINE ( \"A\" ), & def = \"2\" , & required = . FALSE .) CALL cli % add ( switch = \"--target-degree\" , & switch_ab = \"-t\" , & help = \"The polynomial degree for the target points for interpolation.\" // NEW_LINE ( \"A\" ), & def = \"7\" , & required = . FALSE .) CALL cli % add ( switch = \"--control-quadrature\" , & switch_ab = \"-cq\" , & def = \"gauss\" , & help = \"The quadrature type for control points.\" // NEW_LINE ( \"A\" ), & choices = \"gauss, gauss-lobatto, uniform\" , & required = . FALSE .) CALL cli % add ( switch = \"--target-quadrature\" , & switch_ab = \"-tq\" , & def = \"gauss\" , & help = \"The quadrature type for target points.\" // NEW_LINE ( \"A\" ), & choices = \"gauss, gauss-lobatto, uniform\" , & required = . FALSE .) CALL cli % add ( switch = \"--nvar\" , & switch_ab = \"-nv\" , & help = \"The number of functions used to simulate increased workloads.\" // NEW_LINE ( \"A\" ), & def = \"5\" , & required = . FALSE .) CALL cli % add ( switch = \"--nelements\" , & switch_ab = \"-ne\" , & help = \"The number of elements to use on the test mesh. \" // & \"In multi-dimensions, the number of elements in each direction.\" // NEW_LINE ( \"A\" ), & def = \"10\" , & required = . FALSE .) CALL cli % add ( switch = \"--gpu-accel\" , & switch_ab = \"-gpu\" , & help = \"Boolean flag for enabling or disabling GPU acceleration in tests.\" // NEW_LINE ( \"A\" ), & def = \"false\" , & choices = \"true,false\" , & required = . FALSE .) CALL cli % add ( switch = \"--tolerance\" , & switch_ab = \"-tol\" , & help = \"Tolerance to use for determining if a test passes.\" // NEW_LINE ( \"A\" ), & def = \"1.0E-5\" , & required = . FALSE .) CALL cli % add ( switch = \"--derivative-type\" , & switch_ab = \"-dtype\" , & help = \"Flag to choose the type of derivative operator (weak/strong).\" // NEW_LINE ( \"A\" ), & def = \"strong\" , & choices = \"strong,dg\" , & required = . FALSE .) CALL cli % add ( switch = \"--function\" , & switch_ab = \"-f\" , & help = \"Function to interpolate from control points to target points\" // NEW_LINE ( \"A\" ), & def = \"f=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--derivative\" , & switch_ab = \"-df\" , & help = \"Derivative of the test function; used for estimating errors.\" // NEW_LINE ( \"A\" ), & def = \"df=0.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--vector-x\" , & switch_ab = \"-vx\" , & help = \"x-component of the vector function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"vx=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--vector-y\" , & switch_ab = \"-vy\" , & help = \"y-component of the vector function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"vy=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--vector-z\" , & switch_ab = \"-vz\" , & help = \"z-component of the vector function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"vz=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-11\" , & switch_ab = \"-t11\" , & help = \"Row 1 column 1 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t11=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-12\" , & switch_ab = \"-t12\" , & help = \"Row 1 column 2 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t12=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-13\" , & switch_ab = \"-t13\" , & help = \"Row 1 column 3 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t13=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-21\" , & switch_ab = \"-t21\" , & help = \"Row 2 column 1 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t21=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-22\" , & switch_ab = \"-t22\" , & help = \"Row 2 column 2 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t22=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-23\" , & switch_ab = \"-t23\" , & help = \"Row 2 column 3 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t23=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-31\" , & switch_ab = \"-t31\" , & help = \"Row 3 column 1 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t31=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-32\" , & switch_ab = \"-t32\" , & help = \"Row 3 column 2 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t32=1.0\" , & required = . FALSE .) CALL cli % add ( switch = \"--tensor-33\" , & switch_ab = \"-t33\" , & help = \"Row 2 column 3 of the tensor function to interpolate from control points \" // & \"to target points\" // NEW_LINE ( \"A\" ), & def = \"t33=1.0\" , & required = . FALSE .) CALL cli % add_group ( group = \"ci-test\" , & description = \"Run all CI-Tests\" ) CALL cli % add_group ( group = \"blockmesh_1d\" , & description = \"Block Mesh generation in 1D\" ) CALL cli % add_group ( group = \"blockmesh_2d\" , & description = \"Block Mesh generation in 2D\" ) CALL cli % add_group ( group = \"blockmesh_3d\" , & description = \"Block Mesh generation in 3D\" ) CALL cli % add_group ( group = \"s1d_interp\" , & description = \"Scalar 1D Grid Interpolation\" ) CALL cli % add_group ( group = \"s2d_interp\" , & description = \"Scalar 2D Grid Interpolation\" ) CALL cli % add_group ( group = \"s3d_interp\" , & description = \"Scalar 3D Grid Interpolation\" ) CALL cli % add_group ( group = \"v2d_interp\" , & description = \"Vector 2D Grid Interpolation\" ) CALL cli % add_group ( group = \"v3d_interp\" , & description = \"Vector 3D Grid Interpolation\" ) CALL cli % add_group ( group = \"t2d_interp\" , & description = \"Tensor 2D Grid Interpolation\" ) CALL cli % add_group ( group = \"t3d_interp\" , & description = \"Tensor 3D Grid Interpolation\" ) CALL cli % add_group ( group = \"s1d_binterp\" , & description = \"Scalar 1D Boundary interpolation\" ) CALL cli % add_group ( group = \"s2d_binterp\" , & description = \"Scalar 2D Boundary interpolation\" ) CALL cli % add_group ( group = \"s3d_binterp\" , & description = \"Scalar 3D Boundary interpolation\" ) CALL cli % add_group ( group = \"v2d_binterp\" , & description = \"Vector 2D Boundary interpolation\" ) CALL cli % add_group ( group = \"v3d_binterp\" , & description = \"Vector 3D Boundary interpolation\" ) CALL cli % add_group ( group = \"t2d_binterp\" , & description = \"Tensor 2D Boundary interpolation\" ) CALL cli % add_group ( group = \"t3d_binterp\" , & description = \"Tensor 3D Boundary interpolation\" ) CALL cli % add_group ( group = \"s1d_derivative\" , & description = \"Scalar 1D Derivative\" ) CALL cli % add_group ( group = \"s2d_gradient\" , & description = \"Scalar 2D Gradient\" ) CALL cli % add_group ( group = \"s3d_gradient\" , & description = \"Scalar 3D Gradient\" ) CALL cli % add_group ( group = \"v2d_gradient\" , & description = \"Vector 2D Gradient\" ) CALL cli % add_group ( group = \"v2d_divergence\" , & description = \"Vector 2D Divergence\" ) CALL cli % add_group ( group = \"v2d_curl\" , & description = \"Vector 2D Curl\" ) CALL cli % add_group ( group = \"v3d_gradient\" , & description = \"Vector 3D Gradient\" ) CALL cli % add_group ( group = \"v3d_divergence\" , & description = \"Vector 3D Divergence\" ) CALL cli % add_group ( group = \"v3d_curl\" , & description = \"Vector 3D Curl\" ) CALL cli % parse () END SUBROUTINE Parse_CLI END PROGRAM SELF","tags":"","loc":"program/self.html"}]}